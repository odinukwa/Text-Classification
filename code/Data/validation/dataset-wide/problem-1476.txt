Please separate out your code into at least two classes 1) Fetching data class 2) UI binding stuff class 4)inline SQL vs Stored Procedure Stored Procedure is good as your code lies at one place in db but creating Stored Procedure for one line of SQL is not a good idea. If your logic is going to be complex and big ,Use a Stored procedure other wise inline sql. PS: I have created a gist named SQLHelper class for you to abstract out the sql connection and command things, $URL$ 

As per my interpretation, you don't need empty string check inside the if clause you can put it out side, and last condition could be expressed in one line. 

Your sorting logic is dependent upon the specific type. "Separate your data representation from logic." you must take advantage of the generic to reuse the same component to sort any kind of object. In case of class you can specify comparer to sort the values. Naming convention should be followed. i and j does not make sense and in c# standard method naming convetion should Pascal case , should not start with lowercase. Rest logic looks good. 

A couple of things that I haven't seen others mention. One is that access modifiers are not security. You should want to control who creates your object, not because you don't want someone creating it when they shouldn't, but because they shouldn't HAVE to know how to create your object -- whether the "someone" is a fellow developer, a class that you are writing or even you while working on another class, that knowledge is a burden you don't want them to bear. Secondly, as others have mentioned, the way to do this is to create a nested inner class. What I haven't seen others mention, perhaps thinking it too basic, is how do you let others interact with your inner class -- and the answer is to create an interface. 

To let several objects respond to the same commands. This lets you have a function where one of the parameters can be an object, but it doesn't have to be of a particular type. To allow an object in one assembly, to use an object in another assembly, without having the first assembly rely upon the second. Instead, both rely upon a third assembly, which defines the interface. In this case there MIGHT only be one object that implements the interface. One reason for doing this would be to avoid circular dependencies. 

b. create an interface named as IView and implement it in your view , pass the instance of IView to data context of the view 

As rule has been passed to ArchiveAction class , you dont need to check type inside ArchiveRule class. Move all processing related code to the process method like ZipTempFile ,MoveArchiveToDestinations 

You have multiple options a. Use an event Aggregator where publish the message from the viewmodel and subscribe from view. see prism documentation for event aggregators:here is sample code 

so it all depends upon your use case.In this case table will always have columns so passing a array of column will make sense. 

Server is a part of Message so server initialization is part of message itself. so updated solution: 

Bind method should be used only when if your element is not loaded into DOM on pageload. So you could attach events to it using bind after wards. also if your using jquery >= 1.7 use 'On' method to achive it. but as per your js fiddle you don't need it at all. second you could declare a variable to store the jquery object of follow. Make sure about the variable scope though. 

While Corbin's answer is great (and I'd cetainly recommend accepting it over this), it buries the key point: your method does two things. This makes testing, understanding, and maintaince harder. You are supposed to a) generate a licence number, and b) filter out unacceptable ones. This should properly be split into at least 3 function, 1 to generate, 1 to reject, and 1 that calls the other 2 and only returns the result of the first if not rejected. At that point you should see what needs testing, what can be tested, and how to do your test. As for your final question: you fiddle with the process to make the error both frequent and repeatable. 

You basically repeat the same 7 lines 4 times. And what's worse is that, as written, half the time the full block isn't possible. 

I like icemanind's answer, but to give an alternate point of view -- sometimes you just need to get it done. 

Whether you're solution is over-interfaced or not, depends upon whether the interfaces are used for one of the above reasons -- if not, then you should probably be using the objects directly, instead of using an interface. On a totally unrelated note: you are accessing fields in your datarow by positions. This is a bad idea, as it is fragile -- it's easy to change the position of things and have it appear to continue to work, and only fail on some rare condition. You have properties with declared backing fields, where the backing fields aren't used to do non-standard manipulation. They should be turned into auto properties for smaller code and easier reading. 

by using this you have only a reference of interface will be there in viewmodel . but not the whole view itself 

Here are few comments 1) Try to encapsulate the piece which is subject to change. your code is dependent upon amount which can be withdrawn so rather one by one division you can create a list which will consist of that piece only. 2) Use for loop in case of repeating logic. (See below) 3) Prefer Writing Extension method 

I would write an extension method to do parsing of input string. so it should not be inside your query method. I have declared a class named SearchCriteria to encapsulate all data member you want t o query. 

Just continuation to @Malachi an here is a generic version of ExecuteScalar, so it is good so you dont have to cast it again in code. 

so basically it is your choice : with optional params you cannot enforce user to input the value, so user can leave giving any input and complier will not complain. 

Introduce a DAL helper layer which will be responsible of opening and closing connection and executing commands. There are lots of DAL helper layer is available Write an extension method to get values from the data reader. Here is one dummy code 

The efficiency of a join is primarily based upon covering indexes, not number of columns used. Given your scenario, you basically have the right idea. You don't mention which RDBMS you are using, but you could possibly use the INTERSECT command. 

Abstractions rarely result in optimizations, but that doesn't mean they aren't useful. Whether this a good idea or not depends upon whether you have a large number of tables that can be treated the same, and whether that helps you. In general it's not a good idea not because there are cases where it doessn't do what you want, but because it will add complextity for little gain. If your tables are relatively stable, you could use the same (or very similar) code to autogenerate stored procedures, which you then call directly -- you end up with more code, but it's easier to understand. 

Why is this a static method? While the sql connection string is generally either going to be injected or a dependency, the user name seems likely to be a property of the object. Not a big issue, and in context it could be the right thing. Disposable objects should generally be wrapped in a using block -- unless there is a need for the object to be used after the function is done, which doesn't seem to be the case here. Why are you doing validation in a method called Get...? That should either be done in the database, or after this method. You return an empty string in the case of validation error and null on an exception. You do nothing with your exception handling except return an error -- no logging, no report to the user. You catch an exception at the first point you know what to do to recover from the error -- since this function doesn't do anything with the string it retrieves, how does return null; recover from the error? 

This is overall comments on above code 1) Encapsulate what is repeating In your method you are opening sql connection, adding parameter and executing it one by one. Rather doing this please extract out it into one method. 

Rest code looks okay. just wondering why you just not cache the data for a predefined interval rather that doing this.I am not sure which kind of application you are working on. 

you dont need this whole code in this way , rather create a logger class and put this whole line of code there. Pass only dynamic parameter. Once you are able to cleanup , pattern can be applied easily 

once this is done you can further refactor your if else clause in a strategy pattern , so you will need a factory which will return class will handle the Archive rule or mirror rule inside a different class and your FileActionService will contain only processing logic 

I would write an extension method to check whether the above condition holds true. and I hope eHistoryCurrentMedsGroup is a list of some object so you could use Any(). 

I used nsubstitute and fluent assertion instead of Rhino mocks , It will make your test code more readable here is an example. 

You basically have two values, that have a one to one coorespondences. I would take advantage of that. One value is what you want to return, the other value is the distinct value you get by using your 4 (5?) booleans as a bit pattern. Here's an example of creating the mapping programatically. It is for illustration purposes only, I don't recommend using it -- better to either put the map into a config file or a database. 

I see one thing I would consider a minor quirk: the usage of when the includes a return, exit, break or continue statement. I expect statements to be used when you don't want both branches of the code, not when both branches of the code cannot run. Changing those statements to just bare statements will allow you to seperate them from the prior condition and, IMO, make the code a bit more readable. 

The two options are not really two options as they are not mutually exclusive. You should prefer two for things that are tied closely with foo and need to be checked everytime that foo is done, you should use one where it is not always applicable to foo, but it is under these circumstances. IOW if all code paths include a check for x immediately before calling foo, and foo would break or take an incorrect action if x was incorrect, then put the check in foo, if on the ther hand, it is only checked 4 out of 5 times, then obviously it doesn't belong in foo. An additional consideration is whether foo is being called to return a result or to take an action. If to return a result, then you may be just changing one check at the call site for another, in which case it depends upon the check -- which makes more sense. 

This is bad way to write code , I could not even read the code without headache. Please separate out your logging functionality, you function should not be more than 30 lines per method, so first 

I would create two extension method , ToApplicationData and ToAddress and will define mapping over there. it will sorten you code and much better readablity. you can break this methods too if you want. 

You can minimize you code taking out the filtering out side of loop. Avoid catching exception inside a loop if it needed ,(it seems like it cannot be avoided here) No need to invoke datarow extension method to get value , you can get it directly. Naming of variable is really bad. 

2) Always dispose the connection In above code your opening connection and closing it, but this can lead into connection leak in case of errors. Please wrap your code into using statement or try clause like this 

toggleRows should not take a checkbox id but a show variable to show/hide the row by doing so you can call this method from any where. 

One more tip for , reading the content from the HttpRequestMessage you could user some model binder , I did not find any async version of the code though so you might need to look for it.