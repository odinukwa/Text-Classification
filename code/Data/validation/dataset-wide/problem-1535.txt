Naming: is not an index, but the actual value in the valid sequence (from min to max). I would call it or or something like that. I don't like the name either, because the target is actually the sequence of numbers from to . would be better IMO. 

Because of the flag-behavior of ConsoleModifiers.Control it will be true if any combination of Modifiers are pressed that involve . It would maybe be more useful to make it more distinct like: 

I think TheQuickBownFox's suggestion is rather elegant. With a little twist (the use of ) it is only necessary to call once per num: 

(The meat of the extension methods can surely be done more sophisticated than the above.) is an with a rudimentary definition like: 

You are firing the InitializingAssessments event on the form each time it is activated. Shouldn't that be in the load-event? 

because it will not return before all primes are calculated. It is btw strange that the client of the has to figure out that 2 is a prime :-): You could change the function to take a max or a count value to stop the generator when enough is enough. As an alternative it is IMO more useful to return a of primes, because it returns the primes as soon as they are individually calculated: 

Singleton 1) It is fine to have the static context object as private and the static Method Context. But a pure singleton class should hide the contructor(s) as private in order to prevent undesired instantiation: 

I think it's best not to do too much nesting as it makes a flow hard to follow. Further keep it simple and do not do everything in one function. IMO it's OK to make multiple return statements in a function if it's clear why, but others may disagree. I would do something like below: 

Challenge 5: I'll come back to this. This challenge is a bit more tricky. Your solution is again too complex: 

It's really just performance. There's gotta be a better way to do this, but I can't think of a single way. 

Probably a big problem is that your code does not handle ties. I will leave that to you, as it is pretty easy. 

Line 1: Space before brace Line 2: Space after Line 2: Space before and after , or any other operator, for that matter Line 2: Usually, though optional, there is a space after in end-of-line comments Line 3: It is recommended to use two tabs, or 8 spaces, for a continued line. Line 3: Again, space before and after all operators. Line 4-5: Here, it should be 4 spaced. Line 7: Space after Line 7: Space before and after operators, twice Line 7: Space after semicolons Line 7: Space before brace Line 8: Space after Line 8: Space before brace Line 8: Space after commas Line 9: Space after Line 9: Space before and after operators Line 9: ALWAYS put braced for statements. I explain it here. Line 11: Again, ALWAYS put braced for statements, including . Line 11: Space after comma Line 11: Space before and after operators Line 12: Space before and after operators Line 12: Space after comma Line 13: Space before and after operators Line 13: Space after comma Line 14: Space before and after operators Now that was quite a bit. Notice that most of my suggestions appear over and over and over again. Next... 

Select a pivot Create two pointers, one at the front and one at the back Move first pointer up until there is a value greater or equal to the pivot Move second pointer down until there is a value less than or equal to the pivot Swap and advance both pointers If the pointers have not passed each other, go to step 1. Otherwise, continue Repeat recursively for each subarray 

Zeta gives a thorough answer; I'll just add the following. The operateCaesar function could be written as: 

As the image shows checks against two different generations because the board cells are successively updated through the calls to in resulting in a false new state. The solution is to create a new board per generation and recursively check those while creating the next generation board: 

Instead I would make sure always returns something enumerable. And since it is always returning the same kind of objects, I would make it returning a defined class instead of the use of dynamic. I don't understand why you don't use the fact that it's all about Exceptions. Instead of collecting the subtree of Exceptions you could do it recursively avoiding the use of : 

If you've showed the environment the function is used in, the review could be more useful, but I think your reasoning is right, except that Lazy is used to defer instantiation and you actually use the lazy-created object () the first time it is called for by returning DataCache[key].Value. Therefore Lazy is of little use in this context as its object is instantiated at the same time as the Lazy. IMO your DataCache would give more meaning if you up front filled it with all possible queries without actually using them and then call them as needed. Alternatively you could just cache the queries directly in the DataCache without Lazy. 

I think your code is not that bad and for small segments and data sets it is all right. May be a better naming of the class Estacion would have turned you in the right analytical direction. I'm not that familiar with your language, but I think translates to or in English where a more appropriate name would have been or . The class is error prone in the following way: In the constructor you calculate but both and (and ) are public properties and may be changed in the process which will leave the object in an inconsistent state. In stead you should make the a read only Property as or . As for the algorithm it self I think Janos' analysis says it all. 

In the case of roots, to find \$\sqrt[z]y\$, \$f(x) = {x_n}^z - y\$, and \$f'(x) = zx^{z-1}\$, resulting in: $$x_{n+1}=x_n-\frac{{x_n}^z - y}{z{x_n}^{z-1}}$$ 

Now you have a horrible bug. It looks fine, but when you run it, will execute no matter what returns. If you actually had braces: 

This is one of the cleanest code I have come across in a while. Congrats to your lovely, well-written code! Just some points: 

I am currently creating a chess game, and have so far done the board. The board is pretty much a two-dimensional array, where s are stored in their positions. For example, will be the position , which at the beginning of the game, is a White Rook. The board has some useful methods (as well as required methods), such as , which checks if a specified square is protected, or , , and , which allows test-moving. The only problem to this is that it doesn't handle En Passants. Here is the class: 

Isn't it annoying when you can't find a file you recently created? Especially when you either have a very disorganized drive or a directory with lots of files. Even if you don't care, isn't it nice to have a program be able to locate a file for you? I did this because I have files that I can't seem to locate, but I know roughly where it is. The class can: 

Sets all numbers to (as in, is a prime). Starts at 2, and works its way through the primes. While doing that, marks all the multiples of a prime to . If it has 100 primes, the loop will terminate. Print the result. 

Formatting I can't even read your code. Format it better; in an IDE, you can find a formatting option. In eclipse, it's . If you don't use an IDE, I suggest you install one. Eclipse is available here. Choose the installer, or the "Eclipse IDE for Java Developers" option. Naming 

If their role is more advanced than that with methods and state, it IMO calls for at class hierarchy in some way like: 

I find your code clear enough, but you could improve it a little bit, so you only do the add operation once: 

on the view (form) maybe should be an interface which HomeScreenPresenter implements. Further: Instead of the presenter reacts on events on the view the view should call "passive" methods on the presenter - but it's a matter of taste maybe. 

As stated in a comment the above solution does not handle accented letters so a better solution may be: 

3) For the fun of it, you could consider: Because you basically do the same same loop nested three times, it could be a candidate for a recursive function iterating over each addend and yielding all the positive sums. In that way you could generalize the algorithm to handle any number of addends... 

Make resources: as show above the ForegroundBrush and BackgroundBrush are created as resources and referenced in the Button Style - and you can reference them inline on other controls as well. It makes it easy to maintain if you later want another color. Fixed Sizes: Be cautious about fixed size Windows. Your Display Window is defined with . A better solution would be to make your content sizable, which gives the user a possibility to resize the window to his/hers needs and a better experience. 

When testing the algorithm against other implementations it seems to work as expected and without a thorough knowledge about calendars it is hard to comment on the details of the algorithm as is. From a computational or mathematical point of view it is possible to simplify or make the formulas a little clearer by removing unnecessary parenthesis and just rely on operator precedence: 

You have extra spaces all over the place. To me, it makes the code look not natural. If you like how you write code, you can keep how you write it, but these are some suggestions. 

This way, programmers using it has a choice of being able to give less information, and add it later through the methods. Also, this allows them to prevent them from doing stuff like: 

Does this even work? It seems to me that you are trying to test to each of the above values, but what you are really doing is a binary math operation of and . Let me explain... "and"s each of the bits in the number, e.g.: 

What??? confuses me. Might want to do some naming changes. I would simply remove in and use instead: 

The second line is only two-spaced. Make sure that your spacing is consistent through your code. Don't import the whole package: 

How many warnings do you have? ANY of them means bad code. In this case, some of your variables are unused. Remove them. 

Your method names are currently in , when they should be . should be , should be , etc. Now to individual challenges: Challenge 1: No problems there, just some minor readability improvements (plus closing scanner): 

Just my opinion, but I feel uncomfortable with that many spaces in code. The only place I would use spaces would be: 

Your file has awkward indentation. I don't understand the extra tab after . Instead, you should keep indentation same for the same level of code: 

So you have to put somewhere in your constructor. Also, when it shows, is so small you could see nothing. You should also set the size you want it to be and if you want it to be resizable or not in the constructor, like this: 

3) Have you considered using and let the item class implement interface to keep track of collection and item changes in a dynamically and event driven way? 

I think you show a good understanding of F# as a language and functional programming in general as far as I can see. A couple of things though: You use as variable name on multiple levels of function definitions. It makes it hard to read. IMO is a very readable construct for more than two matches. But for only two I prefer if-statements. The function/sequence is a kind of double sequence. I would do it this way: 

Sometimes extra parenthesis can make an expression clearer for the human eye, but here the computation is more or less incomprehensible for non-experts, so they really make no sense. Whether or not you should have spaces between operands and operators is a matter of taste - I prefer the spaces. 

As others have pointed out you only have to check the number of distinct characters in the sentence. A one liner doing that using linq could be: 

Secondly I think it is a problem that has its own implementation of because you then don't evaluate the base class implementation which could be invalid. A solution to that problem could be as shown below. Be aware that I have dropped the IPrimeChecker, because it is unnecessary. 

Writing something consecutively to the console is of very little value. OK, returns a list of primes, but you really can't use them until all primes are calculated in the domain of , and that's a lot. For instance, it is useless to write 

I would let PDF.WrongPasswordException (because you don't have a choise) be the only exception to catch in this method, because all other exceptions have nothing to do with its Purpose (to check for password). If the file it self is missing or invalid, then you really can't tell if the file has a password or not and therefore returning false doesn't give the client valid information. If the IO exception instead is left to the client to respond to, he can react appropriately.