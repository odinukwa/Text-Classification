(Which, incidentally is the same as: - use dot notation where possible.) If you write it like that - seeing that you are passing (almost) the same argument in all use cases to your create_filter_input function - you can start to see/think that you don't need 2 local variables - just having "property_type" is enough. As one of the other answers says - don't serially append to the dom. each write is relatively expensive. it's better to build a dom fragment and append it to the dom in one go. 

I'm not particularly fond of the style of coding, not everything needs to be a class. But there is only one point that I feel warrants significant attention: Huge Point: Not escaping means not useful 

Putting as little as possible in-between the user and the content they are requesting means better performance. Handle requests for missing packets If you want to automatically handle requests for missing packets, add a .htaccess file (or equivalent) like this to the css/js folder: 

Putting all your logic in one place is not necessarily the best idea, when the alternative is to write concise (and more efficient) code using php's function directly in functions. As such, consider 'just' using PHP instead of wrapping php functions in some more logic. Make "nu" a separate function Each case you want to handle should really be a protected specific function. Once you do that, consider deleting any functions that are just one line of code as it's better to just use php's own functions. The 'nu' function however, is likely to warrants it's own function. It looks like the main purpose is to strip out XSS attacks. Unless you have exhaustive tests for this logic, it is very likely it doesn't cater for all possibilities - therefore make it a separate function and if you haven't already it'd be in your interest to write some tests to at least cover the most common XSS attacks. 

@Tim gave a great solution of his own, so I won't talk about your algorithm, but about your code: Naming Conventions Class and namespace names in C# should be in PascalCase: 

Also see above how I've avoided the in the above using a guard condition () Code Duplication You've got several methods, which do essentially the same thing. Making a method which takes the duplicate code will remove the need for them entirely - something like: 

Naming, naming, naming... Your code is very hard to read - , , , (?!?). I understand (hope?) that some of these names are part of your business nomenclature, but, especially when asking strangers to read your code for optimization, giving meaningful names can go a long way. Asking me to figure out how to optimize a loop with would be hard enough if the names there meant something to me... Break it down Your methods are very long ( is 67 lines long...) this is a code smell, which also makes your code hard to read, as well as hides the structure of your flow, and possible complexity issues. Refactor your methods to be shorter, with expressive names, that will make your code more readable, more testable, and more optimizeable. Distribute the load As @Dan suggested in his comments - you should consider spreading the load on several threads/CPUs/machines... As far as I could see, your calculations are independent of each other, so you could simply arbitrarily split the load on several instances (let's say take over 9 of your friends' machines, and give each machine all the run ids ending with a specific digit...). This should give you linear scale (up to the point where writing to the DB is your bottleneck). Optimizations for one-time code Perhaps I misunderstood your explanation, but it seems that this code is meant to run once. If that is the case, why do you care if it runs 15 minutes, or 8 hours? Just run it and get on with your life! 

The function invoke handles everything - there are 10 "actions" in it. Each of these if statements would ordinarily be a separate action (function) in a controller. include view That's not how views are rendered in CakePHP. Like that there are: 

If you find you're only using each instance of a class once - that's a relatively good indicator that a class is the wrong approach. Is so much code necessary The question states that the objective is: 

The less logic there is at runtime - the faster the code performs. Use a build process Rather than handle requests for missing packets, a process that builds them all, once, could be used. 

The backend mailer class is just an implementation detail of your own Mail class - it shouldn't be necessary to have intimate knowledge of such details, but because it's a mandatory constructor argument this is currently unavoidable. It should be possible to change the mailer implementation and make no changes to your application/usage code (except in tests). Another disadvantage to everything-as-constructor-arguments is that all classes in use are created eagerly. If the Mail class were to be instanciated but is ultimately unused - the Mailer object would also have been instanciated and unused. In this case that class doesn't do anything - but if it were also creating dependencies on construction, and if there is any setup logic executed this can easily mean a tree of objects get created before they need to be used. A practical example of how this can be a problem would be if the config is modified after construction but before first use: 

and it will just work... Code Encapsulation A ruby file should contain a single class. It should not contain any floating methods. Actually, there should not be any floating methods. Create a different class, or a module, which will contain the , , and . This will also force you to name the module, and make it more obvious what is its role in your application. 

Now all we need to do is multiply them with each other! Method naming Your names are very verbose, which is a good thing, but ruby idiom frowns upon prefixes. Also, prefer using verbs already in the language () over those which are not in the language () So now the code will look like: 

The first line selects all subdirectories matching the pattern. The second line selects only the ones which are empty. The third groups by the numeric suffix (non-numeric suffixes will be grouped under , so they will be last). The last line sorts by the numeric suffix of the directories, and returns the directory names. 

Be aware of the difference between isset and empty This will return true if the userid in the session is e.g. "" 

Note that there's no need to continue to the end once the answer has been obtained - this alone make determining the answer faster. This doesn't defend against out-of-bound problems, but it also doesn't need to. 

That's a lot of code It looks like it works but since it's apache specific what's wrong with using virtual? It's an apache-specific php function for serving files. I.e. 

No I'm not sure why this question is tagged CakePHP but since it is: This is not CakePHP code =). Some specific points to elaborate: session_start, $_SESSION This should not be in any CakePHP application code - The session is started on demand whenever it is first accessed via the Session component, session helper or the CakeSession class. include_once Files shouldn't need to be included explicitly at all in CakePHP, there's a standard way to load everything. For classes that is using App::uses, for template files it's Controller::render and View::element. Model By defining a class called Model, even if it were loaded correctly - CakePHP's base model class cannot be used. new Model This is not the right way to construct a model in CakePHP - the normal way is: 

This way the story has a beginning, and an end, and it easier to follow. Choose your types What is used for? As far as I can see it can have only two values - and , and it is used to flag the get input loop that a valid input has been received. The name is cryptic enough - why not at least make it a ? Block format conventions It is idiomatic in ruby to use syntax for one liner blocks, and syntax for multiline blocks. Instead of writing: 

This will never be true - as is considered an indicator that it is invalid, and will then prompt the user for a new number... It is unfortunate that java does not have like in ... You can, however use boxing to indicate an invalid number as . This way - all valid numbers are fine, including . 

My observations: Use properties - do not expose raw members - your implementation exposes raw members. You should use getters and setters instead. Unused parameters - in your constructor you declare 4 parameters, but you always pass only one which is not (the ), the other parameters are unnecessary. 

Which is in fact set to four spaces. "\t" is easier and shorter to type. Minor Point: Whitespace Whitespace in html is insignificant, so doing this: 

But it should be "pass" and not "password" (internally) so that the code used is consistent with the output of the function - on which the class should rely. Don't repeat yourself (DRY) #3 The build method could be written as: 

That means in all cases the variable is tested 3 times if it's null, and twice if it's an array. A couple of side points: The first use of is really testing if the variable is a string by inferrance - it would therefore be more appropriate to use . Also by using type-insensitive checks an empty array or empty string are caught by the first if block (perhaps that's deliberate but it isn't obvious). Instead the code can be written as: 

What is going to happen if $label is or any other innocent string that will cause malformed html as a result? Why is the class not taking care of that automatically? Note that there will be use cases where you want to put html in some tags - such as using an image for a label, or where tags are nested - attributes should always be escaped though. And that's just talking about how innocent users could break your code, not those with malicious intent who submit as their name. Big Point: Write real tests If you write a real test (by which I mean using phpunit) you can quickly test normal and edge case scenarios (What if the property looks like this?), which will highlight any difficulties in using the code. It'll also permit you the confidence - if you choose to rewrite any of the code in the future - of knowing that it still works in the same way as it did originally. Mid Point: Inconsistent constructors You have all these different constructors: 

And we have another one-liner! Everything is an enumerable So you want to save on your "upto-loops"? Let's do it! You want to enumerate over each pair of numbers from to , so what you actually want is to have a long matrix of those pairs: 

I agree completely with everything @200_success said, but if you do want a sensitive info solution, I would suggest something more in the lines of - a specialized string which is makes by default, and only shown when explicitly requested: 

Your code is very brittle and hard-coded. Code is supposed to be as generic and flexible as possible so you could re-use it. A new chapter, a different layout, anything would require you to change the whole code. Code is about doing work for you. Think generically - can this code be used for a different book? (I don't mean by you copying it, pasting it and changing it...) You need to abstract it - what do you have here? You have a , which is different than a . A has a . There are some chapters in a book. The TOC needs to be laid out using some logic... and are objects is your system, the layout logic is a method. For example - I pass to a method called a title, and a list of chapters, which (for simplicity) contain their name and their page number in an array. The method than lays out the TOC page according to the format in your code. Note that the data does not contain the words or - they are part of the layout, not the data: 

When the time comes to write unit tests, the code shouldn't need to be modified. Changes to make code testable are usually trivial - and just mean planning ahead and having appropriate methods to set and get data. Be secure As indicated by other answers an unsalted sha1 password is weak. Passwords should be stored such that even if someone gets access to the database, they can't determine the original password. It's not hard to store passwords securely, here's some pseudo code: 

As per the previous point - a model class cannot be named "Model". Controller By defining a class called Controller - CakePHP's base controller class cannot be used. 

There are numerous things you can do to make the code easier to maintain. Put code in your models The minimap function calls find on the banners table twice - with config that doesn't change. It'd make things a lot cleaner to do this: 

Don't catch exceptions that you don't know how to handle. Unless there's a reason you're catching PDO exceptions - in which case document it. Use less nesting. Don't needlessly use . This is easier to read than the original: 

My code still runs ~2 times slower than the original (ends in 18 seconds), but it is more reasonable than with ... 

Accessors in C# You should read on accessors in C# - your setter does not do what it should - it should set the value if . If this has no meaning (you can't change the value of - you should drop the altogether. Correct use of accessors: 

Redundant operations returns a list of strings. There is no point in calling on its children. String concatenation implicitly calls on all non-string elements you concat, so calling after the rounding is also redundant. You assign twice, totally ignoring the first assignment - that line is totally redundant. Don't re-use variables by changing their meaning One side-effect of meaningless variable names is that you might be tempted to re-use them 

On a different note, I was not familiar with , and it looks really cool! I'm going to look for where I might make use of that! 

Looking at your code, I believe that your problem is not only that the logging lines are ugly but they are a risk in costing you more than helping you: 

In this way there are 8 routes in total, no matter how many controllers there are in the application. 

DRY - Write less handle more You can make your function half the size by designing it to work with scalar vars only, and handling arrays with a loop: 

A message inside a class like this shouldn't assume it is to serve html - what if it's responding to an ajax request, in xml, json or even just a log file? Don't sleep I'm not sure if this is just code for demonstration but this is actually the one "problem" with the code in the question. Using sleep will tie up your resources - that's not in your interest. Consider instead bailing early and just returning a 403. Right now before prompting a user with a captcha - you are holding the request open for more than a minute. If you get enough users (and enough could be a relatively small number) trying to login at once and getting it wrong - you're going to take your own server offline by occupying all connections with 1 minute long sleep calls. Don't use empty if blocks Again, not sure if this is just for demo purposes: