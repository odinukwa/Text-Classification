I would like to add to @LokiAstari's excellent answer It is a good rule to write out all possible tags in a switch statement, you have one case which you do not handle also add a default as well to catch any invalid values that may be added in the future. Your / functions I find are a bit too long, IMHO it would be better to split up the function in a couple of separate functions to make it more readable. (Also here you suddenly stopped having any comments). You have quite a few variables in your functions so separating the functionality into several small functions will help with that too. When you write comments have in mind that the reader often wants to know why something is done, not what is being done since that is the purpose of the code. When you initialize member variables do it in the form of 

This way you only need to process the data of each image once and then group them by the hash. A few remarks to your code: 

On initialization we load the current configuration values synchronously. After that a background monitoring job gets kicked off which executes a callback whenever a key changes. 

In C# methods are generally same goes for public fields and properties. Prefixing names with their type like or (also known as hungarian notation) generally provides no value and just creates clutter which decreases readability. Please use sensible names for variables, fields etc. , , , , , ... etc. That just nuts. A name should convey the purpose of the variable/field - what is it being used for and what kind of information does it hold - in a concise but readable manner. Maintainability is about someone coming back to it 6 or 12 months later and still being able to understand what that stuff all means. 

your function can fail in a few ways but you only set the when malloc fails, you may want to add some more error codes like when nothing is read. 

I/O You want to read 2 characters although you use this can have the effect you are overwriting the end of the buffer when you read since there is always an \0 added to your two characters. Either increase the buffer, change the format specifier or use an alternative method of reading from keyboard e.g. followed by or simply read the characters one by one using . The latter method has the advantage that you could prevent the user from entering invalid characters while he types. You may also want to convert the characters to upper case just to be a bit more flexible towards the user () structure I think the code could do with some more functions to clarify the purpose. E.g. 

I'm not a huge fan of reading all input in one one go and transform it in one and then write it in one go. It seems clumsy and will not scale properly (although in the given case it's probably not going to be a problem). The basic structure I'd go for is this: 

In addition to what @lol.upvote already said: I don't really like the way you pass the column names and values around for several reasons: 

I think I'd go with the first option. The factories are all very light and really only contain so it's unlikely the implementer will forget to overwrite it. Unit tests should catch inadvertent calls of the base class method. I might have assumed totally incorrectly though so please correct me if I'm wrong in my assumptions. 

This way the user doesn't have to care how you implement the stack, just that they need a object to pass around and use. 

Update on : I missed that your were also looking at the performance of the function. Unfortunately, if you keep the original allocation scheme there isn't very much you can do. Memory allocation/deallocation can be slow and with not always consistent (it can take longer or shorter depending on the state of the allocator). For example, in my sample test of 150k words has to check 10.5 million pointers and deallocate 388k of them taking 7 seconds to do so (would be faster if not running under VS). If you change the allocator to a single bucket as in my example then your deallocation is simply: 

Note that the code below is missing some error handling/checking code for simplicity and the node allocation size is hard coded for the same reason. Look up "block/bucket/arena allocators" for more details on this type of optimization. 

You don't check for EOF in your inner for loop meaning your code will run forever unless the file ends exactly with a . 

it is a common defensive programming technique to put asserts at the beginning and at the end of a function to ensure that the functionality is as expected. first you check if the caller contract is fulfilled, then that the expected result is reached. 

you should check the return value of , it is not always successful. you need to deal with that event as well. e.g. reading many lines and with a memory that is fragmented may cause it to fail to find a large enough continuous memory block. also is an expensive function to call, it is better to allocate larger blocks than try to allocate several small blocks. 

check the parameter if it is null before dereferencing it to avoid error, just return 0 - optionally print a message to stderr. 

is not a good name for a function, pick a name along the lines of {verb}{noun} to make it more clear what the function does. 

Your original code (with the two fixes mentioned above) takes 1500ms to load/parse 150k english words. Not necessarily bad. It results in 388k allocations of new nodes. Removing the call reduces this to 1060ms. Loading the file all at once (only 1.5MB) and parsing the string using has a very small performance increase to 1000 ms. Replacing the with manual parsing logic has no visible effect. At this point the only obvious thing left is to optimize the individual allocations with one block allocation (see code at the end). This has a huge effect on performance reducing the loading time to only 15 ms. Hopefully that is fast enough for you.... At this point there isn't anything obvious left to optimize. You could try saving and loading the completely parsed trie but the I'm not sure if you'd gain much with the larger read size involved. Profiling would be your best bet to see what, if anything, could be optimized. 

can be replaced with (or fputs), puts has the advantage that it cannot be hacked by putting in a format specifier so avoid using when you don't have to. 

whether ownership is to be passed to it or not, using a smart pointer eliminates that need. e.g. here you directly that GenGenParse only shares the object, it does not delete it. 

EDIT to the actual code review: writing to calculate size is unnecessary and is hard to read, just write size. i.e. malloc(size) initialize all variables, one day you may change the order of the statements and then you may end up with uninitialized variable during runtime BTW I don't think your code works, when is successful you never set str to point to the new buffer i.e. temp_alloc so by next fgets on the same line (by lines larger than ) you are in uncharted territory. 

in general it is better to write functions that do not force the user of them to look at the implementation in order to figure out how to use them. your function allocates memory and returns a buffer that the user needs to free. this fact is not obvious from the function name (it could have returned a ptr to a static buffer for instance, or a pointer to a global array whatever). 

In general your code is quite hard to comprehend due to the bracing style and the single letter variable names. A bit more spaces and more meaningful names would do quite a bit for readability (I've kept your 2-indent spacing) and also remove the need for most of the comments: 

Consider refactoring your into a method like . If you ever want to change your dispose method or add logging or whatnot then you have to change only one place. Code duplication should be avoided even for trivial things like that. You swallow exceptions in and and return a which tells you nothing except that it went wrong. Same in and . You throw away a lot of information which will be useful for troubleshooting should the need arise. In general I would consider that a bad idea. Replace your magic constant either with a definition or even a setting you can tweak. If you make it a setting please make it a - I personally find all that code which scatters around s with implicit units very annoying. I often have to look up what it means because it's not always that obvious - seconds, milliseconds, ..? 

Prefer references instead of pointers when you pass arguments to functions, that way you are sure in the function that they are defined and not null. Also you see that it is not clear from the function prototype 

is the name of the function if you want to use standard C but I understand your compiler has some convenience function. You should also check the return value of ungetch() to see whether it failed or not. It returns EOF when it fails. Code is for programmers to read so there is absolutely no benefit of making terse expressions by ocular optimization, instead let the compiler optimize and focus on writing clear code. Use compound statements instead of single line statements for clarity. 

that may make its use less confusing than keeping track of all possible argument combinations. You may also want to include the stream to print to as an argument to , that way if you can alternatively print to a file instead of . 

The other answers go over a variety of good optimizations and code improvements but I wanted to look specifically at how each one impacts the performance of the loading code (Note: please take the times below with a grain of salt...do your own benchmarks if performance really matters): 

Always check return codes when reading data from files. I suspect this may be the issue with your code "crashing" as even with loading 150k words your code only takes 1.5 seconds with the fix. Another issue is the mixing of with depending on if your word file contains or line terminations. Using mode with will probably result in incorrect parsing when seeking...at least it did with me using VS2010 on Windows7 causing considerable head scratching. Changing the mode to fixed the seek issue but eliminating the seek altogether is a better fix and then the file mode doesn't matter. 

I was curious about the performance of a trie so did a few tests to satisfy myself. First two problems with your original code: