Use more vertical whitespace (newlines); your code is hard to read because I can't see which parts are logical blocks. Optimized code doesn't need to be (and shouldn't be) hard to read--leave that for obfuscated code. 

Your CSS seems very good, although do you really need both and if they both do the same thing? Why don't you just get rid of one of them? You have one error in your HTML - an unclosed ($URL$ 

MY EYES!!! Seriously, use indentation. I didn't even realize these were s on a cursory scan, which would be very dangerous for anyone editing this code (and the others like it): 

First, your loops are evil to read. It took me several minutes to figure out what the condition did. Essentially, you loop N times, where N is the Nth instance of the character in the string you wish to find the index for. Each time you loop, you find the index of the next occurrence of the character in the string, update the position to search from, and continue the process until the index is either -1 (no Nth instance), or until or , based on which side you are searching from. A simpler way to write this algorithm is as follows: 

Compared to the slice-to-slice variant, we are only taking every second (every block size in general) element from the iteration. In the current state of the code, this is done with a lot of nested loops and a lot of repeated index calculations. Despite being repetition of code and mixing of different tasks in the same function, it is also inflexible. We want to support a second scheme, the interlace one: 

The code must be C++11 and compatible with GCC and the Intel C++ Compiler. Do you have suggestions to achieve the same results but with less dense code? 

Since there are so many lines and I have a bunch of helper functions, I wonder whether there is some better wayâ€½ 

Your description of the algorithm used describes the famous backtracking algorithm. This algorithm, by definition, is guaranteed to find a solution, but is terribly slow because it tries all permutations until a solution is found. In order to speed your algorithm up, you should try to solve the grid the way a human would. The first step is to develop a table of legal values for each cell, rather than just trying any value from the allowed range. This alone will significantly increase the speed of the backtracking solution. The second step is looking at all possible values in each row, column, and subgrid. If a cell can only have one value, based on the limiting values in the row/column/subgrid, then you have a positive value for that cell, which can be used to reduce the number of allowed values in other cells. You also have a positive value if that cell is the only free cell in one of these subsets to support a specific value. The third step is slightly more complicated: If any two cells in a row/column/subgrid each can have only two identical values (both cells can have either 2 or 4, for example), then one of those cells will be 2 and the other 4, and you can remove these potential values from all other cells in the subgroup you are examining. The same applies to any N values in N cells ([2, 5], [3, 5], and ([2, 3] or [2, 3, 5]), for example, guarantee that this set of three values will exist in those three cells, and no other cells in the subgroup will have these values). The fourth step is based on the same principle as the previous point, but is slightly harder to identify. These cells are when any N cells have a block N values that no cells in the subgroup have. For example, if a subgrid only has two cells that allow 2 and 4, but in the current state, placing a 6 or an 8 in one of the cells would not look like a mistake (e.g. the "penciled" values for the cells are [2, 4, 6, 8] and [2, 4, 8], but no other cell in the row/column/subgrid has the values [2, 4]). Identifying these patterns and limiting these cells to supporting [2, 4] can help you limit other cells' potential values, and reduce the numbers checked in your backtracking solution significantly. Most advanced Sudokus can be solved with just these rules, and if you encounter a legal Sudoku that cannot be solved with these rules, your program will still be significantly faster because it will limit the solution to checking only potential solutions knowing the current state. 

The outer loop does not use range-based- because we want to parallelize that part with OpenMP and that needs to see the range explicitly. With this, we can just change the value of the in the constructor and get a different iteration pattern. Also it allows me to iterate other the slice combinations in the current block combination . The output would be the following for our example: 

We go through the blocks, and within each block combination, we take all slice combinations. The block combination with switched sink and source blocks is to be done right after because we can re-use a bit of data with that as well. For the functions of type , we want to iterate from slices to blocks, like this: 

I really like how you use the HTML5 element instead of using the old style When people write CSS, they often format it slightly different, like this: 

This loop is almost right, but you check the value an index , which you did not set to because was the value to exit the loop: 

As for working, it appears that it will work - until a student figures out what is happening and turns the script off. I am not a JS expert, though, and I do not have the full context of how this will be run, so you should get another opinion. Personally, I would set it up and test it thoroughly over a day or so before deploying it. 

As @IvoWetzel already said : CSS has no place in javascript code. Instead you should have configurable classnames for elements of that Note widget. Leave styling of elements to CSS in *.css file. 

I will ignore the android specific parts. And i will fix/ignore the missing semicolons & unnecessary brackets Ok .. here it goes. 

You could start by removing dynamic HTML generation where there is no benefit in it. You would be much better of writing something like this : 

PHP itself already is a templating language, so my first thought would be - this is completely pointless. And no, "designers do not know PHP" is not an argument for making such templates, since those same developer would have to learn how to use your miracle instead. About the code .. 

We have a set of time slices, in the order of 50. Throughout this question I will use 6. We group these slices into blocks, in this example the block size is 2. Then we want to iterate through all source slice and sink slice combination and call functions of the following types: 

The following is my attempt in Haskell. I made comments which probably state the obvious for Haskell experts but it should make my reasoning clear. 

The data that we work with has the property that we can re-use intermediate results as long as we have the same source and sink block. Therefore this scheme wastes opportunities to re-use data. We cannot fit all the data into the RAM, so we want to iterate through this more intelligently. This is the iteration scheme that we want: 

Well , you have to keep in mind that not all browsers implement , not even all of ( what you would call ) "proper browsers". You should add a fallback for such a problem. That said, you probably could get rid of at least one , if you use something like a . Just put said object into closure, otherwise you would be creating it each time anew. 

Instead of wrapping your code in , you should put the tag at the bottom of file ( right before closing ), then you script will get executed right after the DOM is ready. Do not use innerHTML for working with DOM Stop selecting DOM element each time you want to do something with it. It is an expensive operation. Instead get the element once and store in a variable. Your method initializes twice. Do not use in loops. Instead assign value to variable and reuse it.