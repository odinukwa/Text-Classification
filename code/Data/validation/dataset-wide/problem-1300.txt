Why choose a specific handler Your specific use cases will affect your choice of handler for cleaning up, and there can be large variations on needs and requirements. Here are some arguments related to the different options. Manual handling In the general case, using manual handling is unreliable as we're humans and we tend to forget to do the right thing. Having the option available though, is useful. The largest caveat for this is when exceptions and errors occur to then properly assure the cleanup actions to be taken. Trigger at exit Using a trigger at exit is, in my opinion, the safest option, as you then have made a conscious decision to always cleanup when script exits. This will catch all cases, except abnormal termination of the script, i.e. through external signals or similar. Exceptions doesn't not prevent the exit methods to be called. However this option needs to have an option to actually allow cleanup not to take place if your script is use to handle a smart home where the pins needs to stay in their low or high position after script termination as you might want to use your Raspberry Pi to do other stuff in between. This does require proper handling of warnings when reconnecting on later invocations. Context managers Context manager does have their purpose and right of life, and it possibly comes down to personal choice whether to use these or not. They do have the element of remembering to use them, but when remembered they do the job. One minor detail is that they increase indentation levels, and it can be hard to find the proper level of when to do it as the scope of this context might be rather large, spanning several functions. And in my opinion I would like for a context manager to be in as narrow a scope as possible, without too many large functions called from it. That is to have at little code as possible within the scope of a context manager. Related to file handling, I would like for the file handler to be open for a shortest possible amount of time. My opinion on this is most likely based on the concept of not clogging up resources, and releasing that at the earliest point of convenience. This might not apply though, as the requirement to cleaning up for GPIO is not a matter of resource allocation. Using decorators Decorators seems like a more natural choice to me, as they decorate a function and you can then give a proper bounding for when you need the cleanup to occur. The concept of resource allocations doesn't apply as a decorator is by convention something to do in front or after functions, and I think this use of a decorator is a good choice. Cleaning up through encapsulation My last option is to use cleanup through encapsulation. That is to create a class which fetches or references the , and then when the object is freed it calls the cleanup action. At first this might seem like an extra step considered to other methods, but one advantage is that this could allow for proper encapsulation of more than just the cleanup. It's not unlikely that you have a dedicated script to control a given set of pins, which lends it self to being encapsulated as a class where you hide the actual operation on the pins themselves, and instead provide helper methods like , , ... That is you give your script higher level methods doing the logic, and not implicitly needing to do the with magic numbers. This would allow for easier refactoring of pin layout, and a lot easier code to read at higher levels. And if doing this, it would also make sense to have the cleanup being a part of the class so that when freeing the class, the pins are cleaned up as well. Conclusion To be on the safe side I would implement the trigger at exit with an optional module method to disable the cleanup in the rare cases where you want to leave the pins in their current state. This would allow for an almost guaranteed cleanup unless you specific says to do otherwise. Secondly I would use decorators given a low level script for intermediate cleanup of pins throughout various parts of script. Possibly opt'ing for the use of encapsulation for a larger system like if you build a smart home system, where it would make sense to encapsulate the different pins and have better names to address the different switches. 

Your code is lacking in the regards that you do floating arithmetic when you don't need to, and this potentially introduces smaller errors as you multiply back the different intervals. With that being said your code looks clean enough, well spaced and good variable names. Only thing missing as such would be a docstring to document the functions return value as the name is somewhat ambiguous. To avoid the floating arithmetic, and ease the calculation I would flip the order of doing divmod operations, and then we end up with the following code: 

I've tried searching and googling for variations on how to solve this kind of problem, and all the searches turn up either posts made by you or references to the original documentation and the Effects library. In other words, there is not much online documentation available for the Idris language, and I'm a little unsure as to whether it is worthwhile pursuing this language. However I can comment a little on general issues in your code and state machines: 

Algorithm considerations If keeping to your format of not using functions, there are still some issues related to your algorithmic choices: 

Here is an alternate version for finding the multiple of \$N\$ which looks like a binary. It doesn't depend on a prebuilt table of binary looking decimals, but generates these on the fly. This is done using a counter from 1 through 4096, which is converted to a binary string1, before that binary string is converted back to a . This newly formed binary looking decimal is then used in the modulo operator testing. 

Lets first review your code, and then introduce you to one alternative on how to do unit tests in Python. 

And corresponding in the definition: and then your view will be simpler and will contain no logic at all: 

But the 2nd fastest version was using postfixing the string, a single function, and skipping the pairwise iteration, like in the following code: 

Coding is supposed to be fun, and there are tons of lessons to be learned for us all out there. Hope this somewhate elaborate code example can give you some ideas for further coding! Happy coding! 

Lots of alternative and partial rewrites have been given already. In this answer I'm going to try to focus on the strange mix of static vs non-static methods and variables, and badly named methods and variables, in addition to proper signature of methods. At the end I'm going to present an alternative version, which might not be optimal with regards to using streams and other new-fashioned stuff, but it should work, and hopefully will illustrate some of the stuff I'm commenting upon. Code smells in current code When reading your code I react to the following code smells: