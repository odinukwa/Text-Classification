The better way would be your first, as you're just comparing the element A with element B and not creating a copy of the element as you are in the second version. Additionally, to be a bit of a pedant - you don't want to name a function where its only returning a boolean, over where its assumed it would return a boolean. 

So, we'll use that as our baseline for improvement (further runs stay constant around .052/1000). Let's grab the low hanging fruit - caching the calls: 

"I'm pretty confident it would be a bad thing to have the same code for opening a connection in each function of the class, that's why I've put the connection opening code in a function itself." 

I just put this together, so I haven't tested it or anything, there might be bugs and someone else PLEASE come along and improve upon it, but I think this might be a good starting point to answering this question: OOP version of OP's code: 

After that, we continue with an if/else block which calls the function according to the user input. Our i/v/r/w should already be defined in the block above. One major change here is that we are no longer printing directly from here. Rather we are setting the output in an variable, which we later use to print. 

Use PDO, not mysql_* as they are deprecated and dangerous. Break up your code into functions, this makes it easier to call and test. Throw and catch exceptions. You can omit the ending ?> 

You should think more about how you arrange and style your code. Additionally, you should be aware of DRY methodology and keep from repeating code wherever possible. I made a couple of modifications to your code. Primarily, I cleaned up the arrangement and styling. After that, I added an Ohm class - which places all of your Ohm related functions as methods (again for code cleanliness): 

These are the two final products, one brute force, and one using built ins, and both return the same value when a word is found: 

And I m having a Discount class. In fact, we can apply Discount on product, the the amount we obtain is a Euro : 

I m working on calisthenics objects and I'm actually having some troubles while trying to follow the calisthenic objects rules. In fact, I m stuck with the one telling that we have to wrap all the primitives inside of objects. Context I'm having a Euro object that looks like : 

Problem My problems appear on the multiply method of the Euro object. In fact, currently, I m accepting a double as parameter, and it doesn't follow the rule of wrapping all primitives in objects... Moreover, a "double" in a business context doesn't mean anything at all. I m a little bit stuck with this example and don't know how to bypass this. Moreover, I don't want to use getter / setter on this implementation... Any suggestions ? 

On the Account class When working on the Account class, I was facing some problems while recording transaction. In fact, I wanted to test the deposit function and I had no way to mock the DateOfOperation (not injected, but created from a hidden way). From a technical point of view, this method is private, and its creating a new DateOfOperation to create a new Operation. But the fact of creating this date internally seems to break some SOLID principles. From a business point of view, I don't want people to provide me some DateOfOperation as argument, because they could have modified that date while passing it as argument. And my operation could now be false. So, I don't know how to test this result, and I m lost between the two possibility : matching absolutely SOLID, or accepting that I'm completely hiding the date creation of the operation. One step further to blow my mind, Uncle Bob, in Clean Code proposes to have the fewest parameters possible while creating methods. If we have too much parameters, we should split it in multiple classes / functions (I think I m in this case) 

I seem to get the feeling you are either not comfortable using maps as others have suggested here...so why not throw in a switch instead? 

Now, we know that the Sexagenary cycle consists of 60 periods, thus, to determine what animal and element a certain year matches: 

Again however, if some class extends it, they won't be able to access the var. Also, stay away from static. 

I wrote a Player package in Go. It builds correctly, but I would love a review on what I did and did not do "the Go way". I'm new to coding in the language, although I've gotten about halfway through Ivo Balbaert's "The Way To Go". The code consists of a struct and a bunch of setters and getters for the struct. 

Another way to do it, if the generator consistently returns small sets of data, is to just use . This is especially true if, like aforementioned, the generator returns small sets of data and that data is not dependent on an action (ie, data is static) and that data is not kept in memory for a long time (such as in a child that is killed (and its memory freed) once its served its purpose). The way to do so, is: 

::EDIT:: In regards to the comment (not same as OPs code), turn the function into an iterator rather than returning a list. This will give you the speed boost of the prior code, and still give you all the places of occurrence: 

Notice that your original answer does not catch nor raise an error when encountering a string val. I've reworked your code to this: 

But without knowing how you want your JSON to be defined, at the moment I can only suggest the following, which fetches all records in the SQL query and shunts them to the JSON encoder. 

That way, we end up with 2 function calls to and 2 new variables (which are cheaper than a function call), but is still not as performant as your original one liner.