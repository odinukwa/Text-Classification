My two cents: Swing Swing's dead, just wanted to mention that. I still use it too sometimes, to test stuff out. GUI The main issue I have with your code: I don't see a GUI pattern involved. You might want to check Martin Fowler's website, he has quite the list of Presentation Patterns with good examples. I mention that, beside the Single Responsibility Principle problem, because of the following reasons: 

I'm not 100% certain if that's the intention of your API, after I've seen the usage code, but alas, if I understood your intention correctly, that would be easier to read. 

To be honest, the code is way too chaotic and very hard to understand. Main object oriented principles are not followed, a lot of bad naming, passing around of variables everywhere. Just following the code flow is very hard. The main concerns: SRP The SRP: Single Responsibility Principle. Your does like everything. It's something like . Your types should do one thing. I'd suggest you first start to refactor all the responsibilities into separate types. I mean, you just provided us a list of those responsilities. This, and the passing around of the variables is hurting the most (e.g. the , which is passed from the type to everywhere. I do not accept the "Shutdown hook" argument. Thread management When I see Threads, I'm usually very suspicious - it's a very icky source of bugs. And when I see Threads starting other Threads, which then start other Threads again... well, actually, I have never seen that. If a bug occurs: Good luck, or better: good night. First of all, I don't see any reason, why should be a Thread? Shouldn't it be possible to start the app twice with a different ? As long as you don't need to tail dozens of files, I wouldn't implement this type as . Why does need to be a ? If the file is "rolled over", the actual thread is done anyway? Even if not, e.g. the new file has to be processed, too, I'd just "read the rest". Performance A priori: If you want to improve "performance" (whatever that exactly is!), you have to measure. HDD Quote: 300000 lines per 8876 My test file is 100MB's with 1'024'000 lines (100 chars length). I read it completely in 186ms with a and 8192 buffer size. To count the lines, using a , it takes 281ms. And that's on a ~3 year old fair SSD. I wouldn't care about read speed from the disk, so that's why I would get rid of all the Threads you are using for accessing the file system. As long as you do not read with some stupid buffer sizes, reading will always be faster than writing anyway. I'm also fairly certain, that the removal of those Threads will improve the throughput, because thread management is not free. In general, I usually say: Adding more code and complexity will reduce performance - which of course, is not entirely true, but I try to avoid doing performance-improvements, as long as a certain part of the code is not a problem (which reading from a file is not). Logging Configure your logging correspondingly. Check your Logging API's performance guide. RabinKarp When I call the search method 10'000 times, I got ~9 millis, using indexOf, I got ~1ms. Again: This type has added complexity, without being a problem and without measurement. HTTP Your main bottleneck will be the http processing. If you can avoid it, avoid it. If you can reduce the amount of requests (called remote calls in general), reduce it. It - mainly the latency and the performance of the backend system - is usually the only component, which you can not influence. 

Depends on the context, or how the rest of the method looks like. With the exception, it's clear, what the method does - but Exception messages shouldn't describe what the intention of the code is, right? If you had something like 

: The method name is not clear, I had to read the method to be sure, what's going on: It deals the first two cards. Maybe . Even though, many are familiar with the Black Jack rules, not all are. 

... if possible. In your case: Try not to send one json string per line, try to send as much as you can. 

Please don't do that. Declare variables line by line. Btw, what ? In maths and physics, it's usually called velocity. 

($URL$ The first one doesn't match, so that's an argument against decorator. You say, you decied not to modify your existing service, because it's "hard to unit test", with all the dependencies. In my opinion, the usage of the decorator pattern makes it more complex. In your case, you only have two actual implementations (original / extension), that wouldn't be too complicated, but if you have just one more implementation, it will be horrible, because A can composite B, B can composite C, and so on. So it's very hard, just to understand how a specific composition works, especially in your case, when states of an object will be changed. If you're argument will be, "well, it's only two implementations", that will be an argument against decorator, too. What I find amusing: You decided to use decorator, because it's hard to test. Well, if something is hard to test, it's usually a sign of a design problem. Or bad test code. At first glance, it doesn't really seem very complicated - if we're talking about unit tests, and not component tests. I mean, most of the methods just call other services. When I look at , the things that have to be tested, in my opinion: 

Basically that means, you're very inexperienced in java itself and you can't provide an easy and well written solution for a rather easy problem. Why I wouldn't give you the job, if you were a junior with a degree (applies to senior, too): 

In general, the Decorator pattern is a nice thing, if you don't overuse it. And with overuse I mean endless wrapping of instances and super-calls. To answer your question in the last paragraph: Yes, you should in my opinion hide as much as you can and provide concrete cars with a factory. Just think about debugging the method in your last example. That's a lot of jumping around until you exactly know what is happening, and it's only sample code. Also: You're mentioning that this is a demo and you want to use that pattern in production code. Without knowing what the concrete use case would be, we certainly can't tell you, that the pattern will solve your problems. I somehow have the feeling, it's the wrong choice. I think the decorator's strength is, that you can add behavior, but more important: you can add/change behavior at runtime - and I don't see that in your example code. Hope that helps... 

Dude... where to start. I even have a hard time to somehow group the issues. I'll just go line by line, I guess... oh and disclaimer: If sarcasm is found, keep it. And this will be kind of a code review I'd give my co workers. Welcome to the real world, I guess. MK_7 Quite bad naming all over the code. What is supposed to mean? Seventh level of Mushroom Kingdom? Quite a fancy easter egg, but keep those for a start up, not while doing your PhD, man. Comments This is the worst: 

In general, it's easier to learn something if you start easy. It's better to learn driving a car in a small car than in a 1000PS Koenigsegg. If you're not in that learning phase, it depends, if it's a 'throw-away' app or a productive app. To your code, I just reworked a small part of it, to give you an idea 

Some additions to the other answers: In those circumstances, it's usually always a good idea to ask yourself the question: If I were to exchange the presentation layer, what part has to be changed. In your case, it would be printGrid(), printFinalStatus() validateMove(..), the main method which takes user input. Question 1: Yes, usually main() just makes an instance of an object. Again: If you would have a GUI,... Question 2: Yeah, one method should do one thing, the thing it's named for. So, it basically checks, if a game is won, but it has to check three things. The 'three things' part is more of a readability-issue. If you have three methods checkRows() / -Columns() / -Diagonals(), it's much easier to understand. Just think about having a bug. If you are in the method 'checkRows(), you know, that the error occurs during that check. If you have everything in one method, you have to figure out that part first. Question 3: "Tell, don't ask" ($URL$ In the main, you ask the turn number, and you ask if the game is won. Make a method 'gameOver()' or something similar. To the code itself: It's actually very clear and understandable. A bit too much nesting for my liking, some conventions I don't like ({ on a new line), but nothing serious. You did group the problems into subroutines, which is a good start. I think if you put a GUI on top of the game, you will learn a lot more about OO, how to decouple stuff from other stuff, which type should be responsible for stuff, and so on. My tips: Google SOLID, five core object oriented principles. Start unit testing your code, google JUnit. Hope this helps, slowy