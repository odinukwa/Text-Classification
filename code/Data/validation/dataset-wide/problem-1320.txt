Caveat: I've never written a line of C#, nor do I know anything about its compiler. I think that the approach taken in your code could be considered the more modern approach. It is definitely more suitable for human consumption, and it makes it more easy to test individual parts of the algorithm. With luck it will compile down to very similar byte code too. But, your code is inelegant in that you loop twice skipping alternate elements. You also have a bit of smell where you have the code . I'm not sure what the accepted usage of Tuples is in C# but for internal use I'd have thought a single function that returns you an (insides, outsides) would be acceptable - if not a little helper class with two elements. This would modify you code to begin (pseudo-ish): 

Are you changing the fields that you expose from your objects depending on certain conditions? On the whole it would be best to use reflection only as a last gasp. Gson works fine with collections in general see the documentation over at Google. If you want to exclude some fields from serialization then you can use the annotation, as documented here. This requires you to annotate all fields that you want to serialize with the annotation, and to use a builder to instantiate your Gson Object like so: 

In general your code is a good start. Keep going :) However the class should be refactored. Issuelist: 

Classes are included manually Instead of including classes manually it is recommended to make usage of the autoloader function ($URL$ The advantage is that you don't have to worry about including a class. 

The code became even better readable and when the validation has to be adjusted it is obvious where to make the changes plus you can validate the Route at any line in your software with the guarantee the validation is up to date. Approach 2: Move the assignment to a respective setter and throw an . 

As you notice it is better readable. From here there are two approaches how the code can be optimized further. Approach 1: IsValid-methods should be created. These kind of methods performs a validation. 

PHP-tags are closed It is not recommend to close the PHP-tag. It can happen that you have an empty space after the closed PHP-tag which leads to error. Not closing them reduces headaches :) 

Script is terminated in the constructor The script should not be terminated in a random class but by an . The type of the exception decides wether the script has to be terminated. Commonly a leads to a termination. Possible Route class 

This is an addition to other reviews. Code Quality: include 'home.php';: In the context of your shared script it's not obvious what it does. I recommend to rename it to e.g. . Further depending on the content there are other more beautiful ways to handle "that". require_once 'class.user.php': Including classes manually shouldn't be practiced anymore. Okay, maybe in an application which has like 3 files in total. However, in larger applications you should use feature provided by PHP using . So, when you try to instantiate a class PHP automatically tries to include the class once if it does not exists in the current context. View & Business Logic are not separated: Nowadays view and business logic is separated to provide a better overview. Further it grants a better maintenance if implemented correctly. Check patterns like which stands for Model View Controller. Other header("Location: index.php"); You perform a redirect without specifying the reason like . 

So, I'm not sure how to answer because I don't understand the use case, but here are a couple of thoughts. If you are defining some data that will never change and is well understood then you could consider using an enum: 

Firstly, underneath everything Javascript is an event driven language so I do not think that there is anything wrong with using an event driven design pattern if you are comfortable with it. Events are a great way to be able to interlink different components of your system without exposing the inner workings of them (loose coupling) and they add queuing by default. However they are more complex, they make it hard to trace behavior which in turn can make them hard to debug. I think that you would get a cleaner interface by developing using something called the revealing module pattern, there is an excellent resource on various design patterns by a guy called Addy Osmani at adyosmanio.com and the revealing module pattern specifically here. This (or a flavor of it) is commonly used in jQuery plugin development which you can see on the jQuery advanced plugin development page (see Keep private functions private). By following these principles you can keep the private stuff private and only expose the functions that you want the calling code to have access to. You mentioned specifically , and so a quick example of how that might look. 

There are both empty methods and methods that return always true : When a method body is empty it usually means you have not implemented its logic yet. It is possible that one forget to include its logic but calls the method which can leads to a difficult to identify bug at a later time. Therefor I recommend to throw an with message . , : Why does this method returns true/false anytime? Does it switches tags on/off? , : These methods rather append, do they? Or does this word describes appending as well? 

As others mentioned the code is not completly OOP. A real OOP application does not contain functions but classes and methods. Well, except of the file that includes the class that initialize the application and the autoloader function - AFAIK function expects a function only. The autoloading part is missing as well which is part of dependency injection. I recommend to get into it. In the constructor of class User you do not validate the email etc. that are stored in the session. They should be a) passed as arguments to the constructor and b) validated. E.g. in the method. Another point is the php closing. To avoid errors never close php. It's hard to figure out a space or another character after php-closing. 

There are global attributes with the access modifier An object is responsible for its valditity. As of that its attributes has to be setted via setters always and the attributes has to have as access modifier either or . 

If you cannot rely on a selector (like I used above) to find the elements that you are interested in, or if you cannot add classes to the elements when the page is assembled then you could add the class in code: 

So, if you're clever about getting an index in there you could write the algorithm (without validation) in just 3 lines and you'd have done a bit of functional programming which sets you up nicely for playing with a new language. 

-. When you are coding your method start thinking in templates. Sure it's not necessary now, but it costs nothing to write and you've got a utility function you can use forever. One thing that would concern me about this method is the Cyclomatic Complexity due to the number of loops and conditionals. Consider how you could break things down, e.g The content of your loop can be broken out into code which finds/verifies the rectangle is complete. As a rule each method should have a role as discrete as possible, again this makes things more testable and more readable (when coupled with sensible naming). 

Finally, you say you have read about the factory pattern, that is ultimately what you are playing with here. Note. I think Enum naming should use the singular (Type) rather than the plural (Types), you are not selecting an Object of type Types as your Object (Types.DOUBLE) represents just one type. 

I suggest that the word "new" is understood to mean object creation and initialization. Rather than , consider . Going one step farther, you might make this a preprocessor macro that returns a typed pointer. (In a post- version, where arbitrary data can be handled.) Something like: 

(Of course, you could observe that is basically a constant in this expression, and simplify the lambda function to just or whatever.) 

This is because a loop would run a fixed number of times, but it's possible to win in 5 moves (xoxox) or it might take 9 moves (xoxoxoxox). Since you don't know how many, you want to "keep going until something changes." That's a while loop. In addition to that change, I'd like you to find places where code is copied, and convert those into a function. For example, all your checks of , etc. The principle is called "DRY" for Don't Repeat Yourself. It applies in a lot of ways, but this is the most basic: if you write code two times, make it a function (or a macro) and maintain it in one place. If you make those two changes, I think your code will be a lot smaller, and easier to understand, and easier to review. I'd encourage you to submit a new review with that code. 

Your and are basically the same function, except for one boolean expression. Instead of passing in the values and comparing them, why not write an underlying function that takes a boolean value and does the work: 

You include an autoloader in the test class. From UnitTests I am aware of a bootstrap file. If such a class exists/can be registered for functional tests as well you should move it to a respective file. 

Not every method has a self-describing name : What does it return? Object Length, Current Line Length, ...? I recommend to rename the method to what it does - . 

There are multiple returns in one method This makes the code less maintainable. Having more than one return means there are multiple scenarios when the method can be stopped. In case of a bug one need to debug through the whole method to figure out the return-point. 

Description: This section describes missing setter, multiple returns and if-conditions. In the constructor of the class Route are multiple returns. This makes the code less maintainable. Having more than one return means there are multiple scenarios when the constructor can be stopped. In case of a bug one need to debug through the whole method to figure out the return-point. So, at this point a switch to if-else-if-else should be performed. Below you see a minimalistic sample. 

Variable definition You sometimes define variables in camelCase and sometimes with underscores. I recommend to use one spelling type only. PHP If function is not part of a class consider developing a database class that handles it. Another option is to add a function to each of your Model classes. This makes your code easier to read. For more details check mvc pattern. In the function you establish a new database connection with each call. You can avoid it by promoting the function to a proper class and define a global attribute holding your database connection. JS In your javascript you have html code. I recommend to either load it with rest of the dom and hide it by default or load it using ajax. I personally compare it with inline css. HTML In html form you have an attribute . It should be in a javascript file. I compare it with inline css as well. "QUOTES" Also see CodeX answer. As tim mentioned and other variables not provided by yourself have to be validated and parsed by htmlspecialchars e.g. to avoid XSS. A bit about security I've added this section due to mentioned XSS. Security is a very complex topic and must not be underestimated. There are a lot of options to implement and grant security. What kind of options you choose depends on your time/budget but also kind of project and data that are going to be stored in your database. I kindly ask you to think wise about the data that will be saved in the database and make researches about proper security measures. There are a lot of PHP Frameworks. I recommend to take a look into some of them as those provide security standards.