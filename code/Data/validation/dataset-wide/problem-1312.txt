can be significantly cleaned up. There is no need to use enumerate() just to get the i variable. The idiomatic approach is to use 'for hjob in historyjobs:'. With the int() conversion already done you can replace the complicated comparison with a simple comparison of the slice of interest. 

Now you need to run the fight. I've created a function that takes two player instances. I've kept some of your logic here (though using abs() is better). The fight function calls the encounter function in a while loop which checks they are both alive. 

A conversion and filter operation can usually be achieved with a list comprehension. Something like this should do the trick. 

This is not necessary if you return data from your functions as above and assign the result of the function calls to variables which are created in the scope of your new() function. As I say, I'm not sure what your doing exactly here so I can't advise on the logic. If you can tidy it up a bit then I'm sure we can help you get to the bottom of it. My feeling is that the code can become much shorter and much clearer than your current version. 

If I understand your intent, you can also create a simple list and return it from the function as a way to remove the listsub global variable. 

It's not strictly necessary to have the dice roll in the character class but that's how I've coded it. The method provides a nice way to present your character. e.g. 

I'm modelling two processes which have been put into a cyclic pipeline - the output of each feeds into the input of the other - so as to work out when they've deadlocked (i.e., neither can progress since they're each waiting on output from the other). I've used the conduit package for this, as I couldn't see an easy way to do it using pipes, and streaming doesn't really look suited to this sort of task. It looks like monad-coroutine would be another possibility for this, but I didn't investigate it further. Define the problem as follows: 

This may not be as concise as your code, but should be much easier to follow and to modify - and importantly, for your purposes, it runs in less than half the time. Other notes - the versions of will normally be faster than the boxed versions, if you can use them; if you're submitting code for review, then I'd think a few more comments in your code wouldn't go astray. I hope that helps. 

(Possibly a hand-coded loop might be even faster than , but I didn't check that.) I'd also suggest splitting out the parsing of input from the actual solving of the problem - no advantage is gained by putting everything into . I'd further suggest that writing makes your intent clearer than ; and that you use s instead of , since this will (a) get rid of extra bits of cruft in the code and (b) allow you to use the package, which already contains a binary search function. It's usually far better to use someone else's de-bugged search routine than write your own. However, if you are submitting for an online competition, that package may not be available. Nevertheless, it provides useful inspiration on how the search may be sped up. This gives code along the following lines: 

With all those bridge_... variables, how about moving the logic into a class representing a bridge? There is much to be done with this code but the basic restructuring is done. EDIT: Refactored the code somewhat 

I would reduce the global variables to the absolute minimum (which is usually none). I cannot work out the detail but the only reason I can see to keep globals here would be if they are continually being appended to and this is not happening as far as I can tell. For example, I think the global variable a = [] can be removed. Your original function. 

Doing the conversion once up front you can forget all the other int() conversions that clutter up your code. This includes removing the need for your mlistsub global entirely as far as I can tell as it seems to be an integer version of the listsub variable. I suspect the following reference to job[0] should reference job[1 ] as it is column1, not column0 that you talk about in other comments. 

Aside from the terrible function name, this function seems to do very little. You could replace the function call with something like this 

OK, your code is a bit of a mess. I take it you are fairly new to python. Read the python style guide and stick to it. It will make it easier for people to read your code. It is not easy to work out what you are trying to do here. As it stands the code doesn't run. However, here are some thoughts. building on @Changaco's answer you can iterate through the file and process each row into integers like this. 

It's a good idea to profile your code (which is easy if you use – instead of , just type , and run your program with the options ) to find out exactly where the bottle-necks are. See the GHC profiling guide for more information. If you do that, you'll find that a significant amount of your program's time is spent splitting up strings into words, and parsing them into s. Remember that a Haskell string is a linked list of characters, and thus not particularly efficient – I found that using the type from the package results in the revised program taking only 40% of the time of your version. (Contrary to the other comment here, the binary search you've implemented seems fairly efficient, that's not where the slow-down is.) Instead of from the standard Prelude, use the version of from ; instead of parsing a line of text using , I'd suggest something like the following: 

I think this problem is of interest because pre-emptive concurrency doesn't seem like a good way of solving it -- most concurrency libraries do their best to help you avoid deadlock, not model processes that have got into deadlock. (But perhaps I'm wrong, and this is easily modelled with a standard concurrency library - I'd be keen to hear.) Also it gave me a good reason to look at some of the streaming data packages (conduit, pipes and streaming), all of which I believe are modelled around the idea of processes that can "yield" data "downstream", or "await" it from "upstream", which is exactly what this problem requires. Here's my code: (NB: contains possible spoilers for the Advent of Code 2017, day 18 problem, Part 2 - but this is not relevant to my question, which is about modelling deadlock with coroutines.)