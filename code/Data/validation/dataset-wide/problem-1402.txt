Just because you mentioned recursion it in your post, here is an example, and also an example of implementing this as an infinite sequence. Pure Recursive Note that pure recursive functions in ruby have to be used carefully as ruby has a limited stack. Recursing more than a few thousand times tends to cause a stack overflow. Also note that this implementation does not include support for memoization, so it does a lot of redundant work. It is, however, a pure function. 

Ruby also has C-style format strings. Use '%d', %f', '%s', etc in the string and then supply an array at the end of the string with all of the arguments. 

Your code is nicely organized, but there really isn't much to the calculation that it would require all of that. All you really need is your enumeration and a variable of how much you've accounted for so far. This code simply loops over the rates and starts summing by bracket until the quantity is fulfilled or it runs out of rates. Any remaining quantity is added in at the highest rate. 

If you wanted to look more ruby-ish, you could convert your switch statement into a hash and then / your input string. 

Some style comments: First, you don't need to put in a class, you can simply declare it and use it directly. Additionally, the ruby preferred style is to use snake_case and if the function is a predicate (a function that takes a value and returns true/false) you should add a question mark to the end: 

There aren't many things wrong. And the code itself is surprisingly short. But this will be a really long review. The first thing that bothers me is that you talk about JSON, but you show an object. That's fine, but you should show how you decode the JSON into that object. But, within the scope of this review, I'll refer to it as an object, which is what was presented. Not to mention that all the links point to s. Now, lets tackle the code! Javascript: The indentation of that object is really off. Not to mention that you have mixed quote styles. 

This should do it for you. It throws an if the imge is invalid or if it can't write to the location. 

What did I say? Declare variables as close to where you will use them as possible. You should have this: 

This will have the exact structure you wish. Simply use to access all values. And done! An alternative with 0 lines of code! 

You don't need the there, since all methods are by default (since, at least, PHP5.3). You should use type hinting. This basically limits the received value to a certain type/class. This is how you should've done it: 

As the title says, this batch script installs the XignCode Bypasser. Xigncode is a software bundled with games to analise running programs and prevent cheating. (Sometimes, it prevents the game to load at all on the newest Windows releases.) For this, a bypasser was created that disables this check, allowing players to run the game (if they couldn't), mod the game (One Click Tool, for example) and (if you want) cheat. Copying the files manually is a boring task that can lead to mistakes (copying from the wrong location, deleting the Bypasser by mistake, ....). For that, I've made the following batch script that does all the copying and extraction: 

Hopefully a bit to get you started! I whole heartedly recommend this book if you're coming from Python, it's a short in length but really comprehensive and does a much better job than I could at explaining how to write good C++, and by the man himself - Stroustrup's "A Tour Of C++" 

Now the issue is with how do you tell in advance what the blocksize is going to be i.e. ? The way the code stands now, it may not work because we need some way to let the host tell us the blocksize before we actually start processing the audio in . We need this because now the needs to be fully resized the same as the blocksize (and filled with zeros) before during the setup time. Is there a function that you can hook into that will tell your plugin what the expected blocksize will be? (Sorry I'm a JUCE user I don't know the specifics of what framework you're using but for example in JUCE there's a function called that gets called before processing the audio with , this would be a perfect place to resize and zero ). Hopefully you can figure this bit out! 

This would get you by for now. The 'best practise' would be to make your FFT size independent of whatever the size is. That way if the user changes the soundcard block settings, they will still hear the same thing. i.e. lock FFT to size 1024, soundcard block size variable 64-512 This is accomplished with a circular buffer of size 1024, you fill this up sample by sample with input, then when it's full you call on those 1024 samples. Hope these are all helpful tips to get started! 

This, again, is a very simple code. This is my 2nd polyglot question and this time I've tried to do something that I miss sometimes in Javascript. PHP has the function, but Javascript has no direct equivalent. So, I decided to make one that works with both languages! Here is the code: 

This code was written purely for fun, but that's not an excuse to write it poorly. Still, I feel that there's something to improve on it. Besides of any performance issue that there might be, and some readability crimes, what else can I improve in this code? 

Notice that you have to use instead if you are using this in JSON! As I refered earlier, I would review it as an object. 

I hope you can understand everything and hope it is clear enough for you. And hope it really helps you. 

Adding on Flambino's answer, I just have to say that your code breaks on IE9. Since you didn't specify which browsers you want to support and which versions, I will assume you want to support all modern browsers plus IE8. According to the MDN page about , this method is only supported on IE10+. Currently, Windows Vista SP2 is supported (until 11th April), which only supports IE9. IE9 can still be installed on Windows 7, and may be the default browser for some. Also, devices with Android 2.1 will throw errors, since this isn't supported. 

Update 1: Added second enumerator and search function, fixed a bug Update 2: Added lazy enumeration and profiled code against a tree with 10K nodes. Searching for nodes with values in the middle, the new lazy code runs about 2.5 times faster than the poster's original implementation. Also running rubocop, there are no Cyclomatic complexity warnings 

After the worker has completed, it will call the event, where it will return its result (which should be the encrypted block and the block index. The event handler should write the encrypted block to the corresponding index in the output file, and then add the worker back to the list. Repeat until all the blocks have been processed. 

Set Unions Looking at your code, when you loop through the attrs, you are breaking after you find the first key that is in and in and in the passed . This is also known as the of the arrays. As such you can simplify the inner loop with: 

Ruby has several ways to conveniently print text. First there is string interpolation. You use double quotes on the string, and use inside the string. When ruby parses the string the code is executed and the results replace the code in the string. 

If you can't do that, when you start the new thread, try setting the thread priority to low or tweaking other related settings. 

I don't know if it is prefered or not, but if you wanted to get rid of the , you could do something like or instead. Naming seems ok. No comment. I don't know. Your regex for is suboptimal. will pick up any character, but you really only want digits. Something like would be more accurate. 

Please, don't do that! Don't set anything on the variable! The points to the object. You can use it by itself or using the dot notation. That variable is the only way to access the current on a . Please, leave it unset. Use or something. 

Closures are a really nice feature that came with PHP5.3, and they weren't being used to their full potential. Closures have the method , which generates a new Closure binded to that object. This allows to use the variable inside the Closure. It helps the fellow programmers that decide to use this to write in a more natural way. The best part is that there are no kludges needed! The method will look like this: 

At least I find it easier to read. Way easier! Other than that, it seems pretty much day and night, comparing to the old code. 

With the replacement as an empty string, you would remove the double-space in . Normalizing it to a single space will return instead of minifying into . 

One thing that makes me cringe is the indentation. It really is off. I had to look 20 times to that stray brace to realize it isn't closing that . 

I always suggest wrapping the code on a , but I leave it for you to decide if it is worth it or not. 

As it stands, your code is pretty much unreadable. It is easier to read the minified version of jQuery than that. Yes, it's a mish-mash of super-clunky almost-minified unreadable code. I will review the little I can understand: 

Sorry I wasn't thinking clearly about the issue previously! The simplest way around this issue is to make larger than you could possibly need i.e. larger than the largest possible block size, then if a smaller block size is actually dealt with in , it will only access the start of the buffer. Note how we are now sending the block size through to and now iterating over (since is overcompensated). 

The solution is to create work areas beforehand as a member variable. This is created to be the right size at setup time before playback then the can write to it as it wants. So (now renamed ) is outside as a member variable... 

Firstly, does the program give correct results? If so, how do you know? Without going into extensive unit testing, checking your results against a Matlab prototype/your Python implementation is probably good enough for now. I can't comment on the Gnuplot functions as I don't have it installed, also but some general C++ tips are... 

The main point is really the heap allocations in the . Only after it might be time to look at implementing and benchmarking the FFT performance vs. Apple Accelerate vDSP :) There are other things you should avoid in time critical code too, for more info see this section of this talk... CppCon 2015: Timur Doumler “C++ in the Audio Industry” 

The main thing that I feel you should change is the heap allocations inside the . With realtime processing like this audio application you never want to call within time critical code, either yourself (or indirectly like adding a , etc. etc.) The reason it's unpredictable how long a will take. You have two lines that call new either directly/indirectly