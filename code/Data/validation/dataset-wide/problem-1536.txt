Why use a linked list at all? Seriously, what does the Node concept buy you? This problem could easily be solved with a primitive array (... or an ArrayList, or LinkedList if you were not using primitives .....). If your data was stored as an array, it would be as simple as: 

The use of the code makes things hard to follow, and they appear to be completely gratuitous. The conversions from to and from Float values are easily done with regular casting of values, and the input code is unnecessary too. The repeated use of makes the code hard to read, and, worse, you cheat a whole lot with this line: .... that's just really, really horrible. You don't actually use except to get their length in You should just do some subtraction instead of getting the length of the string later. But, what's all moot, is that if someone enters a value that's a whole number, everything will break. If the user enters the value , with no decimal point, what then? As for the power function, consider using . Then, use package for conversions. I would consider taking the input value as an argument to the program instead of trying to read standard input. Just use (if it exists). So, really, what you should be doing is something along the lines of: 

You are not doing your tests 'appropriately', and this is part of your issue. there is no need for the 'supplier'. The supplier is an instance field, and, it's an extra level of abstraction that is unnecessary. JUnit has concepts at play that allows it to run tests in parallel. Having instance fields that are not part of the before/after sytsem can lead to problems. Instead of the supplier, you should have an abstract method, and your @Before method should be changed: 

About that loop.... why do you have a magic number ....? What does it do? This code needs more testing... and magic numbers need to be removed. 

I have some test cases, and other interesting tidbits in this ideone. I suspect the computation will be faster than the lookup table, and certainly faster than your solution. Performance is not always the target, but I am putting together a performance testcase anyway. here's the performance numbers, with an interesting lesson: 

Note that the above code puts a waiting process in to a spin lock (100% CPU) instead of locking. This is the same as your code. My preference would be to use a more traditional Lock (or even synchronization) and block threads that are waiting. 

I don't like that you ignore the required format for UUID's, essentially you say if it has 4 dashes it's cool, but, really, the number of digites between dashes is significant, and you ignore that. I feel that you should be calculating the long bits at the same time as you are validating and counting the dashes. Repeating the loops afterwards seems redundant. If you are looking for raw performance, a trick I have found out is that lookup tables make a big difference... I will show an example in a bit. 

Style - good The TDD is a great way to start. You can see the benefits already, especially in the fact that it was easy for me to copy your code and run it locally, and make sure it works (not that I doubted it, but it's nice to check). There's a typo in a method name... I know that's a silly thing to point out, but it is the first thing I saw. My spelling (actually, my typing) is often criticised, and as a result I am sensitive to these things. The method is missing an here: . Beyond that, though, the code is really neat, and well structured. Two nit-picks.... in your bracing style (yeah, yeah, I know, not the bracing....!) But, you should be consistent with the space before the opening brace. Sometimes you have a space before the brace, and sometimes, not. You should have a space. So, for example, the lines: 

it returns return-statements inside return a value now the input includes the 'maze' (instead of being a static variable) there are no references to , just to the array it has an internal variable it changes how it calls 

Note that I have chosen to use real variable names, instead of 'a' and 'b'. I find this helps me, even in functional declarations. OK, so is a lambda expression that returns true in the event that two positions are unsafe relative to each other. While we are talking functions, here's a part of the scala that needs to have a matching concept in Java: 

Once you have the class instances in the map, you are singing ;-) That's enough for the reflection, but what about the rest? Your runAllProblems() does far too much. At a minimum I would expect a method that contains: 

That code would make your methods block in other threads... I have no volatiles or atomics... only synchronized. I use primitives, and arrays to store the data. This is fast, and reduces memory usage. I don't do any math in the time-sensitive methods. All I do is store away the . The math is all done in the get methods, and outside of the synchronized blocks. 

Finally, I don't like that you have variable-length results from the conversion. You should ensure that all hashes of data with the same length have the same length of output... -left-padding with as needed. It is possible for something to hash to 0x0000000000 (hex).... which will give you 0-value . 

Your method should have the same generic patterns as above. Now, the two Hashtables... they should be Generified (your IDE is giving a lot of warnings, right?) 

Algorithm Your code is searching the grid in all directions for each word. That's not a bad approach (it gets the right answer), but it becomes complicated because of the palindromes aspect of the problem, and because you have to search in each direction for each word. There's a relatively simple trick you can do to drastically reduce the search cost of the problem.... you can search only right, down, and diagonally down and diagonally up to the right (i.e. half of the directions to search), and you can remove the palindrome checking, if you compute the palindromes before searching. So, for example, instead of searching for in all directions, search for in half the directions, and in those same directions too. If the search word is a palindrome () then only search for it once.... You can put all that logic in to the method too: 

There is a race condition in the above, but I would probably solve it with documentation, not logic. The race condition is that there is a moment when you add a member, the size will be incremented, but the get() could return null in one thread in the instant before the value is set to the new value in another thread. If you document that the container can hold null values, and that the iterator/get may return a null before the value is added, then you have the bonus of being able to support null values in the data too. Note, it would be relatively trivial for the calling code to handle null return values. There's a second caveat. I set up the iterator to loop to the last value that was added when the iterator was created. If you change the line: 

Note a few things in there.... my Computer is a 4-core i7, and it has slow performance on your locking when there's 4 threads at 100% (two producers, 2 consumers). Something 'odd' happens then. The rest of the time it is fairly predictable. The single-sync code is slower than yours for simple cases, but starts performing better than yours under high thread imbalance - where there are many more consumers than producers, or the other way. Double-ended Synchronization Still, the results are interesting for their variance.... but, what if I used a similar double-ended synchronization system to your double-ended locks? What would happen then? 

The advantages of these changes is that each element has a unique ID that will help resolve looking for things in potentially multiple places. Additionally, having a reference that is independent of the display name allows you to change properties of the data in a single place, without having to redo many places in your code. For example, you could possibly have multi-language support directly in the XML with something like: 

EDIT When I wrote my review I assumed the HTML was supplied (I did not realize that you wrote the HTML as part of the process). This makes some of what I suggested a little less relevant... Still, you ask about the third paragraph: Consider the following: 

There is a major bug/issue, and also stringing together three very different recommendations here. Bug/issue in the Game-Of-Life you are supposed to scan the entire board, and only then apply the changes. You are applying changes part-way through the process (as you check each cell, you change its state). So, if you change the cell in one location, when you check it's neighbour it will affect the results). You need to 'store' the counter for each cell until you have completed the scan, and then re-set each block in the board. Essentially you need the following: 

Note that I also put the end-of-line comments to be above the commented code. Since comments tell you what to expect in the code (and why), they should be there before the code, not as an afterthought. The matching mod and multiply methods for both and arguments, are a bit messy, but hard to avoid. What's more problematic is that you don't have matching argument symmetry for add and subtract. You should have versions of those. The parameter names and for the function are poor... multiplicand and multiplier are messy too. maybe x and y are better ;-) The final comment I have is about the Javadoc comments on your methods. They are incomplete, and don't have @param and @return values. Does Lombok fill those in magically? As for performance, I can't see anything that would make much difference. The fixmod method irks me... I don't like ternaries in tight loops, they have implications for branch predictions, but, even though I could match the logic with a non-ternary expression, it was just as efficient, and not as readable. I don't believe performance can be improved much. 

Now, that may not look faster, and you're right, it is probably not faster, but, if we replace the second loop with: 

There are a lot of things to cover here.... but, some forewarning, you have completely over-thought this problem.... and your algorithm is far from 'the right one'. Given that I am suggesting that the algorithm is overkill, there are two things I can do: 

Streams are not designed to naturally fit every computational situation in Java. As you have found, you have needed to perform a number of compound/stream/Iterator/array state changes. 

Now, whether you are marked on that, or not, is a different story. I have found that the academic application of marks for comments is often contrary to the need for comments... particularly when the code is good code. Good code seldom needs comments. let me say that again. 

It took me a while to figure out your code. I have solved this problem a couple of times before, but found your code hard to read. In large part, because your variable names are misleading.... 

The above code initializes 1000 boolean members, and sets them all to true. Now, with your sieve like that, you can simply: 

A class called should have a primary method called or something. It took me a moment to discover that is the primary method. That's doubly confusing because it is a hungarian-style name, (setting an Object), but it is not an you pass in, instead it's a . I like how you have made the method final, though. I would instead have something like: 

A logical optimization here would be to remember the primes you have already calculated. Consider the theory: 

In PostgreSQL, you can use the mechanism to help. It still requires a subselect, but consider the following query: 

Then, we use that Stringbuilder to cache the characters, and append them... but we are smart about resetting it when needed..... 

as I look at that specification, and the code, I can't help but think you have missed the 'simple solution' that they were looking for..... Now, the spec says: Your implementation must implement the FlattenTree interface Did the spec include the interface for the ? If it did, that's horrible, and as a person being interviewed I would say the Tree interface was broken. If they jsut gave you the interface definition: 

Your algorithm is plain \$O(n)\$. If you double the number of nodes, your runtime doubles. If you double the number of nodes at the current level, you also double the total number of nodes (or are you planning an unbalanced tree?). Your algorithm is OK, but there are some deviations from the classics... The use of a queue here is not quite right, or, rather, the way you are using it is not taking advantage of its queue features. In fact, you are using it as a List, and not a Queue. A Queue should be using the methods , and (or , , and ). You are using the iterate method though instead. Also, instead of emptying the queue, you create a new one, and throw the old one out. This is inefficient. A more traditional implementation of the algorithm will use a single queue, and add a 'marker' in the queue to indicate the end of a 'row' in the tree. Consider using 'null' as a marker, to show you have reached the end of the row, as follows: 

Your print-grid method would likely benefit from some Linq, but what you have is OK.... rather, it is very readable. Linq (or using a StringBuilder) will improve performance by reducing the calls to Write. 

With the above code, 90% of your rolls will do just one test, 9% will do 2 tests, 0.9 will do 3 tests, and so on. Note, also, that I have used braces even for the 1-liner blocks in the conditions. This is a good practice and it avoids bugs when maintaining your code, later. 

The synchronization in the code is in some places overly broad, and in others, it is absent where it is needed. synchronizing on in your method means that only one thread can be accessing the instance at any one time. This defeats using the concept entirely (where only a small portion of the map is locked and other portions are available for other threads). The granularity of this lock is overly broad. Inside that lock, you add data to (and potentially create) a instance. This HashSet is then used in other methods, but without any synchronization. Those other methods may have issues with concurrency because they are not included in any synchronization at all.