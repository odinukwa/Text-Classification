Why set the value of the checkbox to if it's not ? Shouldn't it already be false? Or can the value of a checkbox be "null"? I can't remember, but it's probably worth a comment if you're doing this to make sure the value is false instead of . 

But wait! Didn't I just say not to create dependencies in the constructor?! Yes. I did, but that's really just to make things easy to test. By having an overload that does allow dependency injection, we have the ability to easily test in isolation. Nothing says we can't also provide a convenience ctor that creates the dependencies for production code. We've just made things more flexible is all. 

Why are you setting the default value to ? An array is already null by default. If you want a version of this method that doesn’t take any methods, use an overload with no parameters. It’s much less error prone than intentionally introducing nulls into your code. 

tells me almost nothing about what that class is. It's enough to guess that's it's serialized from an file, but that's about it. Even then, it's a name that tells me about implementation details instead of what the object represents. 

There are two things "wrong" with your Abstract Factory pattern. Neither of them are terrible, but it does mean that you've not implemented the pattern, but some other type of factory that I don't have a name for. 

You've got two options to help solve this. You can either skip the verbose method of using argument identifiers and simply not pass the missing argument into Find, 

You're already aware that this is a linear and slow search method, but as you pointed out, it shouldn't affect overall performance much. What I wanted to mention is that there's a lot of here. You're already referencing the library, so you should go ahead and strongly type these if you can. 

Fun fact though. The color constants are dependent on what version of office you're running. This may render differently in Office 2003 than it will in newer versions. In fact, isn't even available prior to 2007. To be compatible with earlier versions, it's best to use RBG values. It's been mentioned a little bit already, but I'd like to mention it again and challenge you to create a few classes for your game. 

The variable names here are pretty obtuse. What exactly are , , and ? They're related somehow, but that's all I can readily gather from the names. Also, commented out code is dead code. Remove dead code. If you're worried that you'll need it, then I recommend you start using source control of some kind. Personally, I like Git. 

There are two different ways you could go about DRYing this up. 1) Create a subroutine that takes some parameters. I want to show you this first, because it's very important to learn this concept. Anytime you see patterns like below, you should be extracting out new subroutines or functions. 

You inject the , but not the various repositories your requires. You should also be ctor injecting all of these dependencies, and using Ninject to bind them. If you can't inject it, you can't mock it, and right now you can't do either with your repositories. 

Once you get accustomed to this, you can begin to (at least partially) gauge the quality of a routine by looking at the distance between a variable's declaration and it's last use. Speaking of, let's talk about that comment... 

So, you have a couple of issues here. First, your question... What I've done in VB6 (which your question was originally tagged as) is create a module that is responsible for reporting errors and logging them. I would imagine seeing your error handler look something like this. 

What does represent? Is it a name? Full file path? What is it man?! =;)- Seriously though. I've no idea. A better property name is in order. 

The other would be to make the method private and introduce two separate methods that call the private one. Another way to go is to give the arg a default value. The example I showed is the "quick fix", but it's hard to maintain. It'd be better to improve the API a bit. 

First thing's first. The indentation is all jacked up. There's not really a standard for formatting SQL, but as a rule of thumb, , , and for any (sub)query should be at the same indentation level. 

You're not actually setting the list. You're appending to it. Setting it twice will result in simply adding all of the new values to the end. 

Albeit a matter a preference, I prefer the latter because it puts the variable that's being written to completely on the left of the statement. Doing it this way also reduces the total number of operations. (Not that it's a performance bottleneck anyway, but it's important to know how to spot these things when you eventually do have a bottleneck you need to take care of.) 

In order to add any new styles to your code, you potentially have to make changes to three places in your code. Minimally, you have to add it to your enum and your switch. A little OOP can go about making this much easier to deal with. Particularly because these all do a very similar thing. You could extend this indefinitely and easily by inheriting from your class and overriding . First, you would need to change the signature of in the base class so that we can over ride the method. Second, change it so that only the default case gets executed here. 

There are a couple of other little improvements to be made though. You need to alias this column. Otherwise you'll end up with a mile long name for it. (Depending on your RDBMS. I know SQL Server will name it with the expression string.) The second thing I would do is declare a variable for . You're using the same parameter in two places, so it makes sense to declare a variable. This will also make things easier if you should decide to wrap this query up in a stored procedure. 

There's a fair amount of setup and teardown code. I'd change many of the local variables into fields, and then add a and method. Extract as much of the test rig as you can into these methods. Always remember that test code is production code too. It's just code that we don't ship to users. It deserves to be written to a high level of Single Responsibility and DRYness as well. By moving all but what's different out of the tests, it's easier to highlight what it is that we're actually testing, rather than getting lost in a bunch of boiler plate setup code. 

While your function does not break my Single Screen Principle, I do see an opportunity to clarify it by breaking it down into a few distinct functions. Keep in mind that VB6's operator does not short-circuit. This means that when checking to see if is not a number, the code will evaluate both calls every time. So, first, a quick refactor to resolve the slight inefficiency. 

I would expect a Tokenize method to return a stream () of s rather than modify state. This should be a pure and idempotent function in my opinion. 

This doesn't do what you think it does. The only variable declared as a here is the very last one (). The rest are declared as . Properly declaring them as types will remove some overhead. 

There's a lot to cover and talk about here. I'm going to take a line by line approach, so this review might seem nitpicky (and it probably is), but there are some seemingly innocuous things here that can cause bigger problems given a chance. 

It's not quite as DRY, but an here instead of an improves readability. Considering it's merely assignment, I think it's a good change. 

I don't understand the trouble you were having with returning your model from . You shouldn't need to pass it by ref. 

I'm not sure how to optimize your code, but let's talk about those variable names. Naming is hard. It's doubly hard in vb.net, because it's case insensitive. That fact makes it difficult not to step on keywords like . I don't like recommending this, but without a being able to use and to differentiate from the keywords and , you could de-vowel it to and and still have a variable name that's easier to understand than . I get, but what does that date actually represent? ,,? What do those mean? I vaguely understand what is, but then I hit this. 

Your view is calling methods on your presenter. The view shouldn’t know the presenter exists. Instead of calling the presenter directly, the view should raise events that the presenter reacts to. The difference seems trivial for what you have here, but it can make quite a large difference on a larger more complex system. Oh, and I should mention a few other things. 

This is really very good in my opinion. I like your use of interfaces, and an abstract base class seems to be the right design choice to me. The double checks here bother me a little bit though. 

The Ugly: You're using Structured Query Language to do procedural programming. t-sql just isn't designed to do that efficiently. The code has to loop twenty times for each "record" you pass into it. I'm sure this works great for 1 row and is probably still good for 20,000 rows, but what about 200,000? 2,000,000? This just won't scale well. A set based approach would be better. You could take two different approaches to this. What you do may depend on what you're able to do. 

has a definite smell to it, but I suspect that's because you're manually changing those prior to each run. I'm not sure what to do about it though. 

Yes, it's nice to get a parse error rather than a runtime error, but that's all you're gaining. It seems a little silly to inherit from a class and then have the exact same functionality. 

Looks fairly clean to me for the most part. You could reduce nesting a bit here by extracting a boolean method in the code behind. 

As for a simpler method for getting a byte at a particular place in a string, I think it's a wash for VB6, but there is an alternative. Create a byte array then return the byte at the index you want to retrieve. How this is done is different in VB6 vs. VB.NET. VB6 The function to return a byte array in VB6 is StrConv(). 

I see a couple of issues with the code, but I'm afraid this isn't exactly the answer that you're looking for. Hopefully someone a little smarter than myself swings by... Anyway, in , you have this call. 

I don't see anything wrong with the comparison in the example you showed. To me, at least, it looks like exactly what you need. I think that perhaps your issue with it comes from all of the repetition in your real code. 

This works great for now, but what happens when I want to expand it to include other document types? I'm thinking a enum could go a long way toward making it easier to extend, as well as improve readability. 

I really don't like that there's sooo much logic in your constructors. Constructors should do the bare minimum required to make sure your class is ready to use. They also should have next to zero possibility of throwing an exception. Move as much of this logic as possible somewhere else. Probably into some kind of class factory, but I'll get to that in a second. I don't think these classes should know how to query the data from the website. In my mind these classes should be pretty "dumb", consisting mostly of properties. In order to dumb these down, you'll need to introduce a Data Access Layer, or DAL. Your DAL will have the responsibility of querying the data from the website and creating new instances of your models. This is the class factory I mentioned earlier. 

It's really not a great idea to return a from your method if you can help it. You've effectively bound your code to always using a list. What if your client wants to use a ? You'd have to do some messy casting. By all means, use the Linq that @TravisJ provider, but you should change the signature to return a instead. 

That should give you a pretty good start. It might take a couple of iterations until you really have something manageable. It's completely possible that you'll find the variable is completely unnecessary once you've implemented the temporary table. 

This is probably fine so long as you're only interested in mocking up a project with a single code module, but you'll quickly find yourself in need of a proper collection of modules. This method should have an overload that takes in an , or perhaps an method would be better. 

Two small things I noticed at a glance, both involve this code and it looks like it made it into your refactored version as well. 

This looks like a very nice implementation. An iterative solution (without linq) would only serve to obfuscate the code in my opinion. I've found that when working with trees, recursion is a much cleaner and understandable method. At first I thought about suggesting that you change the method from to returning a list, but I think that would be less efficient than this. The only thing I can really note is that you should always use braces. It will prevent future bugs. 

Same with the very next line. Maybe it wasn't a mistake. Maybe you did this intentionally because of all the noisy daisy chaining your logger needs. Try extracting a few small helpers to reduce the noise.