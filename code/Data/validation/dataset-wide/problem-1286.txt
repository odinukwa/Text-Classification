I've actually implemented the same functionality in the past, so here are my comments. Wrong behaviour? It depends on what you can consider wrong. Consider running your own example and inputting . The 2nd will be left in the stream buffer and will be automatically assigned to your 2nd variable. This clearly causes weird behaviour, but it is the same behaviour that occurs when normally using . Suggestions The following are what I consider to be useful features for such an utility function. Better interface In order to provide a nicer interface, you could instead read a single value from your stream and then discard anything else that's been left in the stream buffer; calls to will always return one single value and successive calls won't be forced to take what's left in the stream buffer. Example 

Welcome to Code Review. This queue implementation is not truly concurrent-ready. Arbitrary initial capacity 

3.2. Example 2 This example displays a more "real-world" use. Instead of having the function call , that would be done by threads consuming from the data member. Since this is an example, I've provided a simple function that works only for free functions; overloads can easily be added to deal with functors and member functions. 

Consider what happens if returns value A, but before the expression is evaluated, is changed to some other value B. This could cause to say that the queue is empty when it isn't or that it isn't when it actually is. Conclusion These are two of many issues that are currently in your code. I've decided to stop here since that's a pretty bad problem. This current implementation if not safe at all. I recommend you do some more reading and learning about thread interaction. Good luck. 

Imagine a first call to in thread A makes it inside the statement and gets stalled just before executing . Now another thread B calls and successfully gets past ; the writer now has a value different than reader because of the compare/exchange operation. However, the store of an element has not happened yet since thread A is still stalled. What is thread B going to pop? It's going to access whatever garbage memory is at that location. Issue #2: Malfunctioning empty function The load from and the load from followed by a comparison is not thread safe. 

3. Sample usage Here's some sample usage to show how a user can get the return values. Basically, the user would send in their function/functor to the dispatcher and would take care of the rest; the dispatcher would return the from its submit-a-function function. 3.1. Example 1 This example is pretty much just a test of the template deduction rules and shows how you can use a collection to erase types. The main feature is that you can have a collection of functions that all have different signatures and return types. 

1. Description 1.1. Functionality The objective of these types is to provide type erasure for any function while maintaining the ability to provide a return value through a combination of and its associated . 1.2. Motivation This is useful for any sort of dispatch manager, a thread pool that you can submit tasks to being the actual target; where a task is any function with any parameters and return type. 2. Implementation 2.1. deferred_invoker.h This is the main functionality. Type erasure is provided through the base class, which simply has a virtual member function that is called when the function has to be invoked. The specializations will then know how to deal with the invocation and whether they have to save a result. They also take care of ensuring the correct initialization arguments required for the call are initialized and saved in a tuple. This applies for template parameter which is any function. A simple tag dispatch system takes care of return types. I've omitted a third implementation of for lambda and functor types to focus the review. It's basically the same style as the other two (possible design issue?), but it takes a copy of the lambda/functor and the arguments, instead of a pointer to the function. 

Specialization for special types You can also provide a way to read whole lines through template specialization or through a different function, since it would be useful for strings (reading a phrase, for example). More functionality You can provide a way to obtain values based on a predicate. So that it can be a lot easier for people to get valid values. For example, I want to get easy input of an integer that is between 0 and 10 from an user. Example 

Why have you decided that the default size should be 100? Different people have different needs; having default values like this isn't a good idea because there is no true advantage to having a default size of 100. While this is subjective, I suggest you remove that default size and just have users be required to specify the size that they want. Compare/exchange confusion There seems to be a misunderstanding in regards to the use of compare/exchange. The compare/exchange operations work as follows: 

This prevents the indexing from going beyond automatically (no bounds checking required). The downside is it will cause more collisions on average compared to , but its something to think about given that you're already handling collisions. 

so it must be freed as an array with (not ) otherwise will also be a memory leak because only its first element would have actually been deallocated. 

The dark side of copy-paste is the potential bugs it introduces. The variable gets redefined halfway into your copy operation. That will confuse the compiler and throws a monkey wrench into your copy-probing. Namely, which should the compiler use use here? 

Performance Bitwise operators are significantly more efficient compared to modulo and other binary/unary operations. For example, since is -scoped a second variable could be declared as part of . So when a is constructed, and after in just set 

The primary data structure is a c-style array because I wanted the practice, so the heap arrangement only works on contiguous memory blocks. Dynamic memory allocation for the array occurs in block sizes given by the as seen in to reduce allocation overhead. The allocated memory is only freed on , , or if the is called. I've unit-tested this with POD types, , and and it executes all functions without issue. Question: Are there any memory leak/corruption issues I'm not seeing? 

That will result in undefined behavior once is accessed again, and it also leaks the original 's memory. So just switch it around: 

Its easier to review code if its complete, so please include the class declaration and full definition. However, working from the top I'll make some suggestions. Parameter lists If your declaration (header file) has a data member , then member functions don't need it passed in as a parameter, namely 

To solve the excessive collision issue just ensure is always a power of two by using the bitshift-left bitwise operator and bitshift-right bitwise operator : 

The first parameter indicates the starting address of the memory block you want to assign values to. The second parameter indicates the value each byte of the memory block will be filled with. The third parameter indicates the number of bytes forward of the starting address to affect. For example, if then all your s will be thanks to twos-complement. Beyond there are functions that allow values longer than one byte to be assigned to each index of an array, as other answers have mentioned. Copy-Pasta Bugs Copy-paste is a useful tool for repeated segments of code. However, I always ask myself if the code I'm about to copy-paste would be better off in its own function. One of the goals of writing efficient code is to reduce the amount of repeated code. The copy operation in : 

Made me wonder if your function could be called instead of copy-pasting its loop. In this case you made the right choice to just inline the loop, but it's something to keep in mind. 

This works because is already scoped to so every member function already has access to . Then there's the bonus of not having to make a copy of the array pointer each time, which speeds up your code a bit. Variable Names More of an aesthetic point than a functional one, but would be easier for user's of your to understand if it were or the like. Two reasons for this: 1) The name is typically used as for template parameter types, and 2) itself doesn't really express what the variable is used for. This means well named variables add the benefit of making your code self-documenting. Storage Space Only one decimal place precision is checked for in , so a is more storage space than is necessary. would work just as well and saves some memory (on most machines). Memory Management Your code s the block of memory it intends to use for after its been assigned to , namely: 

The one defined at or the one defined just before the ? The quick-fix is to rename one of the variables, however another thing I ask myself when I'm about to copy-paste is if there are variables I'd have to hunt down and rename like that. If so the code is better off typed from scratch, plus you get to think about your logic a bit more as you type it out. Indexing The difference between and is significant, but the data in that gap is not. Also, going past will give an index-out-of-bounds/read-access error on , so: 

This heap will be used for A* search pathfinding in my 2D isometric game engine. It uses lambda functions (instead of or ) to allow me to dictate min-heap or max-heap more dynamically. It also uses lambda functions for , , and so that the search key can differ from the compare key (for example: sorting by priority, but searching by name). Typical use: 

Be sure to assign after everything is done copying, otherwise indexing through the changed will be troublesome, and won't actually grow the array the second time its called. Re-inventing the wheel If your variable is one-byte in length (EG: or ), then the loop where the array of integers is set to a specific value: