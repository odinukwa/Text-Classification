I came to C++ from Java. This is my attempt at making a calculator on about 2 days worth of knowledge. I don't really know what is redundant or unnecessary. Nor do I know of the better ways to achieve this effect. First class (it does the math): 

A program that will count up the number of words in a text, as well as counting how many times a certain character shows up in the text. Only ignore spaces. This gave me a lot of trouble as I grappled with list comprehension syntax errors. 

Wondering if there is any way to do it without if else statements since the course hasn't taught those yet. 

As a first step instead of 20k graphics objects containing each a single line use a single graphics object and put the 20k lines in it 

Prefer making explicit functions instead of macros. They are more easily debuggable and compilers like to inline such short functions anyway. 

has capability for custom deleters. Besides that assuming you are doing this to deal with COM objects then you can use ComPtr and its 

Your Big O interpretation is a bit flawed, This is only O(n) per recursion step (single loop with every operation in the loop being O(1)) leading to the normal O(n log n). The first optimization you can do is 

Explanation We use to create a new array from the existing numbers array. The new array contains the first 11 digits of each number from the original array. Each element is an int, converted using , which lets us apply to sum the array. We then convert the sum to a string, and take the first 10 chars. And voila, you solved it. This assumes you already have an array of strings, as is the case in your code: 

Is this a good way of testing me controllers? The part that makes me think is where I'm generating the JSON using Rails helpers instead of explicitly writing the JSON myself, or looking for keys in the response body. For example: 

I had never done a full interactive app before so this is a really big step for me. It's very simple and fits into a single file. One thing that will be odd is the fact that I didn't use arrays. I don't know why but there were a ton of runtime errors occuring whenever I tried to do something that involved an object in an array. 

In this problem, you need to calculate someone's pay by multiplying their salary (double)by the hours (int) worked. If they worked for more than 8 hours, you pay them 1.5 times their salary for however many hours more they worked. Here is my solution. 

I'm building a JSON API. I'm writing my controller tests so that they compare the response body to actual JSON I'm generating in my tests using ActiveRecord. I wrote two helper methods that make the process easier. The first simply parses the actual response body and returns it. 

A square can technically contain the tail of a snake and the base of a ladder, or head of the snake and head of a ladder. But this could have weird side effects (presumably why I've not seen a board with those characteristics): You slide down a snake only to reach the base of a ladder that takes you to the winning square; or you climb up a ladder only to reach the head of a snake that drags you down. While not fatal, such side effects muddle the role definition of ladders and snakes; in that, ladders are no longer necessarily good, and neither are snakes necessarily bad. Example World 

First thing that is wrong is that you are reinventing a wheel. Second why not ditch the and do directly in the first runnable instead? 

You can instead use a LinkedHashMap, which lets you get the in access order if you made it with the (int, float, boolean) constructor. Then adding means removing if it becomes too large. However LinkedHashMap is specially designed to let a subclass decide when to remove the oldest entry using the removeEldestEntry which gets called on each put: 

When grabbing the items most code will simply iterate over them and then discard the vector. You can avoid the allocation and copying cost by using a visitor pattern. 

It depends. I prefer the newer syntax because I feel that it is more readable. As others have pointed out, however, the newer syntax is only compatible with Ruby 1.9.2+. You should be aware, however, that the new syntax does not entirely replace the hash rocket syntax. This is because you can only use the newer syntax with symbols. 

Am I testing too much? Is there a better way? Running 70 or 80 tests for something like this seems excessive. As an aside, can my regex be expressed better? 

The best way to ensure a bullet proof implementation is to avoid having a square contain more than one object. For example, there's an edge case where a square can contain a ladder's head and a tail, causing you to progress even further. To do that, the placement should be delegated to a method that checks if the square is occupied. This requires tweaking the initialize method, but it's worth it: 

This is my solution. The course hasn't taught if else yet, so I'm wondering if there is a way to do it without the if else. 

The Collatz Sequence is an iterative sequence that is defined for all positive integers as such: n → n/2 (n is even) n → 3n + 1 (n is odd) If 13 were to be entered into this sequence, the result would be as follows: 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1 And the total number of terms in the chain would be 10. The sequence always ends with 1. You must create a program that will calculate for a value in the range of 2 <= x < 1000000. This value must give the longest chain of terms when inputted into the Collatz Sequence. I will now post my solution. Any criticism would be greatly appreciated. Did I use too many if/else statements? Was recursion not the best thing to use? Anything you have to say. File Main.cpp 

The and temp variables represent a transitional state. I would ask myself if I will use them in any other form. If not, and if their entire reason for existence is to transition to text, I would do away with them and have one entry point for clean, or savable text. I would consider if generating the report is the class responsibility. The report is a presentational concern, and I feel it should have its own class. 

The second method returns a JSON representation of an object, and accepts options. This is what I expect the response to be. So I compare the output of this method to the actual response. 

This alone means it's O(n). Because stack has internally an array to hold all its elements that needs to grow as it holds more elements. Each reference to an element also takes up space. 

However there are better sorting algorithms (like quicksort) and there is a built-in sort in (and one in that works on ) which has been used for a long time and can be assumed to be efficient enough for most applications. 

Actually if there is any virtual function you should include a virtual destructor so proper cleanup can happen if you a and it happens to be a (otherwise the destructor of is never called). 

I wrote a random world generator for the classic Snakes and Ladders board game. Snakes and Ladders is a dice game played over a grid, usually 10x10. You win by reaching the last square first. The board has ladders and snakes that connect specific squares. Land at the base of a ladder and you climb to the ladder's head (good). Land on the head of a snake and you slide down to the snake's tail (bad). Snakes and ladders are key value pairs; the represents the start point, and the represents the end point. Both are identical except that a snake's start point must be greater than its end point, while the opposite is true for a ladder. World rules: