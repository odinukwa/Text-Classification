This has a couple of advantages 1) not hitting the disk for every query will be much faster 2) the dictionary lookup faction is much faster than straight for loop comparison, since the dictionary uses hashed values instead of more expensive string compares. As an aside, you should look into readlines, which the usual pythonic way of reading text files with info on lines. For the longer term this is a great application for Python's built in database functionality (with the sqllite module). You could convert your existing text files into a sqllite database and then your lookups can be much more flexible and precise ('find spectrum and power for stars with id > X and < Y' sort of thing). You probably also want to set this file up so you could call it from the command line, which would involve using the argparse module to grab command line arguments and out them into known_stars, master_list and output_file 

Python has a neat built in called 'zip' which creates a pairwise list from multiple iterables. So you could do: 

Conceptually this is halfway between 'traditional' inheritance heavy OOP and @MichaelUrman's data customization approach. All three have their applications, and the neat thing about python is that it's very good at both @MichaelUrman's method and mine -- which is not true for languages obsessed with type-checking and signature maintenance. 2) On the strategy level, in the long term you'll benefit from a finer grained approach. Engines, transmissions, and tires for example might be their own classes instead of aspects of vehicle (a station wagon and a sedan, for example, might share everything but body styles). The class hierarchy becomes less of an issue as you do more mix-and-match customization by creating collections of components. The usual pretentious programmer way to say this is 'prefer composition over inheritance' 

From a style perspective I like the first option; if you're treating this as a property its clear what you intend For implementation, I'd try a class level default with an instance override to provide the right words to allow for specialization or extension (for other languages than English, say, or use at Oberlin College). Whatever your gender politics this implementation is extensible to new cases and one offs. 

I would avoid inlining the actual constants in the list comprehension tool - that's bad for readability if it's not sitting on the outermost outline level. On the philosophical level, I'm ambivalent. I hate all the quotes etc too, but this only works for strings, so it's not a general purpose idiom. You could extend it with exec or eval to get non-string values, but that's a whole big can o' worms :) 

Here's a couple of ways to shorten the code, which may or may not involve perf gains but may make it easier to work with. I tested this with plain lists-of-lists instead of numpy.arrays but I think it should work the same way. I used itertools.product to get rid of the nested loops and used sum() to avoid another loop. get neighbors will be called for every cell, and it's going to loop and iterate mamy times. You can get the same result by summing the rows of a subset: 

Note that there's no need to continue to the end once the answer has been obtained - this alone make determining the answer faster. This doesn't defend against out-of-bound problems, but it also doesn't need to. 

The backend mailer class is just an implementation detail of your own Mail class - it shouldn't be necessary to have intimate knowledge of such details, but because it's a mandatory constructor argument this is currently unavoidable. It should be possible to change the mailer implementation and make no changes to your application/usage code (except in tests). Another disadvantage to everything-as-constructor-arguments is that all classes in use are created eagerly. If the Mail class were to be instanciated but is ultimately unused - the Mailer object would also have been instanciated and unused. In this case that class doesn't do anything - but if it were also creating dependencies on construction, and if there is any setup logic executed this can easily mean a tree of objects get created before they need to be used. A practical example of how this can be a problem would be if the config is modified after construction but before first use: 

Either invert the test (!) or put some logic in there - e.g. redirecting the user to their profile page. 

The less logic there is at runtime - the faster the code performs. Use a build process Rather than handle requests for missing packets, a process that builds them all, once, could be used. 

The function invoke handles everything - there are 10 "actions" in it. Each of these if statements would ordinarily be a separate action (function) in a controller. include view That's not how views are rendered in CakePHP. Like that there are: 

(Which, incidentally is the same as: - use dot notation where possible.) If you write it like that - seeing that you are passing (almost) the same argument in all use cases to your create_filter_input function - you can start to see/think that you don't need 2 local variables - just having "property_type" is enough. As one of the other answers says - don't serially append to the dom. each write is relatively expensive. it's better to build a dom fragment and append it to the dom in one go. 

Don't catch exceptions that you don't know how to handle. Unless there's a reason you're catching PDO exceptions - in which case document it. Use less nesting. Don't needlessly use . This is easier to read than the original: 

There are numerous things you can do to make the code easier to maintain. Put code in your models The minimap function calls find on the banners table twice - with config that doesn't change. It'd make things a lot cleaner to do this: 

I use gearman as an example - but you can implement it any way you wish. Just ensure your solution account for jobs that fail intermittently (job fails once, reschedule for later) and for jobs that fail consistently (something wrong, job fails 3 times - flag for action). 

I'd also use string.Template for any complex string formatting opertations. The % operator is great for single substitutions but Template is better for keeping the code clean: 

This could be even a little shorter if you use list comprehension, yields and iteration to avoid all the if-tests (and, btw, use named variables instead of indices for clarity!) 

If you've learned object-oriented programming, you might see how the residential and business functions could share code by becoming classes (or more likely a class and a subclass) If you haven't looked at OO, think about refactoring the way 'business' and 'residential' work to avoid having methods which differ only in hard-coded constants. 

This would work well if there is a high correlation between the optional functions: if they tend to cluster together they'd make a natural class hierarchy (and you'd have an easy way to see which nodes were using which function sets just by looking at their concrete classes). OTOH this won't work well if the functions are not correlated. Kwargs to the rescue You can simplify the constructor logic by using kwargs and by including the defaults in the init method (for sanity's sake I'd move the pure data into required parameters, but that's just aesthetics); 

When you're composing, think about how you want to access the components you're putting together. In this example, you are asking the window to include a DrawRect that always draws to a 50 x 50 pixsel square. Does the window really need to include that rect? The DrawRect has all the info it needs -- you add the window reference in the constructor -- so what's the rationale for including it in the window? In the example code you create a DrawRect outside the window, and another inside the Window - and then never update the independent DrawRect so it never shows up. This seems less like composition and more like gluing things together which don't need to be connected. Consider the alternative: 

You're doing three things here: splitting up the listing into sentences, parsing the listing, and recording the results. You can clean this up by separating these out into separate functions functions or classes. This keeps the code less nested and easier to follow. To keep things simpler I'm using regexes for the room names as well as for the dimensions. This will actually be a bit slower - "in" is really fast - but it is more flexible (for example, if you have to support plural endings or something else besides string lookups). I'm compiling the regexes using re.compile to make them faster and re.I to make them case-insenstive. Lastly, I'm returning the results as a list-of-dictionaries, where each dictionary includes the room, dimensions and the sentence from which they came. This lets you keep the printout display separate from the parsing. In practice I would probably use instead of a dictionary but I didn't want to get too far off topic 

I think this will be faster than your current update routine (among other things, using itertools is usually faster than hand-written loops) -- though depending on the data the incremental update might end up slower for data that doesn't cohere in time. The other obvious optimization would be to cache the collision checks as has been suggested. You'd maintain a dictionary of entity-entity pairs (this assumes entities are hashable, but they probably are). Inbetween steps set all existing pairs to a neutral value like None or -1; then as you do the checks for a given pair, you check the dictionary to be sure you haven't done that particular check before. I'd also do a two stage check for collision to cut out the square roots: 

DRY - Write less handle more You can make your function half the size by designing it to work with scalar vars only, and handling arrays with a loop: 

That means in all cases the variable is tested 3 times if it's null, and twice if it's an array. A couple of side points: The first use of is really testing if the variable is a string by inferrance - it would therefore be more appropriate to use . Also by using type-insensitive checks an empty array or empty string are caught by the first if block (perhaps that's deliberate but it isn't obvious). Instead the code can be written as: 

Be aware of the difference between isset and empty This will return true if the userid in the session is e.g. "" 

Code separation What you have there is everything mixed together - just by moving the php logic to the top of the file, makes it easier to read. With some minor reformatting it becomes easier to read/maintain: 

When the time comes to write unit tests, the code shouldn't need to be modified. Changes to make code testable are usually trivial - and just mean planning ahead and having appropriate methods to set and get data. Be secure As indicated by other answers an unsalted sha1 password is weak. Passwords should be stored such that even if someone gets access to the database, they can't determine the original password. It's not hard to store passwords securely, here's some pseudo code: 

A message inside a class like this shouldn't assume it is to serve html - what if it's responding to an ajax request, in xml, json or even just a log file? Don't sleep I'm not sure if this is just code for demonstration but this is actually the one "problem" with the code in the question. Using sleep will tie up your resources - that's not in your interest. Consider instead bailing early and just returning a 403. Right now before prompting a user with a captcha - you are holding the request open for more than a minute. If you get enough users (and enough could be a relatively small number) trying to login at once and getting it wrong - you're going to take your own server offline by occupying all connections with 1 minute long sleep calls. Don't use empty if blocks Again, not sure if this is just for demo purposes: 

Which is in fact set to four spaces. "\t" is easier and shorter to type. Minor Point: Whitespace Whitespace in html is insignificant, so doing this: 

If you find you're only using each instance of a class once - that's a relatively good indicator that a class is the wrong approach. Is so much code necessary The question states that the objective is: 

I'm not particularly fond of the style of coding, not everything needs to be a class. But there is only one point that I feel warrants significant attention: Huge Point: Not escaping means not useful 

That's a lot of code It looks like it works but since it's apache specific what's wrong with using virtual? It's an apache-specific php function for serving files. I.e.