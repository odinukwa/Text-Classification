I'd also consider making that property readonly as you assign it in the constructor and mutable tree nodes aren't my cup of tea. What's with the s? is generally used more. 

Each entry in the loot table just tracks the range of values that should return it. Usage is basically the same: 

This may seem like a really minor point but try to avoid side effects wherever possible. You want your code to be really obvious to anyone reading it what the main purpose of the code is: 

You can do this with more easily by manually creating a and then calling a overload. I think it's something like: 

There are a whole bunch of variations on the above - feel free to make any changes... The has always bothered me a bit but I like the terseness of it. With that extension method in place you can simplify your code to: 

Notice that the explicit operator can throw as not all strings are valid Skus but the implicit operator can't because all Skus are valid strings. I feel like I've rambled, but hopefully something in the above is useful. 

Methods should only do one thing - in your example I think you should have seperate methods: and . I'm always wary of public static void methods as well. I would expect something more like this (tracing code ommitted): 

Keeps it simple It's about 30 times faster than your method You can view the code as a schema for the data array. I.e. is the third element 

Putting the JSONArray aside (given I don't know the fully qualified name of the class), here's a Groovy-er version: Working example 

This has the additional benefit of not having side-effects. Another improvement is to change the location s to s so that instead of you can do . This improves readability. To build the path , I think using is better suited than because it helps clarify the code's intent. can be used on the output of , but that would have been more trouble than it's worth due to the need to keep multiple things in context (accumulator). So I used instead. 

In this example, is an interface with four implementations, (only one of which I coded), one for each of the possible directions. The methods accept a and any other necessary parameters which are not part of the . The implementations can then get , , and from the . Sure, this breaks some object-oriented programming rules, but as the adage says: some rules are meant to be broken :) Note that it still involves passing the current state of the . Alternatively, you can implement as an abstract class containing and the equivalent of the methods as abstract methods. Then, you can remove all together and implement four s; one for each direction. 

How it works The method iterates through the and calls a closure with an object to aggregate with and the current item in the list. Iteration begins with an empty as the aggregated object, which remains empty unless the un-matching countries are found. When a mismatch occurs, it is recorded in the . The closure purposely returns the because the output of the closure is what's fed back in during the next iteration. Finally, if the resulting is empty, then all of the countries are the same. Otherwise, the contains one or two keys indicating what the problem was. If all you really need to know is whether all the countries matched or not, you can simply use : 

arrays can be null. If that happens, your methods on the class will all throw s. You should validate that the items array is not null in the constructor and throw an there instead. 

I can't think of a better approach than a session cookie. It feels safe in that you have three potential ways of leaving the page: 

You need to aggressively refactor the rest of the code so it's readable before you can hope to track down the problems with it. 

Edit: As Peter Taylor pointed out in the comments, you can take the logic further to incrementing by 2520 each time because the final solution needs to be divisible by all the numbers 1-10. However, the main thrust of my answer was supposed to be that you don't need to brute force and you can compute the solution directly. 

If you're going to keep your SQL queries as part of your code, you should pull them out into named constants. You can also use a verbatim string literal to keep them nicely formatted: 

Ask some beginners what the code above logs. I bet at least some of them will get it wrong. Obviously naming a variable the same as a function in the same scope is a pretty big mistake but I have seen it happen. Confusing code Look at this bit of code: 

I hate to break it to you but your code doesn't work. For the input you've given, your code returns: 

The first pass is similar to your File.eachLine() loop except it's done with Collection.inject(). The inject() method Closure returns a List containing two items: the line which matched the sourceMatcher regular expression, and a List of the entire file with a null inserted as a place holder for the destination of the matched line. The second pass is actually not executed right way. Instead, a Closure coerced into a Writable is returned for later use. The returned Writable contains the code needed to write out the changed file. Using InputStream.moveLine() With the Writable on hand, it's now possible to write the file with the line moved. But to even use the InputStream.moveLine() method the Category in which it's defined needs to be made available. the Object.use(Class) method does this. 

The meta-programming You can start with a Groovy Category that adds the method Writable moveLine(Object, Object) to a class, such as an InputStream. 

one to determine what to move and where to move it to, and another to re-write the file with the lines moved. 

If you were dealing with two properties that were in the then you'd probably be able to use a derived property. But since one of the properties in an association, a derived property won't work. Instead, you can do this: 

With some meta-programming you can add a method to the InputStream class that would allow you to move a line ahead of another using concise code like this: 

It's a stylistic thing without doubt and if you prefer the brevity then that's absolutely fine. I should have been more explicit about that being a preference thing rather than a rule! 

I just use a dictionary to keep a tally of the number of edges in each column and keep the current winner in a variable. My original code was simpler (only using the dictionary) but it failed the performance requirements on leetcode so I had to manually keep track of the maximum as well. 

By modelling your stylesheet as a simple you lose the order of the rules. You have to know which rule came first to in-line the rules in the right order! That's why it's called a cascading style sheet. It looks like you're only doing a simple thing so I think you can reasonably ignore specificity and media queries. Build up the domain! 

This is a pretty good attempt for someone just starting out. However, there is always a lot to learn and the books never seem to take advantage of all the latest language features. The first thing I'm going to tell you to do is stop abbreviating everything. You don't pay extra for full naming. I'll choose you constructor to highlight this: 

This review comes with the caveat that I've spent a few days in total on Elm so far... Take anything I say with a pinch of salt. Firstly, some style things. 

The program begins by applying some mixins to Groovy and Apache POI classes. Then, it opens the Workbook using the added method . This method takes care of opening the Workbook and closing it when the Closure exits. The core of the process happens within the Workbook Closure. 

Leverage the GDK Early in the script, you have a variable which is used to ensure all of the rows in the map are of the same length. The variable is not used elsewhere. So to limit its scope, you can refactor the validation using : 

The new property , which is maintained by the and methods, takes care of saving the current resolved client to the GORM store (database). With that value persisted you can use it in GORM queries: 

In addition, since in the JVM is immutable, concatenation can create temporary objects which the JVM must then dispose of. It's typically better to use . Testability To make the code testable, meaning that it can be executed via a method call and the output can be validated, I placed most of the code into the method. As a consequence, I converted the closure into a method. I know the challenge states If a map is invalid, STDOUT 'Invalid map.' (That includes if the map is unsolvable). However, I disagree with using the same error message for multiple problems. That's one reason I replaced these messages with insightful exceptions. The other reason is to keep the Groovy Console from exiting. 

You're mixing aliases and typenames. E.g. vs vs . Choose one and stick with it (and preferably aliases). 

It is nicer to put all of your fields at the top of your file. You have some mixed in between method definitions. 

By having separate classes and using extension methods to construct instances, you make it trivially easy to add more validators - create a type that implements the strategy and add an extension method to instantiate the type. You could add additional extension methods to IValidationStrategy to make composition easier and avoid leaking the knowledge of . 

Why don't you materialise from the collection (whatever that is) and then access the properties instead? 

I don't want to start a holy war about it but you should know that your bracing style isn't generally the expected style for C#. It is more common for the opening brace to appear on a newline: 

I'd think to myself, does this person know about the overload of that mirrors ? Do they know that line endings can be different on different operating systems? I'd much prefer to see here or another call. Cool, let's move on to the next line: 

I think you'd really benefit looking at either jQuery UI's widget factory or (my preference) using some boilerplate such as jQuery Boilerplate. Other than that, in no particular order: 

We don't want to search the DOM for the element every time (unless it can be added/removed) so let's pull it out: 

If you're interested in creating some Groovy mixins, you can make your Fizz Buzz program quite simple, while getting some reusable Excel functionality out of it. The Fizz Buzz Program Here's the business logic of the Fizz Buzz program: 

Templates Ideally, you'd have two templates: one for the class and one for the methods. That would avoid the clunky JSP-style programming. You can read more about Groovy's template engines here. 

This makes use of to handle most of the building, instead of looping and appending to . The only comes in during the case of 3 or more items. Revised It's possible to knock out one of the cases like this: 

In order to resolve the client with a GORM/Hibernate query you basically need to persist the resolved client value. Based on your method I'm assuming your domain class model goes something like this: 

Since , , and are public, you can just pass the to the instead. Also, has so much functionality that it might as well be a class rather than an enum. In fact, it would be even better if it's an interface: 

How it works It's actually quite simple. The method signatures are gathered from the class's MetaClass. Then some hefty formatting is applied to write the method signatures correctly. Also, final methods are excluded. Example 

On the Groovy side, it would still be best to use the method because the property can get out of sync if changes.