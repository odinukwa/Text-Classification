To answer your question "yes it's possible" because you've said your competitors do it. I don't really understand what "it" is so I can't give specific advice. Besides which, code not yet written is off-topic for code review. On to current code. 

You only need to check the even numbers because the answer is divisible by 2 Only numbers ending in 5 or 0 are divisible by 5 

In a project I'm working on, I need a component that is able to make a best guess about file's type based on its contents (a ). It doesn't need to do a particularly great job - basically just need to guess a file extension (which will later be mapped to a mime type). I can't trust any metadata - I can only act based on the content. I opened up Bing and Googled around a bit and found this gem on magic numbers. I figured it would probably do the job well enough so decided to roll a limited implementation in C#. Most of the time it's a straightforward "starts with" check. However, some formats (I'm looking at you JPEG and PDF) make life slightly more difficult. E.g. JPEG starts with where xx can be anything (I think). EDIT The second byte in a jpeg is actually 0xD8 - I obviously had a copy paste error here PDFs can have their header anywhere within the first 1024 bytes which is why it's not always a "starts with" operation. FileType.cs 

So you're either going to have the option to remove the cookie on the unload event or the session cookie will expire anyway. I would structure the code a little differently: 

Then you've got a reusable chunk of HTML and you now don't need to worry about your original concern. As a side note, there may be a more semantically correct choice than using here. For example, a definition list could be appropriate. Also, don't use , style the elements with CSS to be block. 

Remember not to abbreviate names. doesn't mean anything to anyone. I'd also suggest grouping by and converting to a string in your UI layer. I don't know if you need it, but it's much harder to localise if you include hard coded format strings all over the place. 

Firstly, by doing you're never going to be getting the last element of the array. That's going to help me a lot when I'm trying to crack your passwords. Secondly, we know that , being a can be 0 to 255 inclusive. Your array is 62 items... 

Your code has a pretty massive flaw - it only accepts single digit numbers. Trying to use falls over (specifically your assertion fails). A calculator that can only handle single digit numbers isn't really that useful. I'd recommend you changing the signature of your method to return an where each string is a token. You could actually create a token class if you want. So you might have 

It's actually a template for a function on a file name. The parameter is the filename too. It's worth checking MS guidelines 

will all be counted seperately in your solution. You can fix that by passing an which ignores casing when you create your dictionary. 

Note that I've assumed that skipping was a mistake and that you want to set code 1,2,3,4,5,6 and set misc 1,2,3,4. If that's not the case you'll need to slightly modify the for loop to take into account this discontinuity. 

You don't need to brute force expression generation either. Choose the operator first, then choose the LHS and finally choose a number for the RHS that is within the allowed range. '+' (addition) Choose LHS: 1 <= LHS <= 8 Choose RHS: 1 <= RHS <= 9 - LHS LHS choose 5. RHS can be 1, 2, 3 or 4 to yield a single digit answer. You can do the same for the other operators: '*' (multiplication) Choose LHS: 1 <= LHS <= 4 Choose RHs: 1 <= RHS <= 9/LHS (rounded down). LHS choose 4. RHS can be 1 or 2 to yield a single digit number. (9/4 = 2.25 -> 2) I'll leave '-' for you to do. 

So, based on the name and return type I'm going to "Spend" something(?) and get a list of items. To me, I find it had to believe this method is going to have a single responsibility straight away. The parameters only confirm the suspicion: 

It's very hard to follow the builder when it's jumping around like it is... I wonder whether you could achieve something like: 

This is going to be a quick review to kick things off... As this is a public method should should check the arguments and throw suitable exceptions. 

The handles all of the encoding for you so you don't need to worry about doing it the right way. You just create the name value collection and any null/empty values will just be skipped in the method. Update As svick has pointed out in the comments it might not be ideal to use an internal class in this way. I think the risk of the implementation changing is quite low but it is a risk and should be thought about. 

Forgive the second answer - it's very separate to my other answer so I think it warrants a new one. A bug? Your code (and my suggested solution too) has a bug - UTF16 surrogate pairs... Here's an example: 

For point 1, why are your methods ? You want to know the results of sending the emails (that's why you've added the list). Why not return the list directly. You could even add a class which encapsulates both successes and failures as well as other interesting data to be logged somewhere. For point 2, consider this: 

I really disagree with the view model saving itself - it reminds me of active record (which I've never really liked). It gets the job done but I think your code would work better if the class was just a wrapper around some data and you had another service to have the responsibility of saving the model. This service would almost certainly depend on both and . 

Style points: All methods in C# should be not (see msdn guidelines) Choose descriptive names: doesn't "deepen" anything as far as I can tell. Auto properties reduce code bloat: 

(all of the code in the edit has just been typed directly in the browser, if it doesn't compile, hopefully it should be close enough to correct.) 

Most people writing C# prefer braces on new lines. What is ? A property that gets input from the user? I could go on but that's not very constructive. What you need to do, is go back to the drawing board and come up with some classes to encapsulate all the different things going on here. 

I wanted to implement the Sieve of Erathosthenes up to in C#. No object is allowed to exceed 2Gb so you can't allocate a array. In order to solve the problem, I created a class that packs the bits into an array of bytes instead. I know that it's possible to use a segmented sieve: this was just for 'fun'. 

Some comments on your code: When checking for empty strings, this works but is less than ideal. It can sometimes be hard to see the difference between and when you're scanning the code. 

StringBuilder's append methods return the StringBuilder so you can chain calls. AppendLine also has a parameterless version. So this: 

Now you create your service with 2 parts, one is your setting (working directory) and the other is the path to your base directory: 

You'll notice that I've changed almost all of the names in your code because yours weren't very descriptive. ** Creating the instances of the T is the most difficult part. You could solve that by adding properties on the base class and a parameterless constructor so you could simply do: 

I have some bad news for you... According to MSDN only one thread can enter an upgradeable read lock: 

Do you see the problem? For every item you're doing a which will iterate over all of the items you've already processed. First iterating 0, then 1, then 2, then 3, then 4... all the way up to N-1 items on the last call. So we know that is going to get more expensive on each iteration of the list even when we schedule everything on the same resource. In the worst case, you need a new resource for every item. You're now doing one call to for every resource id that you've already created. However, you never search the last one as it is created on the last iteration. So just on your last iteration, you'll be doing (N-1)*(N-1) operations. Ouch! I'm sure the average case is creating quite few 'resources' but it is worth considering the absolute worst it could be. Just while I'm at it - you're also calling loads and loads of times. You already have one answer that improves this for you, I'll just throw another one at you. All you need to do is keep track of your 'resource id' and the date/time the current item ends. That fits nicely into a list: 

Why create a class to wrap the validation strategy at all? A common pattern with immutable objects is to have an empty or seed value to start construction from. 

Names should relate to what they are is it a "Manager" or a set of controls? The type name doesn't match the variable name in my opinion. As an aside, I generally dislike as a name (and I'm not the only one); 

This avoids having to hit the DOM each time, for example, you had $('window') four times... It's much better to get it once and store it in a variable. I've also wrapped everything in an IIFE (Immediately Invoked Function Expression). I'm not sure what you were trying to do here: 

Is that an Entity Framework Data Context? If it is, you're getting all of the organisations back from the database to see whether the domain exists. Let the database do it: 

Here's a working fiddle: $URL$ Have you considered a solution that starts with only 3 inputs and then creates extra inputs instead of showing ones that are already declared but hidden? 

I look at the code and think that the main purpose is to iterate the array. In fact, the whole reason for the code is writing the array to the console. That can be done like so: 

First, is a great name, is also good. Now, I'd guess at phoneNumber but it could also be the name of the Primary Health Network if this was an Australian healthcare customer. - is really that much harder to type? is a great choice for the but is a terrible name and there's some extra whitespace which should be removed. Also, your fields shouldn't start with . They should aslo be . The old version of the guidelines stated this explicitly but the newer C# standards don't specify a convention for non public fields. Most people use in my experience. As a commenter has mentioned, you can use auto properties: 

If that is the case (and it's a stab in the dark from me) that's where your refactoring effort should lie. 

Definitely add a it removes a lot of clutter. Prefer built in methods e.g. overwrites the file or creates a new one - no need to whip out a . Also note that if your file becomes really large this will start getting pretty slow. Final(?) Edit Can't use var in the foreach loop as MatchCollection implements only - not the generic version. Sorry about that. In order to use a Linq method (such as ) we have to supply the type by calling : 

If you create your classes to match the xml or add appropriate metadata, the method might be as simple as using an or to deserialize the data directly. 

It's probably going to complicate the design a bit but I think the addition of some type objects may help you in the long run. I realise that the above isn't really a review of your code... I can whine about some of your naming if you'd like ;) Naming You're inconsistent with capitalisation on / the class is but you . I'm guessing that's because VBE is a generated class? The documentation for (and what it does) is a lot more than just navigating to the project builder. method doesn't quite follow the pattern elsewhere - should be . Those are the only ones that I can see... Your code is getting too consistently good to pick out many things! I wonder whether calling your methods that navigate to a parent builder would make the code read a bit better? 

Look at that there - you're newing up an and an - neither are being injected! You've overcomplicated things a bit here I don't see the point in having a class. looks a bit like an adaptor but again, I think it's all a bit overcomplicated. Basically, you want to move everything that your class depends on into a constructor argument (which is the easiest form of dependency injection to use). Need a ? Pass it into the class's constructor! The point of DI is to have all your dependent services easily discoverable. Other notes All methods should be . should be isn't particularly random at all - for this sort of thing you'd be better off with System.Security.Cryptography.RandomNumberGenerator. Autoproperties reduce the amount of code you have to write: 

is a typo; it should be . It's also not a user - it's an id! The name would be better as . You should read the official naming guidelines and capitalisation conventions see here. 

I'll come back to your other point later if I have time :) Update As your second bit of replication: Create another method: 

If I've read your code correctly, this will never return because the time based cancellation token will have already requested cancellation and you don't check the property at all. It would be better to store the TimeSpan in a field and set up the time based cancellation token as the first step of your method. 

Word interop is pretty horrendous. I notice that your extension is .docx - have you considered using a library to manipulate the file as openxml and throwing out the interop? 

A couple of quick comments: You can use the see tag's cref attribute. If you generate documentation, some tools will generate hyperlinks for you. 

I've added in a commented out Route attribute just in case that floats your boat duck. I personally prefer attribute routing because I like to see the url in place. Especially because one of the people I work with is mad for clean urls, so you can do: 

The first collection is already in memory I can't remember why I thought this applied. I can't think of a reason why now so I'll just strike it off the list. The second collection is not lazy (so doesn't help) Fetching the second collection is expensive (so you want to minimise surplus data retrieval) 

I was looking at your code thinking "it's so nice to see struct when it makes sense and one that implements all the equality and comparison stuff!". Then I saw this: 

You're assuming that filenames can't contain a period/full stop other than to separate the name and the extension: 

I wish I could suggest something useful but I still haven't figure out what you intend on doing with this thing.