What you have is a very good start. I would suggest refining your exception type where possible. In your case, I would suggest using IllegalArgumentException. Using a specific subtype helps with diagnosing/debugging. Additionally, since IllegalArgumentException is a type of RuntimeException, you can then remove the from your method signature. 

This is all just data, though. To be meaningful, we will also need methods/functions that can use the state in these classes to produce results, to modify state, or create desired side effects. Below is an example of how functionality for attacking creatures could be done. Note that the methods only read or modify the fields of 'this' object, and not (directly) those of other objects -- this is a good rule of thumb for what a method should do, and where it should go. 

Immutability is not a matter of whether or not your class has getters; in particular, a class without setters does not make an immutable class. In its purest definition, immutability is the absense of mutability. An object is immutable if, and only if, there exists no way to mutate its state. In Java, this implies what the documentation says: 

Access to is unguarded. It should be marked as volatile, or wrapped in an AtomicReference, or accessed only through a lock or synchronized block. The executor is created from within the class, but there doesn't appear to be a way to shut it down. Consider passing an existing, externally managed executor through the constructor. If the executor is to be created and managed internally, and you'd like to lazy-load it, consider using a holder class, like this: 

On the whole, yeah, looks good. I recommend you use braces for one-liner blocks as well. In this instance, I'm not batting an eye at it—it's fine—but it's a good habit to learn. 

Each branch in ultimately leads to ; we can pull that out as well, and put it at the end. Grand total 

Reconsidering the Design The basic principle behind object-oriented design is, put bluntly, to stuff the code where the data is. Store the (source) code with the data it operates on, so that people that reason about the code (that includes the designer!) have to keep fewer things in mind at the same time. Ideally, this leads to robuster and/or simpler code. If OO is all about putting the code with the data, then how do we decide which code to put with which data? A good short-hand is to think of objects as having responsibilities. Think of it of asking questions such as: "Who gets to decide what happens?" (who has the code) and "Who knows this?" (who has the data). Examples: 

It takes the lazy-loading out of the lazy-loader, but then you could ask yourself what the remaining uses of the class are. 

I'll freely admit that my following suggestions are hunches. I hope they make some difference, but they may be negligible. 

Quarantine Any time you use a map to link information with an object, consider adding the field directly to the object. If it doesn't belong in the object, or you don't have the ability to make changes, consider a wrapper object, such as a new class . The statics need to go. Passing the Quarantine object to your Treatments will solve this. This try-catch seems to be a fail-safe because you're not confident your code is correct: 

We'll also need a way to get such an axis. Since the axis represents an axis in our tile map, that feels like the place to provide them: 

Does a type of creature have a specific behavior different from others? Subclass for a special case: 

Also be wary that is subclass of , as distinct from . If you rely on interrupts to abort, you may have to handle both exception types. 

is rarely a good idea. Consider reusing existing exceptions (IllegalStateException?) or defining exceptions specific to your domain (NoPathToTargetException?). Otherwise, callers of your methods will be forced to handle the top-level throwable type, which invariably leads to the next paragraph... An empty usually causes more problems than it solves, especially when catching the base type. If this is a debugging construct, consider printing the stack trace to the error stream. You'd be surprised how many can't-happens logging catches. ;) Use braces even for single-statement blocks. One day, you'll be sorry you didn't; I know I was. I can see exceptions being made for condensed one-liners, but if you put the following statement on a new line anyway, there's no reason not to add the braces. is only used immediately following assignment, so you can pull its declaration down to the block where you need it. You may want to factor it out and make a method. (Your comment stresses that calling is important, but I don't see why.) Since you check for low power in your loop anyway, you may want to throw the exception (BatteryLowException?) there and then. Another option is to make a specific return type: 

When you start extracting data and code like this, your main method will shrink, and you will find it much easier to scale to more creatures, more items, and even more complicated dungeons to crawl through. 

Let's define a problem statement, so that we can tell what we are trying to model: The aim is to model a quarantine. The quarantine has a number of patients. The patients may have ailments / diseases / conditions. The quarantine makes treatments available. Treatments may involve medication. Note that writing out what we are trying to accomplish already makes some concepts clear. When we model them into classes (object types), we have a few core classes: 

You could perhaps squeeze out some extra cycles by guessing that numbers will take up three to four bytes (since they're all between 150 and 250, plus a whitespace char), but the point of the experiment was to check whether we could do better be faster than Scanner, and the answer is yes. 

We would already need a change in protocol, because there are a number of messages that we may want to send to the client: 

Indeed, there is—good catch! We can speed up the duplicate counting by using a instead, mapping a name to the number of times we've found it. (This is essentially a multi-set, but our standard libaries don't carry such a data structure, so we 'fake' it.) Our printing code will look quite different, though: 

appears to carry information that is local to a student, and is not very useful outside of the context of a student, so your instinct of 'hiding' it through delegation is a good instinct. But it makes me wonder why you have a in the first place. If the goal is to close for extension and provide immutability, then the next question becomes: is included in the guarantee of immutability? If not, can be said to be immutable? That depends entirely on the relation between student and status. tl;dr What's better depends on what you aim to achieve. Don't get mired in the perfect way to do things, because such a thing does not exist. Do think about what and why, which is what you are doing, and I wholeheartedly applaud that. 

Review isn't used. What is it for? The method is declared to return , but doesn't. Consider adding braces to all code blocks—including and . This will prevent errors from adding lines later. and could be replaced with (left-hand side) and (right-hand side), but that's a bit nitpicking. In order to implement returning 0 for equal elements, try using : 

I'm cool with either, as long as it's applied somewhat consistently. If you don't use calculate and calc in different contexts and implying different meanings, either one's fine. 

Note: ObjectOutputStream.close() closes the underlying stream, which will close the socket's outputstream. It's not an issue here because the socket is closed immediately thereafter anyway, but you may want to flush rather than close in some circumstances, or to slip a close-ignoring filter in between. Subtle trouble has a potential issue in its nested loop: 

Consider using instead. Or, as you are working with Calendar instances, you may find JodaTime useful in your efforts. 

There doesn't seem to be a way to retrieve the from a . You've provided delegate methods, but if you change the interface, its extra methods will not be accessible unless you also change the class. Now, interfaces ideally don't change often, but it's something to keep in mind. 

The trick is to give special treatment to your first or your last item. If you know that you have at least one element, you can unroll it and then loop over the rest; the examples below make that clearer: 

Use lists (expandable) instead of arrays (fixed-length). A number of arrays have sizes that appear arbitrary, such as (later redefined to length 100). Unless these lengths represent agreed-upon limits, in which case it would be best to name them through constants (e.g. MAX_CLAUSES), consider using an ArrayList instead. ArrayList has comparable performance to arrays, will grow as needed, and will relieve you of having to store or guess the number of elements. Add documentation or help code self-document. There are useful comments in the code, but not enough to get a view on what happens where, when, and why. They probably would be enough if the functions and variables could be renamed to signal use or purpose ( ? ? ). Reduce the number of static, reachable, mutable references. The abundance of statics greatly widens the conceptual scope of named references, making it harder for human beings to read and reason about the code. Reduce this scope by making them instance references—this will also reduce the number of arrays you need—and by restricting access through where possible. This will be tedious, make no mistake. It will require you to rethink and remodel some parts. But it will greatly improve the ability for people (including yourself!) to reason about the impact of a change to the code. Consider a instead of and . Maps tend to be very fast in lookups, so it will save you processing time. It will also free you from keeping the two lists in sync. Add to specific classes where needed. All calls to appear to follow the pattern of . Consider adding an instance method to class Symbole, so that you can change into . Aim for 1 statement per line, and prefer using braces for code blocks. This is not an unbreakable rule: there are cases where 'packing' statements or blocks is defensible for visual or conceptual reasons. But I'd err on the side of caution. Prefer generics over raw collections. Generics help keep your collections type-safe (reducing bugs) and reduce the number of casts you need. Prefer logging over System.out.print. Java comes with a logging utility (java.util.logging); you can also use one like log4j or slf4j-logback. If this feels like overkill, consider moving to methods like to reduce clutter. Consider instead of chains comparing to constants. is an example where would probably both be faster and clearer. Scrutinize . You'll probably need only two or three of its methods, so you might get away with adding the methods explicitly, and then delegating to a private field. If these classes do need to be list-like, consider adding the interface instead, and then delegate, or add a method that provides a view of what you need. 

Parsing is always a bit complicated/ugly in terms of code—a library like ANTLR can do some of the heavy lifting for you. But let's assume some level of reinventing-the-wheel for practice/exercise. Recommendations What follows are fairly broad recommendations based on the question: "If I were responsible for maintaining this code, what would I do?" 

This is a little better, but it's still inefficient. If you're feeling brave, there is a formula to generate all Pythagorean triples. Euclid's Formula Briefly, Euclid's formula involves two integers, \$m > n > 0\$, that generate Pythagorean triples: \$a = m^2 - n^2 ; b = 2mn ; c = m^2 + n^2\$ (This doesn't generate all triples; we'll get to that in a minute.) The sum of a, b, c becomes: \$sum = m^2 - n^2 + 2mn + m^2 + n^2 = (m - n)(m + n) + (m + n)^2 = 2m(m + n)\$ Because sum, m, and n are integers, this means that both m and (m+n) divide sum. For minimal n = 1, m is maximally \$\sqrt{sum \over 2}\$, so that's a good upper bound to start with. And given sum and m, we have \$n = {sum \over {2m}} - m\$ 

(1) If you're confident about your data being densely distributed and bounded, you can replace this with an array for quicker access—approaching O(1) i.o. O(log N)—but it's going to make your code messier dealing with edge cases. 

Because is a volatile reference, and there is no other reference path way to that array (aliasing), reads from and writes to it are strictly ordered. That means that you could never read the array and have incomplete writes dangling. This is not bulletproof. In particular, if you have code that looks like this: 

This interface requires some documentation to answer questions implementers will have. What is the expected behavior with respect to the parameters? What do the parameters mean? At any rate, you will probably want to pass a Quarantine instance. This will help you get rid of the hacks: 

This is more of a code maintenance problem: each time we add a medicine, treatment, or ailment, we also need to modify the Patient class. That's because they are tightly coupled in behavior—they depend on each other. For a small enough project, like this one, this is fine. (Larger projects, where there may be many, many more combinations of treatments, medicines, and ailments, will benefit from a rule-based approach, but that feels out of scope here.) 

Because patients know/own what ailments they have and what treatments were applied to them, they seem ideally placed to decide what happens to them when time passes. Strictly from an OO perspective, this is good design. But the code itself is going to be messy: