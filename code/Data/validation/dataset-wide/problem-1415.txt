Your classmates solution is better, but not perfect. While he realized that you can just access an as if it was an array, and avoided the handling of , going via indexes is usually not the preferred solution in C++. It's just far too easy to introduce an off-by-one error when doing that. The solution to that is simple, rather than going by plain array indexes, stick to iterators when dealing with C++ code: 

Not that your input disabling logic would work properly either way. It only disables the inputs the first time an operation is performed, but once the inputs are re-enabled by a form reset, they stay enabled. Your method is literally breaking react, because it once again touches the DOM directly and outside the method. In case you haven't realized or don't know it yet: Any DOM manipulation your perform outside of is not properly tracked by react. React will assume that the DOM is still in the state interfered from , and will not update it. 

More curly braces and indentation please. The syntax with multiple directives on the same indentation level should IMHO only be used when the declared disposables are independent. If they are dependent, they can no longer have the same life time, and that should be reflected by the code structure: 

Providing different layouts for different screen sizes? Good. Even though a "medium" sized screen hardly requires to switch to an effective 1 column layout yet. That would only been appropriate for "small". 

That algorithm does build the index in less than 2.5 seconds for a list of 663k words. ($URL$ with ) The catch? Memory consumption is at ~750MB with php 7.0.6 on Arch 64bit. How does this approach then differ from the original one? Mostly by storing the tree in a flat hash map, rather than nesting right away. It's also storing the full prefix in the hash map. The latter one is responsible for the higher memory consumption, but it does also allow to traverse the tree from longest(!) to shortest prefix, and stopping right away when encountering an already known prefix. This little hack makes the effective runtime independent of the length of the words, you are only paying for each unique prefix once. Just removing the will already triple the runtime, and writing to the index unconditionally ramps the runtime back to the ~10s, which is almost the same magnitude as the OPs approach with php7. Actually, in the current implementation, about 50% of the CPU time is spent on , but I can't invoke it less often than that. String handling in PHP is pushed to the absolute limits here. You can do the same in C++, and probably even cut the runtime at least in halt once more. But don't expect the memory usage to go down by much this time. This is a good example of how dynamic programming can trade additional memory consumption for a vastly improved performance. Why do OOP and the array approach differ so much? There is a lot of overhead involved when working with objects in PHP, mostly related to possible magic and reflection. The compiler isn't able to just inline functions as it would in other, stricter typed languages but needs a rather long detour to dispatch method calls. Objects themselves are also nasty little beasts - then compiler can't just deduce from the context as what to interpret the memory block, like any compiler in C++ can, but the Object itself holds a lot of metadata, including the information what datatypes it members currently(!) have and alike. The compiler will surely try to work around this, but as PHP is weakly typed, only rather simple constructs will be efficient. There is actually a tiny difference between the implementations: 

That's a global variable you created here. Unless you have a very good reason to do so (and trust me when I say you almost never have), don't. You should have instantiated inside the function instead. 

That's one of the benefits of PHP, you have always a hashmap at hand when you need one ;) Supporting only a single level of nesting Let's see what happens if we add another generation of children. suddenly lists the child with grandchildren as another regular root. Ups, that did not go as expected, did it? Not using the return statement in a recursion This points out that you have a rather weird understanding of recursion. When you do a recursion, your goal is always to to break the problem down into smaller problems, and to return a partial solution. In this case, respectively for a tree in general, your goal is always to completely construct a single sub-tree, starting at the current node, prior to passing the current tree back to the parent context. So in short, for traversing a tree, the recursion function looks something like (pseudo code): 

Reinventing the wheel. While it is possible to fix the flaws in the design to get the recursion working properly, storing a tree with a fixed order in a database is actually a standard problem. A problem to which much better solutions than explicitly storing parent-child relations are known. Before we go ahead, ask yourself a question: Given that the database actually contains a much larger tree, and you only want to fetch a sub-tree starting at a given node, how would you do that? Right, you couldn't, at least not without modifying the algorithm slightly. You would always have to fetch the whole table content. There is actually a model which provides that, and also gives the sort order of children for free: Nested set model Have a read for yourself, knowing how these structures work can never hurt. 

Still rather comprehensible, isn't it? Unfortunately, the drawback of using and references is that updating the database just got slightly more complicated. It's generally better to just use a index which can be sorted by. So best drop and again, and instead just add an field which contains a unique number for each entry. You can then just fetch the rows in the correct order from the database, and the previous algorithm already yields the children in the correct order. (Bonus round: Ensure that is not only ascending for all children of a single node, but also when traversing the tree in pre-order. Now the previous algorithm can be modified to traverse the result set from the database only a single time, treating it as a queue which only supports the and functions. If you got that working, congratulations. Your algorithm has just reached runtime.) 

I must assume the world state, respectively the list of updates is not buffered, so this reads from the live game state? Writing out all changes to the game state to a transaction log (with all dangling pointers resolved, implemented as a list with a single producer and multiple non-consuming iterators), and then walking the transaction log for each active connection asynchronously removes this load from the main loop as well. There is no good reason why this should be allowed to stall the main loop. 

And a bug: You are placing the food randomly without checking for intersections with the snake's body. That can result in the food colliding with the snake. 

So what you have in your database isn't a tree to start with. Add a new node which is the only root to your graph, and attach all of the previously created root nodes to this new node. This makes it much easier to work with the data. 

This line isn't making any sense. Why would you factor the index in? And why ? Shouldn't this be the following instead? 

Benchmark Now let's compare how the different versions actually fair against each other. I'm testing this on a 64bit PHP 7.0.4, running on Arch Linux 64bit, 2Ghz Intel Broadwell processor with Turbo disabled. Using the word list mentioned earlier, mixed case. Best out of 3 runs each. The times measured are only for building the tree. Memory is measured with . This is allocated memory, not memory actually assigned by the OS and in use. 

You know there are other implementations of the interface than just , right? You are not even using any implementation specific behavior, so that declaration is overly specific. When declaring the variable, only declare it to be the interface you are going to use. The specific implementation only needs to be specified when initializing it. Or not at all, when using e.g. a factory. In this case, the only interface you were interested in is the one: 

Well, except that this isn't exactly a clean way to manage a collection of products in C++ either, better use a dynamically growing data type with checked bounds: 

Not using C++11 shared pointers with builtin reference counting? Respectively, any specific reason (like cyclic references) which would prevent these from working? 

Said ahead, the "fix" suggested by @BrunaCosta doesn't work either. The only way to reconstruct this information, is to record it when creating the stack. You can't identify the position correctly afterwards. This shows that you lack understanding of what data you need to compute in order to solve the problem.