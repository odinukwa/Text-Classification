Maybe my approach is crude, but the first thought I had was to use a simple dictionary with key as "ping host". If user separates command and parameters with multiple spaces or tabs, that too can be handled by preprocessing the command before indexing the dictionary. Another approach that may be more pythonic would be to convert the input into a tuple and use that tuple to index the dictionary. Maybe there is a specific reason why you require hierarchy, which is not obvious to me. 

Since memory and performance metrics are similar, coding style is possibly the only differentiating factor. Nothing wrong with solution 1 but it takes more time to read it, unless you are paid by the number of lines you write! I guess it is Pythonic to write code in fewer lines so long as readability is not compromised. I prefer solution 3. It reads well and terse. Solution 2 is just as good but it appears to be doing extra work in the sense of creating a list and then counting. Why do that when you can directly sum up the matches? 

: I think should not be doing this. When the object is created it should be initialized fully. So this line should be placed inside at the start of the part. : What if this call fails? Exceptions should be handled. There is a good chance that someone using this class may trigger file open failure because they may instantiate the same object from another object (constructor is allowing this). If you make low-level stuff easy to do, you should also provide for exception handling where things might go wrong. Files opened are not closed. In fact, it might be a good idea to open/close file handles using and methods, which need to be defined for this class. One of the things I find with file I/O is that users want control on the order in which messages are printed. The application may throw out stdout and stderr prints in a certain order and the user might want to preserve that order. Unfortunately, the current code flushes the queue of one pipe first before moving on to the next pipe. Users of this class might find this to be inadequate. In addition, users might want stdout and stderr to be redirected to files. This is not possible with the current class. It maybe okay now, but sooner or later someone will want this and they will start looking for alternatives. Just a thought: since a getter method is used for , perhaps you can consider a setter method as well. 

Code samples in this are approximate, I didn't test them. A couple thoughts: 1) You've currently called inside the body of your foreach loop. This is unnecessary, you only need to prepare your query once. You may reuse the that returns repeatedly in every iteration of your loop. This is actually very efficient, as the query will only have to be evaluated once. Once you're prepared, the preparation is done, no need to re-prepare for each loop iteration if your query structure is the same. (For the record, prepare is indeed the correct method to use in batch operations like this. In the future, if you only need to execute a single query, you could alternative use (if you need results) or (if you don't need results from the query -- it simply returns the number of rows affected by the query as an integer.)) The same goes for . You don't need to re-bind the params each loop iteration-- once bound, they're bound. binds by reference, the actual evaluation of the param happens every time is called. So let's do this minor refactor. We prepare the statement and bind the params before the loop begins, we the statement on every iteration of the loop, and we'll move the -ing of the PDOStatement to be after the loop. Your sample now looks like this, and will be a bit more performant: 

Another thing worth considering is the exception safety of . Since you're invoking it in a destructor, you're risking facing if it throws. A small block will fix it. Also, as of now, seems redundant. And yes, even with all these fixes, the semantics of seems rather unpleasant compared to more traditional scope guards. At least to me. Edit: full code - $URL$ 

Notice that you don't have to perform any checks on the stream this way. Once will reach the end of the stream it will set the on it, so the loop condition will evaluate to on next iteration. Next, use can use to find an index of the occurrence of the character in strings filled by : 

First, you can use to extract key-value pairs from the original string. This can be done by passing as a delimiter to : 

Turns out this point is invalid. Your is called twice in case of regular allocation. First time, by destructor of your string: . Second time, explicitly: As you can guess, this leaves you with undefined behavior. Older (and more common) versions of gcc and clang (4.9 and 3.6, for example) will not compile your code, since older versions of and don't use . You have to explicitly define implementations of optional allocator requirements if you want portability. 

I'd recommend NOT to use variable variables. They're generally considered a blight on the language, and people have pretty strong opinions on them. They tend to make code more confusing to read, debug, and lint; and they don't do much that you can't do in a simpler manner. 2.5) Actually, looking at your sample data array, your data doesn't look to be of arbitrary depth. It looks fixed-depth. Yes, there are number of per day, but the the structure is repetitive. It looks keyed per-day, each day has a few unique key/value sets. The only thing in the value array you seem to care about is the per-day dates and resting heart rates. You aren't using them yet, but I can also imagine maybe you want the heartRateZones, you can just grab those directly without iterating over all the other keys in the 'value' array. I'm not seeing a need for recursion at all. We can easily eliminate the variable variables and get rid of the unnecessary recursion all at once. I'd probably handle this with loops or nested loops instead of recursion. You don't appear to currently be using any of the heartRateZones. If you wanted to insert a record per zone, you could run in that inner foreach. Otherwise just delete that loop and run the in the days loop. I didn't see defined in the code sample you gave, or in the JSON data. I assume you already defined that elsewhere in your script. 

This code will corretly handle bidirectional iterators as well since inherits from . And code duplication can be avoided by incaplusating common logic in separate functions. Viola! Now you have only one pass. 

This function is immune to memory leaks since it doesn't perform any explicit allocations and is guaranteed to give you the desired "50/50 chance" ( won't do the trick). The only catch is the dreaded specialization, but in this example, it's not going to do any harm. 

But that's not everything. The 's arguments are either copied or moved, they are never passed by reference. Thus, despite , you might end up copying your arguments. To void this issue, consider using perfect forwarding (as well as ditching ): 

Notice that you can omit the second argument of , since it has the default value of . This value is very huge (in fact, it equals to the maximum value that can be represented by a size type of ), but never reads past the end of line, so everything will be good. Tie all this together and you'll get a small and readable solution: 

Starting from C++11 the most canonical way to generate any kind of pseudo-random sequence in through the standard library pseudo-random generation facilities. Like this: