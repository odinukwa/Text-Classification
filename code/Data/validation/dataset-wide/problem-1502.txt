Additionally, given the last example of Equivalent constructs, the while loop could be rewritten as a for loop as well: 

If I were you (and I am) I would take the suggestion by J H, i.e. "You're doing a linear scan through an array. You'd be happier if you were doing hashed O(1) time lookups in a set (or map)." and use the end time as the index of the output array (i.e. the hash map). Also, let us build on functional techniques (beyond array_map()) and use array_reduce() to iterate through the timeslots. By using the end time as the index, we can look for that end time in the array and if it exists, then combine it, setting the last start time, moving the combined timeslot to have the index of the new end time and un-setting the timeslot at the previous end time. Then when outputting the times, we don't need to worry about the keys, since we output the start times only. A great advantage of this is the need for referencing via the statement within the lambda function is eliminated since we aren't iterating over the keys anymore. 

Scope of Variables Unless is used outside of the code in your post (which would be grounds for making it off-topic), then you should declare it as local to the function using (or if you want it to have block scope. The same is true for and . That way those variables won't be global, which could cause confusion if you did use to declare a variable inside a function but not before that. For more information on that topic, see the section Keep your scopes close and your scope even closer on this page. Accessing DOM elements multiple times via DOM lookups are slow. It is wise to cache them once in a variable and then refer to the variable when needed. This is also mentioned in the aforementioned article under the section Cache DOM Lookups Those lookups could be added above the function (possibly assigned in a DOM ready function like jQuery's , though it is argued that isn't necessary with modern browsers): 

The on can be replaced by using . I'll let you work out for yourself how to do that, now that I called your attention to that method. And, yes, it that method works on as well, though it doesn't appear on Scaladoc for Scala up to 2.9.2 because it is added implicitly. I suggest you use the nightly scaladoc to look things up -- the documentation there is better, though it may show things not available on release versions, and so is the tool itself. 

Each condition is a function. It might be that you could write it more concisely, but I think the code is clearer if you do this: 

Part of the problem is all the exceptions. There are better ways of handling exceptions, such as Scalaz Validation or Lift's Box. Scala itself comes with , which isn't particularly flexible. On the other hand, you are not returning anything, which actually turns the whole code into a reverse : you either have or . Now, the test itself, except for checking for nulls, has a name in Scala: . Only it will not tell you what the problem was. I can think of two ways of handling it. The first is just a small improvement on your pattern matching: 

That is, if used as you did. I'd make it an instead, and initialize it at creation. I'm not sure would help you here, but might. I just don't think it is a particular good fit for BFS, but it might just be ignorance on my part. 

The first two being means this cannot be reused. However, if you turn them into , then will already return a valid iterator. 

Finally (unless I missed something), the inside can be avoided simply by using multiple , and statements like this: 

This is a fold, not a scan. A scan produces something with the same number of elements, and change the elements. A fold produces something new. 

That way doesn't have to handle the headers. Actually, the loop within that method could be replaced with a - then the index would be increased automatically. Additionally, the code in that function could be moved back out to the foreach iterating over the rows. The entire code could be simplified like below: 

Feedback The diverse colors and UI controls look good- nice work! And good work chaining the animation calls for the slide-up/down text (i.e. ). Suggestions Javascript/jQuery Cache DOM references Instead of looking up the DOM elements every time they are used, they can be stored in a variable and the variable can be referenced. Use const unless Browser compatibility is an issue - then use var. 

That could replace that function you added. Notice it uses the keyword instead of , since we likely won't need that function to output anything differently within the runtime of our program. And it appears that function is called even when there is only one element in the array. While it likely won't save much computation time to have a for statement loop over an array element with one element, it would be beneficial to avoid the function call in that case. Check that the array has more than 1 element: 

That way there is only one call to String.replace(). While it might not save much processing time or power, it can at least make the line shorter and hopefully easier to read. In addition, if there was a need to add the attribute to additional tags, that tag name could easily be added to the expression in the capturing group. 

CSS There is some redundancy that can be abstracted- e.g. both and have 6 out of 7 identical lines. Those can be pulled out into a class selector. That way if one of those styles needs to be updated, it can be done in one place instead of two: 

One good technique at eliminating vars is recursion -- it can certainly be used in this example. Alternatively, you can identify a common pattern, such as fold, traversal, etc. For example: 

The solutions given are simple but have quadratic complexity. I tried to improve upon it, while keeping it strictly functional. The solution I came up with is huge, though some of that resulted from breaking it up into smaller pieces for readability. While it is much faster, I'm not sure if that's due to an improved complexity, or just better heuristics detecting when no more palindromes are possible. I feel like it could be improved, perhaps with some Scalaz tricks. I see a couple places where I could remove some code by using an Scalaz abstraction, but not enough to be worth. On the other hand, I'm not particularly familiar with Scalaz. So, here it is: 

One could also keep a , then either use it alone when computing (instead of zipping stuff), or skip that altogether and put that computation on -- incurring the cost of computation O(nlogn) times instead of O(n) times. It would make the code shorter, but whether it would be faster or not is something I'd leave to a benchmark with a real application -- I'm guessing it would depend on actual sizes for . So, let's talk a bit about performance. Before Scala 2.10, if you want performance you should avoid methods added through implicits on critical paths. The code you wrote will probably get inlined by JIT. You can also reduce the number of computations by pre-computing , and if you make that , then you don't need . More specifically, views are not guarantees of speed, particularly if the computations are light, such as here. I'd not use them at all, unless I'm specifically optimizing the code. Doing a fixed size of multiple passes on small data structures is often not a problem. You are not changing the complexity, just losing memory locality. If the data is bigger, you can incur in gc overheads, which are more substantial. If maximum performance is required, just drop immutability and go to mutable arrays. Finally, is faster on than -- and, in this particular case, a would be way faster. Call it , however, since is a general method on traversables, while set's apply is a fundamental operation. If one of them is less than optimized, it will be . This is the most idiomatic beginner's code I have ever seen... do you come from another functional language? 

jQuery usage It appears that (in the code above) jQuery is only really used in two places (i.e. the save/download function, and the click handler for the upload link. Presuming those are the only places jQuery is used, that is a lot of overhead just for a couple functions. Consider just writing native Javascript in those places - the only reason I can think of not to would be to avoid adding a hidden download link to the DOM just to trigger the click event on it Event delegation Consider using an event delegate for the events. That way, a click handler can be added to the body (e.g. with ) or some other element that is a parent of the elements that would be clicked. For example, if all the elements used to change the font family had a font class name added, e.g. 

There doesn't appear to be a way to get the results directly from . Taking the concept from this answer, one could get a snapshot result, create an array filled with dummy values (e.g. s) and then map calls to snapshotItem(). 

And as you suggested in your jsfiddle via comments you could just omit the call to . In a large web application one might want to explicitly use but it is probably fine to omit it in a small script like this that you are likely the only one who will maintain it. Notice how I added . In your code, and are global variables because "Undeclared variables are always global."1, which could have unintentional consequences - for example, if the wikipedia JavaScript had a variable with the same name, then it would be overwritten. One style tag for each ruleset? Why not just add one style tag for the whole set of rulesets, instead of one style tag for each? To do this, just combine the three strings and call once. Template Literal Going along with the advice in the previous section, you could use a template literal to add the styles. With expression interpolation, there is no need to terminate the string to add the arguments. That way there is no need to worry about appending strings together. 

In Scala, never use unless some API requires it of you; use instead. If you have to interface with an API that returns , convert the result into an . As long as you do that, you can ignore checks, for they'll always be errors: you got a from some code that shouldn't be producing it, or you forgot to convert some return value to , or else you didn't even know you had to. Use or -- seems better suited, but either will do with the proper conditionals. Also, do not use -- use . Yeah, it looks weird, but / is idiomatic, and faster. There's a function that is used for parameter validation. Either or will do. 

We'd usually make the solution more functional. That is, move the "fizzbuzz" logic into something that returns a string, and use that: 

Scala has an unfortunate overhead compared to Haskell to do these things. Also, Scalaz will be able to do a bit more in the next version, but this works with 6.0. The gain with Scalaz is not, however, legibility or conciseness (in this code, anyway), but of composition. For instance, in the current Scalaz we can abstract most of the body of like this: 

Looks ok. A is a more interesting way to do this, since you can then auto-close the resource. There's one thing I took an issue to: 

This is longer, and handles nullness in two separate places, and doesn't protect against nullness, but I think it reads much better. To get more than this I need Scalaz: 

Ok, I'm changing the answer now that I understand what you are doing. The main problem here is -- while Scala people, in general, don't mind special operators, they don't add operators just because they can either. You can replace with the existing just by adding to any one of the terms. Views aren't often used either, and it's important to have a very good understanding of how they work if you are going to use them, and it's not that easy to gain performance with them, since the machinery they use to support non-strictness is quite heavy, and not everything takes advantage of it. For example, will create a new collection before and are applied. Views can gain when you have many mapping/slicing steps, and few elements of it are ever used. Most of the time, iterators will gain you much more performance, at the cost of the mutability problems iterators have. If you want to reduce the number of times you iterate through the list of proportions, there's at least one place where you can simplify: