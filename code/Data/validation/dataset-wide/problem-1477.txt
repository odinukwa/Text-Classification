Also, you should always use brackets in your statements, even if it's just one line. Not using brackets makes things harder for other programmers to read your code and increases the probability that unintended bugs arise. 

You have accessors (the and methods). These methods allow us to retrieve data from our private members of the class instances safely, without revealing how they are implemented. This is known as encapsulation, a very important topic on programming to understand. This is where having a properly implemented copy constructor can show its' worth, due to the fact that you can now create copies easily without exposing references/implementations of the member variables. Typically, accessors are paired with mutators, which conversely, allow us to alter the members of a class instance in a predictable and controlled way. As pointed out by cbjobar in the comments, the use of mutators changes a class instance from immutable to mutable; the data values can now be modified after instantiation. 

You have this copy constructor in your class, which is confusing because your class is mutable. Typically, we only need a copy constructor if an object is immutable. If you wish to keep the copy constructor, remove the setter and getter and change the copy constructor to this: 

You never do anything to modify , yet at the end of the method you return ? Some comments would go a good way in explaining that a bit. 

You might also want to look into functional coverage (IEEE1800-2012 ยง 19), to get an idea that your test bench has covered and spot possible coverage holes. There are plenty of advance test bench practices and strategies; such as UVM and formal analysis, that I will not cover. For your assignment automated checking and constrained randomization should get you what you need. Reminder: and are unsigned, therefore 32'hFFFF_FFFF is 4294967295, not -1 

From a style/best practice your code looks pretty good. The only glaring error is that your module is missing port directions. 

For the design Issues The biggest issues with your code is is an inferred latch because the condition is undefined. This type of latch is not ideal as they can cause area and timing issues. To remove the latch, simply assign to a determinate value; , , , or other constant (not which is still a latch). Depending on your synthesizer, may be treated as a latch. If it is, you should move the above the if/case statement. Or code STL differently and not need . Improvements Other than using declaring the port data types as , you have not used any SystemVerilog constructs. is a one Verilog 2001 way of declaring a combinational block and its sensitivity list. Verilog 1995 required instead of . Verilog 2001 also introduced auto-sensitivity ( or the synonymous ) which is preferred over manually managed sensitivity lists; especially when the list is long. Your is not wrong; it could be better. For more refer to IEEE1800-2012 ยง 9.4.2.2 Implicit event_expression list. SystemVerilog when one step further and introduced as an improvement over . throws a compiling error when one of the variables it is assigning is also assigned by any other block (if not caught here it would have been an error in synthesis). It also allows the designer to specify the intention of the block to lint, lec, synthesis, and other tools that the block is combinational logic. This allows those tools to flag an warning/error if they detect a latch in the logic. (There is for when you want a latch). For more refer to IEEE1800-2012 ยง 9.2.2.2.2 always_comb compared to always @*. You may consider changing chained else-ifs statements into an case-statement. It can be easier for the synthesizer to detect a a full case logic with a case statement than else-if statements. Since you are using SystemVerilog, you may want to consider the or prefix depending your your target area/performance/design-constraints. For the test bench The test bench is very brute forced testing only about 21 conditions; not testing an conditions where or . There are trillions of legal combinations. It unreasonable to check all of them, but you need to check the major conferrers: all legal values of , overflow, underflow, and random values. I suggest adding a clock to your test bench to synchronizes randomization and checking. This way you can randomize your values and use assertions to check them. Read about assertions in IEEE1800-2012 ยง 16. Example of an assertion: 

Using this technique you don't need any data locks. You just need a way to know when all the mappers have finished working. 

C++ has a better literal. is the literal that represents a . More Info Vector - Resource Management Allocation Vector - Resource Management Copy Swap Vector - Resize Vector - Simple Optimizations Vector - the Other Stuff 

Decreasing the size of the stack when you take elements out. This may cause a lot of work (in your code) if you are near a boundary and do a lot of push/pop combinations. It is unlikely that the memory is actually released by when shrinking anyway. 

Note: members are initialized in the order they are declared in the class declaration (not the order they appear in the initializer list). If you turn up wanings the compiler will warn you about this. If you make the compiler treat warnings as errors (as you should be doing) then it will not compile if the initializer list is in the wrong order. 

But what if you change the type of the internal container. Then you need to also go and change the type of the iterators. It is best to define the iterator types in terms of the container you are using. 

Why reset the m_value when it can not be accessed anyway when m_isSet is false. Also the cost of setting T here may be expensive for some classes. As a general comment. I don't see the point. Each class should have its own serialization operators (>> and <<) and you will need to serialize the whole state for this to work symmetrically. Anything that is not need for serialization is already marked as mutable (ie it is not part of the logical state of the object). Everything else is part of the logical state of the object. Anything that is optional has its own serialize operator and understands when not to serialize its own state. 

First thing that catches my eye.. Where are the comments?! I mean if you write good code, you don't have to write a lot of comments. But you literally have almost no useful comments in your code. What are you doing here? 

Another copy constructor that just takes up space without providing any added functionality or benefit to your program. I would remove it if you don't use it (unless it is required) Finally, the reason that your professor added the extra methods was to force you to protect your data. This is a normal practice in Java, but you really don't see accessors/mutators as much in a language like C++, for instance. 

Your overall code is good, I do agree with Wenqin that a more class-oriented approach to the shapes could prove beneficial to the structure of the program. Anyways, onto the review. You are right about the use of your statements in the beginning. This can be handled in a much easier way if you just make a to store this and call it from a single statement. That way if you make changes later, it's easier to maintain and it's definitely easier to reuse. 

Room_Carpet Class Once again, the class is designed pretty well, but the copy constructor is not implemented. 

Rule of Three Don't make things expensive for expert users just to hold the hand of the beginner. Implement Move Semantics (moving is cheaper than copying). Use operator rather than get/set (though you can have both). Think about how your class will be used with the standard library. Can you add iterators to it (that gives you accesses to algorithms). Have you though about standard matrix operations and how they can be optimized. 

The only difference is that the type actually implements the concept. The question is why is your iterator only implement the concept. 

You should define macros based on your conditional tags in the header file. Use the macros in your code. This should make it clear what you are trying to achieve. 

Unit tests are great (as is testing). When one of the test indicates a failure in the test it may take a while to find the actual problem. As a result you may want to re-run a specific test (or set of tests) without running all the tests (as all the test could take 30 minutes). As a result I would expect to be able to pass it run time arguments on the command line to specify which tests I want to run (if no arguments are passed then run all the tests). If you run unit tests in isolation you need a way to make sure that the environment is setup correctly (as some tests may change the global state). As a result most testing frameworks provide a and methods on each class. These are called before and after (respectively) each test. Why does need to know the name of the test. This should run all test suites. Otherwise you open yourself to accidently leaving out test suites. Personally I would pass the command line arguments to this macro. 

Room_Dimension Class Overall, I think that this class is laid out pretty well. There are a couple small things that I would question though; 

So what would happen if a user input a negative number? This would definitely give you output, but is it valid or even usable? Overall, your code is alright. But try to avoid uneccessary spaces or excessive blank lines, it results in code that is tedious to scroll through as the program becomes longer. Try to implement the DRY Principle as often as you can, it will result in elegant code that maximizes re-usability. Putting my suggestions together and leaving some work for yourself, is the code below: 

Otherwise, I would remove the copy constructor; it really has no purpose if your class is mutable. On the topic of mutability, you have one private member and one public member? It's a bit odd that you would expose the next node, but keep the values private. I would change the to be private: and then I would create getters and setters for it. Only do this if you are required for some reason to have mutable Linked List. 

As a side note, look at how much easier it is to read! Think about what it would be like to read your code from someone else's perspective; would you think it's cluttered? Confusing? In your , this can be broken up into methods based on shape (unless you decide to create a class for each shape). This helps in maintainability also and builds on what I stated above. 

Importing the to the global space is legal, but it is not considered a good practice. There is the risk of confusion if there are other imported packages that happen to have the same names for their own typedefs, functions, task, or signals. This is a low risk when it is just your code. However, the risk increases are you work with team members or start including external IP. I would recommend moving the line inside the modules that need it or use the static scope operator () when declaring signals (ex: ). I'll also suggest renaming the user defined type to . With your favorite search engine search for: SystemVerilog Coding Guidelines. It is a common best practice to name simple s with an suffix. s are often suffixed with . I'm guessing you are not planning on synthesizing . As a behavioral model, your fine. My only suggestion is to change some of the tasks to to guard against accidental time delay. If it is going to be synthesized, then you may want to reconsider you coding style. I'm not going to get into how it should be coded for synthesis. I will provide links to papers from Verilog/SystemVerilog experts that I continue to find insightful. (FYI, My profile page also includes links to verification resources) 

Its a bad habbit that will get you in trouble latter in life. Always use the prefix in your code. (Why is โusing namespace stdโ considered bad practice?)[$URL$ Passing C-Arrays is frowned upon. 

Had to refactor to read. But the static assert is checking that and exist and are members. But if is not a member of then you will get a compiler error above. So I think the static assert is a waste. Also in C++14 we added , and in C++17 we added for exactly this situation. If the parameter supports the method it will work but it also works for C-Arrays. So I would replace with: 

Your large number of if statements could be reduced (without reducing readability). I would not go to the extreme of putting it all in one if statement but you can definately combine a few. 

Now if you just go and remove the attribute names they may not be in the order you expect. Now imagine a well formatted URL but with another domain. 

Observation. Though you are compiling this with a C++ compiler and using a couple of C++ classes this is still C code. The style is C and does not reflect the standard idioms of C++. We refer to code written like this as . Exception Safety When you see code that looks like: