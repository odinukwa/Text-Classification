What happens if the user enters a really long path. Prefer to use . This version reads from a stream into a string that is auto resized to make room for user input. Don't manually close a file (let RAII do it). Unless you are explicitly checking for a close error and prepared to compensate for it. 

I can't fault the code (assuming it works). Looks good. But what I would point is that to improve flexibility you should probably use numbered replacement sites. The problem with format strings is that for I18N and L10N the format strings will be pulled out of the source code and placed in a separate resource file for translation. Unfortunately not all languages use the same noun verb ordering so for I18N to work efficiently you need a flexible placement strategy (so that you only need to change the string resource not the code). English: 

Implementing operator + - * / is easily done if you implement them in terms of += -= *= /=. This also provides the user of your object the opportunity to use your class more efficiently when a new object is not required (though this should be a secondary though). 

Organization of files. I normally put header and source files into the same directory. And I normally break these into directories based on libraries or executable. But I add an install target into to my makefile that uploads the to a build directory for other projects so they can use it. 

You are using fprint() rather than std::cerr (and your error messages and clean can be better handled by exceptions). Inside glxdate them members 

Design Review Not sure you need both and they seem to be the same thing. Style Review If a function is only one line do it in-line in the class rather than breaking it out. Code Review Use References Return by reference when you can (to avoid a copy). If you don't want the user modifying it then use const reference. 

Note the must be there for it to be a valid C++ program. You are using a static member function as your callback. 

If a response object from the server is required: Then you need to provide a map of expected package ID to function that know how to build RespPackages of that type (this is because package ID are Request specific and overlap. 

Also note that the stream operator returns a reference to the stream. Which (as stated above) when used in a boolean context will convert itself to value that is useful using 

Blocking Vs Non Blocking Socket Blocking sockets are not a very useful concept on a server (especially if you have the 10K problem). They have some utility on simpler clients but I still think it much more advantageous to use non blocking sockets. Thus I see a red flag when I see this: 

Optimize Copy Constructor/Assignment I believe what is getting at is that the copy/assignment operator can be optimized under certain situations. If the type has a no-throw copy constructor and no-throw destrcutor then we can optimize the copy of the array. The Copy/Swap idiom is designed to be great when there is the possibility of failure and if that happens uses RAII to cleanup and destroy any temporary objects created. But if you don't need that cleanup then you can use an optimized version. This is where the keywords comes in. Using template meta-programming we can check if these operations are safe and plant the appropriate code. I can see the basics here. But my template meta programming is not something I can do of the top of my head for something like this. So watch this space. Initializer Lists Some obvious constructors missed. We are now in the land of C++14 and rapidly approaching the next version is supposed to be out next year in C++17. So we should allow at least 

Its not very portable and only really part of the MS project. This header files are part of the C language. Don't use it. 

The should return a reference to the object (so it can be updated in place). As such it is not normally const. Also this method is usually unchecked if you want a checked version you should add the method . 

This means it is pointing at some random piece of memory. When the destructor is run you delete a random unitialized pointer. You actually did the assignment operator correctly and the hard way. Though if you had user defined types rather than in your object it may not have worked correctly. 

I disagree with the . C++ string may use a couple more bytes but if general usage will be quicker because the size if pre-computed (you would be surprised how many times the size of a C-string is re-computed). 

I would avoid unless you really want to flush output (usually not the case). Prefer to use in its place. 

But if you have a lot of dynamically allocated stuff this may not be suffecient. You could pass a then check of the subscriber is still available before sending the message. Use the new foreach loop 

In fact there are situations where this is bad. But in general you should let the destructor close the file. The destructor will close the file (and importantly catch and discard exceptions). You should only call close() explicitly if you want to explicitly handle error conditions (there are cases where this is important, but usually not). 

Your use of exceptions is on the edge of being acceptable. Some people will say it is OK others will say it is in-appropriate. Personally I could go either way depending on what the application is doing. What you should keep in mind that exceptions are used to transfer control when an error occurs but should not normally by used for control flow. Error codes/status can be good internally, but don't leak them outside your interface. The other thing I would point out is that you should probably not use int (though I suspect you were just doing that as a demonstration) as an exception. Either pick one of the standard exceptions or build your own (derived from std::runtime_error). 

You know what the types are so why not be specific (personally I think that will make the code easier to read). 

You are constructing into location 0 a new object without calling the old objects destructor. If your type is anything non trivial this will screw up any memory management. BUG 

You should define the copy constructor like normal. Then define the assignment operator in terms of the copy constructor. It is known as the . Also you don't set up the members. This means unless the assignment operator only sets the values you are looking at undefined behavior when they are read. 

The only problem I see with this is that after you have started using the stream any attempt to imbue can silently fail (or it used too they may have fixed that in C++11). Now I assume you are trying to force this initialization before use with: 

Code Review Just wondering if there is an EC library inside windows. Best to be descriptive and long winded here. 

USe standard algorithms when you can. There is a standard algorithm for removing space. Easier to use that. 

No. Move semantics leaves the source in an undefined state (this is not what move semantics are for). Move is used to move an object efficiently to a destination where the source is no longer valid. 

Your is fine. But I would make it more generic. Rather than print to you should print to a generic stream (you can always default to std:::cout. 

It has no place in your code. If you want to remember old code then use version control software. There is lots of free stuff around. A very popular one nowadays is . You can even host you repos for free on . Not much point in using a class if everything is public. If you are just using it is a property bag (ie no methods and all the code is in BST) then you can use struct as an indication that this type is not that important. 

Placement of '*' and '&' In C++ the '*' and '&' are part of the type information and usually belong beside the type not the variable. This is the opposite of normal behavior for C. 

The constructor does the initialization. It may defer to an initialize method but that should not be publicly available. But maybe you mean reset? Don't re-do work 

There is not enough information to give a real review. If you fill in all the type information and make it a compilable function I will review your algorithm, but based on the available code the only thing I can review is the style. 

If you want to keep using your original code. Then you should know that the way you are doing it also biases some numbers slightly more than others. returns a number in the range [0, RAND_MAX]. If this number is not an exact multiple of your divisor (e.g 10). Then the numbers greater than have a slightly lower chance. Let me illustrate. Assume RAND_MAX is 65534. Then the numbers 1..4 have a slightly higher chance than the numbers 0,5..9 If we count up all the potential results from modding by 10. 

This will work 99% of the time but if somebody starts logging (using one of the std:: streams (in/out/err/log) in the constructor of a global scope static storage duration object then all bets are off). Since this is a rare case I am not too worried but you should document this somewhere like at the top of the header file (assuming it is still a problem). I don't see a definition for or or or 

There are several places where a failed call to pthread_X results in you abandoning the initialization of the object and returning. The problem with this is that you now have an object that is not in a consistent state (people can still call start() stop() and addTimer()). If something fails during construction it is best to throw an exception (If an object is bad then you should not allow it to be used). Your problem here is that the objects you are initializing in the constructor are C type objects that have a separate destroy call that must be called (but an exception from the constructor will prevent the destructor being called). As a result you may find your self wrapping each of the C objects in their own class to make sure they are automatically destroyed correctly. The assignment operator for Timer: 

But I think an easier way is to alter the shut down code. The reason is set inside a is that if we set inside then threads will start to exit the main loop in as soon as is set to true; even if there is still plenty of work to do. But we see from the discussion above that we don't really want to modify in a child thread as that adds a whole set of problems. So an alternative is to alter the termination condition. 

What if I type on the input? As user input is line based. Most programers decide to get a single value at a time. 

The user of your code should never be manipulating any of the internal members of your node structure. They should only do that threw the access functions you provide (to make sure the internal structure stays consistent. PS. You can set everything to NULL by zero initializing your object on construction. 

The shift left by 3 is very cryptic. Multiply by 8 or explain what you are doing. But a better solution is to multiply the number of bytes by the actual bits in a byte. If you want the number of bits in an integer: 

Ring Buffer has no resource management. So remove its destructor. It does nothing useful anyway. Don't use inline were not needed 

Tokenizer is complex You can seriously simplify by using self documenting code (split reading each token into its own function). Your current code is complicated because you are trying to read all the different types at the same time. The good thing is that you can tell the next token simply by seeing the first character of the next token. 

Note 5: You may think this is C++ but its not. This is a C implementation and not a good one. The javascript version relies on an engine written in C++ that is highly optimized. If you don't apply the same techniques that were used by the javascript engine that I am not surprised you get similar results. I would expect the C++ version to run 100X faster (not 4X) than javascript.