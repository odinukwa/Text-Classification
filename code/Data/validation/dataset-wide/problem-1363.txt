After fumbling along for some time I have come up with the class to help me in my formatting quest. This class extends the functionality with: 

Before attempting to refactor your code it needs to be understandable, and one major issue is poor naming of the variables. This makes the code almost unreadable, as we don't get any hint as to what the variables are supposed to hold. This combined with zero to none comments regarding what the different methods actually are supposed to do makes it really hard to give you good suggestion as to how to improve your code. So for starters, I would go over all the variable and function names, and make them clearer and let them indicate what they are actually used for. Add docstrings to define what they return if not given by function name. Function names like aren't good, as they give no indication as to what happens when it has checked something, or if the function has some side effects like changing the current solution. Try to aim for something more like , with a description of what is a valid solution, or . A suggestion could also to be to add a function which prints the current solution, where you could split the lines at the current row length and use lowercase characters for the unoccupied fields, and uppercase character for a tree placed in that field. For the first few lines of your current output example: 

There are flaws in your design, and room for improvements, so here are some comments to choice of coding algorithm: 

In this answer I'm going to review a single part, and that is the repeated code for generating the various GUI elements related to the counters, and the repeated counter code. Please do read the other answers, and implement the good suggestions from these such as using for the file reading, and so on. Now let us stretch your imagination a bit, and aim to make it more general. This is based upon the fact that whenever I see variables named with numbers, it triggers some automation mechanism in me. Any numbered variables could be replaced with an array or list of some sort. In your case you want to test various character characteristics of all text in a file. What if you could add those test methods into a dictionary, and do stuff related to this dictionary? Luckily, you can actually do that in Python, and you can use your own functions as well: 

Algorithmic review with proposed solution Often challenges like these present all needed information related to solving the challenge. On top of the information given, which includes a very specific remove element from middle of stack and leave at top, you've chosen to implement a tree structure, re-implement a stack/enqueue, and also using dicts for remembering touched values (or similar). This kind is kind of like shooting sparrows with cannons. There is actually no need to use such big guns here, let's review parts of the challenge: 

If you create a two-dimensional array in java, , and use (from ) to print it. It'll print something ala: . And has the value . This I interpret that the first dimension is zero-based rows, and the second dimension is zero-based columns. In your code you intermix and and use the when calculating the (which I read as height or rows). In addition you add an and to the mix which makes everything very hard to read. So I plain and simply gave up trying to understanding what your algorithm tries to do. The last two variables further add to the confusion with one and the other . Is the to the right or left, and what happens when you start iterating? Helper methods In order to try figuring out what is really happening I made these three helper methods and variables: 

This version runs substantially faster than your version. Here are some timing tests, where I left out the buidling of prime list, and left out your versions when it took to long: 

Combine these, and you'll get a fast enough solution. Style review of current code Some tips according to PEP8: 

Implement a better test scheme Your tests are executed but you only have a visual test of them. A much better option would be to use doctest. This would allow you to write tests in the header of each function, and you could be sure they all works as expected. Something like the following: 

Then you can replace the cryptic with a more meaningful variable. Similar can of course also be done instead of using and friends... This alternate approach in addition to some of the other comments related to only read what you need, and avoid the when you actually mean , and prebuilding regexps, and other suggestions in other answers should make your code a lot faster, and easier to maintain and understand. 

In other words if you decompose each of the numbers of your range, and then count how many of each you need to create each of the numbers, this can be used to calculate the answer directly. To help you get on the way for the range through let us decompose the final numbers as well: \begin{align} 11 & \rightarrow \mathbf{11} \\ 12 & \rightarrow 2 * 2 * 3 \\ 13 & \rightarrow \mathbf{13} \\ 14 & \rightarrow 2 * 7 \\ 15 & \rightarrow 3 * 5 \\ 16 & \rightarrow 2 * 2 * 2 * \mathbf{2} \\ 17 & \rightarrow \mathbf{17} \\ 18 & \rightarrow 2 * 3 * 3 \\ 19 & \rightarrow \mathbf{19} \\ 20 & \rightarrow 2 * 2 * 5 \\ \end{align} I've bolded the numbers not already present in our set, and those are \$11 * 13 * 17 * 19 * 2 = 92738\$. So the end result will be: \$92738 * 2520 = 232792560\$. So there you have yourself a new challenge: Implement this alternate, but more efficient algorithm. 

I've not commented upon the usage tests as I consider those test cases to illustrate usage of the cleanup variants. And they look nice enough, although I would probably use as a function, and introduce a little vertical spacing (with comments above instead of after code). Refactored code Here is my suggestion for : 

Having this helper class, , eases the task of the main class quite drastically, so I provided some extra methods to allow for retrieving the name/value combo by index, or by name, so that one could verify that the is in the right place. Some other comments related to the main class: 

I think one of reasons that this question is on the verge of getting closed, is that the code presented doesn't make much sense combined with a question of iterative version. But let us come to back that. Code and style review 

Using this construct would allow for your code to be reused as a module later on, whilst still allowing it to be run directly from the command line. It also makes it very easy to understand what happens just skimming the code. 

And if using Python 2.x you should use as it doesn't generate the list, but uses a generator, which in turn will save you some memory and gain a little performance for large \$n\$'s. Code review You don't need a list comprehension to initialise all the off-diagonals values, you simply multiply it. With new variable names, and a docstring your function could look like: 

What I'm trying to say here, is that you need to extend your test regime quite a bit, and get real life examples when testing. If possible, you should build more complex test scenarios in addition to the happy flow or basic case which you are already testing. 

Added: My little rant on Usually one sees this construct in stuff like or , and I know the syntactic meaning. These reads as Increment index before getting array element at the new index position and Read array element at index, and then increment the index. It has it usages, but can also be rewritten in most cases to something even more readable. The two usages which I don't get used to seeing are: 

I runned your version, and mine version multiple times with a few various texts. With the default text you supplied your version used 440 µs, whilst mine used 27 µs (7 % of your time). When tripling the length of the text, yours used approx 4 000 µs, whilst mine used 77 µs (2 %). Tripling the triplet, your used 15.7 ms, and mine used 151 µs (<1 %). As can be seen, your version is growing faster as you always check everything, whilst my version depends on actual number of palindromes in correlation to length of text. Somewhat imprecise one can say that your algorithm has a constant time complexity \$O(n^2)\$, whilst mine has \$O(n*m)\$ where \$n\$ is length of text, whilst \$m\$ is number of palindromes. As number of palindromes is usually quite a bit lower than length of text, my version tends to go towards \$O(n)\$, whilst your version remain constantly at \$O(n^2)\$. 

At the bottom is a new version, addressing most of the issues you're wondering about. But let us give a review to explain the changes: 

Now the only thing you have to repeat is the class name, but otherwise this should follow all of your guidelines. Code review Regarding your coding of you could return a generator object directly if you use the following: 

I'm not quite sure I understood your requirements, but as I understand it you want to find the variant id for a set of values with the values for the three options. In other words, you need to do a double join in order to access the three different values, this can be achieved using some thing like this: 

Alternate solution My suggestion is to use boolean arrays of dimension to keep track of whether all numbers have been visited. In the standard case with , there would be 9 arrays for keeping track of the rows we're checking, 9 arrays for the columns, and 9 arrays for the squares within the board. Instead of using the possibly expensive or the slightly unreliable sum of 45 for checking uniqueness, I suggest to check the value to be in the correct range, and that corresponding value cell in either of corresponding row, column or square has not been visited before. Here is a tested implementation of this algorithm: 

This doesn't require any memory besides the original text, loops through the entire text in one go, and calculates the points for word counts starting with either a vowel or consonant. Feel free to test this one with text length of 1000 or more. Tested it with a text of length 1.5m, and it completed within 0.35 seconds. 

The answer by Joe Wallis got me thinking about an option of just popping the last values of a list which would make for something like: 

Performance review I've timed four solution based on answers so far: Original solution by compguy24, solution by SuperBiasedMan, and two variations of mine solution. In order to time them I've done a few adaptations, and only focus on the build of the data list. Here is the interesting part of the performance setup: 

I might be missing something because I don't really understand why you have the four almost identical statements at the start, which only vary in the name and in the . My suggestion would be something along the following lines: 

You are in for a treat, first of all a style review of existing code, followed by a code review of your current code, followed by a code refactoring, and topped of with a performance review of current solutions. All a part of the experience here at Code Review for free! Sit back, and enjoy. :-) Style review Actually it seems like you've done some coding before, and so most of the style is quite good. There are however some issues, and they are all related to naming: 

First of all, I'm not proficient in any way with Lua, but I do know programming in general, so this review is based upon that knowledge. I'm sorry if I say something which is dead wrong when it comes to Lua. Use spaces and indentation to your advantage Readability of code is crucial in any language. Even if the language it self doesn't require a fixed indentation (or braces), using indentation will help readability which in turn helps understanding and maintaining the code. So instead of: 

In this code I've also added a few comments to explain what is going on, which was missing in your original code. And I used a little longer, but more descriptive variable names. Note that this method has the same space complexity as yours, as it creates a string to be returned, but the time complexity has been halfed as it only traverses the string once. Performance comparison I did a simple comparison test at repl.it (see complete code), running the reversal of a given list of domains (including your samples) 10 000 times, and taking the time. Your version clocked in at around 0.024 seconds, whilst mine clocked in at around 0.013 seconds. That is almost half the time of your code, or a 50 % improvement. Addendum on memory cost It has been argued by LokiAstari that my solution is not the fastest one, which is a claim I haven't made, and that the cost of memory allocation is more important than traversal costs. When comparing mine versus the OP solution, the memory cost is almost identical as both solutions uses a as input, and not a mutable string. And timings clearly indicate which solution is the faster. If you change to a mutable string, and does an in-place edit, faster solutions does exist, where one is presented here. This does use the double reversing method and in-place editing, but is even less readable and understandable than the OP version, from my point of view. This solution claims to be 3 times faster than my solution (half-heartedly transformed into an in-place edition).