This achieves the desired data reduction. But now you haven't got objects yet. Can't be done by this query, because they also contain data from . This final step can only be achieved by joining the result in memory with : 

If you forget to use (or don't want to apply) the modifier, it will no longer be a shallow copy (because is typically used for navigation properties). It relies on unmapping properties by attributes. If at any time in the future you start using the fluent API for that purpose you'll change behavior in an unexpected place. 

You evidently want to clone mapped and scalar properties only. Your approach works (if you remember the error sources), but I'd prefer to use a method provided by EF itself: 

Single responsibility: a controller shouldn't also have Unit of Work responsibilities. The context itself is the perfect Unit of Work. You don't always need Use dependency injection. 

It's not necessary to set the return string all the time. You can first look for occurrences of with an incrementing parameter of the function. Only after no (new) occurrences are found, or when the required max number of occurrences are found is it time to set the return string: 

As a loose definition, repositories are supposed to expose the database tables as collection-like interfaces to the application code. So it's expected for them to have , , and methods. But what's the use of a method like ? Remember that consumers of the repo only see the outside. They'll wonder "am I going to insert a context? And into what?" This is bad, but the really bad thing is that the method has vastly unexpected side effects: it replaces the context's by . How can consumers even begin to expect that to happen? Together with the first point above I don't understand anything of these methods receiving as a parameter. No composability. OK, now if the above points wouldn't exist, you'd be left with a pretty regular repository. The only problem would then be that you can't use it to compose queries efficiently, because the "get" methods return , not . Take this example: 

Yes, there is. In fact, a very nice way to solve this code redundancy issue comes to mind if you consider that is a just type alias for and an alias for . Likewise, and are also just aliases for and , respectively. This allows for an easy template-based approach to the problem. What really suggests itself to me is keeping this alias-of-template-base-type pattern from the STL (although there may be other valid approaches as well), an implementation of which could look something like this: 

There are a few things here that could improve your code (whether the code becomes more succinct or not is a matter of debate, but it will definitely become more readable): 

is not a good practice, because it can make your code harder to read if you are using a lot of standard functionality and introduce hard-to-spot name resolution problems. While that is less likely to be an issue in short programs, I still advise you to not use it (creating good habits is worth a lot in the long run!). Don't do too much on a single line! In particular, don't , because, on the one hand, you are likely to forget an initializer or a part of a type here and, in the worst case, end up with undefined behavior, and, on the other hand, it is just hard to read for everybody not familiar with your code (such as I). Please split that line up into multiple definitions and declarations. Also, ... Initialize and use variables as locally as possible. This not only prevents scope pollution, but also increases the readability of your code. As a reviewer, I don't want to (and even cannot) keep a mental map on more than a handful of variables, especially if I have to remember them through large blocks of code where they don't even appear once. To my understanding at least, the term decimal implies floating point numbers, not just integers. Please think about clarifying, e.g. by writing "decimal integers" or something alike. Your code does (probably) unexpected thing for numbers smaller than 0. Since you take input as an and also do virtually no error checking, you could end up with the user inputting a negative number, for which your code will output 0 for the binary and 0 for the decimal representation. If you don't want to accept negative numbers at all, should be unsigned. If you do, change your implementation to work correctly for those. Either way, you should do input verification on the numbers (or non-numbers) you get. Don't use . If you want a newline, simply write . The reason is that does more than the name suggests. In particular it writes a and flushes the underlying buffer which is very rarely what you want or need to do because it seldom yields any benefits and can decrease performance. Order your includes. In general, alphabetic ordering is expected to enable fast header verification for people reading your code. Write meaningful comments. In particular, follow the DRY principle in comments as well as code, which means that , for example, should go without the comment because it only repeats what the code does. Instead, try to us comments to give reasons as to why you're doing something, and don't overuse them because you've read somewhere that "the more comments, the better". Usefulness and clarity are key. is not exactly what I would call a good variable name. Most of your other names are good, but this one identifier is definitely not. How about something along the lines of instead? If you have access to anything , use in place of because is fragile and convertible to a lot of things that are not actually pointers. 

Since it may not always be clear if the program control flow will end up calling the method it may seem sensible to load the collection always. But that would require any old time s are loaded, even when they're not needed. Load right before is going to be called (if possible). 

As I explain here, the EF model is primarily a data layer. Its classes may be suited for other roles, but their primary responsibility should always be: smooth data access. Your question is about combining three possible roles an EF model class could play: 

The second part is OK. Getting the most recent item from a collection always requires some ordering that defines "most recent". Note that using the improved form, EF will translate this into one query, because isn't materialized yet. It is an expression tree1 that can be merged with the second expression. If you want, you can create one statement in LINQ as well: 

In short, this would mean that each step in a workflow would be represented by a service method. The UI just issues commands and reads results. It doesn't contain any business logic whatsoever. 

Whether or not you should set up a UoW/Repository layer on top of the UoW/Repository implementations that EF offers out of the box (/) is a question I consider beyond the scope of this review. You'll find many many opinions about this on the internet. But a couple of things are definitely wrong. Repository's internals 

Where's Commit? No, I didn't forget the method. The fact is, repositories shouldn't commit. Maybe this is surprising, but if you think about transaction management it becomes obvious. There may be business transactions in which several repositories are involved. When each repo has the potential to save all changes, it may be very hard to figure out which one is able to save at the right moment. That's the reason why generic repos always come with a Unit-of-Work pattern. This is all explained well enough in the link above. You can see this problem lurking in your code. At the end you have 

This review is not comprehensive. There is likely much more in your code that needs to be addressed, but as it currently is with code structure and readability, I am unwilling to spend my time analyzing the logic of your code (maybe someone else will be kind enough). I suggest you read my suggestions, then take a look at a good C++ book, then read the C++ core guidelines. Afterwards, you should improve your code and submit it for a second review. Do not become discouraged, writing good code is hard. 

should be . I hope you agree that the latter expresses your intent much clearer. Instead of , include . The former is a C header, the latter is the C++ equivalent. Also, should include (or similar) for . Even when dealing with C APIs, please try and stick to your C++ coding style as well as possible. This includes not using C-casts, using instead of , using functions from the C++-version of the C standard library headers (looking at you here, ) etc. If your member attributes have default values (such as and of have), you should assign them in default member initializers, not in the constructor. This prevents undefined behavior from missing an initialization somewhere in more complex cases and also declutters your constructors a bit. About C-style strings and string buffers: Don't use them. C++ has better things to offer:, (since C++17), even . Even if those are not to your liking, please take the time to find a better method of passing data around than pointer-length-pairs. Some typos: should probably be . Similarly, should likely read . 

... assuming that simply s the entity to the context. Now EF will see and as new objects and (try to) insert them on . So how to assign the and values? You could do that in a very generic way that will solve this for any you add, not only copied ones, even removing the need of this constructor. It's by overriding in your subclass: 

All other pieces of code that wrap this part can be deemed redundant. As the ultimate (over) simplification you could even write this code directly in an MVC controller's action method. No added layers involved and the job is done. Useful layers? Anything added on top of this base line should be carefully considered. Additions should be useful, not restrictive. Your proposed architecture is restrictive because it is "vertical". You seem to have a column of abstractions for each entity: , (as ), with subclasses like . Then there is a class, maybe part of a similar column. This architecture has the same drawbacks as Data Access Object: it will lead to multiple isolated queries and repetitive code. Alternatives? This columns-per-entity setup defeats the purpose of an OR mapper like Entity Framework, which is to work with object graphs that map to a relational data model. When you need orders and their related customers you can get them in one LINQ query. Likewise, when you want to save orders and customers, you can add them to the context and do one call to save everything in one transaction. This has made me move to API-oriented architectures. I usually create services that live for the duration of one web request. Each service has a number of methods that execute some business case, like creating orders. For this, the service has one context instance that can pretty freely be used inside the service methods. This works best in combination with dependency injection (or Inversion of Control, IoC), but that's not a prerequisite. This is, very briefly, what it could look like: 

Code Explanation: First, use a two-dimensional array. Each row holds details about the question, answer, and choices. The number of rows is equal to the number of questions. Dedicate column 0 for question, column 1 for answer, and columns 2 - 5 for choices. A sample array content is shown below: 

For instance, in row 0, the question is "1. Which country currently emits the most greenhouse gases?"; the answer is "B"; and the choices are "A. United States", etc. Since you have fix index dedicated to hold a particular value (column 0 is always question), it is a good practice to declare it as a constant inorder to make your code more readable and reliable (less error in encoding). 

In line with @M. Mimpen's answer, get all methods of object and store them in , where the key refers to the key from your parameter . An alternative to this, is putting an entry to Map every time an entry is added to your (the one you pass to the method). 

You can use the shorthand using the operator for simple if-else. Thus, your code will look something like this: 

@Heslacher's and @Sleiman Jneidi's answers are really good. Just in case you want to have a list implementation, you can compose List inside your custom-defined Stack ADT. This way, only stack methods will be exposed outside, excluding that of List's. 

Second, breakdown your main process into sub-processes. For each sub-process, handle them independently. In case that there are required fixes to be done in your code, you only modify the sub-process(es) responsible for them. Sub-processes: 

Side note: Dapper's Multi Mapping Feature won't alleviate the first two points because it also creates separate object instances for "equal" entities. So all in all, I wouldn't do this. I would get the data separately and perform some sort of "relationship fixup" manually. 

These s generate a very wide query (as you show), because all fields of as many as six tables are queried. Often, when tackling performance troubles, people focus on reducing the number of rows that are fetched by a query, but reducing the number of queried fields can be at least as beneficial. This is especially true for ORMs, where materializing entity objects can take a significant amount of time. So it would make a lot of difference if you'd project to the view models, and in the LINQ query as , i.e. not after . This would narrow down the query to only the fields required to populate these models. However, you don't do this, obviously because this function call is not supported in a LINQ-to-Enties query. Then, of course, you also query too many records. In the end, you only need data from one and one , but because of the s you fetch all seasons and all episodes of a show from the database. The Solution I think you can both reduce the number of queried rows and fields if you start the query at the bottom. If a user watched an episode, they obviously also watched its season and its show. So if you get the latest episode directly, you don't have to worry about getting watched seasons and shows any more. You don't need this function, because you start by getting the latest episode. Further, you can get required data by accessing parent navigation properties. Like this (only showing the essentials): 

There are different algorithms for finding the most significant bit, but usually an iterative approach works well enough. The general idea is to iterate the number bitwise from the most significant to the least significant bit, checking whether the current bit is set. If it is, return the current bit position. In code, this might look like this: 

Design Issues If there is one thing that bothers me about your code, it's that template parameter. First off all, why would you code that into your class if you could just use and be done? Secondly, I would argue against adding additional functionality to iterators. After all, the reason for having iterators in the first place is to have a uniform, pointer-like access to the contents of a collection. Adding additional functionality into this interface violates the principle of minimalism that the design is based on. Other Things 

Do not use , it can lead to hard-to-spot name hiding errors. Read Why is “using namespace std” considered bad practice? for more information. Be more generous with horizontal white space. Lines like are hard to read and do not gain you any advantage over . Do not try to fit more than one statement into one line. Things like are usually discouraged because they are ugly and hard to read. Putting onto its own line is not going to hurt your code. All caps variable names are unusual to say the least; most of the time all caps style is only used with macros. Thus, should probably be . Do not use for everything. One reason for this is that can overflow and cause undefined behavior, the other is that your code should also express the intent it was written with. Since is a signed type, you imply that a user could also enter or any other negative number for , and also that some prime numbers could be negative (Why else would be of type ?). If you are only dealing with positive integers, use (but be aware to not decrement past 0).