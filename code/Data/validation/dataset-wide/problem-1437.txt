The component receives a as a string and a as a string. The contains key-value pairs or just the values. The describes how to turn that into a Java object. Firstly, we parse the into a Java object (schema format is known in advance). There is an with possible , which imply the format (it can be XML, JSON, or something custom). So, the contains this value as well as some additional information (like the keys if the only has the values, so we can later map already known key names to values and we don't need to send the keys every time over the wire). Now, that's how it works: 

Result: msgJson is now: {"Metrics":{"agentId":"12230","callsPerDay":"15"}} Now, I'll explain the classes briefly (too much code to fit here): Serialized: Has a private field, sets in the constructor, there is a getter. Deserialized Serializable: just an empty interface. Should I implement Serializable? I don't really know much about it, just seems appropriate. Schema Deserialized: represents an abstract Java Object for any kind of . Has a getter for FormatMessage value. Message Deserialized: represents an abstract Java Object for any kind of . Has a toJSONString() method. Parser: empty. Because for a message I need 2 parameters, for schema one. ParserMessage Parser: has a method ParserSchema Parser: has a method Format: empty FormatMessage Format FormatSchema Format For each FormatMessage value, there is a concrete class for Message and ParserMessage. For each FormatSchema value, there is a concrete class for Schema and ParserSchema. Obviously, ParserSchema returns its corresponding Schema and the same with messages. Now, the main part: Deserializer: has 2 methods: and . For both he accepts a Format (for message in a form of schema). Inside those two methods this class uses a by calling methods named and . Inside those methods, there is a call to a ParserFactory which holds all the concrete Parser static instances and gives away references to them by by the given Format on the appropriate . The problem is that I'm afraid that the Deserializer class abstracts everything too much that I have to cast a lot, even the caller has to cast a little. My team accepted this design, but I just want to make sure :) UPD: The code for and the as requested. 

My application accepts different messages. A is described by its . MessageFormat: represents . (, , ) Message: represents an abstract Java Object for . Schema: represents an abstract Java Object for descriptor. Contains MessageFormat. SchemaFormat: represents . (, , respecively for each MessageFormat) MessageParser: has a method . There is one concrete for each MessageFormat. SchemaParser: has a method . There is one concrete for each SchemaFormat. At start-up, all of the supported schemas are loaded and parsed one time each and kept inside the memory as concrete objects. When a message comes, we pass the message with its schema to the appropriate parser. It would be optimal to also have each appropriate parser instance inside memory (schema - parser, one-to-one). What is the best way to achieve this? My current layout is to have a switching the static parsers by asking a for the reference at the static parser that is inside that factory (as well as all of the parsers, for schemas and for messages, all are static). Strategy: 

That way I can just completely delete the and the classes. If they are present, however, each Parser in lazy-initialized and as soon as it's initialized, it's kept in the memory for the rest of the time. If I have all of the Parsers inside the enum then for each message an object gets declared and then discarded. But what happens with the performance when the application obtains 150 messages of 5 different types within a short period of time? I'm concerned that it would be really slow and the memory will bloat until the garbage collector comes and cleans it. I also don't have the way to load the schemas at the start-up, so I may choose the option with putting the s inside the just for the reason I will parse them once. But several data providers may choose the XML schemas, so, I that case I will instantiate the XML parser twice but that isn't a big deal, because there will not be more than 10 data providers. 

So, yes, I know that "you shouldn't derive from std containers" but by now it's more of philosophical rule in my mind than a technical one. I've googled again for the one fundamental reason one should never-ever-ever-ever-do-that-ever-ever-ever-or-you-die but couldn't find it. So, if there's nothing fundamentally wrong with the following and if we set aside performance considerations, can I a get a plain-old code review of this: 

Good. Now, I have to read in s from the user, decide if they are palindromes and save them in my special container. The following lines of code are quite compressed. It's a single statement that does all what I just described. 

Again, I don't expect you to grasp this fully. Just keep it way in the back of your head and revisit this post in a year... Ok, so I have my custom-made comparator. I can declare my container that will hold the palindromes. As I add s to this container, they will automatically be kept in sorted order by length. But wait, here's an important detail, it's possible that I may have more than one palindrome of the same length! No sweat, use . It does the exact same thing as but allows multiple values where the comparison will say they are equal, i.e. of the same length in our case. 

I will add one last thing. The fact that I use a (or ) does mean that this code is doing a bit more work than what you needed given your problem statement. That is, you did not necessarily wanted to keep all the palindromes sorted, you just wanted to know which one was the longest. But I offered this solution as an example to leverage stuff from the standard library that can do a lot of work for you transparently. 

Well, I have no shame to say that I just copy-pasted @MORTAL's code for that part. :) That's a , an in-place function that you don't need to write somewhere, you just write exactly where you need it. Apart from the funny syntax, the body is the same as the more mundane but equivalent function. So now we have all palindromes saved and ordered by length order. Let's print them out: 

Another call to the family. This is a plain copy and it will copy all elements where I tell it to. In this case, all elements will printed to standard output, with a newline in between. They will show up from the longest to the shortest. And we're done. 

I offer this code as something to look forward to be able to write in the future, not as something I would want you to come up with right now. What you have is great for someone at your level of C++. The most important aspect of this code is its use of . is a container that keeps its element ordered, even as you add more element to it. It's contents will always kept sorted. By default, will perform it's duties by comparing elements with a plain less-than comparator, i.e. . So, by default, a will keep a bunch of s ordered from the smallest to the greatest. Though that's the default, you can change the comparison function. The standard library already has some options ready for you to use. For example, to keep the s sorted from greatest to smallest, use instead of just . But what we want to do here is keep sorted according to their length, from longest to shortest. The standard library doesn't have something ready made for us but we can follow the example of . It would look like this: 

That's the output. That's where elements that satisfy the predicate will but copied. The function is how I tell to call the member function on my . Why do I specify ? That's make little sense. The multiset will keep the elements sorted according to the rules I gave it. It should not keep adding the elements at the beginning! Well, that function is a very generic one. It works for all kinds of container. With a , it would do as I wrote it. But with a or , that is just a hint and will be discarded. On to the predicate: