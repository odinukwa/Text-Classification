So how are we gonna keep it thread-safe AND performant? Well, first we need to get rid of the spin loop. If there's mail, the queue should start, and if mail is gone, the queue should stop. For the start condition, you can modify to check if there are threads running at all. This is a pain when dealing with 15000 mails, so consider having a scheduler that periodically checks if the mail queue is empty (every 5 seconds?). For the stop condition, well, once the queue is empty, kill your threads. It's as simple as that. You could even have a single "main" thread that doesn't die, then you could get rid of the scheduler. This "main" thread could sleep for 5 seconds if it didn't find any mail. ... I took another look at your code. I'm still not fully understanding the enum hack. Are you... having multiple threads running the same runnable? ... what. (By the way, this gives you yet another bug, where a previously waiting-for-start thread will get started and set to true). Next, now that we're rid of the spin loop, we need to fix synchronization for starting new threads. It's not possible to precisely limit the amount of created threads based on the size of the queue. For that, you'd need to determine the size of , but you can't do that without locking access to . That would require synchronization... which would give you all this locking madness for grabbing a single mail. You're better off just doing as you do now, mostly - use and just naively trust it. Besides, a few extra threads don't matter that much - either you have work to do and could use some extra threads, or you're not doing much and can handle having to clean up a mess. What's more concerning is fixing the case where more threads than the cap are created. To fix this, you can use double checked locking: 

The problem JSLint is pointing at is that you usually iterate with an index that is an integer. If you were to have an array, you couldn't use to access the array elements, because if is big enough, rounding issues may cause you to skip elements or see elements twice! What I'd recommend is that you just use as integer, and then once the for loop is done, check if there is an additional chance to roll for. That way, you don't have to worry about floating point rounding errors accumulating. Another way you could do it is first roll, and then if you roll high enough, up by 1. That way you only have one place where you run your code. So like this: 

21 characters saved. Stupid joke aside, I think you shouldn't worry about this so much. There's probably other places in your code where you're spending far more resources. This is a textbook example of a micro-optimization. You're worrying about incrementing a value by 1 and in the meantime you ignore the more complex parts of your code. 

Some suggestions: For appending the 'chr(0)', it would be easier to do an in-place append, . You shouldn't need to do , just should work for most types. This may be my personal issue, but I think putting two variable declerations on one line, such as , is bad style. For , you start the range at , then immediately subtract from it. Better to just start at . It might be a little clearer to get the values up-front and then iterate over those. You overwrite each instance of the loop, so there is no need to declare it up-front. Rather than using a list comprehension in the last line, you can just zip it. Your is just the values of rolled to the left, which can be done by slicing for lists: . However, since you only ever use the last elements of each tuple in , it would be easier to split it into three lists, one for the indexes, another for , and another for rolled . You also don't need to do the full calculation on the last loop, since you don't use any of the changes after the . 

The functions can either be s or external functions that are short and easy-to-read as values. Usually this is better with only one or a few consistent arguments. The functions are so long that putting them in an chain makes it hard to keep track of the flow. Again, usually this is better with only one or a few consistent arguments. There are a huge number of possible inputs, which makes for an overly long test chain, but where there are again only one or a few consistent arguments. 

You can simplify the recursive version of your code by dropping elements until you are left with just one, and then comparing pairs sequential pairs: 

You exclude words less than 5 characters when reading your vocabulary. I think it would be better to exclude them when creating the vocabulary, which reduces the number of elements in your vocabulary and avoids you needlessly looping over words that are too short. Considering there are only 26 letters, it may be more efficient to have a single dictionary with two character keys rather than nested dictionaries. This would reduce the number of dictionary lookups. You would need to time it to see if it helps or hurts, but one possible initial check would be to create a of each word in your dictionary, and a of at the beginning, and then use the subtraction operator to make sure all the letters in each word are present in the pattern. If not, you can skip doing a linear search on that word. But the act of creating each at the beginning may offset the benefit of the check. Sorting will hurt your performance. 

Some suggestions: Empty lists are , so is the same as . is also , so you can check for empty lists and values at the same time. You can use to get a value and set it to a default (in your case an empty list). if it isn't already there. You can convert an loop to with a generator expression, or better yet just a . Your last two tests are mutually exclusive, so the last can be an . The test does the same thing in the first line of both cases. I moved that out of the test, but if they are supposed to do something different you should fix that yourself. always has its value subtracted by one, so it is easier to subtract one before defining it. You always set to if is non-empty, so you can move that out of the test entirely. And if you put it at the beginning of the loop, you can avoid the test entirely. You can simplify this further by only getting it if you need it. 

You're missing the case where a word has more than one of the same characters. For instance, the strings and would be seen as an anagram by your algorithm. You can fix this by removing the found character from the string. Additionally, if you wanted to make your algorithm faster, you could check if both strings are the same (and if they are) before checking the length. This is only a valid option if this is a likely scenario, because otherwise you'll be slowing down each anagram check. 

And lastly, give Game a 2D array () for storing cells. This array is for iterating cells. The array is not for searching for things. That's what are for. And have the game just go through the cells, asking how many neighbors have and instances on them. Add the relevant changes to a list, then make the relevant changes. This solves your problems where your Ocean is recreated each frame. This solves your problems where Critters of various sorts need to hassle with and . This solves your problem where adding a Critter to an Ocean means you need to hassle with and . This localizes your game rules in one location. The hassles you gain are that you now need two iterations. First iteration is to find out what needs to happen to all the cells. Second iteration is to apply the changes. I think you'll want to make a new 2D array of objects to place on the cells. The alternative is storing a set of commands per critter; Whilst this does make more sense, it doesn't scale. ... in a functional programming language it would: one would create a set of delayed function calls, then execute them all after another. 

You check 4 different cases here... but instead of checking if one of them happens to be the case, why not check if it's "not the default"? That is, you define to be an empty String, and then set a value to it if you find a special character coming up. So if is not empty, then it's a special char! And aside from that, don't manipulate to break a loop. Just use for that. 

can take a as argument. Doing so would allow you to remove your call, shortening the code, making it more readable (and potentially speeding things up slightly as you need 1 function call less, but that's negligible). 

Consider declaring a variable and using . Strings are immutable, so whatever performance benefit you had with ripping open the , you completely waste it and then some here. You can then put the into a . 

And is true, so application thread 2 will soon be moving into the while loop. Now we've got 2 application threads again! Darn it. So, before we start a new thread, we should make sure that it's actually dead. Now, whilst it is possible to save the running thread, it makes things hard, so lets discard the running thread - wait for it to die first. Looking through the Javadoc of , we can find , which does this: "Waits for this thread to die." Great! 

So you can see it takes the same columns you did in your original, but keeps them in a single 2D array. And it greatly simplifies the code and speeds up the computation as well. 

If you can use the built-in module, then is probably the easiest, but it probably not allowed. creates an iterable of the cartesion product of two sequences. Since you want it with both the element first and the element first, you need to do it twice: 

It is safer and cleaner to open files with the syntax, since it will safely close the file no matter what happens. It is better to do imports at the top of a module, rather than in a function. It is a convention to use ALL CAPS for module-level constants, which you appear to have several of here. This makes it easier to keep track of what is module-level and what isn't. You re-define certain constants every time through the loop. It is clearer and faster to define them once outside the loop. It is a convention to import numpy as , rather than . This would be much easier using if you can. I will assume for now that you can't, though. Although has a link to the module, it is, as far as I can tell, undocumented. Even if it was documented, it would be clearer to use the module directly. You potentially re-use the same value many times. It would probably be easier and quicker to define it once and re-use it. Along similar lines, you write the same value multiple times. Since it is just a object, it would probably be easier and cleaner to just duplicate the value. They are small enough that this shouldn't be a problem. You use for two different things in the same loop. Don't do that. You should use a more informative name for the first . You only use a small bit of the variable. You should probably strip that off at the beginning. Rather than finding a particular value in and then slicing to that, you can just use to split it at the first , then take the first value returned using . You don't even want the , you want the frame, or rather the frequency. You create variables only to immediately re-name them, then never use the original name. This doesn't have much effect on performance, but it is confusing. I don't know what produces, but I will assume for my improvement it is an iterable. If it isn't, then just put the wrapper you have now back in. Is a numpy array? If it is, then change to . If Syntax.struc.num is already numeric, then you can drop the . If you define your frequencies in a numpy array at the beginning, you can also pre-calculate and much faster in a single step rather than at every point in the loop. Try to avoid "magic numbers", which are seemingly-arbitrary numbers in your code. They should be named variables for clarity. You never use or . Numpy has a method that converts an array directly into binary. You create , but then write instead. If you can just write numbers, you don't need at all, right? I think it would be easier to read in the future if you use the functions rather than setting everything in one big function. Are you sure you want the max value to be ? 16 bit wave files can handle .