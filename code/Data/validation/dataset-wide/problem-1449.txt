What you have, at the moment, works, but is it the best way? I don't think so. You code has a few features that are important: 

Did I mention that successful thread-safe implementations require discipline? You have to be diligent about implementing the synchronization correctly at each place it is needed. Finally, there are ways you can force thread-safe operation with light versions of locking. My general advice to people is "don't try to be clever unless you really are that clever". It takes a special kind of brain to understand all the nuances of Java's memory moela nd the way the threading affects it. If you have it clear in your mind, then sure, play some tricks.... but, even those who have i clear, mess up when they try to be clever. 

This class should instead use an AtomicReference to ensure the state is kept valid. Alternatively, you should incorporate thread-safe handling of the String. Consider: 

Now, for long strings, the above will be more efficient than your solution. It goes through each character in the string just once, but it has to create a list of what's been seen, or not. If it is a new character, it has to count it as seen. Your mileage may vary. 

Now, that Node only works on values, but you want it to be an . Using generics, this is a treat (while we are at it, we will make and private and final, and add getters for them...): 

I prefer a mixed approach for situations like this, and a second problem is your code duplication. Let me describe the mixed approach: You have a monolithic event handler, that handles the for all targets. Each of those events should be in a different function in your code. For example: 

There are a bunch of things in here that @nanny has not yet covered, so let's go through some of those: 

(but then continues to use your version in his subsequent code) This is a good suggestion, but, more than that, you have to do that (or something similar) because your version of the dice-throw does not work. 

It's better because it stops streaming when the first problem is found - it does not need to check everything. String joining 

That code gets the file-size in bytes, but then reports it in KB. Also, for that code, I would recommend a printf.... 

what if someone gives you the input . Your code will output which makes no sense. The of the minutes is a problem. You want to get . your handling around noon is very problematic. You use to test for noon, but, that should be . As it stands, your code says the input is when it should be . 

I have been testing it against some input data similar to @tsleyson's, and then added in a performance test too, that checks the scalability of a non-matching case. 

In general, the code you have is neat, and easy to follow. The QuickSort algorithm is relatively traditional, and the pieces I expect to see are about where I expect them to be. Let's go through the issues that I see though... and some of them are serious... Namespaces Using is generally a poor idea. The possibility of namespace pollution is real. In fact, you have implemented a function and there already is one , but we'll get to that. Style 

SQLite is notorious for doing calculations based on the wrong affinity of the data values. I immediately suspected that the SQL was doing integer division on the values even though you are casting them to decimal. I put some examples together as an SQLFiddle here, and I cast the values to float instead, then used the SQLite function to get things decent. Doing floating-point division is what solves the zero-value division before. This is the SQL I ended up with: 

Because your MAP_HASH_SIZE is likely a power-of-2, the is essentially the same as a bitmask of the low-order bits (or for size 32768) If all your values are similar, you will end up with many collisions in just a few buckets in the hash table. For the hash function I would consider guaranteeing a minimum size (say 16 bits, or 64K), and then having a function which at least shifts some of the x value in to the range, and does an Xor.... 

I would consider your class to be good, but the most complex part of your code is the math of adding months to it. You are already doing modulo-arithmetic in the default constructor, so I would just make your underlying unit a single value.... which is a literal value. This makes any arithmetic easy, and the presentation of the values is easy too. It also saves an unsigned value of space in memory.... note that there is no year 0.... and also that it is now limited to the year 5K or so, on 16-bit-int machines. The cost of the modulo will be low on the get-methods, and I doubt it would be a significant part of any performance issues. In other words, I would define the class as having the single and then implement the class as: 

In surveying these answers I surmised that the best solution would be to do partial memory copies rather than to-end-of-line copies. This would pay dividends in the event of multiple matches. As a result, I put together this method: 

It's interesting that you chose to put the code in its own package. I think it's great - but it does make the code a little more difficult to run as an experiment, or on ideone, or something. So, I encourage you to use packages, but remember that the main function/entry point will need to be in a different directory. Now, as a package, there should be no reason to have an exported function . Why have you capitalized it? It should be . Then, working through your functions, the next most striking thing is the poor choice of variable names. x's that are "lines", y's that are "triangles", etc. Worse, you use the variable in two different ways in the two different functions. Renaming some variables made it easier to read. Finally, the tool will re-format your code to conform to go conventions. You should always do this for your code. It helps when sharing go code with others. With those changes, I would consider your code to be reasonably good. On the other hand, I did mess a bit with the method to use instead of direct index assignment. I feel the append helps by making the at the beginning and end of the line more obvious. I also moved the special-case of the first row outside the loop of the method. This makes it clearer, I feel. So, your major issues are code style, and naming. The actual code is otherwise OK. Some tweaks may help readability - but that's something you should decide whether it's better. I put those changes together in a runnable format in ideone. 

A in the middle of your game loop is a problem. No-one wants to see that. A really simple solution to this problem is do things a little differently.... 

@Simon has a good answer about some usability issues, but I want to focus on the performance and memory aspects of it. I agree with Simon that the counter should be a long value, but, more than that, you should create a mutable long class, and not use Long (or, in your case, Integer). Consider the class: 

Note, that you synchronize on two different Objects at different times too... you sync on the as well as an instance of the Client (). Further, your concurrency is broken.... you are doing network activity in the sentMessage() class, and it calls: 

Loop/range on a channel (assume returns a channel of Frame instances), and then send each Frame down the websocket. This sets the channel as an "api" to the camera, and the logic is encapsulated in there. Now, the challenge is to set up a source for that frame channel.... A separate goroutine that polls the camera for new frames, listens to a stream and breaks on each frame, or loops on a timer (like you have now), or whatever mechanism best suits managing your camera, would feed Frames in to the channel, and you've thus separated the two concerns. You can also now have different mechanisms for sourcing frames, and still feed them in to the same method for delivering them to the websocket. 

Then, when the person enters a month, you can subtract 1, and index it back in to the above array, and get rid of all the if's: 

For the most part, the code above is a simple copy/paste of your code, with some restructuring, and variable names no longer have the qualifier. So, with the above code, we can have: 

Performance tuning can be a strange thing sometimes. My instinct is to say that the explosion/implosion of the data will cost more than any branch-prediction benefits. Also, the only use of the sorted in clause is in the database itself... which should be efficient regardless of the order of the values in the clause. Finally, performance characteristics of big datasets can be very different to small data sets. When people go out of their way to do a 'hack' for performance, it is normally only with a very good reason. Normally there is a 'good' comment as to why something is done. In this case, I can't seem to find any reference on Google why a sorted clause is beneficial. So, you should do the following: 

Common constructor Your class has a constructor taking the data, left, and right nodes, but you never supply real values for the left and right nodes, only . You should probably remove those parameters from the constructor, and just default them to null. Alternatively, have an additional constructor like: 

you initialize your class with an empty but then you throw it away and replace it with the from()'s argument. Any changes outside your class to that (bad name) will now also be reflected in your class. For example, you may sort your collection, but then someone can add stuff out of order..... You should be copying the collection content, not the actual reference: 

This is a really neat program. For what it does, it does a good job. Really, there's only one criticism, and a few suggestions. The criticism is designed to get you in to the right habits, it's not a major bug.... Using try-with-resources Java, for years, has had a problem with people being lazy about closing resources.... you open a file, read it's contents, and move on.... leaving an open file handle and other resources until the Garbage Collector cleans up the mess. These 'forgotten' resources can sometimes lead to unexpected bugs and deadlocks. In Java7, the concept 'try-with-resources' was added to ensure that resources are guaranteed to be closed nicely whether the code succeeds or not. It actually allows the programmer to be even lazier than before, and get a an even better result. In your case, the Scanner instance is a resource that should be closed.... 

And that code is obviously broken, it returns 1 when nothing matches.... For the input it returns 1... which is not what it is supposed to do. This second bug works to make the first bug disappear... because now anything matches! Alternate Solution Putting it together I figure the code is broken.... This is how I would solve the problem... a set-up recursive method, and the actual recursion. The setup method does the work of identifying whether there is a prefix match on any of the words. If there is a match, it recursively matches the subset words with the target until there is just a 'tail' left. When I wrote it I assumed that a subset word could only be used once, but, then when I compared it to your results, I found that this is not the case. I have commented out the code that enforced the use-once rule on the subsets..... 

Your code can be drastically simplified, and there are significant bugs too. First, the bugs. SQLInjection is a serious bug because it allows a malicious attacker to compromise your system. Vogel612 has already emphatically pointed that out. On the other hand, SQLInjection is simply a way to exploit a bug in your code in an intentionally malicious way... The bug has to be there first... and, in this case, your bug is that you do not 'sanitize' or 'escape' the values you concatenate in to the String query. Now, why is that bad? Well, I work with a person who's name is . You cannot save that name using your system. It fails to execute. A malicious person could use that fact to craft a name which does more damage than just fail..... A second item of interest, is that you are not running a query, you are performing an insert. Calling it 'query' is not helpful. Finally, when you do not mention a column as part of an insert statement, it gets the value null. So, you are inserting null values in to the and columns when the params are not set right. There is no need for the conditional columns if you can just insert null values explicitly. Now, all of these issues can be easily solved using parametrized statements. Vogel612 has already strongly recommended them, to solve the injection, but they will also solve the complexity of the code.... Consider a PDO solution: 

I prefer the more compact result, although it is debatable as to whether the "Outer" Join is a better solution than the UNION. Outer joins can lead to confusion. So can UNIONS and I prefer the outer join. In the above query I have removed the TagName since it is not used outside the sub-select. I also found the final 'assimilation' of all the data in the final select to have too many casts and data conversions. The actual logic was lost in the detail. I moved the complicating CASTS to the previous clauses. Finally, the indexed has caught a number of people out in the past, as it is too easy to change columns and suddenly the data ordering is off, even though the query still runs. I always recommend named-column ordering. Putting this all together, I have the SQL: 

Algorithm It took me a while to understand the algorithm. In general, i dislike the use of a because it is ugly that you have to check for the null value before you can increment the count (the value is a Counter of sorts). This part is something I believe should have been rewritten as a separate class. A class perhaps. The class could have a mutable inner class called that can be incremented/decremented in place. When it decrements to 0, it auto-removes from the Map. The removal of the autoboxing may lead to performance improvements, but those will be small. The other observation I have is that the should probably have a custom comparator that sorts in reverse-height order. This is another small item, but it is more intuitive to me to have a call to rather than The may even be better off as a completely custom class without the at all. I would have to rewrite it myself to see. Apart from these issues, the algorithm strikes me as being sound. It's not quite the same as some papers I read on the subject, but the performance time-complexity of \$O(n \log{n})\$ is in line with expectations. I do have an issue with the multi-responsibility method though, building the skyiline and appending to the StringBuilder at the same time. For more flexibility and cleaner code, you should produce list of events from the and only then convert those events to the String output... Single Responsibility Principle Resources