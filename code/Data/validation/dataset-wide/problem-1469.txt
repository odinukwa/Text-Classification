That's shorter and more readable. However in this case, it would actually make more sense for it to be a private field. 

This comment tells you nothing about the code that the code does not already tell you. It just bloats the code and requires you to read more redundant information. When you read , it is perfectly clear that the speed is being set. Comments should tell you why the code does something (if needed), while the code tells you what it does. 

and are inconsistent names. Often boolean variables are named with just the adjective ( and ), because they are attributes of the object, while the methods returning them are named and (which your's are already), because they are questions about the object's state. 

Using for exponentiation is faster and looks cleaner than using . Note that and are local variables here, even if they have the same name as the global ones. Use the function like this: 

Built-in functions You don't need the function, as Python already has one. It is called . Boolean expressions If you return a boolean value based on an expression, don't write 

You had some wrong indentation in the following two lines. Not sure if it was due to copying to your question, or also in your actual code: 

It seems like you want to check "has player 1 won but not player 2, or vice versa". Instead you check in the second part whether any of the two players has won, so the entire expression is equivalent to just , assuming that you don't have to explicitly check whether both players have won, which shouldn't be possible anyway. 

Class is open to modification should be closed for modification, this is the OCP principle. If it's not, its behaviour can be altered (by inheritance for example) and can lead to an unpredictable behaviour which make it rather difficult to test and maintain. How to achieve that ? Mark . Executor never shutdowned Once started, the executor can never get shutdown, which causes the task to be run indefinitly. How to achieve that ? Create a method: 

The is really nasty here ! One expect to only return a value but before it does some unexpected computation ! You should write it in the form of a simple getter. 

Bill What does a need in order to compute a price ? A base charge and a distance. These two values must be provided in the bill constructor. The bill doesn't have to know about the . Then, the implementation becomes (note that I have made this class immutable): 

contains only notion of blocking until the value is not computed. How the value is computed is totally abstracted here. 

There's still a bit of duplication between the but I think you get the idea. The goal is to avoid duplication in order to have tests that are easy to understand and maintain (clean tests are as important as clean production code). 

This is the kind of test I would write (I picked a convention for the names, you can choose another since it stays coherent). Given the previous refactors, the test implementations are more expressive now: 

Exceptions are (badly) swallowed is closed but not opened in this method. This could be a major flaw because it induces a nasty side-effect. It is a general idiom that the one who opens a resource is the one who closes it. is declared in the , no need to close it manually ! (it will be done automatically) 

It returns the instance of in any case where it is not the itself. But what if you ask the player that you are using for empty fields what its opponent is? Maybe you could instead use a variable to save the opponent and set it where you instantiate the players. It is not good practice to have the internal behaviour of classes depend on global state. 

This assumes that width and height are the same, otherwise it gets more complicated. Also, you need to use when you loop over the other diagonal, as the direction changes. Doing the same for rows and columns when the width and height might change, you can do the following: 

Header files You have a lot of implementation code in that header file (files.h). Header files should only contain the function or class headers, the implementation should go into an extra cpp file. That makes your code more organized and also more performant, because your code would be included as is in every file that includes your header file. Out-commented code Your ai.cpp contains a lot of out-commented code. When that code is not used any more, you should delete it instead of commenting, as you might later not know why you commented it out, and whether you can safely delete it or not. If you want to make sure not to use it in case it turns out that you do need it again, that should be covered by your version control system. 

Note that I had to invert the logic, because it seems like you are using a value of in the (intended to be constant) variable , which is counterintutitive. Try to be more consistent with spaces around operators. You write , but . Always add spaces around operators, i. e. .