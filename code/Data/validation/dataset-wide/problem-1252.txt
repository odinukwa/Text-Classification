while writing Python. If you are used to writing in Haskell (for example) you shouldn't expect to always write like that in Python, so I think you should reconsider your ideal. As for an actual correction to your code: If you're going to call on , you might as well use a list comprehension, change: 

Naming conventions The PEP 8 style guide says that functions/methods should be and not . So for example should be . Some better naming For something like: 

Remember readability is subjective, look at something like APL for example and you will see that APL strives for code most closely aligned to math. The creator of this language purposely designed the language to be effective at representing math operations (in particular, matrix manipulation) and it takes a vastly different approach from Python. One interesting thought experimenet: If we grew up and learned that the word "print" was simply "p", "print" would likely be considered not readable and we would replace each case with "p". However, in our world, we consider the opposite to be true in most cases. For me it is much easier to read instead of something like because I have learned to appreciate the former. The only thing I would consider changing is getting rid of and just writting it out explicitly (unless there is some worthwhile performance cost in doing so). 

So what if ? Then It doesn't cause a division error. Same goes for . (Also, if you think that could become or some other sort of indeterminate form, the program will fail well before you get to that statement.) Reducing over addition You write a few times. There is common name for this operation, it's called , and it is included by default, so you should be able to get rid of all together. 

On top of what @alecxe has said I would advise you update your docstrings to include the parameters and descriptions of what they do using some well known convention. Also, I would emphasize you use a well known convention so that way some documentation generator (for example, Sphinx) can use the information to generate readable docs. Note: Sphinx uses the reST convention. 

The class can be considerably shortened using Lombok. You may not want to use Lombok, but I think it is something you should consider. Specifically a lot of your setters and getters are trivial which allows you to simplify the code considerably: From this: 

As you never use , by convention you would use instead. More importantly, I'm not exactly sure what you hope to get out of shuffling the deck three times. I think once is probably enough. Using is usually bad practice. You can use the return value of to get around this. (I'll leave that as an exercise.) I would change to . Although they do the same thing is considered better style in at least Python. 

Are extremely similar and should be placed into a function. This is doable if you put stuff like into an approprate dictionary (maybe ?) - chains Instead of: 

The way you have it set up, it doesn't matter, if someone gives me a number like (-3)/(-4), my first thought is this can be reduced to 3/4. I would probably call reduce in the function, so any constructed is immediately reduced. You could get an integer overflow sooner if you don't reduce stuff immediately depending on how hairy the fractions get from repeated arithmetic. Possibly a good exercise is to write a test that illustrates this overflow issue. 

I personally think that there isn't much gained by adding these two functions, but others may disagree (your post suggests you might). In otherwords, I would just write wherever I see . However, I think is sufficiently complicated to be a good stand-alone utility function. I would also move: 

Firstly, "sub-string" is different than "word". I think "word" is more appropriate in this situation. (A substring can contain non-alphabetical characters). 

Your variable try appear to be roughly the "ASCII" equivalent of the ones used in the equation. You cite the paper where you got the equations from. (This is probably the most important thing to do) This allows the programmer to understand the context. 

As for the overall structure of the code, I would try to avoid the -- chains. Instead you can use either a dictionary with a keys , , etc. and with functions such as , etc. or a list that stores just stores etc. in the order and in a particular order. To go even beyond this, you could add a function attribute to , , etc. called and generate the start menu by iterating through the list and loading each . Here is an (incomplete) example of what it should look like: 

About () I guess if you really want to "encode" it fine. I wouldn't really bother, but ok. But along with don't appear to mutate so I would use a tuple (change the and ) to ensure that they don't mutate. 

The resulting code prints out as P1 can always win. I am not too particularly concerned about speed, as I plan to make optimizations later (including threading and memoization). I am mostly concerned about writing idiomatic C++. 

Based of the statement I would know that this the purpose of . I would omit it, but it does explain why you increment , so there is some grey zone here. You write some good comments toward the end, let's analyze why they are good: 

(Also, I would keep as a local variable defined in and then refer to instead.) I would advise you look at how Python classes work. You can replace with . Furthermore, once you pull the functions out of , things like: 

The biggest issue I see with your code is your ability to extend it effectively. I would recomend you store a lot of you data in a format like JSON. So you could create for a something like: 

PEP 8 Please follow PEP 8, you ca use tools like pylint to find PEP 8 issues immediately. But for instance: 

Although Rosetta Code doesn't always provide the most idiomatic code for each language, look at the "idiomatic solution": 

Too long is way to long. It is hard to read and interrupts the flow of statements that call that function. may be a better alternative. You probably wont get a name quite as descriptive as what you came up with but I would just write it in the docstring. XSS sounds like you're talking about an XSS exploit or something. Why do you use that as a variable name? Why not or ? (Same goes for etc.) Some hardcoded stuff. 

Are usually used for docstrings, you are using them to elaborate on certain steps in an algorithm, I would use for this. Place the cycle decomposition into a function The while loop introduces a lot of global variables and makes it hard to use, I would put the contents into a function. Also explain that this function displays a permutation as disjoint cycles. Please use better names. I'm still not sure what every variable does. Like why is ? I would think is short for , but seems to be what the actual permutation is. This program is really hard to understand simply because of your name choice. 

Should be somewhere in your function, not score. Pass a erence string to . I would advise printing out more information than just numbers, something like this, so you can tell what is going on: 

(This section is less of a "review" and more of considerations for future development) Not exactly required, but a lot of casinos have different variants on craps here are some possible abstractions you may want to consider: 

Just get rid of it. Also, in this instance in particular I would get rid of it, because when I read it, I believe there might be a way to abstract it. "Maybe let the user change the , somehow?") There isn't a particularly good way to "abstract" this out in particular. Furthermore, it is considered good practice to use format instead of the addition of strings so: 

I don't know if this is the best way to measure internet speed or not. I won't comment whether this is the right approach. There are, however, some stylistic improvements that can be made. You should run your code through pylint. Some issues could easily be addressed such as too many newlines between and . pylint enforces two newlines. This isn't English class, you don't have to double space your functions. 

Find current issues with your code. Nip likely future issues. Prevent errors you've had in the past from coming back. 

What should be in place of ? is often assumed to be an integer, yet you use it as a string. Organization doesn't really feel like a test, it feels like the main point of your application. Maybe just change it to and do something like: 

But, again you should probably reword the comment, at the moment the meaning is not so clear, possibly: 

Generalization I would argue that you should add an additional parameter to . is one of the many functions you could pass into the set so allow someone else to change it and add as a parameter to and pass the function in. Optimization What would I change to optimize the code?* 

On top vnp's answer, I would return and instead of and unless you have good reason to do otherwise. (Which you might, i.e. in the case you want to run a simulation. Otherwise, returning and instead of and is un-Pythonic.) 

Firstly there are some minor stylistic errors that can be detected with pylint. Most notably you never use the module. I looked mostly at this section of code: 

is the Pythonic way to do getter and setters. For instance, I would do the following for the variable: Change: 

This was mentioned in the last post. Even if you can't find the specific number you need, you should at least assign to some variable something like so the meaning of such a number is more obvious. 

Easy stuff There are a lot of stylistic issues (indentation, spacing between operators, etc.) that violate PEP 8, you can use tools like pylint to find what they are. Moving on 

But you can abstract this further! Create a higher order function, that depends on a string parameter and pass in either or . 

The past, present, and future. So for example, your function may have a good reason for being there. Maybe you had designed a stack before and had issues with pushing 3, popping 1, and then peeking. I've never personally had such an issue. It seems like a weird test case I wouldn't consider it, but maybe you have. If you have a compelling reason to have that test you should explain your reasoning in a comment so I can understand the purpose of the test. Ultimately: 

I don't like the inline . I would abstract this into some sort of / dictionary so you can do . Game representation Although Python rarely bit twiddles like some other languages. When I see the tuple of s and s I immediately think this probably could be naturally expressed as a binary number. You gain very little to no abstraction barriers representing the stuff as a binary tuple. I would advise rewriting as a binary number. This should simplify the creation of , and the printing. 

Instead, I would first switch to PyPy (which uses JIT compilation to make the code, in this case, much faster) and run the program that way, install PyPy, then (this worked for me): 

Documentation You should definitely add a docstring. It took me a few seconds to figure out was was going. Make sure to add some examples in the docstring as well. Naming The name may not be the best name. Why? Let's look at the definition of cache: 

This way you can't accidentally change it later (Well, you could mess up something in iteration...). If you attempt to, the interpreter will get upset at you and tell you exactly where the issue is instead of it silently failing and you having to spend a ridiculously long time to figure out the problem. Naming Functions are verbs that transform data ("nouns"). Instead of call it . When you are inside the function you are opening the link, but what does the function do, it opens the link. (The same argument applies for . Call it ). 

First some stylistic stuff Variable names According to the PEP 8 style guide, Python variables use instead of so, for instance, should be . Add a The equivalent of a function in Python is: