Great job on writing as a separate function instead of inlining it in . That being said, we can go a little bit further with splitting the functionality of your code. At the moment, your contains five distinct steps: 

There's not much to say, to be honest. The type signatures are all there, which is a plus. Communicate possible errors and make functions total However, has two possible runtime error sources: (which is partial) and , since the latter can return a . Therefore is partial too. In Haskell, we try to keep the partial functions to a minimum. can fail, but it's type does not communicate that to us. Instead, should return as . We can use to communicate another possible error, namely an empty : 

Note that all complex interactions are moved into functions. However, as you have seen in and those functions aren't complex themselves either. Keeping things simple is a principle (KISS) that's often applied, as is splitting the functionality (separation of concerns). A concrete example of overly complex code Why am I pointing to simplicity? Because your loop is overly complex: 

If you aren't sure whether you replaced them all, works in pretty much all editors. Often there's even a search and replace :-) 

I noticed your commenting style and decided it's worthy of it's own answer. You admit the comma is not always a comma. So don't call it a comma. I went for separator, which is as neutral as it gets. If you think of something better, go for it. Also, I think your comments would fit better as a docstring than as comments. 

is already short, don't shorten it even further to . Especially since you use all around in your code, making this particular part inconsistent. The parentheses around seem superfluous. Consider replacing these numbers with constants. 

Of-course, that's keeping the current way of writing pretty much intact. If you prefer one-liners, this does exactly the same: 

While learning to play the keyboard, I find it helpful to write down the score of the pieces I play, regardless of whether a score already exists. The code is written using Frescobaldi as IDE and using LilyPond (docs) as format and engraving tool under the hood. The music is engraved to PDF and a MIDI file is generated. Writing music in LilyPond is somewhat similar to writing a book in LaTeX. I want to share one of the easier pieces. A shortened, simplified piano version of Morning Wood (Morgenstemning) by Edvard Grieg. Specifically, it's a 1:1 translation of the version provided by Flowkey (no affiliation). 

A key problem with a monolithic construction such as my is that it's hard to see what's going on without lots of commentary. A key problem with a slew of overly-short functions such as in your implementation is that it's hard to see how things fit together without lots of commentary. There's a happy medium where you can still understand individual chunks of code and where you can see how things fit together, and without needing an excessive amount of commentary. Some comments about my code: 

One last point: You did not mention how you are using and . I'm assuming you used one of the following: 

While neither one of these is a very good integrator, the latter choice is far better than the first. You should try the two variations and see what happens. Once you see that the second choice is far better, you might want to learn about more advanced integration techniques. 

Huh. That's strange. Could we actually form that ransom note? No. We're missing "we", "have", and "daughter". So what can we conclude? 

Still too much garbage collection, but that's fine for a start. Additional discussion Try to avoid . Instead, you could have used 

It seems unlikely that you accidentally change . But why take a risk? puts an ease on your mind. Make exclusive branches exclusive We're still following your function top-to-bottom. And while your for finding the minimum and maximum of the range works, it's not really friendly to our PC: 

Unfortunately, you cannot expand , since content in parentheses (like this) does not lead to a new sentence. Note that and aren't valid in some languages, though, they require and , so it's not clear what you try to achieve there (see comment above documentation above). So all in all, well written, but without additional explanation or documentation there is no way to check whether the function actually does what you want. I also suggest you to add some tests. 

But it didn't improve readability a bit. I've also tried putting everything in a module and use more specialized functions. That got very messy, very fast. Anything and everything is up for review, including the design of the whole process. The current execution time of the program is low enough that I'm not worried, even for larger amounts of data. 

All at once! Keep in mind we suddenly changed the type of what we're adding to the , so now we instantiate like this: 

However, it's often preferred to include explicitly. If you use threads, include . Even if you don't have to because it's already included by another include or because your compiler sorted it out for you. If you refactor your code and removing one include suddenly breaks functions you didn't expect to break, you'll know you didn't include explicit enough. It's also a good overview for the next guy reading your code about what features are used. Including the same include twice won't matter for your program since the compiler will notice the include guards and only include every include once. The following function could use a better name: 

This compiles fine, even though we've used , not . So our s arent' really the same. This behaviour can be changed with , but it's something to keep in mind. For example, if you had checked that none of the elements were the same as the first, you would have gotten a type error: 

Disclaimer: I'm a Rust beginner with a background in C and C++. Now that I've lost my credibility, let's have a look at your code. Use rustfmt, clippy and rustc There are (at least) three helpful tools when one writes Rust code: , and the compiler rustc itself. Rustfmt provides a common ground The compiler doesn't yield any warnings, but rustfmt will change your code. As many Rust developers use (or , which calls the former), you should also make a habit of using it. That way others will feel right at home if they look at your code, and the same will hold for you when you look at theirs. Clippy's warnings on the other hand will catch common mistakes. In this case its mostly the redundant in your functions: 

Let's start with the obvious remarks about whitespace: Whitespace is important in Python. You got trailing whitespaces all over the place and you use an indentation of 2 spaces where 4 is prescribed by the official PEP8 Style Guide. When talking about sticking to best practices in Python, starting with PEP8 is a good idea. There's a lot more violations going on, a couple of them can be checked using the off-line tool and/or the on-line tool. I like how you split your functions. It's straightforward and maintainable, except the large amount of magic numbers. I have a personal dislike for numerals in function names and variables (for example: ) and constructs like the following make me think you got naming problems: 

A branch is when something else than the next line of code is executed. According to OWLTEST, you have 17 branches where it deems 12 the maximum acceptable. Long story short, it doesn't like your style. There are many loops and many ifs in the same function. Splitting up your function will increase the readability significantly. Another point it could complain about is the repetition. 

Either way, your original code was mostly fine. But I would keep in mind that you can pattern match on multiple elements of a list. 

Note the missing in . In order to make those modules type safe, you have to constrain the exports so that no or can be build or matched with their constructors our of their respective module. You had a similar loophole in your prime code, by the way. A based on GADTs does not have this problem: 

You can use the same method in . Errors Your code has several errors. Some of them will prevent your code from compiling, some of them will lead to undefined behaviour. Errors during compilation Let's start with the compiler errors. Here's the part you should remember: whenenver you use a template, the compiler will only instantiate the methods if you actually use them. For example your function does not compile, since its signature uses , although it returns a : 

Even in Java, the fizz-buzz problem should be very small (allowing a couple of violations of very standard coding practices): 

The version is even faster than is the C-based I/O version in the case of using g++. Clang, in this case, bites. Or perhaps it's the standard C library. Here's the getline version: 

The above raises a exception if there is no such index. The easiest way to deal with that is to simply let that exception pass through up to the caller. Doing the same with your next chunk of code reveals another one-liner: 

This is just wrong. The standard approach for determining whether some string occurs within another string is to loop over the substrings of that start with the first character in , returning true if the characters that follow are equal to the remaining characters in , in order. 

Now it's a simple matter of assembling the output. Once again, this is much easier than you made it out to be. Simply swap the values at the pivot and swap points, and then reverse the digits after the pivot point. Putting this all together yields 

However, I vaguely remember you're not supposed to use in JavaScript unless absolutely necessary. What would be the more idiomatic approach for this loop? 

Stop. Regardless of what you're doing here, you should not be doing so many things in one condition. This looks like you need to write a new function instead. Talking about functions, they'd greatly improve the readability and maintainability of your code. Now you got everything in one big . Your could use it's own function. The data changing, inserting and replacing could probably use a wrapper as well. If you give those functions meaningful names, the readability will increase big time! Imagine the following: 

Basically, it works like a charm, the result looks like a charm, but the code itself could use some serious clean-up. 

Naming Illegal names The following is quite important. Don't EVER name a variable or function after a built-in. It confuses everyone including (possibly, although you usually get away with it) the interpreter.