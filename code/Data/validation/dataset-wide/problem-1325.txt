Before we actually implement it, I'll warn you that Python isn't the best language for expressing concepts like this (at least out of the box, there are libraries that can help make this a lot nicer). In the end, some of my suggestions above may need to be bent or broken. Nevermind, I love Python :P That said I'd still argue it isn't the best language out of the box for this. (If you're interested in the "best way" to do things, at least in my opinion, wait a few years (I don't want to confuse you too much!)--depending on your skill level--and then read about parser combinators and monadic parsing) The scanner could look something like this: 

In compiler design these two are called the scanner and the parser, respectively (I'm using parser loosely here, since in a real compiler a parser produces an AST, but in the case of a calculator it's more ergonomic just to do the math in the parser). Their jobs are: 

I continue into the meat of my analysis assuming you take all of the above recommendations. As you'll see, I think this greatly simplifies the code and also makes the system easier to use and understand from a users' perspective. The Meat You identify yourself that the code is "very long [...] and [your] main concern is readability and abstraction." So it seems like you're on the right path. Let's motivate that a tad. One of the first observations I made when reading your code was that it looked really good until I reached the class. It contains about 98% of your logic, and while the separate commands are somewhat separated, the concerns address by each of these commands are interwoven and duplicated in many places. Just skimming over , these concerns are easily identified, mainly because you've done a good job of phrasing your code with whitespace. So perhaps, you are even aware of these separate concerns. For example, most of the commands are responsible for a series of things: 

Now what does all that mean? The things on the right side of the equals are called productions. By default, the first one is the "main one." The means we need either a or a next. The indicate that whatever is inside them can occur zero or more times. So, an could be just a , but it could also be a . If you try some examples like , you'll see how it breaks down into the productions in the EBNF. Notice how the and group things so order of operations works (the deepest in the nesting are the and , which should happen first). Hopefully, you can see how if we were able to turn out stream of tokens into this nested structure, we could evaluate it (ex. evaluate an by evaluating all its s and then adding/subtracting the results as appropriate, evaluate a by evaluating all of its s and then multiplying/dividing the results as appropriate, and evaluate a by either returning the number or evaluating the expression and returning that). It takes a little to wrap your head around, but spend some time with it, and it'll become clearer: $URL$ With these in mind, let's write a capable of parsing these productions. As we discussed, parsing a production should return the value it evaluates to. 

Big takeaways: Notice how each of the commands is now significantly simpler. They only attempt to handle parsing commands and formatting output. Their behavior is immediately apparent from a quick glance, as are their edge cases. It should be easy to modify a command's output or behavior or maybe add another command without having to understand the specifics of serialization or the poll's business logic. This deferral to the other components is also done in the most pythonic way possible. We call out to a , which if one isn't ongoing is . A current poll can be cleared by setting to . Also note how our use of a as the return of formally codifies a contract between the and the about how to exchange information. Additionally, we have completely removed the idea of the "changed since tally" flag. That is now entirely handled in the poll, so it is impossible to make a mistake where we don't set this flag inside the . Another thing that you mentioned was your were unhappy with regexes. I removed most of them, because I believe the commands should error when given the wrong arguments. The only regex is the one for checking if a or precedes a message (indicating it may be a vote) for . We have significantly simplified the regex and that method since all polling logic has been extracted. Now let's look at creating this object that we've been using. For now we'll skip serialization and and focus on implementing the class. 

Now, hopefully you were able to figure out what does (it's provided by ). If not, the high level summary is that it yields characters from the input as long as they satisfy the predicate (that's the lambda that's passed in). For completeness's sake, here are the utility classes needed to make that work (I've separated them out because our parser will use them too!): 

Watch out for the recursion. Python's recursion limit could bite you depending on the size of an island. To avoid this, it's pretty easy to rewrite the removal iteratively using a set. 

Note: This assumes that returns for a key that doesn't exist. Assuming retrieve just returns the command result from Redis, I believe this is the default behavior for most redis clients. If not, it's easy enough to modify this to handle how behaves. Now without making any other changes, we have a poll that serializes as we update it. This is a really elegant concept. Should we want to swap out the persistence layer or remove it entirely, we only need to modify this property. We also note that on first access, we try to read the poll from the persistence layer. This is a little jagged of an edge, although since we extracted the decorator, I content this is still rather clean. Since the Plugin is the only object that has access to and , we are somewhat forced to somewhat handle persistent within it. But we've successfully extracted it away to a small corner of the object. The whole code is in this gist, in case you want to see it all together. Separation of concerns also has the benefit that we can separate this behavior into three more-manageable files. So, I think that's about it. I was pretty aggressive and opinionated with my refactorings and I skipped a few steps, because this is answer already way too long. But that should be the gist. tl;dr Separation of concerns/SRP is your friend; it makes code easy to maintain/read/test 

Grumble, grumble. Browser tab crashed and SO didn't save my draft apparently. I'll try to recreate everything I remember writing: First off, your question is fantastically written. Often one of the most important skills in writing good code is being able to communicate your intent and any problems you face clearly. You've done an excellent job of this. I'll start with the good: