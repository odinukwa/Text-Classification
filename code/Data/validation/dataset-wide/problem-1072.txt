There is nothing circular in any of these cases. In "circular reference" scenario you have "a chicken and an egg problem" -- can not insert a row into a table because it is always missing a reference to some other table, like in: 

Though there is nothing cyclical here it does have few problems. For example, the model has no relationship between and , although you do state that "District has many Counties". It is also possible to have such that that teacher does not teach in the district the county is located in. 

The only problem that the author of that article has is not understanding database design. The problem in his examples is simply lousy design stemming from insistence on single column PKs (IDs), and not understanding how business logic relates to DB constraints. In the second example, his design assigns re-sellers commission based on the user and the product, instead on an actual purchase, which makes no sense business-wise. In the first example it is possible to assign a user to a task outside his project scope; again nothing to do with "circular", but not knowing how to implement constraints. 

I would recommend you to spend some time with the XML data type instead. The same query in that case would look like this. 

The implicit conversion also works if the value is enclosed in curly brackets . If you add those in the query the implicit conversion will fail if the original value is too long because the last ends up in the wrong place. 

What you want here is not entirely clear from your question. My guess is that you want the value from the node where the node is . Shred the XML using the function on and add a predicate to check the value for . 

After that you want a new node and to create that you can use a node without a name that has no value as a separator between nodes. This is the pattern to use for each field node you want to create. 

| Teacher (TeacherId) teaches in school (SchoolId), in district (DistrictId). Each teacher may teach in more than one school in a district. For each school in a district it is possible that more than one teacher teaches in that school. If a teacher teaches in school in a district, then that school must be located in that district. If a teacher teaches in school in a district, then that teacher must be licensed to teach in that district. 

This is simply not true, you should modify your belief to something like: "Often it is beneficial for a table to have a single-column primary key because ... " 

And now a bit modified model where is a dependent entity (note rounded corners). Here can not exists outside of the context of the . 

This is not about natural and surrogate keys, but about concept of independent and dependent entities. Here is your original example 

Scalar valued functions are executed in a different context than the main query and setting that up for each call takes time. 

Split the string to get one row for each character, order it so numbers go last and all other characters go first and then rebuild the string. Code below uses a numbers table to split the string and the for xml path trick to rebuild it. 

You can use instead of . Build your hierarchy in correlated sub-queries in the field list. You can also make use of in the sub-queries to have tables ordered alphabetically and columns to order by . I tried to translate what you have and came up with this. 

Switch to the message tab and evaluate execution time and required reads. Presumably you have better data in your database to test on. The performance characteristic will change depending on the actual structure of the XML you have to deal with in the real world. A side note is that your queries are not equivalent. The first is easily adapted to longer element names. The second query changes the content of the elements, not just the element names. The third query does not really deal with case insensitive element names, it just enumerate all possible element names that in this case happens to be different in cases only. If you wanted to deal with lets say a 3 letter element name with your third solution you would have 8 (I think) different permutations to deal with. I added a fourth solution, mostly because it is short and pretty, that has the same limitations as your third solution. It is in my measurements slightly faster than using FLWOR. 

I would say both are OK, but I prefer the second example. The confusion stems from something that you know as absolute. 

As far as mandatory address is concerned, verify that on the application layer and wrap the loading statements into a transaction -- that way you'll get all or nothing. 

| School (SchoolId) is located in county (CountyCode), district (DistrictId). School is identified by SchoolId. For each school, that school is located in exactly one county, district. For each county, district; more than one school may be located in that county, district. If a school is located in a county, district; then that county must be located in that district. 

So, both R1 and R2 are in 6NF and therefore in 5,4,3,2,1. There is no in-between -- it may happen that in some specific example you may see "progress" 1, 2, 3, BCNF; but that is an exception, not the rule. 

The query takes a lot of time because it finds no rows. The plan first is setup top pick one row from where . It then moves along to the index scan of tabData. For each row fetched from there is a clustered index seek in followed by a clustered index seek in which also checks for not null on and finally returns the values of and . is then compared against the returned from the Index Seek in . If they are the same the query immediately terminates and return the . If they are not the same the index scan in moves to the next record and all the checks are executed again. That keeps happening until there is a row returned or all rows in have been processed. As it turns out you get a totally different query plan when you do top(1000). You can use the hint to make SQL Server think you actually want 1000 rows when you only need one. Your scalar valued function would then look something like this: 

| County (CountyCode) is located in district (DistrictId). County is identified by CountyCode. Each county is located in exactly one district; for each district that district may have more than one county. If a county is locaeted in a district, then that district must exist. 

If you prefer single-column then you can ADD them to and tables, but you must keep the existing ones as (unique) and reference them in foreign keys where applicable. 

| Student (StudentId) attends school (SchoolId). Each student may attend more than one school, for each school is is possible that more than one student attends that school. If a student attends school, then that student must exist. If a student attends school, then that school must exist. 

P2 Course number (PRE_NUM) is prerequisite for course (C_NUM). c2.1 For each prerequisite course that course may be prerequisite for more than one course. c2.2 For each course, that course may have more than one prerequisite course. c2.3 A course can not be prerequisite to itself. c2.4 If a course has a prerequisite then that course must exist. c2.5 If a course is a prerequisite then that course must exist. 

Dropping a constraint requires a Sch-M (Schema Modification) lock that will block others to query the table during the modification. You are probably waiting to get that lock and has to wait until all currently running queries against that table are finished. A running query has a Sch-S (Schema Stability) lock on the table and that lock is incompatible with a Sch-M lock. From Lock Modes, Schema Locks 

Group by and get the rows where there are less then 3 distinct values in . To figure out what groups are missing you can use the table value constructor to include the group names you want to check and use to build a string with the missing group names. 

The job for the query is to count the number of rows in with a specified value of . There are two obvious ways to do this: 

| Teacher (TeacherId) is licensed to teach in district (DistrictId). For each teacher, that teacher may be licensed to teach in more than one district. For each district, more than one teacher may be licensed to teach in that district. If a teacher is licensed to teach in a district, then that teacher must exist. If a teacher is licensed to teach in a district, then that district must exist. 

I prefer the first case when possible -- you choose your favourite. And obviously, there is no need for direct FK from to in these three cases. 

which is often not preferred in high-transaction-volume environments, so it is common to see these replaced by an auto-increment, essentially serving the same purpose. It is true that this auto-incremet is now unique, hence it can be used as a KEY -- but you may choose to look at it as a necessary compromise for the . So, with some renaming and -> you may arrive to this model 

Makes it easy to divide the work between you and your friend that does the same going from the bottom of the list of procedures. And it will not leave you with a half done gigantic wall of code when you need to go on a break or something. You also minimize the time span where you can end up with editing conflicts between what you do and what someone else did with the same procedure. If you after 4 days of editing the 46,000 lines of code eventually execute the thing you could overwrite something someone else has done during the time of your editing. If you use source control (and you should) you would "only" end up with having to merge the changes. 

Here is a recursive CTE solution using a technique that Paul White blogged about in Performance Tuning the Whole Query Plan.