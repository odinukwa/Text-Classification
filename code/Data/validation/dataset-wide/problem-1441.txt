I agree with other answer about removing styling for into CSS. You don't use this DOM collection anywhere else in your code, so why have it in JS at all? 

rather than having some inflexible centralized approach being enforced via a wrapper class. Ideally the logic for each database access is co-located together in one place (i.e. methods on a model class) vs. being spread across a number of classes, obfuscating the logic in the process. For example, I have rewritten your example using only an injected object 

I don't understand why you would ever need a concrete instance of this class, as I would guess usage would be something like: 

Good to see the continuations of your efforts here. Some thoughts: I would tend to think of a request as being a concrete object, capable of being passed around as a dependency to the various code in your framework that needs it vs. just having it be statically accessible. Why? You want to guarantee that code needing this request information has it set up in a correct state. When thinking about a router for example, you want to hand the router a valid object to work with. If that object cannot be properly instantiated (maybe because of bad input), you should never even get to the point in your code where the router is invoked. If using the static approach here, rather than passing a to a router, you would likely end up having code in the router that tries to statically access the request info (even if the request is not in a proper state). This means you now need a bunch of guarding code in the router class to handle these edge cases where the request information is not in a valid state. This is in contrast to say your method, where I think there is a good argument for static invocation, as the class is not going to be needed as a dependency anywhere else in your code and the class and method serve a very narrow purpose in your application (perform a one-time initialization sequence). General purpose classes/libraries for validation (like your ) or other not-instance-specific functionality are also potential candidates for a static interface, primarily if you want to provide some grouping around a common sets of methods or constant values. One could arguably use namespaced functions/constants for the same purpose as well. 

And I called your extension on , you would end up with duplicated options for these two different selects. Is this desirable behavior? 

I don't understand in your unit tests why you have one method using a data provider but then a slew of additional test methods that just test different values which could probably be covered in the method using the data provider. 

This approach would actually perform better as well, as the collection would only be iterated a single time to remove all those classes as opposed to iterating three times due to having having three different calls. If you are working with large collections, this could add up. The same approach of splitting longer lines of code across multiple lines could also be applied to longer conditionals like this line of code: 

You are doing none of that. You are just obfuscating the underlying MySQLi implementation from the caller, while simultaneously leaking implementation details outside the class, as the caller has to know that you dealing with a mysqli result set being returned from and then work with that result set, splitting DB interaction logic in two places. 

I question the method name and return signature here. You are only ever returning a single (though wrapped in array). Why not drop from end of method name and remove the array wrapper on return to be less obscure about what is really happening here? This would also mean related change in method where you would replace with more straightforward array push operation. 

To me this helps make the data model for more clear. And decouples the operations of data model definition from data population/decoration more clearly. The init() function could, for example, be an external function. If you want even more decoupling, you could simply pass the data structure to the decorator function, rather than having the decorator function living on the object. 

The main thing here is that you are driving towards a granular approach to handling routing, controller instantiation, etc. with each method doing one specific thing, rather than an intermixing of responsibilities as is done in your current index file. 

In this case, I am not seeing great value in breaking your interfaces apart from your base class for and . To me, in order for you to consider an interface, that interface must have applicability to multiple classes which would implement it. I don't think that is the case here, and your interface names themselves should be red flag to you, as their names are EXACTLY the same as your abstract base class names, prepended with an . Now if you had some behavior that you wanted to attach to each model like, for example, making them JSON-serializable, that might be an interesting use for an interface. 

I think that working with a natural language style query builder has sent your implementation a little astray. I don't understand why you need to select a count of rows from a sub-queried result set when you could just count the rows returned from the query itself, without even pulling the result set down into the application. Outside of that, I find your code hard to read. 

You might consider iterating the map in the second part of your code vs. iterating the string again. Why? Depending on the expected alphabet of characters and the expected length of the input string, it might be faster to iterate the map than the input string. For example, if you know you are dealing with an alphabet of 256 characters but you might have input strings lengths into the thousands or tens of thousands of characters, it would be quicker to iterate the map. This would require a change to your map so as to store the first index where a character is encountered in the string, so you might build a data structure like: 

I think @holroy gave a good answer, regarding the function itself. I wanted to add some thoughts around your unit tests. With , you are supposed to put the expected value as the first argument, not the second. 

You have way too much vertical white space (i.e. blank lines) in the HTML output part of your script. This makes your code hard to read. 

I think using the above and due to the nature of your function just needing to count X number of "valid" days from given day, that you are kind of wasting your time using and (both classes that usually I am a big proponent for their use). Here this can be as simple as the following code: 

You will note that the core logic in both examples is pretty much the same. So really the only difference here is whether you allow the function (class) definition to be callable from global scope. In the second example, wrapping the logic in an IIFE has the effect of hiding the function definition from global scope, in essence providing singleton behavior. Which you might use could depend on the needs of your application. 

Never hard code database or other security credentials into your code. These should be derived from configuration that lies outside your code repository (ideally derived from environmental configuration). You should change your DB password NOW as you just posted all your credentials for the whole world to see. 

Where you can pass the parameters to a single method and get returned either a false (or structured error return information) or an array of fields that have all been validated (or perhaps even cleaned/sanitized if you want further extend the functionality of the class). 

I think your conception of the factory pattern is a little off. Throughout your classes, you seem to want to deal with concrete factory objects, which doesn't seem to make sense. Typically, a factory would be invoked statically and would not store local references (i.e. in properties) to the dependencies it is acting upon. Your MarkerFactory class is close, just needing to have method defined as static and possibly defining the class itself as abstract since there would not seem to be any reason to ever instantiate it. But getting into your other classes, there seem to be issues with where logic lies. The probably should not have a method such as on it. That would seem to be a method that should perhaps exist on the itself. Now, if the factory needs to call that method on a concrete window object to get it set up properly before returning it, that might be OK (though I might suggest the InfoWindow constructor is changed to trigger this action). I would like to see InfoWindowFactory be something like: 

I don't think database retry logic should live in this one central place. To me that is logic that should reside with any given model in that there may be some cases where a retry is needed and some cases where it is not. I would also favor other methods to prevent/resolve deadlocks rather than just blind retry. If your table gets into a bad state, just blindly retrying queries over and over could actually exacerbate the problem. 

You enforce the dependency through type-hinting, allowing you to not have to write validation code in your class. Your class gets it's dependency in a proper state. VS. your current approach which might require validation such as: 

Why create your own custom session id's using ? This will mean that you will resend cookie to client every time they load a page, even if the session id has not changed (a side-effect of calling with explicit value passed). If you want to specify something other than default hashing algorithm, you should probably do so by changing your configuration (either at application level or at runtime). 

Make up your mind on whether you are trying to work with functions in an object-oriented manner or not. You start to provide an object wrapper around it in your connection class. But then just work with it in a procedural fashion. I might actually suggest you dump these procedural methods and just work with PDO with PDO_SQLSRV extension. You would then be working in a much more modern paradigm. 

Your terminology of for this class is not really appropriate. The terminology of is oftentimes tied to a (usually abstract) class in an application meant to provide certain data persistence behaviors to inheriting classes. Even if you are intending to use this class to store a model (the occupation), you should still class the class something else like , , or similar that might be appropriate and less ambiguous. 

This approach to use recursion to find a key in your config also unbounds you from your current hard-coded limit of only having 3 key segments. 

Your code id very happy-path oriented. For example, you just assume all your database operations will work as expected as there is no real error handling around them. For example, what if does not return a value? You are already passing this directly into another function, just assuming a user ID is returned. 

I like using heredoc or nowdoc syntax (especially on longer queries), but even breaking up the SQL string across lines in a standard string assignment works. Note also the change in variable name from to which is my guess as to what you are actually representing in this variable. 

This also automatically handles all concerns around daylight savings times, leap years, etc. and you can also incorporate timezone considerations using Tying to manually work with dates the way you are doing is a bit of a fool's errand. 

From a global key-value store standpoint, it is hard to understand how this is actually used in your application from what is shown and unclear what value it really has. What is stored here? If application configuration, should you really provide the level of mutability you do? Would you better be served to have an immutable configuration class that exposes these values? If storing key-values that are going to be consumed in classes, why not move these items into those classes where you can better enforce class-specific validation rules for setting these keys? Do you really need the flexibility provided by this functionality and the fragility problems this flexibility can introduce? I would think it trivial to split this portion of functionality away from if you decide this store truly gives you some value that is not apparent from the code shown.