The GROUP BY Using the wrong array to provide parameters to your PDO prepared statement because your big chunk of code is unwieldy. 

I have a few observations from looking at your code. Some of them are related to the PHP code, some of them are related to the SQL. Some of these observations may also help you resolve some of the perceived bugginess of your code. Let's start with the PHP: Use only one database abstraction per database type I see that you are using three different database abstractions to access two databases. I would try to bring that down to two: one for your DB2 database, and one for your MySQL database. I am guessing that your code is using both PDO and mysqli against the MySQL database. Choose one and use that. If you need multiple connections to a single database, you can do that with a single abstraction. Use different connection handles or objects to differentiate between your connections, not different database abstractions. Use functions to structure your code It could be that your code is using multiple database abstractions to keep your MySQL connections separate. A large monolithic block of code can be hard to visualize all at once, particularly if it is doing a lot of stuff. Break things up into functions that just do a single thing, then assemble the functions into a main procedure. For example: 

This can be rectified by replacing the statement with , and putting a on the outside of the loop. It should be at the end because at that point the function has gone through all the possible factors and found none that divide evenly. Improvements 

What it's doing Basically, this is just going through all the numbers up to the square root of , and seeing if they divide evenly. They divide evenly if . If anything divides evenly, then the number is not prime and the function should return . However, there is no anywhere in the program, and it actually relies on undefined behavior. Try going through it yourself with equal to 9. The loop will go until , and then it will terminate because of the statement. After that, the function doesn't know what to return since there isn't any statement outside of the loop. On my computer it defaults to , but if you compile with you'll get this: 

I used C++ metaprogramming to build taylor series for sin, cos, and tan (not really for tan). The whole thing is on my github. Please give any feedback related (but not limited) to style, functionality, etc. Overall I think the biggest flaw is that the client needs to make their own struct with a member called , and pass that struct to the "functions." I would have just passed the double, but C++ doesn't let you use floating-point numbers as template arguments. Using a struct was the only way I could think of to get around that. Thanks! 

If is a unchanging list that really is as short as you show then you should just hard-code the strings into the code (or use a macro, or declare them (make sure they're const pointers as well as pointers to const)). That way the compiler can optimise the calls away to almost nothing; short strings like you show might even be done via a numeric comparison (a four byte string is the same length as a number), but don't do it manually - let the compiler sort that out. The key point is that the compiler cannot optimize this to the maximum if it can't prove that is constant. If is unchanging, but much larger than shown, then you should use "perfect hashing". There is a tool called that, given a list of names, will generate C code to do the lookup in an optimal way. If can change at run-time and is small then you're probably just about optimal already. If can change at run-time, but can be very large then a hash table is the best option. Failing that a sorted, balanced tree would be better than a list. 

I would say that if you are looking for a code review of code written right now, you should be using modern practices. I can excuse the lack of as it appeared with v7.3 (PTF'd back to v7.1). But you still should be using free form H, F, and D specs. Also ditch the O specs for print files as those do not have a free form equivalent. Also realize that by sticking with SEU, you are not able to use any advances in RPG or SQL put forth since v6.1 (about 10 years) without turning off syntax checking. So that is a big issue as well. On to style, I have just a few points here: 

Use named indicators rather than numeric indicators. Even with display files. The keyword should be used to name your indicators. Otherwise you are going to have to keep going back to the display file to determine what all those numeric indicators mean. It is a lot more readable if you can write something like rather than . Use file references. That is activated by the keyword on the file spec. This way you can keep your file activity seperate by using a qualifier rather than by forcing yourself to rename fields or set prefixes. This allows you to read and write into data structures and assign values by name (using ). Break SQL out into it's own procedure, it just clutters the logic of the routine that contains it. Because local variables and parameters are scoped to the sub-procedure, the does need to be in the same sub-procedure as it's associated , but keep everything else separate. Don't mix and match command key processing. In your DDS you specify but . You are also assigning indicators 01 - 03 to subfile control keywords. So F3 must be detected by the AID byte in the file information data structure or the old K indicaotrs, but F5 can be detected either by the AID byte or , and - don't refer to Function keys. This will be initially confusing to anyone coming behind you. Either use the AID byte exclusively, or reserve indicators 01 - 24 for function keys F1 - F24. Once you start using on your display files, the K indicators will not be usable. Not a big deal, the letters aren't contiguous anyway (there are gaps in the sequence, do you know off the top of your head where they are)? Finally, your life will be made a bit easier by using a message subfile rather than a standard subfile for error messages. 

Everything looks right from this, so we can call it a day. Note that if generating a list of primes like this is what this function is used for, you should consider using a sieve instead. 

Instead of using , just cast the square root to an , i.e: The should be outside of the for loop You might also want to add something to catch weird input, such as -> . If you have this you can also eliminate the first part of 

is never going to be larger than due to the constraints in the loop, so should also be of type . (Or should be of type ) The two statements at the beginning of the loop that check if is or are going to be the same every time, but are evaluated at the beginning of every loop for no good reason. Put them before the loop. The middle statement of the loop, and the at the end, are doing the same job, which is limiting the amount of times the loop repeats. Replace with and get rid of the at the end. I don't know what function you're using, but I'm guessing it's from . That function takes a , so either use a square root function that takes an or replace with . Mathematically, it's pretty much the same thing (though we can get rid of the unnecessary ), but we avoid using that function incorrectly. This loop will check every number up to the square root, but if has any even primes then it is a multiple of two. You check early on if is even, and then only check odd numbers in the loop. That will cut out half of the iterations with one quick statement in the beginning.