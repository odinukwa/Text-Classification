It looks to me like it is thread-safe. But don't take my word for it; you better consider each answer as a vote, and go with what the majority says. (Multi-threading is tricky!) Note: comments should not be considered as answers. 

Add a parameter of type called, say, . Replace the fields , , etc. with a that has a key of type and use to access values within that dictionary. Do the same for your , etc. global variables. (For which you will burn in hell, incidentally.) 

As GregS pointed out, macro arguments need parentheses. does not really do what its name says, nor what the comment above it says, because when we say "whitespace" we don't only mean the space character. You need to use from to tell if a character is whitespace or not, and this applies to all places in the code that compare against the space character. The comment looks like it has been added after the fact, in order to describe what the code will actually do, rather than to specify a requirement for the code. I would suggest that you replace it with a comment saying , because if you ever decide to implement that function differently in the future, you don't want to have to do tricks in order to precisely emulate the bizarre functionality of the old version, do you? Obviously, will fail if it is ever given to parse some text containing a word larger than some buffer, and the way it is written precludes the possibility of ever having any control over this so as to prevent it from happening, because the size of the output buffer is not passed as a parameter. In the test code, you would have a failure if you used a word longer than 100 characters. You might say, "you gotta be kidding, who would ever write a word longer than 100 characters?" One answer is, my son did, when he was 1.5 years old, and got a hold of my computer while I was in the kitchen, and he typed his first word document by holding the z key down for a couple of minutes and watching the 'z's fly by on the screen. If Microsoft Word was using your code, it would have crashed. Another answer is that this is precisely the kind of stuff that buffer overrun exploits are made of: the hacker will intentionally give the kind of input that the programmer did not expect. 

One more note: I see that when your colleague declared the email address variable he assigned to it, and then further down he re-assigned a meaningful value to it prior to using it. Some people believe that when declaring a local variable you should always initialize it with some initial value, and they follow this rule in an almost superstitious fashion. This is wrong. It may have been advisable back in the times when all we had was some primitive and crude C compilers, but not anymore. Modern compilers of C, C++, C# and Java are quite good at warning you if a variable might be read before it has been initialized. So, by pre-initializing the variable at declaration time with a value which is by definition meaningless, (since a meaningful value is not yet known at that time,) you are circumventing the safety checks of your compiler, and you are actually opening up the possibility of error: if you forget to assign a proper value to your variable further down before you actually make use of it, the compiler will not warn you, because as far as the compiler knows, the variable has already been initialized at declaration time. Furthermore, even if the compiler was incapable of warning about uninitialized values, you would still have to wonder which outcome is better for a program with an uninitialized variable bug: to fail with a null pointer exception the first time it is used, or to appear to work but never send any messages to anyone. In any case, you should not really have to worry about the above note, because if you follow the rule which says that the scope of local variables should always be as minimal as possible, you will always be initializing your local variables with meaningful values precisely at the moment that you are declaring them. 

In the SetFileText/GetFileText functions, is not symmetrical to . Consider either using , (the preferred solution,) or using and also asserting that the text to be written does not already contain any s, because if it does, then will not return the same string that was given on . The functions and expose implementation details of the class. These implementation details should not have to be exposed for a class which simply acts as a repository for a single string. It should be possible to rewrite the class to read/write the string from the Windows Registry, or from application.config, without having to change the interface of the class. So, replace those methods with some method which abstracts their usage. And, by the way, why are you doing all this instead of just using the Windows Registry or application.config ? 

The scope of local variables should always be as minimal as possible. So, I would declare the variable precisely there where it is used even if I have to re-declare it in multiple places within the same method. As a matter of fact, I would declare it precisely where it is used even if there was no condition. Many people do not know it, but you can start a new scope with curly brackets anywhere you want within a method, even if you do not have a control statement to put it under. For example: 

Version A is definitely better, as it employs a more familiar pattern to get the job done, and it makes use of bit of trivial code () to save you from duplication of non-trivial code. () I would trivialize the trivial code even more, by saying right before entering the loop, and as the last instruction of the loop. Note that even though this is two lines of code instead of one, its complexity is smaller, because it deals with constants, not with variables. I could perhaps give more advise if you explained what you mean by 'algorithm to position boxes in a grid'. A grid is generally thought of as a two-dimensional structure, but I only see operations in one dimension, on variables which are defined outside of the code fragment that you provided, so... what is this code trying to accomplish? 

Passing an int with the keyword does not involve any boxing at all. Do not confuse this with "passing an int by reference" (as in, a function with return type returning an ,) which is quite a different thing, and it does involve boxing. Your code seems quite efficient to me, I have nothing to comment on. 

Jesse's answer is good. My personal preference would be to put it inside . I would do this because this code does not have any state, and since it has no state, it does not deserve to be a class. (The only state it has is trying to make sure it does not get invoked twice, so that does not count.) 

I would not waste any time at all worrying about factoring away one of the two comparisons, because a good compiler should be able to optimize them into one anyway. (Maybe during Kernighan and Ritchie's time compilers were not smart enough to pull such tricks, so maybe this question was meaningful back then, but believe me, they have gone a very long way since then!) The compiler knows that and (or the result of calling the comparison function) are not changed by the statement, so it can emit the code which compares these two operands only once. The results of the comparison will be stored in the (C) and (Z) bits of the register of an x86 CPU, as follows: If Z is set, it means that the two operands of the comparison were equal; otherwise, if C is set, then the second operand was greater than the first; otherwise, (both flags are clear,) the second operand was smaller than the first. So, if the compiler is smart at all, after the comparison instruction it will emit two consecutive conditional jump instructions: one which will branch to the part if the result of the comparison was 'greater than', (Z=0, C=0,) immediately followed by another which will branch to the part if the result of the comparison was 'less than'. (Z=0, C=1.) A jump instruction never modifies the register of the CPU, so after the first jump instruction has examined the flags, and decided not to branch, the flags will still be intact for the second jump instruction to also examine them. And if the second jump instruction decides not to branch either, then the CPU will fall through to the code which will handle the last remaining case, where the operands were equal. I would be willing to bet money that a decent C compiler will do this for you. Even if it turns out that it does not, the whole topic can nonetheless be dismissed as belonging to the general class of problems that compilers should be taking care of for us, so that we can spend our time thinking about more useful things. 

Leaving aside philosophical issues like why do you bother with a language which today is only used for programming micro-controllers the size of a contact lens, and why would you ruin a something written in C++ by converting it to C, I must say that it is a well written piece of code, authored by someone who has a good understanding of what he is doing. (Then again, of course, you really cannot accomplish anything in C unless you have a good understanding of what you are doing.) Notwithstanding that, there are a few issues. 

First of all, you are right, what you have there is not a builder class, but more like a factory class. Which is roughly equivalent to a static factory method. Now, the question of using constructors vs static factory methods is one over which there has been a lot of talk, and for the most part no conclusive, universally-applicable answers. (Just search for "c# constructor vs static factory method" and you will see.) However, specifically for your case, where both the constructed class and the code constructing it are private within another class, the advantages of "discoverability" and "recognizability" that the keyword has are not applicable, so I'd definitely go with a factory method or class. With regards to whether you should be using a factory class or a static factory method, I think that the factory class is fine. The overhead for the generation of an additional object which gets immediately discarded is negligible, (especially compared to the amount of work that the object will do,) and might even be optimized away by the compiler. On the other hand, having a factory class instead of a static factory method could turn out to be useful if in the future you decide to introduce some state into your builder. 

This class has a well defined role and by keeping it intact you are satisfying the Single Responsibility Principle. So, I would leave it like that. Perhaps you might want to look into how you could refactor some common code out of each method and into a separate utility class, but that's all. 

You are using , so most of your code gets compiled into the same machine code regardless of the bitness of the target. Also, A^A = 0, so the compiler might be optimizing your entire for loop with a single call to with zero. I would recommend that you move different values around instead of xoring the same values together, and I would recommend that you use int32_t for the 32-bit version, and int64_t for the 64-bit version. 

The best way to implement a public generic method for binary search is by invoking the method of . (Better yet, don't implement such a method at all, and call directly.) 

is cute, but it makes one pause for a moment and think whether it is correct or not before moving on. It is better rewritten as . Your arraylist is allocated once and never changed, (its contents are ganged, but not the object itself,) so it should be declared as . Right before you start using it, since you know how many items are going to go into it, do so as to help it to avoid resizing itself as it is discovering its capacity by itself. Use better names; should be or perhaps just . In : Get rid of the and variables and simply use and instead. Declare inside the loop, not outside it: Rename to , or , or just . In : Again, declare inside the loop, not outside it. Declare inside the loop, too, and do not initialize it to null. It is bad practice to initialize things when there is no need. It prevents the compiler from giving you useful warnings. When you do this, the compiler will give you a warning that you may be trying to use before you have assigned a value to it. That's because your if statement checks for , and then for , but there is no clause to handle any other possibility. So, add an clause and throw an exception: Get rid of these: they are not used. Actually, the fact that you have these in your code, and you have not seen a compiler warning about them not being used, tells me that you are not compiling with all warnings enabled. Do yourself a favor and enable all warnings so as to have the compiler help you. That's his job. Replace this: