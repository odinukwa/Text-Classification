So if writing unit tests don’t help you writing the code then don’t write unit tests for code that is tested by acceptance tests. However unit tests help you developer the API to your class and provides examples of how to use the class, so may be of value even when you already have 100% test coverage. On a normal sized code base, it may also be quicker to track down way a unit test if failing. 

On Fixed Size: I don’t think I have ever backed a queue with a fixed sized array apart from code written for university exams. However it is easy to extend what you have done to allocate a new array of double the size and copy the item over if the queue gets filled. Doing so tends to be faster than using linked lists on modem CPUs (due to the processor cache) and also creates lets garbage so helps the garbage collector. See Strategy: Stop Using Linked-Lists On Naming: Lets take this code for example: 

You have written nice small methods with clear names that greatly helps with understanding the code. However it is very easy to mix up parameters that are passed into the method and fields of the object when reading the code. Therefore it is better to prefix all your fields with “_”, so making the code read like: 

Looking at your sql's you seem to be repeating the same queries in a loop. I will pick out one simple one for example, it doesn't take long to run on its own, but if you add them all up, the amount of roundtrips to the db grows. 

I have been using php for over 10 years and never found a need for a session wrapper, but maybe you find it easier/better. There are a few improvements that could be made with your code If we are checking to see if the session has a key, a simpler test is 

You have a lot going on in one middleware. Keep in mind a middleware runs for each request so it needs to be reasonably well optimised. I have split the logging bit out into PlatformLogger class, that seemed like a logical separation. I have also removed a lot of the } else {, to me they just add noise and in most cases you return anyway, so the else will never get triggered. PLEASE NOTE: The conditions below where I removed the else's may not all be the equivalent to the sample provided, it is just to show you what it would look like, you would need to check and make those changes yourself if you choose to do it that way. Also check your if conditions, and do the cheapest test first as they might short circuit the if statement and you won't have to perform the other slower test that involve database access for example. 

One one side, the argument is less characters -> less information to process -> more readable code. On the other side, the argument is that extra parenthesis help to read the code. I'm curious if this is a purely personal thing and the entire community split 50/50 on this (in which case, I'm probably going to be bashed for asking this question), or if you guys think one way is actually more preferred than the other. UPDATE: removed spaces in the example code so the answers/comments just focus on existence/absence of extra parenthesis pairs. 

The problem becomes that if this unit test fails on line 119 or 127 (from original code segment), my refactored code would not actually tell me which line failed. Instead, in both cases, it will report the same line number which is now in the helper function. So in original code, yes I have duplication which is bad, but I also have an exact point of failure, which is good. I've caught myself several times now kicking myself because I would eliminate all duplication, but then end up having to use debugger just to see exactly which one of the calls to the refactored methods is failing. That seems to be the opposite of what you want from a unit test. How would you guys approach this type of scenario? 

I can't comment on security as I haven't had time to go through and understand the code, but I have written comments in regards to coding style, search for // ### to see my comments. I will have another look later if I get time 

Here is a start I opened your code in php storm and it says Non-static method Database::getPdo() should not be called statically Where you have code like this 

Overall your code looks fine If you are having trouble with sessions, check the live server configuration, especially the cookie domain and path. I have put some inline comments in the code, the changes I have done will make it a bit easier to maintain (in my opinion) but are not essential. 

I prefer to have a guard clause at the top, so you can easily see the outcome of the if/else without having to scroll to the end of the code 

Basic authentication is very basic. It is not really designed to allow responses, such as Wrong Username/Wrong Password. If a login attempt fails it will prompt you for the username/password again and again, (usually the browsers allow 3 attempts before failing) Once the login fails you get 1 error message. This could be caused by wrong username/password from cancel option. If you want to show bad username/password messages I suggest you implement your own authentication form (which is not difficult). It is also not a good idea to show wrong username, and wrong password explicitly as once I guess the correct username, I will be able to tell from your response saying bad password only. Then i can work on cracking your password knowing I have the username correct. I have altered your code substantially and tried to explain why in the comments If you are using apache websserver, all of what you have done can also be achieved using a a simple .htaccess and .htpasswd file Here is a website that can generate those files for you $URL$ 

Also your qSort could be written to be a lot faster by not creating 3 new , it is also very important to quickly choose a good item to privet on. You do not even set the size of the list when you create them, hence each list will have to be reallocated and copied many times as you add items to it. You have a qSort that is implemented is an inefficient way compared to a boubleSort that is close to the best implementation for boubleSort. Yet as you confirmed in your comment the qSort does better when you have over 10000 items, slowing just how much better qSort scales. 

It is normal in production quality qsort code to switch to another sorting method (maybe a unrolled bubble sort) when the size of the input is small (often 8 is used). QSort has very high overheads, but scales well, for a small input size the overheads are much more important than the scaling. If you run your code on an input that is 1000 items long, then I expect that your qsort would be faster than your bubble sort. Try writing a test problem that increases your input size in steps of 100 and then graph the results with both sorting methods. The other way to look at it, is to find the largest input that each sort method can sort in say 5 seconds. 

For a while now, our team has been doing peer code reviews of all submissions. As we've learned, everyone has different styles and going forward, all of us see a need to converge at some kind of tribal/team style so that the code looks consistent and we don't spend time in code reviews arguing one style vs. another. For most part we've been able to come up with compromises but few, such as this one, are turning out to be sticky: 

Works like a charm and everything is DRY as it should be. If anything inside those calls throws an assertion, that assertion will be intercepted, source file/line number of the CPPUNIT_CALL will be added to message details, and the whole thing will be rethrown. (*) - p.s. I'm not sure what's up with do {... } while( false ) loop in there. I modeled this macro after CPPUNIT_ASSERT_NO_THROW_MESSAGE and that was in there, so I figured somebody at some point must have had a good reason. 

As Cygal pointed out, keeping things DRY is a very good thing and I clearly agree with that. At the same time I did not want to just simply blame the tool for its limitations or to have to use a debugger when one really shouldn't have to be used. So here's an alternative. We have our own CppUnit library on top of CppUnit where we defined a whole bunch of helpers not available in the framework (things like CPPUNIT_ASSERT_IN_RANGE( min, max, value ) macro). So I added this macro to our library: 

If you can get all the shift ids in advance and do something like this. This is just some pseudo code to give you an idea 

On a final note $lang->xlate may sound like a nice function name, but after a while you will get sick of typing it, $l->x is cryptic but shorter 

The security aspect of things looks fine, but there are some areas for improvement, I have provided inline comments where possible. The whole quiz could be coded as a class, and would be a lot nicer, however I didn't want to go too far from what you started with so you can see what changes I have done. Overall, I have split the code into functions, and tried to make each function do 1 thing only, and renamed variables for readability. This will become more important when you go to maintain the code. The first bit of code is what I used to test all the functions and catches exceptions that occur. You could improve by adding more error checks after each prepare and execute, but I will leave that to you, as they are only really necessary if the database structure doesn't match the sql. 

I note you have preset values for your arrays, which contain no html, otherwise I would be wrapping those echo statements in htmlentities() or the likes. And lastly not sure if it is intended behaviour, but you use ->addDay(0), then addDay(1), then addDay(2), but when you get to 2, you will have actually added (1+2 = 3 days) to the date, and so on.