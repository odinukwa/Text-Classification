Here is an old instructions for setting up master-master replication for windows but concept is same. Considering you already have a 3306 instance by default you can follow below steps to setup as well (if above doesn't help) 

Before doing any changes and attempts, take complete backup of your databases. If you have physical backup of your database: 

So there's tuner's logic, if the (Created_tmp_disk_tables/Created_tmp_tables)*100 is more than 25(%) then increase your tmp-table size (upto max 256M). Again, mysqltuner is for reference, if you don't see performance issues you don't need to blindly follow the suggestions. Also note that tmp table has nothing to do with InnoDB vs MyISAM (if you mean that in your last line). You might want to read about internal temporary tables. 

Looks like in the name of alises you also seem to ignoring the join ! So my guess is non-existence of index is causing the delay, but you can confirm by posting explain plan and/or table definitions. 

With larger records and data-size you might see increased margin of difference. If those are MyISAM tables then you might want to review following notes from documentation: 

Ofcourse a physical files restore will be quicker than loading a dump. So, if you have full physical backup / snapshot of mysql data-directory - you can go fast! (Below answer assumes that you have physical backup available.) Tables are MyISAM: 

While WAMP comes only with MySQL-Server (no client tools etc), not 100% sure but did you see if the wamp-setup is offline installer only? 

but as @greenlitmysql has mentioned you might see performance issues later on as the data grows (and length of column)... 

In general different results can be produced, depending on the order in which the dependencies are considered for the elimination of extraneous attributes and redundant dependencies. This means that even the normalization algorithms, like the analysis algorithm for BCNF, can produce different results in certain cases. A terminological note: in general the algorithms used for the normalization start by computing any canonical cover. A minimal canonical cover is a cover which has a number of dependencies less than that of equivalent covers. An optimal canonical cover is a cover that has less symbols of attributes than each other set equivalent to it. Different algorithms exists for the different type of covers, some of them are discussed in Maier, D. The Theory of Relational Databases, Computer Science Press, Rockville, Maryland, 1983. 

Finally, note that the dependencies 4 and 5, that you have called “Multiple Functional Dependency to the same dependency”, are in effect particular, in the sense that they are transformed in a relation (department) with two primary keys, the number of the department and the number of the manager of the department. And this is managed by the algorithm in the third step by merging the two relations previously obtained (and for this reason the relation has two primary keys). 

The following decomposition is both in Third Normal Form and in Boyce-Codd Normal Form and is without loss of data and loss of dependencies. It can be obtained by applying both the “analysis algorithm” to produce the BCNF, and the “synthesis algorithm” to produce the 3NF, but note that in general only the latter is guaranteed to avoid any loss of dependencies: 

You can generate these SQLs from information_schema database and source it to mysql to quick action. 

Well you can review what mysqldump does on git and try working on it!! Though I'd not go this way... Few things to suggest: 

Yes, if your mysqldump is backing up all databases! If not, for future make sure you use with mysqldump. Alert but this will take your system to the state what it was earlier... If you know what your java programs are connecting using (user-name and host) then you can choose to fix the permissions for that!! 

If you need to loop over the output of one query to another you can use cursors. For eg, in this stored routine to find in all tables databases we have looped over: 

When you cannot identify a primary key for a table you need to use surrogate key; auto_increment columns are most common surrogate keys which database internally provides and hence you should use them then. You may alternatively have sequences or programmatically handle uniqueness... 

"My current mysql backup strategy is replication." Replication cannot be a backup strategy but you can setup backups on slave! I guess you're talking about HA "if master fails then use slave"... Anyways... MySQL 5.7 comes with Multi-source replication. You can have single slave machine replicating from two different masters. You may write your own script to loop around CHANGE-MASTER-TO switching masters and replicate. Idea for you: 

Thus it appears that your table have more column than the file. You will have to specify the column-names explicitly. Also the remaining columns should be nullable. (You might want to share table definition if below command doesn't work) Try this: 

Without any knowledge about the workload of the database, is almost impossible to answer to a question like this. How often those “extra” data will be used? What are the most common queries? How frequent they are? and how much it is important the speed of the execution? The general advice is always the best one for me: make things as simple as possible, than optimize if you need to. So my advice is: create a single table, look at the performances, and only if those performances are not adequate to your objectives, split the table. 

Your decomposition is not correct, since in R2 you still have dependencies that violates the BCNF, for instance ( is not a key of that relation). The problem is that your algorithm is not correct. When you find a dependency that violates the BCNF, you should decompose a relation in two relations, the first with X+, not XA, and the second one with T – X+ + X. Then you should repeat the algorithm, if you find in one of the two decomposed relation some other dependency that violates the BCNF. So, in your example, a correct decomposition is: 

So in your example you can see that both and are dependencies in which the left hand side is a key, so the answer to the first question is yes. In the third dependency, instead, is not a superkey, (since ), so, is a prime attribute? To answer to this question, you should know all the keys of the relation, and see if belongs to one of them. And in this case this is very simple, since A is the unique key of this relation, so you can conclude that the relation is not in 3NF. But note that in general, in more complex cases, it is not so simple to answer to such question, since you can have a very large number of keys, actually a number which is exponential with the number of attributes. 

Finally you can setup backup on this slave. (This is little complex than wht's written below) You may also have individual slaves for both masters and setup backups on them. You can later push those backup to remote location / network drive/ tape / upload to s3 to retain longer. 

MySQL Server master-master replication is possible for max 2 nodes. You might want to use Galera Cluster (Percona Xtradb Cluster or Mariadb Galera cluster) Or Oracle's NDB Cluster to achieve HA as a better solution than master-master. 

MySQL Installer provides an easy to use, wizard-based installation experience for all your MySQL software needs. Included in the product are the latest versions of: 

No. Grants are not defined per database (as in mongodb 2.4). mysql database is a centralized system of records for authentication etc... (just like admin database in mongodb 2.6+). You might want to refer the document for mysql privilege system. 

You have few options to consider but first I hope you're not troubling your production server but may be a slave of it to dump out things? (things may get bad there.) 

(Consider backing up binary-logs if you want point in time restores.) For backups you can use traditional mysqldump or mydumper/loader. If your data size is large, it'd be better to go /w physical-backups, follow settingup xtrabackup for mysql with Holland framework. 

Solutions to consider even before we identify exact error here: - separate instance for reporting. - optimize the query. 

Last line explains the case. Referred: Dealing with MySQL case-sensitivity Update: For views and case-sensitivity, refer this bug report.