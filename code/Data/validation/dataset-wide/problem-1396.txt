Now for my LogOn and my Register they are a little more to the point and easier to understand with just a cursory glace. 

If I had to put a number on your code it would be a 8 out of 10. You did good here. Since it is so good I am going to be nitpicking a few things. First is your test. You are comparing arrays but using . Instead you need to change that to (providing you are using JUnit 4.0) The other thing I feel you need to test for is no begin and no end delimiters. The other nitpicking thing I can find is in your split method. I know that you referred to not using the String.split method, but your method does the same thing. For this exercise there is nothing wrong with giving it the same name seeing as it does the same thing. One thing that annoys me a small amount is the making a while or if statement do more than one thing. Are you assigning or are you comparing? The convention for while and if is to compare only. So move your assignment out of those functions. I'm going to paste your code multiple times and I revise it, so here is where I am sitting now on your code. 

I don't know enough about ASP to know if i can further pull out the boolean in those, but as it sits right here it is easy enough to read this. The moral of all this is to stay consistent (which you did) but reduce as much duplication as you can without sacrificing readability. Thinking about it now I should have just passed in the required value from result instead of passing in result since it doesn't make sense in that context. So in the end I would end up with this. 

I'm going to go out on a limb and assume you come from a java world based on your comments over your methods, and the use of your fields instead of properties. Neither of these things are bad, just not what we are used to seeing in the C# world. If you are using Visual Studio you can type a triple forwards slash and it will make a xml style comment that intellisense can and will use. example use would be 

Yes. You are correct. making just the list class which does only list things would have been the correct approach, anything else breaks SRP. so a bit more of an OO approach would have been to have a factory that takes in a path (be it in string form or other) and returns your person list. Its only responsibility would be reading the file end to end and creating a list with all the people in it. 

and that is a good concern to have. Here there are a few approaches, you could again go with the factory pattern that takes in a line from the file from your other factory which is reading the file. You could make a converter/adapter (same concept just coded slightly differently) The factory pattern again seems to fit the bill the best. those 4 classes would have gotten you to the point of having all the objects you need. I would not have gone past that. This makes them modular and easy to use else where because they behave much like any other class in the java world. So when it comes down to answering the 3 questions again you would want to create another class that does those things. I think the Builder design pattern would be a good choice here. (sorry for the C# version, but the same principle applies) GOF builder design pattern I wont implement the code, but show you what structure I would follow. First I would make the builder interface 

Another helpful thing to learn about is the power of some of the testing frameworks at your disposal. As it sits right now NUnit is probably the most popular. MSTest isn't horrible. I've never used xUnit so I can't speak for it. whichever you choose is up to you. In terms of speed and easiest to setup MSTest will be the way to go. I also recommend using Fluent assertions (search for it using Nuget) with it, but that is more of a personal preference then anything else. Now I'm not going to get into the debate of what style of testing to use be it test-after (write a test after you've written your production code) TDD, BDD or a combination there of. I will say though that if you write your test first and try to make your tests pass your code will be more testable. Just like writing production code has a certain art to it, so does writing good tests. It all takes practice. With that said I will focus now on a comment made in a post up above by Abbas 

Enough on that. Next is why is in Book? it isn't used. Even if it was used, this would be a bad place for it. Keeping a clear separation of concerns (Single Repsonsibility Principle) will show that putting logic into classes and/or methods that makes it harder to debug and fix code. Naming gets the count of entries, not the entries themselves. A better name for this method should be or or . same goes with . I nit pick the word entries because you have a class called Entry. Most collections are either called the plural version of the class name, or by the logical name of a collection of classes. (For example a collection of Animals in a Person class could be called pets, instead of animals) Be concerned when methods start to have more than 3 parameters. Your method has 4, and the intent of it is to just add a new entry. So instead of passing in those 4 entries, just have Entry as a parameter. Duplicate code: and do the same thing. that being said create a new Entry with the 4 parameters and then call addFromCopy in add. Or better yet, just delete the method add, and use only addFromCopy (but rename it to add). Be mindful of when you have code that essentially does the same thing and when you spot it, pull it out into a shared method. (yes even if it is only for 2 or 3 lines of code) Last but not least, is that I'm suprised that a new blog about learning how to program doesn't mention ANY THING about unit tests. I know it is geared for beginners learning the basics, but the basics can still be taught by using a testing framework instead of viewing the output on the console. Normally I'd give a brief example, and I still might, but I have to get going. If I have time tonight I will edit my post and show an example. 

This is where a person can start seeing the full power of MVVM. With only the viewmodel I can now test how it flows, and works. As for the smaller code in your view model there are a few ways around this. You could use a framework (I've never used one, so I can't speak to how good they are) for MVVM that helps with the getters or setters. I typically make my own BaseViewModel with a Get and a Set that uses an Expression. Since it is an expression I can programatically get the name of the property. As of C# 6 you can use nameof. And there is even a attribute that you can use in I think .NET 4.5 (quotation needed) that will set the name of the property for you. Anywho using an expression my ViewModel properties turn into something like this