but let me explain why his suggestions arepure gold. ECS pattern is about decoupling all the game logic (yet seems most articles put focus on components, the point is deocupling the logic). 

You have to write a complete parser (a simple one, but too complex for becoming a single answer) to avoid these issues. You can know if you have done everything correctly luckily: 

This allows you to implement entities in C++ directly (prefer always this, even though direct memory addressing of C++ allows you to do dirty things) 

This gives an overview simplified of the design process. You continuosly refine things, because you can't predict everything. I Assumed objects have a position ok, but then after I defined the first piece of logic It was obvious that the bush was missing the radius for collision avoidance. It was not so hard to add it later. This kind of continuos changes are a real pain without an ECS system. And I added a Radius, without warrying if that could interefer with other engines, just because the engines are selected by the entity view, so there is not risk that adding the Radius to bushes automatically makes the bush processed by Radius-realted systems. Bushes are only processed by Systems interested in their EntityViews. If later I want bushes to be only slowing down player, I could altogheter remove the EntityView from the descriptor, and automatically I change bushes behaviour, without having to change engines, or without having to change the Bush. Honestly I think the final syntax in C++ will be quite different from C#, but I believe it is actually possible implement the same of Svelto in C++. 

The ECS paradigm emerges as a tool as long as you think your logic in a modular and decoupled way. I think you should seriously take a tour into Svelto.ECS (beware, its author renamed "Systems" into "Engines", I believe to avoid confusion with c#'s namespace "System" from .NET), written in C#. To do that you have to drive away from most of ECS articles you find on the web, I'm sad to say that, because I tried to use ECS "the old way" and it simply didn't worked well, it forced use of anti-patterns and made me wasting time. Most ECS frameworks, don't scale. You start easy and when the project becomes big you enter dependency hell, but you don't realize that because the dependency is hidden by components. With Svelto you just need to start, it seems hard (well it is a change of paradigm afterall), but after you get the first 10 engines done you realize how easy and flexible it is. 

This is deeply different. Basically you can select which engines process which entities without having to resort to specialized components or without resorting to usage of Tags or groups. Basically when you spawn an entity, you have to select in advance which engines will see that entity. You can change that at any time by updating EntityViews in its descriptor, if there are missing components a nice error message will tell you that (I think you can implement that at compile time with C++, I done something similiar in past). Basically you may have X entities in your game that have a Position component, but you don't want to process your position the same, so in example static objects should not even have Systems updating them, so they could just have a method that returns the position without allowing to change it (that method does not implement any logic it just returns data). 

When you instantiate a bush you also specify which entity views it will implement, so basically this allows it to be processed by right engines. In example if you want bushes to be avoidable by avoidance algorithm 

Let's me make a premise, I'm actually a consultant, helping a small indie team of quitting dependency hell, I'm basically re-writing a small game (30k lines of code). Turning it into a full-fledged ECS game. And I'm using an already existing ECS framework, not a mine framework. Explaining it is the most difficult part. I'm actually learning new things with every-day problems I face, so I'm not speaking to you as "expert", but as person that is learning. Sometimes I ask questions to the author of the framework I use and he is very willingly to help me and find better solutions to certain problems. Believe me, I come from a C++ programming background, so I always struggled to make my custom engine, dealing with allocation etc. I even started a 3D engine once, I would never do that again. What you are trying to achieve already however: 

Once you have pieces of logic, working on Components, then you finally just need one further step to link that logic togheter, and what you need is actually a ECS framework. 

Simply use EntityViews like in Svelto. This concept was introduced with that framework. And I really love it. Most ECS frameworks have this dull concept that Components are coupled with engines and every engine should loop all components of a certain type. They should not! Both for flexibility and performance issues! (there are even technical articles from AAA industries that use tricks like skipping updating Systems every X frames because they were basically looping too much). Everything in Svelto is decoupled. Most ECS frameworks have this concept: 

the ObstacleAvoidanceView could be something similiar to (assuming the avoidance is done using a circle or a sphere): 

Please, resist the temptation to write your own ECS system, I've been in you and it is a no-go. But if you have to do so, do it right! 

suggests me that you already spent a good amount of time digging into the topic. While your first point indicates you are on the right way, your second point gives me the impression that you have been hijacked by articles written by people that do not really use the ECS pattern or do not understand the pattern at all (Unity, Unreal and Lumberyard are NOT Using the ECS pattern, neither in its old conception). To directly address your question, I think the best suggestion comes from @Laurent La RIZZA's answer: 

The casts to a boolean. It's not required since an empty string is falsy, but it clarifies the intent. 

Four inputs is not that many, so, doesn't really matter. But, if it grows or if you might have to change it often, probably better to loop through the inputs as I have in the jsfiddle. 

The JS files should go at the end of the . Usually, you want all JS in external files. In practice, I find the only exception to be when the server is injecting data, for instance, if data about the current user needs to be available to JS it would go directly in the page and not in an external file. 

Generally, attaching event listeners in markup should be avoided. A couple reasons off the top of my head: 

Main thing is the first issue, the listener has to be in the global scope. I recommend either or the jQuery to listen for the event on the elements. 

The function should be called to initialize the values and it can be used as the event listener for the select inputs. 

I don't know if this is better, but might be more flexible to have a parameter for a factory function that creates the objects you're filling the with. I also added and parameters so subsections can be replaced instead of just the last elements. 

I'm not a compiler guy, but I'll offer some feedback, anyway. Hope it helps. Nice work. Regular expressions are a powerful tool, but they can become difficult to maintain and sometimes to get right. You used them, they work, seems fine. I'd suggest making it a point to always use simple regular expressions (which you did). If you need more complex matching, using multiple simple regular expressions in a sequence or loop or in combination with character / string comparisons seems to work pretty well. To answer your questions: 1: Using integers does make error messages harder to read, so switching to strings for token types is a good idea, IMO. But, instead of adding properties onto the class I'd suggest doing something like the following: 

You'll notice I'm using classes of the form like , that's because it's nice to separate CSS class names that are used purely for JS from those used for styling (more info). The full JavaScript: 

Nice work. You can make a lot of headway by using attributes. These are attributes you can add to any element to store whatever you want in them. They will be available on the property of the HTMLElement, and will always have string values. For instance, given the following HTMLELment: 

In , the leading unary operator () is used to convert the string values to numbers. Just a side note. 

I recommend using bluebird for promises; it has a ton of nice features that really improve quality of life and seems to be faster than the alternatives by quite a large margin. (Note: I only briefly looked over the JSPerf, but it seems to be done well enough.) Using bluebird (and a few other adjustments), the promise version of the code can be simplifed to: 

2: Slicing the string is fine. If there is more to the question, then please elaborate. 3: Use of the variable to store the match is not too clever. I recommend against assignment inside the condition, though, it's just something that can be error prone, in general. Down the road you may make an edit and forget to have only one , or something like that. It's usually considered against best-practices, but is not invalid or anything. 4: As I'm not a compiler guy, take this for what it's worth (there is probably obvious conventional wisdom that I don't know about). Using a single token type for these four operations seems fine to me. They all have similar characteristics. But, it will likely be an issue if you broaden this usage to operators that have different characteristics, like the unary (e.g. ). Having said that, you may end up keeping these four operators under one type. You may end up wanting to group on precedence, though. 5: Not a question. One thing I want to note, the and methods are organized in a way that is a little strange, to me. You consume a token (move forward), then when you are getting the next token after that, check the type of the previous token. I like to have separate methods for the various tokens I have. For instance, you might have and . Each of these can attempt to consume the correct type of token, and if it fails return . The method that called them can decide if that is an error or if another type of token should be attempted, like . As a side note, a scanner I wrote for a DSL: JavaScript and Python. It uses a mix of regular expressions and character comparisons for consuming content. The scanner has a property and a property, and any time a token is created the content spans from to . Then, is moved forward to . 

With that, you can generalize what you're doing with your handlers. On each case, you can store the case number (1, 2, 3, 4) in a attribute, and store the following case in another attribute . 

I recommend an approach where top level buttons, sub-buttons and content are all grouped separately. This way, these grouping wrappers can be used to scope selectors and grab all the top-level buttons into one variable b) all sub-buttons into one variable and c) all content into one variable. These grouping variables can be used to toggle off visibility for all items in that group and then the attributes can be used to toggle on specific items. Also, I've changed it so the content (lines of text) have unique selectors and the on the sub-buttons has complete selectors for their target content. This way, each sub-button doesn't have to know anything about the top-level button that toggled it. To keep track of when something is supposed to be turned off and nothing is supposed to be turned on (ie if you click the "Toggle a" button twice in a row), there are state variables for the last chosen top button and last chosen sub-button. Since this is not in a form, you might want to stick with tags. Generally, where possible, it's best to save your DOM queries. Hope this helps.