Try to add a space between control flow instructions like , and friends. Therewith you can readily differentiate them from functions. 

There is an even simpler solution: $URL$ You can define a separator between the different words of a stream, which of course can also be any word you like 

Your names should be more descriptive. The fact that the actual game is in the function loop is a bad wording. Same for logic. Generally a function does something which should be reflected in the name. 

So here would be my take for the code using two std::vectors. The idea is that the first vector simply stores the individual profits, whereas the second vector starts with all the profits of the 2 segment chains, aka [i, i+1]. We determine the minimum of that vector. Now in the next step we increase vector2 by element i+2. So now it holds all the segments of length 3 (obviously in every step the last element gets ignored). We continue until we reach the full segment. 

That is a copy of all neighbors everytime you access a node during your search. If you really need the temporary, which you dont then at least make this a reference. 

At a first glance it is hard to discriminate what is the condition and what is the following code Also separate controll flow instructions with a whitespace so one can easily discriminate them from functions 

I would suggest a different but more general approach (aka in case the element is not a single number but a struct that cannot be xor'ed) The idea would be to utilize a simple . The following code should give the idea, assuming one can initialize the struct of type T from std::cin 

If you define global variables make them or You should use stl container here, or better . This would allow you to use range based loops, which are more descriptive. 

So although this is already marked as accepted i would like to add, that if this is indeed C++ you should definitely use containers (std::vector in this case). That will also allow you to utilize range based loops, which condense everything a little bit. Also you can use the algorithm library too 

Do not use this is a bad practice, that will hurt you in the long run. In C++ you would generally want to generate classes that represent the objects of your code. So what do you have here? 

I dont really get why your animal class has no sound member but your dog does. As @fernando.reyes said, your setFriends method is buggy. this should be a member function of you animal class that takes a animal and adds it to the friends. If friends are bidirectional you can add a wrapper that takes two animals 

Now that you have a vector with all the wealth of the beheaded people you can easily print them out: 

And have a stack based on a std::vector The second most frequent topic next to namespace std. Use descriptive names! What is g,v,n? In this limited example this might be easy, but does it hurt to write 

I think you choice of a data table is really bad. You should consider creating nodes similar to an trie. 

EDIT: So I made a mistake here. The problem becomes obvious when looking at the simple sequence AAABC n=2 The A Instruction will be scheduled after B and C with the old code, leading to the sequence 

A minor nit would be that in your constructor you check for emptiness of the provided string via an implicit 

Thats it. No more searching sorting and finding multiple elements. Now how to generate the words. Luckily there is . However, life is hard and it does not work with a std::set, but, it works on strings, so after having again a look at my favorite book there is this little beauty: 

I would strongly suggest, that you create convenience classes for that use case, which act similar to functions. The reason is, that the random number generators generally increment their state and more importantly that initialization is costly. Therefore, create a class that holds the generator and the distribution and create an 

Your insert function is bogus too. When reassigning the values, you overwrite the old ones here . This should start at seqSize+1. Similarly your insert function can benefit from 

That way in the interval [first, second) there would always be the numbers and you would not have to replace the final character or other stuff Again encapsulation. There is no reason why the this block of code is not inside its own function: 

There is an incredible amount of boilerplate here. I would like to remind you that with C++17 you can use fold expressions, which do basically the same but way simpler: 

You might even put this into variadic templates and overload min. Now you can get the minimum value and define a switch statement 

What is also apparent is that you are setting n->parent = n whenever you construct the element, so maybe just add it to the constructor? 

Now the return is really not needed,and a look at the reference tells us that erase returns a string& $URL$ 

Why is the head separated from the tail? If you use a container you can utilize to get the first element or for the last one. 

You are always using . This involves a copy of . If you do not alter then you should use As far as i know it is more idiomatic to check for existense of an element in a set via count. So rather than you can check or the in my opinion way better Your code assumes every node is unique. You might want to adopt to a more robust approach utilizing a that holds the data and then wr on pointers to that node 

However, there is no call to delete that i can see. The C-way would be to cleanup at the end of your main function. However in C++ we have smart pointer, that handle this for you. So rather than simply calling new you can use a std::unique_ptr. While we are at it, you can combine the constructor call with the insertion into you vector and reserve the memory beforehand 

As a rule of thumb always use braces in nested statements. You only need one loop that goes over the array once so start with determining the sum/product of the first subarray. Also if you use unsigned data, then the result is automatically rounded down for you. 

However with less indentation and easier control flow. You should definitely reserve memory in your merge function: 

Why is xnew defined outside the loop it is used in although you never use it anymore? The next thing to notice, is that is actually more of a copy of . One could be tempted to just write rather than , however that prevents a possible optimization by the compiler if is passed in a move constructible way to the function. Therfore it is better to let the compiler do the copy 

So this would be the plain algorithm you utilized. However, as you said this will most likely give you TLE. So what i believe would be the main idea behind the challenge is to realize that there might be immutable orbits inside the map, aka whenever you end up with the same combination of token and machine, you can shortcircuit by taking the remaining number of steps modulo the number of steps it takes you to reach the node the again. So the question is, how can you find out, whether you can shortcuircuit and how long it took to get to the same token again. For me the solution would be not use a std::pair, but rather a custom struct 

Therewith you always know that the richest person is the one at the end of the people vector and your loop becomes: 

You can declare const in the constructor and add explicit so that there is no other possible constructor. I personally dislike using int for variables that are strict non negative, but this is purely opinion based. You can use range based loops in your implementation 

More a personal thing than anything else but still. Your if ladders are really confusing. Whenever i see stuff like 

If you know its bad dont do it. --> looking at namespace std; For gods sake use braces. You are in your 5th level of nesting without a single brace. That is simply a bug in waiting. As a rule of thumb, whenever you nest something use braces. It is not like the additional line is hurting you. Similar to the above declare each variable on its own line. That way it is much easier to read. Use separate files for each class you have. That makes it much easier to follow your code. Your main function is loaded with stuff that should be part of the class initialization. 

Do not use It is bad practice that will cost you in the long run, so avoid it early on. While it is a good representation of your physical world, I cannot see a real benefit for utilizing a nested 2D array. In most cases your code does not rely on the position within the grid and when it does you do boundchecks anyway. So i would suggest, that you simplify it to 

The only way that you can change the last movement is via DepositMoney and WithdrawMoney, so the function SetLastMoneyMovement should not be public, but only be called via those other methods. You seriously lack any form of error checking. What if the user inputs wrong data, are there bounds etc. While your code works, it does not show a valid concept of the problem at hand. The ATM only knows persons and a person has multiple accounts. Therefore, your ATM class should only have a list of available persons and you should create a person class that in turn has the information about that persons accounts. At the same time account balance last transactions are relative to an account and not the person that own that account. So as a stub i would suggest the following design (I ran out of time too :( ): 

The same obviously goes for indexes Given that you emplace in sequential order here you might want to switch to If you do not care about memory you can reserve the memory for your graphics vector with a guess during initialization and then call afterwards. That way you avoid possibly costly reallocations. However depending on the size of your guess this might significantly increase the memory burden. 

For a binary tree you need to compare the values of the nodes with the data you want to put in. This is best done by defining an or As you might have seen i did not use . In recent C++ we have a keyword for that so you should use that. Why does your function returns a pointer to a node. You are deleting it. Where should that point to? 

Also you could use emplace_back to enable inplace construction of the elements in the vector. On the other hand std::find only takes const T& so I would guess, that move semantics do not really buy you anything here. 

So I think the first thing to note, is that if you want to merge N vectors you should start with the longest one and then procedually increment from it. Also i think you do not need to develop a function for an arbitrary number of vectors, but a good one for inserting one into another. Because then you can just iterate over vectors U2...UN inserting them into U1 (Given that U1 is the longest). Also it is unclear what you actually need. Is it just the number of elements? Because your code doesnt merge the vectors but just counts elements that would be in the merged one. If you really need the actual vector you might want to consider C++ std::vector for this task. 

As you have seen, I used some better names too and seeded both random number generators independently with the current time. 

You are missing the third point, which complicates the code more than it should. So lets start with a data structure that fits the problem 

EDIT: this is no longer relevant but i dont know how to cross it out. However, i would suggest, that you keep track of your jump length via the queue. So rather than haveing a have a New: I would now suggest to store the first visited field in the struct itself, which simplifies the code a lot 

Have a look at your function arguments and declare those const who are not modified. Also you are always passing a copy rather a reference so you should either be dooing one of the following. 

So you can pass it a suitable iterator and it constructs the set from its own. So how does that look like? 

While you might just want to use the default move constructor and move assignment, you should mark them Otherwise the compiler needs to wrap those with exception handling code. 

This only takes 0.018s on my machine, which is considerable faster than the other approach. The only caveat is, that you have to dereference the values of the edges. 

Your interface is a real mess between C and C++. Why do you provide , and when they are actually sizes of the respective arrays? Also you should really not use especially not if you use it as a fake integer That leads to the following: 

The first thing to note, is that this is highly inefficient, as you only want unique elements of your string. This kind of asks for a Most importantly if you look in your favorite book you will find the following constructor: 

However, this function does something really terrible, as it overwrites the parent member of node and all its parents, which is most certainly not what the user expects of a function called "find". So you should rather add a temporary for that 

denies construction by reference or move semantics. Although as you deal with basic types this will most likely not be a bottleneck 

Declare variables where you use them, e.g. rowCal and colCalc in the shift function are only used inside the for loop- Your sense function does not need to preserve the old array so directly overwrite it rather than assigning a temporary. 

So first things first: Dont use namespace std; It is a bad practice and generally unneeded; There are some lets say odd things about your code. First thing it feels a lot like some basic C-code rather than C++. On top of that you deviate from standard practices. For example you use recursive function calls to find the parent: 

You could also go for sorted insertion into the vector, however i felt that it complicates the matter of finding and in my experience just inserting and sorting at the end is more performant. Now for the optimal schedule we have to start with the last element and then go from there. If currentTime is not less than nextPossibleTime of the final instruction we can schedule it. Otherwise due to the ordering we know that there is no possible instruction and we have to go idle (I choose "1" for that). After an instruction has been scheduled, we check whether there are remaining uses and either remove it or reschedule. 

I dont see where you reserve the memory for your operations. From a performance point of view this is catastrophic as you are forced to permanently reallocated huge chunks of memory 

So the first think to define is the state of Muttal on the route, which is a pair of the current token and machine, which incidentally are two unsigned numbers 

Do not use . It is a bad practice even in coding challenges. Use the std containers e.g. That way you do not have to deal with memory. So this 

You pop is seriously flawed. If the stack is empty, you still access top. In that case better throw a std::exception or at least do an early return 

So when we schedule an instruction we decrement the number of remaining uses and set the next possible instruction time until the current time + the cool down period. Obviously we can put in the caller but that is a question of personal preference. Now to check whether an Instruction can be scheduled we only have to compare with nextPossibleTime for the instruction. So now we have scheduled an instruction how do we move it withine a queue? Quite easy there are only 2 relevant quantities 

Actually there is a std::isspace for your characters, however find_last_of does not seem to take a predicate, so we are stuck with a constant. What is also really useful is the deletion of multiple consecutive whitespaces. Here std::unique is your friend 

Do not cramp your main function with all the code. Generally the main should only handle inputs/ouputs and calling functions. So restructure your code into little well named functions. Use proper functions for example this