(Yes, I know it will give a spurious result if $var1 and $var2 are equal, it's just for illustration) 

By the way, the username checking method is doing two things (checking that the username meets some validity parameters such as minimum length, and checking that the username is free). I'd be inclined to split this into two independent methods, as a validity check and an availability check are really two different operations. 

The other commenters have covers most of the main points, but I did want to add one of my own. Your checkusername () method doesn't return anything, but instead echos out messages regarding success or otherwise. This is inflexible, because you can't easily change the messages. If you want to reuse this class in a different application that requires different success or fail messages then you'll have to go in and change them manually. And what are you going to do if you want your application to work in languages other than English? A better approach would be for checkusername to return true or false depending on whether the username is free or not. (I'd also consider renaming the method to something more descriptive of what it tests for in this case, like usernameIsFree ()) 

As you can see, it is now impossible to set the protocol variable to any state other than the ones you allow. This isn't the extent of the power of getters and setters, the benefits they confer are huge. You can, for example, use a getter to do lazy loading of instance variables. Say you have one instance variable that isn't used that often and requires an expensive operation (a DB lookup, a file load and parse, connection to a potentially slow external server, etc), you can write your class to only load the data on demand, and have the getter do the actual data fetch the first time its called. It can then cache the result and skip the data fetching state on subsequent calls. Doing this improves performance because the expensive operation is only done if its results are actually needed, and it's only done once per object instance. 

My first comment is that your function needs a more meaningful name. The current name tells us that it's for comparing something, but doesn't convey what. If you rename it to something like you'll convey more information about what the function does and what it's expecting as input. Readability of code is one of the key contributors to the maintainability of the code. On a similar note, your function's local variables don't have very descriptive names. Again, a well chosen name is much more helpful than one like $counter. What is $counter counting? A lookup table for converting the numerals to values might make more sense than your $evaluation array. 

For a university project I'm trying to build a system that has a general architecture of: Client app <=====> Client library < - - > Server library <=====> Server app I'm trying to make the client and server as general (in the context of a java application, cross-platform compatibility is a concern for later) as possible, so the client library serializing objects from the client app to send to the server and deserializing objects from the server as responses. I have the client library written, and a simple test application that just sends String objects to the client library for sending to the server. I've gotten cleanup code which (I believe) works fairly well in the client library, but the cleanup code in the test app doesn't seem to work, even though it's quite similar. It leaves its threads running and doesn't shut down. The TestApp.UpstreamThread remains in the running state, while the TestApp.DownstreamThread remains in the waiting state forever. As you can see from the code, when one thread ends it's supposed to interrupt() the other. The code for the test app is as follows: 

Whilst the test app is obviously a fairly disposable bit of code, I would like it to clean up properly as it will form the skeleton on which the actual client applications will be built. I'm also curious as to the quality of the code I've produced (which I think this is better suited to a code review than a question on Stack Exchange). I've been trying to follow recommendations as regards cleaning up after yourself, and it does seem to work, but I'm wondering if it's sufficiently robust. Any input on the cleanup code quality would be appreciated. 

I'm not going to do a full code review, but there are a couple of issues that I think need to be addressed. Everything's public in your class, this is very bad because it means that external agents can scribble all over the class internal state. You should definitely make all your properties (variables) protected or private and provide a set of public setters and getters instead, as this will give you more control over what external state consumers of your class can change and how. I've already given a few answers that cover the benefits of getters and setters, so you might want to look those up ;) When designing a class you should be thinking about what the class embodies, what it's meant to accomplish and what services it's providing to consumers of the class. What is the consumer going to ask the class to do and what output can the consumer expect in return? For these services you need to provide a public interface (public methods/functions) so consumers can ask the class to perform some service for them and collect the results. Anything else that the class does internally to achieve the goal of providing the service it implements should not be publicly available to consumers because consumers don't need to know about how a class does what it does, only that the class provides that service. The more of the internals of your class you expose to outside agents, the harder it becomes to make changes without breaking something that depends on the class. Your constructor is too big. Constructors should do nothing more than initialize the class to a usable state, they shouldn't do any actual work, because if you want to subclass a class to give it different behaviour and a lot of behaviour is defined in the constructor then you will need to either inherit a lot of behaviour you don't want, or rewrite the constructor to completely override what the superclass constructor does, possibly resulting in a lot of duplication of effort as you rewrite the bits of the superclass constructor that you do want. It also means that you have less opportunity to configure an instance of a class before asking it do provide its service for you. Your build_links method is also too big. This means it's inflexible and difficult to modify without causing other issues elsewhere. If you split the method down into smaller chunks, then you can more easily swap those chunks out for different ones should you choose to subclass your class, thus making it easier to adapt your class to work in different ways. For example, all the code between each of the function's first level of if statements (the ones with the least indentation) could be split out into their own (protected) methods. This will make the main method shorter, and the methods in question can be easily overridden in any subclasses you choose to make. Also, if you notice you have several methods doing similar work then you have an opportunity to come up with a way to generalize the operation being done and removing some code from your class. Long methods/functions have other issues too when it comes to understandability and maintainability. A shorter method is easier to understand and therefore maintain, so long methods should be considered a code smell and refactored out. A good rule of thumb is, if you need to scroll to fit the method's body into your editor screen then you probably need to split it into smaller chunks of functionality. Programming is all about divide and conquer (splitting a big problem into smaller problems and solving each small problem until you have a solution to the big problem they're a part of). Additionally, good code isn't code where there's nothing left to add, but when there's nothing left to take away. 

I have a table containing URLs as they should appear in English and equivalent translations of them into other languages. Originally, I was told that there would always be an English translation, so when listing them in the application that updates them I just searched for the ones where . However, it turns out that it's entirely possible for there not to be an English translation. I needed to update my query for generating the list displayed in the application so that it would select the English translation in preference to any other translations that might exist, but if there is no English translation, then use a single example of which other translations there are present (doesn't matter which, just as long as there's a single entry presented to the user). The query I came up with is as follows. I'd appreciate it if you could give it a sanity check so I can be confident that it's returning correct results. (It appears to do so with the current data set, but it's currently quite a small set). 

The big one is all your properties (variables) are public! This is really bad, because it means that an instance of this object has no real control whatsoever over what its own state is. Any external agent can inject anything it wants into public properties and it can all too easily result, through accident of malicious intent, in the internal state of the class being corrupted. You need tighter control over your class state. There are two methods involved with doing this. The first is simply to set your instance variables protected instead of public. Now they can't be messed with from outside. Of course now you also don't have any legitimate access to the instance variables either, but this is where the second technique comes in. For each instance variable you want to make accessible to the outside in some way, you need to create a pair of methods for getting and setting its value. Example: 

You really really REALLY don't want to hide errors like this. It will come back to haunt you when in 18 months you're asked to update the script or debug it and you do something that triggers an error condition but nothing to alert you to the fact ever happens. I've had many jobs where debugging some code was made far harder than it needed to be because someone had tried to just sweep errors under the carpet with an @ operator or by catching an exception and doing nothing with it. I know that doesn't answer your question. But I thought it was important to point that out. 

At first glance this might seem like unnecessary extra work, but because this is the most basic example of getters and setters it doesn't illustrate the benefits that such an approach bestows on the programmer. First, you can now have read-only/write-only properties. If you need a read-only property, for example, simply don't implement a setter for the property in question. Now it can't be modified from outside. More importantly, it allows a lot of control over what happens when an instance variable has changed. It can be used to restrict their values to valid states, notify some other internal part of the class that a property has changed, and so on. Say you want to limit the protocol to http and https in my above example class: