EDIT If you look at the math, you will see that, we can do much better than , and can determine that if we find a value that is a multiple of both and that the final result will be a multiple of that value. If we can use that value as the 'step' then we will go faster than just using . Similarly, if we can find a multiple of all , , and then that would be a good step too. So, consider the following: 

Note how we use an anonymous class in here, and we can do it by making the config parameter final, as well as the relatively unknown final inside the for-each loop 

The above function will give you better distribution (perhaps not perfect) even if the hash size is a power of 2 > about 16 bits. 

There are some issues you may run in to. If someone puts values in tot he array that together exceed the limit, then the result will be wrong. It would be more correct to return a value from the method, and convert the and values to longs before computing the diff. For example, what is the in 

"Caching" the String length has a small (1% in this case) improvement in performance. More interestingly, the idea @Chillworld had of creating a lookup array for each relevant character is much, much faster. His idea started off as: 

will repeatedly overwrite, and then delete the file. Note that shred itself contains in the documentation: 

Update: I just went through and verified your calculations, and you were off by a factor of 100 in the number of passwords that you will generate. The combinatronics is that you are performing permutations. There's 26 characters, and you can choose them 8 times, so you have \$26^8\$ possibile permutations, which is: 208827064576. Now, if you have 8 bytes plus a newline in the output file, that's 9 bytes per value, which is: 1879443581184 bytes, or.... 1.7TiB of data. I hope you have enough free disk space. Assuming IO will end up being your bottleneck, a decent disk can write 100MB/second, and that works out at almost exactly 5 hours... so, there's not much point in going faster than the Java version I presented unless you have a decent IO subsystem (I presume you don't have 1.7TB of SSD, do you?) 

Swap C++ has a swap function, use it. To get it, from C++11 and before that Algorithm The classic quick-sort is done in 5 stages: 

These are both items related to the context-naive usage of the method. Still, as far as the specification goes, your code looks like it does the job. There is one improvement that can/should be done to make it more readable. You reuse the value four times. Performance-wise this may be sorted out by a compiler, but it does not help the readability at all... I would prefer the function written as: 

Note that I have a main method which processes image files from the arguments, and reports on their timing of various stages. Specifically, I report the time to load the image, the time to extract the array of pixels, the time to transform the pixels, the time to write the transformed pixels back, and finally the time to write the image back to disk. Note here, that the times for a large picture that I have on my computer, are long: 

I'm sorry, but the best solution to this problem has to be a logic solution, not a code solution. There are only 2 digits that, when multiplied by 3, have the same last digit... 0, and 5. So, 0+0+0 is 0, and 5+5+5 is 15. Since C cannot be 0, it means that C can only be 5. Now, if C is 5, and we know that there is a 'carry' of 1 in to the tens column, it means we need to find a number other than 5 that when added together 3 times ends in a 4. There is only one value that does that, 8. 8 + 8 + 8 is 24, and with the carry of 1, we have 25 (and a carry of 2 in to the 100's column). So, now we need a digit that sums three times to 3, and that's 1. There is only one possible solution where ABC + ABC + ABC is CCC, and that's 185. It can be deduced using logic alone, and brute-forcing it is overkill. 

That will likely halve the time needed to find the string length. Then, your code would be a lot easier to read if you used array-like subscripts to access the chars instead of pointers..... that way you can get rid of the variable as well: 

Java 8 Streams have a number of features that make them ideal for parallel processing, and for reducing more complicated class structures down to simpler functions. You can use this to your advantage and it makes a big difference in this particular case. Consider your problem, you want to generate many ECKey instances until one of them matches a particular phrase. You want to monitor your progress, and you want to stop when you find one. You also want to do this all in parallel, and as efficiently as practical. There's really just one trick to know in this instance, when applying streams, and that is using an infinite stream of increasing values as an "infinite loop". This can be modeled as: 

Note Note how, at this point I have never referenced the actual size of the grid as being 3...? So all the code I have changed so far will work with a grid of any size.... Then, the final part, is getting the scores..... This part is slightly more challenging, but, can be done with a few loops... first, the is another 'magic number' (8), and should be: 

the methods are all thread-safe now (you can find many paths in parallel using the same methods). the data and the logic are both self-contained. there are no static variables. 

A (long) while ago I set up a file server in my basement running Linux. I am OCD when it comes to backups. I set the server up with (remember, this was a while ago): 

Why are there counts.... oh, that's because those are IP's that are not accessing the home page, but are accessing other pages... they appear as but don't actually "GET" . I would consider making it more a study of and use the native structures to get things right.... no , , etc. 

Additionally, apart from the performance, the code style is... unconventional. You should parameterize a lot of the static values so that you can reuse the code better too. Here is the results of my simplified code: 

You are right on the time complexity, but wrong on the space complexity. because you copy the data from the String to the buffer, you incur an \$O(n)\$ space complexity too. vnp has suggested an alternate algorithm that scales at better than \$O(n^2)\$, but you can also significantly improve your current algorithm. Your current system compares each character with every other character twice.... Consider the word "and", you will compare with and , then compare with and , but you have already done the and comparison. What you need to do is alter your inner loop to restrict the range of the comparison. Consider the following: 

The method seems contrived, and will also do multiple things depending on multiple states. Should the methods just return instead of falling through to the next check. Odd, but the current code could be right, just unusual. The way they call and implies those methods can be private. Now, about the overall state system. It's hard to get a feel for the actual state manipulation. You only have one state, and it is controlled mostly by static manipulations. The actual state changes are 'wrapped' in a class you do not show to us: 

You should use your standard libraries when you can. Consider that a already does all the hard work, unique, and sorted values: 

OK, we set up the system where we expect the third value to be a continuation of the sequence.... and then we start the loop, starting from position 1 (the second item) in the values array: 

OK, the above class will be used as follows... consider the example data system, the value appears in and . This would be stored as: 

(well, I also checked that only perfect squares have an odd number of divisors - which is true). What is the truth about the sum of digits? Well, it is true that all perfect squares have recursive digit sums that total 1, 4, 7, or 9, but the inverse is not true. This is obvious if you take the value 7, which is not a perfect square, but has the digit sum of 7. When I looked around, I found this entertaining read: How to check if a number is a Perfect Square. It is quite clear that this is the second line of attack for checking whether a number is a perfect square. The first line is to check the last digit (which excludes 7, by the way). Even once you have done (and passed) these two tests, all you can say is that the number is likely a perfect square. You still need to do the hard work to confirm it. As an aside... why do you use recursion for the digit-sum. Something iterative would be great: