As described above. In the header file (were there is only declaration) only include another header if the header file defines a type that is a member or is used as a parent or used to pass a parameter by value (parameters are infrequent as they are normally passed by reference). In all other cases in a header file you should use forward declaration. In the source file include the header files that define types that you use (ie call methods on). Note: You only need a forward declaration for objects that are pointers or references. 

Not sure I like the fact you have different behavior for a newly constructed verses an old vector . Seems like the stuff for a new vector only belongs in the constructor. Did not realize how much I disliked that brace style until now. Sorry I can't keep going. 

Code Review I don't see anything wrong (or that needs improving) with your code. Its nice and clean (some comments may hep the less experienced read the code). But overall it looks fine. Goal of Code I don't agree that the code achieves its goals (reduced verbosity of user code). I also think it makes boilerplate code more likely in user code (and boilerplate is bad as it tends to be cut and paste rather than written). 

Notice how I have pulled common elements out of if blocks to a higher scope. Now that we have done this it becomes easier to read and leads to more clean up. 

OK. I see this as practice (which I think is good). But you don't need to reinvent everything. The point of this exercise was the hash table but you can use the std::list and std::pair to help you (so you don't have to reinvent everything from scratch). HashPair Hash pair is a property bag. There is no intrinsic state to maintain. This is a classic case of trying to turn a property bag into a class where it is not needed. Just make the members publicly visible. Arrhhhh: getters/setters (I hate getters/setters because they destroy encapsulation and expose the inner parts of the class). But in this case we want to expose the internal workings of the class. So just have public members. See for an example. Even though I don't think you should have any methods on this class lets look at some of them: Pass values by const reference to avoid a copy. The key is probably small but the value can potentially be anything and copying it around could be expensive: 

Out parameters are hard to spot and maintian. Also its not very expensive to return a vector (there is no copy the compiler will elide it (assuming you enabled optimization)). Check out RVO and NRVO. Also in C++11 and C++14 move semantics kick in and even if you can't optimize it with RVO or NRVO then it will be moved back to the calling function rather copied. Standard functions A lot of this work made trivial by the standard functions and some lambda's 

Additionally with the addition of template varargs the use of emplace to create the data object in place using parameters is always an option. 

By making you destructor virtual you are indicating that this class can be extended. But you have no virtual methods. So I see no point in using vvirutal here (it is also misleading). Pass by reference rather than pointer: 

When you have multiple locks. There is always an issue with deadlock caused by acquiring the locks in the wrong order. To avoid this you should use to make sure that all locks are acquired in the correct order. So things like this: 

The last successfull read will read but not past the end of file. Thus leaving the stream in a good state even though there is no data left to read from the stream. Thus the loop will be enetered but the first read will fail. But inside your loop you don't check for failure. As a result you push_back() one more node than exists in the file (though the last node is a copy of the previous node). The correct way to write the loop is: 

There is no need to create a new array just to loop over them. You can use the keys directly in the foreach statement to loop over the hash. 

Get rid of them. The side affects make it harder to remember things when modifying the code and also probably prevent the compiler optimizing the code as much as it could if you passed around things by parameter. Spurious code: In 

A tiny bit of work wrapping your data into a class goes a long way to make the code more readable. Your style you are using the classes available in C++ but really your style is more C than C++. Learn to use the standard algorithms: 

Your quick sort seems to work but is slightly non traditional in a couple of features. The pivot point . Values that are equal seem to go into both sub buckets. Traditionally they would go into a specific bucket. You always use the first element as the pivot point. This case leads to worst case behavior of quicksort when the list is already sorted. Either choose a random element or the one in the middle of the partition. Currently your code works with pointers to integers. But really you are using pointers as iterators. So you should templatize it so the inputs are not pointers but are generic iterators this then allows you to use the algorithm on any container type (with the side affect that it works with any type that implements the <= operator. 

According to the W3C ($URL$ Your form tag is not valid. Technically it must have an action attribute: 

The function returns a . This can be assigned to any pointer type in . Thus removing the need for a cast operation (which will cause any good linters/style checkers to go apoplectic). We should also note the size calculations here: 

See at @Caridorc first. Use the full power of the stream. The standard stream operators will read a word at a time for you. 

Once you do this you don't need to wake all the threads when you add a new task. Just wake one of them. 

I would be OK if you used it to generate an error message. But as it stands it is just protecting the loop. You don't need to do that. The loop will just not be entered because will fail to read from an empty file. As discussed above: 

Because the return type is not r-value reference. Best advice is not to do that (sorry don't have a reference handy). But the clang developers hinted that it may hinder at "Going Native 2013". The compiler is great a copy elide in this situation so let it do what it is good at. Don't like the fact that your helper functions are independant: 

When you provide a print method it is usally a good idea to also pass as an argument the stream you want to print on. This can default to std::cout but at least provide it. 

This is a funny way of accessing member variables. Normally I would use to specify the exact member (rather than as that implies static members). But better yet is not never to shadow member variables. Shadowed variables will eventually cause a problem as you will forget to disambiguify them from the shadow and your compile will not warn you when you go wrong. A nice trick is to turn on your compiler warnings to tell you about shadowed variables and to treat them as errors. Comments I hate bad comments. But this would be a nice place for a comment. 

You are passing a pointer and not checking for NULL. Actually the code never checks for NULL so you must use a valid pointer. In this case you may as well pass a reference. If you want to store this internally as a pointer then take its address inside your object. 

There are all sorts of other issues with rand. So you may want to look at the new random libraries provided with C++11. But if you want to use rand() in the most non biased way possible. 

Your library should not be handling user interactions. This is the job of the application. The library should just inform the application that an error has occurred and then let the application decide what to do (this code could be used in some background server app; you defiantly do not want a dialog box to show up on a headless server). Two big options. 

Your biggest problem is the code does not take into account not finding the word. If it fails your code will loop forever. You need a not found exit case. This is always a bad sign 

Summary A lot of work still needs to be done on this. Fix all the suggestions below then resubmit for further review. Dice Rolling. 

This variable is created locally. It is destroyed when the function terminates. If you had written it correctly the destructor would then clean up any internal memory it had allocated. 

For readability I would just make this two separate functions and . It make the code more readable and removes the need for an if statement in the middle of a tight loop. There is a standard utility function for creating std::pair<> called make_pair. 

No real reason apart from tradition I suppose. But it does show tail recursion more clearly. The compiler can easily optimize tail recursion into a loop for you. But it also makes it obvious to the human eye where tail recursion is. A static member of a recursive function!!! 

You have 6 RAW pointers. What happens if the constructor to throws an exception. Then you have just leaked . In modern C++ it is very rare to see RAW pointers. Pointers are usually contained inside an object (usually a smart pointer). Now you are passing the pointers to a list. 

The member seems to be used as a temprary. I don't think you actually need it as a member. Declare a local variable in each member. 

Also this value in C++ is retieved from You are making a whole bunch of assumptions about the shape of a floating point number here. None of this is guaranteed by the standard. 

If getline() fails with a real error (not EOF) you end up with an infinite loop. The last line read reads up to (but not past the EOF). So you have read the last line but EOF is not set. You then re-enter the loop try to get another line, this fails and sets EOF but nothing is done with yet you still push in onto . So you end up pushing the last line twice. 

I am assuming this is some form of signdness test (to make sure both source and destination have the same sign). If you are going to do this please comment the code explaining exactly how you think it works. There are integer traits that allow you to pull the signdess and size of the template type from the input/output types. You could potentially look at this to help identify things. 

I think I can see that from the name. Your comment should explain WHY not WHAT. I should be able to see that WHAT from the well written code. The problem is that code and comments can diverge over time (as bug fixes are applied) if they are describing WHAT. If you explain WHY that will usually remain the same. What happens if I change the code to return now the comments and code are different but it still works. Does the next person change the code or the comments. Error Codes 

DRY code The implementation of and is nearly identical. Why not make the code identical? I am sure with only minor tweaks you can combine the code bases of these two functions. Iterator types. There are to ranges here: 

Most standard C libraries have a C++ version. The main difference is that the code is guaranteed to be placed in the standard namespace rather than the global namespace. Prefer to pass by const reference If you are not mutating your parameters ( and ) then pass by const reference this will prevent you objects from being copied. Currently you will be making a copy of which if it is 200K in size is a serious performance issue. 

At this point you have created a thread. But if you fail to create the second thread you exit the program without cleaning up the resources of the first thread. A bit of RAII here would definitely help. 

This way if destroying the old stuff causes problems you don't leave your object in an intermediate state. You should probably look up copy and swap idiom. It will help with this. 

I mention this last as it is just one of those quirks and it does not actually break your code. see: What are the rules about using an underscore in a C++ identifier? 

No don't do that its dangerous. Looking at your code you avoid the pitfall of slicing (because you use references). But all to often a downcast results in the object being sliced and you now no longer have any-type of Saw. Your problems are caused because you expose the internal implementation of the object via getter(s) (don't do this it breaks encapsulation). 

I like to keep my unit test separate from my source. So I put all my unit tests in a sub directory under the source. The makefile detects its presence and forces a build of the unit tests if you try and install the code. The unit tests also automatically do code coverage and fail if you don't get an average of 85% across all the files: 

Note: This is technically not legal C++ (bit a lot of compilers accept it as an extension). I am not sure why you are doing this: OK spotted what you are doing now. 

Actions based on specific types should be accessed via a call to a virtual function. Where each type then handles that action in their own special way. Also you should check that the result of the cast is not NULL. You don't need to use dynamic_cast<> when returning. 

Vector is a relatively common name (as is vector 2/3 etc). So you may need to make your include guards a bit more unique. I always put my stuff into my own namespace (which happens to match a domain I own to make things unique). I then include the namespace as part of the include guard. Alternatively you can generate a GUID that will also make sure it is unique. 

None of these conditions match the name of the function. Also I would prefer it throw an exception rather than call . The result is probably the same (application termination). But this would allow you to handle all logging in the same way (catch all exceptions in main and have the same logging applied to all points in your code). Or potentially the exception could be fixed. Don't use this version of getline. 

This breaks separation of concerns. You are doing memory management and business logic in the same object. Also because you don't follow the rule of three. Your code is broken and will likely cause crashes. The best way to fix this is to change into a vector. 

You are polluting the namespace of anybody that uses that header file. That will get you banned from most projects. Do this in as small a scope as possible. Or better yet don't do it all (learn to type at the front of stuff). It would be nice if you could specify the stream you want to display the objects on: