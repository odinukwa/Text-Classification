This is the sort of thing that Python is really good at. Your code seems like it functions, but it will be very inefficient for large data sets. For each input value you have to check every line in the the master list -- and the way you have it set up here you're going to read the master list off disk for each input value as well, so it will be really slow. The first step obvious fix is to load the master list into memory and keep it around for the duration of a session. This is a fairly simple change to your existing code. First, change your pull_lines so it returns a dictionary instead of a list: 

I'd start with the caveat that you're buying some syntax sugar at the cost of possible bugs - the need to do the attribute resolution, and as you point out the possibility of name clashes, makes it seem like it may not be worth the effort unless you need to access these class properties in lots of places in your code. That said you can simplify this by converting your sections - which are dictionaries -- to namedtuples: from collections import namedtuple 

In general I'd try to avoid functions that are open ended on both ends -- in your case, taking a variable number of inputs and returning a variable number of outputs. In this case, returning a dictionary means you should always get one answer to the question your asking and not have to write too much conditional logic to parse the answer later 

So, using CSV files and DictReader/DictWriter to handle the reading/writing, our 'database' is a list of dictionaries': 

For combining (1) and (2) you can reverse the sort by only trying if your are under a test directory Also this is a great use for a generator / map combo to avoid extra loops 

update grid is creating a copy of the working grid You could try to collect the list of born and survived cells and only update changes: 

Bisect is the 'right' answer for serious applications where speed matters. It sounded to me like you're asking a style question. On that assumption: 

I'd see what happens if you refactor drawing code out of the cel update loop. Let each sprite image maintain a list of bools corresponding to all of the available tile position (as the other commenters have noticed, make separate images for the different alpha versions of the same sprite instead of tweaking it on the fly.) As each tile updates, see if it's state has changed enough to warrant a sprite change. If it has, toggle the corresponding entry for the old sprite list off and the same entry in the new sprite list on. In general you won't be changing the lists that much (and by keeping them as fixed size lists instead of adding and removing them you won't have to worry about moving a lot of memory around). Once all the sprite image lists are set, just loop through each and draw a tile for every true value (you'll need a formula to get the 2-d position from the 1-d index of the bool, but that is basically just (tile_height * floor(index / columns), tile_width * int(index % columns)) Hopefully this means (a) you do a lot less moving of memory around - the biggest category of changes is bools toggling on and off in fixed sized arrays - and (b) you can draw the same sprite many times, which should be more cache friendly for the graphics hardware, instead of constantly cycling different art in and out of memory. in this context you might want to google the phrase 'Data Oriented Design' or 'Mike Acton' 

This will work, but it may be hard to scale. At a minimum, I'd create a separate class for the work you're doing in the enumerate loop so that the dialog class is only concerned with populating a widget list and the details of what the widgets look like internally are handled in a class that just pops out book widgets - that will make for cleaner code and easier maintenance. The more 'modern' way to do this is some variant on the MVC (Model-View-Controller) or MVVM (Model -view - viewmodel) patterns. The basic idea is the same - create a factory which produces display widgets for the items in a list of some kind. The main difference its that the MVVM pattern encourages you to split out the different aspects of the problem -- managing the contents of the list, displaying parts of the list, and interactng with the list items -- into distinct parts of the code (the 'model', the 'view' and the 'viewmodel' or 'controller') respectively. (There's a whole lot of programmer-on-programmer controversy about MVC vs MVVM - background here.) In this example, going with an MV* pattern offers facilities like filtering a list ('show only books from 2013'), enabling/disabling list items ('gray out the books over $50') without lots of tedious looping codes. Plus you could potentially do things like design your widgets in the QT designer for better layout, etc without touching the code directly. All this lets you decouple the UI functionality (views, filters, appearance) from the data. As your lists get bigger, and the need to manage their contents gets more complex, this is a big help in staying sane. Yasin from TAO has nice, detailed Youtube tutorial on this approach. 

There are a ton of good template rendering libraries out there, but I'd leave it to you to figure out if they are better suited to your needs than hand rolled code. Assuming you still want to write this yourself, I'd look for ways to make the code more completely data driven and also to make it more readable. On the data driven side, you might want save your design as an html file. That way you can use whatever styling or graphic layout tools you want to produce the layout. You merely need to leave template placeholders where you want the data to go and apply the substitutions. Django's templating system offers a great example of what you'd expect: vanilla html data with placeholders where the data's gonna go. Going data driven will reduce a ton of the code here (since so much of it is just string assembly). You can do some nice syntactic tricks to clean up things like writing html tags, for example 

with minimal effort and no changes to the overalls structure of the program. In a real application you'd probably return something more definitive from the 'fight' method than a string - a result class with its own message, or something -- but by keeping the details of the comparison out of the main flow of the program it's easier to extend as needs change. Overkill for rock paper scissors, but a big plus for rock, paper, scissors, lizard, spock. Unfortunately real life is more like the latter than the former ;) 

If after all that you still can't get the perf you want, you might want to look into using numpy for the heavy duty tasks. 

that would make it easier to clean up the series of lines. Python is a great language for this sort of thing - it should be easy to cut this down by half or more with built in tools. 

There is probably some perf overhead in the generators here, but they do have the pleasant property of hiding several different selection styles behind a neat facade and also minimizing the index mongering. You could easily parameterize the windowing code to support larger or shorter sequences too. 

I don't think is a standard python construction - does it even execute? In that sense this does not look 'well formed'. Does this execute? It does not work when copy pasted but I think that's just formatting issues. It's hard to write this without some try's, since the standard string > float conversion method is 

The results include a printout of the point and the circles which it overlaps. Or you can just get the points which are included in more than one circle with Note that there are no bounds on the grid, although it would be trivial to add them (probably by setting a range on the and rejecting points outside that range in the add method). 

The advantage of pushing the comparison down into the RPS class is that the behavior can be extended without going ELIF crazy. For example the above can be changed like so: 

which would return a list of all the indices in the list with the target val, and an empty list if the target was not found For the simplest case - just finding an object in a list, the real python way to do it is: 

A couple of things to consider 1) As a style thing, I'd prefer **kwargs to *args in your constructors. This makes things clearer since there's no chance that a change to a base class initializer will invalidate other code in subclasses. Something like @MichaelUrman's example: 

function components If a lot of reasoning goes into the choice or relationship of the functions, you could just put them all into an object and work with those objects instead of loose funcs: 

In the comments to @MichaelUrman's example, OP asks how to create a specific class of car. A common python idiom (which is less common in other languages) is to create 'thin' subclasses that vary primarily by default content and then occasionally override default methods. This is common in cases where you want a lot of classes which are mostly the same but differ in details and you don't expect to manage lots of subtle hierarchical changes. From the 10,000 ft level this is the same using helper classes, since you're just populating a set of variables in a structured way; I prefer it to using helper functions because it allows you to add custom methods as necessary while keeping things data driven. For example: 

This could actually be improved further by replacing 'is_number' with a function that did the float conversion and converted all non-numeric values to -1; then you could just have a single test in the get_input function. I did it 'the long way' so the logic is clearer. The last thing to look at is the layout, it would typically look like 

There's three ways I could see this going. stronger hierarchy Create what amounts to an abstract base class for NeuralNet with stubs for the math functions and then make subclasses to override the methods. 

Allows you to flexibly specify values while providing class level defaults that vary on application. Super (as mentioned in other answers) is great for avoiding repetition here. For example 

Rather than making the game a class, consider making the choices a class. This makes it easy to define the behaviors: 

Searching this can be done very efficiently using the built in filter function. Filter takes a list and a function as arguments; it returns a list of all the items where the function returns true. For example: