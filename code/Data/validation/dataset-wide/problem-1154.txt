Your "Idea 1" is the best approach as it most naturally and accurately enforces the cardinality between SITE and CLAN/GAME/TEAM. Your other rule that SITE must be only one of CLAN, GAME or TEAM would have to be enforced with a partitioning attribute on SITE, e.g.: SITE.subtype_code. You would need either application logic or a trigger to enforce consistency between the partitioning attribute and the existence of a record in either CLAN, GAME or TEAM. 

Your model includes referential cycles. This comes up quite a bit when you're modeling and you haven't worked through the differences between what relationships exist and what relationships are important to your system. Without knowing more about your business rules and their justification, I would suggest that you consider dropping and possibly also . Your table relates subjects and topics. Since you have a many-to-many relationship between teachers and lessons, you can use (via ) to tell you which teachers can teach which topics and which subjects. I doubt that neither nor are correct anyway, since this would imply that any given teacher can only teach one topic and one subject. I don't know about your school, but it sounds much too specialized to me! 

No native RDBMS date data type is going to do for applications that require very old (and for some, even distant future) dates. If I were you, I'd use a string type for the native storage and stick with a place-significant format like: +YYYY-MM-DD to accomodate BC/AD and any foreseeable historical or reasonable future date. If it might help, you could build a library class that converts your internal storage format into a more presentable one for the UI layer. You might even include library functions that convert to a native date type, if your language of choice supports the dates that you will have in your database. 

The way to manage this is that your sub-types have to be determined by the super-type (i.e. the PK of the sub-type is also a FK from the sub-type to the super-type.) The challenge is understanding whether something is truly mutually exclusive or not. The attributes of sub-types should apply only to those sub-types, but it may well be that some sub-types are mutually exclusive and some aren't. If you have some mutually exclusive sub-types, then you can use a partitioning attribute on the super-type to indicate which of the (two or more) mutually exclusive sub-types apply. This partitioning attribute can be used in with constraints or triggers to enforce the mutual exclusivity. If you have sub-types that are not mutually exclusive, then they can exist without using any partitioning attribute. Consider this data model: 

An intersection table such as you've described is the standard way to implement a many to many relationship in a physical relational database. The intersection table has foreign keys to each of the parent tables that it's joining. These may be simple or compound foreign keys. That doesn't matter. The primary key of the intersection table is the combination of the two foreign keys to the parent tables. For this reason, the primary key of an intersection table is always a compound foreign key. 

NoSQL and RDBMS are totally different animals. You should pick the one which suits your data and how you intend to record and access it. Don't pick your style of database system on the grounds of performance. Performance can be managed in a range. If HBase isn't performant at your start up volumes, then maybe you'll just have to work harder to tune it, or throw more money at hardware, or just live with slightly lower performance until your volumes catch up to HBase's sweet spot. 

There are very few scenarios in which you would probably benefit from your second design: One is if there is a sub-typing scenario where only certain a certain sub-type had the relationship (and the super-type doesn't) and the sub-type has other additional fields, besides the foreign key. Another might be where the existence and value of the foreign key needs to be controlled for security reasons at a different level of granularity than the rest of the entity containing the foreign key. Most DBMSs can handle security per table. Most don't handle security per column. 

Your table is an intersection between and . That is a perfectly legitimate design. Intersection tables don't have to be pure intersections. They can have other attributes in their own right (such as your or ). 

The way it works is you have three tangible things: Users, Allowable Actions (the access that is being controlled) and Roles. Roles are groups of both users and allowable actions, therefore there are two intersection tables which record the people in each role and the actions that role permits. Some people include additional information in the ROLE MEMBERSHIP and PERMISSION intersection tables, like when the record was created and by whom. Some people keep that kind of audit log information in a separate table. In this model every type of user is stored in your table. The rules that you have stated for cardinality of users (one owner, one assistant) are frankly very brittle if you ask me. I don't like to cast rules into my data model which are almost certainly going to change. It seems unreasonable to me that a business will use your system if it doesn't allow a manager to delegate their responsibilities for when they are off duty, on vacation or away from the business. Your cardinality rules should be enforced in application logic or with additional tables related to USER if you really feel they need to be in the data model somehow. 

One thing you might want to consider changing is making nullable. Until the employee clocks out there isn't a reasonable value to use here, so NULL is the best choice. You can tell the difference between someone who is still working (theoretically) and someone who forgot to clock out by checking their previous record when they clock in. If the previous record has a NULL clock_out_date then they obviously forgot to clock out. You could also create a report that checks for employees who haven't clocked out for more than (some configurable number of hours) since they last clocked in. You should be able to get a reasonable number for the longest expected shift. It may be once in a while that you report an employee to management for not clocking out when they are actually still working, but that should be rare and the manager will know it - or find it out quickly enough, so the few false positives you might generate aren't serious. One other thing you might want to think about is not keeping the hourly rate right on your staff table. It might be better to keep this in a child table which includes date ranges since you want to be able to let a wage go up or down over time and it would be good to (a) have a history and (b) be able to enter future-dated changes to relieve time pressure for data maintenance. 

There is no earth-shattering difference between a data model depicted in UML notation versus a data model depicted in any of the many common ER notations. They all depict the most important elements: entity types and relationships. Depending on which graphical convention you choose, there may be other features of the model which are conveyed, such as the attributes of entity-types, relationship cardinality, strong or weak associations, etc. The point of the model is to communicate your design. You should choose the graphical convention that is most expressive of the information that you're trying to convey with the least "noise" (unimportant information). You should also take into consideration the needs of your audience. No matter how artfully your diagram conveys the information you intend to transmit, if your audience isn't comfortable with the notation then you will have not achieved your goal. If your audience is familiar with IDEF1X then use that, if they are most comfortable with Martin or Chen then use those. If UML does the job and is what is familiar, then UML ER notation is best, otherwise it isn't.