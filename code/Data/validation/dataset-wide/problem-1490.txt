Let's see if I understand what's going on with get_filtered_lines() and apply_filter(). First, get_filtered_lines() reads physical lines from the file and strings them together in line_buffer. When we find the beginning of the next logical line ('['), we pass line_buffer off to apply_filter() so the material that has been collected gets processed. Then we empty out line_buffer and start over with the beginning of the logical line just read. Here's an approach I think is simpler and clearer: 

The idea is that rather than embedding your data in the code, you should structure it in a meaningful way, then use generic code to present the data from the structures in the way you want the player to see it. I think you're on the right track with your Creature and Item classes. I think maybe you want more classes like Place (or Room), Container (to represent boxes, chests, hidey holes, etc.). If you have to write specific logic for each step in the story, your game is going to be very linear and you'll be limited in how much branching and looping you can manage. On the other hand, if your game is just a network of Places connected to each other with Items, Containers, other Creatures and such scattered throughout for the Hero to encounter and either fight or befriend, and the Hero is free to wander from Place to Place backward and forward and in loops, then the game becomes much less predictable and more interesting. What would the code look like to process such a network of Places, Items, Containers, Creatures, and whatever else you can dream up? 

Seems like that might cut the time in the final loop by almost 50%. The extraction from match_iter doesn't change, so it will take the same amount of time. The append will take about the same amount of time as one of the appends you're already doing. Since two appends will be eliminated, I think the time they're taking will go away. 

I think using that form of the import will let you drop the line where you instantiate the Publisher. I like to put my mainline code in a main() routine right after the imports so it's clear where the work begins 

GraphicalView, OscilloscopeView, and DioramaView each have to implement curve() and line(), obviously, each doing the right thing to display the shape described in its own terms. 

So, let's say you build a website that uses this class for storing data. Then, one evening, you and I both visit the website at the same time. We both hit the button that opens the table and reads the data into memory. Now there are two copies of the data in memory -- one in the page you're looking at, one in the page I'm looking at. You add a record. The "insert" function adds your new record and writes the file to disk. Now I update a record. But the copy of the data in my window doesn't include the record you just added. So when my instance of the code hits the statement file_put_contents(...), what happens to the record you just inserted? This is the sort of reason it's recommended to use real database engines like sqlite or mysql. They're designed to serialize calls and protect users from each other so they can't overwrite or corrupt each other's data. 

There are a few strange things about your code. You are using SHA like a KDF, which is a function that generates randomness from a limited source of entropy. The strange thing is, you have a (virtually) unlimited source of randomness in either or . And you are asking for a random hex in a way that to me distinguishes it from random bytes. So let's clear up a few points: 

There's a bit to unpack here. But the idea is that you'd use it like this: . behaves exactly like . It has all of the same properties and methods. However, whenever you call one of the methods, the method is invoked afterwards. For example: 

Ignore whitespace (although this has it's limits, we probably don't want to become --instead we probably want to error that we can't have two sequential numbers, we'll leave this to the parser so for now let's say the scanner will just emit two tokens for that and ) Turn symbols into single tokens (ex ) Parse numbers (may be multiple characters, can be ill formatted as in ) 

This is the exact code from the module, so I'd contend it's python-endorsed way to generate the randomness you're looking for. 

Notice how each of these concerns cordons off a specific part of your application. And, critically, each only interfaces with one component. (1) doesn't interact with redis or do any bookkeeping, it delegates that to (2) and (3). (2) doesn't have to concern itself with redis things. (3) doesn't have to concern itself with what user command caused it to be invoked. Now unfortunately, because of the way the plugin API works, it's not possible to completely separate these, but we can get pretty close, and in the process produce code that is easier to maintain and understand. Let's first look at the itself to inform what kinds of APIs we need from the other concerns. It needs to handle , , , , and any message containing a (and emojis) vote. That would probably look something like (inline references are of the form ): 

That's a lot of responsibility for a single method. What's more, a lot of these points are duplicated code between the methods (especially the storage/retrieval/serialization/deserialization of the state). What's bad about this? For one, copying and pasting is bound to produce errors eventually. Also, to modify how data is serialized, you need to modify code in many locations. Someone who isn't as familiar with the code as you may miss one. Finally it makes the code difficult to test. As you've seen the only tests that you can reasonably do are integration tests. While this may be sufficient for a plugin, I believe testable code is maintainable code. What is a better way to structure this? It's all about separating concerns. Each class should optimally have a single responsibility. Here are the concerns I can identify in your context: 

There's a lot to unpack here! First, take a look at . It just parses an expression and returns the result of evaluating it (remember how the first production in the EBNF is the "main" one?). To parse an we parse a term , collect any number of that follow it, and evaluate out that math. We do something similar for . For we either try to parse a number (just a ) or a (subexpression) and if we can't find that we raise an error. Notice how the actual work of doing the math in done in and . But, critically, note that the former should only be given lists of floats (must already be evaluated, the parser handles this via recursion) separated by operators of the same precedence. This means intentionally cannot handle . The parser handles this. It would first parse a and call . This would be returned and then it could finish parsing the and call . For a simple calculator example, this code is decent. But you can see how things quickly get out of hand for more complicated EBNFs. This is what I was alluding to earlier. This code needs the following helper: 

One way to get the neighbor coordinates without checking for (a != 0) or (b != 0) on every iteration would be to use a generator. Something like this: 

Actually, I agree with Quentin. For a first effort, your code looks pretty good. You have a hero class called Erdrick and an Enemy class instantiated as a Slime. A class structure like what I show below would allow you more flexibility with less repetition. See what you think... You might want to work out some way for specialized weapons to increase the damage a hero deals and for armor to reduce the damage suffered. 

That way, apply_filter doesn't have to be aware of the list being built. It just returns a list of what it finds -- either a line that passes the filter or an empty list. Passing an empty list to extend is a no-op. 

You don't need "if not out:" at the top of this -- you're in a "while not out" loop and out hasn't had a chance to change since the top of the loop. The "for items" loop just scans through the inventory looking to see if you have the door key. That can be done in a single statement, as I show. Once you've opened the door, you're out, so we can just break out of the "while not out" loop and carry on from there. Several of your descriptions are hard-coded: 

So display() keeps showing the menu as long as userInput() returns None. userInput() returns None if the user's input doesn't match a button, or the inputSel value if it does match. I think the way the Controller loops is fine. The program will always stop when it gets to raw_input() and read stdin until the user hits ENTER or RETURN. That's what raw_input() does. You're managing your buttons as a list, which means you have to scan the whole list until you find the navigation element the user selected. If you put them in a dict, you can simply use the user's input to index directly into the structure and select the correct button (or determine that the user's selection is invalid). However, you still want them as a list for display because you can't control the order in which entries are pulled from a dictionary and I think you want your menu to display in the same order every time. That needs a list. I would suggest the following for the constructor for the Display class. We're going to pass in a list so it's easy to define, and we'll keep the list, but we'll also have the class internally turn that list into a dict so it can more easily find the user's input on each selection. 

With the simplification in userInput() and display() above, the shouldCycle member goes away. Now, with the menu defined internally as a dictionary (self.menu_dict) and as a list (self.menu_list), display() and userInput() will look like this: 

Overall, it looks pretty good to me. I agree that you have good commenting and variable and function naming. I see just a few things to comment on. 

Nice job with your calculator. Overall it's pretty clean, and you have decent use of functions to break behaviors up. But, I'm very nit picky and am going to recommend some really aggressive refactoring, so don't take anything too personally :) 

It seems that someone has copied @MathiasEttinger's answer claiming it as their own and posted another question on CR asking for feedback on "their" solution. So here are my improvements to @MathiasEttinger's solution (originally posted here): Overall this code is pretty good. Well organized, sufficient commenting, good spacing, good use of pythonic patterns (comprehensions, try/catch, etc). So, most of the issues I see are just nitpicks: 

At this point, everything should be working. The plugin and all its commands should just work. We have a well designed set of components that handle single concerns and are not tightly coupled to eachother's implementation. We haven't implemented any serialization though. And honestly, this would be where I would stop. Unless it is really common for the bot to crash or polls take hours instead of minutes, I'd say the effort to serialize isn't worth the complexity it adds. But if you need it, read on: Serialization is always a tricky subject, because it often breaks some rules. Ideally we'd like our to not be concerned with serialization, but for this simple use case it is easier and cleaner to add serializing and deserializing to : 

Now that a knows how to serialize itself. We'd really like to extract the serialization behavior. We don't want it in , but we also don't want it in (since the responsibility of that class is command parsing, delegating, and printing output). We note that after a each (public) method call to we should serialize it to Redis since a change is possible (we assume here that saving a poll that hasn't been modified is of negligible impact). So, we want to decorate the methods of so that after they are called, the poll is saved to Redis. For this we look to the decorator pattern. Namely, we want to make a class which will defer all method calls and property accesses to another object, but after all method calls, we want to add some special behavior. There's a bit of Python magic here, but I'd say the tradeoff is worth it since it gives you such expressive and storage-independent syntax for querying and updating the poll. 

With specific comments about your code done. Let's think generally about calculators and talk about useful patterns for building them (and compilers for programming languages, to some extent). The end product here will likely be a lot longer than the code you've written, but it will be a lot easier to reason about and extend! As a result of it being long and me becoming hungry, I'll omit many uninteresting parts of it (such as exceptions, which I'll just assume exist). You likely didn't realize, but your code is actually already divided into the right parts! You just named them a little differently (and they don't behave exactly the way the patterns proscribe). Intrinsically, we have two different concerns here: