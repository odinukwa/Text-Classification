generates an board as a list of columns 1 to n. So each element in the list is a row, containing a list of column places. is a function (implementation not shown yet) which filters rows to remove any squares which are threatened by a queen in a specific position. For the moment, it doesn't matter how it is implemented. is a recursive function where for each square in a row, that position is prepended to applied again to a filtered version of the remaining rows (filtered to remove any squares threatened by a queen in the current position). So this is a recursive function which pursues a lot of branches. The top left corner of the board alone generates 6 branches (it can only threaten 2 squares in the next row), the first row as a whole generates 42 branches, each of which subdivides again and again. That's a lot of branches. Yet this function is simple and performs fast. Why? It's simple because it doesn't need any special logic to backtrack if it hits a dead end. If at any point there are no more valid moves, then will return . Which means the next iteration of go will effectively be 

Once you have these classes and created each object, your game could consist simply of a loop which takes the first situation, runs its method and then runs the of the returned situation and so on. Note that I haven't told you which kind of collections to use for any of those fields. Lists, arrays, sets or maps could all be used. Which do you think would work best for or ? Another question to ponder is "What if different decisions (in the same situation or in different situations) have the same result, leading to the same situation? Would that need changes to the Situation or Decision class?" In my simple suggestion above, Situations describe both the action of the decision you make and the situation you are in after the action. If you think about this carefully, you will realise that what I haven't explained is how you would end the program. There are several interesting ways to do that, but rather than just give them to you, I think you should refactor your game to make it use classes and then try and solve the problem yourself (maybe asking for help on a StackExchange site). Once you have working code, come back to this site and ask for a review. EDIT OK, I'll give you a hint for the simplest solution - a which has in the field. But I think that is the worst solution. There are much better ones. 

There are ways to do this without modulo arithmetic and/or even fewer iterations. While my simple solution addresses the first 3 inefficiencies I listed, it is iterating rather more than is needed (mitigated significantly by working down from the top). Maybe you can improve on this from here. 

I did this using a companion object, which is easier because it doesn't require modification of the original class. This is the conventional way in which type classes are used. Although I have been able to implement all the Numeric abstract methods using only your method, it would be useful to add native , , methods to and rewrite the implicit type class instance to call them. The important point is that what I have shown you is really very little extra work and immediately gives you the use of many built in functions from the collections api. Arrays are not appropriate here Did you use arrays simply because you aren't very familiar with pattern matching but understand pulling elements from an array? There really is almost no benefit at all to using arrays here. Arrays only offer an advantage where random access is needed to a collection of fixed size. Your use of the collections is entirely sequential sumFractions As covered above, need specify nothing more than as input. The solution will use the appropriate, optimised implementation of whichever sequence you pass in. Even with explicit recursion (example provided on demand), the solution can be generalised to without demanding by default all the copying required by . Even if you choose to optimise the file input and parsing step with parallel collections, need not know. LinesArray not necessary Any sequence (and other collections) can be mapped over. As explained, does not need an array. Even if it did, you could convert to an array at the end of input processing. Also, consider that some of the lines may be invalid. You may choose either to halt at the first error or discard invalid lines; in either case, converting to an array first would be a waste of effort. Parsing Ah, now, does offer a simple way to parse the input lines. If you want to handle only perfectly formatted lines (not even permitting whitespace) and halt/crash on bad ones, it will do the job. Although your current implementation actually does tolerate some possible bad lines. Processing the input Halting on the first error 

Rectifications can only be actioned once a car is added Cars are not removed from Rectifications once added 

My final two observations... Firstly, you should have an apply function in the companion object, so that you could create a CrockPotTree like this 

Of course, what we both really want is a way to minimise traversal. Scala just doesn't make that as easy as I'd like. But does mean only 1 traversal, with no new build, both if the value isn't found or if it is already at the front. It also means equality tests are only done on one traversal, not two. After a little more thought, I came up with a variant of the above solution which really only iterates just once. But it may not be future-proof. 

The Scheme code is quite reasonable. However, this is a very naive solution to the problem. You are wasting processing time by testing each number to see if it is a multiple. Even with this naive solution, why do you start at 1, not 3?. Think. If you do start at 1 (which you know fails the test), you can create all the multiples there are by working forward. DonÂ´t forget you need to avoid generating numbers which are multiples of both 5 and 3 more than once. 

Now, the functions that work should be recursive (or fold over a path through the tree, which is a kind of recursion). Why? Because this is a recursive data type. The first point to consider about this is that your steps type in WalkTree is wrong. It is almost certainly better to have it a list than an array. That way, each recursive iteration of walkTree can look something like this: 

So that is how to use folds and iterators to process collections efficiently, traversing them as few times as possible. And how to do that without mutable state. Note: I did it entirely with immutable state to show it can be done. However, using one mutable variable inside a function, where nothing else can see it, is not a functional sin. Updating immutable maps (that is, returning a new copy* can be just as fast as using a mutable map, depending on the usage pattern. Really, you should test both options with a range of inputs to compare. The (slightly) mutable version can be done simply by using a mutable map and the update method - very small change to the code. 

Your code is structured only around months, so has to use conditional logic to create your rows. My code is structured around rows (and within that around months), so needs no conditionals. My code also only has the value for the number of months in one place, which is less error prone and makes it easier to change the number of months in a row. You don't have to use a list comprehension, though. The important thing is simply to slice the list up into groups of 3 (or , where is the number of months you want in each row) and iterate over those. 

You should now have enough knowledge to create an Option 2 style walk, if you think hard enough. This is why we seal algebraic data types so they cannot be extended. My size function knows that the answer will always be 0 or more, because there are only two CrockPotTree types and they both return a proper value. If some idiot added an new case class which returned something else (null, for example), things could explode. 

Now anybody using your code can choose to do , after which will return Pattern matching in explicit recursion As Janos said, the best solution is a higher-order function but if you are going to do explicit recursion, pattern matching is often much more expressive and clean, as in 

As ErikR points out, you are calculating much more information for each row than you need. Only the queen's placing in each row need be kept. You are explicitly calculating (almost) every possible placement and then filtering out the illegal ones. 

Io has no switch or case function and the community doesn't want one. lists (using a numeric index lookup) or maps (using a string key) are sometimes used for very simple switch-style control flows but that doesn't work here. 

Basic problems with input Your code will blow up if there are fewer than two fractions in the input. Even @janos's solution (which can cope with only one fraction) fails if there are no fractions in the input. Is that reasonable, especially given that the sum of no numbers at all is 0? Your code also fails on any badly formatted input but there's enough else to talk about to leave that for another day. Style apply method It's common practice in Scala, with types like your , to add an method to dispense with the need for . It can be added directly to the class or in a companion object. 

Because this uses a partial function, if any input line does not split into an array of precisely 2 items then the program will throw a . Pattern matching this way is expressive and succinct enough to combine the second and third transformations. So we could replace both and with 

You are doing the same thing to both a_counts and b_counts. Duplication that could be eliminated. You have a loop updating a mutable variable. A for...yield block would be one more idiomatic (and functional) way to do this. If one of your lists has values not present in the other, you are wasting effort totalling counts of those values. 

Point 2 is actually the more important one. To choose an apt analogy, you know the story of the peasant who asked the emperor to place one grain of rice on the first square of a chessboard, two on the next, four on the next and so on through powers of two? And the whole empire is bankrupt before square 64? That's what you're doing. You are forcing Haskell to consider every possible variation, which would be costly even in an imperative language but is more so here. In an imperative language, you would use lots of tricks to detect when you can abandon one branch of the permutations and track back. The advantage of lazy Haskell is that you can greatly simplify such code by "creating" large or even infinite structures, but only every evaluating small sections of them. The trick is to only ask for what you need. Here's part of a much more idiomatic and also much more performant n-queens solution: