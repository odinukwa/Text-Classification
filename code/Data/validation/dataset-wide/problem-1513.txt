Selection sort No issues, although you have variables declared a little further from their point of use than in the previous routines. ... I might look at some more later. 

Here indicates that will not be updated in the loop. You code could probably just exit the function from the second loop, once the odd-occurring element is known. If you don't do that, you should perhaps handle the case of multiple odd-occurring elements more reliably. 

Insertion sort You appear to be writing the moving element repeatedly, which isn't needed, and as mentioned there is a flag you don't need, so you can break out of the loop to place the moving element. 

Your main slow-down there is that you are copying and recopying the interesting data on every line. That's fairly easy to fix. Your construct didn't appear to be doing anything, so I removed it. In any case it is not a great idea to have a 'With` block that reallocates the referenced object internally. You would do well to use "Select" a lot less often, and there is no need to continuously redefine RngCopy. Here is an update that should run quicker and look calmer: 

One possible bug is that you reset your output column to 1 with each Shape but you only output for each Slide. If there is more than one Shape with relevant information you will lose some or all of the first Shape's input in your table. 

For review, ignoring the excessive SQL selection, I would observe that your code is quite likely to create a spreadsheet of misaligned and partial data. Any values requested for retrieval which don't actually exist in the database or are in a different order than the spreadsheet will be set against a different identifier, potentially wrecking any association with the values in the A column. If that association is not important, I would suggest that the records should be put into a different tab (or different workbook altogether). If the association with the A column is wanted, you could retrieve the records singly, although of course that would take more time. The gaps of nonexistent records would be apparent, if that might be useful. You can achieve the sheet clearing action you seem to want at the start of the process - preserving first row and first column - more generally with 

Which now only the parser and formatter need to be concerned about. We could then change the function signatures to: 

Whether the class is immutable, or I need a "quick" way to instantiate it and have getters (additional features of a case class) is irrelevant to me. So, I hope this has helped and gave you some insights. 

Once you extracted the parsing and formatting to external functions, you could further simplify their parameters. I introduced this case class: 

3. Formatting It would seem that my code is less functional, less Scala-idiomatic, less fancy, more boring and more Java-esque. And, you would be right! It is a matter of personal preference. My top priority when I write code is for it to be as readable as possible. For me, code which is obvious to the point of being boring is something positive. But that's just me. For example, and in case it serves any purpose, here is my refactored version of your : 

5. Case-class or not? To close I want to address another question you had, which I will paraphrase as this: 

It is longer and more verbose. Yet it does the same. I tend to favour longer, more verbose code, but not to the point where meaning is lost. 4. Other Points There are some other improvements that I want to mention, which could also be considered: 

The decision is subtle, probably personal, and we enter in philosophical arena. There is of course nothing wrong for this to be a case-class. But personally, in this case, I would not make it so. This is the criteria I use to decide if to make it a case class or not: Case class if: 

Naming naming naming Your code is very intimidating - it is filled with single letter variable and members (...). Those which are not single letter are generic and unhelpful (, , ...). This makes your code very unreadable. You also use a lot of literal numbers (...) which make no sense to a person who is not familiar with your algorithm. Use constants to make your code more readable. Your comments are also not useful for someone to read and understand your code. If you want a serious code review, you must make your code readable, break large methods () into smaller ones, etc. 

I'm not familiar with Umbraco, and I could not find any documentation on LinFu, I do, however, have some remarks on your code: Comments - your code is more than 40% comments, and un-useful comments at that - a comment that tells me that is is a waste of space and reduces readability of your code - I actually needed to copy your code locally and remove all the comments to read it. Static vs. instance scopes - you chose to put some of the state in the instance, and some in the class, but you manage both from the class. This means that if you create two instances of your class, their state will be unexpected, as they will change each-other's state. If you this class is meant to be a Singleton, make it a Singleton. Use locks properly - you chose to use as your lock object. That's OK, though I don't see why you would need a reader-writer lock. The problem is that you misuse it - the way you use it is as if it was just a regular object. Again, a simple lock object is fine, but declaring it as a fancy lock type, you confuse the code reader to look for (and assume) its use. 

Which would only need to be defined once in your main method, and passed as parameter to both parser and formatter (if so inclined, you could go one step further and dictate this to be an implicit parameter). I think just these changes so far would make your design simpler, separate concerns better and let your main class have less parameters. 2. The parsing But you also mention that you are not happy with the implementation of your parser. What do you think of this? 

You have an interesting implementation. I like your approach into making it "boundless" (that it could expand as-needed). I also like how you use "streams" to compute the values lazily. And some other minor gems. There are of course some things that you could consider in order to make the design better. 1. Separation of Concerns The most important thing I would do is to keep the parsing and the formatting separate from the "game". For me, these two concerns should be external to both your internal representation (a set of tuples) and logic. For example I would have an object (or a class) and , each with one method to respectively parse and produce a "formatted" string-representation of your object. (Why not just leave the formatting to ? In my opinion is not there to produce complex formatting, much less "parametrised" formatting (as the "living" and "dead" chars are carried around only for this purpose) but to have an useful, but minimal, string-representation of one object instance. The way I see it, is for the developer, not the end-user. Note that for this reason implementations often "cut" or "summarize" the contents of the object. It gives you an idea of what the object is about). You could, then have the same symmetry we see in JSON serializers. There we find readers and writers. You could have something like: