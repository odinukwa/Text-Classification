I see quite a lot of repeating code, repeating the same activity: get request, build string, query string, return result. The Single Responsibility Principal can help to clarify your code here. As a suggestion, you might want to turn something like get_products (and similar) to: 

I can see the following problems with the above block: Redundant comment, redundant brackets, using a while loop and throwing an exception to control program flow, converting the input into an integer (you're not doing any math, so there's actually no need to convert it into an integer) and assignment with an unused variable (). I'd do something like this instead: 

Also, for your locations, having functionality and properties separated into tuples doesn't make sense, you'd need to create hundreds of tuples and track them all (how do you link them for the adventure? how does the user move between them?). It would be easier to create a base class of and or to inherit. The class would contain the logic of the user moving into and out of the location, Rooms would have additional functionality like light switches (and if they're on or off by default). For this, I'd use a feature map (a matrix containing a 's default properties) and make the process of loading them responsible for creating the objects (and adding certain items to a room). As this design is quite complex, I would suggest separating the location data from the code, possibly by using and storing the data into an file. Something like: 

because is the same as etc. When I run your code after making those changes, I do want to ask why you have the file "split" happening. When you perform that, (if I use the smaller example data on pastebin you linked to) I get the following structure as : 

Admittedly I actually wouldn't do the last line, purely because it's not clear coding, but it demonstrates the ternary and that you can utilise functions in such a fashion. The while loop is removed, the exception is removed, and the input isn't converted. An extra line is printed explaining what happens if any other key is pressed (you should trust your users will know if they hit the right key - don't over engineer it - plus also as they have to hit [ENTER] to complete the input, they have a chance to fix it, if they do actually press something other than intended). Hope this helps, Good Luck! * code is wrong: Not wrong per-say - but a failure to express the instructions in an easy to comprehend fashion. If I cannot read your code and understand what you're trying to do - then you've wasted time writing the code (obviously there are always exceptions to the rule and there are times when a comment is necessary). 

Example of the chaser and chasable interfaces in action: First lets make our interfaces a little more rounded 

There is some form of JS voodoo going on here that I can't programatically work out, can anyone help me shed light on how JS is interpreting this and why when I call: 

within a class scope, the Extension object seems to extend the calling objects prototypes allowing me to bind a callback within the class scope. And then attach a handler after I have instantiated the class. 

I agree with Gerard a little, you have made (in my eyes) a common error with interfaces where you've tried to make them specific to a certain type rather than what they actually do, I see this a lot in the wild (excuse the pun). This isn't to say that interfaces based on type are bad, they have their place but in general an abstract would be better suited for types as types will have unique properties that you could not declare in an interface (nor would you want to). As an example I'll elaborate on the "Dog is also capable of chasing" example. Declaring a as makes no sense when trying to describe what a Dog is, instead, make it capable of doing something. 

Only functions parenthesis start on the same vertical. Objects and arrays are always indented 4 spaces beyond the function. 

First things first, you're creating no less than 5 jQuery objects for each time someone hovers and moves out of a menu item. Two things on this : 

You're jQuery can be written in one simple function as a catch all for the entire navigation. As you stated you think it could be condensed, you'd be right. As a rule of thumb if you see yourself writing the same thing over and over you should be able to cut it all down into one function. Starting with one of your methods I'll step through it to show how you can condense this and make it more efficient. 

which is easier to work with. Anyway, hope these code suggestions help you to write better code and update the design of your code to make the solution work for all data sets. Good luck! 

Several issues with your code which is causing you issues (this won't give you the final code but it will help you get there). Firstly, never hide issues by modifying the stack recursion, and never wrap operations in . The errors are there because you are doing operations the computer does not like (and you shouldn't be doing). As an analogy, you could drive sometimes on the wrong side of the road to get places faster - but you don't because it breaks convention. Next, update your code to be more python'ish. For example: 

having them all send a sql string into a single function. That way, you separate the database functionality from the business logic of each activity. For and , three things. Personally, I don't use double underscores for functions, a single one is sufficient to advise other developers that the function is intended for private use. Secondly, the string building process, you should attempt to use list comprehension to build the strings rather than a loop, this will result in much simpler code (and no "last param won't have..."). Thirdly, both these functions are the same, and only differ in their use of a or . You should have both refer their details to another function with a parameter. Something like (not functional code, just a typed up demo for the concept): 

I would narrow down your try:except to only the statement(s) which could throw the error. Having such a large chunk of code in a try:except block could result in many exceptions thrown, none of which would be caught as you're only looking for IOError. Also, for performance, you should build the statement and the data set from the loop, then throw the statement against as a single database call instead. Regarding construction, your code is just one huge blob. It's important that you refactor each operation into its own function, this saves on tracking down errors, and if you make changes in the future, your changes only affect one function. If the change is not liked by the rest of your code, it's easy to back out. Can you imagine if you made 5 or 10 changes in your program as it is right now, and then it stops working? Which change was the breaking change? How would you find out? Why did it break? etc. Also, I'm not talking just simple syntax errors, I'm also talking about logic errors or data errors. These can be hard to track down if you don't have any tests validating your code. Good luck! 

Don't use jQuery to... Modify CSS unless it is absolutely required (ie CSS alone can't achieve what you want). In this case CSS can handle you're requirements easily. If you find you need to change a lot of CSS and would like this CSS to change due to a jQuery or javascript event. use and . Applying the styles in CSS rather than in jQuery. This is far more efficient in terms of code and your eyes. :) Cache your jQuery objects 

The difference is that your routes are mapped to the controller methods. Your GET route would map to the method in the controller. While the POST route would map to in the controller. Also, the GET route would be handled by in the controller. Changing the routes is a case of changing the controller methods. This means one place to change your routes rather than two. 

I'm unhappy with the one jQuery call with $.extend() but this proved the easiest way to accomplish an object merge and I use jQuery quite predominantly in the majority of my projects. Despite that can anyone suggest a different way to do this? While this works fine I know it's far from perfect as it's limited to one search term. My thought was to add in another loop within but I'd prefer to avoid doing that, my second thought was to map the object and perform the lookup once I'd found an object with the first property match. Again any suggestions on how I might accomplish this whilst keeping the script clean and fast I'd really appreciate it. Any other suggestions welcome, thank you for taking a look. :) 

The logic is really confusing me, I understand how call() and apply() work in the simple example above but I have no idea how or why the prototypes of the object are extended when I call . Could anyone help me shed some light on this?