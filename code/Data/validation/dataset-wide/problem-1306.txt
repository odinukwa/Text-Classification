This is bad way to write code , I could not even read the code without headache. Please separate out your logging functionality, you function should not be more than 30 lines per method, so first 

I would create two extension method , ToApplicationData and ToAddress and will define mapping over there. it will sorten you code and much better readablity. you can break this methods too if you want. 

Your sorting logic is dependent upon the specific type. "Separate your data representation from logic." you must take advantage of the generic to reuse the same component to sort any kind of object. In case of class you can specify comparer to sort the values. Naming convention should be followed. i and j does not make sense and in c# standard method naming convetion should Pascal case , should not start with lowercase. Rest logic looks good. 

once this is done you can further refactor your if else clause in a strategy pattern , so you will need a factory which will return class will handle the Archive rule or mirror rule inside a different class and your FileActionService will contain only processing logic 

you dont need this whole code in this way , rather create a logger class and put this whole line of code there. Pass only dynamic parameter. Once you are able to cleanup , pattern can be applied easily 

Your instincts are good here, in almost all respects. Your basic algorithm is good, and your suspicions that you are changing too often between String an char is also good. Using the StringBuilder is the right thing to do, well done. Breaking the String in to chars is also good, but the way you do that is inconvenient.... In part that's because there is a convenient function in the standard Java class that you will find useful: With that function, you can throw out your function, and simplify the whole thing down to chars, strings, and ints.... something like: 

Collector associativeness One of the properties of a Collector is that it is supposed to be associative. 

In general, with data structures containing nodes, it is common practice for the node class to be a simple container, and not a computational power house. You have reversed this concept, and made the Node the engine.... which is unexpected... and is why you feel your class is 'awkward' with the static methods, etc. Rearranging where the logic is will make a big difference. This is a big change, and going through your code as it is, while saying "everything is in the wrong place" is not productive.... it's better for me to show you what it will look like if the Node is a simple container, and the actual Trie does the heavy lifting. Things about this re-factor that are significant, and you should look for are: 

Here are few comments 1) Try to encapsulate the piece which is subject to change. your code is dependent upon amount which can be withdrawn so rather one by one division you can create a list which will consist of that piece only. 2) Use for loop in case of repeating logic. (See below) 3) Prefer Writing Extension method 

2) Always dispose the connection In above code your opening connection and closing it, but this can lead into connection leak in case of errors. Please wrap your code into using statement or try clause like this 

Please separate out your code into at least two classes 1) Fetching data class 2) UI binding stuff class 4)inline SQL vs Stored Procedure Stored Procedure is good as your code lies at one place in db but creating Stored Procedure for one line of SQL is not a good idea. If your logic is going to be complex and big ,Use a Stored procedure other wise inline sql. PS: I have created a gist named SQLHelper class for you to abstract out the sql connection and command things, $URL$ 

If any object provide dispose method , prefer using statement. Use dictionary rather than list of parameter as you have a possibility of specifying param names also Current implementation sticks only to datatable , you might need to think about the datareader. naming of variable should be explicit. 

Solution 2 The second solution you have is similar to the merge sort in some ways, but not exactly. The merge sort is a stable not-in-place mechanism. While your solution loops through the content once to count the even numbers, I would also recommend a solution that just has one insertion point. Note that you test the evenness twice for each value. The following solution also does that... it's not worse: 

By doing this flattening of the data you can halve the number of loops you need (you only need one loop to access the entire matrix), and you reduce the number of physical arrays (and the memory-separation) of those arrays. I have employed this type of logic in the solution.... Pro's: 

the above code no longer uses "using namespace std;" The sum method no loger uses static variables. Those are a bad idea especially when it comes to re-entrant code. Output a newline after the last line. 

A single is almost always times faster than s. If that does not make it work in time, then consider reading the entire System.in in to a buffer, and parsing it from the buffer. 

Your code is well structured, and nice to read. This is a good thing. You appear, from what I can see, to be using the appropriate threads for doing swing, and non-swing work. This is good. There are a few thread-safe issues I can see: 

Introduce a DAL helper layer which will be responsible of opening and closing connection and executing commands. There are lots of DAL helper layer is available Write an extension method to get values from the data reader. Here is one dummy code 

I used nsubstitute and fluent assertion instead of Rhino mocks , It will make your test code more readable here is an example. 

Rest code looks okay. just wondering why you just not cache the data for a predefined interval rather that doing this.I am not sure which kind of application you are working on. 

Bind method should be used only when if your element is not loaded into DOM on pageload. So you could attach events to it using bind after wards. also if your using jquery >= 1.7 use 'On' method to achive it. but as per your js fiddle you don't need it at all. second you could declare a variable to store the jquery object of follow. Make sure about the variable scope though. 

I would write an extension method to check whether the above condition holds true. and I hope eHistoryCurrentMedsGroup is a list of some object so you could use Any(). 

This is overall comments on above code 1) Encapsulate what is repeating In your method you are opening sql connection, adding parameter and executing it one by one. Rather doing this please extract out it into one method. 

Using these two values ensures you cover the possible spectrum of valid input values. In addition, a sadistic user would enter 5 large values, and cause your value to overflow, creating a bad result. You should declare your as a value: 

There are a number of issues I see here related to the implementation. vs. ratchet freak has already pointed out that the should be outside the : 

That code does not .... probably because it was just an oversight... and this is why functions are good ;-) The above code could be: 

The tools in the package provide very convenient access to complicated structures that can save a lot of development time. The tools all come with a caveat though - their behaviour when accessed by multiple threads concurrently is deterministic, but not necessarily intuitive. In your code you use: 

There are two major sections to your question, the first has a general purpose comparator setup, the second has a specific rankings system. The Rankings system is the one that concerns me most..... ... it's an enum. Enums are naturally comparable, and sort in the same order of their declaration. Your entire use case in the second set can be handled (in Java 8) with: 

Variables I understand why you have the and to avoid confusion about where those variables come from... If you need the as part of the teaching exercise, then sure. Otherwise, I would recommend three things.... 

by using this you have only a reference of interface will be there in viewmodel . but not the whole view itself 

okay first of all, you need to use buffered stream to read data from the file, there is no need to write data once in file as it might hung altogether. so I would suggest that read the file line by line , parse it and then write to file. 

You can minimize you code taking out the filtering out side of loop. Avoid catching exception inside a loop if it needed ,(it seems like it cannot be avoided here) No need to invoke datarow extension method to get value , you can get it directly. Naming of variable is really bad. 

b. create an interface named as IView and implement it in your view , pass the instance of IView to data context of the view 

As per my interpretation, you don't need empty string check inside the if clause you can put it out side, and last condition could be expressed in one line. 

toggleRows should not take a checkbox id but a show variable to show/hide the row by doing so you can call this method from any where. 

Server is a part of Message so server initialization is part of message itself. so updated solution: 

so basically it is your choice : with optional params you cannot enforce user to input the value, so user can leave giving any input and complier will not complain. 

Unfortunately, that has a flaw with Integer.MIN_VALUE (the abs of Integer.MIN_VALUE is.... Integer.MIN_VALUE - a negative number). The net result, is that I considered doing an abs on each digit value inside the loop, but then realized, that all the digits will be negative, so the 'sum' will just be a large negative value, and we can take the absolute of the sum safely, because the sum of the digits will never be large enough to be a problem... Thus, the solution I would recommend is: 

This is a 'specialized' task, converting an input string to a double value. Whenever I have micro-tasks like this I try to refactor them in to a method which does things properly. As far as I am concerned, neither of the above two systems are valid. You should be validating the input value to make sure that, even if it is populated with a value, that the value is meaningful, and the parse succeeds. So, I would have a function: 

So, for a short run, the Java code is 3 times slower. Note that a lot of that time is probably startup overhead for Java. When I run it with 6 characters, it runs as: 

Using a CTE (Supported by SQL Server) would help separate the logic of the query better than the sub-select in the from clause. Using the auto-increment ID is also something that can simplify the query. Consider the following: