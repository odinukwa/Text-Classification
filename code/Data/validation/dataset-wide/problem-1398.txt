All the above (and there are more) require considerable memory resources. They also prefer these resources to be readily available to the GPU so if possible will occupy GPU RAM (shadowed from RAM) Running out of free GPU RAM is a the biggest performance killer for the browser's rendering engines as it begins to swap resources in and out of GPU RAM to complete the render (GPU bus thrashing, or GPU RAM thrashing). Do your best to keep usage as low as possible by always releasing unneeded resources. I would make some changes 

Over time the difference from the lowest count and the highest count for any item should slowly approch 0%. Distribution test results 

Now you have an alternative solution without a slice in sight, improved memory and CPU use because you can avoid the recursive over head, and a reduction in the overall complexity by turning many of the merge call into simpler single statement sort. 

Simple balanced brace checker. The quickest way to solve the problem is to use the Javascript RegExp (regular expression) It is used to search strings. It is a complicated object to master but well worth the effort as it will save you 100's of lines of code. To solve if some string has balanced braces you need two regular expressions and some assumptions 

Object properties. When you are creating objects with dynamic properties you can assign properties directly to the object using This has some performance benefits as well. The following is an example of an instanceable account state machine using object assign to assign the the state. 

General style issues. These are not must do rules, they are just guidelines to think about as you code. 

Improvements. In the end the weak point is the hash generator. Using a 64bit hash will improve the result. But that will not get much more. Using the characters of the word as an integer will give a perfect hash, but then you will have numbers with bit counts as long as the string * 8, and the random number generator would have to be able to accommodate these large integers as seeds. It leaves the question, how many bits long does the number type have to be for the fnction to get within 99% of ideal? 

Re-write Using the points above I have written you methods. The test call gives 5 elements, to fit in a 8 units max width. You result returns the wrong count the count should be elements with widths ,,, and 

Do you need to iterate? There is a lot of room for improvement.. Use one loop if possible. You have many loops where you iterate the same number of times. Rather than doing each loop in turn do as much as possible in one loop. Eg. 

As a parallel solution. With not to much effort the regexp searches can be done on the GPU via webGL making this solution a highly parallel solution. Thus the max cycle count is the depth of the deepest matching pair + 1. That can be no more than 

try to define your event handlers as named functions because you need a function referance to remove the event if you need to. 

In terms of memory use GC impact, and CPU use the following can do the same in ~70% the time and much less memory. 

Your code would overwrite any global scoped variables, and is completely unsafe for general use. If on the other hand you had bound a specific object to the function to isolate the variables from the global or containing scope then you still have some problems. General issues The function needs to return if any 2 of the array's numbers add up to sum. In the loop you check for the match and set a flag. But the condition has been meet, there is no need to check for any more matched. You should return true at the first match, this saves CPU cycles and memory. 

Though this does highlight a problem with this method of defining settings, you can not access the settings when defining them. EG 

The best way to use a hash to scramble a list is to use the hash as a seed for a pseudo random number generator. The seed ensures that the sequence of random numbers will be the same for the same seed. Unfortunately javascript does not provide a seed value that we can access for it's function so we have to create our own. The most basic pseudo random number generator is seed = (A * seed + B) % M where A,B,M are large integers. Each time the function is called a new seed is generated and return as a random value. The seed is also used as the seed for the next value. Once you have a good sequence of random values you can use them to create a better shuffle. Putting it all together. Thus a rewrite of your code with a random number generator to do the shuffling and an improved string to hash function. 

Functions If you write many functions with just a few minor differences its a good sign that you can write one function and pass the differences as arguments. Each function has just two differences, and abstractly just one "The choice" 

Quadratics can also include fractions or . You should also be able to add the equations strings together, two or more 2nd order polynomials added together (joined with a "+" or "-") should equate into a valid quadratic. Naming The function naming is rather bad. To name a few examples 

Javascript's Map object You can use a Map to reduce the array of objects. A Map holds a list of key, value pairs. Each Key is unique and can be any Javascript Object or primitive type, the same for the associated value. You could create a generic function to handle many data types. The unique index needs to be defined for the function and could be handled as a callback the takes as an argument an array item and returns a string containing the index. Also I assume that the name is not unique and that is why you need an ID as well. I added two names each with and different ID just to test. 

I am the wrong reviewer Coders can be grouped into two types, those that will use libraries for anything and everything, giving automatic trust too 3rd party code, and those that see libraries as inherently slow, a potential source of unknown bugs, and will only use a library after thorough evaluation of its source, documentation, performance, and cost (kicking and screaming the whole way, "No No... dont corrupt my perfect precious code... " ;) ). I am of the latter and thus maybe not who you want evaluating your code. However as nobody has yet provided a review I will give mine. Why the most popular libraries are inherently slow. A library is designed to work in unknown environments and be usable by both professional, amateur programmers, and many monkeys. A library can not trust any data or adherence to methodologies. To protect the libraries stability it must vet anything that is exposed to the user (code that uses the library). Library code must constantly be on guard that internal state is not mutated. Your code is lacking some basic protection and there are many ways to have it fail, not because your code logic is bad, but rather that the monkey using your code is feeding it bananas skins rather than the banana. You need to add more vetting of arguments, and properties that come from external (un-trusted) sources. Evaluation. This evaluation is in terms of my expectations of a library, is subjective and is certainly not how everyone would see it. The other camp will say, does it run? Yes, does it like my data? Yes great stuff add it to the pile. Documentation. There is no documentation apart from that in the source. You should have a separate document that contains, at minimum, a Library overview, how too guide, abstraction explanation and complete API reference. You should not have documentation spread randomly in your code. Even if this is just a hobby project at least move the documentation to the top of the source file in one comment. That said the documentation you have given for each function is good, though the top comment, listing API methods, is so sparse it provides little useful information. You are also missing details about errors that can be thrown explicitly by your code or can be expected by the JS context. Performance. Without running the code and based on just viewing the source I would say your code has good performance. You are not using any of the common anti performance patterns. Memory use is also good with not too much wastage and GC overhead. Good is not great, there is thus room for improvement, anyone that has used GA's will know that they can be time costly functions with run times being very long. I don't see any performance oriented patterns like object pools, pre-allocation, object reuse, and in-lining (Yes JS optimizers will inline for you, if anyone knows how to ensure that do tell) Cost This is a hobby project (I assume) and dollars and cents don't come to play, well kind of. Cost is time, does you code save the users time. The time is not just adding the library to the project, it is in learning the API and reliability, you dont want bug hunting to enter the library costing users time. Time savings. I ask, can I write the same (and tailored to my needs) in the same or lower time cost. Based on the fact anyone using the library will already be familiar with GA's, and an effective line count at ~250 you are at the time saving border, experienced codes would see using your lib as a time cost (I can write it in less time than it takes to evaluate it), less experienced coders will see a time saving. As the primary designer you should ask your self, "Can I add more value (time benefit) to the library?" Source code. Sorry to say the source code is of poor quality. The primary reason is that you are using old school JS. The current JS version is ES8, and if it was not for the use of (which you only use in loops) and one function using a default parameter, your code is plain old ES5. You need to move the source up to the current version of ECMAScript if you want people to evaluate it positively. Code style points There would be more but I am limiting this mostly to ES5 style points. 

But it is still not the best. There is only one way to shuffle. The only way to shuffle and be as random as the random number generator you are using is by random pick. You create a new empty array, then randomly select and remove am item from the original array and push it onto the new one. 

Look and Learn Look at other examples of similar applications and learn from them. This particular type of app is not new and there is a lot of open source code to learn from. Some sources of code examples are Google search, Github, MDN (MDN's DB indexed API reference will have some data retrieval examples I am sure) and even the fiddle page you gave. The code windows are syntax highlighted. Yay I will say it is good to see you use to trigger visual updates. This is seldom used and is best practice for any sort of visual DOM changes.