Doesn't really belong to the Controller as well. The easiest approach would be to have all your database specific functionality in functions in a separate file: 

Points 1 to 3 are user interface specific concerns. In an MVC approach they belong to the View and not in the Controller. Point 3 can be a user interface concern, if the texts are static, but can also be viewed as a data concern. The same way you get data from the database, you could collect all these static texts in a configuration file and only have to look at one file to change them across every View in your application. That could be considered a Model approach. Having said that, this: 

Consider all of the above as extreme nitpicking, your code is way past the point of obvious flaws. The real value of the answer, if any, was to point you towards the SPL. If you did consider it and rejected it, would you care to share why? 

In an example workflow, let's say we're playing a track and click the reset button. The view added a listener to the reset button, so that listener will fire. The implementation is simple and only notifies the views listeners the the button was clicked (the view is supposed to be dumb, remember?). The controller now is notified, and it is smart so it will know what to do! The controller takes charge and stops the sequencer (updating the state), and then tells the view to reset itself. And that completes the cycle! (Interact with view -> view notifies controller -> controller modifies state -> controller updates view) 

MusicInfo Class Long story short, you don't need this (I also think there's a better approach than using a 2D array, but for now, let's assume the array stays). The 2D array that's being wrapped here is a UI component, so it can easily become part of the GUI class. The methods in this class are just syntactic sugar, and really don't provide any additional benefits. Plus: 

The clause is very similar to the one discussed previously, only this time other than checking if has a index, the author also checks that the value is larger than zero. That's an unsafe check, because at this point we don't now what the type of the value in is, and if it's anything other than a number, there will be automatic type juggling involved, and the check is completely unreliable. From the name and context, I'm assuming the variable should hold an integer (if anything) that limits the search. If the variable doesn't hold anything, the limit is set to zero (), curiously using a string form of zero. I'd rewrite that check as: 

I was trying to explain the mediator pattern to a new developer, and ended up writing a simple event mediator. Thoughts? EventMediator 

This is my first foray into the wild world of jQuery plugin development. The plugin "ajaxifies" forms, which isn't particularly spectacular: 

Resulting Code With all of the design changes in mind, here's what the result could look like: BeatBox.java 

BeatBoxConstants Constant Class (of Interface) are a bad anti-pattern. Instead, we can easily just pass in the number of beats to the constructors! 

Use static variables that are already part of the Javax MIDI library. For example, your and magic numbers can be replaced with and respectively. This applies for the message as well. I'm not sure what that's for or why it's necessary, but I'll take your word for it :) Similarly, that magic can be made a private static final variable on the class. And the . I'm not sure what that does either. Velocity? Let's go with Velocity. 

Added bonus: You can select new check boxes and the player will now start playing the new track without having to pause and restart the player InstrumentRow.java 

Midi class. If Midi is no longer to be sharing the MusicInfo object (since it doesn't exist anymore!), it needs to know when to update the track, and what to update it to. One option (there are probably better ways) is to expose a method such as: 

I would suggest returning instead of when element not found. It feels a little more natural and expected. 

If is empty, is set to "no" (can't read the author's mind, but my choice would be , not a string). From the naming we can assume that holds (or not) the keyword(s) of a search. Now if that is not empty: 

for brevity, readability and to not have redundant checks. is not that expensive, still no point in calling it more times than necessary. I'd advice against having HTML in your classes, as you do in . Simplest solution would be to create an array of your database results, return the array and construct the table when it's absolutely necessary - at the script you actually show it. Moving on to , is called every time is called, and that's absolutely unnecessary. Not really an expensive database call, still redundant, you can safely move it into , it's a call that only needs be done once, just after you connect. In general, avoid functions, they are essentially obsolete, kept around only for legacy reasons. Their use is discouraged in the manual: 

Back to the class, and the GUI class. Do away with . I view your UI as having rows. Each row is for an instrument, and each row has some checkboxes which represent beats. To model this, we can make : 

Just to reiterate, the view should be a very thin layer of the application. It does not have any business logic, and it should be the only place in your code where UI elements (AWT, Swing, etc. classes) reside. That is, no other classes should have ANY knowledge about what UI framework the view is using. Why? Those classes shouldn't care! (Separation of Concerns) 

Private initializers. I try to not use them if possible, but I do understand that they have a place. When code is short and simple (like this project), then I find it much easier to read if all of the UI components are setup directly in the constructor. I've found that it's easier to understand what is all happening and build a proper UI hierarchy when they're setup sequentially. A little documentation of what is being setup can go a long way as well. Plus, any variables that need to be accessed elsewhere in the class can still be final since they're initialized in the constructor. That said, in a very complex and large class it can be more readable to break apart the constructor work into some private methods. But even then I might argue that your constructor is doing too much, or that your class is responsible for too many things. 

and avoid the costly call to . And do return something, tell the user if the operation succeeded or not, regardless of what the Java interface does. 

Your code is just fine, exactly how I would do it. There isn't much to discuss really, it's kind of simple. It's as effective / efficient as it could be, and fairly readable. 

mysqli is a drop in replacement, all you need to do is add that extra i to all your functions (yes, it's that easy ;), but I'd strongly advice exploring PDO. You don't do any kind of validation on the stuff you throw at the database, your code is vulnerable to all sorts of trouble, the scariest one being SQL injection, and the simplest solution would be to use prepared statements. For example, how can you be certain is an integer when you call ? In you also have some HTML, ideally you should move it out of the class, still given the class' nature, don't make it a top priority. As is, your class isn't reusable, if you want to have a different looking pagination somewhere you'd have to change the HTML in the class (and then your first pagination would look weird ;). Read up on separation of presentation and content. Architecturally, there's a bit of a mess with , as it's declared static when it's not really static, as it depends on having been instantiated (for the database connection to be established). That's more PHP's fault than your own, the way utilizes the global namespace always made me chuckle a bit. Now, since it's not really static, there's no point in declaring it as such, just make it a normal public function and feed your object where it's needed. Read up on dependency injection and try to avoid static functions if they are not absolutely necessary. You could just pass the object as a parameter in and , and replace with . Your index file is indeed messy. Start by breaking it up into smaller files, as appropriate. And... good luck ;) Overall, your code is good for a starter, you're in a good path. If you significantly alter your code, don't forget to post another question here, there's always room for improvement, that's just the nature of code reviews (but don't over-engineer, done is better than perfect ;) 

Keep in mind these are only my suggestions. Take them as you will, and hopefully at least they will teach a bit about good design patterns! 

Again, maybe just personal preference, but I find this approach a bit easier to see how the hierarchy is being built up. 

Your MVC usage is a bit skewed. We have the GUI class (clearly the View), MusicInfo (Unnecessary model that the View uses, but is also passed to Midi?), Midi (Controller, but is also directly accessing MusicInfo which should be internal to the View), Instrument (A model) and BeatBoxConstants (More on this later...). In the MVC pattern what is supposed to happen is this: 

can be removed Instead of using a for loop and iterating with a counter, you can use the built-in iterator and iterate over . 

No need to say the method name again - the method name is automatically part of the Javadoc. What are the parameter constraints? (To be fair, you don't enforce any constraints in your code, so it makes sense to not mention any in your Javadoc) That said, you should at least have some minimal constraints on your public methods and constructors (eg. The GUI constructor takes a object - do you want to allow a consumer to pass in ?) When are your exceptions thrown? I see lots of classes which throw a , but as a consumer of your code, I would want to know what causes that exception to be thrown. Private methods. It's not wrong to add Javadoc on private methods, and some people will argue that every private method should have Javadoc. I don't necessarily agree (Feel free to come to your own conclusion on this one), and I am of the opinion that if a private method is so long that it needs documentation on what it does, you should probably clean that code.