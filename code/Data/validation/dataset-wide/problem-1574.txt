Now, having done that, why do you need the initial not-a-function-key check at all? Can't the whole thing just be a positive test? 

OK, so, what I am saying, is use the fast mechanisms where it is possible. The implementation of the based solution should be 'trivial'. Use the recommendations others have suggested (treat 2 as a special case, then only work with odd values). Now, as for your method, I still recommend you stay in space as much as you can.... By doing it this way, you will only resrt to slow BigInteger math for large input values, and, even then it will be relatively fast until you get to very large prime numbers.... By my calculations, that will probably take you a couple of days to get to (in order to first search all the prime values less than Long.MAX_VALUE). Consider the functions: 

General I believe the rest of the code supplies the required functionality. There are odd cases where, for example, on Linux you can remount a sub-directory at a different mount point. These two distinct file-systems may mirror each other, and a file/directory in one mount-point is identical to the other mount point. This may produce false-positives in your code (where your code will claim the directory is not allowed, but it actually is...). False-positives in 'edge cases' in a security situation are better than false-negatives. The intricacies of the new-in-Java-7 NIO2 Path class/interface may help with this. You could translate your instances in to instances, and then use the isSameFile(...) method... which may, or may not help (reading the documentation it is unclear, and I do not have direct experience with that). Update .... more Paths: Using the and other NIO2 features, your code could probably be reduced to: 

I can believe it when the replace is the problem... it's creating a mess of nested code that's creating a lot of intermediate string values. There's not much I can see to improve, though. The nesting can be reduced by combining a few of replaces...: 

So, that is 'can the code be improved?' and 'will sorting help' As for the 'unrolled' (no recursion) version of the system, it can be done. It would require three int[] arrays: 

I am struggling to understand your algorithm. I don't fathom why you have to go through all that work of adding digits to values when the math behind this problem is so much simpler. The smallest value will always be a digit followed by nines. The number of nines is the number of whole times 9 divides in to the value, and the first digit is the remainder. Mathematically this translates to like: 

By working backwards over the array you reduce the amount of space allocations that happen as the array grows. Here's the results of that benchmark for me: 

This is not an accurate implementation of the Reservoir Sampling algorithm. The Reservoir Algorithm creates a reservoir of size and fills it from the first items from the source data. It then iterates through the remaining source data, and selects a random value for each subsequent item in the data set. If the random value is within the limits of the Reservoir, then the item is placed in the reservoir at that point. The issue you have is in your details.... Consider a source dataset of size 4 (values a,b, c, and d), and a reservoir of size 3. There should be a 3-in-4 chance that the 4th item is sampled. Conversely, there should be a 1-in-4 chance that it is not sampled. In your code, if we applied this example, would be . You would create a reservoir of size 3, and you would fill it with the values a, b, and c. At this point, you would loop again and your would be 'd', your would be , and we would enter the 'else' clause. You then get your random number with the expression: , or, effectively . will never return the value since is an exclusive-of-the-end-range function. As a result, it will always return one of , , or . These values are all less than 3. As a consequence, your algorithm will always include the k+1 element in your reservoir. You need to change the way you generate your random number to be: Alternatively, you should increment your count before it is used to generate the random value. 

The alternatives to this sort of logic are complicated transactions that need to be managed in PHP using begin-transactions and commit-transactions. Doing that would be a 'leap' in your requirements. 

There are some basic issues here, as well as some algorithmic complexities, and then some advanced suggestions. Basic issues relate to Java code conventions, etc. Basics Use try-with-resources. You have code which may fail, and leave open files lying around to be garbage collected. Consider the following code: 

Now (the sum), is truncated back to 3 bits, and the sign bit is set, and the difference is thus . If the value is negative, we negate it back to positive (abs value). This can be done by running the 2's compliment again if the value is negative. This all sounds awfully complicated, but, the point is that, in a long, you can do 16 2-bit processes at the same time... here's the code: 

Just to point out a bug in your text processing. You convert all the operations to 'upper', but for division, you compare it to the lowercase value . This will never match. Your testing has not identified this problem, and it is a good reminder to have comprehensive tests, and to be careful with copy/paste. Finally, the repeated use of indicates that it should be stored in a variable, and reused. 

is not closed (always close IO streams when you are done with them). Many variables are not used: in there's , and in there's , , and (which are unused both places they occur - both in the 'if' side and 'else' side of the condition). The remaining variable names are not very reader-friendly... apart from for 'scanner', , and , all the other variables are single-letter: , , , , , , , , , and . Oh, there is also , , , , and . This all makes it very hard to read/understand your code. While it's a personal preference, the official Java code-style guide recommends putting the open brace on the same line as the block introduction, not on the following line. For example: is all on one line. 

Now, at that position, we know that the value will be 8 because we are human, and can see that. The best algorithm on the computer though, to get that 8, is that we can split the data we know in to 4 areas.... Consider the input data again (I have marked our spot with the parenthesis): 

Now, we have a fast way to find any data record in for a given name. Using that structure becomes easy again, by looping for each of the values, and updating them based on the value that was indexed, if any. Loop for each record, search in the index, use the default if the index value was not found. To make the code a bit more flexible, and because the "column" names change from to , it helps to have a structure containing this column mapping: 

The above splits the input in to words based on punctuation and the _ character, then it takes each non-empty word, and splits it again at CamelCase transitions. It accumulates the results in a List, and returns that. 

In other words, to be immutable, you also need to have non-overridable methods. The best, and easiest way to accomplish that is to make the class final. Apart from that, yes, your class is a decent Immutable instance. Note that the immutability depends on the fact that the list consists of String values, which are also immutable. 

Functionality I cannot find anything wrong with the algorithm. It works as advertized, but there are some places where the code is excessive, redundant, or 'artificial'. The was the worst offender. Performance Right, Performance is where I really get interested in problems... I have modified your code and run it through some benchmarks, then I have made alternate systems, and benchmarked them too. The first thing I noticed is that you are reporting the performance time of the first run. It is common knowledge that Java only starts getting 'fast' when it is 'warmed up'. You want to know what sort of difference it makes? Well, you say your code runs in (your benchmark code), but, I say it runs in . Yeah, the numbers are really small. The problem is not particularly challenging. But, I thought, "I always complain about people using autoboxing instead of primitives... surely the Streams API has primitive processing options?", and, when I looked, it does! So, I converted your code to use and other constructs, instead of . This has helped with performance. There is an example of that code. I also thought, what If I write it as I 'learn' Java8, and compare it to what I would have done in Java7. So, I now have 4 implementations of the problem: 

By suggesting that the complexity is \$O(n^2)\$ you are showing a gap in your knowledge of complexity. For a start, there is no defined in your problem... what is it? Also, if time complexity really was significant/applicable, a complexity of \$O(2^n)\$ is huge. Every time you add an input value, you double the execution time. So, for example if you currently had 4 input values, and it takes 4 seconds, then it will take 8 seconds with 5 input values, and 16 seconds with 6 input values, and, with 20 input values, it will take ..... almost a day. and 24 values will take a month, and 30 values... 8.5 years .... 

Now, in your function you would produce the ID by shifting the X, and the hash, by the modulo of the table size. Let's assume the table size is 32768 (a nice big value that should eliminate collisions, right)? 

This illustrates a potential bug in your usage.... anyone can synchronize on your class. This may, or may not be a good thing. Your get and set methods are already synchronized on the instance, so now you have multiple classes all using the same synchronization point ("monitor"). The bottom line is that Java already identifies atomic operations to be a problem, and there is a subset of the standard library dedicated to ensuring that Atomic operations are safe. In your case, use AtomicInteger 

That findAny returns an Optional, which may, or may not contain a key, but it will only ever get there if it did find a key, because the stream is infinite.... So, we can just use it as our successful find. But, what about the multi-threaded requirement? Well, that's easy, just add as the first stream step. That will use all available CPU's and run part of the stream on each. Wrap that all up in a nice function, and you get code like: 

Now, if this was my problem, I would restructure it entirely. I would have one method that loops through all the members of the input set, and checks to see whether there's an overlap at the 'end' of the String, then I would split that matching value and keep the unused prefix, and then recursively search the remaining values.... let's explain that with pseudo code: