As you can see, I'm listening to the event and updating the browser title based on the title param in defined on the respective route. Here is the RouteInterceptorService: 

Are there any improvements you think that can/should be made to this, or any corner cases that I may not be thinking of? As is, it works just fine. 

I am trying to make an efficient algorithm for removing script tags from an HTML string. Can someone point out any flaws in this? This seems to be the best I could think of. 

I wrote a little function, which takes a variable number of arguments of type and then calls each of those in order, passing in the value of the previously called function. My function works just like I want it to, however since the function provides a way to program functionally, I figured it's application should be functional as well--but it's not. The function: 

The name name is often imported is the built-in functions as an alias for the function. Using it to discard unwanted variables could result in surprising errors. 

I was about to add more things to my answer on your previous post and noticed meanwhile that your already asked a following question (that's almost too fast! :o). I have done some additional reading about C++14 and integer sequences. And I have found some things in the standard that could help to improve your code again. I realized at some point that you were using as the of . However, you initialize your with the result of and returns a , not an . Then I remembered that, along with , there is a for which is called and which has been made to solve the kind of problem that your are trying to solve. Therefore, you should every occurrence of by and of by . 

WARNING: Please see @MgSam's answer for a fatal bug in my original code. He has a revised version that fixes the bug. 

Anyone have any idea how I can make the logic inside the function more functional? I am having a hard time since I am just now learning to think in a functional way. Is it even possible? I don't know of any ways to loop an array without using or . UPDATE: Never mind, I figured it out. Didn't think I could use for this but I suppose I can: 

I have made a route interceptor service that has an API to hook into every event that the router broadcasts, and pass in , a function that will be invoked on each event and takes in the route as an argument. Also, the route that is passed in is a modified copy of the original. The difference is that any observables (such as the route data) will be accessible directly as values instead of having the need to subscribe to them. Here is the implementation of the service: 

Does it make sense in declaring 'Add' methods as and 'Remove' methods returning ? (similar to .NET collections). Does it make sense in adding other collection-specific methods like or ? 

I need to define an entity () that contains and manages two collections of identifiers ( and ) that are ids of some other entities (). The business rules are the following: 1. The collections must contain only unique identifiers. 2. The same identifier cannot belong to both and . 3. Identifiers can be added or removed (performing the checks above). Note: Adding an identifier to the is not opposite to removing it from the . For instance, there is a list A that contains included lists B and C and excluded list D. That means that . An attempt to add list C to the leads to an error while C is in the . If the list C is removed from the , the list A will be the following: . I introduced two properties to get the collections and four methods to manage them. There are few areas I'd like to hear some feedback about. Which variant is better? Property naming 

Access modifiers There are several parts of the base class that you do not need in the derived class. You could make them : 

Here, you are allocating memory for a , then you try to add it at the end of . When inserting an element in an , a new node should be allocated. Unless otherwise specified, uses to allocate new memory, which is based on and . In other words, if there is no more free memory to allocate for the new node, will throw an exception and will rethrow the exception. In , if throws, then the newly allocated () will not be freed. This is a memory leak, and so your method fails to provide the basic exception safety (also known as no-leak guarantee). If you use a smart pointer to allocate the memory, then when throws, your method won't catch the exception, but the destructors of the automatic variables of the method will be called. Therefore, the destructor of the smart pointer will be called and will be safely deallocated. 

The tests should be easy to maintain and understand. That is the tool that drives development. Sometimes it may contradict with the widely known rules you mentioned, but it does not mean we should be fanatic about that (as soon as the tests drive the development and work as the safety net). 

Also, you have to create an instance of the wrapper in the production code, haven't you? So, what is the purpose of the static class then? Static classes are inconvenient for unit testing. Instead of introducing wrappers that mimics the original class, you can simply get rid of statics at all and go with simple 'injectable' abstraction and implementation: 

The three classes above are the most simple ones in the world (ok, it may be a little bit superlative), yet they make your functions signatures easier to read and reduce the risk to pass a size to a position parameter for example. Also, you can return them while you cannot return two integers. Moreover, these classes are so small that any modern compiler should be able to inline the code and make it as fast as if you were only passing integers around. Note that I considered the classes simple enough to be s with members. I did not write any method, but methods such as on could be useful. You can also meaningfully overload some operators that will make the code using these classes easier to write and no harder to read. 

Rule 1. When I add the same identifier twice, does it may sense to throw an exception saying that the cannot be added? Is there any harm in 'doing nothing' here? Rule 2. Trying to add a list id to the included lists throws an error if it's already belongs to the excluded. Does it make sense to introduce some helping methods like or ? Does it make sense to throw an if an empty is provided? 

That's totally fine and even more - introducing 'common' initialization logic increases coupling of your unit tests. Imagine you need to add a new 'common' line to setup things common for a few tests. You never know for sure if there are any other tests impacted; you may make your tests false positive. It's more safe to modify your test 1 by 1 as necessary. Tests like have about 6-7 arrange lines and 2 assertions. IMO, it is easier to read, understand and (!) maintain this single test than splitting it into two (or more) just because of the 'one assertion per test' rule. That looks like Facade tests. That might be fine to have them at some level, but it's important to understand that tests like that may be a bit more hard to maintain since there are more parts that might be broken during refactoring. Don't have any oppinion on that... Looks fine to me. 

If you want to zero a , you can take advantage of its public data member, which is a good old C array. Then you can rely on the standard library algorithm to set every element of the matrix to ; the algorithm generally does static dispatch at compile time to call whenever possible. Using it should allow you to always be safe but also to be safe when possible: 

Even without much code filling the blanks, it seems that you want to have some associative data. In which case, you could create an with strings as keys and associating function pointers to them, generated from captureless lambdas. A small example: