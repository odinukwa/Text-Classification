3. Checking for duplicates - The algorithm itself can be improved by thinking in terms of set. I am not very familiar with Java language and I have used data structure, but the bottom idea is the following: if current element is already in the set, it is a duplicate. Else add it to the set. This solution also has the advantage that avoids hardcoding the number of allowed characters (26). 

Things that just pop up in my mind when seeing the code (more of the architecture and robustness rather than language constructs): 1) Harcoding path to ini file The path might have a meaning in your development environment, but it will mean nothing in a test or production environment. I would set it in an included file and use it from there. Something like: 

Besides great performance improvement due to 's suggestion, the code can also be improved. I have put comments to indicate changes: 

One way is to have a function that returns a table composed of two s, corresponding to each of your s: 

The function doesn't seem to be working correctly. If only one of the two fields is filled in by the user, is echoed, but is called anyways. In this case it doesn't really matter, because it will not do anything. But then your function could be simplified to: 

Generally, when creating an entry for a collection, it should be posted to the collection, not to a specific entry (the id is then determined by your application, not by the user). So it should be: 

It is customary to write instead of in loops. loop variable It is also customary to use as primary loop variable and as secondary variable in case the loop is nested inside another loop. As your j-loops in are not nested, I would use for them, and then instead of for the nested loop. Call of should generally be at the end of a function, but in this case, I would pull it up in front of the function definition. It is easier to overlook at the bottom. But the whole method seems unnecessary. Couldn't you just remove these lines: 

However, logic for the dates is unclear for me, even after reading operator precedence (AND takes precedence over OR and BETWEEN). It is strongly recommended to use parenthesis when using multiple operators with close precedence. 6) Set based logic WHILE and other looping constructs are intruders in T-SQL language. They will usually behave (much) poorer than set based approaches. So, your WHILE can be converted into something this: 

Your models project should contain only functionality related to data models such as: data models themselves, data context, repositories. Provided code does a simple thing: gets a model based on its identifier, so this can be included in a Repository. E.g: 

I would also mention a little about your naming. C# uses a CamelCase notation for most identifiers (class names, public methods etc.), so you should try to use also for your structures: 

5) Try to use mainstream frameworks such as EntityFramework to handle data fetch dirty work. Fetch would look like this: 

I will try to cover several points: 1) Naming Try to use homogeneous naming. Pascal/Camel case seem too be used most often, so stick to it. E.g. should be , should be . 2) Improve readability of your declarations Your table variables could be declared like this: 

Unit Tests and Single Responcibility It's always good to test your code. With random data, this is a bit complicated, but at least your original mistake of the same input generating different urls would have been caught by tests. Now the question becomes how to test that there will be no duplicates when randomness is involved. And the easy answer would be to remove the randomness from it. As creating random numbers shouldn't be the responsibility of this class anyways (it's already responsible for managing urls), you could create a interface (with as method) whose instance you can inject into the class (via the method). For unit tests, you can then simply create a dummy random object which returns a static value. Your test would then look something like this: 

Loading Config Data You are loading all config entries into an array, but you are only using . It would be more efficient to only load what you actually need. XSS You are not sanitizing your data with , so anyone creating frontend titles, product titles, or product descriptions will be able to execute arbitrary Javascript on the clients machines, and can thus steal cookies, log passwords, deface the website, etc. 

1. Functionality extension - besides already mentioned answers, I would extend your functionality with a back-off mechanism which can prove useful in some situations (e.g. a SQL deadlock). Since the options are quite a few now, these can be contained into a special class: 

Other aspect is the harcoded number of possible graphs. Are they so different that they must be defined one by one? Do they share common functionality? 

This is a late answer which already applies some of the previous answers suggestions. However, it will concentrate more on architectural aspects, rather than technical ones (there is a lot of dust on my C++ skills). 1) use classes - since you are working in C++, it is better to encapsulate anything in a class, that does a specific thing (Separation of Concerns). So, your main function should be very slim and delegate the actual work to an object: 

2) * usage in SQL scripts It is recommended to avoid usage in SQL scripts and provide the actual columns. If columns are added to the table and your code does not need them, their selection is useless. 3) Unhandled exceptions Your code does not handle any of the numerous exceptions that might arise from the operations (I will not go into the actual exception types, but illustrate in natural words possible problems) 

You answered your own question already. It's not easy to read, which is a very good reason not to do it this way. In addition to the readability, your code will (probably, I didn't profile it) also perform worse than the simple solution (because of the extra function call). So you have two points against this pattern. What are the advantages? Two other points: adds extra complexity. I would just write , and let the function return false. And you should assign right were you need it, inside the loop. If you consider all those points, your code might look like this: 

Usability Your function will be extremely hard to use for anyone not familiar with the actual code (and in a month or two, that will probably include you as well). They only see this: 

Your idea Your idea is nice, but it will cause problems when extending the game. For example, we will add spock and lizard: 

I don't mean the code inside the function, just the function definition and the function call. General Approach You already mentioned that this is probably not the best approach, so I'm not going to say too much about it. Generally, I would probably go with an iterative solution as most of the time they are easier to understand and faster as well. An example of an iterative approach might look like this: 

Complexity should be as all dictionary operations are done in . If your documents were copied from some other data structure to your response, I think it is better to construct the dictionary from that data structure and obtain from the merged data. Otherwise, you have to use a loop to remove documents already merged (somewhat more convoluted than version). 

What happens if your dice changes into a larger polyhedral one? Your ifs statements will not handle the value at all. So, a reasonable version is to use something like 5) Encapsulate your damage simulation in a class Since main is much slimmer now, we expect that everything is handled by a special designed class: // created new class to separate things 

I have used properties, a more generic list type (IList<>) and put a more C#ish capitalization (Pascal case). 2) Proper disposal of disposable objects implements and should also included in a using block (as its close friends and ). Also, in order to shorten things a bit, C# allows usage of to replace the actual data type: 

You can omit the if you don't like it, but I think that the really helps. Note also that I changed the second line slightly for more readability, and that I declared the variables when assigning values to them, saving a line and increasing readability. Misc 

Your alternative method of having a class is definitely not the correct approach. Your class doesn't work without a db, so if a caller doesn't call it, it will cause problems. Either pass the db object in the constructor, or pass it on to the various methods. 

Data Handling & Security You use prepared statements, which protects you from SQL injection, which is good. However, the way you handle passwords could be improved to increase security. It's not a good idea to semi-randomly apply sanitation functions to user input as it results in dirty data. for example really only makes sense when magic quotes is enabled, so you should check that first (and then only strip the slashes in some init file, not every time you access GET). For example, if a user has a password like this: , stripping slashes reduces the password length from 9 to 6 characters. Same problem with , only much worse. If my password is , now my password is . You also don't need . As XSS protection it's not sufficient anyways (and definitely not needed for passwords, which aren't echoed); You should HTML-encode data when echoing it instead. There's also really no need to have a length restriction on the password, especially not one that is shorter than what your hashing algorithm allows. Hashing Simple sha is really not good enough anymore, as it's too fast. Use bcrypt instead. Error Handling Don't echo database error messages directly to the enduser. They won't know what to do with it, and it may provide attackers with information or enable some forms of attacks (such as error based SQL injection). It's also not a good idea to echo anything in a function, as side-effects like that make it harder to reuse. Structure I think your structure is pretty clean, and your code easy to read. Just a couple of small points: doesn't seem to have any purpose. I wouldn't call the constructor inside a function of the same class, but just use it directly. I would also not pass a magic array to the constructor, as it's hard to use and reuse (I have to guess how the array must be build and what it must contain, and I have to use the pre-defined array keys). Instead, just change your constructor to . This increases clarity and reduces future bugs. Misc 

2) Error handling function does not handle any incorrect formatting. Any line which is not in the format name=value will not be imported correctly. You can explode into an and check if elements are defined and exactly two. 3) A more powerful config reader This is a good exercise, but ini files have a more complex format that seems to be handled by parse_ini_file function. 

This solution should be easier to understand, but uses extra memory for the result. This can be overcome, by reusing the same documents: 

Part of my job is to maintain an old application written in Silverlight talking to a WCF service which in turn fetch/persist data into a SQL Server database and in a BI cube. Most of the security is specified at database level using database roles, users are authenticated using Windows Authentication (integrated security) and no user can access table data directly, only through stored procedures. For persistence user defined table types are used (as input parameters of procedures). As most of the code performs data table construction and reads data quite messy, I thought of developing a small framework to work more object oriented. In order to standardize how data is fetched and persisted, I have created some helper classes and attributes. The vast majority of fetched or persisted data does not go beyond hundreds of rows, so performance is almost never an issue. Also, data can be fetched from both SQL Server and Analysis Server (via ADOMD.NET) Ok, enough talk. Let's see the code: 1) Base class for all data contracts used to fetch data and sent to the WCF client