Perhaps I'm missing something, but is there a reason you aren't converting to first with any of a set of functions, then formatting the output in a separate set of functions? e.g.: 

just screams "I am extracting a single bit from the number and printing it!" to me, whereas with and , it seems like you might be calculating something at first glance. And, if you really like brevity: 

I am begging you to reconsider. If your students ever work with real world programmers, they won't be able to read each other's code. If you want them to learn OO, teach it in an OO language. Really, if they aren't ready for the idea of a prototype the way JS supports it already, they probably aren't ready for JS. 

This looks perfectly good to me. Everything has a unique purpose, everything is either clearly explained or self-explanatory. Unless you have tested this and found a performance issue, and you are sure that it is happening here, do not do any optimization to this. There is no loop and no recursion, the code itself can't properly be an optimization target. If you are observing that this is running slowly, the hidden costs of setting the scrollbars must be the cause. To address this you will need to change your entire strategy to keeping the contents in the right place using CSS only. I have to say that while I find using the position of some element (?) to be a pretty elegant way to duck issues of messing around with coordinates that will be inconsistent otherwise, it is technically the best practice to do all positioning with CSS. 

If you don't really need to constrain your declaration to one block, stick with and . You can still stick it in a hash or factory class if you like. That's the idiom that everyone understands, and it will do the same thing. If you don't really need to look up classes by name, use function scopes (again, look up module pattern) to manage your namespace instead of a hash. If you don't really need to be writing JS... well, it seems like you'd really rather be writing Ruby or Python. Those languages have classes. JS doesn't. It has prototypes and constructors and function scope. 

Assuming the constraints are that you must have classes defined in a single block, you must be able to create objects by providing a string instead of a reference to the constructor, and you must use JavaScript: 

will get the job done. Not particularly clean, though. Other than that, the particulars of the conversions are good. Stuff like constants for strike a good balance between efficiency and readability. 

I don't use underscore, so I am more or less naive about what you're meaning to accomplish and how it might look otherwise. Instead, from a consumer perspective, I am comparing/contrasting this utility with not having it only. I am assuming "all aspects" includes code quality from the perspective of maintaining, reading, or extending the code as well, and I'll start there. Reading this is made somewhat more challenging due to the similar-looking and . I believe this has been mentioned by another reviewer, but I would like to offer some workarounds. I assume that you do need an object for - if you don't, you should follow a previous reviewer's advice and be rid of it - to loop over its keys or use it as a prototype or dump it on the console at some point. It's okay to provide an abbreviated global name to consumers ( for your library), but it doesn't pay to do it in your own scope. Even and are more easily distinguishable, immediately clear in their purpose, and if you count the shift key, it only costs you one keystroke per typed pair. Speaking of saving and losing keystrokes, actually requires fewer keystrokes than . The same goes for , , , and . I've seen some other libraries do stuff like that, so you're not alone in this, but I've never found a use for any of it. That goes double, though, for and . I can't imagine wanting to spell that out. Just curious - why is there an explicit spell-it-out test function for everything but ? I guess if I was trying to maintain code written by real neanderthals that I didn't trust at all, it would be reassuring to see what they were intending to test explicitly in every conditional. In any case, it's more bondage & discipline than utility, and you can tell by how little use you get out of these functions throughout the rest of the code. There are lots of opportunities to use those functions. There are many cases where the body of those functions as well as and appear repeated verbatim, with precisely the same intent. Normally, I would say it's overkill to call repeated simple boolean expressions a failure to DRY, but that's the point of your library, right? You wrote those functions because they're useful code, so use them. The function returns false for boxed numbers. If there's a reason for that, you should probably add a comment about it and document it somewhere, or someone might assume that if then , since if then . I would rather see in instead of using native for-in and filtering with . It takes up less vertical space, restricts the scope of to the block that should be using it, and does the very same thing. I can read what you have, and it works, though. Just a matter of preference. If I understand it correctly, the difference between and your is that the iteration of can be ceased from within the callback by returning truth-y. I would then expect, when I read code that uses and not , that you are scanning an array to find something and intend to stop at some point. However, you go on to use the functions in and where the intent of the loop is to iterate over all keys or array elements. It does show that you have a useful function, but it also reads a little hack-y. Each time I read it, I spend a second or two looking for a to determine what you're looking for, only to realize that you just aren't using . I can't really comment on all the suffixes and underscores because, if they belong in the utility at all, they're tools specific to the rest of the project. Seeing , tokenizing, and meaningful underscores with no regex or grammar in sight makes me a little nervous (long story, code-based parsers are bad) but I have no idea what you're really using it for. 

No, this is not efficient, if indeed it can be made to work. The operation has a loop that can iterate over N - 1 elements of an N deep stack. Typically both push and pop are expected to be constant time, as they are in the standard implementation. An additional disadvantage to this implementation is that it can only hold .