You are storing pointers to local (stack based) objects, which is correct in this example because the vector is in that same scope. But usually you will never do that in real code. More realistic code would be to write 

Your operators are assuming that the arguments are in Cartesian representation. It will get the wrong results if in polar. 

The is two copies of the same block inside the loop. After making a single function rather than and , can you see how to make one loop that alternates players on each iteration? 

The main problem with your code is repetition. The idea of using a variable for each rotor and hooking them up in order by assigning to them is a sound idea (though they should be instances rather than functions). I call this out because it is a place where you did think abstractly, using variables to refer to different things at different times; the rest of your code is characterized by repetition rather than applying different data to a common piece of code. Repetition: I see 

It seems to me that the function should be generated from the BinaryOp. So that makes it the same in all your specializations, and the only thing you need is the matching . I think you should have a fully generic template that figures out and from the template arguments, and looks up the proper unit value for that operation using a smaller specialized metafunction. 

Don’t write explicit tests against . Don’t have naked /. Your list doesn’t do anything except . It should have some general purpose means of accessing the values, traversing the list. And then can be written using that public API. 

and the type of thing you are constructing in the statement is automatically taken from the return type of the function. 

You might get faster code if you declared , and whatever else you can as . It’s odd that and are written in totally different styles when they work in the identical manner. 

more speed You can find videos of Stroustrup explaining why is so slow※. See Why you shouldn't use set (and what you should use instead) by Matt Austern. Use Boost.Container for flat_(multi)map which is a mature implementation based on Matt’s article, via Andrei Alexandrescu. As a drop-in replacement, see what that does for your speed! 

A lot of this is duplicated from so the same comments apply. You forgot the handle the case where the list was empty, so will be left as null. Other than that, just how is this any different than ? 

But really, look at the comment on the header's declaration! You should be passing an enum for this, not making the user figure out the mapping just so you can reverse it. 

Don’t use macro in C++. Don’t compare pointers (or pointer-like objects) against explicitly; rather, use their truth value (an operator bool in smart pointer types) 

or something like that, modulo typos. Then, instead of having the indirection in the code where you want to find something, hide that in a smart find function. You are exposing the conditional mechanism to the caller and at the same time limiting it to just this pair of functions. That is, write two versions of your own as a non-member, and they forward to the member or the as determined. (Or if in C++17, one function with in the body.) Then you are doing what you hope the standard library vendor had already done for you: provide optimal special implementations for specific containers. Only it works for your own collections now, presuming the existence of a member means the right thing. 

The style in C++ is to put the or with the type, not the identifier. This is called out specifically near the beginning of Stroustrup’s first book, and is an intentional difference from C style. You seem to be exploring different styles in this code; I see three different ways. 

If you did need an object, there is no need to allocate it on the heap. Unlike certain other languages that came later, C++ lets you declare variables as values which are allocated on the stack frame of the function. So just 

Don’t use for normal member access. In this function, you could just write . See CPPreference — you mentioned needing to get to know the libraries better; this is a good resource to keep at hand. 

(though I don’t see why you don’t just modulo 360 after adding) But better for here and other uses in general would be to get rid of three separately named variables for x, y, and z and use an array of 3 values so they can be indexed by a loop. 

Work it over with new language features, libraries, and style in mind. (I’m doing something similar.) We have C++17 now, and your code was written for C++11. I’m sure your skill has grown since then too, so the code shown above is obsolete. You might want to use that problem again, digging into structured binding, constexpr, and other new goodies. Please post your latest code in a new Question if you do so! 

Your values in the chat message are free to set and get; they behave as a simple struct. So hiding them and having get/set for each one is not useful. If you have boilerplate get/set for every data member that do nothing other than return and assign, you are missing the point. In this case, you could have a content sanity check done before the serialization, if you wanted to check the values for legality. 

Don't use for constants or “functions” (⧺ES.31) I see this is only used in one place, in , so why do you even need a name for it? You can have the array automatically determine the size based on the initializer: 

It doesn’t return the tuple of results though, but rather just returns the function object. So you would instead of -int the results. Incomputable: In your version, can you use return type deduction and avoid the horrendous meta-computation for the return type? Let do the argument deduction on the results and figure it out. 

The is OK, but you are not doing that consistently. The constructor with the same kind of argument does not have . 

It is not normal to have a return here. You should . Edit: OK, that’s not a copy assignment operator at all. is fine. But the automatically-generated copy assignment code will not work right, as described next for the copy constructor. 

Do you really want to copy the entire multimap? It might be fine to return a constant reference; that is common enough that users will not be surprised by the lifetime dependency. How is this “three ways” ? 

that’s it! A higher function does the file reading and writing, and a lower function does the rotate logic. As for the file reading, you are doing the exception thing again: throwing 299 and catching it again in the same function, where there was no need for non-local flow control in the first place. For the rotate, we want to add the shift but wrap around. If you start with zero, that is a simple modulo operation. So, subtract the starting letter to get a number from 0 through 25 inclusive. 

Not taking advantage of class template argument deduction? This is a case where I really want it. (If not, use an alias for the lock type so it can be easily changed.) 

No, never do that. This destroys the object, and subsequent use of it is undefined behavior. What you can do is have the destructor and the assignment operator both call a common helper function for tearing down the object. The rest of it looks the same as the copy constructor. So again, make a common helper. 

Function is another example of repeated code. You can see that the win/lose messages and return values are stated three times, with a pair of nearly identical checks in each repetition. Instead, call a separate function that just returns a code indicating the winner (or lack of) and then print the message based on the result. And only have one copy of the print code, using the variable to state which player it was. The actual checking can be done more algorithmically, not expanded out into individual tests like that. I see you did manage to not repeat the checking for X and O, but test for a row/col/diag of the same mark. That is better than most of the other code here. 

But... this is meant to be used internally when creating nodes to values. You know where it is being called and how. So use an rvalue reference to avoid copying it here. Likewise, the should take by value and “sink” it deeper in its own call to construct the node. If done right, the parameter you pass is only copied once, directly into the newly-allocated node, with intermediate locations being completely elided. Considering the inherent slowness of linked lists, thus they are only used in a few special cases including when is large and/or expensive to copy. So make your implementation handle that specific case especially well! Allow insertion to construct directly in the final node location. 

The memcpy/memset use of makes me want to look closer at that. Could it be done in a properly typed manner? And since it’s a , you could use instead of memset. 

You can get a hint from my comments above. Consider: you can chop up the source into individual “words” only, but when you feed this to the next stage the only thing it saves you is not having to skip white space and mess with comments getting in the middle of grammatical productions. If the tokens have a rough type, like number, identifier, punctuation; it saves the parser some work. The parser grammar uses these, so starting with that dovetails nicely. If the tokens have a type and a value, it can save the next stage from having to figure that out. But someone has to figure it out, and if you do it in the lexer you’re guessing at what the parser will find useful. If you need to figure out something to do the lexical analysis, then preserve that information and pass it along. If you write the lexer and parser grammars together, the lexer is just the bottom end of the whole grammar and it is clear what you need, because you are choosing which terminals to handle (or partially handle) in the lexing step. Why two phases? Well, the designer or Perl 6 patterns say “why indeed?”. The tutorial and overview of Boost.Spirit goes into it, and lets you use a separate lexer or not. One good reason is to get rid of comments. Eating whitespace after each nonterminal in a monolithic parser isn’t that bad, but consider comments and backslash continuation lines and other stuff that lives in the text, that makes it hard to deal with that mixed in with the parser grammar. Other reasons historically are memory usage and machine capacity; that matters less today. And there is the adage that “If you put a team of three people onto a compiler-writing project, you’ll get a three-pass compiler.” 

You also duplicate the entire code for each case when they are identical. Now this is weird and I don’t follow: you read into with no qualification or receiver on that name. But you then use the value from which is a different variable. OK, here is the only call to it: 

You can also make the clauses of the condition more readable by making the names short: For example, see that I used the same instance to get rather than its class name. 

Be sure you use the real name of the struct, not the all-caps typedef, when you derive from it. I assume is a C function, so I kept it as-is. In C++, you do not use the macro. Given that the work is done automatically, you can then (just) report an error as part of your set-up. 

for , you are also using legacy loops and manual implementation of the work. Know your std algorithms. That’s a specific case of know your libraries, which is a very important thing. As before, I’ll use Boost’s version instead of std. 

Write a function in your program that has a readable name for what it does. Use to implement it as the special builtin on GCC; an equivalent intrinsic on MSVC, or portable code (just a comment and #error if you have no need for the portable version). (I think or .) Division (and modulo) are very expensive operations in the CPU. If you could structure your test to use multiplication instead of division, or work with the powers rather than the total number, it will be better. 

Second, the code you wrote is highly repetitive. When you have a whole bunch of duplicated blocks like that where only a couple values are changing, pull those values out into a data structure and then loop over it. Without a lot of fuss, I just used a primitive array of pairs. 

⧺C.149 — no naked or . I also think that allocating nodes as part of is why it is slow! That is inherently a slow operation. You might time the function separately and compare that to the time, and see what percentage it accounts for.