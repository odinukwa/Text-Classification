Note: If you try PrimesBySieveAndLinq.GetPrimes(int.MaxValue) it is very slow at the beginning, but speeds up after some 1000 of primes. 

Xiaoy312 has a point about the risk of missing seconds when using . It seems that each "tick" of waits until the previous returns. So if the OnNext halts the thread a while, the next "tick" is fired too late and you may miss a second or two. Trying to start each scheduled task on a new thread - for instance via a seems to be a bad idea, since the same Cron job probably can not run concurrently(?). One way not to lose any seconds using is as follows: 

Zeta gives a thorough answer; I'll just add the following. The operateCaesar function could be written as: 

I find your code clear enough, but you could improve it a little bit, so you only do the add operation once: 

3) For the fun of it, you could consider: Because you basically do the same same loop nested three times, it could be a candidate for a recursive function iterating over each addend and yielding all the positive sums. In that way you could generalize the algorithm to handle any number of addends... 

If their role is more advanced than that with methods and state, it IMO calls for at class hierarchy in some way like: 

I like your idea, but instead of ending the sequence of KeysToValue() calls with a call to ToDictionary(), I would make an Add-extension to IDictionary like below. You then only need one extension, and it is more flexible: 

I largely agree with JanDotNet. I'm not sure if it's a good idea, but maybe should clean up after it self as a IDisposable? 

Naming: is not an index, but the actual value in the valid sequence (from min to max). I would call it or or something like that. I don't like the name either, because the target is actually the sequence of numbers from to . would be better IMO. 

As I'm new to scala, I don't feel I could generate the appropriate code, but I wanted to make a couple points. First, your method is doing way to much. I see validation, I see messing with a request object, I see sending the SMS, I see response generation. From my point of view, when looking at this method, you can't tell what is going on without a lot of effort. So my recommendation would be to add more methods. If I were writing this, I would have an outer method that abstracts away the HTTP portions of your code should pull the string value from the request and then delegate to (or something like that) to perform the logic of validating the string. My second suggestion with this method is that it not return a string, but a type safe object. Now that you have a type safe smsPhoneNumber, you could write another method that does the status checks: is the number blocked?, ... Now that we know everything is good, create a method that takes the smsPhoneNumber and actually sends it. The last bit I would emphasis is that the JSON response generation should happen within . The other methods will return values types or throw exceptions so signal when bad things happen. Keep all of you HTTP related code isolated to . Update: Below is my take at trying to break your code apart. It is completely untested and there is almost certainly no way that it compiles, but I think it does a reasonable job of demonstrating how you could break things down. So, just think of it as pseudo code that looks similar to scala, but not actually scala. First, note that I convert things from strings to a type safe type as soon as I possibly can with and . Note that they return an option instead of the actual types. You probably could throw exceptions as well, but I preferred this. The next thing I did was create a bunch of case classes. This is to abstract out the status of situations from happening. There could be a different way to do it, but I liked using case classes because they seem to work with within es. Next I isolate all of the sending of the sms to withing ; notice how the exceptions stay within this method. There really isn't any benefit of having the API specific exceptions spill out. If you ever need to change service used to send SMS, then you would only need to modify this one method. Lastly, notice how all of the HTTP related objects (request and response) are isolated to within . Perhaps you want to do a similar process but without being attached to a request (such as a timed job), with the HTTP information isolated, then this is nearly trivial. I agree that my pseudo code below still needs more work (i don't like the if/else plus two matches in , I feel it should be "flatter"), but this is the best I can do right now. Hopefully, some of my points make more sense with some pseudo code. Completely Un-Tested/UnCompiled Code 

Beside that, I think your naming is quite remarkable and rather hard to read because of the length: For instance it's hard to quickly distinguish between: 

I'm not sure if the objective was insertion sort or tail recusion? In any case the performance is rather bad for larger data sets. If insertion sort was the focus the following approach is maybe somewhat more straightforward: 

The calls to CheckForDuplicate(...) seems to be on the same level of concern so maybe make a combined handler for that: 

because you do not filter anything out, so the isn't necessary. I wouldn't feed with a file path but with the actual input data and load the file elsewhere, making it more flexible. Because you know the total number in advance you could actually do everything in one single Seq.fold call on the input string without recursion - but maybe your focus was on recursion rather than anything else? A detail: when I run your code on the names string I get ? 

It is IMO easier to understand because the index is incremented in a more "natural" place, and the Write...() functions knows where they are. If you insists on _index as a class field, you could do it like this: 

Although your efforts show a good understanding of details of functional programming, I think you make it all too complicated. The overall task is to map a list of integers to either the integer itself or a text in respect to one or more predicates. That can be done like this: 

Make resources: as show above the ForegroundBrush and BackgroundBrush are created as resources and referenced in the Button Style - and you can reference them inline on other controls as well. It makes it easy to maintain if you later want another color. Fixed Sizes: Be cautious about fixed size Windows. Your Display Window is defined with . A better solution would be to make your content sizable, which gives the user a possibility to resize the window to his/hers needs and a better experience. 

Without going into implementation details, I would suggest looking into the following performance optimisations. 

I think this make the different logic parts separate and you will get cleaner code, where it's going to be easy to add a new transformer, while still paying some attention to performance. 

So now you have divided you elements into specific entities like Quotation, Customer and Events. Adding more details to a Customer or adding a new Event type, don't require change to the Quotation class, but only changes to the specific entity. On the side, you might also find it beneficial to look into a simple visitor pattern for the events and provide algorithms to etc. calculate total price, date collisions, number of participants etc. etc. Enjoy. 

Creating the DocXTransformer will load the file. Calling Transform, will execute a list of Transformer classes, which each implement the ITransform interface. 

I would normally suggest consistent usage. In the example you provide, you use both constructor parameters as well as property initialisation. Depending on you options to change etc. the SubjectDto I would add another construction parameter to it and pass in a hasBeenAdded variable. When talking about improving the LINQ query, I think readability and maintainability has highest priority. Often performance optimisations degrade readability and enforces you to write some additional comments. 

Depending on number of nodes in your tree, recursive post-order traversal of the tree, might let you run into problems on the stack. If the number of nodes is huge, you might need to consider a non-recursive post-order traversal. Have a look at $URL$ which describes multiple solutions, both iterative and non-recursive. On think to keep in mind is that the non-recursive algorithms use more memory, as it need to push nodes to a stack. You might also consider doing a post-order tree traversal enumerator, but that might be for another day. 

The Sprite class and inheritance Since Money, Item, Monster etc. all are subclasses of Sprite, I would only have one set of objects containing all sprites: 

In general it looks OK to me, but you could maybe consider the following: 1) Return a instead of and then yield the positive results when found: 

It looks alright to me, although it seems odd having a young man of age 20 to equal an "elderly" man of age 30 :-). I have 3 minor things: 1) One MemoryStream can be used to serialize all expressions: 

As I see it, your code works fine as it is. You could though improve it a little bit by appending each priceTypeId in one appendFormat operation as in: 

In this way the first permutation is returned as soon as it has been computed and everything is running more smoothly. 

In the way you show that you create each Skill instance, you really have anything than the Description to distinguish them from each other. I read your Skill class as merely an advanced flag that defines a small set of properties. In the below I further anticipate, that each skill type doesn't change throughout the game. If that is correct, then I would make the Skill class as a "singleton" per Skill type (onehanded, twohanded etc.) and let a static Factory method create/return the right Skill according to a Skill Type enum: 

then it would not be found as a change. If you're going to use the class with lists of reference types you need to track the state of each item between calls to - which could be a hash or something like that. 

Instead I would make sure always returns something enumerable. And since it is always returning the same kind of objects, I would make it returning a defined class instead of the use of dynamic. I don't understand why you don't use the fact that it's all about Exceptions. Instead of collecting the subtree of Exceptions you could do it recursively avoiding the use of :