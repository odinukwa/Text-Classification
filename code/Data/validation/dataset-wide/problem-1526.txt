You would need a class or function to first parse each item individually, and then use the id fields to create all the links between nodes. Common ways to store configuration data like this are JSON (mainly) or XML. You could also choose a hybrid of these approaches. Perhaps a class you could use in the REPL to dynamically construct a part of the map, then it saves it to your configuration file when you're done. 

This is a little better. But then after we have our a and b, there is only one possible value for c to satisfy , so you don't even need that last nested loop. 

I got frustrated with C++ not being Python, so I put together a .ini file reader for myself. The last C++ code I posted, the feedback was that it's better to use free functions that private static methods when possible, so I tried to apply that here. I also tried to follow the single layer of abstraction principle as dogmatically as possible to see what would happen. A questionable decision I made was to have, for example, assume that has already been called. I'm starting to think that was a mistake, and that I should have just done 

First, some style nitpicks: Throughout, it would be better to have more descriptive, spelled out, camelCased variable names. As a reader, is so much easier to understand than . Class names should be capitalized ( -> ). It's also not great to have a local variable the same name as your class. I'm surprised that didn't give you a warning. Since will always evaluate to , you can simplify to ). My knowledge of Java is not great, so this next part will be largely a vague suggestion, but it should be clear what I'm trying to say. You have a lot of repeated code, which is a flag for refactoring. In particular, you could have a class, with and as subclasses. Then you could have an abstract method that they override. The location could be passed in as a parameter. This follows the DRY Principle. At the very end, you're setting to false, and then checking if they're false... I'm not sure I understand what purpose the flags serve at all. Are they needed? On a higher-level, this probably wouldn't be great if you need to add Kelvin or Rankine units. I'm not going to try to give UX advice, but if that's something you want to worry about, there are plenty of online samples to look at for inspiration. 

Because parameters are used to supply data to functions, it doesn't make sense to pass in a value, then immediately re-assign it before use. Parameters: I would pass the strings by const reference instead of by value. Naming: No need for at the end of every function. It's obvious that it's a function from how it's used. The names could also be slightly more descriptive: , , for example. Commenting: Generally, I'd discourage line-by-line comments explaining what each line of code is doing. It's usually a sign you need to write clearer code. The way you use it in your function to document your testing has some merit, I think. Look into unit testing for a more scalable/professional way of doing the same thing. If accidentally using the same input for testing is a concern, I'd just use a different variable completely. A unit testing library would provide better tools to handle this. While I believe this fulfils the question literally, there is an implied task of reacting reasonably to invalid input. I would test more thoroughly and make sure the edges don't do anything surprising. 

I'm not sure what Sukha is supposed to do, but I'm finding it odd. I think what you meant to do was raise the HP, then reset it if it's higher than the max? It looks like whenever health changes, it's a multiple of the . I'd suggest having that in a new function such as: 

This feels like the sort of thing where you can find a clever algorithm to make it super-efficient. That's not my strength, so I'm just going to point out some simple things you can do to make things faster. First, I'm going to rewrite it without a list-comprehension to make it easier to think about: 

Correctness: There are some cases that aren't handled. What happens if the user enters a word instead of a number? What if the user enters ? The program will exit regardless of what character the user enters when is called. I think your overload was a clever solution to a vague instruction. To make it clear that the extra parameter is irrelevant, you could comment out the name. For example: 

It looks like there are several fields getting initialized to the same thing. I would have a base class that the other three inherit from. The base class would set default stats and define the method. I had trouble figuring out why each character had an empty variable. I'd recommend a comment. Actually, there's probably a better design for that, but I can't think of it atm. I don't find the "Preallocation" comments useful. You might have a bug in the character variables. Base HP etc don't have self, so that makes them static variables. I think odd things will happen if you have, for example, two Tricksters fight each other. You can cut down on code re-use in by having a function that can tell whether the character is human or computer and doing the right thing from there. 

I don't know Java well, so I'll just be writing about more general ideas. Zero One Infinity Rule: This is a guideline which says: "Allow none of foo, one of foo, or any number of foo." This applies in your method. When you have a lot of variables like , , etc. you're giving yourself a lot more opportunity to make a typo, and there's more code you have to change if you want the top 10 instead of the top 5. Instead, store these in an array (or , or whatever the most appropriate container is) Bug: I'm not convinced is correct. I'm unsure of the ethics or the CodeReview policy on describing bugs for homework assignments, so I will be cautious and say nothing more at this time. Performance: Look at 

If the intent is to keep going with an empty word list if there is no file, this needs to be more explicit. A comment would help clarify. Or better, an explicit check to see if the file exists. (I am unsure how using exceptions as control-flow is considered in the Java world. It is usually frowned upon). If this is not the intent, the error needs to be handled. Naming: I found your variable names to be mostly clear. It confused me that wrote output though. would be much more clear. In general, it is recommended for methods to be verbs and classes and objects to be nouns. Some of your names are vague. I had to keep checking which file was supposed to be read. It is surprising that not only returns the word count, but loads the dictionary too. You could be more clear my having functions like , and . 

And that inner comparison happens times. You have some constraints in your check that you can get rid of by setting things up a little more carefully. 

so feedback in those areas would be nice. Also, because I do not get much chance to explore past C++98, if you see any places where modern language features would help, I would love to hear about it. Handling whitespace is deliberately ommitted. ConfigParser.h 

A couple quick things to make maintenance easier: It's easier to work out where you're going if you use instead of the goto. If you do keep the goto, I'd at least edit the comment to refer to the beginning of the while loop instead of a specific line number. That will change if you have to change something, and you don't want to have to remember to update the comment. In terms of readability, when checking for order of operations, you could do something like 

Being more familiar with appropriate data structures is going to help a lot here. I will suggest a better map structure that will make things less confusing at the end. First I want to suggest an intermediate cleanup which will let me think and talk about things more easily. Room class: You have class for , , etc. It will help a lot to make a class to contain an element of the map. I'm going to call it . Maybe there's a term more appropriate for your game. Then your initialization could look something like this. (I'm leaving out the field for now. Hang on.) 

Turning it into a graph: Now we have a nicer way to link rooms. Without going into too much detail, a graph is a common way to represent specific connections between objects. I'm sure there's a cool graph library we could use, but this should be all we need to get us going: 

( is an Enum, by the way) Now you can go straight to the connected room without worrying about indexing But now what about all the local variables? This still isn't great. You're probably going to have a lot of local variables lying around, and this is mixing data and code pretty heavily. A cleaner solution would be to store the map in a .txt file. It might look something like this: