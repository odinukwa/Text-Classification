The second solution can not perform range scans. It is great for selecting a single ID. But what if you want ids 3 through 8? It has to grab all the records individual which in the real world isn't just O(1) * 6 records to retrieve. In a large, production database with a HashMap index you would get records on different pages, requiring you to hit the disk and read six different pages into memory. In a B-Tree structure, like how your first situation would actually be implemented, the ids would be sequential on disk and a single page would likely hold ids 3 - 8 increasing the speed of range scans will making individual access O(log n). 

If you have foreign keys to this table, add the option ON DELETE CASCADE. Then when you delete a row in a parent table all the rows in the child tables that refference that row will be deleted as well. 

Does it exist in nonSQL dbs? Yes. Taking a quick look at the create index documentation for postgressql I see it supports both Hash and B-Tree indexes as well as a few others. 

I don't have a huge experience in lots of different databases. I know Sql Server uses B-Trees mostly, but SQl 2014 has some new Hash Indexes you can use on certain table. I hear a lot of No Sql databases and caching databases built on retrieving individual records use hash indexes as well. This makes sense for caches since you want the record for user A Page 11 and don't need range scans. 

I did the upgrade on my laptop with SQL Server 2008 R2 and SQL Server 2012 already installed. The issue I had was that SSCM actually disappeared from the Start Menu, if after repair it would not put them back. I ended up finding them under the Windows root directory, but have since done a complete reinstall of Windows 10 on my laptop, and reinstalled SQL Server. I would expect you are looking at a similar situation that is going to require a reload of Windows 10. You might try just doing the , where it does not completely remove everything...but I doubt that is going to work. I did a factory reset where I went back to Windows 8.1, then forced an upgrade to Windows 10. Which I might add, doing that seemed to have improved Windows 10 at least on my laptop (Lenovo Y 40-80) compared to running it after the upgrade. One last chance you might attempt is to install the SSMS preview (standalone of SSMS) from here. 

This is just an opinion but could be a consensus... Based on search this is actually a EMC product. However it also states in the guide that it uses VDI devices to backup and restore. I, and others probably, would advise against doing this with production databases. Again this is just a preference for me to stick with native backups. Now since you are getting service through a provider it could be there prerogative to force the service to be used. So I would try to be as professional as you can about it. 

Which one is more popular in current database implementations? Maybe different dbs use different approaches? 

What are the adventages and disadventages of both solutions? The second solution can not perform range scans. It is great for selecting a single ID. But what if you want ids 3 through 8? It has to grab all the records individual which in the real world isn't just O(1) * 6 records to retrieve. In a large, production database with a HashMap index you would get records on different pages, requiring you to hit the disk and read six different pages into memory. In a B-Tree structure, like how your first situation would actually be implemented, the ids would be sequential on disk and a single page would likely hold ids 3 - 8 increasing the speed of range scans will making individual access O(log n). Which one is more popular in current database implementations? Maybe different dbs use different approaches? I don't have a huge experience in lots of different databases. I know Sql Server uses B-Trees mostly, but SQl 2014 has some new Hash Indexes you can use on certain table. I hear a lot of No Sql databases and caching databases built on retrieving individual records use hash indexes as well. This makes sense for caches since you want the record for user A Page 11 and don't need range scans. Does it exist in nonSQL dbs? Yes. Taking a quick look at the create index documentation for postgressql I see it supports both Hash and B-Tree indexes as well as a few others. 

If overlaps are only partial, (i.e., a range may partially overlap another, but no range is a subset of another range), I think the following query will do what you want: 

Since MySQL 5.6, MySQL may automatically convert IN-subqueries into a JOIN query. This is called semi-join transformation. By converting the subquery to a join, the MySQL optimizer may be able to process the tables in a different order than for traditional subquery execution. For your query, the amount of data that need to be accessed, will be much less if the tables of the subquery is processed first. However, as described in the manual, semi-join transformation will not be done if subquery contains UNION. In your case, it seems straight-forward to avoid the union so that semi-join transformation can be done. AFAICT, this query should be equivalent to yours: 

I do not think it will be worthwhile to change the type. You may save a byte or two for the length field of each column value if using TEXT or MEDIUMTEXT, but that will be insignificant compared to the size of your data. VARCHAR and TEXT columns are handled the same way in InnoDB, so there is no reason to switch to VARCHAR either. 

It is difficult to say why MySQL Optimizer is choosing a different join order for 5.7 without seeing the optimizer trace for the query. However, you can force the same join order as 5.5 by using STRAIGHT_JOIN instead of INNER JOIN. That will tell MySQL to process the tables in the order they are listed. 

I tend to lean toward using SQLPS if I can. It is simpler and if I use it in scripts is much easier to read and less typing than trying to use SMO. SMO does it have its place in that it has a good bit of power, but can be confusing at times to use if you are unfamiliar with it. I think as SQL Server versions are released the SQLPS will be improved upon. Especially since with SQL Server 2012 SQLPS is not modular instead of being a snapin. This is going to allow Microsoft to push out fixes or improvements with SQLPS through service packs or hotfixes, maybe even CUs. Then there are also the community offerings like SQLPSX, which has alot of that SMO code already prepared for you as cmdlets and functions. Which I am all about not re-inventing the wheel :) 

In the sense, that script creates one backup and you are overwriting it each time it is executed....then you can most definitely just throw it into one step of a single job to run on your schedule. Just understand that you only have one full backup for each database, if you have requirement to go back in history to restore you cannot do it. One tweak you can make to that script to get additional backups for each day is just throw in a date value. A little bit more robust solution is offered by Ola's SQL Server Backup scripts that handles gracefully when databases are dropped and created. Just setting the parameter will handle this for you, along with the other required parameters of course.