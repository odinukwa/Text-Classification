There is a way you can distinguish the human during login process and although have all 5 humans use the same "root" account. Of course the PAM module has its limits at this point. But you should take a look at privacyIDEA. This project of mine lets you manage any kind of tokens (also TOTP, HOTP Google Authenticator, Hardware token, yubikey...) and assign these tokens to users. Now there are two possibilities: A) You may assign several tokens to the user root. And you know which token was handed to which human. On the server you install a privacyidea pam module, which authenticates against the privacyidea server. privacyidea determines which token was used to authenticate as user root and logs this in the digitally signed audit log. Thus you can deduce, which human logged in. B) Every human has its own user account in privacyidea. You assign a token to each user account and hand over this token to the human. Now you can assign "remote" tokens to the root user. Thus the user root gets some kind of virtual tokens which link to the real tokens of the human users. When a user "root" authenticates you get the information about the virtual/remote token and the realm user's token in the audit log. Thus you directly see which human logged in as user root. Shared Accounts is a bad idea It is stated that shared accounts is a bad idea. I would upvote this statement. Avoid shared accounts! But sometimes it might be really difficult to avoid shared accounts. So the question is, what is the bad thing about shared accounts. And if we can mitigate this bad of shared accounts, shared accounts might not be that evil anymore. I guess on big bad thing about shared accounts is, that you can not distinguish which human being logged in and performed the actions. So if you have a possibility to differentiate which human logged in as shared_user_A, then the problem might not be that big anymore. In this case 2FA is a good possibility, because you can identify which 2nd possession factor was used to login to the shared account. And if you can match the serial number of the possession factor to the human, then you are relatively clean again. In your SSH scenario you might want to combine ssh keys (in authorized keys) with the shared TOTP Google Authenticator. A human has to have both, a unique ssh key (by which you might identify the human) and a shared TOTP. 

There is an old concept of Microsoft which let the OTP server enroll a short lived logon certificate to the Windows Client. Thus the user on the windows client will in fact use PKINIT to get his kerberos ticket - use the certificate to login. $URL$ You still need to setup a CA. The OTP server must be capable of requesting a certificate on behalf of the logging in user... Thus, this is often implemented in another way. Also the solution I developed(!) and work with works in a different way. On the client you install an additional Credential Provider. In this case the privacyIDEA Credential Provider first verifies the OTP value against the privacyIDEA server. If this succeeds then the credential provider uses the windows password to perform a normal domain login based on the windows passwords. This works pretty smooth without setting up complicated environments - no PKI. The drawback of such an approach is that 

I created a Makefile to deal with this. So I never need to remember any openssl command! :-) I used it to enroll server certs and client certs and even certificates on smartcards. I can also revoke certificates and publish the CRL. Hm, I just created a repo on github, so that you can take a look at. OpenCA is rather cool and mighty. But I think it is not activley maintained anymore. The user would enroll his certificate in the browser, but afterwards he would have to export the certificate... 

With AD integrated CAs you can specify the Certificate Templates, which a CA is allowed to issue. So, yes you can. But note: Certificate Templates are stored in Forest Root. Thus the Forest Root admin can change the available certificate templates! The domain admin or local admin of the sub CA can change the templates provided by the sub CA. Thus you should in addition set the access rights on the templates accordingly. 

You shoult take a look at the Univention Corporate Server. This is a linux based distribution providing LDAP, Active Directory (via Samba 4), SAML and many other third party applications. Using privacyIDEA on the Univention Corporate Server you can also setup 2FA in your network. As the UCS provides an Active Directory, you can connect all your windows clients. Thus you do not need to enroll the pGina. As the UCS also provides simpleSAMLphp, you can also use SSO/SAML with the external applications - even with 2FA. 

a patched SSH server, that supports DNs in the authorized_keys a client, that supports handling certificates like the tectia ssh client. 

Still looking? privacyidea is the open source solution. It is a fork of LinOTP. privacyidea is hosted at github, discussed at github and issues are kept at github to give you best transparency. 

The smartcard authentication on the client side performs a normal challenges response. I.e. the ssh server encrypts a challenge with the public ssh key from the .ssh/authorized_keys. You smartcard decrypts this challenge using the private key on the smartcard. But at this point no x509 certificates are involved. If you want to include x509 certificates and CRLs you need: 

Just guessing: Are these local home directories or are the home directories on NFS or SAMBA shares? If you have so many users and machines, why not use a centrally managed system like privacyIDEA? Addition: Looking at the code $URL$ the function getpwnam_r seems to fail. So maybe the connection to LDAP is disturbed/timed out so that getpwnam_r can not determine the user's home directory. 

If the PAM config looks good, I can transfer it to gdm, ssh or whatever. (Who needs a local login ;-) And yes, success=n means, in case of success, skip the next n lines. 

I think SSH does not do this right away. You may take a look at privacyIDEA which is a multifactor authentication system. It was originally designed to do one time passwords but does a lot more now. It also support a two-man-rule authentication token, which you can use to do exactly, what you recommended. You can define, that e.g. the user "root" can login, if "n" persons of group1, "m" persons of group2, "x" persons of group3... authenticate togeather. Read more about the so called "4 eyes token" $URL$ Disclaimer: I am the lead developer of privacyIDEA. 

The authentication was successful, which you see at the :-). So obviously it is your remaining stack. If you say, that it works, when you remove pam deny, then you obviously have a problem in 

So that you can login with a fixed password offline, and otherwise the password gets handed to pam_radius and is validated as OTP against privacyIDEA. See this howto $URL$ 

You can do so with Samba 3. Samba 3 can use openldap as a backend. But samba 3 can not mimick an AD. Thus you will logon to a Windows NT domain. Samba 4 comes with its own LDAP backend but can mimick an AD. Then you would have to sync your users between openldap and Samba 4. You may also want to take a look at the univention corporate server. 

You need to decide if you want to do 2FA on your own of if you want to trust an external entity. This is not only to not trust authy but to not trust any attacker, who might intercept the authentication request. Each time you want to login via SSH an HTTP API Request is sent to authy.com. Authy decides if access is granted or not. There are other hosted services like authy but there are also solutions which you can run on your own and thus you control the authentication decision. You can use the google authenticator PAM module or Yubikey, which work locally. Or you may host your own authentication server like privacyIDEA. (Displaimer: I am a developer of privacyIDEA). What also sounds a bit strange to me to use ForceCommand and not provide a PAM module to be integrated into the PAM stack. If it was integrated into the pam stack, then you could do backup scenarios like: if OTP fails still authenticate with password or with ssh key... You can not lock you out when you get out of sync. THere are means to resync. You can not lock you out, when you loose your phone. You can always ask authy to says "yes" to the next authentication request - however it looks like ;-) 

You may use privacyIDEA in conjunction with NPS. Note: You need privacyIDEA and a FreeRADIUS server. The NPS will forward the request to FreeRADIUS. privacyIDEA can manage the knowledge factor and the possession factor. The 2nd factor can be any kind of OTP token like Smartphone App (Google Authenticator or FreeOTP, Hardware Token, Yubikey...) Here is an integration guide to configure NPS with FreeRADIUS and privacyIDEA. The OTP is entered in conjunction with the password (not necessarily windows password - can be): 

[success=1 default=ignore] means that in case of success the next (1) entry is skipped. So when removing pam_deny the password-auth entry is skipped. So take a look at this subtrack! Update: Probably it fails due to the lines 

Regarding your first answer I am always wondering this myself. I would test this very specific scenrio in your lab! I think it should be possible to renew the certificate with the same keys but another expiration date. Regarding the issuing (online) CA. Your cisco VPN should verify the trust chain up to the root CA and then again complain about the validity period of the root CA. Thus you either need to renew the root CA with the same keys and a shorter validity period OR you need to setup a second CA.