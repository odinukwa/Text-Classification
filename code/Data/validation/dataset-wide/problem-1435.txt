Even worse - what you just implemented yourself can have unitended side effects if the row object has additional properties with special meaning, which coincidentally collide with (not actually ignored) keys in the passed data. So your logic can be written more compact and less error prone once again: 

I'll let it to your exercise to decide on the visibility of these attributes, and to add a constructor. And the class then correspondingly holds a collection of products instead: 

In every single location in your codebase where you need to handle either 2D coordinates, or 2D bounding boxes, you always chose to store each single component in an individual variable. Why? But you didn't just duplicate the pattern of storing the components individually, you also typed the bounding box tests over an over again manually. It's so simple to solve that, just group 2D coordinates into a object, and bounding boxes into object. The class should also contain the commonly used methods for test for with collisions, and in inclusions. 

By the way, there are functions for this available, too; take a look at from (base-10 specific) and from (pick your favorite base). I won't try to write tests here, because the types of these functions are more informative (and more correct in many ways). Final result Barring the reuse of already-written functions, here's the final versions of all the functions. 

Now, as we all know, building up a linked list by repeatedly appending to the end is a bit inefficient. Probably for such small lists as you'll be using in test cases here it won't matter, but it's a good idea to get in the habit of paying attention to some of the easiest stuff, so let's try to improve this a bit. We have a choice here: either we can keep the interface of this function as-is, that is, always output a list in the right order, or we can choose to change the interface, and change all the call-sites of this function. I think for this case we can keep the interface. The idea we'll take is to build up the list backwards, then reverse it at the very end. The name is traditional for local workers. 

You should not refer to an example section just to explain the basic syntax. If you need to do that, chance is that your syntax is bloated. In this case, it would have been a better choice to pass directly an to your function. That both removes the need for half of your code, and provides a simpler interface. 

Notice a difference? There is nothing modified by reference. In a recursion, there is no global state, each single recursion step only reads the data. A strange way to sort children There is nothing wrong with wanting to define an order on children of a node, but make sure you are aware what it actually means. It's still a tree, so the same construction applies. But in addition, you want to be able to sort the children of a node. Or even better, already have them sorted, e.g. in a linked list. A linked list just what you constructed with , except that you got it linked backwards, not forwards. If you really want to use this structure (I will cover alternatives later), do yourself a favor and use instead. This at allows to traverse the list of children in a more natural way. Furthermore, if you want to be able to use the linked list half way efficient, make sure that you always store an entry point to the linked list. This means in addition to , also store a on the parent node. Let's just extend the code sample for better comprehension: 

This isn't obviously better, since it still fails in all the same situations it used to fail, and it never returns multiple answers. So we should differentiate the two cases that lead us to the branch: 

Okay, let's check our work. We already know that the final thing works differently for negative numbers, so let's only check non-negative ones. 

My only complaint now is the name, for two reasons. The first is that isn't capitalized, which is inconsistent with the naming of the remainder of the file. The other one is more of a philosophical one: our input is an integer, not a base-ten integer. If anything, the base-ten-ness is being imposed on the output. So: 

Whoa, whoops! Can you figure out which refactoring above was the culprit? =) Now we have to decide whether we like the old behavior better or the new one. I think in this particular case we should like the old behavior better, since the goal is to show a number, and we'd like to show up as rather than as . It's a bit ugly, but we can special-case it. Since we like our future selves, we'll leave ourselves a note about this, too. 

Speaking of disabling fields. Why did you use the attribute? The requirement only speaks of making the result field read only, and the attribute which does that is named . Disabling the input fields prevents, according to specification and in most browsers, all interaction with the input fields, including the ability to select or copy text. 

Be careful when you log. Logging when something spawns? OK. But spamming a log entry every single frame? Waste of resources. 

Your approach of separating the actual algorithm from the input/output handling was almost correct. Except that you forgot to implement the latter part. You are neither capturing any input, nor are you creating any output. Except for the log spam resulting from placing your strange test cases into main file. Providing a user interface of any sort is usually considered part of these challenges, even if it's just a console application which reads from and outputs to . Or in the case of JavaScript best a small HTML application. 

which we can use to index into our lookup table with the digits of our integer. So let's try to write this directly! Taking a cue from the final implementation of above, we can write 

We first need to fix up some typing issues, since we've changed the interface to and this is a caller. As before, we can do that just by putting in a ; as before, we'll spell the combination of and as . 

Personally, I often prefer to , and the is complicated enough that I feel like it should be named, so I'd write it as follows. But this is an aesthetic choice that you may or may not agree with. 

Now, we have this branch primarily because still isn't total (it can't handle an empty input list). Instead of protecting ourselves from calling in this case, we should just let deal with empty lists correctly. So: 

This case of magic numbers is even worse, because this time I can't even deduce from the context what these numbers are supposed to mean. However, this time the solution is not to uses constants, there is a better solution. Remember how you didn't complete the work on ? It's time to implement another operator, . With that operator implemented, you can simply return an instance representing the offset the enemy is supposed to move, and add it to the enemies current location. Absolutely no magic number needed this time. 

This is somewhat pointless in Javascript, it's a double precision float anyway. Unless you have a good reason to specifically use deciseconds, just stick with the established standard of using seconds as the unit for all time stamps.