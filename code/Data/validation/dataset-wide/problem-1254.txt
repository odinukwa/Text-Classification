This contains the name of each object, any keyword arguments that are necessary, and any attributes that also need to be created (as objects themselves). These can be created from this structure using the following functions: 

Since will always be by the virtue of the list not being empty (as previously checked). This second line is equivalent to 

With this approach, the same result is achieved, but with much less code. Combining this all into a single function yields: 

Sort But wait, this decrement function suggests that we turn into and turn into . This clearly isn't correct. While the outputs are larger than the original and the digits sum to the correct value, they are not the respective minimal solutions. However, if we sort all of the digits after the incremented digit in ascending order, the minimal solution is achieved. 

We can't increment the because decrementing any other number would result in a number that is less than the original. We can increment the , because we can then decrement the . From this, we learn that the right-most digit should not be incremented. 

This does not seem to be the intention of the code. Assuming you want to check all lines in either and you may want to use the following code: 

One immediate, fairly significant improvement that I see would be to calculate and outside of the loop in . This provided a 30%-50% reduction in time in my tests depending on the computer and Python version. 

Back when using .NET 2.0, I wrote a class which inherited from , and a which inherited from . For legacy reasons we still use it, but I'm pretty sure it could be rewritten in half the code as a few extension methods. Here's a small sample: 

I realize this isn't necessarily faster, but it will be much easier to maintain, and at least one example ought to be posted using LINQ. So here's that example, using LINQ and the Combinatorics library to do it in a single statement, and in a more object-oriented manner*: 

The first method is an all-purpose "Add"-type method which will either add it or update it depending on whether or not it exists. The second is specifically for dictionaries where the value is a . It'll let you add an element to the , creating the key if neccesary. 

Another possibility would be to store the words in a dictionary of nested dictionaries. The key would be a letter, and the value is another dictionary of every letter that can follow that. Repeat until you've reached the maximum depth. For the sample case, this would look like 

You don't provide any example of how would differ from , so I can't be more specific, but here's the gist of what you should do: 

As an alternative, since you already have the letters and their counts, sort the string then make the regex . 

By doing it this way, you separate the formula (which is basically just Ingredient/Percentage pairs) from each application of it. You can use the same object to calculate the weights for 10000g of dough or 50000g of dough - simply call with a different value. Notice how many fewer properties you need on each class, and the question of "late setting" of some of them is entirely irrelevant. Effectively, weight is not an intrinsic property of an ingredient, because it varies based on the total weight, so shouldn't be a property of . 

I don't really understand what this function is doing, but it seems messy and could likely be improved. Then your function can be greatly simplified. 

Here's a version without , I'm not super happy about either. Neither version seems particularly elegant. 

To be honest, I didn't read through your code much because I don't have the attention span and it seems the biggest issue is the approach rather than the solution. Nothing about your code looks terrible or un-Pythonic, so I'm going to go through a different approach instead. The first thing that I noticed about the next number is that all but two of the digits of the original number remain unchanged. When going from to , the was incremented to a and the was decremented to a . When going from to , the was incremented to a and the first was decremented to an . This pattern suggests that we may be able to increment one digit, decrement another, and arrive at a solution. The first challenge is to find the digit to increment. Increment 

We can't increment the because we can't decrement any of the 's. We can't increment the right-most 's because then decrementing the would lead to a number less than the original. Thus, we have to increment the first . We would reach the same conclusion if we considered the number instead. From this, we learn that trailing 's should be ignored. 

Having a function mutate a global variable is a bad practice. In this case, it may seem easy enough to reason about what is going on, but I guarantee that at some point it will lead to an insidious bug that is hard to track down because you have no idea who is changing the global variable and when. Recursion is not necessary here; it over-complicates the solution and may make it difficult to change/update the code. 

Here's a pseudo-coded recursive function to build the query, since I'm feeling lazy and don't want to double check all the string functions. I haven't tested it for speed - it might be too slow, but I think it should work. 

Each grouping of numbers is an instance of a object, and we test if two are equal based on the items in each . 

Then you can use LINQ to find matches by recursively building up a query which looks like: (ab)(bc)(ca) 

Everything that's the same gets put into . Everything which could vary is defined as an method or property, and then the subclasses implement just those things which make it different. 

If is your slowdown, you're not going to be able to get a huge improvement, but you can get some by parallelizing all the calls to it. Replace your loops with this version: 

I'm not entirely sure how your second example fails to match, because the string contains all of "AU", "A3", and "2.0". That being said, here's an attempt at a cleaner rewrite: 

This removes the need to worry about casing, lets IntelliSense prompt you for valid values, and throwing an exception on an unexpected value ensures that you catch it during testing the moment it occurs, instead of the subtle "hey, this just keeps failing to validate" of always returning . 

Everything in your code should either require the interface or the interface. If the former, it can accept any of the four classes. If the latter, it requires the plus four bit. Since a plus four can always be downgraded to a pure zipcode, this set of inheritance will let you pass a +4 wherever you are looking for a . Also, by always requiring the interface, rather than the concrete type, you can trivially implement the null object pattern you asked about. 

Iterating backwards was smart, but, yes, there is a much simpler way to do this using a list comprehension â€“ this is how one typically filters a list in Python. 

This allows for a arbitrary number of objects to be created. However, this runs into some problems when we want to use the context manager since it is not natural to have an arbitrary number of required contexts. This can be achieved using a recursive function. Here, we will supply a sequence of callables that are to be opened with the statement, and a callback function and arguments to be executed once all of the contexts are opened. 

Notice that this isn't contained within a because there isn't really a need for one; a method does the job better. Also, I made some (bad) changes to make the algorithm less readable. This new regular expression counts the number of 's that occur successively starting from the second-to-last digit backwards and replaces the old loop, the at the end absorbs the original . Now, if we really want to make things unreadable... 

I echo both of the previous reviewer's sentiments, but I'd also like to add that regex is overkill for the parsing here - will work just fine. Implementing this and some of the other suggestions might produce code like: 

These do the same thing, but are much more readable once one knows that can be used to iterate over both the index and element at once and that is a common method to iterate over a list backwards (albeit, slightly inefficient). A final note is that I have updated all two-word names to use snake-case. 

Just to build on what @svick said, this is definitely not a good way to handle things. If you want to catch all exceptions, simply . If you don't want to catch everything, then only catch the specific types you want. There's also the block which you can use to do any cleanup which is necessary, regardless of whether or not you've handled the exception. 

is just a call to get as a (instead of an ). And so on... This lets you easily add a lot of logic ("Do I add this set of tags?"), doesn't require a multitude of s, and you can go back and add more things to a tag later. 

I can't say that it's going to be more efficient, or better designed, but one option is to take advantage of polymorphism by creating a set of classes for this. 

Edit: Stole the idea from Jesse C. Slicer's answer, but didn't modify the function signature. You can also return if that is more useful to you, or you can go with his idea of returning , in which case you don't need that at all. 

I find this much more readable than trying to do conversions to an Enum, and more straightforward than a decision grid. That being said, it doesn't scale as well as either option. 

Heslacher is correct in that you should split this into two separate methods. That said, sometimes doing that isn't an option, so I want to point out an alternative to passing the "magic values" of and into your function. When you have a function argument that only takes a very limited number of values, you're usually better off replacing it with an . That enforces the limitation when you're writing code, and helps avoid typos and other subtle gotchas. 

I'm going to expound on this answer later (when I'm on my Python 3 machine). To begin with, there's a lot of repeated logic, especially in the , , ... methods. You can avoid this with a class method to generate these instance methods. 

Per Graipher's answer, I extended the chance of victory to accept an arbitrary number of regions and number of wins required. 

We can't increment any of the 's since isn't a digit. Thus, we must increment the . From this, we learn that 's can't be incremented. 

The code itself is rather concise, but the weird data-flow out of the function makes it difficult to understand what's going on. This is complicated because the function is recursive and so you then have to keep track of the calling stack when figuring out how is being changed. I don't think the module is really necessary here, I bet that it is heavier that just searching for strings and doesn't seem to offer any benefit. I've kept it for now, but I might offer another solution without it. Here's how I would approach the problem: 

Finally, we want to create a decorator which will do the following things: (a) create all of the objects, (b) generate and enter the required contexts, and (c) execute the supplied function. 

To address the recursion depth error, you could either change , or you could rewrite your initial solution to use as an argument to avoid the global variable.