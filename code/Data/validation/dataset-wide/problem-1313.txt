Also, you should always use brackets in your statements, even if it's just one line. Not using brackets makes things harder for other programmers to read your code and increases the probability that unintended bugs arise. 

Another copy constructor that just takes up space without providing any added functionality or benefit to your program. I would remove it if you don't use it (unless it is required) Finally, the reason that your professor added the extra methods was to force you to protect your data. This is a normal practice in Java, but you really don't see accessors/mutators as much in a language like C++, for instance. 

I have created a StopWatch class to measure the performance of any code. I use this StopWatch code in any of my multithreading projects as well. 

I am using below class to send data to our messaging queue by using socket either in a way or way as shown below. It depends on requirement whether I want to call or method to send data on a socket. Most of the times we will send data through aysnc way but sometimes I may need to send data through sync way. 

Below are my corresponding validator classes: ValidatorA class This class is called by , basically it's method for validation. 

This is a simple boolean comparison, so you can literally just return the result of the comparison and not have to make a bulky if-statement. I think that Janos did a good job touching on making your class a simple static method. I agree with him about your use of tests also. You put in a lot of code (more than your actual list and program) to do some really basic tests. I would honestly just keep it to one method. 

Room_Carpet Class Once again, the class is designed pretty well, but the copy constructor is not implemented. 

This way, you divide the problem into manageble pieces, give you thoughts a place to stop every once in a while, and should get rid of this nervousness. BTW: from an interviewer's point of view (at least I you want into my team in my country ;-)) a well thought pseudocode algorithm is worth more than working code. If you apply for a programmer's job, I just assume that you have the basic skills to use an IDE and kick against some piece of code until it compiles and produces the correct result. What I am looking for is organized thoughts and problem solving skills. One last thing: there is one and only one correct exception to throw for a null parameter that must not be null: NullPointerException. Ideally by simply using Objects.requireNonNull. 

If this method doesn't actually do anything, it shouldn't be in the code. I would say that having copy constructors can be very helpful... If the method is properly implemented. The point of a copy constructor is that you can pass an object, which is already instantiated, to another object of the same type to instantiate it. The benefit to this is that you don't have to worry about passing a bunch of values to the object manually. You literally create the copy of the object with the values that it contains. 

You can remove two if-statements altogether if you think about it! Also, you don't even need your first edge-case if you do this: 

So the only difference between those two above methods is - For async case, I need to retry at all cost if acknowledgement is not received but for sync I don't need to retry at all and that's why I am storing more state in a class. is a class which receives the acknowledgement for the data that was sent to our messaging queue and then calls method below to remove the address so that we don't retry after receiving the acknowledgement. 

My question is - Do I need this at all when I already have , class? class just contains all the variables combine from both the validator class and I am using builder class just to set data in both the consumers and then use it in execute method of , and then clone the old builder to make a new builder object again by setting some new variables. Is there any better way to do this thing? Looks like I can get rid of but not sure how. 

You have this copy constructor in your class, which is confusing because your class is mutable. Typically, we only need a copy constructor if an object is immutable. If you wish to keep the copy constructor, remove the setter and getter and change the copy constructor to this: 

Your overall code is good, I do agree with Wenqin that a more class-oriented approach to the shapes could prove beneficial to the structure of the program. Anyways, onto the review. You are right about the use of your statements in the beginning. This can be handled in a much easier way if you just make a to store this and call it from a single statement. That way if you make changes later, it's easier to maintain and it's definitely easier to reuse. 

Then, for the methods themselves. Basically you always do some outer loop checking projects != null, then an inner loop checking versions != null. If you can live with a different message order (errors first), I suggest you create a preprocessing method first, which will sanitize the input and emit the according warnings. Something along the lines of (attn: untested editor-only code) 

is all you need. There are quite a few more problems in your code (especially the mixup of static and instance variables), but alas my time is limited right now. 

One more thing in addition to the other answers: nowadays I'd leave the construction of buffered readers and writers to the appropriate utility class, ie. instead of 

As a side note, look at how much easier it is to read! Think about what it would be like to read your code from someone else's perspective; would you think it's cluttered? Confusing? In your , this can be broken up into methods based on shape (unless you decide to create a class for each shape). This helps in maintainability also and builds on what I stated above. 

You have accessors (the and methods). These methods allow us to retrieve data from our private members of the class instances safely, without revealing how they are implemented. This is known as encapsulation, a very important topic on programming to understand. This is where having a properly implemented copy constructor can show its' worth, due to the fact that you can now create copies easily without exposing references/implementations of the member variables. Typically, accessors are paired with mutators, which conversely, allow us to alter the members of a class instance in a predictable and controlled way. As pointed out by cbjobar in the comments, the use of mutators changes a class instance from immutable to mutable; the data values can now be modified after instantiation. 

Simplify: Getting a next day via an overridden method seems a little overkill. We know the stucture of an enum and we know that the constants will be put into a value array in their original order and have an ordinal() which corresponds to the index. Thus, next() would probably look like this for me: 

... the same for min. As a general advice: Java is a very mature language, and chances are good that every "simple everyday task" is already solved in the library. (Also note that most books on Java are from the pre-java-8 era and may be considered somewhat outdated today.) 

Are there any potential issues or any race conditions in my above code? Is there any better or efficient way to do the same thing? 

I am working with Cassandra and using datastax java driver so I have to re-use prepared statements and that's why I am caching it here. Prepared Statement and BoundStatement. Is there any better way of making my method thread safe instead of using synchronized block like that? Any other data structure which might be thread safe for these kind of operations? I am working with Java 7. 

I have two consumers and each consumer has their own validation logic entirely different from one other so I am using two validator class for that, one for each other.