When ever you are animating anything on the page were you define every frame use it ensures that the animation is in sync with the hardware and any other page rendering. It also prevents updated content from being presented to early or quicker than can actualy be seen. Smooth animation is not about speed, but about being in sync and limiting the amount of work the computer must do. 

The reason is that numbers when used in computers have a limited precision. Once you go over that precision you can no longer add numbers that are smaller. For example adding 100 to the hash number does nothing the returns true. 

Reorder in place But you do lose the object reference that may not be the best option. You can reorder the object properties and still keep the object reference by using to remove properties. A little more complex as you need to delete all the properties you want to move the new property position in-front of 

An example There are many ways to write this function. I have opted for speed. In javascript string searches are slow when you use character by character searches. You can speed up the search by using regular expressions. (Though it does not reduce complexity it does give significant performance increase) 

Some issues that would black list your module in some organisations. Untrusted state The whole thing is unsafe due to exposed properties. Exposed properties should be protected from improper use via code that either 

To do the flow you can define some simple directions and then just iterate following the instructions. For example the human readable form. Start top left, move right until edge,turn down move one step, move left until edge,move down one step, and repeat. Stop when no more places to move. And the machine readable form 

This is a very crude set of reg expressions, and I am sure there are better ones, I leave that to you if you think these approaches suit you. Returning best hands All that is then left to do is test each of the 21 hands and giving them a score. Once scored you sort them from best score down and filter keeping only hands that have the same score as the best. You then get an array of best hands, each with a score that can be directly tested against any other hand. No need to have the high card. No need to have an object holding array of card objects, that is all irrelevant to the result. Example Putting it all together you can create a hand evaluater that will return all the equal best hands from the parsed array of 7 cards. For fun (and to make sure it worked) I have added an interface. Click cards to create a deck, when 7 cards selected they are evaluated. Click on selected cards to remove. Evaluates and names all combos. Best hand has lowest score. 

This is the key: asks the question "Is this proposition false for all possible inputs"? To test this, we split into two parts: its first argument and the rest. If the first argument is , then is it possible to satisfy proposition with the remaining arguments? If not, then it's a contradiction. This is the part . is itself a function of 1 Bool argument, so it is in class , and so we're able to apply to it to see if it's a contradiction. We also need to be sure that it's not possible to satisfy if the first argument is either, which is why we this with . I'll leave the function as an exercise, and move on to the next inductive step. Inductive Instance Definition - Inception Since is of class , then so too is . I could be mistake, but I'm fairly sure that is actually just short-hand for this. So this means that a boolean function of two boolean variables is itself a proposition. How do we determine its validity? We check if both and are valid. The former means 'if and both evaluate to True'. Hopefully you can see now the recursion that's going on (I haven't done a great job explaining it; sorry)-- what we're doing is recursively defining the ity of the type so that such a function is valid if and only if it evaluates to for all possible inputs. 

What stands out to me is that you initially perform a check against every grade range and insert into the map in the right one. By that point, you've already found which grade is right. But then you initiate another loop to start searching for the grade corresponding to . I think instead, you ought to alter your method to output a enum, and delegate the string handling to another function. I feel that it's better practice to return a Enum from the first method because of the strong typing-- you may want to use this information for other methods besides finding the grade name. In fact, s are particularly nice because you can use a on them. 

Or you could have jumper return a promise on the first pass which resolves with the answer. I am not too sure if this fits the FP paradigm. 

Zero indexed array and clean code. The loops are a little strange starting at 1. Normally you index into an array from 0. If you have 8 items in the array the loop would be but you may have extra elements on the array. Without the HTML I can only guess. For finding the checker colour you can add the x and y and then get the remainder of 2 saving you the second loop. Function names should tell you what they do. You have which could mean anything. The whole thing can be done as follows 

I ran the tests for many minutes the results were ashraf aaref's function ran twice as fast as Oleander's on Firefox, running on an old Win10 32Bit laptop. The times; 2ms and 4ms respectively for the above loop. Which equates to 500,000 and 250,000 calls to the function digPow (plus overhead of loop and call) per sec, The array method reduce is the bottleneck in the slowest version. For performance always avoid any of the array iteration functions as each interaction involves a function call that needs to save the current context. Type conversion is the bottleneck in the second function. Avoiding both bottlenecks But there is a much faster method that avoids the type conversion 

You share the page with a variety of 3rd party scripts, adverts and what not. The page is yours alone and no other code, but yours, will ever see that page. 

I will assume that the argument (which would be better named ) is always a string as that is what your code implies. Also assuming that undefined names are to be set to (empty string) and that all middle names are to be concatenated to a single string separated with spaces. Rename properties removing the "name" part as that is implied by what the object is holding. You don't need to store the result object, just return it directly. The resulting function 

What we're doing here is creating a new typeclass called Prop. We need the syntax because we need to define the behaviour of an instance of the class. If we don't introduce a symbol for it, then how will the compiler know what we're talking about the in the typeclass definition? For example, the line says that for every instance of typeclass , there must be a method called which maps to a boolean value. Likewise, there must be a similar method for . Now the line may cause some confusion because appears twice. It's important to understand that , being an instance of a typeclass, is a type. There are no "objects" as in object-oriented languages. Remember: is a type which satisfies the typeclass contract given by . The Java equivalent would be a class implementing an interface . What we're saying here is that for type which implements/is a part of this typeclass , there is a method called of comparing them. And its type is meaning that it takes in two expressions of type and returns a boolean indicating whether or not they're equivalent. 

Inductive Instance Definition - First Step This is the fun part. We're using induction. Here's the full code snippet, and then I'll break down each line. 

I'm late to the party here, but I thought it'd be interesting to consider some more optimisation you could do. First let's consider the number of 'modulo operations' your code does per 15 integers: 

These correspond to three questions which we could ask of any proposition which is a function of any number of propositional atoms. In case you're unfamiliar with this terminology, an 'atom' is one of the inputs to a proposition which is a function taking some number of atoms and itself evaluating to either or . Typeclass Declaration The name for the type class bears no meaning for me, so I changed it to short for "Proposition". 

to check if the proposition is logically valid (true for all possible inputs) to check if the proposition is false for all possible inputs. to check if two propositions of the same number of arguments have an identical truth value given the same inputs. 

Buggy as. Unusable I made a single change and then could not get it to work (turned out I added an extra space) Bugs Any spaces in the wrong spot, and deviations from the simplified equation, any fractions and more will cause the code to throw a variety of errors. Expectation When you create a function people that use it have idiomatic expectations. You must attempt to conform at least to common variations on these expectations, and or ensure that your code does not throw errors if the input is not as expected. One would expect a equation solver to be robust and handle all the standard input variations, like be 

And most likely more problems but as the code is so hard to use I have not looked any deeper into your algorithm. Conclusion. I would say "Try again." as it is not at all what I would expect from a function that solves quadratics. 

I would do it as a singleton, so that the core functionality can be protected and private. All that is exposed is the Interface, ,,,and the semaphore Using prototype is only an advantage if the object that it belongs to is instanced many times. If you only create the object a few times, or once then adding to the prototype is actually more work for the javascript engine. I also added a start method so that the queue could be created and started when needed. Once started you can add to the queue as long as 

The vector lib has forced you into creating a new object for almost every operation. If you were animating 5 balls interacting with 10 lines you would be generating 3000 un referenced vector objects a second. And that is a very modest scene complexity. Simpler line-seg circle intercept test If you get the line as a vector and a vector from the line start to the circle center you can get the closest point on the line as a unit distance along the line by dividing the dot product of (AC dot AB) by ) / (AB dot AB)(the unit being the length of the line). When you have the unit dist you use it to work out what part of the line segment to measure the circle center distance from. if u < 0 then get the length of AC if u > 1 the get length BC else get the distance from (A + AB * u) to C. If the calculated dist is less than the radius the circle is touching. Rewrite Almost zero CG overhead, and much smaller yet does the same thing. 

Not that you need these grade messages, but that's an example of the power of holding on to the type rather than converting the grade directly into a . Sorry if I've made syntax errors as I've not used Java in a while. Edit: Just realised that you might like to put , and into the itself as static methods. 

Notice how as soon as the grade matches the range corresponding to something in the Enum, the method immediately returns. Now an example of how you might use that : 

Now to be fair, I don't know what the bottleneck in this code actually is, and I'm sure your application probably doesn't call for such niggly optimisation, but I still think it's interesting. I'd wager that the third version is the fastest. 

It says that a boolean function of one boolean is valid if and only if and are both valid. Of course, the validity of boolean is just that boolean. So in this case, can be thought of as being a bit simpler: 

says that the function mapping our proposition type of to whether or not it's a valid formula is the function . (This function just returns whatever it's given). says that the function mapping the proposition type to whether or not it's a contradiction is the function . Just as well, because takes just one as an argument, and returns a . This is compatible with the contract we laid out earlier in the typeclass definition of . says that the way of comparing two of these propositions (once again, of type here) for logical equivalence is to simply invoke the already existing method . 

Alright, so is valid if and only if it evaluates to for both arguments! That's what we want. Now for : 

The first thing you should realize is that in Haskell, typeclasses are basically the same thing as Java's interfaces. They define a contract of behaviour which instances of the class must obey. In this case, the typeclass I'm calling promises the user three methods: