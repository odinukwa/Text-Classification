I think so. Without the lock, one thread could start evaluating by evaluating , then another thread could modify and the original thread would then overwrite with the old value of (and so the effect of the other thread would be lost!) 

Yes, I think it will. All access to the field is protected by a lock, so I do not see why this wouldn't be thread safe. A nice coincidence of using immutable lists is that you can also nicely implement or even just return the list of all elements currently in the stack - because the data type is immutable, it can be safely shared with other threads (this means, you won't get into the usual troubles with "Collection was modified; enumeration operation cannot continue" that you'd get in C#. 

If the idea is to have multiple threads sharing the state, then they'll need some way of sharing & mutating the state. Another approach in F# would be to use an agent and keep the current as a parameter of the asynchronous loop - in that case, you're not using mutation in the F# code you write (but there is hidden mutation and synchronization going on in the agent). Logically, the agent-based version is quite similar to the one you have using locks - it might be a bit nicer for other reasons (getting locks right is hard, agents do not make it possible to do the same kinds of errors), but that really depends on what you want to illustrate! 

Naming Your naming is quite verbose, which is good (not counting ), but sometimes, although the name looks meaningful, it actually does not convey any useful meaning: 

How does your intersect with ? As far as I know, there is no such method on ... It is quite hard to calculate complexity of code, if we can't know how this intersection happens, especially since it happens within a polynomial iteration (*) in , and within a recursion in . Caching? If the complexity of is a constant, your complexity would be \$O(maxRays \cdot objects \cdot lights)\$ (I'm counting your operations' complexity as constant), this might not be ideal. I've got lost in all the recursion and iteration loop you have there, but might there be a way to cache some of the calculations? Would it help you to "remember" distances between your (which does not change during your calculations), and your s, and reuse them as you go along? This might lower your effective complexity, and make your code run a lot faster. 

Also, in I personally think that separating the score calculation from its aggregation is more easy on the eyes: 

I also think there is no point in pattern matching over booleans, because you are effectively just writing simple with more complex syntax, so I turned your original pattern match into an inline in (I also changed spacing to 2 spaces in the last snippet, but that's just to fit things on the web page). EDIT: Using nested local functions would also quite nicely work with Mark's suggestion to pass around functions. This way, you would not have to propagate them through all the other helper functions, so it might even look nicer than my answer. 

The next thing that is a bit unfortunate is that you always have to write , which makes all your method headers long. If the private helpers are not used anywhere else, you could avoid this by turning them into local functions. That said, this might not be all that nice, because it makes the function very long (just syntactically, not logically): 

This is a bit difficult to answer, because you did not share code sample that fully type-checks (and so it is hard to make sure the answer is correct). However, I think you're very close. When refactoring two similar functions, you just need to abstract out the bits that differ. In your case, there are two places: 

As I read the code, it seems that what the method does is control the business flow as defined in the specifications. Since all it does (at least as it is written here) is delegate the actual actions to other methods, I don't think 'it does too much' - its single responsibility is to control the flow of the registration process. To answer your concerns about future maintenance, I see two possible kinds of new features - features that should affect all the service consumers, and features that affect only a single (or part) of the consumers, but not all. In the first case - there is no problem - do your change in the code, and it will affect all consumers (if you move the code to the controllers that won't be true, since you'd need to change all the controllers...) In the second case, it should be easy enough to create a new register method for that use case. Since all it does is delegate, the new method itself will be just as simple as the old one, with maybe a delegation to a new method, something like this: 

I think that Mark's answer gives a great alternative perspective here. That said, I would probably write something that's quite similar to what you did here. There is a couple of small tricks that I would perhaps use to make the code a bit nicer (at least for my own personal idea of "nicer" F# code :-)), so I thought I'd share those. First of all, I would probably use and tuples-syntax for the definition of the interface. The is recommended for members and I think it makes sense to keep those aligned with the .NET style. You can also omit : 

The type annotation is interesting. It says that the argument is a function that returns a list of some values that implement the interface - but it turns this type into a generic type argument that is then passed to the other function (), so when you use the function, the compiler knows that the argument of has the same type as the thing that you obtain from . The annotation allows you to write in the filtering function. The two functions can now be defined as follows: 

when is first assigned it is a string, but then you re-assign it as an array. You do the same with and . A reader who misses such a re-assignment will be confused about what you do with the variables after it. When you know what elements you have in an array When you have an array, and all you do with it is assign the first element to variable , the second element to variable , etc. you can use ruby's multiple assignment instead: 

Also, some of the properties which don't change (like processor architecture), you might want to cache your answers: 

This way the story has a beginning, and an end, and it easier to follow. Choose your types What is used for? As far as I can see it can have only two values - and , and it is used to flag the get input loop that a valid input has been received. The name is cryptic enough - why not at least make it a ? Block format conventions It is idiomatic in ruby to use syntax for one liner blocks, and syntax for multiline blocks. Instead of writing: