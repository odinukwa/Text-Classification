Future Features You have s. Why not a ? Right now, you can get a hand that contains 9 2's. That'd be beyond silly in a casino. You'd call them out on it for sure. Blackjack has a split feature. You can split a pair into two hands. And some casinos will let you split again if you get more pairs. (That'd imply you get 4 of a kind; 77 split to 7 and 7, get two cards, you have 77 77, split again to 7 7 7 7.) ... but you don't support multiple hands right now. Blackjack in casino's has betting, of course. That's the point of playing blackjack. Other features I can think of: 

Because you check ALL , it is not needed to check for in the inner for loop. In fact, checking this is a waste of time, as you'll eventually get to it anyway. I don't like the way you handle checking regions, lines and columns, given that you go through 3x9x(8+7+6+5+4+3+2+1) iterations for validating a completed board. That's a total of 972 checks. Consider using a to keep track of visited numbers - if the adding fails, you'll know that you have found a duplicate. Like that, you check the entire row with 9 iterations. This makes the algorithm 9x3 - 9 iterations to check a group, and three sets of groups of 9 elements each: the rows, the columns and the regions. This would make 9x9x3, 243 iterations. 

Your code doesn't provide the correct solution for this. It splits "farmer's" into "farmer" and "s". That's not correct; it's one word. To handle this, you should add a special case for the character where you currently check if a character is in the range . 

You should try making static. You create a new object with each request, when all you use it for is a a database handler. It doesn't have any internal state it keeps track of, except for the Connection and the PreparedStatement, which are overwritten inside of the method anyway. You close the connection at the end of the query, and as such, you could easily make static. It'd help with multi-threading as well, if two threads get a hold of the same and both do , they'd interfere pretty badly. 

Don't declare variables if you don't need them. Move the declarations of and below that if statement. Try to keep all your variable declarations close to where you need them. 

The problem with prepending in a while loop is that you're constantly creating a new String, which involves a lot of copying characters around. This method I just described in code should work just fine, but perhaps there's faster methods around. That said, this should still be faster than padding the String one character at a time. Of course, the chance we actually need this code is pretty small... so you could leave it as is. Or maybe opt for a StringBuilder, which would be a lot less messy. 

There's no need to count the amount of times each item differs from the previous item, like you do here: 

These two snippets differ in that is wedged in the second one, but we don't need it here - it's not useful for doing things to . They also differ in the variable written to, which we can use as return value and the strings displayed. I'd make a function . 

This section of code, you check if the is not null. If so, set it to null. The only value which is going to equal to null is null, so skip the check and just set it to null. 

Almost the same as the previous constructor. But this one is a ton better. Imagine I use this one blindly. I put crap in... and I get back... 

When you put regex in your code, I think you should describe what the regex does. So that if there's ever a problem in the script, you can understand what each regex is for. You've done this already for the "tab" regex, but should do so as well for the subtabs. 

First of all, you should fix your indentation. Get and use an IDE - they have auto-formatters which you can use if you have trouble getting things indented properly. For an example, 

I was also a bit worried about willing to accept negative numbers, but Java will throw a , and as such, the error should be pretty clear. For use in a larger application, you might want to handle the exception, rather than the program forcibly exiting. Documentation You should use Javadoc style comments. Simple before each function generally don't get picked up by IDE's. By making use of Javadoc, you can provide descriptions of what a method does and what the meaning of each parameter is. Like that, not only will other programmers easily be able to search for information in a method's documentation, it can also be automated - like an IDE showing a tooltip for each method parameter as you type them. 

The trick to this problem is that you shouldn't check each number. It takes way too long. An important thing I noticed is that there's only 3 digits that count. If N is 10, then there are 3 lucky numbers, because there are 3 lucky digits. And if N is 100, then there are 12 lucky numbers, because there are 3*3 combinations of lucky numbers. But there's 12 in total, because we write '01' and '07' and '09' as 1, 7 and 9. So by looking at each digit of N, we can solve the problem faster. Have a look at this table, where I wrote all the lucky numbers up to N = 1000. 

Bug: on empty list in . You don't have a comment stating you need to input a list containing at least something. Consider returning and adding a comment. 

Use the class you were using earlier Make use of java's char to byte casting; use Define the value as a constant Add a comment . 

But you can reduce the need of comments by having self-explanatory code. It doesn't solve all the problems, but it certainly alleviates them. Except you often use single-character or dual-character variable names. Have a look at this: 

The thing is, as a junior backend developer, yeah, you'd be pretty workable. Depending on how badly I needed people, I'd hire you, if the personality was a match. I don't know what kind of job you applied to. For a higher experienced job, I'd expect better. On the other hand, I don't know how much time you spent on this. An hour? Three hours? A day? If it was a day I'd think it to be a bit much but if you did this in an hour then I'd say it'd just need a bit of polishing. I mean, I did kinda tear into it, but most of my comments were minor. I'm not really spotting any bugs either. I think the most important thing you should take away from this review is that you should have sensible javadoc. And, where possible, provide an explanation from your point of view when you're presenting your work. Why did you make certain choices? For instance, why does a BidTracker accept random items to be bidded on, items it has never seen before? Maybe you take it as a given that you can just let a BidTracker work like that for demonstration purposes. Maybe they see it as a law of Demeter violation. 

You've named a function in a way that suggests it shouldn't be used, but keep it public then support it via anyway. There's no need to name your functions something different here; Java can do overloading just fine. If you name your function , java knows when it needs to call or . 

Which would simplify your game code quite a bit. You could make it even smaller by remembering that you don't need the check due to the existence of the statement. I'd also take a look at moving the whole "Game" to a separate class. That way you could ask the player "do you want to play again" and start at the top. Aim for a structure like this: 

Similar code, so similar answer. Please take these things to heart; I feel like I'm wasting my time otherwise. 

This ... kind of makes sense, but I'd like to see what kind of file is created here. Logging data? Save data? Temporary storage? 

This part of your constructor could be moved to a private function . The rest of the code seems fine. There's comments you can make about various things like 

A lot of your methods have side effects. I recommend adding javadoc comment blocks to list these side effects, or to rename them to explain that they have side effects. For instance: 

To me, these two methods hurt the most. To start with, these methods shouldn't have been implemented by you. Use Objects.requireNotNull: 

These reflection calls; you make them every iteration, but you only need them if the search string is found. Move them down. Lastly, you should consider finding a way to get rid of the reflection. It's making the code slow, ugly and dangerous. 

If you turn the arrival and departure times into objects that give or to a variable, then sort this array (\$O(n log(n))\$), then you can iterate over the list of events. As a result, you'll have 6 iterations after sorting, and the algorithm will bound on not the length of the durations but the amount of trucks. So read inputs, sort the array, and then... 

Make new list, , . The application shuts down. Please test your code before putting it up for review. You'll get higher grades too, especially if you show your tests to your professor or whoever is teaching you. 

And these two pieces of text. If you could remove those differences, or somehow extract them from the section of code to another place, you could merge the two sections of code. Having less duplicated code is good, because if you would have to make a change, you wouldn't have to make it in two places. For this, I'd add a method to : . That way, you could print . Implement in as and in Human as, well... your choice, maybe it just returns , maybe it returns a string the player has entered at the start of the game. Then, you could use an array or a to do this: 

In drawRoute, you first declare , and then after the for loop, you assign values. I think it'd be better if you moved the creation of so that it's created and used in one place: 

This snippet contains "John" twice, which I think is strange. You already have the person's name stored in the person, so why does a have a name? The security role having an id is more plausible, but I don't know what you're going to use it for. There's no mention of it in the requirements, so I don't know why you put it there. 

Use javadoc-style comments for method blocks, it allows IDEs to apply the documentation you write for usage during programming. Looks like this: 

It records a user's bid on an item. You have to provide the bid and the item. Also, it might throw InvalidBidException (presumably because the bid is invalid). And it returns void, so I guess the recording is "saving" or something. There was no new information in the javadoc, as a result the javadoc is just meaningless noise. I don't blame you, from the problem brief you have no real business rules to describe here, but still. Don't put javadoc on methods just to tick a box. 

This function is rather messy - there are three cases, but the comments only mention 2. And the random return in the middle there seems like weird flow. Let's fix it. First, replace the with . 

This sort of statement, I'd wrap in a function. Bit manipulation tends to be very low level stuff and looks out of place in a function responsible for doing high level stuff. 

Looking at this segment, you seem to be iterating over a set of columns and then rows in order to make tiles. Rules-as-written, the game seems to work on a set of tiles that doesn't have to form a square, as you could have a total of "14" and a column count of "4". But you do work with columns and rows to make some sort of 2D playing field, so why not use two for loops? 

And people will always be forced to set a device. With you can even make them not pass in a null value (you can also write the check yourself, but it's easier with . 

then you'd be able to get rid of part of this duplication. To get rid of the numbers, you'll probably want to use a List. 

All you gotta do is make a 2D array, populate it with the right values (enum?), and alter your method to use the lookup table. That solves your complexity issue, your implicit data storage (you're trying to algorithmically map the values of 3 variables (card 1, card 2, dealer up card) to a lot of different values), and it should be a speedup too. Plus, what are blackjack explanations doing in your code? Note that you might have to split your lookup table in three sections: One for the doubles, one for the case where you have an ace, and one for the last case, where you need to use the total of your hand. 

And, save for the "air" option, they're all really bad choices! Exceptions for regular cases, infinite loops, program exits... what's so bad about ? Back to Employees for a moment; say I want to generate a report that tells me all the costs I spend on Employees per month. That's salary, compensations, bonuses and all that. I sure hope there's an alternative data source out there, because the only way I'm gonna get to that data is by pretending I'm going to display it. I guess adding up all the salaries is gonna be done by casting String to int again. It's also weird that I have to delete the old employee if I want to give them a raise. You also have the issue that your views are stringly typed: if you wanted to prominently display Job title at the top, you'd have to filter via . And if we ever change it to or or or then guess what, we're going to have to go back and change everything again! IDE's may or may not support this refactoring, so chances are you'd have to do all this by hand. 

A minor bug: You get an for an empty list in . You don't have a comment stating you need to input a list containing at least something. Consider returning and adding a comment. 

If you'll read the documentation, you'll find a method which sets the internal buffer to the specified string. Basically, it combines creating the buffer with appending the first string to it. You could make use of it here to simplify the code to 

I also implemented a listener that waits until a process dies, which will be used to schedule cleanup for any missed files and then to restart the process if needed. I did research as to what would be the best way to know when a thread dies, but all I found was "make the thread notify listeners as the last task". This introduces a vulnerability where if a thread dies, nobody is ever notified. And I don't trust all subclasses of to never fail with handling output. ProcessListener