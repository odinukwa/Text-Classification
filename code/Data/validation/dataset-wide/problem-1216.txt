The dependencies are . The functions at are more reusable than those at are more reusable than those at the highest level . Complected. I'll reflect my bias: If a function is so complex it is hard to name, it might need to be refactored. The place to start is with a function [let's call it ] that takes one item from and modifies atomically. Then the existing function can focus on operations at the level of the collection. Conceptual mangling of the three levels - processing a collection of possible changes versus processing one possible change versus comparing two items - is clear from the description of the 's behavior in the question. A lot of it is at the level of processing a single URL against a collection of URL's even though operates on collections. Some of it is about dealing with two URL's. The naming should flow from smaller pieces to larger pieces. Or could just be 

Unfortunately, it is up to the candidate to guess the purpose for which a question is asked (and that involves interviewing skill more than technical skill). But in general, a take home problem will tend to be designed to determine relevant technical experience. It's also worth noting that companies that are worried about candidates "cheating" do not trust their interview process to produce reliable technical evaluations. find_index as an interview question Because the specification of allows for a range of implementations it is probably not a FizzBuzz. It is most likely a How much relevant technical experience does the candidate have? type question. One of the features of is that it will reflect the candidate's knowledge of the Python built-in functions much as a similar question in C might reflect a candidate's knowledge of C's standard library. Some candidates will start solving the problem by writing code. Some candidates will start solving the problem by looking at Python's module. Depending on what the interviewer is looking for, either approach might be preferred. For example, might be a FizzBuzz type question on iteration in a whiteboard context and a "relevant technical experience" question for Python's Standard Library in a take-home context. 

Highlights Note the use in two places where a symbol bound to a function is passed as a parameter to another function: 

Modularity All the definitions are in the same lexical scope. For example is in the same lexical scope as even though the only place is referenced is within . In addition is defined between them. Organizing the code: 

Efficiency Correct code is the first order objective. Writing clear code facilitates that because it makes debugging and testing and maintenance easier. Speed of execution matters only when it matters. That is always after the code is correct and after there is an objective performance issue, not just a theoretical one. Getting a wrong answer fast may be worse than no answer at all if we mistakenly believe the wrong answer is correct. 

[Disclaimer] This review does not address algorithmic issues. Indeed it dismisses them as inappropriate. To avoid confusion, it should be considered a partial review. Two Conflicting Goals At the level of abstraction where the choice to use Scala makes sense and discussions about idiomatic Scala make sense, the idea of implementing a bubble sort does not. The decision to use or not use Scala is typically based on programmer efficiency. Decisions over sorting algorithms are typically based on computational resource efficiency and raw execution speed of critical sections. Idiomatic Scala is a State of Mind Trust in the JVM and faith in the sound engineering practice of profiling code before worrying about tuning performance is part and parcel of a wise decision to use Scala or similar languages. We've given up micromanaging memory for a garbage collector and high level abstractions. Despite the Curly Braces Scala is not C. Applying "Fortran in any language" with C in Scala will not produce idiomatic Scala. Applying it with Scheme won't either. Writing Ruby in Scala is closer to the mark. Only Write Code that Matters The idiomatic Scala would look something like: 

Nodes are necessarily properties of Edges. Edges are not properties of nodes. Edges are [ properties | fields | objects ] of a graph. The dependencies are: 

Is "tree recursive" and therefore does a lot of extra work. Tree Recursion is described in The Structure and Interpretation of Computer Programs. Section 1.2.2 has a very helpful illustration that shows how tree recursive algorithms wind up performing substantially more work than is necessary. Remarks People often describe Structure and Interpretation of Computer Programs (often called "SICP") as a book about the language Scheme. It isn't. It is a book about computer programming and probably worth reading for many programmers. It just uses Scheme because Scheme is both powerful and easy to use. For example, SICP does not dive into Scheme's Macro system. It is also worth looking at section 1.2.1 on Linear Recursion and Iteration. SICP is a reasonable introduction to the way good recursive algorithms can be written. 

There are lists and arraylists, maps and hashmaps, etc. These are in addition to all the different object types. The multiplicity of data structures adds complexity and impedes reasoning in terms of the underlying mathematics of the algorithm. Recommendations 

Now we do our usual modular multiplication: 11 * 4 * 9 * 9 (mod 13) = 44 * 81 (mod 13) = 5 * 3 (mod 13) = 2 (mod 13). 

Mathematics A graph is defined as a set of nodes or vertices and a bag of edges . The only relation between edges and vertices is that for each edge between vertices and both and must be members of . Dependencies Mathematically, a set of vertices is independent of the set of edges . Two different graphs and can be defined across the same set of vertices based solely on the difference between two sets of edges and . 

There are two levels to the problem: Computer Science and Idiomatic Programming. Computer Science The simplest structure for matching parentheses is a pushdown automaton. Pushdown automata consist of three parts: 

Tune the procedure for generating combinations for the problem domain. Tune the procedure for generating combination to those that are of interest to the specific question at hand. Tune the procedure for generating combinations to reflect structural properties of the data. Statistical analysis is a good place to start, try to avoid analysis that takes exponential time. 

are blocking and require further input from one of the players. Implementing The Specification This is a sketch of the game: 

A more direct implementation of the Scala code might use for both and . There's nothing wrong with using types to make writing correct clear performant code easier. Recommendations Think about how much effort Odersky invests in making his code understandable. There's thirty minutes of video. There's the hours of video that come before it in the course sequence. The coding session starts with diagrams explaining the problem. Those are habits that are worth emulating. Following what Clojurists on the internet espouse doesn't make one an expert [I am aware of the irony]. Clojure is the product of Hammock Driven Development. Extension I'm a big fan of Lamport's idea specification as the starting point. One of the issues with Odersky's generalized approach is that it doesn't quickly trim the search space. Consider the case with two glasses: 

Disclaimer I'm less concerned about how Pythonic the code is than how understandable it is. A Few Observations 

Further refactoring is possible, but not shown to make the high level structure read more clearly. Semantics In the review code there is a bit of disconnect between the form of the output and the execution path of the implementation: 

Each diagonal gets clipped at the board boundaries based on the distance of the bishop from the edges. The distance of the bishop from the edges is defined by it's coordinate value. 

The object hierarchy, instead of hiding the implementation details at the lower level of nodes and edges, exposes them at the higher level of the graph. Redundancy Redundancy occures in two forms, abstractions and data structures. 

Getting user input can be dispatched similarly by the dictionary. However, the initial state, threading might be justified so that doesn't block or vice versa...that's IO for 'ya. Recommendations 

Abstractions When working with collections, there are three layers of functions - each essentially justifying a module: 

Minor Point Because , it may not be necessary to use ... depending on the implementation, of course. 

It's worth noting that at this level of abstraction there's obvious isomorphism between the and the . Fine Grained Objects Each step of the process has a corresponding fine grained record type that captures the individual items of the aggregate. 

Computer Science In terms of functional programming, the use of recursion is a step in the right direction. However the recursive code calculating the Fibonacci values: 

It doesn't concern itself with how the transformation takes place or what the long term implications of a particular implementation might be. Simple Business Centred Model A receipt documents the exchange of goods for payment. So a sound business doesn't produce a receipt when an order is placed. The receipt is generated only after the sale of the ordered items. 

Alternative Implementation The problem can be met using list comprehensions. Since this approach does not use a binary tree either, it may not meet the specification. 

To address this last class of cases means going even further, and by 'further' I mean looking outside of Emacs Lisp. ANSI Common Lisp implements it's function to take an arbitrary test for equality and this is the sort of thing that might be useful. And since we're already writing a function...how hard could it be to add that flexibility? An Implementation of value-in-list Like most questions that start with "How hard could it be" it turns out that it is not as easy as was initially thought. In this case because there appears to be a 'bug' like behavior as documented in the comments. 

This review is in response to the request for help on "overall coding practice." It does not delve into the syntax or semantics of the C++ language. There are three levels: Computer Science, Architecture, Variable Names. Computer Science Technically the implementation is not a stack because: 

Clipped Cartesian Space A bit of Linear Algebra Since it was mentioned in the question, perhaps there are some useful abstractions there. It is possible to think of and as two matrices. Each has two columns and an infinite number of rows. Going further can be transformed into the other matrix by the 2x1 matrix [1,-1] where the values are arranged in a column. Going back to the original Cartesian grid, we translate the solution for the portion of the diagonal lying in one quadrant, into the relevant diagonal for the other column: 

The problem with Dijkstra’s Algorithm here is that there is no guarantee that the target node is connected to the graph, and the code does not appear to handle unreachable goals in an informative way, e.g. 

These programmer defined data types automatically provide functions like and that align with the business logic and require. During debugging, a programmer defined data type provides something explicit to inspect. As the code evolves it provides a single place to implement changes, a known type to pass among procedures, semantics for creating a list of easter bunny headquarters locations, or hash table to memoize intermediate locations. Formatting Racket also has a style guide. It is typical to limit line length to 102 characters. For example: 

Knuth has written a whole book on strategies for solving combinatorial problems. He didn't find a general solution. He doesn't believe that he ever will, and he encourages readers to contact him if they do. 

and the specification suggests that the method use an existing implementation of a binary tree. Remarks on Code details 

1: The name is as type agnostic as . I would have used but it is the name of a built in Python function. This can affect syntax highlighting in the editor. 2: I don't believe in self documenting code, but calling the output is an exception. 6: The short circuits. The slice covers all the logic of what to do when is matched in the source. 8: This bit of cleverness is why the absence of comments makes code harder to understand. Remarks: The code does not have a code path for a null/false pattern. Based on the specification, I consider it undefined behavior. There are some things I like about C. Practically speaking, in the context of an interview, "What happens with null pattern?" might be an interesting request for more information...then again, what happens if the pattern is not iterable suggests that treating it as undefined behavior might be reasonable in the context of a technical interview. 

is the sort of code that is hard to understand and hard to maintain. Perhaps to the point where it is better to forgo the user friendly approach? Nay! A thesaurus is a good place to look for synonyms. Although, Python lacks Thesauri, a dictionary will probably do. Now the game can be sold at Ye Local Renaissance Faire as Stone, Vellum, Shears! Indeed, a dictionary is a good way to map each possible game state to the next state. The code does in lieu of directly implementing the logic the specification uses to describe the final states. The reason is maintainability. The mobile version of the game will offer an upgrade to Rock, Paper, Scissors, Spock, Lizard currently in development. Once we get around to updating the dictionaries and the game will be done, profits will role in, and we will never have to work again unless sleeping on a stack of money counts as work. But Really, Why All the Ceremony? One of the real values that comes from using dictionaries is that a dictionary can be used to dispatch functions.