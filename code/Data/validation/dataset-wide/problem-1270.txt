As far as basic implementation. You've got it down pat. That being said, I do have a few suggestions that could allow your app to run more fluently. I assume that you are uploading these photos and that they aren't photos already on the server being accessed. 

The biggest problem with your performance is that your query is MASSIVE. And I mean it. Depending on the size of your database, you are going to see major performance hits from using the scalar function in your query. This is because it has to be called for every single row in the result, even if it isn't used. Creating a table-value function then using will greatly save you time in these 7 areas. Here's a great tutorial on using . The next biggest thing, you have several nested statements inside. The best thing your going to be able to do is turn this into a stored procedure and call that from the PHP. Right now, you might be having to send and make multiple trips across the network to retrieve the requested data. This slows you down immensely. With a SP, it would hit the database and then execute the whole thing without leaving before returning one piece of data. This article does a great job of explaining the Do's and Don'ts of SQL Queries. There are several parts of it that apply to your script. Hope this helps you speed up your script! I know it's been a while! 

You probably want to localize any environment changes. You should initialize your variables to a known state at the beginning, otherwise you could get the wrong result. You have a lot of redundant code that can be eliminated by using a CALLed subroutine You can use the operator to conditionally execute code if the previous command failed. I find it simpler than using IF ERRORLEVEL. You can save a bit of typing by storing code in a variable to be used as a simple macro. 

B) Your sendmail arguments look very suspicious to me. Normally values that contain spaces should be enclosed in quotes. Note that the routine above preserves the lack of quotes by using and instead of and . C) I don't know WinSCP, but I suspect it will overwrite any existing log file, in which case you could remove the prior DEL command. 

I’ve found that I’ve used both of these answers. I didn’t want to give one person all the credit as both answers provided helpful insight. @JS1 helped me find a valid bug in my solution and solve it. @200_success provided an excellent answer of alternative solutions. I completely understand the idea of separating the logic out of . I actually had an assignment a few weeks ago where I did this, I just pulled it inside this class for this assignment due to the reliance on access to the multidimensional array to calculate the topology check. That said, I don’t like calling the problem a topology check. I prefer to look at this as it is just an adjacency matrix. Unless it was called a topology, no one would know that this multidimensional array represents a network. For that reason, it might be smarter to define the class and then a class that holds the logic for , , and . From here, I both agree and disagree with @200_success. I love the simplicity that he achieved, but I would probably go with the first suggested name of as is too specific in my opinion. This same problem could be solved using a provided it was given the logic to check for it. Having said this, both answers provide learning opportunities and helpful insights into my programming practices and I appreciate both of them and the time their authors took to write them. I’ll update this answer with any other insights or answers that I find helpful in the wait time to select this as the answer. 

*As an aside, it's also a good idea to use an alpha value of 1.0f, instead of 255, because alpha is also measured on a 0-1 scale 

Not only that, but if you were to decide to expand or contract the board at any time, you could add or remove objects at a whim, and, so long as you release any references to the objects you put into the array, when the main array is released, it will release the sub-arrays, and the sub-arrays will release their objects. It really is quite beautiful. 

So long as you initialize the members of the multi-dimensional array, this is correct, but definitely not optimal. Objective-C has it's own array objects, which free you from having to make these ridiculous memory management decisions, and a dynamic, expandable multidimensional array is as simple as nesting NS(Mutable)Arrays: 

I see what your talking about there. That is way too many variables. After reviewing all of your methods, it seems the best solution might be to make an Object Class that would encapsulate the objects. Maybe ? Obviously add whatever variables are required to the below class, I just put what I saw. 

Mizech makes a good point in his comment, though. Typically, you don't want to pass special characters unless you absolutely have to. That being said, the tagging system means you will having # showing up so why force the user to input it? Why not just have them input the tag without it? On the server side you can take the input and append the # in front because you know it should be there. It's about only having to do as much work as necessary and if you have to regex before sending then it would be easier to just send and then add it on the server. 

You can use a FOR /F to parse out the command from the arguments. I would define a variable containing a delimited list of all valid commands. Then you can use simple search and replace to validate whether the user entered command is valid. Addition of a new command is as easy as adding the command to the list, and creating a labeled subroutine for the new command. I would use CALL instead of GOTO so that each routine can easily parse the arguments. The only disadvantage is CALL will double up quoted carets ( becomes ) Here is a basic framework that can easily be extended. Note that user entered will be corrupted (or expanded) because of delayed expansion. There are simple ways to get around this limitation with additional code. 

You could even parameterize the two divisors, but then a different algorithm is needed. Here is a fully parameterized solution that is efficient, though perhaps a bit obfuscated. I still use a modulo operation to test if divisible, but instead of an IF statement, I intentionally divide by zero to raise an error and trigger the conditional execution of the SET statement. Of course I redirect error messages to NUL to avoid unwanted error messages.. 

The rule in ObjC is "You own it, you destroy it." Because is an explicitly 'ed property, you own it. If you were to not destroy in , then your class would retain a valid reference to it, and it simply would not go away. (memory leak). *As an aside, switching to ARC will alleviate all of these headaches. 

Actually, they are completely equal (obviously sans the keyword on the constant define). When literal strings are declared , the compiler expands them out to a compile-time constant expression, which looks familiar to us all: -albeit with a lot more compiler magic thrown in. Nearly the same process occurs with macros, but with one extra step: replacement. Macros are placeholders, which the compiler replaces with the value you at compile-time, which is why CLANG can show you errors and warnings. Where the difference lies is how much work the compiler has to do to replace your abstractions, not in the "memory overhead" they will incur (which means there is absolutely no speed or performance to squeeze out). Besides, NSString* is a brilliant class cluster that's been optimized over the years, especially with literal constants, where a sort of caching occurs in the binary itself. That way, literals used over and over again don't get reallocated over and over again. Though, to make one thing perfectly clear: #define'd literals do NOT reduce memory overhead! 

6) You do not need to create an label and GOTO that label. Instead you can do either of the following: or . They are identical, and neither form requires an explicitly declared label. The only difference is that can take an optional argument specifying the returned errorlevel. 7) You should encapsulate the logic for writing an email into a subroutine that accepts the variable portion as arguments. It reduces the amount of code, and eases maintenance. 8) I've simplified your ERRORLEVEL logic by using an extra variable to store the return code. I also make use of the conditional && and || operators with FINDSTR - I find them to be more convenient then checking the ERRORLEVEL. But I didn't use them with WinSCP because the logic is a bit complex. Note that if the last command within a block raises an error, then it would cause the block to fire. That is why my :sendMail routine explicitly exits with a return code of 0 (success). Using the above principles, I would write the code as follows: 

Alright, there's a number of simplifications to the Utility Class I'd like to make before I continue: Your abstraction from (at least that's what I hope it is), is too expensive to not just use the corresponding C-code directly. You could even make your own method in C, and use the inline qualifier for faster code than calling out to a singleton 3 times for every color. Also, it is never good to name an Objective-C method "instance". Singletons usually use a naming convention that makes sense with their overall implementation (i.e. ). The following will generate a random for you between 0 and 1. Not only is it cleaner, but it's cheaper. 

Another beauty of NSArrays is the ability to swap-out objects into a new index of the array, so long as you don't exceed the array's bounds. See the "Replacing Objects" section of NSMutableArray's documentation. Again, as above, memory management is vastly simplified with an NSArray, than dropping down to a multi-dimensional literal. 

I can almost guarantee it is not doing what you think. The most it can do is set the ERRORLEVEL. However, The EXIT command expects a numeric argument, but you pass . The EXIT command returns 0 if it does not receive a numeric argument. I doubt you have a variable with a name of "0", so the EXIT command sees a string literal value of , which is non-numeric. It consequently returns 0 every time. Your very next command (FINDSTR), is an external command, so it will set the ERRORLEVEL anyway. There is no need to initialize it. 2) It is generally a good idea to enclose SET assignments in quotes. This guards against poison characters, and inadvertent trailing spaces. (There are some exceptions, but it is a good rule of thumb). 3) It is generally a good idea to always enclose file paths in quotes if a portion is a variable. You never know if the variable may contain spaces or poison characters. The value normally does not have spaces, but it certainly could. 4) There is no need to delete "%temp%\rdcto.txt" when you immediately turn around and recreate it. You can simply redirect using overwrite mode () instead of append mode (). This will guarantee you start out with a fresh file each time. 5) Why do you write the value of %MailDst% using a FOR statement? You can simply echo the value directly.