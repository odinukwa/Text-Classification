as you see I have 2 dialogs now. One was yours, the other is simply a folder browser. Judging by the code you provided I would say the FolderBrowser is the actual control you want and not the other. Either way you only need one. But they do the same thing. Once you've selected a Folder you then go to check the files in the folder. tells us the state your openFileDialog is in, not what the method does. We want all our methods to tell us what they do. Hence, Lets gander at that method now. Notice how each level gets more and more detailed, but we still aren't doing any nitty gritty work. It's just easy to read right now. 

I don't have much this moment, but if you could provide a little bit more information as to how things are calculated and what some expected output is that will help. I see that you are doing a C approach to this, and some of the C++ habbits are rubbing off in the C# code. Here are 2 things I spotted right off C# initializes values to 0 by default making this code a waste of cycles 

writing unit tests is getting to be very important. Employeers are looking for people who can write tests and use them. The above can be run in about 400ms. (and even if I add more tests it will still take about that long because the majority of that time was getting the JRE up and running) You may think that writing tests will slow you down, and at first you will be right. However once you get the hang of it and start doing it well you'll ask your self, how can i test this class BEFORE you even started writing it. The whole topic of tests is large, and there are some very vocal proponents of it offering the world. I believe it to be very worth while. 

and if you look at the rest of them they are all basically the same. You set the Words, and the Category and show the MainGameDialog. (side note I think you have a small bug in each of your click methods. I think you meant to use and not ) This could easily be extracted into a method and called by each button click. This would clear up atleast 40 lines of code. something like this is what i'm thinking. 

I'll leave it to you to make that test pass. If you get stuck there is a big hint in the UnitTest shown above. What i love about unit tests is that they are fast and tell you very easily if all your tests pass. Example your test should say this if you run it: 

This has 2 advantages. 1 is that it is easier to understand. 2nd is that if I want to change the behavior of what happens when I am going to show the game I can do it in 1 place instead of 10 (or more if you add more Categories) Dynamic Code This is probably where you will struggle the most at. Is making code that is dynamic. Think about this scenario. You want to add more Categories to choose from? How hard is that going to be for you? I can think of it being 3 new Properties for easy, medium, and hard. 1 new button and check box plus wiring it up. 1 new check for IsCompleted..and the list goes on and on. Kind of a major pain. This is going to require a design pattern of some type. In the end it would hopefully be as simple as making a new class that extends/implements something. Then your UI would update and pickup the changes, and life would be good. That is going to be difficult though. 

I know it's not much to go on and I normally give much longer reviews but there isn't much code to review. Here is the code I used to test against 

Moving on to MainGame, I hate to see deep nested methods. I would rather see a method inside at most the second nest. That would turn something like this 

I'm going to assume that this isn't used in anyplace other than your unit tests. Part of the reason you wrote it is because your class isn't testable. I would rather see maybe another class created that represents a point on your graph that would contain its point in space and its color. Than you'd return the two points and test that the colors are the same. Some pseudo code. 

I very much agree with Jakob about using MVVM as a pattern of choice with WPF. The two go very well hand in hand. Since Jakob mentioned it, this is as much as I will mention it. As your your code there are a few things you can do to clean up a few lines of code. 

in C# using lambdas is nice and easy. There are also a few shortcuts. You don't have to specify the type and if you don't plan on using the variables from the event naming them and implies that you don't care about them. this would make it short enough to inline it 

since @kraskevich already mentioned making new classes I will take it one small step forward and mention something I think all beginners should know and that is creating and using unit tests. There are a few different test libraries but they test in about the same way. For beginners it is that you would do a simple 3 step process of arrange-act-assert. I'll give examples pertaining to your game in pseudo code to express my point. Arrange This is the simple act of making your class ready for a test. I'll use kraskevich's points here. He mentions making an argument parser. so lets assume you created a and a . You would arrange your test something like this 

For those who may be helping this is what I can figure is the class. I'll be editing again here shortly. 

There are three things I'm up in the air about. One is getting the Subscription by its primary key. I feel like I should pass in the POCO, then find by the primary key (I tried passing in the Dto in the find method but it said it needed a scaler object). The other is setting the initializer in the DataContext. I just don't know where to put it, and I need it because Entity was throwing an exception saying it couldn't change the table or something because I changed my Dto. Lastly I'm thinking I'm going to remove the Id because in the UI its not used, and in the Find method it isn't used. The UI relies on the name of the subscription so in my opinion 3 strikes and you are out. Thoughts? 

consider replacing it with this I'm going to assume that this was a mistake specifically because a few lines above you ask and if it did you split it up. Which means that your smallerTOkenValue should not contain any ',' Lastly I believe you can actually use a small form of recursion to simplify your code some (providing of course you split your big method into smaller methods). below is my final outcome. (I have not tested this, as I'm typing this in notepad++). Notice that the second to last method uses calls itself. 

Worried about the code not working the same? Look into unit testing. I wrote these tests (using nunit) first before I changed 1 line of code and made sure all 9 tests passed. Then I proceeded to refactor until The code looked like it does above. 

Now in Program.cs in you'll need to make an instance of your GameGraphic to make use of it. But before we do, I want to introduce you to another type of class. A test class. Unit tests There are many different TestFrameworks available so you can search for them on your own (NUnit, xUnit, msTest...etc etc). Even though I'm part of the NUnit team I'll recommend sticking with what is built into Visual Studio so that you don't have to learn about NuGet and all that it brings to the table (although it is also a good easy research project). So you've created a new Test Project (Create Unit Test Project how to). Now lets write a test for GameGrahpics. But wait! It doesn't compile! And even if it did it doesn't lend it self to a easy test. Grumble.. ok not a huge problem. Really we only have 1 test that we need to write, we could write more and with any thing it takes practice, but I'm going to write my test to make GameGraphics work the way I want it to. So here it is: