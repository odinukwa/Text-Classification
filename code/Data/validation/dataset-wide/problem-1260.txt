Recently I've been doing some experimenting with RPN and the shunting-yard algorithm, in order to test these systems more appropriately I planned on writing a tokenizer and then using these tokens to check validity and eventually get some output. I also think that I could use this to work with some primitive programming language, such as making a CHIP-8 assembler. Function The intention is for my tokenizer to separate the input string into a list of the following: 

From this code review I'm most interested in comments w.r.t the genSamples function, the program as a whole seems to work well for frequencies between 20Hz and 18000Hz although there are some strange distortions after that as my sin wave becomes distorted (normally I wouldn't be able to hear 18kHz+ but as the the distortions are clearly audible). Any suggestions on how to improve the wave generation functionality would be greatly appreciated. Note I am aware of PEP8 and I am less interested in the styling of the code as this was just a quick write up to test what I'd been reading and to try out a couple of things, the code will be tidied when I more fully understand what I'm doing and how I want to continue. Until then I'd appreciate it if just the functionality of the code were to be critiqued. Also note that the current setup of the code takes some time to run and any performance gains that are possible would also be appreciated. 

Doesn't work because you do not in the worker threads, i.e. the worker threads don't care and still access whenever they want. Plus some more issues which affect the functional correctness. I suggest you try and fix those first. You may want to have some read on Java's threading, especially about how and relate, what thread-management routines there are in (mainly thinking about , , and ) and when and how to use . It's actually not very complex, and pretty straight forward to use/implement in a simple case like your's. To improve your solution you could then familiarize yourself with and for inter-thread event signalling and/or ready-made data structures like s for data exchange between threads. 

The following is a .wav file generator that I wrote briefly while (re)learning about audio sampling: 

I'm working through some Project Euler problems using C++ and some of the numbers in question are starting to get quite large (21000 for Problem 16) and I need to add some of these large numbers together, so I quickly threw together a string represented (positive) integer adder: 

As a small suggestion, I noticed that your s have an odd line at the right hand side due to drawing them with the outline of an oval (as you noticed and commented in the function). You can fix that by instead using two filled ovals, a big one which is filled using and a smaller one filled using (Although this does require adjusting the to compensate for the missing width): 

Suggestion Don't run your checking code and wait for the result. Better have your checking code run in the background periodically (e.g. in a dedicated or a ) and have that code post its result back to any interested party. You can use a to send a message from a background thread to the UI thread. For example, send one message each time the connectivity state changes. 

This PRNG uses an arbitrary encryption algorithm to generate pseudo-random numbers. The trick is just that the encryption algo will return the same crypto text whenever the same plain text is encrypted with the same key. Because the routine used is usually employed for encryption, it operates on two parameters: the plain text and the key/password. In your case, there's no need to encrypt a particular plain text, but since the encryption function needs it as input, some arbitrary, but constant, "plain text" is given to it via the "ClearData" array. Because the Rijndael algorithm chosen here is a block cipher, it will always output a whole block of crypto text, even if, as in this case, the input plain text has zero length: 0. Your program then takes the first 32 bits of the block of crypto text () as the random value. This value should depend (pseudo-)randomly on the key, so that will yield a completely different value than with high probability; this way, there's no simple correlation between subsequent values of the RNG, which makes the output look like real random data. Another approach I once tried was using a simpler stream cipher (RC4) whose calculations can actually be completely reversed so that one may go back and forth through the sequence of output numbers as desired by either using the (normal) forward or the reverse operations. 

This indicates that a few of your opcodes may be functioning incorrectly (although it could be a deeper issue), it might be worth running your emulator alongside another to see how they compare. 

Following the review of my old merge sort implementation here, it appears that the biggest improvement to make was to use iterators instead of copying the s. Having never used iterators before, I'd like a review of the new code following that review: 

I'm writing a very simple engine which I hope to use to create a game at some point and felt that I needed buttons to allow the user to select options in a menu, so I wrote up a rudimentary button class. Think of this as similar to Windows forms if you like. Whilst what I've produced works and I can detect the button presses I feel like this is not the simplest way to do it (although note that I would like to do it myself as a learning exercise rather than using an existing library to produce the buttons). One of my biggest problems is that the buttons are done using rather than and so have a top left anchor and working based on window width and height in pixels rather than a center anchor ranging from -1 to 1, needless to say this makes rendering buttons a chore. Any advice on how to improve that alongside general scrutiny would be much obliged. display.h 

You create a new, private each time the method runs. The intention behind s is that they're created once and then used over a longer time span to execute multiple (short) tasks. This should save you from having to create a new for each task, because the executor manages a number of threads which get re-used for multiple tasks in succession. You don't need that . The usual idiom of the is like: Callable myCallable = new CheckConnection(...); Future future = service.submit( myCallable ); ... Boolean result = future.get(); It does not make any sense to a (single) task to an executor and then start waiting for completion immediately. This will block exactly as if there was no involved at all. In your case, you could just write with the same effect w.r.t. concurrency. 

Note that this would require a few changes to make it work but would result in there not being any recursion hidden away. 

Will not come out as the numbers they represent but can be reconstructed later on. But sequences such as will come out as making it easier to account for multiplication of variables. Questions For the most part I'm quite happy with this code, a couple things that I'm interested in (alongside general review) are: 

The tick rate of the CHIP-8 doesn't directly affect framerate, indeed frames act slightly differently than normal in that not all games will necessarily clear and redraw the entire screen. Perhaps a better name for this would be or and it may be worth increasing it to get a more playable experience. 

It looks like you should be able to compute the bit error probability once, in the initialization. Then that whole method would become . You could also replace the use of with your own, dedicated instance of and use its for example, or . Either should be somewhat faster than the double-generating version. Indeed, you can skip that boolean logic in favor of speedy bitwise , like 

Does not work reliably. is assigned when the corresponding thread executes that line; if it does or not before the next iteration changing is undefined and hence not guaranteed. 

I've recently started learning OpenGL and thought that a great way to start using it in its simplest form would be to create a Chip8 emulator using the keyboard callbacks and graphics that GLFW and OpenGL provide. As this question would be too large to request a review on my classes used with OpenGL and my Chip8 emulator, I'll keep it to just the Chip8. 

Is there anything that I can do to improve my function? I'm especially interested in the use of storage types other than and what the advantages of doing so would be. It should also be noted that I do have an intention of doing something like this in a however, as this was quickly thrown together for the solution that's parked for the time being. I'm less interested in my method of solving Problem 16, however any comments on that would also be appreciated.