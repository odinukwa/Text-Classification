Is really a valid month? If so, then you're fine, but I have a feeling that this would be more appropriate. 

Using a filter allows you to access the interface members. Of course, that means you'd have to go mucking around with the auto-generated EntityFramework classes making them all implement a common interface though. So, all in all, I'm not sure I'd recommend it. Boilerplate code is the price we pay for working with many frameworks. 

A really small style point to add to the other answers: I personally prefer over empty quotes. I think it makes the intention of the code more clear. At a glance, it can be difficult to tell if it's empty quotes, a single space, or if the original dev simply forgot to fill in the text. 

It looks pretty clean. As far as I can tell, you have a good separation of concerns. Everything is properly cased and your functions have verb-noun names. All good things. The only nitpick I have is the variable. I'm not a fan of ultra short names of any kind. You could call it or some such thing. Seriously though, that's a huge nitpick. I just couldn't find anything else to comment on. 

This is a useless comment. If the maintainer doesn't know the difference between and they can look it up. 

I like this function and the abstraction it provides, but you are calling it over and over and over to get the same string. Declare a variable and call this function once. Also, as an option, It would be completely acceptable to remove the variable and one line this function. 

I'm always a bit wary of "set only" properties. I would take a moment to consider why you're doing this and if there's a better way. If you've done that, and decided that this is good, leave a comment explaining why it's good. I feel like that was just a whole bunch of nitpicking though. It seems to me that you've really improved as a developer over the last few months. 

Which is fine. You don't want to use a boolean because you'll be adding more status codes in the future. Cool! But you shouldn't be hard coding the error code numbers. This is what enums are for. 

I'm writing a tool to create shortcut menus for an application that I maintain built on the Access runtime. I compile this app into an *.accde file, so much to my chagrin, all right click menus are disabled. After some research, I've been able to develop this tool to add the menus to the database. This code is called during development, not at runtime. I'm already seeing a lot of duplication, and am not sure what to do about it. So, I figured I'd stop and get some feedback before I started building all of the various menus that I'm going to need. Note: There is not a built in Enumeration of all of the different button types. There are thousands of them and I'm adding them to a self defined enum as I need them. 

One final note: I'm not entirely comfortable with the fact that the catch block doesn't actually contain any code. It feels a bit hacky. 

I don't see anything ugly about your module. If it was .Net I would use a () type class, and a standard *.bas module is roughly equivalent in VB6. It seems to have been the right move to me. What I do question is the usefulness of defaulting to the object's pointer as a string representation of it. Since VB6 supports default properties, I would take advantage of it. It's not exactly pretty, but perhaps a more useful representation of an object. 

You may not use it for formatting now, but you may want to do so later. Create your markup correctly now, and you won't need to modify it later just to change the style (theoretically). 

Will you remember what that means 6 weeks from now? 6 months? 6 years? No. You won't. It's often been said that the hardest thing in computer science and programming is naming things. It's true. It is the hardest thing, but it's also the most important. It's been my experience that the easy way is never the right way. You took the easy way out here, when you should be coding like the programmer who touches the code next is a violent psychopath who knows where you live. 

I would suggest storing it in a variable. That way, if the path ever needs to change, one change would cascade through all of the places it needs to without any risk of making a mistake in just one of them. The same could be said of the and literals as well. 

One last thing. Your error messages kind of suck. It's one thing to abbreviate variable names, but it's an entire other matter to abbreviate error/log messages. 

You can apply that through out your query. (In SQL Server I had to leave it duplicated in your Cross Join.) This subquery shows up a lot in your code too. 

Where the interface matches the public API of . This allows you to test your client code in isolation from the native library, which likely interacts with hardware/the OS. 

Please note that I do like that you're not using that Devil Between for your date logic. This is how I would write it: 

This way, if you ever swap the libraries out, you're truly insulated. You create a new class that implements your interface and it is much easier to swap one for another. If you make this small change, I'd say you've got it right. 

With just two keystrokes I've re-enabled the update statement. The single line comment on the closing marker prevents it from becoming a syntax error. I know it's nothing to do with your code or cursor, but this little trick has saved me cumulative hours, maybe days, over the years. 

Next up, you've broken Liskov's substitution principle, which is common for these kinds of implementations. 

I noticed this because looked really weird to my eyes. It's almost always seen as . So I looked around a bit and found this. 

Your comments indicate that you're using a pseudo-code driven approach. This is good, but the last (and often overlooked) step to that approach is to remove redundant comments. 

The other thing I would like to mention is the hard coded IP address. should take that in as an argument in its constructor so that the ip can be stored in a configuration file and injected in at runtime. 

One last note, don't use an infinite loop to receive the packets either. It's much nicer (and user less CPU) to use a to do this kind of work. It has a 15ms resolution but, then again, so does . You're waiting longer than that resolution anyway. 

By using ADODB to connect to the closed file and query the sheets. Then you can write the results of those queries to text file. 

The comment about the number of weeks should be much closer to the declaration. A better variable name would eliminate the need for this variable entirely. 

It's an interesting concept, but not exactly how I would expect this to be structured. First, it's superfluous to have an external function to return the middle of a circle when it's already available though it's property. I would expect a class method to move the object. Something like . If you're concerned with making the size immutable, simply set it in a constructor and disallow external access to the radius property. 

I'm not terribly familiar with directly working with pointers this way, so I have no idea why this uses . A well named constant would help a schmuck like me understand what's happening here. 

The Awful I'm chucking this under awful, but it's really not. It's simply the worst offense. You're using magic numbers for the Divisors. Minimally, use constants. For maximum flexibility, pass them as arguments and calculate the GCD for the first test case. You could even set them to default values using parameters as not to break existing client code. 

And ditch the hungarian notation. The variable names more or less tell me what type these are without those prefixes. 

First off, there is zero advantage to using single letter alias names. I know there are a ton of examples out there that do this, but don't. It only obfuscates the code. Particularly when your CTE name is only four characters long. Don't be lazy. Type these things out. Give a reasonable name, like for example, and don't bother aliasing it. 

Your exception handling seems really very good, but I'm not sure that it's entirely appropriate to use exceptions here at all. The code is using them to control program flow. Exceptions are for exceptional and unexpected behavior. I think would be more appropriate here. 

Which works, but isn't great. I would prefer "not Any" here. I find it's good practice to get into the habit of using . It's just more readable IMO. 

I take it back that "I'm not sure you're considering strings that could break your method". You're definitely not. It turns out that you're not considering group separators at all. You probably should be. These are strings after all. These are numbers in a format that could be expected to be as people would write them. All of the following numbers in string format will break your code. 

Before we can do anything here really, we need to clean this up so we can understand exactly what's going on. To start with, let's remove some duplication. This code is copy/pasted all over the place, but no matter what happens, it executes. 

This is not for the faint of heart, and I wouldn't want to tackle it without an excellent refactoring tool like ReSharper and a copy of Working Effectively with Legacy Code by Michael Feathers nearby. Best of luck. Remember, keep your changes small and safe. Don't change logic if you can avoid it and drive as many tests as you can at the code before changing it. (Although, you'll have to make a few changes to make it testable first... So... Slow and steady friend. Slow and steady.) 

Note that utilizing this strategy, you could likely implement all of the logic in one ctor, where it belongs. Braces Use them. Always. Take a look at this snippet. 

P.S. You don't use Hungarian notation anywhere except the variable. Drop the part and give that variable a more meaningful name. 

It's pretty obvious that you're storing seconds as an integer. The comments just clutter the code and make it noisy. In there's a lot of repetition. I would use a loop here instead. 

You had asked how you would replace the and tags with CSS. I haven't worked the links out, but given some markup like this. 

If you look carefully at this, you'll notice that the only difference between these loops is the source column, the destination sheet, and the destination column. 

I haven't done any web dev in a very long time, so I'll leave your actual question to the experts. I just want to point out a small style point. Your variable assignments could use some breathing space. 

This is good. I like well named constants. These are implicitly Public though. That means they're available to all scripts. Which is also okay. I see no reason these can't be, but it's always better to be explicit and declare the scope. 

A method that starts with should never be saving anything. No side effects. If I call , I expect it to retrieve me a Foo, not save that foo to the database. 

I shouldn't be selecting all like this. Even if there's not really a performance hit because open query needs to get all of the meta data anyway, this is a bad habit to get into. Selects should be explicit in what we're selecting. 

Side Note: The methods you wrote to traverse and search the tree look like they could be cleaned up with some Linq. 

This a good candidate for a temporary table. I don't know how to create and populate a table in MySQL, so you'll have to look it up. The query should flow something like this though. 

Finally...... Performance: You can set the recalculation of the sheet to manual prior to running the code. It will only make a large difference if your code has a lot of formulas, but it's worth a shot. Just be sure to set it back to in the "CleanExit" part of your routine. 

Which brings me to recommending that you use ADODB for this. The only time it's really important to stick with DAO is when you intend on binding a form to the resulting Recordset. Instead of concatenating all of these parameters into strings, you could instead be passing parameter into parameterized queries. It looks and reads much better than this. 

The truth is, it's really very hard to refactor this code out of the code behind once it's been written like this. I would suggest that you start writing your tests first, for now at least. The benefit there is that you have to design your code to be testable to begin with. If you decide later (once you have an idea of how to better design your code), to test after the fact, that's fine. The important thing right now is to separate the concerns. You need some Model-View-Presenter in your life. It's more or less the default design pattern for WinForms. There are two flavors, passive and supervising controller. 

I've got to say, I didn't even know that properties in a standard module would compile. They're typically reserved for classes. You've created well encapsulated and abstracted code, but I would change those properties to functions to lower the surprise factor. 

If you stick with the regex to do this, you'll find that you can use an almost identical pattern for several implementations. For a hypothetical you would have this: 

Neither of these should be Public. Nor should they be variables. They're constants and should be declared as such. Let the compiler warn you if you ever try to assign a new value to these. 

I’m relatively certain this only works by accident. The default value of an int is zero, so I’m actually uncertain of the actual behavior here (and I’ve been using C# a long time). Consider the alternative code. 

And call it from . Continuing doing this until each method has exactly one responsibility. You should end up with code that looks something like this psuedocode. 

I'm sorry. I just can't follow the logic well enough to give you a query closer to what you'll actually need. You might also want to consider creating a new temp table to insert data into temporarily. Once you have that the way you want it, you can delete all of the records from instead of trying to preserve just one record. 

It's time for a . The old code had only two cases. "If doc type else..." Now we're looking at two special cases, it's time to . The insides of those switches need extracted into private methods, and . The logic is non-trivial enough that doing so would both clarify things and contain future changes. Prevent the spaghetti! I'm not convinced that should be public. It seems like an implementation detail at the moment. I wouldn't expose it until you're ready to expose it's been thought out as part of the API to support other features of the app. This line should be extracted into a well named private Boolean method in order to clarify the intent.