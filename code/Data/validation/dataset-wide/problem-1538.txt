Style Python has a style guide called PEP 8 which is definitly worth reading and and worth following if you do not have good reasons not to. In you case, your usage of empty lines for instance is not compliant to PEP8. You'll find tools online to check your code compliancy to PEP8 in a automated way if you want to. Code organisation You've written your code in classes which is sometimes a good thing. Sometimes, you don't need a class. In any case, most of the things in the class could be extracted out of it (also removing the need for many ). By the way, it may be interesting to point out that variables defined at the class levels can be pretty complicated and are not entirely needed and could be simple global variables. Also, you have variables that are not used at all and you should get rid of them. Once everything than can be moved out of the class (and renamed) is moved out, you get: 

Also, your function looks like the typical situation where you could use the / Python builtin. However, because of the length of the expressions involved, it becomes a bit of a matter of personal preference. I'd write this (but you don't have to like it) : 

it looks like we are doing the same thing twice but using a different value. You could easily rewrite this with less duplicated code (the variable name introduced is terrible): 

If the first condition is false, I guess the second condition has to be true. Just use a simple . Remove useless conversions Because your code is so convoluted, you lose yourself and you tend to forget what the objects you are handling are. 

Not quite an answer but too big for a comment and it seems important to let you know that your examples do not work - at least not on my config. Here's what I have (string1, string2, actual result, expected result) 

This is a classic example of algorithm where we can define the number of elements with a property without having to enumerate them. You can either save the two last results as you progress or you can keep track of the result for each index in an array. This is up to you. Reusing your exemples and adding more : 

Oops, I might have gone too far . Actually, we can go even further to handle the trailing whitespaces in a smart way : 

What you've done looks good to me. However, here's what I would do if I were to write the same function : 

Simplifying operations Instead of divising by a fraction, it may be easier to perform a multiplication and a division: 

Now we can get into the internals of . First, you could get rid of the various way where printing is repeated. 

the line definitly shouldn't be a list comprehension as we are building a list that we do not use. If it is side-effects we are interested in, we might as well use a . 

Don't repeat yourself (again again) I have to repeat the whitespace in the different elements of the list I a using. This is easy to forget if I ever need to add an article. Let's add the space as part of the logic. 

On top of the comment from jonrsharpe, I'd like to point out a few things about the code to generate the initial list : 

This also removes the need for an argument to know whether this is the required input is asked for the first time or not. 

Then, this looks like a scenario where we could use /. The obvious way to convert the code above is : 

When you perform both a division and a modulo operation with the same values, you can use the more concise and faster builtin function. 

Starting from taking into account janos' really interesting comments about flow control and style, you have : 

Something I had forgotten can be rewritten . On Python2, this is much faster (because a list is generated and then we perform a linear search on it). On Python3, the performance impact may not be so big. 

More performance This is pretty good but we haven't really changed the complexity of the algorithm. It used to be and it still is. Only the constant factor has changed (basically, we still perform a huge number of operation considering all bacteria for all inputs, we just handle them in a more efficient way). What could be interesting (and is probably what is expected by the people who wrote the problems) would be to prepare the dataset in such a way that for a given input, you don't have to reconsider all bacteria again and again. The point would be to be able to create some kind of summary of your dataset in such a way that you can easily determine the information you need. Basically, it boils down to determine how many items in a list are smaller or bigger than a value you'll be provided later. Indeed, the solution of the problem is the sum of the number of such that and the number of such that . An interesting idea could be to create a sorted array of the values and a sorted array of the values (don't forget that in order to have this trick to work, you first have to re-arrange in such a way that ). Once this is done, the number of items smaller (or bigger) than a value can be determined with a binary search algorithm. Unless I am mistaken, the complexity for such a strategy would be : because sorting is and binary search is . This should be much faster. I'll let you consider this :-) 

Then, because there is not point in adding spaces because all elements of the array already end with a space, we can do : 

Logic simplification The comparisons seems complicated but it is actually fairly simple: you compare 2 values and consider 3 situations: they are equal or the first number is smaller or the first number is bigger. To avoid repeating (and computing) the different numbers, you could compute the difference once. 

Then, you do not need to repeat before each and every use, you can do it once at the beginning of the function and that should be enough. Also, can be written in a concise way in Python : if apple_num in [3, 2, 1]if 1 <= apple_num <= 3`. Then, you can write instead of . You can simply write instead of . You should try to avoid writing the same condition twice, it makes things harder to understand/maintain. For instance, you could write : 

From what I understand from your comment, using did solve your problems. Here are a few suggestions anyway (that you may want to take into account before submitting a new question with the updated code): 

I think the main issue here is that you are trying to reuse snippets from Google without trying to understand what is doing what. Magic numbers This might be purely personal but I find much easier to understand than . Do not repeat yourself What is the point of having if later on you rewrite ? You could write it : making obvious to everyone that the same format is used. Useless conversion between strings and dates You are converting dates to string and string to date in a convoluted and probably not required way. Usess conversion to int You are using but is defined as which is an integer anyway. Also, I am not sure you would need the conversion of as an int. Taking into account the different comments, my resulting not-tested code looks like : 

Making debugging easier Now that you know that your code is wrong, you might as well try to make it easier to debug. My suggestion is to work with strings until the very last moment so that you can print it whenever you need. At the end, you just need to get the length of the string and you are done. 

The right data type Your store unique palindroms in a list. In order to do so, you check if the string is in the list before adding it. You should use a set to make things easier. 

You probably should fail in a more explicit way when given an invalid connection mechanism. More generally, having the function called from anywhere makes things a bit hard to track. 

I think a more precise analysis of the mathematical property would lead to a smaller search space. In fact, because corresponds to the smallest side, we could write: and . Warning: from here, it's just me trying to apply random (and simple) math operations with no promise whatsoever that things will get better. By limiting the number of times sub-expressions are computed, one could write (but I do not find this very beautiful): 

This version, just like yours, does not check the validity of the initial . This may be a desirable check. Then, you'd write something like: 

I guess I got lucky (or inspired) because the value leads to a bug. I guess that should be . Different algorithms - string_to_int When you convert, let's say "1234" to an integer, you are currently saying something like :