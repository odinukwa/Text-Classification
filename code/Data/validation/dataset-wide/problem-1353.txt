First, note that this is all untested, but the ideas should hold up. I tried to abstract a lot of the logic by distilling the object creation to a dictionary containing the data, but it turned into a bit of a mess. To start with, consider the following structure for your object data: 

We can't increment any of the 's since isn't a digit. Thus, we must increment the . From this, we learn that 's can't be incremented. 

The biggest improvement you could make is to generalize the two-gram, three-gram, and four-gram functions, into a single n-gram function. This can be done with using lists instead of manually assigning , , and so on. 

Decrement The next challenge is to find the digit to decrement. This turns out to be simple: decrement the first non-zero number on the right... 

Now you don't have to register each effect in your dictionary after the function declaration and this should clean things up a little. Additionally, if you import this object, you can add functions anywhere, easily see what effects are registered, and you can add logic to the class itself if you want more complex behavior (i.e. address the case where an invalid string is entered). 

This does not seem to be the intention of the code. Assuming you want to check all lines in either and you may want to use the following code: 

Sort But wait, this decrement function suggests that we turn into and turn into . This clearly isn't correct. While the outputs are larger than the original and the digits sum to the correct value, they are not the respective minimal solutions. However, if we sort all of the digits after the incremented digit in ascending order, the minimal solution is achieved. 

I think that at this point you might be thinking at how you could obtain an instance of . I think you should use some sort of factory or build it using reflection depending on what is better in your use case. 

I don't understand the reason why you need . What you need are concrete classes imlementing your interface for your specific types. Imagine you want to map a to a . You need something like this: 

First, a general consideration about your project. I cannot see any unit test. I'd strongly encourage you to write some, as I think that unit tests can help you coming up with a better design. I haven't looked at the code in details so unfortunately I don't have other comments on that. Looking at the example main you posted I see you should try to rewrite your code so that you do dependency injection and in a way that you don't have to violate the law of Demeter to setup the simulation. What about changing the constructor of to ? If you do that you make it clear what you need to run your simulation and you can avoid doing the very ugly operations involving . I am not sure what you want to do with all that calls to , but they don't look quite right to me. I think that the idea of having take a as a parameter is good, but I would not expect it to be called in that way. What about this: 

Sure, you could remove the global variable by moving the memoization to a decorator and adding a base case scenario to the function. 

To be honest, I didn't read through your code much because I don't have the attention span and it seems the biggest issue is the approach rather than the solution. Nothing about your code looks terrible or un-Pythonic, so I'm going to go through a different approach instead. The first thing that I noticed about the next number is that all but two of the digits of the original number remain unchanged. When going from to , the was incremented to a and the was decremented to a . When going from to , the was incremented to a and the first was decremented to an . This pattern suggests that we may be able to increment one digit, decrement another, and arrive at a solution. The first challenge is to find the digit to increment. Increment 

Finally, we want to create a decorator which will do the following things: (a) create all of the objects, (b) generate and enter the required contexts, and (c) execute the supplied function. 

We can't increment the because we can't decrement any of the 's. We can't increment the right-most 's because then decrementing the would lead to a number less than the original. Thus, we have to increment the first . We would reach the same conclusion if we considered the number instead. From this, we learn that trailing 's should be ignored. 

I'd structure your program in a slightly different way. First, instead of passing around two arrays of , why don't you introduce a data structure and work with it? It would save you from checking that you get passed two array of the same length, which looks quite neat to me. I think you could also consider introducing a data structure to hold your pair of slope and intercept value. If you do that it will be much clearer what your function does. Since you eventually want to have a function you can play with, you could create a . In this way you decouple the computation of the coefficients that best fit with your data and the construction of the corresponding curve. This enables you to play not only with the curves you fit from data but also with curves you can define from their coefficients. I think that a nicer way to compute the value could be by putting as much math as possible in some temporary variables you define in the block. That could allow you to separate the high level computation you need to perform with all the other smaller steps required to compute some other intermediate results you need. If you apply the changes I suggested you should come up with code similar to the following: 

In I'd probably move the declaration of and of in the block. You're not going to use them outside that scope so it could be a good idea to give them the smallest scope possible. 

Having a function mutate a global variable is a bad practice. In this case, it may seem easy enough to reason about what is going on, but I guarantee that at some point it will lead to an insidious bug that is hard to track down because you have no idea who is changing the global variable and when. Recursion is not necessary here; it over-complicates the solution and may make it difficult to change/update the code. 

I don't really understand what this function is doing, but it seems messy and could likely be improved. Then your function can be greatly simplified. 

Here, the "inc" and "dec" operations were abstracted into a dictionary of . This is slightly more complicated than it needs to be (one could simply invert in the "dec" case and add the result to the register), but allows for other operations to be easily added. The end usage would look like: 

We can't increment the because decrementing any other number would result in a number that is less than the original. We can increment the , because we can then decrement the . From this, we learn that the right-most digit should not be incremented. 

With this approach, the same result is achieved, but with much less code. Combining this all into a single function yields: 

These do the same thing, but are much more readable once one knows that can be used to iterate over both the index and element at once and that is a common method to iterate over a list backwards (albeit, slightly inefficient). A final note is that I have updated all two-word names to use snake-case.