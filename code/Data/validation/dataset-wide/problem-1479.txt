Well, the calculator one at least could be simplified since you're always adding/subtracting the same: 

Your unit tests for now only need to be concerned with the results of - which verifies the was constructed properly (an important bit to test, since it's weakly typed). You can dress it up with generics, extension methods, builder patterns, etc. - but that's the basic pattern. 

Now, we'll need something to keep track of the inventory levels. We could use a simple for this, but let's go ahead and abstract it out into an class, so that we'll have a place to put some convenience methods. Since we know we'll need to be able to remove an item by name (not caring about the price), we'll need some help to find that entry. We can also add some convenience methods around adding a product. 

We are given two list on integer arrays, and the objective is to retrieve another list which contains the duplicates in both lists. The code developed is the following: 

So to conclude, an interruption should always be as short as possible and only used to manage flags which alter the behaviour of your main code block. Hope this helped, comment any question that you might have with what I've explained. Note: The code only wants to give you an idea of how to manage interruption, so it may not be the one that fits your needs. 

The code works as intended what I am concerned about is optimization, how to improve this code in both, execution time and stability. What I am doing in this code is compare each element from one list with ALL of the elements of the other list (I see a problem here, but don't know how to approach it well, the foreach seems not to be the best option here). 

the rest just sets up the boundaries (i.e. the kth limit). So once you have seen a bit of recursion, you intuitively zoom in on the important lines and sort of 'ignore' the rest :) As a side note, there is a slight gotcha with using recursion in Python: Python has a recursion limit of 1,000 calls. So if you need to recurse on large numbers it will often fail. I love recursion, it is quite an elegant way to do things. But it might also be just as easy to do the function as an iterative function, or using a generator. 

Other than the few things pointed out above, it might be 'cleaner' to use a helper function to test primality. For example: 

I see a major flaw in this code right off the bat and that is your interruption management. In my opinion, you are not treating an interruption as such, you are treating the timer as a function instead of a source of interruption in the behaviour of your normal code so a question arises. 

To explain this array, the first dimension of the array declares the amount of messages stored, while the second dimension declares the amount of languages one can output the information. So, if we would like to print in any of the languages, the following line would just do that. 

The problem here is the lack of functions or subroutines to avoid repeating code, thus making the code less mantainable. There are here other issues which are also important, for example, multilanguage support, which I'll address in the following To carry out multilanguage, I would declare an n x m array to store the n strings in m languages. To provide an example of what I mean, to store the greeting message, an array like the following needs to be declared 

If you're familiar with inheritance, hopefully you can see how you could add that functionality into a 'PersistentInventory' subclass. Hopefully, you can see by splitting the functionality out cohesively both readability and maintainability. Think through adding the following functionality in v2 of your app with the various designs: 

Now that we can see that we're looping over all the rows for each , we can change to traversing once and pick up any along the way. This effectively flips the order of iteration (I'm assuming there's more rows than query strings). To get rid of the nested loops altogether, we'll switch to using to find any matches. We'll also drop the check on each iteration for a single call at the end. That should keep us from iterating multiple times. 

I've made a Collatz Conjecture sequence calculator and I would like some feedback on what I can do better in regards to the code I've implemented, i.e. bad practices you see, improvements that can be made to make it faster, errors that might arise from this code that I am not managing, etc. 

First and foremost, You now don't have to worry if it takes longer for the code to execute than the timer to fire, since you have control over whether or not the program has to read from the ADC. Secondly, your program can execute many things while the ADC performs a conversion (essentially we've made the ADC conversion a task which we launch and later ask for its result), this might remind you of asynchronous code. 

There is more than likely a more elegant way to implement this using list comprehension. But conceptually, does this work for your needs? 

EDIT Added loadData(); slight tweak to return a dictionary of dictionaries, instead of a list of dictionaries: 

as you say, it does look like this code is doing exactly what you want. But it also looks like you are repeating yourself in a couple of places. If it was me, I would prefer to loop through the file only once and check for both and at the same time, and then only print out if the sample text is there: 

Now, I know you didn't want any "fancy-pants" coding, but this is actually really really similar to your iterative approach, just using recursion. If we look at each bit we have the following: : this tests whether the value is prime or not. Just like in your code, it takes the modulo of against all of the primes up to the square root of . This isn't too tricky :) The function gathers all of these tests and returns a boolean (True or False). If all of the test (from 2 up to sqrt(x)) are False (i.e., every single test confirms ti is prime) then it returns this finding, and we know x is prime. : ok, this is recursive, but it isn't too tricky. It takes 3 parameters: 

This code would make the greeting valid for both languages, while also making the code more mantainable if you want to change the greeting message for any language/s by having all the messages in the same place. Keep in mind I substract 1 from since arrays are zero-index based. Implementing language this way can save you a lot of code, make it more readable and also more mantainable since you don't have to look in n lines to fix an error that has propagated through all your languages due to copy pasting code. This can be applied too to handle any amount of users, further reducing your code and making it, again, more manageable when maintenance or improvements happen (which you are bound to do). If you need help in developing anything, comment my post with what you need and I'll try to give you an answer as clear as I can. Hope this helped explain how to handle multilanguage. Note: To ease the maintenance of interface messages, you can switch the matrix, n for languages, m for messages, that way you will have in the same first dimension the same message for all the languages, rather than having all the messages for a language in the first dimension. 

It seems that you are looping through the entire job data set 3 times (once each for salaries, descriptions and titles). You will be able to speed this up three-fold, if you extract all the info in one pass: 

RECURSIVE SOLUTION: NOTE: it assumes that the input is already sorted. You could sort this at every call of the function, but this seems like unnecessary overhead. 

By testing for both, you avoid having to use and start looping through the file again. Of course, this is based on the sample input above - and assumes that there isn't multiple lines with 'Time taken' or 'Sample Text' in them. Hope this helps