And then we only have two for loops. But I think we can combine those two as well. First, naively combine them: 

I'm gonna be honest here: I totally suck at python. That said, is it possible to declare some of those numeric literals as constants? That would clean your code up and clarify the code itself a bit more as well. 

Unless performance is somehow critical, you'd do far better by just making use of String.Split on '1' after getting a binary representation. Then you can search for the longest string in that array. The current implementation is very low level and hard to easily understand. A programmer who sees the code as it is now would have to invest time to understand how it works, whereas relying on (even if slower) a few library calls can make an algorithm easier to understand for programmers, thus being of more value than the faster, low level algorithm. It's also faster to write such things and less likely to contain bugs because most of the actual work is done by the standard libraries, which are thoroughly tested by other programmers. 

Why is this a static method? While the sql connection string is generally either going to be injected or a dependency, the user name seems likely to be a property of the object. Not a big issue, and in context it could be the right thing. Disposable objects should generally be wrapped in a using block -- unless there is a need for the object to be used after the function is done, which doesn't seem to be the case here. Why are you doing validation in a method called Get...? That should either be done in the database, or after this method. You return an empty string in the case of validation error and null on an exception. You do nothing with your exception handling except return an error -- no logging, no report to the user. You catch an exception at the first point you know what to do to recover from the error -- since this function doesn't do anything with the string it retrieves, how does return null; recover from the error? 

This sort of stuff is useless noise that adds a lot of maintenance. If your classes are getting hard to find, move them over to separate files. If you don't want to move them to separate files, consider making use of your IDE to find the class you're looking for, rather than relying on optical recognition via big blocks of screenfilling characters. The reasons for this are twofold: 

Perfect for prototyping. I restrained myself from programming a version that did not re-display the pattern, since it's not stated in the requirements (But it would make a rather boring game if I did). I wrote this quickly. I wrote this without an IDE. My goal: Learning how to prototype better. I'm interested in finding ways to test game mechanics faster. That means I don't want to write much code and I'm not interested in polishing it up nice. I just want it to work so I can test whether it's any fun. If it is, I can rebuild a clean version. For the answers, this means I'm looking for how I could alter the way I write code from the start, rather than refining it pass by pass. The code: 

While Corbin's answer is great (and I'd cetainly recommend accepting it over this), it buries the key point: your method does two things. This makes testing, understanding, and maintaince harder. You are supposed to a) generate a licence number, and b) filter out unacceptable ones. This should properly be split into at least 3 function, 1 to generate, 1 to reject, and 1 that calls the other 2 and only returns the result of the first if not rejected. At that point you should see what needs testing, what can be tested, and how to do your test. As for your final question: you fiddle with the process to make the error both frequent and repeatable. 

I see one thing I would consider a minor quirk: the usage of when the includes a return, exit, break or continue statement. I expect statements to be used when you don't want both branches of the code, not when both branches of the code cannot run. Changing those statements to just bare statements will allow you to seperate them from the prior condition and, IMO, make the code a bit more readable. 

21 characters saved. Stupid joke aside, I think you shouldn't worry about this so much. There's probably other places in your code where you're spending far more resources. This is a textbook example of a micro-optimization. You're worrying about incrementing a value by 1 and in the meantime you ignore the more complex parts of your code. 

If you need to clone a list, just make a new list. Additionally, why do you need an ? Just will do - you don't care that toppings are neatly into an array, just that they're ordered in some way so your pepperoni isn't buried under the sauce and cheese. 

By doing so, it's easier to see what difference maps to what mod value. It looks like a complex for loop at the moment, but that's because of the handling for your console logging... if we could take that out, it would look like so: 

Get a formatter which works for you and make use of it. Uniform codestyle means people can adjust. Haphazard application of obscure formatting makes it hard if not impossible for people to adjust. Get rid of the comments denoting the end of a scope. If you find you need them anyway, switch brace-styles until you find something that causes you not to need such end-of-scope braces. If it fits on your screen, you don't need such comments. If it doesn't fit on your screen, your function might be too large. (IntelliJ shows me 55 lines with the debugger closed at the moment, 31 with the debugger open). The thing about those comments is, if they're close to the start of the scope, the comment is useless. 

The efficiency of a join is primarily based upon covering indexes, not number of columns used. Given your scenario, you basically have the right idea. You don't mention which RDBMS you are using, but you could possibly use the INTERSECT command. 

A couple of things that I haven't seen others mention. One is that access modifiers are not security. You should want to control who creates your object, not because you don't want someone creating it when they shouldn't, but because they shouldn't HAVE to know how to create your object -- whether the "someone" is a fellow developer, a class that you are writing or even you while working on another class, that knowledge is a burden you don't want them to bear. Secondly, as others have mentioned, the way to do this is to create a nested inner class. What I haven't seen others mention, perhaps thinking it too basic, is how do you let others interact with your inner class -- and the answer is to create an interface. 

You basically repeat the same 7 lines 4 times. And what's worse is that, as written, half the time the full block isn't possible. 

The way you have done your algorithm, you could just apply the same operation to your variable, rather than reducing the entire array. 

I turned the bodies of the add child bits into ellipses. I think the and the and the could all be part of a method. Perhaps there being separate functions for creating such an and etc. The rest probably goes into a method - there is no footer, to be honest, because everything after the header goes into the . It seems to be something like defining calloc and a main method or something. I'd expect to consider of lines like . Of course, there has to be a body inside that too so maybe the needs the intermediate AST. What you don't want to see (which is what you have right now) is 70 lines (if not more, I just estimated) of code which look like the initialization code generated by those GUI tools that IDE's have. The sort of code you skim over without a second thought because it's auto generated. And the main reason this is so important is because the compilation is hidden between all these steps. Between all these fixed values/node creations is this line 

The two options are not really two options as they are not mutually exclusive. You should prefer two for things that are tied closely with foo and need to be checked everytime that foo is done, you should use one where it is not always applicable to foo, but it is under these circumstances. IOW if all code paths include a check for x immediately before calling foo, and foo would break or take an incorrect action if x was incorrect, then put the check in foo, if on the ther hand, it is only checked 4 out of 5 times, then obviously it doesn't belong in foo. An additional consideration is whether foo is being called to return a result or to take an action. If to return a result, then you may be just changing one check at the call site for another, in which case it depends upon the check -- which makes more sense. 

You basically have two values, that have a one to one coorespondences. I would take advantage of that. One value is what you want to return, the other value is the distinct value you get by using your 4 (5?) booleans as a bit pattern. Here's an example of creating the mapping programatically. It is for illustration purposes only, I don't recommend using it -- better to either put the map into a config file or a database. 

It's most likely faster (one never knows with micro optimizations when one just looks at the code, profiling works better in these cases). New snippet: 

Don't use here; write a descriptive variable name! in general is flawed. What you should use is a constructor, taking a width, height and length of the container. Then you can set the arrays and such based on those values. Right now, only allows creating cubes that are the same size in all dimensions... if I'm reading your code correctly. 

Same here... I think if you went through the code and cleaned mini-messes like those, you could chop off a quarter of the complexity. 

Consider declaring a variable and using . Strings are immutable, so whatever performance benefit you had with ripping open the , you completely waste it and then some here. You can then put the into a . 

Which weren't that interesting, so I just skipped over the comments. Except I just missed your includes and your defines. By putting all those slashes around them, you've actually made it HARDER to spot the defines. There's so many signs pointing "HERE!" that I can't see the actual thing. If you really need the comment headers, try styles like this: 

To let several objects respond to the same commands. This lets you have a function where one of the parameters can be an object, but it doesn't have to be of a particular type. To allow an object in one assembly, to use an object in another assembly, without having the first assembly rely upon the second. Instead, both rely upon a third assembly, which defines the interface. In this case there MIGHT only be one object that implements the interface. One reason for doing this would be to avoid circular dependencies. 

I would suggest changing the return type to a pointer to the list, and drop all of your error messages -- they aren't relevant. If passed in null, return null. In general you should seperate your logic from your UI as much as possible -- and this function needs no UI. Even if you consider this a form of error/exception handling, you should not be doing it in this case as there's no reason to allow this code to fail -- you are not allocating new memory, the only thing that can go wrong is not enough stack space, which happens before your code runs. Elsewhere you may care about whether the list is empty or the pointer to the list is null, but not in the code to reverse the list -- it should be foolproof. 

You have here, in a single iteration, 2 to 3 summations of . Some languages will cache these values. Some languages will not. I'd get in the habit of summing them once, then doing what you must. 

Interesting algorithm. The implementation seems correct, handling corner cases such as empty array and array with one element correctly. Aside from that, though, you should work on using braces consistently, not just where necessary. Your current style is minimalistic and doesn't allow easy visual parsing. Whenever you use an algorithm that has a name, write the name in a comment in either your function description or an implementation. Also include a link if you can, to save someone a google search. 

This function has a cyclomatic complexity of 10. That's a bit high, but that's okay. Nothing you can do about it. However, you should keep in mind that as your functions get more complex, your variable names should be more descriptive. What does mean? Is it a new Node? I don't see the keyword new though. Additionally, such complex methods could use commentary to explain just exactly what they do (this comment of mine might become irrelevant once you've made the variable names more descriptive). More show up - comment those with an explanation for a possible maintenance programmer.