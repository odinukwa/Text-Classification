In practice this procedure is performed as described in answer 2 + exclusive lock on the table modified. 

Standard method to extract some field(s) from denormalized data to separate table with the aim of normalization looks like: 

Prepared statement is stored in memory till explicit statement or connection termination and can be reused in the same connection if it was not destroyed - including from within another simple or compound statement. Query result obtained by SELECT type prepared statement is stored in query cache on a universal basis independent of the source type of query and can be reused both by another execution of this or another prepared statement and by direct query when its text is identical to the SQL text of the first prepared statement. 

No in practice. Because in the second approach the operations execution is one-by-one, not parallel. Cause of this is simple - in theory the next step can be dependent by previous one and so impossible until next step fully performed. 

To ensure max performance (assuming is primary/unique) I'll recommend to move LIMITation into subquery: 

Your subselect looks like remark to server "take EVENT_IT.WRTime from this query:". But server will never understand the syntax You think up, it has its own one... Maybe You want to perform 

Create new table + copy data + (lock source table + copy data changes in source made by another clients while first copy) + drop old + rename new + restore access rights, FKs and triggers. 

I think You can perform update You need using 2 statements. 1) Update all records in decreasing order. Single-table UPDATE allows ordering. 

The problem is that it is not capable of providing me ALL of the and their respective if it exists, OR their if it didn't exist. It is perfect at providing any one of them, but not at all. Basically, it's to enforce that if a language does not have a translation for a specific key, then the default is to use which is of translation. (Ideally, it would not even do that, but instead load the translation for , which I can do myself if pointed in the right direction for the rest of the query.) I've spent a LOT of time on this, and I know if I were to just write it in C# (like I usually do) it would be done by now. I want to do this in SQL, and I'm having trouble getting the output I like. The only caveat, is I want to limit the number of actual queries applied. All columns are indexed and such as I like them for now, and without real stress-testing I cannot index them further. Edit: Another note, I'm trying to keep the database as normalized as possible, so I don't want to duplicate things if I can avoid it. Example Data Source dbo.SupportCategories (Entirety): 

Typically you would design the database such that someone coming into the database alone could get a handle on how the application worked. Had they seen such a foreign key they may not be aware of it's implications. You could approach this in two ways: First, you could do as you mentioned. Create two separate tables and handle them there. Second, and the way I would recommend, you would create a table to handle all the common fields between the two, and then two other tables, one for internal-specific data, and one for external-specific data. Each of those tables would have a primary-foreign key to the common table. I.e. a Guid or ID. The downfall of the second method is the application would be required to be aware of the two different tables, and depending on the method you are using to implement it (.NET, PHP, Python, etc) you may find one method easier than the other. I personally use .NET and C# or VB, depending on the project, and in this situation I would go with the three-table design, as I would create an abstract class ("Event") and then two classes to inherit it and all the common properties ("ExternalEvent", "InternalEvent"). The Event class would handle the interaction of the shared properties, and the InternalEvent and ExternalEvent would handle the logic specific to them. The upside to this approach is the polymorphism of it. If you add a common field to the two in the future (for whatever unprecedented reason) you only have to add/change it in one location. 

Alter source table (or tables - in this case You may create view formed one recordset with all data and use it as a source) and add the field which will reference store for the values of fields which will be moved to separate table with datatype dependent of theoretical limit of new table' records amount (INT or BIGINT usually). Create new table which will store fields data moved from source table, with proper fields (and possibly proper datatypes, if they are not optimal for data stored in source table) and PK-autoincrement with the type of reference field created on the step 1. moved fields from source and the result into new table. Of course, it's one query. PK is filled auto. Remove PK and UNIQUE properties from PK field. Check moved data for "non-equal duplicates" (misprints, synonyms, etc.). Correct "PK" values of poor duplicates to the value of proper one. Update source and fill ref. field with PK from new table (join tables by values of moved fields, solving NULL values problem). Restore PK on PK field. Remove records with "poor dups" (they have no referals). Check JOIN result matched to original state. Drop moved fields. 

You have 5 records with I think. Any operator applied to NULL (except and ) returns NULL treated as False. 

While creating procedure, function or another compound statement consisted from more than 1 command, You MUST use statement. The reason is simple - command to create procedure is one command. But it consists from a lot of common commands. When You enter its code, server has no any marker, what kind of command is terminated by any delimiter - simple statement or compound statement. To avoid it You must use separate delimiters for that aims. Because standard delimiter will be used when server executes procedure, You must NOT alter default delimiter used for common commands. So You must alter delimiter used for fixed compound statement. You must update Your code: 

All relationships described in the image are complete in the database - the and constraints are all setup and operating. None of the columns described are able. All the tables have the schema . Now, I have a query which almost does what I want: that is, given ANY Id of and ANY Id of , it will return either: If there is a right-proper translation for that language for that string (I.e. -> exists, and in , , and combination exists, then it loads for that . If the , , and combination did NOT exist, then it loads the value. The is a given . My query, be it a mess, is as follows: 

Additional Example Given I were to add a localization for (I.e. add to ), the output would change to (note: this is example only, obviously I would add a localized string to ) (updated with French example): 

Additional Desired Output Given the example above, the following output would be desired (updated with French example): 

So here's my scenario: I'm working on Localization for a project of mine, and typically I would go about doing this in the C# code, however I want to do this in SQL a bit more since I am trying to buff up my SQL a bit. Environment: SQL Server 2014 Standard, C# (.NET 4.5.1) Note: the programming language itself should be irrelevant, I'm only including it for completeness. So I sort-of accomplished what I wanted, but not to the extent I wanted. It's been a while (at least a year) since I have done any SQL s except basic ones, and this is quite a complex . Here is a diagramme of the relevant tables of the database. (There are plenty more, but not necessary for this portion.) 

I have configured Always Encrypted on a custom database using SQL Server 2016. By default, it creates the certificate with a validity of one year. Is there any workaround to create this certificate for two or three years at the very beginning stage? I don't want to rotate the key every year in our production environment rather create the certificate at least for two or three years. Experts advise please. 

On executing the step 2 scripts, below error is being displayed. Cannot find the certificate 'MyColumnLevelEncryptionCertificate', because it does not exist or you do not have permission. I'm able to see the certificate under Security->Certificates section and the sql user being used is sysadmin. After researching the online forums, I tried to execute the below scripts but still the same error is being displayed. 

We have requirements to encrypt sensitive column data using SQL Server 2016 and selected the Always Encrypted(AE) feature to encrypt those columns using deterministic approach.. Since, the AE deterministic encryption doesn't allow inequality, range, or LIKE queries on these encrypted columns, we have tried of doing encryption for these type of columns using the symmetric key (column level) encryption technique. Is it a good practice to implement the AE feature on certain columns(which doesn't need any inequality, range, or LIKE queries ) and symmetric key type encryption on columns where inequality, range, or LIKE queries needs to be generated? Is it a good practice to combine the AE encryption and column level encryption on a single table considering the performance, security and maintenance? Experts advice please. 

Desired Output Ideally, I would like to be able to omit the specific , and get all of them, as so (regardless if language 38 was used, or 48 , or ANY other language at the moment): 

(Yes, I know technically that's wrong from a consistency standpoint, but it's what would be desired in the situation.) Edit: Small updated, I did change the structure of the table, and drop the column from it, and replace it with (which is now renamed to , and all relative Foreign-Keys and and relationships updated). From a technical standpoint, this is a more appropriate setup in my opinion due to the fact that the table is limited to ISO 639-1 codes, which are unique to begin with. Tl;dr So: the question, how could I modify this query to return everything from and then return either for that , combination, or the if it did NOT exist? My initial thought, is that I could somehow cast the current query to another temporary type as another subquery, and wrap this query in yet another statement and select the two fields I want ( and ). If I don't find anything, I'll just do the standard method I typically use which is to load all the into my C# project, and then with it run the query I have above manually against each . Thanks for any and all suggestions/comments/critique. Also, I apologize for it being absurdly long, I just don't want any ambiguity. I'm often on StackOverflow and see questions that lack substance, didn't wish to make that mistake here.