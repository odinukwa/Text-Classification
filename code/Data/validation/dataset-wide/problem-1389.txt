I don't know enough about android but in Swing, for example, a combo box took, in it's constructor an 

It's a lot to explain here, but in a nutshell, I would simplify all of this using spring-data-rest and do the following 

Get rid of the REST/persistence/dao layers you have Refactor your services to use the Spring Data events So you're would become an handler for the looking like this: 

The idea is to decompose it, apply the filtering and then reconstruct it. part of the problem is this code mixes development paradigms: it uses and and 

You don't need to explicitly call or any such non-sense. When it exists the event handler function(s) it will save for you You would stay the same but your would become a spring CrudRespository - the implementation is trivial. You can actually look here for an example. With this, you can: 

I would also suggest that you might be able to make use of Java 8 streams to improve your performance on large numbers. 

Your variable names mean zilch to me. You HAVE to give them a better name. Also, create them up in groups of 2. This code here is also problematic. 

First, I applaud your effort - I must confess: this is definitely lacking in the js world. A few things come to mind: 

Delete all of your controllers. The endpoints are created and the content-types managed by spring data rest for you. Read more about for details on that Delete all your DAL code 

I'm assuming that the reason for needing this is for some form of interoperability between a Java process/routine and a C++ process/routine. For the sake of having a more robust solution, have you considered using some form of serialization library to handle the byte array format for you? For instance, Google's Protocol Buffer project is perfect for creating a single definition of your data model, and then creating bindings for different languages (Java and C++ supported) so that you can serialize/deserialize that object from any source. Essentially you'd create an definition of the data you want to represent in a file (like so): 

This may sound really picky, but if this is actually some library code that you would like to reuse in different environments, then you might run into minor issues because of the line : 

That being said, take into account how complex and encompassing you want the final solution to be. If you're not comfortable with making those sorts of edge-case resiliency guarantees in your library then these suggestions are pretty moot. 

This could be an important issue if you were looking to manage a cross platform serialization. If you make a data file on Linux and copy it to Windows, it may not display completely correctly. Even if Windows handles the display correctly (many apps are becoming more line separator agnostic these days), it's still technically bad code hygiene. I have two suggestions for the above code: 

And literally the only thing you need to do is implement business specific event code. The caveat here is that, by default, spring is going to produce a data format called - if you have a requirement to certain output formats you can create and register a and register it for and remove the one defined for 

People generally took this to mean a String[] as that is what they saw in the dropdown. But ask yourself: Why Object[] then? Assume we transpos your case to Swing for a moment. You could pass in your Object[] into the constructor and override the toString() in your enums to display something useful as that is what would show up. Then when the selection is made you receive the callback telling you what it was (as an Object). But you know it's your enum. So, you downcast it and blindly call the 'attempt' method on it. If you have something similar in your arsenal, consider it. What you have here, actually, is an example of the Command Pattern 

Is way better! Think about it: In the previous case, you 'return' and terminate the function. But, in this condition you have no idea if the job was done or not and if not, why not. This is pre-condition checking and an ideal case for it 

Shorten the code Create a type of factory method for these "fixtures". This may not be appropriate for your case but with no other context that is what I would do 

The is signed variable length encoding integer and maps to scalar in C++ and primitive in Java. The is a plain and simple in C++ and in Java. The last field accepts some slight overhead to simplify the code by encoding the field as an array. The option on the end configures the library to pack in the values as tightly as it can. This is for simplicity's sake, and if you require anything more granular than that, there is always the type, which maps to in C++ and in Java. Finally, you'd use the command to create C++ and Java libraries that will handle the serialization for you. will generate the and files for the C++ bindings and a class with a special object for Java. The best part of this is that protobufs support plenty of helpful features to let you add or remove fields while maintaining a degree of backwards compatibility. Need to add a new field? Just recompile the bindings. The older versions of bindings will gracefully ignore any data fields they don't care about. Extensibility can be a big deal if the data has any chance of being modified in the future. Google uses this as their "lingua franca" of data serialization tools, both for storing data and encoding RPC requests. (My examples use protobuf v2, but they now have a v3) 

This works fine on Linux machines, but Windows uses to denote line endings, and Mac traditionally uses for line endings (though I believe this is relaxed a little). If you were to run this code in those environments, your outputs may look strange or not separated at all. You can save yourself from some confusion down the road if you modify that line to be : 

by shifting the digits left, performing your digit selection and bucket sorting, then outputting them back in decimal form? Like, take your random set and first convert all of them. I would expect better overall execution time. 

Here is how I would simply this: First, I would create a reduced method for getting "body" in fixture as such: 

IO is always infinite (or should assumed to be so) and thus is natural for this case. The default node libraries for streams are really unimaginative on this. I was just asking around on JS chat yesterday about something like this. 

And now, a line is gone and your code flows naturally and doesn't abruptly exit the function. Finally, this thing where you put your 

You're using ramda for currying and nothing else? Ditch it and implement your own currying; it's not hard. Since usability is of a concern to you then making this an actual nodejs stream would be hot and also not difficult. Integrating it with iterators/generators would be handy A more natural usage would be 

Craziness? You only need to do this if you want to assure yourself (or the compiler) that it won't be reassigned. This is hyper defensive and, in 15 years of writing code I have never found it to be a necessity. Frankly, 'final' in this case is repetitive and distracting. Unless you have a need for it (which, from this code, you don't) then ditch it. this: