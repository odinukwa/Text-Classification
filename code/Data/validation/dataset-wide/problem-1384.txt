That both makes it clear from within what module you're in, the fact that you expect it to be used with , and will generate nicer stacktraces. I'll also point out that - it's a matter of style but you're on CR so I consider it solicited - hardly ever is code made more bugproof or more legible by using constructor functions. reader.js could just as easily be the following and not depend on someone remembering to use and always bind functions. 

My comments are inline starting with the . I also very much encourage you to look at async libraries such as Q. 

Seems to even work when wrapped in a . That being said, you might have legitimate reasons to want to test for this but I can't think of any. Edit: Added check for 'other' window. You could probably add some finagling to check that eval isn't a stub that always returns . So if it returns true for example you could generate two random numbers, add them together, and then pass them into the eval string and have it add those numbers and confirm the result is indeed accurate. Let's be honest though, that's stupid, if someone wants to trick you that bad, they'll find a way. 

Surely is already defined as a attribute so why not read it from the DOM in the same way as ? Alternatively, simplify the HTML down to the wrapper and generate its content dynamically. The legend doesn't appear in either Opera or Chrome. 

it is an exercise in a form of classical inheritance, by which methods bound to an element are inherited by selected child elements. methods are defined as properties of an object bound to DOM elements with . These methods are intended(?) for private use (within the plugin) but are ultimately accessible by user code. the child elements (spans) will retain a relationship with their original parent after being moved elsewhere within the DOM. the selection of first child spans is hardcoded. 

This is a good thing to do anyway as it puts just one member into the namespace. Then, will return an array of keys, which can be looped through : 

Since this is a public method I added some checks and downcast List to IEnumerable, which is a looser contract and all you really need here. By the way, .Net naming conventions are pascalCase for private and local variables CamelCase for public and protected. It's rare to use underscores. 

Yes this doesn't do all the type checks that you do above but why do you need them? Now let me be clear It is possible to expose an XSS vulnerability for your users here Specifically if you allow users to enter values which are posted back, persisted on the server, downloaded by other users, and then used with this function on their computers. Suppose you are doing binding to objects which users can customize. These can be arbitrarily nested so you use this pattern. You also have summary screens in which users can view other users' customizations. All an attacker has to do is create a property named and it will be eval'ed and run on the machines of other users of the system. That's the danger. If you're aware of it and make sure that condition never happens, feel free to use the with-eval. 

Searching a whole, large DOM for elements is a real performance killer. When possible, always try to search a fragment, or traverse the DOM relative to a known element. With a little rearrangement of the HTML, "network", "boot" and "check_in" elements can be found within the corresponding "selector" element, similar to the way "util" and "workgroup" elements are currently found. This alone should give a significant performance boost. HTML 

In practice, you may define both plot-functions and filters either internally or externally. It's very easy to make mistakes when re-factoring to this extent, so I doubt that my code will work first time. Typical errors will be out-of-scope vars, and referring to the wrong object. Happy debugging. 

You should recognize much of your original code but it's been shuffled around - refactored. Refactoring is commonplace. Even very experienced programmers find they need to refactor, and it's is an important part of their skill-set. It's seldom necessary to restart from scratch. 

Usually I see tuples in js implemented with arrays though of course an object - while annoying to write would be just as valid: . So for this sort of use-case (creation and light usage of a bunch of temporary objects) I'm curious if there's a significant performance difference so I set up this jsperf. Object tuple test: 

Finally, a couple notes on your specific files - you probably want to name those top-level functions even when returning immediately env.js 

I realize that breaks with the "single point of return" wisdom but I'm not a big fan. When you have small functions like this one, it doesn't make all that much sense. Refactoring step 2, with that cleaned up it's easy to see how this fits into a simple LINQ query 

Speaking of which, the class is probably not the best named. you could imagine making a diesel-punk version of this where you use border-radius to have round (not boxy) spaces. Instead name it for what it is. My recommendation would be I'll stop short of saying that you should avoid ids altogether but only use them when you're really really sure that the element is the only one on the page with that name (including any other components built from composite uis). Next - this is a bit of personal preference but I think you're overusing divs. proper html elements can give good semantics to your document. I would probably structure the stuff as since these are part of a series. Other valid possibilities might be (as in article of clothing NOT a blog post article) or elements. I would also say you can make this significantly more lightweight by using a javascript templating framework like Handlebars or a an MVVM framework like Knockout or a full javascript framework like Angular. Your mounds and mounds of html will then collapse down to just a single definition. Runway probably doesn't need to be an element at all. You can probably just tag the the appropriate class (like ) and use css3 gradients to create that stripe. 

Two observations : 1. Transactions Calling a function from within a callback does not in itself cause that function to be part of the transaction. It seems likely that everything in and its sub-functions should be subject to the transaction defined in . If that's what you want (and you probably do), then you need to pass and use it in called functions rather that defining separate transactions. 2. Asynchronous flow control There's little asynchronous flow control in the code. Much of it is written as if it was synchronous. For example, both and perform asycn operations but neither informs its caller of completion. Therefore there's no hope in the caller (or the caller's caller, etc) to schedule things to happen when those async activities have comepleted. If sequencing matters (and it probably does) then you need to be working with promises.