Admittedly, I don't know much about Drools, but guessing from how the rules are defined here, using this class, rules can be defined like (this is not Drools syntax): 

This has a single move strategy, which is what you set to it upon construction. Structuring the the way you did is, to me, a little weak because the class doesn't seem to be in charge of its own state; it seems to rely on some external component in deciding what to do next. In some way, it can be considered an anemic data model whose only purpose is to carry data instead of representing an abstraction or a concept. Going back to my point about the class representing some playing strategy, we know that, conceptually, there many ways a player can play. What I suggest here is that instead of making a Java class, declare it to be an interface instead, like the following: 

Normally, I do this for methods I have yet to implement while I work on specified methods one by one. 

This way, you have more control over the internal state of a given class within the context of a given method, while limiting the method's behavior to something that's more specific. It also makes the code a little more traceable in that if there is no requirement that says a completed can go back to being non-completed, you don't have to enable such state transition. I think it's also somehow more "poetic" to have an invocation like compared to . 

I found a solution I like better, which replaces the loop with a . Sequences work but look funny as fake data. 

ActiveRecord enums "are exposed through a class method with the pluralized attribute name", so I recommend the following code. However, I would highly recommend making the enums symbols instead of strings for compatibility. Also, enrollment is spelled with two l's. Note that you can control the capitalization of DPR using inflections. 

I would just factor out the flash error into a constant. Also, I believe the trailing period in your regex should be escaped, as you don't want to match any character. 

Finally, you should consider whether you want to be when no conditions match, and you might consider explicitly adding an to make that decision obvious. 

Ruby uses SCREAMING_SNAKE_CASE for constants, which is what you are setting up, so I would call the variable . If you have a super long constant, and it's not created programmatically, then listing it a line at a time is clearest. Ruby will coerce into unless you treat it as a string. You can use the shorthand for arrays. So, the first couple lines should be: 

My personal view in methods like this is that instead of making them setters/mutators, you turn them into actions/features. So instead of having a that takes a from a client component, I think it would be a bit more sensible to have something like: 

As for the restriction about what their names can be, since it's not very convenient to use enum, then I'd suggest using a plain text file of comma separated values, added in the classpath. For example a file in the directory could look like: 

I don't know what field represents, but I kept it. However, due to the fact that it's not readily understandable, you should reconsider why it's there in the first place. In any case, notice that there are only getters for this class, and no setters. This is because, like I said, objects most likely won't need to change, there's no point enabling the state transitions in them. Rules Integration I missed a critical aspect of the problem you're trying to solve with your code, which is the rules engine primarily geared towards not-so-technical people. However, I still think that having those rules in the system does not mean we should completely forget about good OO design. I believe that rules should augment your design, not hijack it. Since having a enum is quite restrictive, my idea is to define it instead as a value object: 

Your second method is closer to idiomatic Ruby. In general, you should never need to initialize an array. is a nice alternative to . And, you can open String and add a new method. I would do: 

I generally like to be Rubocop-clean, but it seems like breaking up the first case statement will only make things harder to read. Any suggestions? 

This doesn't directly answer your question, but I also recommend switching from integer actions to enums: $URL$ Interestingly, this should not require any changes to your database at all, but will provide a lot of convenience methods and make your intent more clear. I do recommend hard coding a hash of the integer to the symbol in your enum definition to avoid any ambiguity: $URL$ 

My other suggestion is that you might want to monkey patch String as follows, to follow the pattern of other Rails Inflectors (note that including is unnecessary): 

[Rewritten] You want to avoid inject, as is O(n) and clearer. Monkey patching array makes the code clearer and is idiomatic Ruby. Methods that return a boolean should end in . Method names should be snake_case. Here you go: 

To me, this is a very simple construct that captures the essence of what a Player is: an object that returns a when it s. With interface like this, you can define many different types of Players, like, for instance, one that plays randomly. For example: 

I'm not really sure, but somehow I feel like this can be an instance of a refused bequest, or some sort of breach of contract. I think you have few options here: 

Each move has some seemingly intrinsic characteristics. In particular, each of their name should be lower case Strings, and their values are limited to some given set of words. My impression is that these rules aren't bound to change that much anyway, so why rely on the rules engine to impose them? For one, instead of checking if their names are lower case, why don't we just ensure that they always are? Instead of making it a rule, why not turn it into a basic assumption? 

This way, the code structure itself imposes the rule on what values are valid. In addition, by doing this, you won't have to specify the validation rules elsewhere. As for your class, I think that it should be something that captures some form of playing strategy. It can be as simple as one move player like what you have here essentially, or something more complex. The simplest modification I have for this would be to restructure it the following way: 

In Ruby, it is almost never necessary to set a temporary variable to empty and iterate over an object, given the power of methods like map, reduce, find, all?, etc. I don't see the need to use since it doesn't change whether index will be present or not. It's unclear why you're checking for nil on the first sheet_activities (since you can't guarantee what will be first without sorting), but if you just want to return false when sheet_activities are nil, the above will already do so. Also note that Rubocop likes single quotes when you're not interpolating. 

There's nothing magic about Rubocop, but it does encourage you think about what makes readable (as opposed to just correct) code. In this case, I think it is clearer to make the conditions explicit in the rating method as you've done rather than break them up into separate methods to pass Rubocop. Specifically, I would suggest this: 

Sorry I don't have time to review the full program, but here's a much simpler replacement for the method. Note is a redundant if you're then going to be splitting on white space: