Keep your code extendable - You created your enum as an extendable enum, but then you implemented the various methods repeating the enum values themselves in them. A better solution might be to let each material declare its own type: 

This does a single per combination (instead of once per key), and further reduces the run complexity of your code. 

Use correct container - using a pre-calculated table of squares is fine, but if you put it in an , each will cost you \$O(n)\$. Using will do the same thing in \$O(1)\$. Unclear requirements - "all permutations of the pairs that add to squares" - what I understand from this is that the result should be a list of pairs containing [n,m] and [m,n] for each pair that adds to a square, you sample output though is two arrays containing a list of numbers in which every adds up to a square. This may be what you meant, but this hardly constitutes all permutations of such an answer - will also qualify, but it is not part of your answer... Here is a refactored solution with complexity of \$O(n^2)\$ in time and \$O(n)\$ in space: 

Redundant operations After reading the data from the web service, you go over it a number of times, which seems redundant: 

your code changes seem minimal, and to the point doing exactly what they are supposed to do, and nothing more. What I think you should add are the tests to show your changes, and make sure no-one will break your code in the future. 

Optimizations Since you don't give any background, it is hard to give you feedback on your algorithm - are you trying to implement a specific sorting algorithm on your own? are you simply not familiar with java's own solution to sorting ()? Optimal solutions for sorting an array are with complexity of \$O(n \cdot log(n))\$, your solution is \$O(n^2)\$, so there is room for improvement there... you can find a myriad of sorting algorithms here. You could further optimize your code by making a few quick checks on your data before doing the heavy lifting. For example: if not all the strings have the same length, you can immediately determine that they are not all an anagram of one another, and save yourself the sorting. 

Your code looks very nice indeed, I only have some minor observations you code use to improve this code: Naming Use the imperative form of the verb ( instead of ) Implementation Hiding Use for methods which are not intended for external use. You might consider also renaming them to start with underscore to further differentiate them as internal. Multiple assignment in method signature To make you code more succinct, you can use multiple assignment - meaning that instead of: 

Naming Conventions Variables in java should be , meaning they should start with a small letter. Meaningful names Someone reading your code doesn't stand a chance in hell to understand what you are trying to do without actually running this code in his head... Your class is called , your only method is ... at least try to tell your reader some story on what you are trying to do, especially when you post it for review! Variable names like , , , and add nothing to explain your code. Names like and are even worse. Efficiency It is very hard to give efficiency advice, if I can't say what exactly you are trying to achieve, but some obvious observations: 

One last point, regarding your and classes, I personally don't see any utility in having them, since they add no logic besides a construction convenience, and may even confuse, since their name implies they support only one scale or the other... So now, your class will look like this: 

Avoid noisy code, and noisy logs Your code is filled with and characters, which are meant to highlight sections in your log files, but since it is used so much, your log file will be filled with marquees, and will be painful to read (just like you code right now, only much worse). You should differentiate between events in the log using log levels - exceptions and errors should be logged using , production-level events should be logged using . All other events and debug data should be logged only using , and maybe not at all. Variable naming Using names such as , , , etc. is very discouraged, unless it is part of your domain's nomenclature. For example, for a lot of people coming from XML, means . Be verbal - use full names (). If it needs a comment - you probably have to rename it or refactor it You have many methods with comments explaining what they do. Comments are generally a bad idea, since they tend to "rot" - when you change the code, most often than not, you neglect to maintain the comments (For example what does refer to?). There are two types of method comments in your code - those which repeat the name of the method, and don't add much ( is enough, you don't need to say ...), and those which explain things which are not explained by the method name. Delete the ones which repeat the name of the method. The other kind hints that you probably need to either rename the method, or break it down to its parts. You could either rename to , or (probably better) have a method which will call 3 times - it will make your code DRYier. 

Your problem is that you load the whole file into memory, convert each byte to three characters (that's the file size times 6), going through and . To avoid holding all in memory, you should stream the data, converting and writing each chunk. This way, you'll only hold a fraction of the file at each time: 

Naming Conventions It is conventional in ruby to name getters by the name of the member, without the . For that convention, there is even a shortcut - . So, instead of writing you should do: 

but you should choose one style and stick with it, to prevent reading errors, and general head-ache by code readers... 

You use only to wrap your with a and a , I suggest you consider simply prepend with the prefix, and append it the suffix without using a temp object: 

Mutators vs. Selectors The method both populates the instance, and prints the result. It would be a lot more predictable if it would be responsible only for one or the other. Its name implies that it only prints, so I would suggest to move the population of the to its constructor, leaving only the printing to the method: 

If your question is whether you could refactor the code to return instead of , without knowing more about your code, I would say no. Changing the return value from to may break existing code calling your method, and expects it to always return a value. 

Assumptions For some reason, you assume that the username and password are always equal, and known at compile time. If that is the case, you could have made you life easier and instead of commenting and un-commenting lines in your code you could simply re-write the section, since you know its values: 

More to come - part 2 (the second coming?) After you've refactored the mutator out of your selector, it is obvious that the only state change while printing your classes is the (nee ) member. But a selector class should not change the state of the object! The design which emerges from this is that should probably be a parameter which changes before and after the recursion, probably a : 

Who should use scanner? As was already suggested - should be a local variable. I don't agree with the suggestion to pass it around as an argument, since I don't think the other methods have any business prompting the user. should do exactly that - check that the number is valid! What's the meaning of -1? From reading your code, I can see a little problem: 

Exit Strategy Your use of makes your code a little awkward. Initializing it with , and changing it to makes it even more obfuscated, as it is counter-intuitive to most coders. As its name does not convey it any meaning, your gentle reader is left to guess its meaning by reading your code over and over... I would drop the flag altogether, breaking from the method itself upon finding your stop condition: 

@Flambino and @tokland have both suggested good strategies on how your task should be done. I want to talk about your code: Naming conventions XML file is two words - name the method accordingly - Useful names Names like and are bad because they don't convey the true role of them, and might confuse the reader - and would be better. Any two letter variable which is used for anything less trivial than running index is not advisable, and variables named and are even worse, since the letter might be indistinguishable from the digit in some fonts, which might be very confusing... Don't shadow variables Yes, you should not use , you should use . But if we assume that that is the required API - don't name the inner and out arguments with the same name (). If you know you are not going to use the argument in the body of the block, ruby conventions suggest you use the special variable name : 

Perhaps you want to decouple the point calculation methods from the array altogether. This can be done easily enough by passing instead of , as that is all the actually cares about, although this solution will break as soon as point calculation will need more information... 

And what happens if repetition is not expected? This is actually not defined in your description as well... By looking in your code it means that if there is no repetition, anytime between start date and end date (or forever) is considered valid... Maybe a better name for the method be ? When enums don't matter You have declared two enums - and . One observation - naming conventions for enums is CamelCase, so the names should be and . But, look at what you do with - you translate it (not in a very DRY way) to , you should consider to drop it all together and use the Calendar constants from the start... What exceptions are for? and throw . Why? Again, all dates are legal. Exceptions should be used in case where something prevented the method from completing its promise to its caller. For example - would throw an exception when the input string is not made of integers - it simply can't parse it to a valid integer. The same way that a will throw an exception when the file was not found where expected. Here they are used for completely expected values - the input date is either a match to the indicated repetition dates, or it isn't. Exceptions break the flow of the method, and need to be handled. They are also very inefficient at runtime. These methods should simply return , just like their caller. Simplify you API according to use-cases To set a weekly repetition, you expect the user to call two methods - and then remember to call . This is far from optimal to your prospective user, and very hard to enforce statically. The reason you chose this way is because that is the way your class is arranged internally. If you think about the API from the outside, maybe a better set of APIs would be , and . This way, the user will set the relevant days in the same call where he sets the repetition type. It would also make it easier to expand your API in the future to ... 

I believe you are using much too liberally. The feature for adding new formulas is debatable (personally it is more of a security issue than a value feature, since you make no validations on the code you are evaluating), but for parsing arguments, the use of is completely redundant. Why don't you simply use built-in parsers for numbers, like ?