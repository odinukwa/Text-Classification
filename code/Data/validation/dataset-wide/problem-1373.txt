Hard level algorithm It is hard level algorithm, and Leetcode shows that there are 231.9K submissions. I like to post the algorithm for code review, I did study discussion panel on Leetcode 212 to get one idea to solve the problem, and then I carefully prepare my own learning notes as well. It is also a good idea to discuss why Trie is needed for better time complexity. Brute force solution is to go over each word in the dictionary, and then try to find it in the matrix. The total number of search using DFS is m (words) * rows (matrix) * columns (matrix). The brute force solution has timeout issue through Leetcode online judge. We like to review why the time complexity should be better. Let us go over dictionary with 4 words, "aaa", "aaaa","aaab", "aaac". If we pre-process the dictionary and store all words in a Trie, and then we do not have to go over each words to search matrix. We only need to go over each element in matrix as start char in a word, search the trie to find match words using recursive function. The number of search using DFS is rows (matrix) * columns (matrix). Second advantage related to the above 4 words ( "aaa", "aaaa","aaab", "aaac") is taking advantage of Trie data structure. The space complexity of Trie is better compared to hashset or hashtable. The same prefix "aaa" is only repeated once in the Trie. Trie against Hashset Related to the test with a dictionary "aaa","aaaa","aaab","aaac","aaad", let us work together to talk about the difference. For example, if the dictionary is saved in hashset, then go over each word in the dictionary, try to find word in matrix. For example, "aaab", the first three letters has to be compared and they are the same first, then the last letter will be checked. Same will be applied to another 4 words. In total, the prefix "aaa" will be compared exactly 5 times in order to find those 5 words. Can we do better? Just compare the prefix "aaa" once? Cetainly we can. We can save the words in a trie instead of hashset. a | a | a |\ \ \ | \ \ \ |   \ \ \ a   b c d Trie efficiency talk It takes some time to get comfortable to design a Trie. So far, I have written a Trie implementation more than 4 times in C# last 3 years. Given the fact that I have worked on computer science study and full time work more than 20 years, if I practice one algorithm a day, then it is around 60,000. Definitely I should practice more how to write a trie, use the trie to get better space complexity. How to design a Trie so that the space complexity is minimum? For example, the dictionary has the following words, "aaa","aaaa","aaaaa","aaaaaa". How to store them in Trie efficiently? a | a | a word: "aaa" | a word: "aaaa" | a word: "aaaaa" | a word: "aaaaaa" The above diagram shows that those four words are saved in a Trie. How many char 'a' are saved in Trie, only 6, not 3 + 4 + 5 + 6 = 18 chars. Four words are saved along the trie nodes. Every node can represent a word, it does not have to be a leaf node. The C# code is written based on the study of one of Leetcode discussion. 

There are 2 loops in my function, first loop will run until is equal to . At each iteration the value of is incremented - thus, it will point to the next element; The second loop will copy the elements of the string at the and of . The incrementation is done in the test part - even though after the loop stops and will point to other objects.This technique couldn't be applied in the first loop because when the loop stops will point to an irrelevant value. The exercise can be found at page 121 in K&R second edition. 

This version of is a secure one. The first checks if there is enough space in the buffer to store the contents of . The loop wil run until reaches the value . At each iteration the value that points to is copied in to . After the loop stops, is returned a pointer to the result. Here is my implementation of : 

My introduction of the algorithm This is the algorithm to apply trie knowledge and also use maximum weighted independent set knowledge. And the algorithm is one of medium level in February 2017 RookieRank 2 contest. In the contest, I implemented the trie algorithm but failed test case 10 afterwards. So, after the contest, I studied the algorithm and one of submissions, write C# code to ask for review. Most of my time is to learn how to implement a trie, and also help myself understand prefix neighbor. The return statement in the function is so confusing, for the test case of string dictionary , the stack of return statements and when the prefix neighbor is set, definitely need better solution in my opinion. 

I felt that this code would be good as a jQuery plugin, so I went ahead and altered your code until I was satisfied. I left in some comments that are applicable to your code, but I would encourage someone else (and may do it myself still, I don't know yet) to give an actual review. 

I like the second option, it is easy to read if you just reformat it a little bit (also corrected your selector and fixed the shadow in IE9): 

Without going farther I recognize this pattern as a depth first graph traversal with a little additional functionality. I would abstract that a little and see this helper function: 

The loop will run until reaches the value , or when the charachters that and points to are not equal. At each iteration I check if the and are equal, if they are, I increment and . If they are not equal, I return their difference. After the loop stops, the value is returned. Here is my implementation of : 

Before the I check if the charachter after the + or - is a number. If it is, the function will store the representation of that number in *pn. If it is not, it will push back that characther back on the input - such that, everytime the getint is called it will read that charachter and push it back. Here is my solution: 

is an awful variable name; that underscore adds nothing to it but makes it more annoying to type. Rename to . This: 

But it is even better to be commented out or otherwise removed since you aren't using it anywhere. Similarly: 

cache your jQuery objects reword your condition so that it is more readable parameterize the animations and pull them out into methods of their own move your initialization code so that it is all together 

I am not sure I understand the question. What are these classes going to give me that a standard lock wouldn't? I would write that first class something like this: 

You could do something more fancy using a regex replace or whatever, but I don't think it should be necessary. 

If the friendship \$1\$ and \$3\$ are added before adding 4 and 5, then the value is less than \$24\$. After the contest, I studied one of C# submission with maximum score, and then did some code review, tried to understand the graph design and also read the hackerrank editorial notes, understood the process to get maximum value of friendship. I put together C# code and also tested on hackerrank, the code passed all test cases. Please help me to review my C# code. Hightlights of changes Add name variable in the class GraphNode to help identify node; add the test case to help understand the algorithm, and be able to add comment to explain the function Connect; use meaningful variable names after code review. I already spent hours on the algorithm and really look forward to work hard on graph algorithm and be able to perform one graph algorithm in week of code contest in short future. 

There are 2 loops that will run until and will point to the end of the string that they are representing. You will notice the presence of the variable , at the end of the second while loop this variable will have the value , where represent the number of charachters in the string . By using the variable I know when to stop the third loop. When is less than that means that every charachter in the string was compared with the coresponding one in . At each iteration of the loop I check if the current charachter that points to is equal to the coresponding charachter in . Here is my second version: 

At the expense of having a little more code, I would use a localStorage polyfill [2]. With that code in place you no longer need to keep the create and read cookie methods. You also don't need the code wrapping and . Your resulting code would look something like this: 

Lock based concurrency in .NET is a fairly simple paradigm (compared to the other ways of ensuring thread safety in .NET). When you lock, you declare a block of code as a critical section, protected by that lock object. .NET ensures that a second piece of code in the same app domain will never be running in a critical section protected by the same lock object while one instance is. Here is a good resource for more threading information: $URL$ Pedantry When most people discuss thread safety they mean it in the same sense as saying strings are immutable. That is to say, as long as you don't do anything I shouldn't reasonably expect you might do it is safe. Unfortunately, locks aren't good enough to actually provide true thread safety (bulletproof against reflection and C# pointer code), they are good enough for most usages where you control the software stack out to the actual application. If you need to ensure thread safety in these instances you must ensure thread safety at the field level in your classes (stuff like the keyword will help you here, but watch out). Some example threads that would break your safety here: 

There are \$k\$ obstacles on the chessboard preventing the queen from attacking any square that has an obstacle blocking the the queen's path to it. For example, an obstacle at location \$(3,5)\$ in the diagram above would prevent the queen from attacking cells \$(3,5)\$, \$(2,6)\$, and \$(1,7)\$: 

For example, left direction \$(0, -1)\$, clockwise, next direction is left-up, \$(1,-1)\$. Enumerate all directions, for each direction, starting from the position of queen, just increment one by one using two direction arrays if staying in the boundary of matrix and it is not an obstacle cell. 

My introduction of the algorithm I just started to work on another round of mock interview last few days, but I chose myself as an advanced level interviewer the first time. A few peers are preparing the onsite interview less than one month, some of them complain my communication, I learn to challenge every peer to make sure that the peer learns something after the interview. I start to look for an algorithm to give them additional challenge. The recursive solution with a tricky base case is my first one, I have used the algorithm thrice. The peer with strong confidence may solve it in less than 10 minutes, otherwise I can learn how to give hints to help them. Recursive solution The algorithm is my first choice and I asked three peers to solve the algorithm as an additional test, all of them gave me good feedback. It is hard for them to solve in less than 10 minutes, none of them solves the problem before, and kind of overthinking the solution, using stack or think too much detail. So I decide to ask a code review for the algorithm as well, make sure that I understand correctly. Here are hints I prepare to give and help peers to solve the problem in less than 10 minutes. My first question is "If you try to write some code as simple as possible, and also try to give a partial solution. What is most easiest thing to do?" What if the given node is the root node? It is simple to figure out, go to root node's right child and call the recursive function. And the next hint is how to relax the condition, when to call node's right child and let it solve the problem. The root node's value is not bigger than the given node's value, so the successor node's value should be in the right subtree. Next question is "when the root node is the successor". We need to land the successor on one of nodes, which is the base case. The best candidate is the root node. For example, shown in the graph of problem statement, the binary search tree with root node value , given node with value , the successor is root node with value . If the root node's value is bigger than give node's value , the root node can be either the successor or the node located after the successor. I tried to use another hint on mock interview. The peer could not think using simple recursive solution, he kept busy thinking about inorder traversal using stack. I tried to use the hint: If the root node asks its right node to solve the same problem, or its left node to solve the same problem, when the root node does the work itself. So it is my design to let the root node be the successor. The base case is all you should care about. The peer also gave good feedback on this hint. I choose the algorithm based on Leetcode discussion here. I find that the algorithm is very good to test the candidate on recursive solution problem solving. It takes time to solve the problem, but if you decide to solve the partial of the solution, start something as simple as possible first, you will end up with a surprise. That is my coaching tip, to help the peer to build confidence, aim the smallest target first, write the simplest code as possible. Here is my C# code and please help me review the code. 

The loop will run until reaches the value , at each iteration the current charachter that points to is copied in . After the loop stops, the is copied in and a pointer to the result is returned. The exercise can be found at page 121 in K&R second edition. 

There is a dependency between my second implementation of and . I, also, have some problems with the naming of the variable . What would be a more suggestive name for its purpose? The exercise can be found at page 121 in K&R second edition. 

I have changed the type of the parameter to , thus it will handle the floating point represenation of a number. The condition of the first was extended, such that it will not push back in to the buffer a decimal point. The second computes the decimal part of the number, storing the number of places that the decimal point should pe moved in the variable . If there is no decimal part, will have the value - thus, nothing will change if I devide by when is .