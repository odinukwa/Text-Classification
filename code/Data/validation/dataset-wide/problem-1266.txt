How I would write it I've been writing a lot of C lately, so here's how I'd reimplement your idea. Mine writes a lot less STDOUT, but you could make it do more with the information the functions give you: 

This does declare and define a function in C99 and C11, which I hope you are using. See Is it better to use C void arguments “void foo(void)” or not “void foo()”? 

The method was written rather haphazardly as I tried to find something that seemed robust. The way the elements are finally formatted, using and may seem sloppy but it looks better than an , and can't be used on non-constant values. The recursive nature allows it to be cleverly repurposed for other collection types and on arbitrarily deeply nested arrays. Moreover, string literals in arrays preserve their so they roundtrip too, which I initially struggled with. But, can it be improved? The goal is that any collection converts into a string and s back into its original value (called roundtripping), which it does: 

I'm not quite skilled enough at Factor yet to review your code in full, but I would just like to note as a response to 

must be declared except if its return type is omitted, in which case it's inferred to be by the compiler. Compliant programs declare . Since C99, need not explicitly return -- if you omit a return value, the compiler will insert at the end. 

I've never actually seen this before, but apparently it's not good enough for the real pedants either. You can, however, use the first, simpler one, and satisfy most input cases as well as the compiler, who is right to warn. See What Every Programmer Should Know About Floating Point Math, and The Floating Point Guide. Opinion: omitting braces around control statements like is dangerous and ugly. The example oft provided is to suppose that someone, be it you or not, comes along and changes the branch: 

Ahh, maybe it should be called or so? And why does get a name while and the other operators don't? No apparent reason, so far. 

I was irked by the amount of typing in that, so I wrote a couple of tiny functions that live in my , so I can just do (for example): 

C is very cool in that you can do this in one line, but that doesn't mean you should do this if you don't have to -- and you don't have to. Here's one possibility: 

is not returned or modified, nor should it be. As such, it should be declared , so that the compiler may make optimizations and assumptions around the fact it will not change: 

Instead it gives the message that @vnp showed in their answer, that you should change to either or to . Having said that, the command line I usually use (and the one I put in my Makefiles) is: 

There are unit-tests, but I'll omit them for brevity. Most interesting to the reader is probably a usage example, so here you go: 

Fact: you cannot reliably compare floating point values with or . Instead, you need to use an epsilon and compare the difference, like: 

I've been working on a full stack web application for a school project, and I wrote antiCSRF without prior experience or example code to prevent Cross-Site Request Forgery attacks, and to differentiate users who have authenticated once from arbitrary anonymous requests. The original implementation (v0.0.1) was very short, and used a module-global token register, instead of a class, and reflected how little I understood threading and the GIL in Python. The second generation of antiCSRF (which I deem v0.1 because I think it's kinda stable) is about 400 lines with docstrings and comments in. The continued use of almost definitely continues to reflect how little I understand Python's threading, but it's in there just to be safe with threaded code, for which this is explicity intended. The implementation consists of 4 helper functions (of which only 1 is essential) and 1 class, , which is where it all goes down. One of the first pieces of code I've "designed" in a while, the keeps track of currently valid and recently expired CSRF tokens, as well as providing metadata and "lower-level" functions for more customisation of the API. Specify your own key function, key length and expiry time, or don't, and use the reasonable defaults. anticsrf.py 

When I'm writing Python, I wanna be able to pull up an interpreter quickly, and import what I need easily. Previously, this involved: 

Compiler errors First of all, this code does not compile with the (IMO too lenient) command line of : 

Perhaps this might be regarded by some as a non-issue, but for my workflow when I just want to test something quickly, it's really handy. The functions: 

Instead of writing C++ as if you're writing C in 1978, please use the family of functions: , , and a strnlen implementation: Microsoft's , or the GNU if you are using (Linux, some BSDs, etc). Additionally, in C++ you have access to nice functions like and . Doing so makes your code inherently safer (less prone to buffer overflows), more predictable and reliable, and far more modern. 

These are poor variable names -- you are not limited to 6 characters, like assemblers of old! Seriously, there's no excuse for these to be named this way. I can only guess that is the determined type of the input, is the determined resultant operator, and is the raw input string, but I shouldn't have to guess. Use better names, and then use comments for more complex ideas. 

I've never been too bothered by the lack of (and thus ) support for Factor collections and other objects, but I've never needed to generate Factor programs from JSON until now. To that end, I use these methods to turn arrays, hashtables and assocs into roundtrippable strings: 

Even better, use the newer and more explicit method. However, this changes the semantics of your code due to the different handling of : 

General considerations: Since you don't rely on an external ad network but a self-hosted solution, you might want to inject your ads into your HTML document on the server side, without the asynchronous client side ajax request. 

the 'manual' zero-padding of the timezone offset and its many if-else branches the many hardcoded numbers and strings the long illegible string concatenation 

For brevity, you could encode your messages in a three dimensional array with the dimensions representing row, column and diagonal (no-win = 0, win = 1). This is shorter but slightly less readable: 

Compute any sum of range by subtracting from . Each lookup now performs just two array lookups and a subtraction in constant time. 

Performance Test on V8 6.2 Below are average runtimes (in ms) measured after warmup (1000 preliminary calls). Best case - input queries repeated 

Filtering your operands with leads to strange effects such as returning for inputs with a zero such as and returning for input . Parsing: Instead of I recommend using the unary plus operator which is "the fastest and preferred way of converting something into a number" according to MDN. To split an expression into operands and operator, I recommend using robust regular expressions. A regular expression makes it much easier to understand which input strings will be accepted as valid and which input strings will be rejected. Implementation: First, the available operations are declared. Then, the input is parsed. For valid input, the result of the operation is returned. For invalid (non-matching) input, is returned: 

You asked what happens when you don't initialize in the loop body? Initially you create a single array instance . Then, during each loop iteration, you modify the content of this array and push it onto . So in the end, each index of contains a reference to the same array, similar to this: 

Enhancements: You might want to listen to the "blur" event and deactivate the dropdown when its focus is transferred to an outside element. 

You currently don't prune the forward history when clicking on 'goto'. I assume this is a flaw. Instead of splitting the history into a backward and forward array, I propose using a single array and keeping track of the currently active index. This allows you to simplify your logic, i.e. you can replace and with a simple . I also suggest separating and encapsulating the logic and datastructures needed to keep track of and browsing through a history. A dedicated history module or class is simpler to understand, easier to test and can be reused. The same can be applied to the view navigation logic. Depending on your view/controller logic, you might want to apply the observer pattern to your navigation module or class and listen to navigation events which would then lead to a rendering of the new view. Here is an implementation of the history and navigation as separate classes (without the observer pattern): 

As already pointed out, you need a more sophisticated approach to testing runtime performance of runtime-optimized code produced by modern JavaScript engines. I compared the performance of your datastructure against the built-in as well as plain objects on the well-known performance testing playground jsperf.com based on the benchmark.js library and got the following results on Firefox 53 / Ubuntu: 

It works. But you would then need to return instead of . Also, it is less readable as you re-assign the function's return value to the input parameter, which is confusing. Further suggested improvements: Naming: 

Since the best-case runtime complexity did not change, we only see minor performance improvements. The runtime is dominated by parsing speed. Worst case - input queries repeated 

However, the performance of plain loops is superior. Runtime Complexity If you have to deal with larger arrays and prefer to have an implementation with higher setup costs but linear instead of quadratic runtime complexity, convert the input arrays into sets first and use the much faster instead of . Generalization A generic solution which is not restricted to arrays but handles any iterable input could look as follows: 

2. Remove the redundant condition: The final condition is redundant as it is always when the first if-condition is . Remove it: 

6. Replace the declarative loop with a more descriptive approach: Exploit built-in methods and introduce new named identifiers for self-documenting code: 

First of all, when presenting a piece of code to fellow developers, you help them the most by letting them know what your code does and what the inputs and expected outputs are. You immediately start by describing how your code does something, which is a bit confusing. Regarding your code, I suggest the following: 

However, this function is inefficient for larger inputs as it iterates the array for each element. It's time complexity is in O(mn) where m and n are the lengths of and . You can improve on that by using a and come up with a linear time solution. Using rest parameters allows us to get rid of the slicing: 

That's it. I don't see how we can leverage any other built-in method to shorten above task. Using JavaScript's built-in gets us pretty far, but it is missing timezone offset and millisecond options and introduces unwanted separators: 

Now, when the number of pages changes, you need to touch your code and modify the initialization. So you will probably want to introduce function arguments with default values: 

We can then replace the large string concatenation expression by leveraging one of those array's or method: 

See also Is JavaScript a pass-by-reference or pass-by-value language? Now, if we look again at your implementation, we note that you already perform a regex test. We could perform a regex matching instead and get rid of all those redundant calls. I wrapped this new implementation in a documented function and ended up with: