As far as I can tell from first sight: if you have a situation where is initially and has items but the first item in that list (aka: index ) is then , and will not be set. This might not have been a problem but is never reassigned so it will remain . This will crash your program if a flow is followed where eventually will be called: there the field is used. This will result in a . 

However if you want to stay with your own implementation, there are a few things you could change around: 

This line of code allows us to loop from to or or whatever length we need. In effect this means we can iterate every value inbetween. Afterwards we create our entire new string by simply calling on the generated number. The difference with your code is that it now skips every call and a whole lot of padding. 

Unit tests Github Tests have been omitted for brevity. You can take a look at the Github link to see which scenarios I have accounted for. 

There's little point in storing this in a variable: it's never going to change anyway and you're not clarifying any of the intent. I'm fully aware that is a space and is a left curly bracket. 

Don't shorten names: it's Public properties are UpperCamelCase No need to spell out since the type is already obvious from the name You only use this field once so there's no point in assigning it to an intermediate variable 

Boolean queries return booleans, not integers! You are trying to do two things here: see if the author exists and return the ID. I am okay with you putting that in the same method but you're putting the focus on the wrong task. Instead I would name it and return if no record was found. Although I might just skip this altogether and use . 

The is just for demonstration and is to guarantee the correct ordering of the tables. The is not needed if you have other rules ensuring the id is found only from one table. If the id can be found from different tables just add a wrapper -query (the details left for exercise) to pick the first one only. Now just wrap that inside your PL/SQL as you see appropriate. When some information is not available in all tables it's up to you what is the value indicating missing value. It can be e.g. or or depending on the context. However I'd recommend unless there is other factors that rule that out. Hope this helps ! 

Your core problem is how to find out top-1 and bottom-1 in a single query. This is essentially a SQL problem and has not much to do with PL/SQL. First I present you the SQL solution and then simply wrap that into PL/SQL. You didn't provided table definitions. I was lazy and didn't tried to reverse engineer your schema but instead created very simple table that illustrates the solution that you can apply to your real problem. Other notes that might or might not be relevant to your case: 

This is very much the same idea I'm using to encapsulate "business logic" queries for re-use in PL/SQL code. So if you're looking for a validation of a concept you'll pass my review :) In a comment to the other answer you said this is just a snippet from a package code - that's good you're using packages. For PL/SQL apps in practice all code should be located in a package - a standalone subprograms a rare. The notes: 

is not a good name for a variable or parameter, because it does not tell you what it contains. It implies that it means "string", but even that is not clear. Call it instead. Use to distinguish member and parameter names. 

Having the type in the variable name is not needed, and rather bad practice. You might want to change the type later, for example to a tuple. Using a plural name (like or ) already tells you (and possibly other developers) that the variable contains a collection, probably a sequence of answers (and a list is a kind of sequence). 

This uses as a throwaway variable and assigns a new list to that contains an "_" for every item (i. e. character) in . Another one liner that would achieve the same would be , however I would prefer the former one. 

Your variable is not really a percentage, because it can have values between 0 and 1. Percentages are values between 0 and 100, so you could change the scaling and use a random calue between 0 and 100, or simply rename the variable to something like or . If you don't like any of those names and can't come up with a better one, change it to . Style In addition to the indentation, you are using newlines and whitespace in an unusual way. For example 

What are these values? Better be more explicit with the parameter names. When calling the method, you should not need to read the method's body to know what parameters to pass. It should be obvious from the parameter names. 

Your code makes it look as if you're testing some helper method inside your tests. What exactly is going on? Make sure that you are actually testing your application and aren't extracting all the effort into a "helper" method in your tests. That being said I'll assume that your method is actually the application. If it isn't then you are doing it wrong because you should use input in your tests that represents input which you will actually receive in the live application. 

Indentation I told you before that I liked it, but after closer inspection I believe it's actually too far indented. There's an uncomfortable long white area: 

Personally, I think your approach is very complicated for what it should be trying to do: loop over all days between the start and the end date and count how many of those are not in the weekend. Translating that sentence to code, gives me this: 

It doesn't read very fluently if you specify the namespace everywhere. I would suggest removing this for brevity. 

Your code generates multiple elements. I'm not sure if that's correct HTML (I couldn't find something that discourages it though). 

Inherit from instead of using composition. They define a trait of your type and should be used as such. 

You are sacrificing C#'s strongly typed model by allowing everything to be passed in. Afterwards you cast it to the expected type but you use which means the value will be if it happened to be the wrong type. This will cause on the next lines which call methods on this object. The solution is easy: make each method accept an object of type and embrace the strongly typed nature of C#. 

This assumes that width and height are the same, otherwise it gets more complicated. Also, you need to use when you loop over the other diagonal, as the direction changes. Doing the same for rows and columns when the width and height might change, you can do the following: 

There is a way to ensure that: Sorting. Sort your points locally within your hashcode method, first by their x value, then by their y value. 

This comment tells you nothing about the code that the code does not already tell you. It just bloats the code and requires you to read more redundant information. When you read , it is perfectly clear that the speed is being set. Comments should tell you why the code does something (if needed), while the code tells you what it does. 

Hint: Seeing later in the code that the angle is in radians, and one might expect an angle to be in degrees by default, a better name would be or , which I am going to use later on. Also, since means the rotational speed, I will later use instead. 

"Duplicates" is probably not the best name here. You would expect a duplicate to occur twice in the same collection of values or objects, not at least once in two collections. Maybe would be better, however still not perfect. You might consider using an interface like or even for the parameter types, to be able to support different types of collections instead of just arrays. 

does not really execute commands. The only command it knows is to shut down the bot. The actual command execution is done in . Since process commands only returns or (like error codes, but not quite) you might return a boolean that simply determines whether to close the bot or not. 

I'd avoid throwing because it will make it impossible later on to distinguish between an exception you've thrown and an unknown exception caused by code, should you wrap all this around a general to make sure nothing slips through the cracks. Often this is worked around by creating a custom class and throwing your selfdefined errors with that. 

Avoid try-catch in a unit test -- that means you're doing it the other way around. Using you've got most of it covered already though I could see why you also want to compare whether the code has changed. 

It's good practice to validate arguments as the first course of action in the body. Therefore I would suggest this instead: 

You are now manually setting to true, although this is actually a computed value based on whether or not is or not. It isn't unthinkable that someone might forget to do this someday so I would make this implicit: 

You're not using any form of globalization. Intended? Adding a resourcebundle isn't much work and you'll finally be able to support Swahili. 

Why use a try-catch and not a simple ? Exception handling is expensive and shouldn't be used for normal application flow. 

The comment doesn't tell me anything I don't know yet. Comments should explain why I do something, not what I'm doing. Naming Your class is named , which isn't very descriptive of what it means. would be a lot better and clarifies that it is a game we're talking about. Spacing Add a space before and after your binary operators like , , , etc. Right now the code gives a very compressed feeling. Braces I see this line of code: 

I'd solve the problem by providing a PL/SQL procedure that knows the "split"-logic. In the example below I assume that non-splitted rows are not inserted into the table at all but all inserts should be done with the procedure. This is a rather common pattern when there's data manipulations but it is not clear from your problem statement if this is an acceptable solution in your case. I used regular expressions as it's a very handy tool for pattern matching with superior expressiveness and clarity compared to spaghetti. I didn't used triggers as it's not possible to modify the table trigger is attached to. The solution can be easily applied even if you need to read the input data (i.e. non-splitted) from the same table. Example 

I'm afraid you current solution is a prime example of inappropriate use of PL/SQL when plain SQL provides much more elegant solution: 

Use analytic function (you might also consider using or functions instead) to assign an unique number in ordered sequence to each row. This is the standard way to implement top-N, bottom-N and inner-N queries in Oracle. Note that this example doesn't resolve ties. 

As bonus I also introduced you to standard SQL datetime-literal syntax. Let's create some data to play with: 

is always guaranteed to return a single number so the exception handler for is a dead code and should be removed. If you're just checking for existence there's no point to count beyond 1, thus enter . This also guarantees the returns either or . This might or might not help your query performance (check explain plan). It's a bit questionable if such an utility subprogram should record the exception or not but more information about your error handling implementation would be required to comment further. I usually don't but I'll let the exception propagate to the caller context and then record the full stack trace there. The good thing is that you (I just assume that from the name of ).