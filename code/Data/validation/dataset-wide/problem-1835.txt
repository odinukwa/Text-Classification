The Awk script locates the first MIME boundary, then the first empty line after that, then inserts the snippet, and sets a couple of state variables to prevent further processing. Unfortunately, the script is slightly brittle; it will fail if one of the extracted values contains unpaired double quotes, and process paired double quotes incorrectly. Furthermore, this will only work correctly if the first body part within the multipart is a text part; it will fail similarly to your current case if you have nested multiparts (top-level message multipart/related containing a multipart/alternative structure, for example). It can be extended to cover more cases -- a simple tweak would be to skip up to the first instead --, but at some point, it will make more sense to do the MIME manipulation in a properly MIME-aware tool (a simple Python script, for example). 

The error message you see is basically harmless, but it's Procmail telling you that it cannot create the default inbox with your current permissions -- you need to be root to create an empty mailbox. Creating it manually with the right permissions should resolve this issue. 

The cron job syntax is restricted to only so you cannot use Bashisms like . Fortunately, the fix is easy -- just replace it with . Similarly, needs to be replaced with (just a dot). Of course, the scripts you source mustn't use Bash syntax either if you intend to use them from . Probably the easiest fix is to migrate these things to your script (or create a wrapper script for Cron to run). Because inside your script, you can use if you like, provided of course that the shebang line is correctly (adjust the path if you have to) rather than . If you don't like that for some reason, you can inline Bash in your file by specifying it explicitly: 

The special operator causes Procmail to collect the matching string into the variable , and we then use that instead of the external you were running. This is hardly a crucial change, but should be more efficient, as well as easier to read and debug. (The trailing wildcard is superfluous in the first regex; Procmail is satisfied if a match is found anywhere in a line.) You can test from the command line (but this of course requires that your recipe file doesn't override ): 

If the Subject header contains a command you want to run, you are exposing yourself to an arbitrary code execution vulnerability if someone can learn or guess what your email looks like. But something like this: 

simply reports what the compiled-in defaults are; it does not examine your at all (and if it did, any nontrivial recipe file would contain a large number of mailboxes with different conditions for when to write to which). "Fall off the end" means if you have a which does not tell Procmail to deliver to a specific mailbox and stop processing (such as yours), the final action will be similar to if the last lines in your were 

Procmail can be configured in a variety of ways, also depending on how it was invoked. By default, in the absence of any , you would expect delivery in on most platforms where you can install Procmail as a precompiled package. If you compiled it yourself, you configured the precise location and delivery mechanism yourself, though if you didn't touch anything, this is what you should have ended up with. The output from indicates the default delivery destination for the invoking account. 

It's not clear what you want the single left brace to match; the way it's now, it's a syntax error. I'll assume you simply want it to match literally. 

This is easy enough to do if you use Procmail as the LDA. Here is a Procmail recipe to pass the message to two different scripts, then deliver it to SPAM. (Deliver to instead if you don't want to keep it; or equivalently, remove the flag from the last recipe.) 

This is a very basic regex error. In order to match or literally, you have to escape them with a backslash. The same applies to any regex metacharacter - , , , etc. Also, to match unconditionally, simply don't put any conditions. I'm guessing you didn't really mean to only allow whitespace after the matches, so I took those out, too. If you wanted to say "anything", that's in regex, but there is no point in having a condition whitch matches anything. 

To "place incoming mail into [a] specific folder depending on some set of rules" is precisely what Procmail does out of the box, but I guess you are looking for something like this: 

Here's what I have done. I have a set-up where a lot of messages tend to be delivered roughly at the same time; for a series of experiments I run SA on messages which are copied to a temporary spool and then delivered by a cron job every five minutes. would keep on printing "maybe you should increase the max-children parameter" and I had it raised up to 40 at one point, but I had the server consuming all its swap space and crashing. Now I have implemented a different regime where delivery is governed by a Procmail lock file. Because it was simple to do, I just use the last digit of the process ID, and run with 10 children. I'm not at all sure this is optimal, but it has already helped avoid the insane load peaks I wouled experience from time to time. 

If your mailbox is , Postfix will deliver , , etc to this mailbox with the part after the as the extension. As far as the MTA is concerned, the extension is simply ignored. You can basically invent new unique mail addresses on the fly by creating new extension parts on a whim whenever you need to share your email address. In Postfix, the extension separator is configurable. Out of the box, it is unset, though Debian ships a canned Postfix configuration where it is set to a plus character, which is also the character used e.g. by Sendmail; Qmail uses a dash. Eli the Bearded used to publish an email addressing FAQ about this; it's long abandoned, and obsolescent in some parts, but you can still find it archived on faqs.org. 

What you are describing is perfectly feasible, but Sendmail will produce a bounce message in this situation; that's part of the protocol design. The way to do this is to have Procmail abort with a suitable exit code, to communicate the bounce reason back to Sendmail. For example, to return a "user unknown" error, 

I ran into this on a host where a Nagios job was scheduled to check Openmanage. It would manifest as a large number of stale semaphores owned by Nagios. I put in a nightly job to find the stale ones by simply taking two listings 10 minutes apart; anything present in both listings is assumed to be stale. (Adjust for your circumstances, obviously.) 

Furthermore, the assignment is not a valid command; you have to refactor the variable assignment to be outside the recipe: 

These examples demonstrate how to capture something into with the special regex operator and we rather whimsically pipe the incoming message to a command which will simply ignore its standard input (we basically run it for the side effects). This will incidentally cause Procmail to regard the message as delivered; add a flag to avoid that (). Many Procmail examples allow for arbitrary whitespace after the colon etc but since these messages will presumably be machine-generated, that's an unnecessary complication here. This will not cope correctly with MIME RFC2047-encoded headers; if you require that, you will need to add a decoding step (Perl one-liner?) 

... but I actually like the former, more readable alternative. If you can somehow refactor the command line to read standard input and write to standard output, this could be made more elegant, at least so as to avoid the separate variable, and possibly even be refactored into just a one-liner. 

Your script could be quite simple; I leave the database details to you, and show a simple Perl script to log each incoming message to a file. 

You'll notice the backslashes to match regex metacharacters literally (but slashes are not metacharacters, so we don't backslash them; and actually, has a special meaning in Procmail, and doesn't match a literal slash!), and the to match just the one condition against the body. The double anchor is a Procmail construct which matches before the first character on the first line (and also after the last character on the last line). I'll also note that what you see in your email client can be quite different from the raw message which Procmail processes; for example, in a multipart MIME message, the first line of the first body part will be preceded by a MIME preamble and a MIME boundary. For a simple Cron message, this is unlikely to be an issue, but I'm mentioning it just in case. 

If you still can't get this to work, updating your question with a similar transcript whould be most helpful. Further troubleshooting tips can be found e.g. at $URL$ Once you are satisfied that your code works, maybe you'll want to prefer over which leaves the now rather useless in the headers. (Your prose description says but the code says . It is obviously easy to change if your code was wrong.) The Webmin stuff is truly atrocious but apparently it's not your own code. Somebody should supply the Webmin folks with a hint that Procmail contains a regex engine, so calling to compare two strings is really, really inefficient and generally horrendous. 

It's not hard to write a shell script which performs the same actions, but Procmail does a bunch of things to make sure email is not lost or delivered insecurely, so it's nice as a wrapper. 

The second problem is that the asterisk was in double quotes, so the shell was looking for literally, not as a wildcard to expand. The retrieves just the base name of the file, because the loop now iterates over full path names instead of relative paths within . 

The typical flow is rather one of delivery. Your question is tagged procmail so I assume a Procmail solution is acceptable. You should not need any additional MX records or other shenanigans. Sendmail (or any modern MTA; I would recommend Postfix if you are not particularly married to Sendmail for legacy reasons) can run a script on an incoming message quite trivially. When a message is accepted for delivery, the MDA (in your case, Sendmail) looks for any client hooks such as a file. If one is found, the file is parsed, and any pipeline in the file is executed. This is how Procmail is typically invoked on legacy systems (although more recently, a canned recipe to read the user's and invoke Procmail if one is found is part of the standard Sendmail feature set). Instead of Procmail, you could run a script of your own; or you could run the script from your (which is beneficial because Procmail takes care of a number of pesky error scenarios). 

This is slightly tricky because not all messages are MIME messages, and not all MIME messages are multipart messages. The following is thus probably a bit too simplistic, but works in my limited tests. 

I speculate that the first 122 processes are consumed by Bash itself, and that the remaining governs how many concurrent processes I am allowed to have. The documentation is not very clear on this. Am I missing something? More importantly, for a real-world deployment, how can I know what sort of is realistic? It's a long-running daemon which spawns worker threads on demand, and reaps them when the load decreases. I've had it spin the server to its death a few times. The most important limit is probably memory, which I have now limited to 200M per process, but I'd like to figure out how I can enforce a limit on the number of children (the program does allow me to configure a maximum, but how do I know there are no bugs in that part of the code?) 

In so many words, wants a file, not an email message. An email message typically consists of multiple MIME parts (your example shows a with just a single body part, but the concept still holds), which are not files. You need to pass just the encrypted payload, not the MIME container, to , or find a wrapper or option which helps parse the MIME wrapper. Quick googling turned up a simple Perl MIME wrapper which does this: 

It's hard to see any other solution than changing the on your side to an identifier which does not get filtered on their side. Based on the log excerpt, I'm guessing the organization you are corresponding with is Debian, and that it's completely out of the question that they would add a special case just for you in ther system. Not being able to send bug reports from when you could just as well use, say, seems like a minor inconvenience. You could configure an alias on your side to route replies back to your preferred address, and perhaps even correspondingly rewrite outgoing email from this address to this particular destination, though that seems like a lot of work for very marginal gains. 

If Postfix is correctly configured, it will know how to run Procmail out of the box. Just create a simple file and send yourself a message. Detailed guidance e.g. at $URL$ but do read through to the end before you spend time on this answer; the last paragraph suggests you don't. You don't absolutely need Procmail for this; I believe you could configure Postfix to write to your Go program directly. But unless your program is extremely failure-resistant, Procmail offers a security scaffolding which is useful as a safety net at least during development. To have a copy of every mail message for a user account be piped as standard input to , the account owner's only needs