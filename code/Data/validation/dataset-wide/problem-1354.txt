For more information about Javascript code that interacts with the DOM, read this article. I know it criticizes use of jQuery at first, but the rest of the information is really valuable. 

Before getting into the code, I would suggest reading this article Stop writing slow Javascript. It has some good techniques for reducing time needed for DOM/page interaction. And while it is over 9 years old, JavaScript Event Delegation is Easier than You Think explains the benefits of event delegation as far as memory goes. resetDatePickers The configuration for the two date pickers is very similar. The date selected handler and the min date on the to date are the only real difference. A date selected handler can be used for both fields, depending on the id attribute of the selected date picker. 

Bug I tried converting from base 10 to base 2 (i.e. binary) and the output was , which is invalid for a base 2 number. Also, when I ran the output was , not Your Question 

But I am not sure about replicating the debounce effect in ... maybe that could be achieved with a watcher (perhaps making it more complicated). 

I agree with the comments by Michał Perłakowski. The Fetch API is nice, though it was pointed out in a comment that it doesn't support aborting requests (except possibly in firefox). Other tools like SuperAgent do allow aborting requests. 

And you could select that parameter as a hard-coded value, so as to not need to assign it to each row in the , but then that would make the result set larger... Global variables I see this line: 

Adding elements to the DOM In this article, there is a section Use a DOM DocumentFragment, which suggests calling and adding elements to that, then after all elements are added to the fragment, append that to the DOM. Your code would need a little re-working as far as the cells go but shouldn't be a major job... Possible use of Event Delegate If there were a lot more elements on the page that needed to have click events handled, I would suggest using an event delegate instead of adding an event listener to each one (e.g. the cells) - especially if the elements would happen to be removed from the DOM in some cases. Actually, the codepen example appears to already have an function defined - that could be turned into an event delegate to handle all click events. Update I tried removing the DOM references from each cell and replacing it with an index into an array of the elements. That didn't appear to help speed up the function much at all. It appears to stem from the fact that calls , which calls , which might also call depending on the depth... I would seek a simpler approach to finding the optimal place for the AI player to make a move. 

I don't really think there is a downside to this approach. Below I outline an alternative approach to updating the text - it may not necessarily be better but possibly more robust. Feedback This looks like a good approach - who needs the fakepath anyway?? I tested this code in Windows 10 Chrome, Firefox and Opera; Safari on Mac OS X, as well as FIrefox on Linux Mint. It appears to work in all except in Firefox on Linux Mint, where the output tag text was not updated correctly. I was able to update the code to use Element.innerHTML for setting the HTML correctly. Alternative approach An alternate approach is to use String.split() on the file input value, splitting on , then use Array.pop() to get the last item in the array. Expand the snippet below to see it in action. In theory, this alternate approach should be quicker because it just uses string splitting and array access instead of a regular expression replacement... Here is a jsPerf test - so far it seems it is quicker to use the split() technique in FF and Edge on Windows but not Chrome... 

I would suggest adding the message to the DOM via the success callback - that way, if an error occurs then the message isn't displayed on the page. Other feedback Javascript Cache DOM lookups I would suggest you cache DOM references - e.g. store , , in variables (or better yet, constants if you are using es-6), preferably in a DOM-ready callback, because DOM-lookups aren't exactly cheap.... Accessing elements by class name can return multiple Also: is equivalent to ... which returns multiple elements. While methods like and operate for the first matched element, it would be more appropriate to select an element by id (i.e. with an id selector). with nested I don't believe it is necessary to add the window load callback within the DOM ready callback. Also, bearing in mind that you posted this code a couple years ago, is now deprecated as of jQuery version 1.8, because there is a new method in the AJAX section. Note that in the line below, is called and does not return a function, so the call to appears superfluous: 

only applies to and not all of the variables combined via the OR operators. You probably know this but one could omit the , since anything that doesn't evaluate to a boolean will be considered 1. 1$URL$ 

localStorage considerations It might be wise to put the images in a sub-property of the localStorage, otherwise if other data needed to be stored there, the current code would attempt to load images based on that data. For example, if the following data needed to be stored: 

While you might be mostly interested in feedback on the Python code, I am still working on my Python skills. I can say that the use of storing the data in the JSON file and reading it looks good. Perhaps I can offer more feedback on the Python code in the future. I can however offer feedback on the JavaScript. Code duplication It appears that the code in the and has some redundancy. The redundant code could be abstracted into a separate method like below: 

That way each method is declared only once instead of once per each instance. That would have huge impacts on the memory used by the browser. For more information about that topic, read about it in this post Conditional logic The logic in the Enemy method that conditionally negates the speed, I.e.: 

Obviously there are other ways to handle setting the values within the emotion property on , but those might likely require more lines. One could also conditionally display list items (e.g. add before the line that pushes strings into ). If there was a way to filter with a callback when calling that would be an advantage here but unfortunately it doesn't appear that is the case. Other review points Feedback The code looks quite succint. There are two DOM lookups at the start but then one DOM lookup in the click handler so that could be cached in a variable. Suggestions vs / Perhaps you have already learned more about and since posting this question but many es-6 developers would prefer using for values that don't change (e.g. , , etc.) Template One could also utilize a script template to display the list items, though that may not be desirable here. Invalid HTML when Error occurs This line in the promise catch: 

However if either keywords or employment types are omitted, there would still need to be logic to determine which of those is still present... So perhaps it would be better to give more generic names for the first two - like and ... 

Some might argue that storing the method call in the variable just adds an excess variable that is only used once. Unless the method name is long, it could just be condensed into the conditional: 

P.S. Your comment makes me think of adapting a quote from the Most Interesting Man in the World: "I don't always have a second monitor, but when I do I open the 2nd Monitor" 

A couple improvements: Pop from array and iterate over remaining items in nested loop I tried to modify the nested for statements used to add to and use a functional approach like with array_reduce() but instead found the example in this answer. Consider shifting (i.e. popping from the beginning) from the array to yield an array with the remaining elements with which to generate pairs. 

Could be simplified with the use of http_build_query() with encoding type to replace the rawurlencode: 

return value unused from The return value from the function to compare the hands doesn't appear to be used: 

Abstracting common code to a function One could pull out the common code to a common method. The name suggested below could perhaps be improved but at least it describes the task. 

Obviously the code works but it can be simplified in a couple ways. Event Delegation I would recommend using event delegation. Instead of adding click handlers in the HTML, a single click handler can be added in the JavaScript code to the element containing all the tags (or could be attached to ). Then refer to to know which element was clicked. In the sample HTML given, the user might click on the anchor tag (specifically where the text is) or just to the right of it, which would signify clicking on the tag itself. To determine if the anchor tag was clicked or else the parentNode, .parentNode can be used. One main advantage here is that the markup (i.e. HTML) doesn't need to contain any logic about handling the clicks - that can be separated and left in the JavaScript. This could be a separation of View and Controller code (a la MVC). In the code snippet below, addEventListener is used to register a callback when the DOM is ready (via the DOMContentLoaded event) to be interacted with (i.e. querying, adding event handlers, etc.). Then it finds all the tags and iterates over them to set the class according to whether the element clicked was the current tag. Spread operator Note that the snippet below uses the EcmaScript-2015 (A.K.A. ES-6) spread operator to get an array from the NodeList returned from . One could also use Array.from() instead of the spread operator. 

It is difficult to know exactly what would have made my code more "correct" but it does look like the method is more complex than it needs to be. Specifically, there is a loop that is not needed. Perhaps you were attempting to guard against cases where is not actually a property on . That could be achieved using Object.hasOwnProperty() - for example, the loop could be replaced with this block of code: 

Foreword I know that this was posted nearly 1.5 years ago and the code appears to have changed dramatically and perhaps you've already learned about what I will mention below, but I feel like this question needs an answer... Feedback I like the good use of the Notification interface, as well as the radix passed to . Suggestions 

functions don't need to accept as parameter The function accepts as a parameter but as it is currently written, could just access that global variable. As mentioned in Gerardo's answer it would be wise to limit the scope of variables using IIFEs. jQuery Your code doesn't appear to use any jQuery (though perhaps you removed any jQuery code when you added your code to your post - if that is the case, then ignore this). There is no point to adding the script tag for jquery.min.js. While that file is minimized, it is 29 KB of useless data being downloaded for users everytime, plus time for the browser to parse it, etc. For more information on this front, see You Might Not Need jQuery. Cache DOM references DOM lookups aren't exactly cheap, so it is advisable to store DOM references in a variable, and then utilize those variables whenever needed. For instance, there are two lookups in . Those can be moved outside the function - perhaps it would be wise to move all the code into a DOM loaded callback (e.g. using document.addEventListener for the DOMContentLoaded) event 

Like I alluded to in my comment, I considered voting to close your question because point #8 looked like a request for help implementing code that doesn't work. Alas, I will review the working code. Feedback I agree with the points in the answer by Simon - especially that there is no point to only setting if it is falsey. Below are some other aspects that I noticed. Rendering a list without a key See the section key on the List rendering page of the Vue JS documentation1: