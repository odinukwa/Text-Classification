The algorithm will probably not be an order of magnitude faster (slower? could be!) than a bunch of ifs or a switch statement, but it will definitely be more readable. It also has the advantage of being dynamic, since you can add or remove keys from keysToIgnore. Note: If you have to perform the iteration process many times, it could be faster to simply filter out the keys using and the algorithm described above. 

I have re-written the whole code to make it more modular as well as taking advantage of prototypes. The way your code was written was quite inefficient since everything had to be redefined for every newly created instances of or , since the whole code was inside constructor functions. Unfortunately, there is no way to enforce the privacy of non-function instance members without sacrificing the benefits of using prototypes, so I've used a naming convention to identify private members: they start with and underscore _ (it's a very common practice). You will also notice that I've extracted the logging strategy out of the and allowed to inject it instead. I am still unsure about how that feature should be designed (perhaps an AOP approach?), however it's better than having it encapsulated within the class. Anyway, have a look and let me know what you think. Note: I haven't changed anything related to the processing logic since I wasn't enough confident. 

All good answers. I'd like to add my two cents to @deepee1's answer. If you keep the FoodItem class he provides (with a constructor), you can create a list of food items and then create everything else with completely DRY code. You can even easily move the definitions out of the code. Not to mention creating n different UI's with the same "logic". Here's what I'd do: (Forgive any mistakes, long time since WinForms :) ) 

Notice that I replaced your setter with an method. It's ususally good practice not to replace an entire encapsulated collection using a setter. Although you can validate the entries in the setter, a property should not do much logic other than returning or setting privates. If you have a look at the collections in the BCL, they all expose an method and a method to empty the collection. The method also gives you the option of adding multiple sets in turn. If you need different logic when stuff is added etc, have a look at the template method pattern: $URL$ If you need multiple base classes with differing logic, you could combine the inheritance with the extension methods, or another base class. :) 

I guess this plugin could be useful, however I think you can drop the async part since it's not any harder to call directly. Also, I am not a huge fan of error swallowing or ignoring invalid calls since it makes the code harder to debug. If there's a call to without providing a callback, you should let the developer be notified. I also like to allow defining the value for the callback function so that you do not need to use for that purpose. Finally I allowed to return a value from the callback to change the target object for the rest of the chain. However I am not so sure about this feature since it could harm code comprehension but I am leaving it there as an idea. Basically it would be as simple as: 

You aren't renaming it either, you're naming the parameter for the anonymous function the lambda expression represents. But if you don't like the lambda syntax, there's also overloads taking the property name as a string. 

This might be off topic, but if you use switch statements for more complex functionality, you should read this before going further. $URL$ 

I'd use enums. My suggestion presumes you are able to refactor your existing code a bit. If your control can be modified to keep the position value in one property of the following enum type, this will work. 

Of course you can expand on that by employing the template pattern for the extra parameter settings. I would also look into extracting the parameters to a "parameter object" instead of several parameters. 

I think you are mixing up different concepts here. Presentation logic is quite different from domain logic and both shouldn't be mixed together. I'm having trouble understanding what you are trying to achieve (what does the checked status means in your domain?), however in my opinion a should be expressed in domain terms and should not have any knowledge of specific ui data such as visible, checked...etc. I strongly suggest you to read about MVC. There are lots of MVC, MVP, MVVM... flavors in JS and that's why we mostly categorize these as MV* rather than MVC now. 

Something like this perhaps? I've used an object as a map for quick vowels lookups and took advantage of the fact that the function takes a replacement function. The whole transform is done in a single replace operation. Note: I assume that we were only replacing lowercase letters, but it would be easy to handle all cases. 

I've done something like this a few times (a lot even), but most times it was a complete waste of time. You will probably not earn the time you save by not doing WebForms markup, even if it's terribly boring. If you have like 100-200 entity types to display in similar lists, it might be a useful path, but if it's 10 - go with good old aspx/ascx markup. If you don't need a lot of business rules and/or scalability in some form, go for markup only with SqlDataSource and WYSIWYG listviews. If you need a fancy UI, go with Telerik. Given you actually have multiple customers with different list needs for the same entities in the same product, this might be "the only" way, though. With regards to your code, it seems slim and clean enough. But beware when going further with this - you might get a lot of conflicting requirements. As you say, it's a good thing to separate responsibilities, so keep doing that if you really want to make something "re-usable". (It won't be, but still..) 

EDIT: Here's another way to create the map without using reduce. Like pointe out by @JanDvorak, the reduce construct might affect readability, however I like it since it allows you to define the map in a single statement, which is quite useful when you advocate using a single statement. 

EDIT2: Here's my implementation packaged within a reusable function. I know this is an exercise and that it's probably not meant to be reused, however it's worth knowing how to do it ;) 

One of the simplest and probably fastest way to do it would be to store the keys to ignore in a fast lookup structure, such as using an object as a map. First you need to build the map, which takes O(n) time based on the number of keys to ignore, but allows you to ignore keys with a condition that will take O(1) time to compute.