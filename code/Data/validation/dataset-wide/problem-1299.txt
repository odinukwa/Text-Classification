In your implementation, what happens when the site inclusion has values but does not match, and site_exclusion is null? It seems to not match any of the conditions, which is not in sync with the requirements from my reading. Also what happens when the site inclusion has values but does not match, and site_exclusion has values that does not match? In your implementation, it seems like site exclusion takes precedence. But that does not seem to be the requirement. Perhaps I am reading either requirement wrongly or your implementation conditions wrongly? A rather terse implementation that is same as above is, 

and use this in other methods to avoid repetition. I would also recommend moving the getTblHerd to another class - say Herd because it has an independent identity other than db_tables. Here is an example of using the above method 

The given problem can be attempted in a slightly different manner. You can see that the pairing corresponds to binary digits with { standing for 1s and } standing for 0s. For e.g the pairing with the maximum value for say 4 {}'s is 11110000. So all we have to do is to generate every number from 1 to 11110000 and strike out all numbers that do not conform to our requirement - that is, at no point while counting the digits from left in a number, can the number of 1s be lesser than the number of 0s, and also that the total count of 1s and 0s must be equal. A few optimizations can be done, For e.g, all odd numbers can be eliminated. And the total number of digits have to be even, etc. If the number of braces are , then the algorithm is of complexity. So it is not an efficient algorithm. I wonder what the complexity of your algorithm is, and how you can show that your algorithm is indeed correct. For additional ideas ref: catalan numbers. 

Your code does not really care about mime, other than to skip it. Other than that, it cares that is seen only once. This seemed to be an overkill for bit fiddling. Removing that, 

Your fetch implementation feels like it is partly done. I would prefer fetch to either read the image or move the opening of uri completely to save. Right now, the resource (an open connection) is acquired in one method, and used in another, while you could have done both in one go, and avoided that. (I suppose there is nothing wrong in that, but it just feels wrong.) 

Consider making an error function err() { xecho $@ >&2 } errexit() { local exitval=shift; err "$2" >&2 exit $exitval } I feel cat is cleaner than multiple echoes, but it is just a preference. Also consider making verbose a function 

My preference would be to make a tuple - i.e which is an immutable D.S and hence would be faster than a list. But it may not count for much. 

It may not matter a lot for this case, but usually when dealing with XSLT our rule of thumb has been, always to handle different cases with different stylesheets rather than one huge complex XSLT. 

It may be a good idea to write an abstract class as an interface, and then write the concrete class to conform to it. Another idea is to try to templatize Node so that the data can be any type. Also look at the stack class in STL You may also want top() and empty() methods on logic: If you are going to implement a stack using a linked list, you don't really need to keep a first and a last. Just keep the reference to the top element. On push, create a new node, set its next to the current top, and set it to top. On pop, set the top to the next of current top, and delete the node. Something along the lines of: (may contain bugs.) 

Also remove all the magic numbers like 600. They should be named with some meaningful names, and those variables/constants should be used instead. You can reduce some thing such as this 

Some observations. The space between #! and the path to binary is not needed. (It used to be for some arcane versions of Unix but not anymore AFAIK) Secondly, I prefer to let env find ruby for portability. 

How can I improve this? This question is a rather interesting one. By upping the count of stacks to three, we can no longer be assured of an optimal utilization of the array (for two, each stack could start from one of the ends). So the problem here is that of optimal utilization of the array, Your solution divides the array equally into three, so that even if there is space left in one of the stacks, your other stacks are unable to use it. Perhaps it would be profitable to consider the more general case of storing stacks in the array. If you think about it, the problem is remarkably similar to memory allocation or file space allocation in a hard disk. This would be my approach. I assume that the array is an array of integers. 

A small observation about your code is that it prints the error to the error stream in the case of errors. This is not always the best solution. A better idea is to indicate the error with a return error code and let the caller decide what to do about the error. (This is not implemented in below code.) 

Welcome to programming :) I did not understand your question first, then I realized that python might be your first language. In that case congratulations on picking a very nice language as your first language. Your question seems to ask for the list which is the shortest prefix of nums the sum of which is greater than the limit. Here, you might notice that it does not care about the intermediate values. Alls that the function asks is that the return value be greater than the limit. That is, this should be the output 

Using auxiliary definitions can make your code read much better. Prefer sequence to do notation when values are not used in intermediate computations. Try to move out of the imperative mindset when using do notation. (the do notation makes it easy to write 'c' in haskell :) ), using auxiliary functions can help you there. (I used case instead of if/then because that is what I prefer, there is no particular reason for that except that it makes it easy to use destructuring easier if I need to.) 

Regarding the whole organization, it might be better organized as a small command interpreter with specific commands for hint, level etc 

Note that the way you declared your data structure for Classifier, you get the function 'training' defined. So there is no point in extracting it using @ as you did. 

Where possible use function composition. From my experience, it makes it easier to understand the essence of the function. Also if there is a choice between composing functions and using parenthesis or $, go for (.), That would make refactoring easier later. Use currying in preference to explicit lambdas.