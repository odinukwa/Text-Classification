These three stages are automatically achieved using the copy and swap idiom. No need to check for NULL before deleting. 

But please put the closing brace '}' underneath. There is absolutely no need for this insane attempt at saving space and making the code unreadable. Also this would make it consistent with the rest of your code (which is much more important). 

The difference between the two is a flush. Usually you do not want to manually flush (the stream have good flushing techniques built in). So it is usually best to let the streams flush themselves when appropriate. 

This is a sign you have done a bad job naming your variables and you need to explicitly differentiate members from local scope variables. This is not the case so simply return what you mean. 

But is not the only stream you can print to. How about a file or a socket or an internal buffer before writting to a socket. I would pass the stream you want to display on as a parameter. It can alwjays default to but allow a user to specify an alterantive: 

Get and Set That seems a bit obtuse. When not just one method that returns a reference to the value. You can then use normal assignment to the element. 

Because of the default implementation of these methods a class that "Owns" a pointer will not work as you expect. Note: Owns means that the destructor will delete it. But the general rule is if you define the destructor or any of the above operators you must define them all. If we look at your current implementation: 

Also you are re-defing a system method using #define (I am relatively sure this is not allowed and causes undefined behavior though I can not quote chapter and verse). 

You need to re-read me comments. This dice is lopsided. Some of the lower numbers are more likely than the higher numbers. But better yet go back and implement it using the modern C++ version. Code Review Classes Your class are all public: 

Then when inserting into I would use a back inserter. The reserve() makes sure that you will never need to reallocate the space but you don't make the string too long. Then use the back inserter to increase the size of the string as needed. At the end you don't need to shrink to fit. 

General Style My main problem with the code as it stands is that it is messy (and thus hard to read). The contributing factors are: 

You are only allocating size space. But your capacity is 20 bytes larger. Why 20 bytes? Should this not be 20 objects BUG: You use the allocator construct routines when you are doing . This means the space has not been constructed before. If the location has already got an element in it you must copy over it using the copy constructor. Thus in 

You are using a runtime loop (over each bit). You could use a compile time loop over each byte. Because the number of bits set for each specific value for a byte it is easy to pre-calculate. Note: For each byte there are only number of bits (usually 8). Which is 256 values. So you can swap space for time here for a single byte. 

Everything @Jamal said: When reading user input prefer not mix with as one reads and discards new line while the other does not and this can cause confusion as to where on the input stream you are. Secondly user input (when done manually) is usually line based (ie the input buffer is not flushed until they hit return). So it is best to read a whole line at a time then validate it. Remember scope: 

Yes its still the observer pattern (details in my comment on the question). But there are a few implementation details that are bad for a C++ context. Good interface for your observer: 

I can forgive putting the '{' on the wrong line as about 30% of developers prefer that way (the other 30% prefer to line up open and close and the final 40% don't care (as long as you consistent)). 

Took me a moment to realize that this a lambda and a separate thread not the main thread. I think you can make this clearer by actually moving the code into a method or function so we can see that this is being run be a different thread. You are not providing a guarantee that your is going to enter the loop before you start scheduling jobs on the thread; is this going to be a problem? If not I would make some explicit comment to that affect. Could use RAII here: 

Prefer include guards. Its not that hard to make them unique. Make sure they include the full namespace and file name 

It looks like it works. But when I see the merge sort I usually see the empty array cases have been yanked out of the loop. 

They did not want to pay the price. So they provided the code that allows you to test the state before use so you can make sure you use it in the correct state. 

Also for complex types of you should allow the object T to be built in place by forwarding the constructor arguments for T. 

From your code I would not subclass iterator_base. I would redefine it slightly but then use typedefs to get the two iterator types. 

They provide absolutely no benefit. In fact they are considered worse than useless because they give you a false sense of security. The better way to get the compiler to tell you when there is an issue. Get your compiler to treat warnings as errors (because warnings are actually logical errors in your thinking). Then you compiler will never let you use the assignment operator in a test. Doesn't “if (0 == value) …” do more harm than good? In C and C++, what methods can prevent accidental use of the assignment(=) where equivalence(==) is needed? 

The standard erase-remove idiom does not need to do this because it works out what it needs to remove first. Thus saving this cost (even if it is very small). This does not work on all container types (in pre C++11): 

Fair enough. Lazy but OK I suppose. Personally when using like this I bind it to the tightest scope possible. 

Whether you use or upper case letters to separate words is very developer dependant. Just be careful not to use as the first character in an identifier (The rules about its use there are complex and even if you know the rules not everybody does). Why does the standard not follow this convention. The standard got written over a long period (it was not all there in one shot) and as a result has a mixture of conventions. By the time the committee realized it need a convention it was too late now. But in the standard everything is lower case. 

Secondly don't use pointer. In modern C++ it is very rare to see RAW pointers (as they have no concept of ownership). And they are prone to leaking. you should be using either or containers to hold your dynamically allocated memory. In this case a container would have been better. 

Edit: Based on new code for Producer/Consumer One would assume that the producer needs to finish at some point. You may want to change into or similar. 

Using is not a good idea. Prefer . The difference is that flushes the stream. Flushing is usually always wrong. The streams will flush themselves at appropriate times let the code do its work. Note: The most common complaint about C++ stream is that they are slower than C stream. This is usually down to inappropriate calls to flush that significantly degrades performance when done incorrectly (and manually is usually always incorrect). Questions: