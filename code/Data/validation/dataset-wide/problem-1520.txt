is going to throw an every single time, since you never do before doing . The proper way to do it (incorporating some good suggestions from @mnhg's answer): 

The way I would do it is by simply representing the headers as map of to . That'll be the most flexible and extensible situation, since HTTP headers are added over time, and custom headers are completely acceptable and allowed for by the standard. Any solution involving struct fields will require updating as the standard expands, and can't handle custom headers easily. (You could handle custom headers the same way as standard ones, but then you'd have the problem that their meaning is not standard, and different clients could use them to represent different things.) The downside of making the map values be is that you'll have to translate into the proper data type wherever you retrieve them from the map, rather than only performing this translation when you read the request headers. This is an acceptable trade-off for the flexibility you gain, and you can find a way to encapsulate it if desired. 

I think you are running into a fundamental problem I often have with anonymous types: they are anonymous. C++0x has some interesting extensions for getting types back from anonymous types, though I am not sure they would help here. I suggest creating an explicit type to replace the anonymous type. This may cause early evaluation of your query. 

I am not sure if Reflection wouldn't be the ultimate solution (you would need to use a custom attribute to indicate non-matching CSV headers), but one possibility is to manually create a map for column names to fields in the class: 

You can create a group number for each matching sequence of keys, then group on these group numbers: 

Note: You could use reflection to assign values as well, but I figure it is worth the effort to build the lambdas since you presumably will be assigning to the fields often (once per CSV file row). Now you can annotate the class with CSV information: 

This is also a raw type. Its name also tells me nothing. What are you mapping? A better name would be , or just . 

To me (admittedly a non-PHP guy) this is an extremely strange pattern. A and an would seem to be model classes, but here you have them making database calls - you're mixing concerns for these objects. This is a great situation to use the data access object, or DAO, pattern: 

Is this actually a counter? It seems like a summation, and should be called something like accordingly. 

Dependency injection is infectious. Somebody somewhere has to know how to construct your object. If your object has its dependencies injected, then it has to know how to construct the dependencies. If it doesn't know that, then the next level up has to know, or the next level from there, or.. etc, etc. The result of this is that.. Your classes become more tightly coupled. Some of your classes become aware of the dependencies of their other classes, by virtue of having to inject their dependencies. A good dependency injection framework can help with this. I don't use PHP much so I'm not aware of any. 

Note: Since is a read-only property, the method would skip it even if it didn't have the attribute. Finally, you can convert the CSV file to class members just like my previous answer, using the setters to assign read-in values: 

Since I was looking at similar functionality for runs of sequential numbers, I thought I'd offer my LINQ solution to this. Using an extension method based on the APL scan operator, which is something like an that returns the intermediate results, which I also have modified to use to pair the scan value and matching element so you don't have to use s and keep up with it manually: 

Then you can create another map to map header names to column (field) numbers and process the mapped fields: 

I think the concise version is longer and more confusing, and emphasizes the wrong return (assuming the value of SomeProperty is what is really of interest). For the verbose, I don't like returning the same value more than once, even if it is a constant - so a variation on the verbose: 

I thought about removing some of the left margin when posting, but then realized that this is another rule of thumb to point out: do you see how deep your function blocks are getting? That is a sign that your function is doing too much, and should use more Top-Down Decomposition. The use of to index each position of the string is not the usual way to do things in C++. Anyway, see how many times you use ? Did you think about some way of doing the subscripting once only at the top of the loop? The three punctuation marks are unchanged, but what about all other marks? I think you really mean to pass everything that’s not a letter. The cases for x,y,z, which are the ones that wrap, is kind of clever. But again you list each line in full thee times instead of using a conditional to specify all the cases and one thing to do with those. But really, what you want here is modulo. And don’t be afraid of (more) Top-Down Decomposition! So a first sketch becomes: 

This becomes an algorithm instead of the algorithm you're using currently. You can then post-process the map to filter out the companies you aren't interested in. 

You may not only ever run your code against a single database. For example, if your project grows large, you may have separate databases for different regions about the world (North America, Europe, etc). You could also easily have a database, or a and an , etc., etc. All of this can be controlled by configuration. Of course, you could put this configuration-based logic inside your class, but.. You may want different types of databases. Right now you might be using MySQL; later you may use Oracle, or PostgreSQL, or an in-memory database, or a mock database that has no backing store. Using dependency injection lets you very easily switch between these, provided you adhere to the same interface for all of them. You may even start in one region where MySQL is readily available, then expand to another where you can only get Oracle hosts. Changing types is useful for easily changing technologies later, but also because.. Using dependency injection makes it easier to test. You can test against an in-memory database for your unit tests, and against an actual remote database during integration testing. 

Then you can create a static method to build the PropertySetters for you by Reflection. You need a couple of extension methods to make easier to work with: 

That is a good definition for an but I believe it is better to implement the operation directly for an (note: I don't use VB, so translated from C#): 

Part3 will have the same issue and you can create an explicit type if you want to refactor out the query into another method in the same way as part 2. I run into this quite a bit and have yet to find what I think is a satisfactory solution, so I end up creating explicit types instead. 

Here is another answer, using Reflection, and to create a more automated solution. First you create a couple of custom s to mark fields or properties with the CSV Header Name when it doesn't match the class member name, or to indicate a class member isn't initialized from the CSV: 

This code is unclear to me. Why instead of just - do we expect the input file to be inconsistent with itself? That seems like an important caveat to call out in comments. The behavior of the counter is also very unclear. You only want to store factories with a total price of at least 10000? It would be simpler to do the summation in one step, then filter out the unwanted factories in a subsequent step. 

Here you never refer back to the values stored in the map. If you're not going to refer back to them, you might as well just use a . As an example, here's how I would store the prices: 

You're missing the (or if you're using JDK6 or below) on the right, which means the right side is a raw type and not a generic. Your IDE should be configured to warn you about this. In addition, what does mean? It's completely unclear even from context. You should almost never use abbreviations unless they're industry-standard, and maybe not even then.