For the refactoring, I suggest that you should wrap the logic of the for-loop into a do-while loop. Something like this: 

Objectives of this review While any suggestions/remarks are always welcome, below are the points which I'm mostly interested in. Implementation 

As it is now, it is the responsibility of the clients (in this case the repositories), to take care of this. Also, it is only true for entities created within the same repository. So, I would recommend either moving the description of the constraint to the repositories (this solution would still have another disadvantage, i.e., that it prevents passing 's to -- more on that below), or really make it the responsibility of this class to enforce that. One possible solution is the following: ID should not be a constructor parameter, but should be assigned to , increased in every call to the constructor: 

Braces around blocks: I recommend always putting braces around each block, even if it is just one line. In your case (also, with the correction above), this would look like this: 

But as I understand, this code does not show any digits, just fills a space with a colour. Is this the intended behaviour? If so, then I suggest documenting why is it like that (in a comment), otherwise, I propose to extend the functionality so that seconds are rendered as well. On a side note, I recommend to use always the block-form of if-else statement (and any other statements), even if it has just one instruction per branch. In other words, I suggest rewriting it as follows: 

Post Condition The post condition would pass even if the result is something like "PlingPlongNUMBER". (If I understood correctly, then the result should be either NUMBER or any combination of Pling/Plong/Plang, but never both.) Therefore, I suggest a post condition like the following (not tested!): 

Further remarks: Robustness I recommend some extra checks to your program, to make sure that it is robust to potential wrong input: 

In order to understand how the lazy sequences work in Clojure, I decided to implement the quick-sort example from the "The Joy of Clojure, Second Edition" book simulating lazy sequences in Java. Of course my version of (lazy) sequence is much more simplified than the Clojure one. From the linked source, I basically implemented function as and as class. is a rudimentary representation of the functions passed to to produce the next value. The main question of this review is, whether my Java program grasps the analogy correctly, i.e. if my code represents what is going on in with a Clojure . Besides that, I would be interested whether the implementation could be made "nicer" in some way (I especially do not like the loop in the body of , but I could not think of any better. Also, I wonder if the field could be anything better than , given that it has to store s and s of s at the same time. Last but not least, any further suggestions for unit tests would be welcome. (Of course, any other remark or suggestion is also very much appreciated.) One last remark: I have only very basic knowledge of the new Java 8 functional constructs, that's why I did not use them in this example (also I am not sure if they would apply at all). Any suggestion taking advantage of Java 8 is still very much welcome, though. NextValueProducer.java: 

As I said above, I'm not saying that this suggested change is necessarily better than the code you have now (in fact it is a bit more over-engineered). It is rather a way of exploring how to further OOP-fy your code. Test Code Let me first say, that I find it a really positive thing that you write your code with testing in mind, and add unit tests to cover (almost) all the cases. That said, some remarks: 

Out of scope The quality of the hash-functions used for testing is out of scope of this review. (I know there are much better ones, but for now I focused on the data-structure itself.) However, if you know a way to e.g. better organize them, and avoid repetition (but without making that global!), that would be very appreciated. The code 

(Of course, you can make it atomic as well, if it should be thread-safe.) Another possible solution would be to have a , which takes care of creating 's. (In this case, I recommend somehow hiding the constructor of , e.g. make it package private, and put the in the same package as the factory. Or have the factory return only an interface which the internal implements.) 

This prevents that you add more statements (accidentally indented at the level of if-else block), and think they will be executed within if-else. Validation Although not part of the original problem statement, I would recommend to extend your code with validation. I.e., make sure that hours are between 0-23 (or 1-12 in case of 12-hour format), minutes and seconds are between 0-59, and throw an exception otherwise (or print an error and exit, whichever is available in Processing). Before adding validation, it would be also interesting to experiment how your program behaves with invalid input (e.g. negative numbers, hours consisting of three digits or four, etc.) 

Besides the answer of @200_success, I have one further suggestion for improvement: I recommend making the record separator (currently comma) and the line separator (currently new-line) optional parameters, instead of hard-coding them. (If not provided, the default values could still be comma and new-line.) Of course, the separator parameters could be arrays of strings, so that you can provide e.g. more types of new-line. 

One more remark regarding the API This API might seem verbose, but it is the best I could come up with so far. I had previously tried more concise ones, but they were more error prone, and also more difficult to manage for a large (4-5+) number of states/observations. For reference, here are the previous attempts at the API: 

Alternative While the recursive approach is elegant and easily understandable, it might be less convenient for very long inputs. I suggest another solution, based on the idea, that if you want all permutations, then each character can either be part, or not be part of a permutation. This gives us 2^N possible permutations, where N is the length of the input. So, you can just generate this number (2^N), and then iterate from 0 to 2^N-1, and calculate the corresponding perm. for each number. So, if the number is represented as binary digits, then 1 means that the character at the corresponding position should be part of the permutation, 0 that it should not. (If you do not need the empty perm., just start the iteration from 1, instead of 0.) With your example, 'AA2', this would work as follows: N=3, so iterate from 0 to 7 (=2^3 - 1). 0 corresponds to the empty set. 1 = 001b, so '2' is part of the permutation. 2 = 010b, so only (the second) 'A' is part of the permutation. 3 = 011b, so the perm. is A2, etc. Remarks: 

Is this a correct implementation of the Trie data structure? If not, then what are the mistakes? Can the performance or the effectiveness (both in speed, as well as in readability) of the implementation be improved? Can you think of any test case, which would cause an issue in this implementation, besides the trivial NPE issues, if is passed to the methods (I intentionally left out the checks to make the code shorter)? (In other words, a test that exposes a bug.) Would you improve anything in the unit tests? 

For the record, I checked in this code into my github repository, and probably I'll improve it based on the answers from here. Trie.java 

Both throw an exception, due to in being called with zero arguments. I suggest the following change, in order to handle this case: 

Performace I see one possible way of (maybe?) improving performance (in case it really matters for 9 milli seconds :) ). Namely, caching whether a given row or column has a queen. Let's look at rows (cols would be similar): you need an array of booleans, with the size of , with originally all elements set to . When you put a queen in row #i, you also set the element at position i to true, in the array. And set it back to false, in case the queen is removed. In this way, does not have to iterate on the whole table, but can look up the rows/cols arrays instead. (I am not sure if there is such an optimization for diagonals as well, maybe...) 

Another remark: since you are reading char's and not strings, I suggest using (so replace with ). Or you can also use . 

Leave it as it is: all output is shown, some of it might be on the wrong place. Overwrite the the end of the first string with the second one (i.e. ). Overwrite the beginning of the second string with the first one (in this case: ). Throw an exception. 

Again, starting from the main entry point, it is not possible to trigger this situation, because the user does not provide any positions. However, in case the helper functions were to be reused in a library, this is a question that should be addressed. Corner case #4 

EDIT: Clarification of this last point, as per the answer of Josh. The question is: what is the best practice, in Clojure, for checking the equality of two sets of floating point numbers? Let's say, that we have a set with values , and want to compare it against the set . Attempted solutions: 

Of course, this holds also for all the other numeric constant, and the strings "AM" and "PM", which are repeated more than once as well. (Btw., I would suggest introducing these constants even if each value was used only once, because this makes the code easier to understand.) Organising code There are some blocks of code, which could be separated into subroutines, in order to make the main code shorter, and thus more readable. E.g.: 

Readability could be improved (Besides what @J_H mentioned), by giving meaningful variable names (e.g. , , etc. could have more descriptive names). Regarding performance, I noticed that the same csv file () is read again and again for each date. It would be better to read it once and keep contents in memory. 

This will return . However, is misplaced here, because it should be at position , and it is, instead, at position . To be honest, I don't really know what would be the best solution here. I can imagine the following: 

In this case, he would probably get meaningless results. I therefore suggest introducing a check at the beginning of the implementation of the method (if you need it at all, see below), and e.g. throw an exception if no search was performed yet. Constructors In this particular case, I would suggest initialising only in the body of the constructor, after checking the validity of the parameter. In other words, I would first validate, and only then initialise, instead of initialising with a (possibly invalid) parameter and then cleaning up. Also, it is not clear to me what the purpose of the default constructor is. Would an object constructed through that constructor work correctly? If not, then you can probably remove it, and keep only the parametrised one. Destructors I recommend adding a destructor to this class, where the file stream opened in the constructor is closed again. Idempotency Note, that currently it is possible to call only once. After the first call, we will be at the end of the input stream, and thus it is not possible to read from it anymore. I therefore recommend to either reset the stream (or close/open it again), or introduce a similar check as mentioned above for the state of the object (i.e., throw an exception if is called twice). Responsibility of the class Instead of the method , I would rather introduce a method , which would return the actual count, and then leave it up to the client how/if he wants to print this count (of course this would also need the above mentioned check, whether the object is in the right state). Maybe it would be even better to have return the count directly (and throw an exception if the word we are looking for is empty, instead of communicating this fact through the return value). Naming I recommend changing the name of the variable to something which better reflects what it is, e.g. . ( makes me think of a string holding the name of the file, not a stream through which the contents can be read). Code blocks I suggest always adding braces around code blocks, e.g. for the code above: 

Although I did not run the above code, I am convinced that it would just work also for the first pair (or it could be fixed with minimal changes), since it would just check the second point against the first one, and set their distance as the minimum. Going one step further, you also don't need to check that there are at least two points, when calling . In this case, the iteration would never start at all. 

In general, I think the program is well readable, and demonstrates the idea correctly. I have some suggestions for further improving it. Constants Consider the following statement: 

A modified version I have modified the original code to demonstrate usage of exceptions, and include some of the other suggested changes. Note, that by removing some of the methods most of the "illegal state" problems can be fixed as well. I did not address the "idempotency" issue.