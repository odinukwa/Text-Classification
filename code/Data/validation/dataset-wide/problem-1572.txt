All dots must be clicked in a specific sequence. If a dot is clicked and allowed to switch, it will light up if not already lit up. If it was already lit up it will darken again. The sequence to light up the 8th dot looks like this: 

If you'd be using Python 3.4 or higher, would solve your problem. In Python 2.7 you'll have to install NumPy, an often used library for large number calculations. Now use like this: 

Use a Switch. The moment you start doing things like the following, you got yourself a maintainability problem: 

No. is a plural, while it will only take one thing at a time. That this one thing is a collection of other things is irrelevant. Perhaps or is better. Now nobody has a clue what's going on in the following. 

And here come the magic numbers. You had constants for a reason, right? Why is this exactly ? Is it the amount of sides to a puzzle? The amount of hours till self-destruct? We don't know. It's got something to do with pieces, but that's all we know. Add 4 pieces to a plot? But there are 7 tans and many more figures than 4. Apparently 'k' is a colour nowadays as well. 

For one, did you notice the list of is an exact copy of the list of ? Did you also notice how there's exactly 26 letters in the alphabet and this is not likely to change? Did you also notice the location of the letter in the alphabet is not likely to change? So why don't we simply write those lists into more lists? 

A better approach would perhaps include splitting the authors already so the next step doesn't have to do it. Seems the right thing to do. Perhaps even turning the whole list into a JSON file instead of a text file. Code 

Yes, let's add 'stuff' to the plot while setting it up. Are you initializing the plot? Why is there no mention of having to run interactively to even work? 

Variable naming Your variable names could use some love. You may think is a good name for a position, but is also an already existing function in Pascal. Your variable has nothing to do with the function, so avoid the confusion. is according to the standard. isn't. Result I've fixed the above (except part of the naming, I'm not too good at that either). The result: 

I want to congratulate you for not going the route. It's a mistake many beginners make because they don't know any better and you went for safety instead of laziness. You say you're not sure which of your includes you actually need. These are the ones necessary to run: 

Ah, there it is. In a comment, right after the docstring where it should've been. Perhaps would be a better name, since no actual data is added yet. That appears to happen here: 

The goal is to learn decent BASH. The FizzBuzz has no need for optimization, it's mostly about style, how data should be passed from script to script and whether I followed BASH-practices or not. 

Your compiler should've warned you about this. Please make sure all variables have a set value before checking them. The only reasons this works is because your compiler decided to initialize at zero here. However, it is not required to do so by the specification. This means it will break on other systems. 

By the way, that construct looks like it can be written in more straightforward manner but my C is too rusty to make the translation. 

5 authors. (That, by the way, is an unfortunate example of improper naming. An artefact of being inconsistent and lacking a thorough naming scheme, but irrelevant for the database.) The current idea is the program will deliver a list formatted like this: 

That's 11 in two lines! The design looks sub-optimal, so this could simply be a side effect of doing things in a not too straightforward manner. However, you can negate this problem by using more variables (make those that don't move and declare them in a ). That second line would look a lot clearer if you used the and variable names I've seen earlier. 

Python usually has basic functions like this already available to you. If it's already available in commonly used Python libraries, it's usually a good idea not to re-invent the wheel yourself. 

Make it work The code looks more like Python 3 than 2, so let's stick with that one for now. The main reason your code won't work in Python 3, is because of your statements. In 2, is an exotic statement. In 3, is a proper function. So let's make them all function calls. That's all! 

Which, apart from the part, does exactly the same thing as your code does. That part halts the program so you can actually enjoy the creation on your screen before the rings disappear again. I've also removed the , since it wasn't necessary. I apologize for the poor naming, but at least it adheres to PEP8. Consistency is good, re-inventing the wheel unnecessary so just follow the same convention as everyone else. Keeps code readable for most developers at the same time. Good, no? First, I've reduced the amount of functions. A lot. How? By using arguments. I can even use default arguments to save a lot of duplication. You can see this most of all in the second call to , where a black circle is drawn with standard dimensions. Note that many arguments are read from a value set at the top, which is calculated frome one single value: . By changing one value, all other values scale with it. This improves re-usability and readability by a lot. Your future self will thank you. Another way to improve re-usability is with the following standard technique: 

@janos already stated this, but it's very important. Never use for a variable name. is acceptable in many languages, is not. Depending on your font it may easily be confused for something else. Do note I'm using while Python officially prefers underscores. It's a matter of preference. Reading the naming conventions in PEP8 may be a good idea anyway. 

No capitals. Although Pascal accepts the keywords as valid regardless of capitalisation, it's good style to follow the standard. If then Keep your and on the same line. 

For starters there is only one , not three. And we don't need a comment to indicate it's because it's on the next line. It's like putting up an awfully big sign to indicate where your store is while the name of the store is also above the door and you're already at the entrance. Your other comments are doing pretty much the same thing. They point out the obvious. No point in keeping them around. This checks whether is : 

Notice the underscores make your function easier to read. The comment above the call to is quite useless: 

No, we're going somewhere. No waiting involved. So what's that comment doing in that location? Now we're at comments anyway, a bunch of trailing after a brace or on their own line are seldom useful. If you use them, let them indicate blocks. In this case extra white lines are used as well. Like: 

So, I decided to split those 3 things and give each their own program. Eventually it may end up in one, but with explicit separation. Later on it may also need an automated maintenance program as a 4th module. The database (3NF) should at least contain the name, authors and publishing year of each book. Later versions may include the size in pages, ISBN and keywords. This program does not yet support this, but is should've been written with those features in mind. The pre-loader The pre-loader will take a directory of PDFs. The test set is 222 items large, the final dataset much larger. For now, only PDFs are supported. If I'd ever want to change that, all I'd have to do is change the following: 

I've rewritten as , easier on the eyes. And you made a good start by putting it in a variable (which, according to the PEP8, should be since they're pseudo-constants). So why didn't you put the others in variables as well? Look at how the functions you call have named their arguments and use this as inspiration for your variable names. Keep in mind you're using spectograms as input. Spectrograms have some downsides, since they only measure intensity of frequencies and not the phase. You may have heard this problem described as the phase problem. This means every spectrogram has broadband noise, impacting the overall effectiveness of your output. The measured effectiveness might not even be the real effectiveness, since it probably assumes you actually like the noise. So, not only could you use more data to achieve a higher accuracy, you may eventually need more complete data. As in, less noise and with phase information. As for performance, there's not much you can do. Your code runs significantly faster on my laptop than on your Mac (original set-up in under 15 minutes), even without using a GPU as acceleration. Tensorflow is pretty well optimized to use multiple cores. Keep in mind the X-axis displays steps. The time it takes to reach a certain amount of steps can vary wildly depending on the arguments you provide. 0TWRK8 took 3 times as long to reach step 500 than H57Z4I, while the latter appears to be scoring better. Figure out which arguments are 'worth their weight' and which simply slow you down for little to no gain. My advice? Experiment! After a couple hundred epochs the data will just about flatline, so going above 200 isn't particularly useful when going for sample runs. Fidgeting with the input reminded me of a game I played a long while back: foldit There's the early game, the mid game and the end game. In the early game, you're looking for the big changes. The later you get, the more your focus shifts to different aspects to fine-tune your approach. However, if you had an inefficient start, you couldn't fine-tune enough to reach the score you wanted. The score would flat-line. Consider developing this machine in the same manner. Don't rush the development to make it go fast if that will hurt it's accuracy in the end. After all, nothing is as annoying as speech recognition that only works half the time. If you need certain functions to keep your output in good quality, don't optimize it away only to regret it later. Something else your dataset doesn't take into account, is combinations of characters. isn't exactly pronounced as a combination of and . The same goes for , and other combinations. Keep this in mind when you start field testing your network. 

There's still a couple of problems with it. We're now iterating an extra time, which can't be helpful for the time it takes to execute. But at least it looks better now, so we can see what we're doing. It still fails just as many test cases as your original code did, so at least we didn't do noticeably worse. What else can we do better? 

Blanket imports Do you know what you're importing when you use ? The entire turtle. You don't need the entire turtle. This is what you need: 

Yes, it goes over 52% at times and I'm sure it can go even higher. Let's take a look at what colours are caused by what. 

Start by making sure you actually need all of those. Especially when it's a project which has had many alterations after first release it's easy to have leftovers which are no longer used. Next thing to do is to realize you're probably doing an awful lot in the same file. The Single Responsibility Principle does not only apply to classes. If your file contains multiple classes, consider giving the biggest classes their own file. These steps will have reduced your list of imports per file significantly while improving the maintainability of your code. If you still feel there are too many left, consider using SuperBiasedMan's answer. However, I feel constructs are a code smell and should be avoided if possible. Given your current structure isn't any better, it's choosing between two evils. 

There's good news and bad news. For beginner code, this is fairly well written. The graphics are intuitive and the controls straightforward. However, the site you've used (trinket.io) allows a kind of Python I haven't seen before. Your code will fail both in Python 2 and in 3. Before we do anything else, let's make sure it works on at least one of those versions so you're no longer restricted to an odd flavour from an odd site. Note: If anyone happens to know more about this flavour of Python, please leave a comment. This will be a review in 3 parts: 

= some value minus one. The actual value we need is plus one. Since the description of the challenge says and are given (not and ), it doesn't make sense to modify them. Let's go from to instead. 

Yes, this will lead to somewhat longer calls. turns into and turns into . But the moment you get multiple statements in your code, you got a problem. 

And poof, all the globals are gone. Of-course, a straight port from what you have to object oriented still looks ugly. Pass some variables around, use the power of arguments and when in doubt don't hesitate to split up to more functions. But at least you now have a start and it will be easier to re-use this code later on in different projects. As two final notes: 

Note that since we don't return anything, a will do. Now you're reading all lines of data (up till every newline) and iterate over them, which appears to be what you want to do. Not only will this stop when the file has reached , it will also check whether the stream hasn't failed or took a bad chunk somewhere along the way. 

Where first there's the title of the book, second there's the authors of the book and last there's the publishing year. Author names should be seperated by ampersand, any other character except an underscore will be considered part of an author's name. If the author of a book is unknown, it will be . If a publishing year is unknown, it will be . Books published before the year 1 anno Domini are not supported. If the file is not a PDF, it will be . Such files may or may not be a problem, but a list is kept. For example, a link may have been created instead of a copy, resulting in a instead of a . File names can be very long. Example: 

Algorithm Increasing the accuracy of the graph is a matter of increasing the amount of measurements. If every second isn't good enough, measure every half a second. If that's still not good enough, measure every tenth of a second. Or whatever your time unit may be. Your current set-up does not allow for such modifications. You'll either need a and divide the whole course over that or put in a modifier which does basically the same under water. I'd go with the first. 

Comments Your comments are part English and part French. Pick a language and stick to it, don't alternate between languages. Hard-coded values There are a lot of hard-coded values in your code. For example: 

Most of the things I'll mention are written down as guidelines in the Python Enhancement Proposals (PEP). Read more about those here. Main issues (in order of appearance, not of importance): 

I have implemented the "Sum All Numbers in a Range" challenge from Free Code Camp quoted below. The code works like a charm, but I don't think it's idiomatic. The challenge hints imply I should be using , and . In addition I used the spread operator from ES6 to simplify both calls. I'm looking for a more idiomatic way to solve this. I think it can be done in a one-liner, something like: 

There's 2 possibilities: 2 spaces or 4 spaces per level of indentation. But whatever you do, be consistent. That's the most important of all. As a side note: your tags were oddly matched at times. I fixed your inconsistencies in the code below, I'll leave fixing your CSS as an exercise. In your CSS, the same rule applies: be consistent. With your whitespace, with your indentation, etc. HTML