You wrote good comments and your implementations is clean, IMHO. I only have a couple of nitpicks. 1) This is counter-intuitive: 

According to C# naming convention you should use PascalCase for constants (unless you are mirroring some external API which uses different naming convention). So It should be , etc. Also you might want to use instead of strings: 

And use and to run your tasks on that thread. It is a lot simpler than reinventing the wheel. The obvious downside is wpf dependency. 

P.S. I don't think there is a pretty way to dynamically convert one generic type to another. So using is not a bad solution, especially since you can not modify source types. That being said, there are libraries, that do dynamic conversion using explicit cast operators (that you can define on your wrapper classes). I have no idea how on earth they do it (a lot of reflection involved?), but you can give them a try. Here is an example of such library, that I've used in the past. 

I don't like method, because hashcode collisions happen. And when they do your software should not break. Therefore it is unclear why the test should fail. Also, I can't come up with a case where returning makes any sense. :) If it is intentional, then you should probably document this behavior and explain why it works that way. 

Svick gives a good explanation on why this pattern exists. It is used, when you are not sure which base functionality derived class might actually need. Using your variant makes class dependant on single injection, which might not be the case for every derived class (at least in architector's opinion). Meanwhile, your issues with this particular base class can be easily solved by adding another base class to this hierarchy: 

Your code is super-comlicated for such simple logic. I'm also pretty sure it deadlocks in pretty much any use case. 

You could join the two loops. I think this way your intent will be clearer, and it's not like a few extra comparisons are going to cost you anything. 

why content can not be null? I would assume that at some point you are going to add an element with no children/content. Should I pass in that case? I would rather just pass (or pass nothing at all). 

Mat's Mug made some really good points. I would like to add a few things. I don't like the class. What will you do when you'll want to have a spear? A gun? 10 other weapons? 10 more items, which are not weapons? Your class will quickly grow to a point, where it will be real pain to maintain. This looks much better in my opinion: 

looks like an accident waiting to happen. The entire framework is built around zero-based indexes. I would not recommend having it any other way in your collections. Otherwise it is really easy to make a mistake: your program will have hundreds of arrays flying around, where most of them will be regular arrays, except for that one special array, where you have to skip first element and subtract from before doing any operations (including LINQ queries!). At least make a custom array class, which would override and would throw an exception when you access index. Or save yourself a trouble and just use regular array. And add to index when reading form it. 

I'm sorry, I don't have it in me to read your full explanations (TLDR), but here are some questionable design choices, that caught my eye after looking through your code: 

You should avoid code duplication in constructors. For larger objects this practice can quickly spin out of control. Re-use existing constructors instead: 

You should consider prefixing private field names with underscores, so it is possible to distinguish them from local variables. Edit: There is no "official" naming conventions regarding private members. Not that i know of anyway. Underscore however is a somewhat accepted industrial standart nowadays. Mainly, because a) it is used by Microsoft, b) it is used by ReSharper (by default), c) better intelli-sense support, d) when it comes to choosing between and most people choose the latter. I think this is pretty accurate 

You do not check for in and in equality operators. You probably should, since both and can be null by your design. You should re-use single equality implementation. For example, should just return . 

I think you should either use or , but not both. Also aren't you already catching all errors in your implementation? Another advice: do not discard the callstack, when you log. Otherwise, how are you going to find the source of exception? 5) Don't use Task.Factory.StartNew without specifying TaskScheduler. 6) I don't quite like API. I would expect it to behave the same way most other observables do: it should automatically start inner timer when first subscriber arrives and it should automatically stop timer when last subscriber disconnects. Having to manually call looks inconvenient (although I imagine some functionality might actually be useful). 7) Whether or not uses multiple threads should be an implementation detail of method. This logic should not reside in static factory methods, IMHO. Or you might even want to abstract it out into separate component. 8) I would name static methods or something. Otherwise it is not very obvious, what they actually do. 9) This does not look very precise as far as timers are concerned: 

I am not sure that making your class static is the best way to go. In my experience in such cases its almost always better to make a non-static class and then to either inject its instance or initialize some field. 

This way you can guarantee that all equality methods always return the same result. And fixing a bug in your equality logic becomes as easy as fixing as single method. At the moment passing to method will , while using will work just fine, for example. You have a mutable hash code, which is a bad idea in general. You have mutable static feilds ( and ), which is also a bad idea. Consider this code: 

re-throws the same exception, so there is no point in such catch block. Alternatively, you can use syntax. 

if not: then i agree with Chuck - you need another layer of abstraction to encapsulate lookup logic. replace in method with 

You rarely need to manually implement enumerators. In your case, you should probably just go with extension methods. For example: 

You should probably remove the constructors you don't actually use. Otherwise they look fine. What does not look fine is the way you use exceptions. Exceptions are... "exceptional". They signal that something really bad happened: an invalid state or an error in the workflow which your class can't handle. Exceptions should NOT be used as part of your regular workflow, especially not if you catch those exceptions straight away with an empty catch statements (which are bad enough on their own). In those situations use instead. Here is a quote from MSDN: 

All in all, I think that if you decide to use this builder, you should stick to that decision and use it everywhere. This means that you will have to add support for all possible registration scenarios to your API. Otherwise I feel like its going to be really confusing for a reader to see half the properties registered using builder and half registered without it. P.S. Otherwise your code looks pretty clean to me. P.P.S. I would use just because it does not require any prior knowledge about your extensions, therefore it is easier to understand for fellow developers (and because I'm too lazy to modify re-sharper templates). However if I were to pretend that I know nothing about WPF, I would say that looks cleaner. P.P.P.S. It just occurred to me that the main advantage of your registration lies in strong typed event handlers. After all syntax does not add any additional "safety" compared to regular . So what you could do is this. Instead of overwriting entire registration process, you could extend/wrap class. I see this as a compromise approach, where you do both: keep the ugly familiar syntax, but add type safety to event handlers, if it is needed. 

That's more code than I can handle, so I'll just cover some of it. exposes too much methods and is way too complex. 

Generally you should not dispose objects which came from the outer scope. Disposable static instances are especially bad. It is not 's job to manage 's lifetime, it did not create it, and it does not know if it is still in use. call should be moved to outer scope, to the place where Printer was created. In your case, it is function. You should also avoid static dependencies, they make your code harder to understand and almost impossible to re-use. If requires to function properly - make this requirement explicit by adding parameter to 's constructor. 

So, extending my comment... Enums are designed to represent a fixed number of states. This is their purpose. If that is what you need then nothing prevents you from using standart . If you want to specify items source as a collection of enum values - use , for example: 

1) Why do you have both: static methods and static instance? You should either remove the property (as if you had a "static" class, just make static), or keep it, but make methods non-static (singleton (anti-)pattern). 2) I'm pretty sure this line should throw . 

Parameters of are no longer exposed. Container guaranties, that there is going to be a single instance of . Host is exposed as service () and not as implementation (). You can mock in unit tests. You can easily unit-test implementation with whatever parameters you want, because now it has public constructor and can be re-created as often as it is required by your tests. Classes that depend on will now require it as dependency, instead of secretly accessing it via global static property. 

So called "marker interface" pattern is a controversial topic. Personally, I'd say that yes, it is fine in this particular case. It is a small price to pay for type safety: you can be sure that you can only call with types that were specifically designed for your component system. Not to mention that it might not stay empty forever. Maybe it will turn into -kind of mess. :) Or maybe you would want it to have a single property, that would reference the this component belongs to. Who knows. I say - keep the interface for now. 

IMHO, it is all-around best option, as it allows you to control when to do initialization. Call initialization automatically on every call: 

"Publish" tests have a lot of similar initialization logic, where I create and register listeners. Should I try to re-use it? Or is it ok to copy-paste unit tests. :) "Assert once per unit test" they say, but I break this rule on multiple occasions. For example, I call multiple times to verify, that event handler was called for every relevant subscriber. "Test one thing at a time" they say. I feel like I am not following this rule either. For example, it looks like tests that: (1) subscribers are correctly added to subscription list (2) message reaches registered subscribers (3) this whole thing works for multiple subscribers. Does this qualify as "testing one thing"? Do I test method correctly or is there a better way? Tests that return look weird to me. 

Overall I think this implementation would be easier to understand/maintain if you were to "sanitize" during html construction, and not during rendering. Instead of having special rules on how to render non- objects, you should have special rules on how to convert those object to . This way you should be able to work with strongly typed instead of . 

P.S. I think Artemis nailed this whole framework-independent-entity-based-system-thingy fairly well. You probably don't need all its complexity, but when in doubt it should be a useful source of inspiration. Check it out. 

You can still run it synchronously by calling . I think this approach is more universal, if the goal is to create general retry strategy, but you can do the same thing without tasks, if you already have the background thread which executes this long-running method. 

Additionally, I would like to point out an old design issue. Which is: inheritance does not work that well, when it comes to programming behaviors. It is somewhat ok for small applications, but it scales poorly. For example, your class is not going to cut it, if you add an entity that is "movable", but does not have a name or age. You'd have to implement another base class, without those properties. This can quickly turn into really complex hierarchies, as the number of behaviors and entities grows. That is why applications, that heavily rely on entities and behaviors (most modern games, for example), normally use composition instead of inheritance. So you d have something like: