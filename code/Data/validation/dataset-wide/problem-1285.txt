Where 's' is the starting point, 'e' is the goal, and # are the walls (basically, similar to the format you have now). I'd also include a title, but that's a personal preference. In this case, I'd read the first line from each file while displaying the menu. Alternatively, to avoid reading tons of files, you might just have an "idx" (index) file (e.g. levels.idx) that contains some format, like: 

I'm sure this could be optimized even more, but this answer was meant only to illustrate the use of to minimize the amount of code that has to be written. In this case, using just one single function with some prepared data greatly reduces the amount of data that's necessary. Further optimizations would be to use objects instead of just plain arrays to associate the data. 

Using this design means that you could literally edit levels into the data folder and have them appear when the menu is displayed, and offer (potentially) unlimited levels. Since we're talking about C++, the files could be simple, something like: 

What you've actually implemented is an unoptimized reverse selection sort; in this case, you've combined a bubble sort with a selection sort, which has better performance than a pure bubble sort but not as efficient as a pure selection sort, primarily because you're making potentially far more swaps than you would with a pure selection sort. You could change it from the current implementation to a pure selection sort with minimal change: 

Note how you are constructing the same selector 3 times with the . So this not only repeats the selector construction as it also fetches the element from the DOM multiple times. Save the fetched element in a variable and then use it: 

Which given what it does, a better name would be . Given that all it does is sort the roots, its even questionable if it should exist, and probably better would be to do the sorting directly in . Considering we are talking about two values, you could easily get away with: 

Don't need to be separated in such a simple statement, regardless whether you use destructuring or not. You can directly do: 

There is a similar question that you may want to take a look at for some extra insight, even thought it doesn't have the contrasting color feature: JavaScript Random Color Generator Now lets get to the review. Naming 

I should start by saying that the game is quite interesting, and for a beginner the code is good, but of course there is plenty of room for improvement. Small details You have many small things that may a bit odd or unnecessary even, such as: 

This design violates first normal form, which is a concept that states that each data field should contain an atomic value (using type and ID together makes this a composite value). This makes certain types of queries more difficult, and you'll use more database space and suffer query performance. Store the type in one column, and the ID in another. If you have many tables, you might consider breaking it out so each module type has a corresponding "likes" table (e.g. and . This uses significantly less space and makes maintenance easier, but makes some queries harder (such as "show me all my likes"). Using a single-table notation is acceptable, but by breaking the type and ID out, you can use an and an instead of a , which will improve query speed on full-table scans, and use less space on disk. 

Generally, when you free something, it's a good idea to null out the pointer afterwards. While in a program this small, you'd be unlikely to make a mistake, when you null a pointer, most platforms will terminate the program rather than have potentially undefined behavior from a dangling pointer if you accidentally reuse it. You should get in the habit of doing this. There is a function called realloc that performs a malloc/memcpy/free cycle for you on your behalf. Some platforms can also resize the memory without moving it (assuming enough contiguous space exists after the allocated memory), which can be a performance benefit. You should use realloc instead of malloc/memcpy/free, because it will always be at least as fast, and often faster. That said, your code appears to be free of memory leaks, accessing invalid memory, buffer overflows, etc. There's a lot of minor optimizations that could be recommended, but this code is at least logically sound. 

Just adding a couple of things to what @Blindman67 already said, and focusing a bit on the code itself. 

Refactoring When you see yourself doing the same thing many times, it is time to think again and try to refactor that part because there certainly is a better way. You have very few code that represents repeated logic, but lets take a look at the function: 

Both first blocks have the exact value you are looking for and will always be an empty because there is nothing to the left. Thus it won't affect the result at all. So you can drop the altogether, and adjust the appropriately. Personally i feel you must rethink your logic a bit on this one. Restating @Blindman67, you should take spaces into consideration to make the structure less rigid. On a simpler level you can strip down the spaces before parsing: 

As pointed out by @Zeta in the comments if the color to be inverted is a gray very close to the middle, the inversion will generate a similar color which may not be easy to read. You can try to avoid this by manually checking the difference of all channels to their inverted versions, and if all of them are bellow a certain threshold generate a different color. A simple approach to this would be to generate black if all channels are closer to white and white otherwise. There are also some libraries/micro-libraries that generate colors and their complementary versions with other approaches, such as using HSL. These may be interesting for you to take a look. Here are some of them for reference: 

You can bind a single click to many elements using a class selector, etc. refers to the element that ended up being the target/srcElement for the event. 

Under the covers, each matching element will get its own closure, and therefore operate correctly. I'm assuming in this code that one div is contained within the other (there's no HTML here). It's pretty trivial to use other methods, such as finding siblings, etc. In an absolutely worst-case scenario, you can use data attributes on the clickable element to target other named elements, or you could make a named map: 

Using method will have an side-effect if is modified. This is because arrays are passed by reference, and so any changes to will be visible to the caller when the function returns. Use if you need to manipulate id or name, unless you intend to return the modifications to the caller. Example: 

Avoid Hard-Coding Values should validate the level range. In a real game engine, you'd probably have files in a data folder instead of hard-coding the levels within the source code. For example, you might have files that look like this: 

Which makes it super compact and easy to read. Objects One downside of the way you have your code structured is that you have multiple global variables. This creates difficulties in managing state and also opens the possibility of colliding with already existing global variables. Those may either be from the object or even some other plugin/library that gets included up top. All the game logic can be moved into one or multiple objects/classes, which helps you separating it from the presentation in the page. Sure you can consider this a bit too much for a such a simple game but it's definitely a way to improve especially if you want to keep adding features. As a first step you could consider the following approach: 

When we look closely to we can see that the code is barely the same, except for the very final returned root. So this leans towards repeated logic and creates all sort of problems. In this case it also makes your code less efficient because you repeat some part of calculations. Better would be to restructure your to return an array with both roots. 

Of course, you could instead use std::swap. However, given all the alternatives, if performance was a non-issue (e.g. absolute clock cycle count was unimportant), I'd impress simply using std::min and std::max. 

Since you're breaking out on the first call to remove, then moving on, you'll never violate this rule. 

I'd rather prefer the first method, as you can then add/remove elements in your HTML without having to refactor code. There's plenty of other ways you could do this dynamically, including using to bind to a parent element and then determine which element was clicked. 

And so on. Your selectLevel function could open the data directory and read the list of files (it doesn't necessarily need to actually to read the contents of the files, just a directory list). Use Structs/Classes To Track Data You can make your design simpler by having a struct that contains the game state. You could even eventually add a save/load routine later by isolating the game state from the rest of general memory. Here's a suggestion (feel free to modify as desired): 

In addition to janos' answer, I'd like to add some additional tips. Avoid Goto Goto simply creates "spaghetti code" that will become harder to maintain over time. Instead, use do/while and break as appropriate. Once the user wins, simply return from the function that should be maintaining the play loop; once the user requests an exit, return from the main application loop (examples further down). Keep Main Simple In a typical application, the main function only calls 1 or 2 functions, usually in the form of Your main function should be close to: 

I'm not going to go deep into variables and functions names since @Blindman67 already covered them. But i still can't help but mention them again. They are far more important than they look, and you haven't picked them properly. Take your time picking them, it's definitely worth it. 

While the whole code would now be longer, as you would have to manage both the page visual elements as well as the logic itself, it would also be more modular, organized and easier to maintain or add functionalities. It would still be necessary for some other function to call the game functions and update the corresponding page elements depending on the game state. A more modern way of doing what i did above is using ES6 classes: 

The function actually parses the coeficients for each degree term. I won't dive too deep in to this one, but i'll start saying that you do a lot of . And many of them are almost identical, being not only inefficient as well as confusing. Consider this one for example: 

Note how i used instead of . With ES6 you now have both and as other ways of declaring variables. In this case i know i don't want to change or , and with it will give me an error if i accidentally change them. This builds on writing defensive code that gives you errors sooner rather than later. The itself can also be shortened with an Arrow Function: