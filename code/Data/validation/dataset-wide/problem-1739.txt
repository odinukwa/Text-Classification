You don't need the root certificate in the chain (though I don't believe having it hurts anything). That error is more of a warning from openssl in this case I think. I believe what it means is just that openssl doesn't know that it should trust the root certificate of that chain. If you pull out just the root certificate from that bundle and point that openssl command at it with the argument I expect that "error" should go away. Inside the sf_bundle.crt file you should see two 

You need to find out if you are supposed to have an intermediate certificate or not. If you are then having your server supply it in the chain will help any clients that do not have it build a valid chain (assuming they have the StartSSL root certificate installed locally). That may not be the case and that will not help people who don't already have the StartSSL root certificate trusted locally. You can't help those people though they will have to install it to avoid the warning. 

It's the amount of physical memory being used for cache memory. Even though top lists it at the end of swap, it's really got nothing to do swap space. Red Hat has a nice explanation of all the different types of memory usage. 

Ping is really only good for testing 'is the system up'. The response time is a bit of a red herring. In some systems ICMP ping responses are given a low priority, and therefore it's not a problem if the response time varies. I've also seen someone worry about ping response times and it turned out to be an problem on his own PC, not the systems he was worried about. If this is the only thing you're seeing, I'd not worry about it. If you're seeing other problems, then I'd look at those problems. 

Assuming you mean then yes, that should work. Check that the file has exactly two lines and that there aren't any extra spaces or anything in the key line for the second key. Also check that you have added the correct lines for each desired key. 

Installing an extra root certificate on the server is not going to help a browser trust the server certificate the server sends it. The browser needs the root certificate locally in order to construct the chain of trust when the server sends it the certificate. If you check the certificate dialogs in Chrome and Firefox I believe you will discover that Chrome has found the root CA installed locally and has constructed a correct valid chain whereas firefox has failed to do the same (because it does not have the necessary root CA locally). Installing root CA certificates in browsers is a fairly simple process once you have the appropriate certificate file. The certificate dialogs in the various browsers all have an 'import' button of some sort that you can use for this task. If your certificate requires intermediate certificates then those should, for best compatibility and correctness, be sent by the server during the SSL handshake process. That requires the intermediate certificates to be configured on the server the same way as the server certificate is (that is they must exist in a file and Apache must be pointed at that file with the SSLCertificateChainFile (or similar) directive). 

ls -ld /DriveXT will tell you the permissions on /DriveXT. You can't get the permissions on the lower ones, they are probably '--x' for you for MMT, and '---' for you for LP2010. If you want to find out the permissions on the lower directories, you'll have to be root, or user with 'r' permission on those directories. 

Usually web servers are configured to only allow access to user files in a specific directory, traditionally the public_html directory. The url format would be $URL$ which would translate to /home/user/public_html/dir/file.html This is for security reasons. Imagine if anyone could access your .ssh_keys directory from the web, anyone could break into that account. For that reason, there isn't any way that you do what you want directly. On the other hand, there is nothing wrong with accessing a server by hostname. A virtual host is just another name for that same server, which usually has different content served out. There is nothing you can do with a virtual host which you can't also do with the correct hostname. 

If you are already using yum to install your packages then the RPMs already exist and you could just grab the RPMs you want and store them locally for later use... or you could get a bit fancier and actually set up a local repository with your desired packages (or even the entire distribution) and use that for your servers (though if you go this route you need to be careful about getting security updates and the like if these are things that need a reasonable security status). 

and tell you what sasl plugin types are available. I would assume those would return errors or empty lists if sasl support was not enabled at build time (though possibly not). You could also check the output of and see if it links to a sasl library or not (though it might be possible for postfix to be built with sasl and not link to a sasl library if it supports it via a plugin or something, I don't know whether it does or not). 

Here is a good paper on what ICE is, and what it does. Basically ICE is a inter process communication protocol, with authentication, protocol negotiation and potentially multiplexing built in. It allows two X clients to talk directly to each other, for example, a video player program could potentially talk to a jukebox program to update each other. As Richard Holloway says, the .ICEAuthority file is for authentication. It contains a number of random cookies. If two programs have the same cookie, then they're allowed to talk to each other. In practice this either means that they're reading the same .ICEAuthority file, or the cookies have been added. In a lot of ways it's similar to the xauth program & the .Xauthority file, except that .ICEAuthority is used for client to client, while .Xauthority is for client to server. 

That's a linker failure. It looks like you may not have the gd library installed (or more likely that you have an incorrect version of the library installed). Does report any missing libraries? (I don't expect it will.) What version of libgd do you have installed? 

I'm going to assume that the -f argument expects an absolute path to the file and interprets the path as relative otherwise. Are you running those commands from in /etc/openldap? Does using work? Are you running the commands as a user that can read that file? 

If you configure apache with no listening configuration on port 80 and ensure that you configure it to listen on port 443 with ssl correctly then yes, your server will not listen on any non-ssl ports. 

It depends totally on what you're trying to do. A static website? Probably no problem at all? A website where each page requires a large amount of CPU & memory before it can output the results? You're going to have problems. Is it mainly plain text? Does it output a 1Mb graphic for each user? The best way to know is to use benchmarking software to find out what the site's requirements are, and by extension, if it can handle the load you're expecting. Here is a list of different programs. Loadrunner will without doubt do it for you, but I'm sure there are others which will work just as well. 

The other possibility, in general, is that individual verification checks can be disable on a per-file or per-directory level in the spec file itself. So, while not true in this case, it is entirely possible that a packager could disable MD5 sum checking for files that are known to change for one reason or another. 

blocks (possibly with plain text above each block showing what certificate the block contains). If you split each of those blocks into its own file so you end up with and you should be able to run on each of them to get their respective certificate subject lines. Assuming that has a subject line of you should then be able to run and that should, hopefully, connect without giving you the self-signed certificate error. 

You should give a full path, because you don't know the context that it will be executed in. If your program exits with 67, then this will be bounce the message as unknown user, 0 will drop the message. Anything else will be retried until the message times out and bounces. Be careful of security - you're basically allowing anyone on the Internet to run a program on your system, so don't trust user input, and sanitize it before you use it. 

It says that any request with only one / in it, will be redirected, anything with two / will not match the rule, so will be passed over.