Update It occurs to me that there is a little more flexibility in this situation. I have a function, that accepts a the code submission as a string and alters it. Mostly I've been using it to swap out the value of some variables using regular expressions. Here is an example implementation: 

Multithreaded Approach Since you are using WinForms you can use . BackgroundWorker will automatically use threads from the ThreadPool, and importantly, they have a notification event for when the thread completes. There are several ways this could be done, and also keep in mind that I only have moderate experience with multithreading in C#. You will need to create several BackgroundWorkers. I would start with 4 and adjust from there. We can also simplify reassembling the blocks by writing them to the output file as they complete. Here is a high level overview for what you should do: 

Additional Thoughts As janos mentioned, your program has several usability issues. While I've cleaned it up some a little and added better input validation, there is still a lot to be desired. Making the user enter coordinates, especially without adding row and column headers is hard on the user. It would be better to either add headers, or even better, add a guide with numbers and letters off to the side. For example: 

Don't Repeat Yourself (DRY) Your IsSimilar() function consists of the same code block, twice. Anytime you have duplicate code you should usually either break it into it's own function or find another way of eliminating the duplication. An example implementation removing duplicate code: 

The name for this type of parsing is called the shunting yard algorithm. Your code itself seems fine, as long as you don't intend to support strings with curly braces, e.g. . The biggest issue I see is that it's not very ruby-like in the naming or formatting. I've made brief attempt at cleaning it up a little below. 

Some Code Comments Like Eric mentioned, you can speed things up by not doing duplicate work and intelligently managing the values you loop over. 

Alternative Solution This will be a bit confusing, so my apologies in advance. Bottom-Up Search When I did this problem, rather than brute force looping over all the possible permutations, I constructed my pandigital numbers from the bottom up. We can do this because each 3-digit sub group is highly constrained. For example, the last 3 digits have to be a multiple of 17 and be less than 987. There are only 58 different multiples, and any with duplicate digits, like 119, are ineligible. Let's say that about 40 are valid. that means the next 3 digits (d6d7d8) must contain the first 2 digits of one of those 40 AND also not contain any duplicate digits. The constraints mean that trying to construct the number from the bottom up is a very, very small search space, and thus very quick to search. Possible Implementation/Algorithm Here is a high level breakdown of my implementation: 

New Classes Now there is opportunity for new classes, perhaps that reads the rules/substitutions, which contains a list of divisors, the substitution, and perhaps it supports the comparison operation <=> so that the rules can automatically resolve ties. There could also be an class for iterating through 1..100 and applying the rules. There are a couple of different ways you could define the classes or even the problem here. In general though, OO solutions to trivial problems aren't a good fit. 

Sort your corpus Before processing your wordlist, sort your corpus into a dictionary by character. For each character, if a corpus entry contains that letter, it gets added to the dictionary entry for that character. 

Your statements are superfluous. Just initialize the variables to zero and only set them if there is a valid key. 

Use a struct and a union to do what you want. Note that this implementation is verbose and can be combined into a single declaration. Also depending on your system architecture, you may need to pack the struct or declare the members in a different order. 

Finally, if the spaceship is destroyed, skip directly to the particle application logic. Don't waste time checking torpedoes and asteroids. 

Dom2 was the fastest because it has the fewest number of operations by far. As a weak rule of thumb, when optimizing math, try to avoid BigNum and Float when feasible. Also try to avoid things like converting numbers to strings and then back to numbers. Conclusion Know that more often though, that your slowdown will usually come from lots of branching and flow control, and being inefficient (like calculating the same things over and over rather than caching them), and those are the places to optimize. If this problem were part of a larger, more complicated task, I can practically guarantee that your bottleneck would not be ANY of these functions, but something else entirely. 

already has a mechanism for passing and retrieving arguments. The has a property for a passed in method argument and a property for the DoWork result. The has a property for retrieving the result. No sub-classing is necessary, although you may need to make a custom container if you need to pass/return more than one object. 

There are more sophisticated ways to handle the bytes and endianess, but I've deliberately kept it simple here. 

This is built assuming you want no duplicates in the results, since the goal is a little unclear. Quickly Finding Combinations The function you should be using is , which generates an enumerator that yields all combinations of size from the array. Once you have that it is a trivial matter to only select the combinations that sum to the target value. My function here finds all combinations of size 2 to size and then selects only the combinations with the correct sum. 

Some Notes The RunWorkerCompleted event may run on the background thread (or you may get errors about it) and we don't want that. First, any updates to the UI, like updating the progress after a block is written, have to happen on the main UI thread. Secondly, we don't want multiple threads trying to write to the output file at the same time. There is a simple trick to get the RunWorkCompleted event to run on the main UI thread. 

will pass the array items in groups of n, using a sliding window. So [pt1, pt2], [pt2, pt3], [pt3, pt4], etc. After that you can use to calculate the distance and sum the points. 

Easy Simplification: Integers convert up to doubles just fine. Since you aren't returning the number directly you can safely drop the integer case for LessThan, GreaterThan, and Range and always convert the number to a double. You'll get the same result. 

Ruby has constructs for this called Ranges and Enumerators. Ranges are a collection of sequential numbers while enumerators are looping constructs that iterate over a collection, like items in an array or the numbers in a range. While ranges only count up, there is a function for counting down, that returns an enumerator. 

I know this is a bit confusing, and I can edit this answer with additional comments or code as requested. When I implemented this in in ruby, this bottom-up approach ran in 6ms. 

Make the base class meaningful Right now you've declared as a base class, but all it really does is set up your two variables. One way to utilize it more would be to assign a unit of some sort to the class (I've chosen Kelvin, but it could have been anything). In my version, stores everything as Kelvin. Any class that inherits from it only has to know how to convert back and forth to Kelvin (So Celsius<->Kelvin and Fahrenheit<->Kelvin). Later, if I wanted to add operators to add/subtract/compare temperatures, since the base units are all kelvin, everything is easy. You'll also notice that I've moved to the base class and the threshold temperature is in Kelvin. This gives all sub-classes the functionality without having to know anything about where the theshold is, and likewise the base class will always work without needing to know the details of a particular unit of measure. Finally, while I've used Kelvin as the unit for , the base class could have just as easily been called . 

For each word you process, get the unique/distinct list of characters (for example, by throwing it into a set). When checking for matches, you will now be checking against a much smaller list of corpas, which should speed things up a little 

You can use a ruby case statement to check for different regex matches. If a match is found, it is by definition not nil, so it removes the need for a nil check as well. 

Outputs: " and ProdUsers = aaa and ProdFullyOnline = 'bbb' and ProdPrice <= ddd" I had to add some boilerplate code to make the example work, but I think one gets the idea... 

I would break out the parameter fetch from the setupConfiguration constructor. Also, in MaximumDemandConfiguration, you are declaring two variable that you never reference. While I have left them in, you could remove the variable names or declare the parameters just like all the others and then use the variable names in the constructor. Finally, you can use a namespace alias to shorten the amount of text in the namespace: . You can do this for other namespaces as well. 

Sequence Also, just because ruby is awesome, here is an iterator that generates a sequence of Fibonacci numbers for additional functional programming tricks. 

Update: What I mean by Block Index Let's say a file is 10K. The first block has index 0 and is 1K in length. The second block has index 1, the third index 2, etc. The file has 10 blocks with indexes 0-9. Now lets say that I queue things up and block index 4 finishes first. In my output file I seek to position , or 4000 and write the 1K bytes. Then let's say that block 2 finishes. I seek to position 2000 and write the 1K. My output file now looks like where '*' denotes valid data and '0' denotes empty/nothing written. For performance purposes, I'd probably let the UI thread open the output file at the beginning and only close it after the last block is written. You know the file is done when all of your workers are sitting in the list. (Workers also have a property to check their status :) Links 

Profiling and Benchmarking Rather than benchmarking, which just does total time, you would be better off profiling, which is like recursive benchmarking. I recommend you use the ruby-prof gem. I profiled your code thusly: 

To handle the undesirable cases, I've tried to use and/or to run the code in a process (then I can call ), but I'm not having any success capturing stdout/stderr. So my question is: What can I do to make this better/more robust to handle bad code snippets? (And yes, I know this is a bad idea in general; I'm running it in a virtual machine just in case there is malicious code in there somewhere) Python version is 3.5.3 

This would allow a player to only enter a single digit AND have a visual guide. You could also make other visual changes, like drawing the board grid lines like I have (or even using extended ascii). Finally, you have one major design issue, in that you allow a players to overwrite each other. There is no logic to prevent a player from playing in a cell that has already been used. 

Caching You can increase performance by caching the result. For each number generated by the sequence, cache the number and it's length in a . The later, if the sequence generates a number you've already seen, you can abort the sequence and add in the remaining length. For really long sequences this can save you a lot of time. Note: you should be caching across all runs, so that the work you do in earlier tests can be preserved during later tests. 

Updated Thoughts I think you should completely rethink the way you are handling time. Use a regex to validate that time is a valid string, then simply use to get each portion of the time: hours, minutes, and AM/PM. Next you should convert those into a quantity of minutes: 

I would like to point out that while your code is clear and well written, if your actual goal is to experiment with A*, you don't need to be so literal with using a directed graph. A simple two-dimensional array of weights is perfectly usable for A*. In fact this is exactly what many interactive javascript demos of A* do. It looks as though your final graph is this way too. If in the future you want to experiment with a sparse graph or a non-rectangular grid (like a hex map or something), with a little work your code is a good starting spot for that. 

My Thoughts I haven't profiled any of these, but I'm going to assume speed is not a priority. I like #2 the best. It is clean and simple, and easy to understand what the code is doing at a glance. I think #1 is ugly, and the sequential array slicing makes me nervous and seems easy to break. If your number sizes change at some point in the future, this one would be the hardest to modify. I think #3 is better, but not as clear or concise as #2. 

It looks as though you only operate on a single chunk of the array at a time, and once done you don't revisit an index. If that is the case, this is a good candidate for doing these operations in parallel with multiple threads. Also, if your consecutive IFs are mutually exclusive ( I can't tell ), then you could possibly convert them to a switch statement and/or use Boolean operators rather than logical operators. At a minimum you could use else-ifs. Finally, you could always re-write this in assembly, or perhaps fortran, if you are super concerned with performance. 

Reference Implementation Because there has been some interest in a fully compliant implementation, I have created one. This loops over each character once. There is no look ahead/behind (although I personally think that looking around fits within the spirit of the instructions) and instead I cache the 'a' character when checking for a 'c' on the next pass. This of course makes the code look a little ugly, as like fizzbuzz, the checks are not quite similar. This was written and tested in C. 

On a personal note, I wouldn't necessarily use inheritance as my go-to solution for this problem without a lot more knowledge and thought about the use-cases; I only followed your initial design. Temperatures themselves are fairly trivial, but perhaps for a more complicated scenario this implementation would have advantages. 

Wrong Objects You've made objects, but you haven't really made the right ones. Your , , , and classes are really just wrappers for a string, which is already a class. Object oriented programming is not always the best solution for a problem. FizzBuzz itself is frankly very trivial and almost any object based approach is a needlessly complicated solution. With that said, perhaps we can redefine the problem to make it a better fit for an object oriented solution. New problem definition Consider this modified problem: As input you will receive a list. Each row (a rule) will have one or more numbers (divisors) and a text substitution. After parsing the list, for every number 1..100 you will either print the number or a substitution for the number. For each rule, if a number is divisible by all of the divisors, you will use the substitution. In the event of a tie, use the substitution from the rule with the most divisors. If there is still a ties use the substitution for the rule with the smallest individual divisor. For example, given "3 6 apple" and "2 9 banana" and "18 candle", they all tie for an input of 18, but "2 9 banana" has the smallest divisor, 2. 

We can see that it took 165 seconds to run on my computer. Almost all of that time was spent calling . was called 27722 times, which is 360360/13, the number of iterations in the loop (plus one or two more). There is also another function, that was called many times. This is called from inside to compare each value in the hash to the value being searched for. It is also called as part of the modulus check and probably a few other places as well. The number is very close ot the number we predicted with the formula. In summary, almost all of the processing time is taken by and its inner call to . Fixing The Code Your bottleneck is in so we should get rid of it. All you are doing is checking if the test number is divisible by every number less than or equal to . You store this in a hash, but never reference anything other than the current iteration. As such, you can get rid of the hash and use a simple counter instead.