I recommend naming your array something other than since is also the operator for creating an instance of an object type. ($URL$ Consider a Different Data Structure Since each object in your output has a unique identifier (the date) you might be better off with a different data structure; instead of an array, you can store the data in an object that uses date strings as property hash keys. 

Notice also that you had an unnecessary loop in the function which did the same thing 5 times in a row (set the inner text and attributes of the element). 

Of course, to make the code more readable, you could mess with the structure of the parameters, such as by using objects with named properties... 

We divide it by 86,400,000 just to convert milliseconds to days. The bitwise operation just truncates off any decimals for us, converting the number to an integer. If the sale hasn't started yet, will be a negative number; otherwise it well tell us which day of the sale we're currently on (using array index notation, so for the first day, for the second day, and so on). Hopefully that's got you thinking about neat ways to programmatically determine which elements to show or hide. Try not to repeat yourself, especially when it comes to strings It's not much fun to have to go through your code and update a bunch of strings when something changes nine months down the road. You can make it easier on yourself by storing repeated strings of text into variables. 

Any time you're dealing with multiplying or dividing by powers of 2, bitwise shifting becomes an option. is equivalent to is equivalent to Bitwise shifts are extremely efficient, so they're a slam dunk if efficiency is the main concern. However, if you weren't necessarily dealing with powers of 2, another approach would be called for. Say the next interview question asked you to modify the previous function to work with powers of 3, or to change how \$n\$ affects the calculation... how would you tackle it? In an interview, this may be your chance to show off that you grasp the concept of recursion. Consider the following solution: 

I have a fiddle demonstrating how the technique works, but it's polluted with logging and metrics, and doesn't have all the logic encapsulated into functions; I'd rather any critiques be directed to the above code rather than the code in the fiddle: $URL$ 

avoiding global namespace pollution Since your logic (wisely) does not depend on global variable declarations, you can avoid polluting the global namespace by wrapping all your code in an immediately executing function expression (IEFE). 

Storing your dialog tree as a monolithic traversable object is probably a good starting point so that you can arrange the rest of your code around that model, but in the long run you might want to break it up into discrete, reusable chunks. This would give you the benefit of allowing you to return to previously traversed bits of dialog without needing to repeat yourself in the code. You could, for example, convert the questions to reusable functions. 

Instead of requerying for that item and checking its values to set the Boolean flags, we can just set those flags earlier in the code, when we're first accessing the values of the list item (using the variable). 

Overall, your code's fine. The only thing that really jumps out to me is that it clutters the global namespace with some variables; I'm not sure if that was intentional (such as if other code is then referencing those variables), but I'd try to avoid that if you can. I understand your unease with the way the code is written, so I'm going to use the rest of this answer to (hopefully) address that concern, and then I'm going to offer some suggestions for making your code more concise and arguably more readable ...but that's admittedly a matter of personal preference. Patterns for Asynchronous JavaScript After working with any programming language for a while you'll start to recognize certain patterns for the "right" way to accomplish something. This is especially true of asynchronous JavaScript, which doesn't immediately mesh with the single-threaded synchronous coding mindset we programmers usually start with. The biggest eye opener for me was to recognize that as soon as you've made your code dependent on the execution of an asynchronous function call, you should stop adding code to the current function, because when the asynchronous function actually executes, the current function will no longer be within the execution context. 

Eliminate potential logic error in return value I'm assuming the purpose of this code is to let you provide the name you want for your subsite, and the code will give you an available name based on whether the provided name already exists. It does this by appending/incrementing a suffix to the provided name whenever there is a naming collision. If this is the case, your function should return sans the prefix, not . To walk through an example briefly, let's say you want to name a subsite . The code checks and doesn't exist, so it returns which resolves to . You then go ahead and create a subsite named and everyone is happy. One month later, you come along and decide to make a subsite named . The code checks and sure enough, doesn't exist (since you created last time), so the code returns which again resolves to . Now you're going to run into a naming collision. Reduce the number of instantiated SPSite objects You are only ever dealing with a single SPSite object in this code (the parent site that you are checking for subsites). Therefore, you don't really need to create and dispose of a new SPSite object in every iteration of your loop just to grab a subsite from it. I recommend refactoring your code to instantiate the SPSite object outside of and pass it in to as a parameter, along with the name of the target subweb . 

In the SharePoint Static Class: I would recommend against naming your simple class since that sounds awfully similar to the namespace. I'd also rename the method from that class to be more descriptive of what it truly does. makes me think it would be creating a list in SharePoint, but it's not really building anything, it's just returning the list item collection. would be much more explicit. In the MMTreeBuilder Class: I find code is more readable when all method names are verb phrases rather than nouns. Each method name should describe what the method does. You've done this for all of your methods except one. The method name sounds like a class; I'd rename it to something like . 

Edit: even better, as you noted in your followup comment, just update directly and you won't have to deal with ! 

code layout For code cleanliness, I recommend rearranging your code so that the function definitions are all together at the end, after the imperative commands. 

This also eliminates some repetition from your original code, which is always a good sign. Note that for improved DOM-query efficiency, you could use the native JavaScript instead of the generic jQuery selector function. 

Use UTC Time to avoid timezone issues People in different timezones will see different values for the current date and hour in JavaScript even when viewing the web page simultaneously. This is determined by the user's current timezone as specified on their system. Generally, when counting down to a specific date, you want the countdown to be the same for everyone, no matter their system's timezone. You can use UTC times to retrieve, set, and compare time values against Universal Coordinated Time (which roughly corresponds to the old standard Greenwich Mean Time (GMT) but ignores daylight savings time). If you have a date object, you can call to see what time it corresponds to in UTC. You can also call all the expected getter and setter functions to retrieve or update specific components of the object, such as , , etc. I would create a variable using and then set its date components using the UTC setters. You'll then be able to compare the current date against that variable and JavaScript will be smart enough to take timezone differences into account. 

Right now is a string that seems to be put together solely for searching through it. That has the potential to be a big performance bottleneck. If you change it to an array, you can squeeze a bit more efficiency into your code by sorting the array and then using a binary search method to detect whether it contains the desired value. Here's an example of a binary search method. 

(Since this code needs to work on IE8, it's clobbering the mouseup event instead of adding an event listener to it for the sake of brevity and performance. Add that to the list of things I feel guilty about.) 

I made a few improvements to this based both on Konijn's suggestions and my own observations, although I never was quite able to reconcile the simulation design with any sort of MVC approach. The most significant improvement is to the velocity algorithm. Improving Readability (Variable and Function Names) Only used ALL_CAPS for primitive and string constants, changing the canvas and the canvas context variable names to lowercase. Changed most anonymous in-line functions (such as the event listeners attached to HTML controls) to named functions. Renamed the ambiguous function to Changed the field to to reflect its expected Boolean type value. Removed some unnecessary intermediary variables pointed out by Konijn. Improving Calculation Accuracy (Verlet Integration) I incorporated the velocity verlet algorithm into the function to produce a more accurate simulation than that achieved through the original Euler algorithm. This required me to track the acceleration of each object, rather than just its velocity, and incorporate a variable. The updated algorithm more accurately simulates stable orbits, and doesn't produce the wildly inaccurate results that the old algorithm does when objects are under high gravitational acceleration. It's still an imperfect simulation of gravity, but the stability is more natural. Updated Simulation: 

To generate those nested, nearly identical calls, instead of coding them all manually you could have a recursive function that builds and returns a function for you. Something like this would work: 

For the sake of completion, here are some analogous dummy functions used to generate a biased but still pseudorandom array: 

You'll find that although there's a small performance penalty resulting from the need to sort the array, you'll be able to look up the indices of elements much faster this way. Check out the code snippet embedded below for some dramatic proof! 

That's just to give you an idea of how you could go about cleaning it up. There are other improvements you'd want to make in your final code, such as using a variable for the timeout delay, and wrapping up the relevant code sections in closures as necessary. We'd need to see the full code to identify other areas for improvement. Proof that the concept works: