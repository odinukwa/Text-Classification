The last three steps are pretty much the same for all branches once you have the value and know the style name. So, you can move those three steps to a common place and do them once and just set up the appropriate state in the if/else. Also, this structure: 

I've discovered that node.js v10 supports for promises (or you could employ a polyfill) so it could be slightly improved by moving the logic into a handler. 

Note: You don't need accessor methods for these properties. They are directly accessible as properties of the object. If you don't want them directly accessible as properties (e.g. you only want methods to be able to access them), you can do this: 

Here's a jsperf that illustrates the speed difference: $URL$ If you had a much large data set, then it might pay off to put the values into an object to serve as a direct lookup index (faster than ), but that's probably only faster when the list gets a lot longer because there's setup overhead to build the initial index. 

You could launch all the operations in parallel and then call the callback when the first one succeeds or when all have failed. Here's a way to do that: 

if you want to limit what you find to a particular scope. Or, perhaps you should just be using a class name if there are potentially multiple matches: 

FYI, your jsFiddle doesn't work on Chrome because Chrome won't run scripts linked directly from github (because scripts from gitjub are reported as text/plain). 

You can use which takes an array of arguments and those arguments will then be passed to the actual function as a series of normal arguments: 

This version is coded to return for , but that can easily be modified to return if desired (which seems more logical to me). 

You could also remove some redundancy from the table by making the table only be the steem method name you want to call. 

I'm personally not a fan of using a single variable for many purposes (I think it interferes with readability and maintainability) so I would probably do this: 

FYI, I did not check only for the specific error like you were doing. If there's any error, then the DNS check did not succeed so in this type of structure, it seems you're looking for any single success or all of them failed (no matter why they failed). 

First off, your code really breaks down to this logic and I find it helpful to write it out the longer version to full understand the logic flow before trying to shorten it: 

And, here's an even faster version that just attempts to calculate the desired pixel spacing and starts with that. This is 14x faster than your original. I don't think the last two loops are probably needed at all. 

Any time you see the same pattern of code repeated over and over, figure that you should eliminate that repeated code, either with a common function, a loop or some other technique that makes only one copy of common code. Any time you see an if/else comparing to a bunch of values and then selecting different data based on what matches, consider using the keys of an object to do all the lookup work for you. Any time you don't really need data to persist across function calls, consider moving variables inside a function rather than using globals. Make absolutely sure that all loop variables are declared as local variables. Implicit global variables, particular loop variables are a bad source of hard to find bugs. 

So, this is pretty much the same amount of code as what you had, the main difference being that this version has full error handling whereas your version did not handle errors from and the browser request was left permanently with no response upon error. 

If you can allow fetch to load potentially before promises are available, then you could use the fact that fetch presumably can't exist without promises in a native browser environment (because fetch returns a promise) and could use this shortcut: 

Get a DOM element once into a variable and then use it from there rather than calling more than one for the same DOM element. Put the color code into a reusable function rather than having two copies which also makes it easier to set the color in just one place rather than three places. Put zwa, zwb, zwc, zwd blocks of code in order to make it easier to read and follow. 

So, all you're getting out of your implementation is a slightly more efficient length and every other operation is less efficient than just using the native code way of doing it. Is this collection really useful? There are some older browsers that don't offer the .keys() method, but there's a pretty simple shim that implements it if not available. In addition, your implementation loses functionality that a plain javascript object has. For example, you can't pass your collection to any function that expects a javascript object with the keys and values on it because those are hidden inside, they aren't actually properties of the collection object itself. Then further, you can't do custom iteration of the keys and values without first creating an array of all the keys because you've hidden the natural ability to iterate the keys of a javascript object. 

And, the whole thing could be reduced a lot more by just putting a common class on all elements that you want to perform the same operation on. So, take all the elements that you want to set on and give them a common class name such as and then you can replace most of the first code block above with this: 

You can combine the two identical assignments at the end into the same line rather than recalculating the same value again: 

The other statements are what you do from a handler to turn the promise chain into a rejected promise. You could also do , but works just as well. 

Your implementation is taking and mapping it to which is not exactly the same thing. An exception or return of a rejected promise in in your implementation will hit the , but in , it will not hit , so I think your is not correctly imitating the behavior in some circumstances. Here's my implementation that should more closely mimic : 

Putting inside another function like this seems a little odd. Usually, you would call inside a as that would make your function a bit more reusable. Setting up an ajax call to run every 3 seconds in perpetuity is generally not a good idea. For starters, it's horrible for battery life (phone, tablet, laptop). And, it can get messy if you every get in a situation where the ajax call takes longer than 3 seconds to finish or timeout. Then, you have multiple ajax calls in flight at the same time and they could be building up. The safer way to do this is to launch the next ajax call from a that is set in the completion of the previous ajax call. Then, they can never build up. 

Here's a description of how the code works: cycles through all the images, calling a custom function for each item. The return value from the custom callback is added to an array and the final result of the call is an array of all the returned values. returns from the callback, the promise that returns. So, when the is done, it will have an array of ajax promises. passes the array of promises to which then waits until all the promises are resolved (e.g. all the ajax calls have completed) before calling the handler. In the handler, the results of all the ajax calls are passed as arguments. Each argument is an array of length three. in each array is the returned data from the ajax call. is the status from the ajax call, is the jqXHR object from the ajax call. In this case, you just need because we already know the status. So, then handler cycles through all the object passed to the handler with one array passed as an argument for each ajax call that was executed and the in each of those arrays is the ajax result. Then, after processing all the ajax results, is called. 

On your method, you are only removing the client from the data structure if is already true. I know it's supposed to be the case that those two operations are innately tied together, but why not remove it from no matter what? You don't want any chance of a memory leak here and it's not like some random attacker can send an unauthenticated message using your client object. The client object is uniquely associated with the socket. 

This mostly seems like a layer of sugar coating that just adds overhead and doesn't add any improved functionality over what a javascript object already has. The only new functionality I see is keeping track of a length, but this is a lot of extra overhead just for that. The length could be calculated at any time on a plain javascript object. Here are the analogs to your methods: 

Then, you can fetch an individual parameter anytime from the params object. In fact, you won't even need to store them all in globals since there already stored in this one variable. 

This uses a very useful feature in Javascript called a "closure". When returns the inner function , the code in retains access to the variable even though has already finished executing. This allows you to privately accumulate the sum with successive calls to without using any globals. 

You are correct that it would be much faster to parse all the parameters once into an object and then just access them from there rather than refind every single parameter from scratch each time: 

Some of the things you're doing in here could easily be more general purpose functions on their own that would make them more available for reuse in this or other projects such as and the calculation of and the background color. You might consider make those utility functions outside of this scope that could be used elsewhere. The variables , and could be pulled out of and up into your IIFE (I'm assuming their values don't change) so they don't have to be refound every second when is called. 

When you do need to modify the return value, you just add a handler and the modified value you return from that handler becomes the new resolved value: 

Item 1: I'd suggest getting rid of all global variables except . They don't look like they are needed and just open you up for a potential conflict with other global variables. Item 2: This line of code: 

You could also consider making the max length be a non-enumerable property of the array so you don't have to pass it to every time. 

You don't need to use since the data is already in an array. If you just process each file as it is read, you can avoid the iteration entirely. You can avoid some temporary variables. You should declare all local variables with , or as appropriate. 

A good mindset to be in when tackling coding tasks like this is to Don't Repeat Yourself (known as DRY). If you're ever copying/pasting the same or mostly the same code in more than once place, then there's probably a better way to do what you're doing. You can either put something into a loop to repeat the same operation or put the common code in a function (with one or more arguments) and just call the common operation each time you need it. You pretty much should never copy the same code in multiple places. Here's a shorter version with these changes: 

Well written animation functions typically use a tweening algorithm that checks the system clock to see how much time is actually remaining in the originally specified time allotment and then adjusts the animation increment to put things back on time, even if the timer events weren't coming in exactly on time or the browser was super busy and you weren't getting all the cycles you might want or the host CPU just isn't very fast. Done well, this can even allow you to adjust the step value for smoother animations on more capable computers and coarser steps on less capable computers. As you have it, you have a hard coded step function in time of 1/10th the time and thus 1/10th the total opacity change. On capable computers, you can run much, much smoother than this. Here's an example: