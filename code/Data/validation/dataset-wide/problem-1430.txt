I like the assertion, and breaking the number into a tuple of digits. I'll suggest, however, that you consider calling it instead -- because how can you stand to type the current name? Source code locality Next, I'll point out that you have a pile of "global" variables defined that in general you only use in one place. I suggest that you redefine most of your global lists to be tuples instead, since they aren't going to grow (or shrink, or get changed) during execution. And furthermore, move the tuples into the functions that actually use them. Either treat them as constants, or as literals if they're only used once ever: 

This is an interesting question. Thanks for posting it! IMO, you don't actually have a class here. A would be a system object that has a name, maybe an id, a password, some relationships to material, perhaps one or more privilege levels. What you have here is an object that provides an interface to a database table - specifically, the user table. This is a Table Data Gateway in the parlance of Martin Fowler. Let's write some sample code: 

One thing you should have learned about classes/objects: when you construct an instance of a class, it should be ready to go! There are few exceptions to this, and all of them are awkward. In your you are breaking this rule. Your constructor sets and and leaves all the other instance data unset. There are several ways around this. The most basic of which is to pass in all the instance data as parameters, or compute it based on parameters. For instance, would be a computation, while passing as a constructor argument would be passing it in. Alternatively, you could depend on some (sub)class specific methods to return values you need: Don't use , use subclasses If you're writing OO code, and you find yourself using a case statement, there's a good chance you need a subclass of some kind. Not always - your method might switch on some kind of external data - but if you're switching on internal data to change your behavior, you could probably use a subclass to get that result. In your case, you're switching on , which is doubly expensive since you are re-running a pure function each time with no caching of the result. Instead of doing that, create subclasses. Push the majority of the "real" code into the and classes, and use to provide the string description, numerical stats, and any special attack text that is needed for the game: 

You want to move as much as possible out of the inner loops. This seems pretty easy. Also, spaces are free and don't slow your program down at all (long variable names slow your code way down, but spaces don't)! Your inner loop is . You have a series of that checks the value of but the interesting cases are the first and last iterations of that loop! So, shorten the loop and move the exceptional cases outside of it. Of course, you can do the same thing with the centered on the variable, moving those statements out of the outer loop. But that would make copies of the inner loop twice, which you probably don't want to do. So maybe settle for a little less and move the computations out to the outer loop: 

This is you searching for a matching key in the list. I'll bet you have this same code in other places, like a "find" and maybe an "insert" (if keys are required to be unique). You should consider either defining a macro or a private (internal) function to do this for you. 

There are three types of elevator control systems that I am aware of: rheostat, push-button, and destination-control. Your simulator does not simulate any one of those three types. I suggest you try to implement a simulation closer to whatever elevator model you actually have in mind. Be LITERAL! If you want to simulate a push-button elevator, with [UP] and [DN] buttons on each floor, then do that! Create floors. Give them an up and a down button. Give them lights. Provide an elevator cab interface with buttons, and the super-irritating "door open" and "door close" buttons that don't appear to do anything. Next, implement the strategy pattern to make the elevator control algorithm pluggable. There are a number of competing algorithms for elevators, so why not support more than one? You might consider threads, or async, in order to support some simultaneity: you want to be able to handle buttons pressed while the elevator is moving. Finally, move your argument parsing setup into . And get rid of - use or something more comprehensible. 

(NOTE: A little searching provides this module: $URL$ - I don't know if it's right for your needs.) I'll further recommend that your audioscrobbler module should accept the API key as an external setting. Which means you need one more local module: 

This is a lot clearer, IMO. It shows what you are trying to do, and the conditions under which you will do it. It pushes every other consideration down into lower level functions. Of course, you have to actually write those functions. But, again, focus on doing just the right amount at the right level, and it should be straightforward. 

I would also suggest that you utilize instead of your string. This case is pretty much why it exists - to express the idea that nothing is available. Except for the next suggestion... I would also suggest that you write your code expecting to return multiple values. Actually, to generate multiple values as an iterator. So your code wouldn't check for a sentinel value meaning "I got nothing." Instead, it would iterate over all possible values, and possibly special-case the empty sequence: 

When you see a , you have to ask, could I add this to the main loop test? In this case, yes, you can: 

You've structured your code in this incredibly indented format, for no good reason that I can see. In fact, you are testing a series of conditions, and when those conditions are met, you are returning. Just structure your code that way - it's easier to understand: 

FWIW, I actually think this last bit would be a bad idea, simply because it relies so very much on hidden behavior. It's not at all clear, just reading the code, that there's a bunch of secret-squirrel things happening in the background. With a C++ string class, that's okay - with C strings, secret accounting is surprising. 

Problems in Your and have some serious issues. I think your instructors have gotten somewhat lazy. I'd suggest that you invite them to submit their code ( and and whatever else they have written) to this site for review. First, there is the problem that this file won't compile under : 

There are some things that seem obvious to me, but I don't know how much benefit you will see from them. 

This is good code for a rusty coder. Especially a rusty Fortran coder! Congratulations! First, the experience. I played it, and had this on screen: 

Take these comments together with the comments of others, not instead of them. They have already said much that needs saying. 

What do you think the output sequence should be, starting from 5? I think it would look like: 5, 3, 2, 6, 7, 1, 4 since you scan from 0..size in your adjacency matrix. (That is, 5 would find 3 before 7, etc.) 

The 5 lines above are basically a "ping" operation - you are generating a sonar ping and shaping it using the 1 and 10 constants. I'd suggest you write a parameterized function. 

By default, the presentation will be in insertion order. For you, that is reversed, so you will want to reverse the ordering when you iterate (using or ). Update To use the ordered dictionary, you'll have to import (unless you're using python3.6, where I think dictionaries become ordered by default- check that). So: 

Objects should manage their own data. User interface logic should not be part of model objects. For model objects, pass in data as parameters. Especially data from the user, like . 

Use vertical space to separate unrelated things You didn't separate things using vertical space. This is perhaps the greatest sin in programming. Always, always use vertical space (blank lines, paragraphs, etc.) to separate parts of your code. If you switch from doing one thing to another, insert a blank line. If you end a paragraph and start a new paragraph, insert a blank line. If you come to the end of a function or a loop, insert a blank line. Even if you are the most secretive hacker ever, and you never intend to share your code with a single other living human being, at some point you will have to go back and read stuff that you, yourself wrote six months earlier! Make it easy on yourself, or on whatever other humans have to read your code: try to make it easy to read! Use vertical space to separate unrelated things. Keep related things together Next, consider the line: