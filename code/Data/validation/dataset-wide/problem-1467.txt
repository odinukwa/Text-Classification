In the , you code silently ignores the error if the response code is not 200 and returns , which can lead to an expected exception later on. I'd suggest to raise an appropriate exception here (the simplest thing to do is to the standard request's method). In the function, you cast the columns to a specific type and then check it. For example, you cast the column to an : and then check that's an : . It's useless because it's always a string if you cast to a string. I'd recommend to validate the data first (using standard functios like to check that something is indeed a number), filter it to remove invalid rows and only then cast the result to an appropriate type (your current version will raise an exception if, say, the column has a non-numeric value). Before removing the outliers, you can also remove the data that makes no sense (like negative prices). I don't see the point in using recursion in the function. For instance, this lambda function looks quite confusing: . I believe that a simple loop would be more readable here. Joining to path as strings with a hardcoded separator might break if you code is run a different OS. You can use for a more portable and robust solution. I think that printing the filename itself here: 

Variables naming: their names should start with a lower-case letter(it might not be the case for constants, but there are none of them in your code). You have it almost right, except for the , which starts with a capital letter. You should also give descriptive names to your variables: and , are not really good. Indentation and whitespaces: there should be a whitespace after the opening bracket, before the closing one and around binary operators. For instance, 

You can just remove it (and all other similar comments). Moreover, if you need to make a comment about what the piece of code does (like "# Then check if the value is nonintegral"), it's a hint that it should probably be implemented as another function with a descriptive name. You should strive for a self-documenting code. 

to make your code more concise. Prefer interfaces to concrete implementations. That is, use instead of unless you need some specific features of the latter. Passing strings around as node identifiers make the code less understandable. I'd recommend creating a separate class. 

Code simplification acts essentially as a smart pointer. It's already implemented in the standard library. You can use the class. This way, can just have an as a member. The default copy constructor, assignment operator and the desturctor will work properly. Use of non-standard features 

Spacing and indentation. It is inconsistent in your code. Sometimes whitespaces around binary operators are absent, sometimes there are arbitrary whitespaces before a semicolon. You should keep you style consistent and adhere to established guidelines. It is easy to fix it using almost any modern Java IDE. Testing. If do not use unit-tests, start using them. Testing your code in a consistent, systematic manner is a very good practice. 

Don't care about that. Unless you can prove that it creates a bottleneck, just stick with whatever seems the most readable and maintainable option. prefer the latter. I'd also rename the methods. is too generic. What exactly on ? Weeks? Months? Years? If it's years, call it or something like this. 

The method seems too big to me. Taking into account a new algorithm described in 1., I'd do it this way: 

Use more descriptive names. I have no clue what mean. What is ? Something like and would be better (well the first one is not exactly a digit, so you can come with even better names). There's no need to return from the function explicitly (sure, you can if you want to). Write proper automated tests for your code to reduce the number of bugs (your bug is very likely to get caught by tests). In fact, you can check all possible valid inputs. There're only 100 of them. There's nothing wrong in having stand-alone functions. There's no entity here, so I don't see the point of modeling this problem in terms of objects. A function from an int to its string representation is just a function. 

You can write simpler code without 's here: converts a string to an unsigned int (the last argument is the base). I think that expresses the intent more clearly than . 

The API of your class: in my opinion, there should be one more method: that returns the minimum element but not removes it. The only way to get it now without deleting is to call and then re-insert it into the heap, which is inconvenient and inefficient. There is a bug in the method. The fact that is less than does not imply that . It can lead to a . I have written a simple unit test that exposes the problem: 

All GUI modification must be done in the GUI thread. It refers to the creation of components, too. It means that your method should be invoked on the EDT thread(you do it properly for modifications). This method does not close the if throws an exception. 

Using a while loop to simply iterate over all elements of a collection looks strange. I'd rather use for each loop: 

Functions and variables naming: it is conventional to name functions with a verb(to describe an action). I would use instead of and instead of , for example. You class violates the single responsibility principle. Despite managing memory allocation(which is its main responsibility) it also implicitly implements some data structure(a stack?(I mean things related to the , the pointer and so on)). It makes the code rather hard to follow: those operations with and pointers are not easy to understand(it is not clear why they are performed in the first place). There are two ways to fix it: 

It looks much better now(and it passes the test)! The old version was incorrect because we can have several different lines with the same number of points on them and there is no guarantee that , , and lie on the same line(you can take look at the unit test I have shown above to understand it better). 

Printing the error message to standard output looks like a bad design choice (if you code is run automatically and no one is checking the output, it would just silently return . I don't think you want it). It would more reasonable to throw an exception in this case (I'd throw an instance of the ) because a situation is exceptional (the input is invalid and there's no meaningful way for this function to handle it). Moreover, one function should be responsible for one thing. Your code computes the value of the ackermann's function and does the logging at the same time. It's another reason to handle invalid inputs using exceptions. You can also simplify the code in the function by parsing the input as an integer. There's no point in parsing it as a float and then checking if it's an integer. You could rely on a standard function to do this job for you. This way, it would be enough to check that both numbers are non-negative. Now let's talk about variable naming: 

Binary operators should always be surrounded by whitespaces(it is inconsistent in your code: sometimes you do surround them, sometimes you don't). For example, 

would be nice (otherwise, the user might not which file this message refers to). In the function, you don't need to compare anything to one: . contains boolean values. You can use it directly like . Functions and methods are usually named with a verb. The doesn't sound like a good function name to me (moreover, it provides little information what it actually does). I'd suggest calling it like or . You code is lacking proper documentation. Your comments are quite terse and they don't make it clear what a specific function does. I'd suggest writing proper doc comments for all functions in your code to make it easy to see what each function is supposed to do and be more specific about it (for instance, if a function reads all files in a directory and loads the data, it would be reasonable to write what kind of input format it can handle and what it does if it fails to work with a file). Your specification also says that the application is supposed to handle new data. I don't see that functionality in your code (as I can see, it just reads all the data in bulk and combines it before processing the data). You could also make you system more flexible by trying different ways of outlier detection (at very least, you could make your filtering function take and as arguments). 

Nope, it is not correct. The problem is that the to_visit list can change after visiting a child of the currect node(for example, on a full graph with 3 vertices your implementation will visit the third node twice(if you run the depth-first search from the first vertex)). However, it is easy to fix it. You can just iterate over all children of the current node and run a depth-first from a child if it has not been visited yet(using an if statement inside the for loop). 

Change the return type to . It works with C++17 only, but you can use with earlier version of the standard. If neither C++ 17 nor boost is available, you can return something that can either contain a value or be empty (like a smart pointer to a ). You can throw an exception if the key is missing. You can insert a default value for the key and return it. 

is usually used for something with side effects. If you want to transform one sequence into another, is an idiomatically better choice. 

You run all the computations in the method. It's not a good practice. One method should do one focused thing. That's why I'd recommend to create a separate method for "step" of your computation: 

Using a concrete class where an abstract one or an interface can be used is usually a bad practice. That is, the method of the class should return a , not a . There is no need to get bound to a concrete implementation. The class has redundant fields and methods. The field is not used anywhere, so there is no need to keep it. Getters and setters for it are not necessary, too. Moreover, this classes exposes its internal representation. The clients of this class(in this it is the class) do not really need to know how the children of this node are represented. Instead of returning a and letting the client work with it, I would create two methods: and . Here is my version of this class: 

The logic of the code. It looks like your algorithm is not correct. The problem statement clearly says that the process should be repeated until we get one digit, but you compute the sum of digits only twice(what if still turns out to be greater than 9?). You can use a recursive method to make your work for all possible cases(or you can keep iterating until the root is found). Modularity and separation of concerns. It is not a good practice to have one method that does everything. I'd recommend creating a separate method that computes the digit root so that the main method is responsible only for the I/O. 

More robust error handling. Clearer variable naming and documentation. Making sure that it follows all specification, including adding new data to an existing dataset (you might also try more advanced outlier detection techniques here). 

This way, the time complexity will decrease to , where is the number of edges and is the number of nodes in the grid (it can be even better in practice if finds the "right" path to the end quickly). 

is even worse than useless. It clutters the code with irrelevant information. The documentation for the class belongs to the class, not to a . There several other comments in your code that repeat parts of the class documentation. They're also gibberish. Removing all these comments will make the code cleaner. Adding doc comments for your class and its public is a good idea. They should describe what it represents, what are the pre- and post-conditions of each method (for instance, what happens if I pass a negative salary? In your case, it's garbage in- garbage out. Document that. It's obvious from the method signature itself). You might want to add proper input validation (for instance, you can throw the exception if the salary is negative). You can also use the static factory method to convert integers to 's: to me, looks better than . It can also reuse frequent values. 

The Logic.java class contains a lot code duplication. It's easy to get rid of it. For instance, the expression is used four times. I would rather create a method for it. There are a few "strange" reassignments: for example, in the method and are initially set to and unconditionally reassigned a few lines later. Creating them upon the assignment of the second value (the only one that is actually used) makes the code more clear. The case when the equation has complex roots looks pretty convoluted in general. I suggest doing it this way: 

This code invokes undefined behavior in case . You should probably implement a copy constructor and a copy-assignment operator. A default copy constrcutor(and assignment operator) just copies the pointer, not the content of the (I'm not sure if you it is what you want). A good way to get rid of many bugs in your code is to use standard containers instead of dynamic memory allocation with raw pointers. For example, you can use a to store the elements of the : 

I don't get the point of returning the from the function. The return value is never used (and the which is passed as an argument is modified in place). The functions prints the , doesn't return anything and then it's returned value is printed: . There're two reasonable options here: 

In general, each class should have single responsibility(that it, you might create two separate classes here: one for computing the longest prefix and the other one for checking and parsing command-line arguments). But I think it is fine to have one class here(the entire class is pretty small) as long as the format of arguments is not going to change in the future. 

Unfortunately, your algorithm is not correct. It evaluates an expression to , but it is clear that the right answer is zero. It is not an implementation bug. The logic itself is wrong. So what can be done to avoid(or, at least, to minimize the risk of) ending up with an incorrect algorithm? 

Blank lines: it is conventional to have a blank line between methods, constructors and so on. Here is a refined part of your class: 

. That's wrong. It returns a dangling reference. You can't return an rvalue reference to a temporary object. Return it by value. It doesn't change the , so it would be better to pass it by a const reference. The same is true for . It's also broken because it returns a reference to a temporary object. . Once again, if you don't change the input objects, pass them by a const reference. You can also simplify this function using function with a custom predicate. This piece of code is a little bit confusing: 

There are several places in this code where a loop is redundant(or at least can be simplified). For instance, this for loop: 

I'd use the method here. You can avoid using the queue altogether. You can keep the leftmost index of the current "window" and the set instead. 

can be substituted with a call to the method(the index of the element is not used, anyway. It just checks that whether an element is in the list). This method is also way too long and complicated: 

Code simplification You don't need to use a custom linked list here. will do fine, too. You can keep the pairs in an and store a mapping from keys to iterators in this list in an . Passing by const reference Passing keys and values by value creates an extra copy, which may be expensive. You can pass them by a const reference to avoid it. Comments Redundant comments clutter the code and hurt its readability, for instance: 

If the was equal to before the first step, the behavior of the program is obviously incorrect. As you have said, you need to synchronize a group of actions(write, close, addFile, open). That's why you need to use (or a ). About performance: are you sure that synchronization is really an issue? Did you profile your code or are you just making guesses? Before making things more complicated, you should make sure that it will actually solve the problem.