The Details Let me expand on my answer by first saying that Inheritance vs. Composition type discussions are subjective and are debated amongst developers of various languages. There are many blogs, articles and posts on StackExchange sites that cover the debate. Also, since we are talking Swift, I would highly recommend taking a look at this WWDC session: Protocol-Oriented Programming in Swift $URL$ I highlight this session because instead of Inheritance vs. Composition, we should be discussing Inheritance vs. Protocols. Why? Because not only do protocols allow you to do composition, they also provide other features that let you model things in interesting and flexible ways. I would also like to point out that this question is challenging to answer (though I think it is a good question), because you have two seemingly working implementations in the present, but your design choices may not reveal their true cost until some unknown time in the future. This is where the advice based on the experiences of others will inevitably reveal itself but at the same time seem subjective if you cannot relate to their experiences. Inheritance Is really a ? According to Parse documentation: 

As JonathanR suggested, check if their lengths match, if not then there is no point in doing all that other work. 

IViewModel.cs - Core view model interface. Allows for Paging results and serializing to a RouteValueDictionary(RVD). 

Index It would appear you primarily do three things here. Sort, Filter, and Page. There's not much to say about your paging, but the sorting and filtering logic clutter the action. Try creating an object that does the sorting and filtering for you. Something like this: Note: I didn't include all the logic you need, however; I did include what I believe to be enough logic for you to get the idea. 

Psst...You have a typo: should be . Consider making a list/array of the texts you use for dialog so that it's easier to see the text as a whole, then loop through each one adding it as you loop (see below). Then you could do something like this: 

Constructor Adding the ability to give or of items in a constructor could be really helpful, especially if you have your set operations return new sets as suggested above. 

Modify Caching Strategy It seems every image that is subject to caching is ending up both in memory and on disk. Depending on the number of images and caching aggressiveness, this could be more expensive (in terms of resource usage) than the network request used to retrieve the image. From my perspective, using both and the Cache directory together doesnâ€™t add any value. They are both volatile and unpredictable (to different extents). The system could reclaim space from either when it deems it necessary. From Apples File System Programming Guide: 

Why would I ever choose the Protocol + Delegate method (design 2), at least in this case? In this case... Ultimately it comes down to you design goals and the expected lifetime of your app (how long will you or someone else have to support it?). In my opinion, based on what you described, using protocols provides a more flexible design that is better prepared to handle changes down the road. 

Therefore its either a choice between caching in memory and caching on disk or an emphasis of one over the other. This inevitably leads to additional questions about how your app will be used and the what kind of images you are working with. Some basic guidelines: 

Always use brackets. Even if the statement afterward is a one-liner just use them, it'll prevent a rookie mistake in the future. Secondly, if you insist on not using brackets, be consistent. You have an if-statement with brackets and the else-statement doesn't. Curley bracket placement. The standard for C# is placing brackets on their own line. You have spots where you do this, but you also have spots where you place the opening curley bracket on the same line as the if-statement. 

Other Actions The only other thing I see is that the following code is repeated in many of your actions. 

One Problem Your for-loop wants to use the variable later in the call. That call specifically wants the whole model, so if it's possible why not just have store the whole model? As it stands its purpose is to store data, so have is store all the data it could need then that should reduce the amount of code directly inside your for-loop. I hope you find these suggestions helpful. 

Usage: Unit Test I used a simple "Tile" class that you can see the properties of in their initializers. Downfall #2: If you use that PredicateBuilder function on a type that doesn't implement some of the operators it will throw an exception. (e.g. string and '>=', '<', etc). 

Someone consuming your class will get the entire public interface of . This is a lot of mental baggage that doesn't seem to be related to using class. and the concept of chat don't seem to be related at all. I would think of family of chat objects as: 

Test with no cache (this will be your baseline) Test with a simple caching strategy (maybe just using or the Cache directory) Compare the results of step 2 to your baseline obtained from step 1 Not satisfied, then apply a different caching strategy. Repeat step 3. Otherwise, if you are satisfied with the resource usage and responsiveness of the app then you can stop here until there are significant changes to either your codebase, data or the iOS frameworks. 

What is a large number? How much is too many? You will have to test and measure. Test & Measure (and then measure again) I would definitely recommend testing and measuring your caching strategy to see how much of an impact it has. Xcode instruments provides tools to accomplish this. One way to go about this is: 

Finally, we can determine the range of primes we want. To do this, perform a binary search on to find the lower and upper bound. Then, select a random element from the list. You may wish to save this list of primes, so that it only need be computed once. In particular, observe that the sieve of Eratosthenes can be "paused" and "resumed" in computation, so that the results of previous computations may be used in future computation. I leave this as an exercise to the reader. 

This started out as a comment since I'm only going to discuss , but it grew a bit big, so here we go. First of all, I strongly recommend @nukeforum's suggestion that you use the function. Also, as has been mentioned aplenty already, should return a bool: 

Finally, your implementation of is linear when it could be constant. Observe that performing a union operation (on two disjoint sets) will decrease the number of disjoint sets by exactly one. Then, you could add a member (say, ) initialised to that you decrement in your function. 

You are also tightly coupled to the . What happens if you want to replace Parse in the future? You will likely have to throw away the implementation and create something new. Protocols Your protocol provides an abstraction for what the concept of chat means to your application. It conveys this concept without dictating its implementation. It doesn't give you working implementation, but it does score you a point for the future maintenance of your app. It gives you flexibility. With now a defined concept, other types can adopt it, filling in the details of what means to the conforming type (in this case ). Combining this with delegation (as you have), puts you on the path to a decoupled, flexible type that doesn't expose the public interface of and doesn't require your consumer to know implementation details about how Parse is being used to facilitate "chatting". "Less code is better" You don't say why this is or how you prioritize this design principle against things like readability. Is it better because its less to maintain? Less to look at? Personally I would add a couple of caveats to this statement: 

Here are some minor suggestions in addition to t3chb0t's: Using var could easily be and not lose any readability at all. Nesting All that nesting can sometimes make it hard to follow scope. In some cases you might choose to flip your if-statements and return early. This doesn't work perfectly for all cases but I think it would work just fine here. would become and now your entire try-catch is no longer nested further to the right. 

I'm going to assume that you already know about HashSet and ISet in the following review and are just missing the reinventing-the-wheel tag. ICollection You've got Add, Remove, Clear, Count, and Contains. If you add a and to your implementation then you can implement ICollection. Why Dictionary? Perhaps you'd be better suited with a implementation? Correct me if I'm wrong but it doesn't appear you're actually using the boolean value of the dictionary, so you'd be better suited with a . Generics You could create a generic implementation fairly easily. And if you wanted to still allow your existing functionality then you'd use . Set Operations Perhaps consider having your operator functions return the new set from their actions? For example, 

This post will focus on your implementation of Union-Find. First and foremost, you're not using the member at all, so you should probably remove that. It turns out you actually are using this, just not in your Union-Find class. This is a bad idea. We typically wish to minimise coupling, and using a public member in this manner does precisely the opposite. Next, all your members are . This usually isn't advisable; you should endeavour to make them and provide getters and setters as appropriate. Next, you are in my opinion overloading (not in the programming sense! :P) the member. It's doing double-duty, holding the nonnegative parent node index for child nodes, and the negated size of the set for root nodes. The name therefore cannot be meaningful, since its two purposes are so distinct. If you are pressed for memory then I understand your use of that solution. Keep in mind, however, that since disjoint-set structures are really forests, the classic implementation uses objects containing a reference and optionally an for / . This has the advantage of being more semantically meaningful (and arguably more readable): 

Basic Improvements In addition to Sir Python's answer, I've listed some general improvements that could be applied to your code. They're more geared towards design but you may find them helpful, specifically in the case if you were to ever have to come back and change something in it (say 6 months from now?). 

This way on first use it'll cache the list and then from there on out you will have the list already loaded. This way if you were to ever change what is white-listed or want to use this in another project it's already setup to be re-configured. Pointless variables In many locations you have something like this: where you don't actually need the variable. The places validTag and tag are used are as follows: 

Sometimes it seems unnecessary when you're doing OOP in a scenario in which you could easily do it all in one function but it helps significantly when debugging, reading, or maintaining (or in this case when other's are reviewing your code :D). 

This is my 1st F# program so I'm open to any and all criticism on my syntax and the way I approached the problem. Challenge Project Euler 16: Power Digit Sum 2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26. What is the sum of the digits of the number 2^1000?