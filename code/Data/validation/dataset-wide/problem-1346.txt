Pretty freaking simple. If we have a method, then we can do the transformation, if not then we have that exception. As a test, consider the following method in : 

So what did we learn? We learned that benchmarking is hard, and that by the time we factor in all the candidates, we can finally come up with a result: inconclusive. Do note, my intention is not to be rude, it just seems that way because I got a little flustered after reading the following part of the question: 

I would not directly write to the console. You are best off building an interface, then create a class that is passed as an to the constructor. 

It's a pretty trivial issue, but I didn't see any use of it in your programme so I haven't the foggiest if you knew of it or not. 

Where would do all the major work and such. This also means each type of request can be reused for multiple endpoints, with different parameters specified. (The base cares not about any of this, it only cares about the core processing.) Finally, here's what a sample implementation might look like (this endpoint isn't fully implemented, don't review it yet): 

Overall, this seems quite good. It just needs minor tweaks to make it a little easier to read and maintain. Good work! 

Bottom line: the client computer is always compromised in your eyes. You can do no more to secure it at this point, with an instance of Visual Studio (which this can be done more effectively with a separate programme that hides on the client computer) I can view your connection string and extract it with little to no effort required. (This whole process takes ~10 seconds once you have used the 'Break All' on the programme.) My advice to you: don't take unnecessary security precautions to ensure your work is 'safe in memory' -- there's no such thing. All memory can be dumped, and even if it's only in memory for ~0.00001ms, an attacker can still find it. Just worry about building your application, let the memory security be handled by the user. :) 

As far as cleaning up your code: this is about as idiomatic as php will get. Though you should definitely extract this to a function as appropriate. 

Don't worry so much about the password sitting in memory. Yes, it's generally safer to keep it in memory as shortly as possible, but that goes along with Single-Responsibility Principle, the Principle of Least Astonishment, etc. Your password (and all variables) should be as short-lived as possible. (I.e. Don't do like the old C code used to with 100 variables defined at the top of the file.) I have turned this answer into a guide on my blog for further explanation. 

Is spelled like that? Not ? Also, with what this and the property above it do, I would consider wrapping them in a function call that will do that conversion, that's a lot of code to have in an initializer. 

I want to talk about your View while I'm on mobile and thinking about it. Just like regular C# code we should definitely define structure for our Razor code. The first thing that rubs me wrong is that statement. I really don't like it because you only need it for the declaration at the top of the file. I would just get rid of it and explicitly specify the model full type. Next, I really don't like the block with the and such in it. Generally I just prefer to prefix each code block with instead. This helps create a more consistent convention throughout. (Right now you mix and in your view which is generally bad.) As far as the HTML itself, we've started leaning more on CSS to do the styling for things, so elements like and should be then in your CSS would have . Let's talk about your serialization: 

The is included to demonstrate that each item is only being iterated as maximally necessary, and can be removed for easier visual. 

This saves you LoC, and probably makes it faster. (You could also possible make this a as well.) And in my opinion, this is more readable/concise/descriptive. Another alternative: 

Now I used here to help performance: it doesn't modify the array so there's no need to pass anything special around, just reference it as a "pointer". (Though, in reality, here is superfluous as the array is a reference already, but it's good to be explicit when possible.) Next, we need to take a and get a section from it, so I wrote a helper-method: 

Now we can build more test-cases pretty easily and functionally. Because takes a single parameter of a , we can pass the entire shape to it and then pass each portion of the tuple as individual parameters. 

Addendum: As pointed out on this Stack Overflow answer, your Mersenne5 implementation is wrong. I'll leave it to that answer to explain how and why, they did a wonderful job. 

No more generics, no more casting, no more inferences. Simply create an action that calls the method for the appropriate . You could, also, create a method that does that for you: 

Even though the exposed collection is a , exposed as a get-only property, I still managed to modify it through the underlying that supports it, via casting. This essentially says, "I know I assigned a to this, let me use it as such" and the compiler lets us get away with it. 

Checking if the buffer is of sufficient length to be saved. Validating that ends with a . Creating the directory. Coming up with the filename for the log file. Saving the buffer to disk. Clearing the buffer after saving. 

While HTTPS is good and all, using AES to encrypt data between a server/client is not really a great idea. Encryption has the concept of a 'public key' and a 'private key', some algorithms use both, some only use one. In the case of AES, it uses one key: a private key. The names themselves should give things away, but I'll be explicit anyway: 

A not so obvious advantage of this approach is that it supports new API endpoints in addition to the existing ones. I don't have a lot of time to make this answer more exemplary, but this should get you started. 

You should also look into the tag, and the tag. Your line indicates that it is to be HTML5 compliant, so it is acceptable to use those tags here. 

Recently I was thinking about how Google, Microsoft Outlook on Windows Phone (and now many others) method of giving you a coloured icon with a letter in the centre of it works. Essentially, given some sort of name, they generate a colour based on that name. The kicker is that the same name always generates the same colour, the icon then generates with the 'initials' (dependent upon implementation) of the sender of the email within it. A sample is below. 

It also would not hurt to add some comments, explaining why you do some things the way you do. Comments, in code, are generally helpful to remind yourself in the future of why something is written in this form. That way, when a more experienced you (or other developer) comes along, you/he/she can say, "Oh! That's why it is written like this." Rather than, "this is not the greatest, I should change it." Then things break. 

Regarding your indentation and such, from what I've seen usually assembly is spaced fairly far from the left (8-12 spaces) then all labels go at position 0. This helps keep them in plain sight, since assembly doesn't have 'functions' and such, and there's not a real concept of 'nesting' (you can nest labels, but any label can be accessed from any other location/scope so it doesn't always do any good). 

Then we create a simple method that will find the method that fits and call it, then return the result as an . You can then pass that directly to a serializer which should be able to serialize it appropriate. 

Personally, I think breaking comments along multiple lines like that makes it harder to read. You're eyes have to jump to unnatural places. Likewise, the bit is nice because those comments aren't shown in Intellisense, but they can still be placed in the generated XML documentation files. The only other bit I would mention, is the use of . You should either use it consistently, or try to limit it. Sometimes (especially in larger cases) it helps to clear things up. But if you use it for some of the properties and not others, it can have a negative impact. I'm referring to the following: 

This script is designed to locate and download the first repository in your sidebar on the GitHub repository page. It downloads the .zip file for that repo and saves it to the default location. I built this script as a test to determine what it would take to perform this type of operation since I needed to use it on something else, but this script itself is the actual script I use (very) infrequently. Basically, any/all PowerShell idioms would be awesome to have feedback on. The comments are there for the person I was writing the script as an example for, but again this is the script I'm worried about. I want to continually improve it. 

to our dictionary. Now all our prompts and whatnot can support the power function. This brings up a new issue: you have no support for decimal/double/float numbers. This is really easy to modify, simply replace all our types with . 

I shouldn't have to tell you which one I would prefer. Just look at all those parenthesis. F# also contains a double-pipe-right and triple-pipe-right operator, which will pipe a tuple to the function. (I'm not sure if you were already aware of that or not.) So you can write something like: 

While this is technically true, prepared statements will not protect you against people entering blatantly invalid data. You should still do some filtering. (Though you need worry less about filtering against SQL injection, and more about filtering against data tampering.) 

Much better already, arrow-code removed. We can also use instead of those types (for the most part): 

Any comments welcome, though I would greatly appreciate any comments/advice on the design pattern itself. 

Realistically, your class is a bunch of helper stuff, so you don't really need instance members, and you don't really want to keep an instance of this class, you care about the class. This is similar to how I do objects in Entity Framework, though my setup was more complex. Your version requires adding a property with a self-referencing name, this version eliminates that. 

This type of question actually requires a little thinking outside the box. The idea here, since we need to store the max with each element, is to use the built-in more creatively. 

Why did I choose for this? Ah, right, because that's what is. However, now you have to either: add a comment explaining such, or remind yourself every time you get there what that value means. It adds no value to the code. You should use the property , simply because it's self-explanatory. (It's also no slower than using the constant , which we should remove anyway as it adds no value to the code either.) Generally speaking, you should use whatever practice adds the most value to your code, not whatever practice is the simplest. For example, you have the functions: 

Then call it as . Much simpler, straightforward and to the point. You still have the other method, in case you need it for other things. 

Same number of LoC, but it's a little more clear what's happening. As far as performance, I don't see any obvious bottlenecks. I think the biggest bottleneck you'll end up having is in the LINQ (this is all speculation, but we're talking microseconds, not even nanoseconds). You shouldn't be concerned of your performance until there's a measurable performance issue. 

I would really not do that. This class should not be responsible for knowing that, this class is all about authentication, not redirection/authorization. One class, one responsibility. Instead, I would make those paths part of a class, or a SQL table that stores that type of data. This allows you to easily and concisely change them in one location for everything. (Who knows where else you might need to know that is the gateway?) 

So having used the SE API multiple times, I like how all responses are in a object, and for my own API design I figured it was a good method to follow. Of course, I also wanted to abstract everything out so that common actions could be handled in a simple manner, so that I wouldn't need to write the same boilerplate code multiple times. (Wrap the entire response generation in a / block then serialize exceptions to JSON, etc.) Of course, since the inside of the / block differs for each request, I needed a way to deal with that. I got the idea to use a class which had a method that would call a method which was implemented differently for each request. Let's start with : 

And we're done with this method! :) I'm not going to comment on the others, they're not nearly as big of a mess, and you should be able to take a lot of what we learned from here to them. I wrote this entire thing outside an IDE and I'm a little tired at the moment, I'll try to clean this up more when I wake up. Overall, not bad for coming from java. Hopefully you learned something from all of this. I mean it all in the best of spirits. :) 

You'll notice that the bitwise-operator method takes 12% of the time the method does. And in this situation it makes a great deal of sense. It's easier to reason how the , and variables are being filled with the bitwise-operators. It's not so obvious with the . Yes, this is obviously a worst-case environment, you will likely have other bottlenecks and JITer that will influence it, but this at least goes to show that there are other just as good solutions to the same problem. Personally, I've never touched the , I always do my own bitwise-arithmetic. To me, it's easier to read and more obvious. To you, it may not be. I wouldn't suggest going so far as to make a loop. I did just that, and it's actually slower. 

I built one of these long ago, and it got lost when I reformatted my SSD (sad day) so here is the new version. It is very multithreaded, spawning threads to calculate chunks. When one thread finishes, another is spawned until all chunks have been assigned. It's quite quick and accurate, though the must be a ratio of for . 

Lots of very cool stuff in there. But, there's also some bad stuff. You are significantly arrow-coded in some places. One of the changes you should make is your guard clauses. Most explicitly, in this method: 

For a new project I'm going to need to be able to serialize random types to TSV or CSV files, so I write a class which can be used to serialize any object to a TSV, CSV or any other _SV file you can think of. (You could literally serialize objects to files with the letter "B" or the word "Rawr" as the column or row delimiter.) It's pretty simple, it starts with a . 

This could definitely cause a division by 0 error if not handled properly. (It's handled properly here, but could easily be made not to be.) Here's a link to ideone with the two tests, for comparison. All-in-all, I hope this was helpful. :) 

Those are both by default, so we need to change two things here: First: in C#, members are ; Second: we need to add our explicit access modifier. 

Should be a instead of . The purpose of is to allow for setting the value in the constructor, and making values which cannot be immutable. If the value (such as an ) can be a it should be. In this : 

I'm not a JavaScript expert, and overall it looks good, but there are a few things I would change (mostly style): 

That makes sense, we want to find the method we're transforming with, then deserialize it (non-generically), then provide that value to the transform method. 

This is advantageous as you already did the comparisons twice, and it's clear that you don't want to accidentally trigger things. Only if it's value has actually changed do you want it to update. (At least, from what I can see.) Just as well, I think this is a bug: