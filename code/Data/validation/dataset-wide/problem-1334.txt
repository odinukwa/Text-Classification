serves as both the log message data structure (with many properties), and as the output handler writing the log message. So you will need to modify the class whenever you change some log propeties and also whenever you change the process of writing to output. It is better to separate the two responsibilities to two classes, and preferebly with interfaces that define the contract between these two responsibilities so that they can be extended to accomodate future requirements (for example, writing log to DB or other destinations, different lof formatting etc) The application code that uses does not call the setter methods. not only this is bad design, but I don't see how this passes compilation. While we are at the issue: the log message has many properties with setters. a (working) application code that has to call each setter will look long and ugly. I suggest to either use the pattern, or the fluent technique The does a lot of work. once again, this creates the risk of being hard to maintain and extend in the future. You can start by having a separate and continue breaking up the code to smaller pieces that do "atomic" operations like determining value of one attribute Dates: First of all, you initialize the with every call to . This class makes heavy use of expensive regex processing. It should be moved to be a variable. Second, Java 8 contains a new date time api, similar to the one in Joda library. it handles dates better, including formatting them into Strings. Last but certainly not least: you close the file handler only if no excepption is thrown, creating the risk of resource leak. You should close the handler in a clause or better still, use Java 7 try-with-resources feature 

all of these do not contribute to the correctness nor clarity of the code. regarding usage of parenthesis for operands of operator, personally I think this is another case of redundancy, but there are other who argue that this is ok. Java has constants to define min/max values for number types. They are defined in the number wrapper classes, like 

Java's low level thread synchronization mechanism (synchronized blocks, volatile variables, wait(), notify(), etc) were proven to be tricky for the human single threaded mindset. Threading hazards like deadlock, thread starvation, and race conditions, which result from incorrect use of low level thread synchronization, are also hard to detect and debug. To that end, Java 7 introduced several new features/classes in the package that allow developers to approach the thread synchronization domain from a high(er) level. is more flexible and gives more fine grain control over the scope of locking. it also performs better. The advice that I see around the web (including on Stack Overflow) is that should replace synchronized block in all new code. 

2) Modularity: the does all the work: the IO operation of reading the input file, parsing the JSON contents, and all the SQL processing. This means that any changes in the input or output will result in changes to this monolith class. this create the potential problem of side effects: when you replace the JSON with XML, you may introduce bugs in the SQL processing. For the sake of Modularity (and also clarity) you better break the monolith class into smaller classes that take care of one aspect of the problem domain. Readability 1) : The use of this class (may) have performance gains, but you pay for that in readability. big time (IMO). You should also know that the java compiler replaces plus sign string concatenation with in the bytecode. Only in very specific scenarios (frequent loops and such) it actually makes a different to explicitly use . I would say that as a rule of thumb, string concatenation should be done with plus sign unless you know you have a loop that iterates over thousands of items or is called hundreds of times. 2) but that is not enough. even if we replace with plus sign string concatenation, this statement 

Do not use literals and constants in the code. Each literal should be defined as a static final variable. The reasons for this are 1) it gives the literal a name and meaning and 2) there is only one place where the literal value is specified, making it easier to modify the value. example: You do not have to initialize all instance variables in the constructor. Some of them may have default values. A new will always have zero attempts so why specify this value each time you create a new instance? The variable is declared as which is an Object and not the primitive type. This means that each time you assign a value or compare the variable to a value, there are additional actions that need to be done to access and modify the variable. It is more efficient to declare the variable as the primitive type. 

now you can have the take a type in the constructor and fill the properties by itself. this makes the calculator process clearer: 

properties: , , has one or more ies This relation is represented as optiojal: is favorite of multiple . this will allow the service to show a other s with similar interests (perhaps can set his/her as public or private) This relation is represented as class is responsible for maintaining its inventory of copies. that includes adding and removing copies. it should be able to answer if there is an available copy for rental for given period will return null if there is no available copy the actual rental operation is done on a ! 

Also, it is bad practice to modify a collection while you are iterating over it. Make a new list and populate it, and just assign the reference at the end of the method. 

A dependency injection container, like Spring or Google Guice, requires either the use of configuration files or annotations to instruct the framework where and how to do the instantiation and injection of the singleton instance. Also, inversion of control means exactly that - you lose control of the life cycle of your singleton. this can be confusing. I find that in small programs, this is an overkill. Sometimes, you just need the good old fashioned and simple singleton and move on with your life. So, on the subject of singleton: The classic double check mechanism that you utilized in the method is considered broken nowadays. The reason for that is that modern processors use sophisticated branch prediction and memory cache algorithms, and in some cases execute commands out-of-order all for the sake of performance. this can result in failure of the purpose of the singleton pattern, namely, creation of more than one object. There are two solutions for that (besides using DI framework, that is): 1) static constructor I see you already defined the variable as static (by the way, in the classic singleton pattern, the variable is defined as an instance variable) so why not use the static constructor feature to initialize it? 

name It took me some time to understand that this class represents a complete CSV line. In my eyes, translates to single cell. Why not or use the term from RDBMS or the term from old times' file processing 

all switch-case statements are the same, just invoked on different variables -> put the statement in a method and pass it the variable to query. Moreover, the whole switch-case statement can be replaced by getting the index of the int-location from the String "ABCDEFG": and you can catch the to detect out of range int value you already use a collection to put locations. instead of keeping three separate set of variables for V/H and the rest-> use a colection for these as well. 

If you have getter and setter methods, then the instance variables should be declared private. grouping the declarations of the variables (either at the top or bottom of the class) helps with readability (the reader doesn't have to search for the variable among all the methods) 

so I took these differences as arguments to the new method which contains the similar part of the if statement with the arguments specified in the correct places. I also beautified the code a little: no need for parenthesis in condition and broke down the two outer if statements, allowing for an construct. The end result is below 

MySQL version 8 supports common table expression. If you want to differentiate between the three sub queries, use a column containing literal: 

while it is convinient to use , under the hood, the method will perform all the steps that are required to match an input to a regular expression, including compiling the pattern. since this line is performed inside a loop that reads a (possibly big) input file, you may have a performance issue here. A better approach would be to create a Pattern instance via the factory method and then use a over the input. an even better approach (in terms of performance) would be to ask if a regular expression is required. yuo are testing whether the string is a single letter. This can be replaced by quering the String's length and then quering the contents of the (only) character. Something like