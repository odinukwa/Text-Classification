See this illustrated in the sample below. Accessing container div from DOM BenC re-wrote the code to access the container (i.e. ) only once and went so far as to eliminate the Cat class. If you wanted to keep the Cat class, you could still assign that DOM reference once in the DOM ready callback. I would suggest declaring the variable outside the Class and DOM-ready callback: 

Shared data, HTML, etc. I know you originally wanted to know how to share data between separate pages, and while that question isn't really here anymore and I shouldn't do this, I can't help but want to give a solution to that question. One technique is to store the data separately and fetch it via AJAX, or alternatively have the server side code include it (e.g. with PHP, Java, NodeJS, Python, ASP, Ruby, C#, ColdFusion, etc.) after fetching the data from a file, database, etc.. You could also render the common HTML with such a scripting language and have that abstracted to a single function/template/file/etc. To fetch data with AJAX, there are nice wrappers like the fetch API or libraries like reqwest and superagent. If you were actually using jQuery, then you could use its AJAX functions (e.g. , , etc.). See an example in this plunker using . And the common javascript could be abstracted out to a separate javascript file (e.g. , ) 

I know this isn't a large O.O. application but it would be advisable to separate the functionality that updates the DOM into a separate function - which would be in line with the Single Responsibility Principle. In order for that to work, the promises will need to be returned from the generator function and the recursive function. See the updated code below for an illustration of this. Updated code 

Having been taught to have a few queries as possible, my first thought is to try to help get that code to only use one query. My initial thought is to advise you to add the clause - something like the query below. Warning: Untested code: 

And that function can be bound to the functions for the button handlers using the Javascript function .bind() to create a partially applied function for the parameter: 

I don't remember where I saw it (maybe one of your other posts) but I recently saw a technique for ensuring uniqueness of array elements - iterate over the elements and just return the equality of the current index to the value returned by calling Array.indexOf(). Using that technique here, Array.every() can be used to ensure each word is unique. With that technique, there is no need to count the number of occurrences of each word and hence the reduction can be removed. Thus can be eliminated and can be simplified like below: 

CSS There is some redundancy that can be abstracted- e.g. both and have 6 out of 7 identical lines. Those can be pulled out into a class selector. That way if one of those styles needs to be updated, it can be done in one place instead of two: 

But the question that you asked actually has an answer specific to how JQuery parses the input string to determine selectors. To get the most out of a single call to the JQuery object you can put all of your selectors in a single comma delimited string (if you are performing the same action to all the given selectors). This has the added benefit of much less overhead than calling JQuery many times. i.e. 

I would further reduce the redundancy found in the strings by declaring them (as if a constant) and passing the variable to the JQuery function. 

My final answer is at the bottom with a fiddle, but a little background first: I also think you should use toggle functions instead. It would reduce code repetition. Perhaps something like 

Now when you need to make changes (e.g. adding another option to show when toggling traffic) you only need to make that change in one place. Try it out! 

Ok, now that I have a firm grasp on what you're doing, I think I have what you're looking for. The below still applies in terms of optimizing what you posted, but I think what you want is more along the lines of the following: fiddle 

It still needs some tweaks for your cogs, but I think this is a more adept to the capabilities of the Raphael framework. 

In terms of the module pattern as used in JavaScript- There are plenty of times that a getter is used to access a variable that is otherwise managed internally. This would mean that you would have no need for a setter; in fact a setter in that case would be a no-no. Using a getter for a concept that is not clearly defined within the calendarModule itself could be a little confusing to someone that needs to help you later, or modify your code. But I can't speak to whether it breaks the pattern. Have you considered using the revealing module pattern? I only ask because I think it would be less likely for you to question "am I doing it wrong" because the getter is itself a defined part of the module. I could be grossly misinterpreting that however, but it is how I have interpreted it and practiced it for some time. 

Next I would swap out the unreliable for a recursive . But that is not necessary for this experiment. I use plenty when whipping up little tests such as this, it's a bit easier to set up. Additionally, have you tried using a Raphael set to perform your animation with only one animate directive? It might speed it up a bit. UPDATE: Upon reconsideration, I realize why it would work. Even though you are overwriting the paper variable, the object has already been added to the DOM. This is not undone when the variable is modified/removed within JavaScript. Ether way, you would want to encapsulate all of your elements on one paper if they are related/displayed-near-each-other UPDATE: A further consideration. What I like to do is first create the Raphael objects so that I can access them by themselves 

which can eliminate the lines for initial assignment (i.e. ) and re-assignment (i.e. ) at the end of each iteration. Note that const is used there because the value is not re-assigned (within the context of the loop). These functional JS exercises are really helpful for those who want to learn more about using functional programming in JavaScript. Single assignment for adjacent squares Correct me if this leads to a difference in functionality but the array could be set with the following line: 

While it only saves about 2 keystrokes, it is essentially like removing an clause from an statement. Variable declaration The declaration of the timer variable is within the true block of the statement. While hoisting allows the variable to exist throughout the function, "it is recommended to always declare variables at the top of their scope"2 and then assign the value later (e.g.. 

Bear in mind that the functional approach would likely be somewhat slower because a function call is added for each iteration, but for a small number of controllers this should be a negligible difference. If you would like to become more familiar with functional JavaScript, I recommend these exercises. Use partial(-ly applied) functions for callbacks Instead of making a closure just to call : 

That way there is only one call to String.replace(). While it might not save much processing time or power, it can at least make the line shorter and hopefully easier to read. In addition, if there was a need to add the attribute to additional tags, that tag name could easily be added to the expression in the capturing group. 

Notice that the last 3 elements of the series data array are a , when really the first of those should be a and the other two should be a , since there are only 4 records: 1 in September and three in October. This is because the s of the statement do not contain , and thus whenever a line matches, every case after that is executed (and thus the associated counts for subsequent months get increased). Making the code work The answer by Your Common Sense is good, though there is still one thing that could be improved. Instead of using a operator and the string for the on the dateoforder, use an equals operator with . Refer to this answer for a detailed explanation of why that should be used. 

Feedback As was pointed out in other answers, the (outer) array isn't really associative- it is numeric, and the sub-arrays are associative. And I agree with the point in mickmackusa's answer - just use along with to simplify that function. The within iterates over the keys, which will be numerically-indexed and thus it is pointless to create and increment it manually. It can simply use the associative syntax (i.e. ). Suggestion Simplifying array generation Perhaps the code used to add values to is synthesized for this post, but it could be simplified, using a or even , combined with to iterate 7 times, plus to generate the spelled out numbers: 

Obviously that block of statements and blocks would become quite large for 10 different fields... That could be compacted by defining a mapping, such as: 

There is no need to expose the user of your program to unnecessary details regarding how you intend to parse his input -- he just wants to play FizzBuzz; he doesn't care about how you design or implement your program. Now let's look at the method . It is already very evident from its name that the method runs Fizz Buzz using inputs provided by the user, so there is no need to include 'FB' in the variable names -- it is redundant, and does not convey additional information. So I would suggest that you instead rename 

Notice that you can pass a value of type directly into . :-) I hope these comments are helpful. It is very nice to see such good effort from you; I am sure that you will keep getting better. :-) 

@Heslacher has given some good suggestions, so I won't repeat what he wrote. Here are some additional comments: Firstly, I would encapsulate everything in your wrote in into a private static method named . Inside the method itself, there will be a single line of code: 

But if (for whatever reason) you do want to keep a record of all the random indices, take note of @Loki Astari's suggestion that you should initialize a vector with size instead. The general idea, which is applicable regardless of the programming language you use, is this: In programming, as far as possible, avoid magic numbers (i.e., values with unexplained meaning) and hard-coded values. It will make refactoring far easier and less bug-prone. E.g., if you ever want to change the default value of to something other than 15, you will not have to dig inside the method itself to change the array size of . It is inconvenient when you remember to do so, and troublesome when you don't. You want to write your code in such a way that you are not required to read through the entire method whenever you want to change your input values. Second remark: Always favor using informative names over adding comments. E.g., why is the second parameter named ? Would it not be more reflective of the purpose of the method if it is named, say, instead? If I am a first-time caller of this method who has never read your code or comments, I would find the parameter name uninformative/misleading. But why should I have to read your code to understand what is going on? I just want to get a randomly generated string -- I don't care how you do it; I simply want to know what information I have to provide, and you should make things easier for me by choosing informative parameter names. Similarly, would be better named as , and so on. Choosing good names will significantly cut down your need for writing comments. As far as possible, try to make your code read like regular English. This is how I would write your code: 

Firstly, as @Loki Astari pointed out, you can do just one iteration to both generate a random number and retrieve the character located at the index specified by the number. It means that you can get rid of the array entirely: