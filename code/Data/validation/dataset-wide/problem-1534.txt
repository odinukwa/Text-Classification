This is just an example of how it can be refactored, to give you an idea. It can still potentially deadlock (for example if you call offline and dispose at the same time from different threads) so it requires some tweaking depending on your requirements. method is somewhat hard to read, it should be splitted into sub-methods. BartoszKP makes a perfectly valid points as well, check his answer, if you haven't already. 

But I have to question your design. Why do I have to input (and memorize?) a 10-key sequence where every key means something and the order is important? Sounds like a really poor user experience. I feel like it is not the way to go in modern applications, iddqd or not. Edit: I forgot, that does not preserve insertion order. So if order is important, you should stick to (your original approach). 

1) The library you are trying to use clearly does not fit your requirements. So why force it? Aren't you essentially just calling: 

or something along those lines. Or you can use -based or -based api instead just for the kicks. But the point is: 

Those delegates inside methods are cool and everything, but I think you are overusing them a bit. For example, compare this: 

A strange thing to ask, given that you modify your collection yourself inside method. Consider not purging your collection during enumeration, and regular loop will throw alright: 

Instead of exposing your collection via property, you should implement appropriate interfaces on BinaryHeap itself, such as (or , or w/e depending on what you want to expose) and make the underlying collection . This: 

You should also consider encapsulating your resource loading logic to separate class (or classes: one class per resource type). Handling textures and sound in single method looks messy. Single resposibility. EDIT: If you have to stick to the library of your choosing, then you should just use single output stream. 

- those are not very descriptive names for generic arguments. Perhaps you can come up with better naming. - i'm not sure i like here. It might hide bugs and misusages. I think that strong cast is better in that case. - i don't see any reason to use factory method. 

I don't think there is a way to do this faster. You might want to experiment with unsafe shenanigans, but I doubt you'll get a significant performance improvement if any. Since your strings have varying size direct mapping is extremely unsafe: 

Then i would create a custom user control wich will display such tree using this interface and specidied s (after i will fail to make wpf TreeView work as i want it too yet again -_-). This is a tricky task with plenty of pitfalls, but i think its possible. At least that would be an approach I'd try first. 

You should probably add restriction on , since it is used by method. Also this check: looks like an overhead. does nothing if types match. For example, check out sources: 

You should probably remove empty braces inside attributes. => . This loop is very hard to read due to how you use offsets. 

is inefficient. If but it will start to constantly re-sort while it is waiting for the next chunk, eating up single CPU core. Instead your working thread should be in waiting state until the next arrives. 

postfix is normally used to indicate an abstract class. Might want to remove it from your command class, since it is clearly not abstract. I'm not sure where this whole thing with lazy initialization is coming from (it is not the first time I see it), but it makes no sense to me. What's the point in lazy initialization for commands? Just use regular readonly property: 

Disclaimer: I am biased towards singletons. I think it is an anti-pattern, that has no place in modern C#. First, here is a great article on how singletons become a disaster when you try to unit test a code, that heavily relies on them. Your case is even more complex, because you also have to initialize additional parameters. And you can't change those. So you can't test with different "environments" unless you try to bypass your own exception with reflection. I would just register non-static class as singleton inside IoC container, and be done with it. It will solve all your problems: 

To begin with... what's the point? I mean what is so bad about having a dependency on standard .Net assembly? It is already installed on the machine as part of .Net installation, so this dependency does not affect the size of your app. Am I missing something? This design works under fairly naive assumption, that the app will not change in any way as the time goes on. And it might be the case for your particular app, but it is not the case in general. Imagine I am using your library, and I want to subscribe to event. What should I do? Should I call you at 3AM and ask you to also override this event with keyword? Will you do the same thing for every single event (or property) found on ? Will you then test every single interaction, to make sure you did not break standard behavior? If you are not willing to take this all the way - don't do it at all. I don't even want to begin imagining all the potential pitfalls. What will happen if someone sets for your new event? Will your base event keep going? What will happen, if I have a style for regular button that uses and I want to override this setter for your button's style? How is it going to work, will I have two event handlers as a result or just one? Etc, etc. 

Maybe I misunderstood your intent, but looks a lot like an overly complex (API-wise) event aggregator (aka message hub) implementation. Even though different implementations have different flavors, normally when writing one, you should try to let go of keyword. For example, the most basic API can look like this: 

There is a lot of copy-pasting in method. You should probably have a method to query single value. For example 

Or just add braces (that's what I would do). is probably not the best name for a property, its too generic. Maybe or would do a better job at explaining its purpose. It would be nice to have some control over which properties are deserialized. You know, similar to how you can use attribute to skip a property during xml (de-)serialization. Unless what you do should be completely obvious to anyone working with Azure, you should add some basic documentation. I am not familiar with Azure, and to me it is unclear what problem you are trying to solve, why do you solve it using inheritance as opposed to using separate non-abstract binary serializer or wtf property is used for. You might want to explain some of those things in your code using xml-documentation. 

for two reasons. First: it doesn't have a third value for "empty" cells. This leads to huge amout of all over the place. Having a third state will remove those and imrove code readability. Second: i do not like and as member names. I cant say i do not understand those, but there is something fishy about this naming. :) I think and would be much better. Why throw an exception? Why cant you remove the setter? Is this property supposed to be virtual? 

Personally, I hate deciphering Regex expressions. So I would not use it unless necessary. You should be able to split string in to lines using method just fine with . Also is basically , is it not? methods IMHO will look better if you add a couple of local variables: 

I guess the bottom line is: if this class helps or have already helped you debug the problem you were having, then good for you, well done! :) However, in its current state I would not recommend using it in production code on regular basis. Multi-threading is already hard enough to get right, your class makes things even harder. Instead I would recommend following mr.eurotrash's advice. Refactor your code, so that you have only one access point to your shared resource, and then lock the entire thing from the inside. For us, mortals, in most cases this is the only bulletproof way to synchronize access. 

The initial creation looks thread-safe at first glance. I don't know why you your semaphore instead of just waiting synchronously with but I don't think it matters much. The updating part however is not thread-safe. Any number of threads can come in between: 

You do need polymorphism even though you say you don't. There is no pretty way to eliminate those almost-exactly-the-same loops, unless you extract a common interface. In your case it should be easy to do. 

I think there should be a separate method that checks, whether two animals can breed, that you would call before calling method. In this case throwing exception if something goes wrong makes more sense. 

You should avoid using statements. Not because it took me a minute to recall what syntax even means, but because makes it extremely hard to follow the execution flow. Cases where makes code more readable are rare, and yours is not on of those. Just use another (or ) loop instead. is a poor name for a method, because it doesn't say anything about what sort of calculation it performs. It calculates distance you say? Name it then. Oh, wait, it also calculates angle! Maybe then? That doesn't look right... Which is an indication, that you probably need two separate methods: one to calculate angle and one to calculate distance (related to SRP). 

I am no expert on malicious code, but I guess the only way to know for sure what works best is to run some packet analyzer software on both client and server, and see for yourself. I feel like your implementation uses too many threads. loop probably hurts more than it helps. It speeds things up only if you execute a sufficiently complex task on every iteration. Sending 1 byte over network is not complex at all. Try replacing it with regular loop. It is also unclear what in stands for. Why it is and not, say, , and why you should "sleep" at all. If it is required, then maybe it should be a property of your session, and not a hard-coded value. Clients implement , so you should dispose them at some point. I also don't see why you should create a new client on every iteration. Can't you re-use single instance? Another obvious thing to try is to run multiple clients on multiple threads. Maybe it will work "better". Maybe not. P.S. As for your thread safety concern: see SO answer. So no, calling or in parallel from different threads in not thread safe. 

You don't show enough code to give you accurate advice on design. But from what I can see, class has a bunch of problems: 1) It has two huge static dependencies that are not immediately apparent. Hard to read, hard to unit test. 2) method is synchronous. IMHO, network-related code should never block, and it should not be consumer's responsibility to call on thread pool. It's your connection implementation that should provide asynchronous api. 3) Since there is a , I assume there is also , , , etc. Having one method per request will not be that bad for small protocols, but it scales poorly. 4) Storing password in memory in plain text is a security vulnerability, but if the attacker gets access to your memory, you are probably screwed anyway. However sending it in plain text over network is much riskier (since it is much easier to access your network traffic than your memory). Make sure to either encrypt it before sending or to use an encrypted connection (or both). 5) method looks like something, that will be copy-pasted over and over again across other implementations with very little modification. Which is a sign of poor design. From your explanations it is not clear why can't you have a message-based api, that does not know and does not care, which type of request you are trying to send: