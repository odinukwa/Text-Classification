Now does not ever update the game state directly; it just returns a map of things which have changed between the previous version of the state and the current one. merges the new state and the old state, replacing the values which have changed and leaving alone the ones which haven't. This kind of refactoring could also really clean up Your use of a bunch of chained definitions in a is something I've seen in lots of other Clojure code, and it is purely functional, so I wouldn't worry about it. When you calculate from , you're not doing IO, you're not destructively updating a variable, and you're not breaking referential transparency. Another thing Hague suggests is keeping around only the minimum amount of state. He advises figuring out which pieces of data depend on other things, and calculating them as needed, rather than storing them. In your code, you could do this with ; instead of an atom that contains the current power, you could make another function, . The Enterprise state could contain a base power level that you pass to , and then the function can calculate the actual current output, returning a lower number if damage has occurred, and maybe a higher number if you've got some kind of secret Romulan power generator installed. This would also clean up a bit. Here's a slightly cleaner version of as an example of all the suggestions I've made (except that it still has the global game state): 

If you run that code, it will print "File opening failed". Of course, that's not really what happened; what happened is that exceeded the maximum recursion limit and the code threw a . But the clause is misleading us. Now imagine that this code is much, much larger, and also you didn't write it. It could take days or weeks (depending on complicated the code is) to figure out that the code is lying to you. 

Your original code contains an apparently correct implementation of Euclid's Algorithm, as do some of the other answers, but it seems you weren't sure if the algorithm was correct, so I'll spend some time to explain it a little. (aush gives a very terse C# implementation of the algorithm in his answer as the private method , which is great for writing the program, but not so good for understanding the algorithm.) I don't know C#, but I took number theory at university, the first half of which was more like "Applied Euclid's Algorithm", so I'll summarize the idea behind it a little. The idea is that, when you reduce a fraction into lowest terms, you're dividing out the greatest common divisor of the numerator and denominator. In your example, \$ \frac{3}{4} \times \frac{8}{15} = \frac{24}{60} = \frac{2\times12}{5\times12}\$. Euclid's Algorithm can find the GCD of the numerator and denominator. Think of writing out the numerator and denominator as prime factorizations: \$\frac{24}{60} = \frac{2\times2\times2\times3}{2\times2\times3\times5}\$. Euclid's Algorithm finds the number whose prime factorization contains all the prime factors shared between the numerator and denominator, in this case \$12 = 2\times2\times3\$. When you divide out the GCD, you're dividing out all the shared prime factors: $$\frac{\frac{24}{12}}{\frac{60}{12}} = \frac{\frac{2\times2\times2\times3}{2\times2\times3}}{\frac{2\times2\times3\times5}{2\times2\times3}} = \frac{2}{5}$$. There are no more shared prime factors, so the fraction can't be reduced any more. In this case, the numerator and denominator are both prime and are unequal, so it's obvious there are no more shared factors. Other times, you might have two composite numbers that share no prime factors, e.g. \$\frac{8}{15} = \frac{2\times2\times2}{3\times5}\$. The idea behind Euclid's algorithm is this: if we have some numbers \$a\$ and \$b\$, both integers, and \$a > b\$, we can divide \$a\$ by \$b\$ and get two numbers, a quotient \$q\$ and a remainder \$r\$ (remember back in grade school when \$23 / 11\$ was something like \$2 \ \mathrm{remainder} \ 1\$?). In other words, \$a = bq + r\$. There's a theorem that if some number \$d\$ is the greatest common divisor of \$a\$ and \$b\$, then \$d\$ is also the greatest common divisor of \$b\$ and \$r\$. So we calculate \$r\$, and then we feed it back into the algorithm as the new \$b\$, with the old \$b\$ as the new \$a\$. Eventually, we'll get a remainder of \$0\$. The value of \$a\$ on this final iteration is the GCD of the original \$a\$ and \$b\$ that we started with. (All of this can be proven, but I won't do that here. Here's a page that both describes the algorithm in more detail and gives a proof for it.) I hope this answer and the pages I linked can help you understand that the GCD method does work, and why. Here's a link to another page that also explains it in terms of code. The code is in C, but shouldn't be too hard to understand if you know C#. If you're interested, you can also use Euclid's algorithm to compute the least common multiple of two numbers, which could be useful in the addition and subtraction methods. From Wikipedia: $$\mathrm{lcm}(a, b) = \frac{\vert ab \vert}{\gcd(ab)}$$ So you could also write your addition method something like this (this is the first C# I've ever written, so there might be some errors): 

At the very least, I would have my methods return . Then you can chain calls like in Ruby or JQuery; your main can be: 

There's a precept in Python, EAFP, which stands for "Easier to Ask Forgiveness than Permission". What it means is that Python programmers tend not to check things with conditionals, like doing . The style in Python is more to assume everything is good, and let the program throw an exception if it's not good. In this case, if there's no such file, you throw and complain. Sometimes you do want to ask permission, but I think this is a case where it's easier to ask forgiveness. This is something I also see elsewhere in your code. It's good to be safe, but in Python, people tend to really lean more heavily on exceptions than on explicit conditional checks in most cases. The case where you do use a conditional is when there are multiple possibilities, all of which are valid, and you need to figure out which case you're in. But if something is wrong or invalid or unexpected, like the passed file name not being a real file, I recommend exceptions. (By the way, you don't need in your clause. What does is skip over any code that comes after it to go on to the next iteration of the loop. In this case, there is no code after , so it would always go to the next iteration anyway.) In both and , you have some code like 

Finally, you asked about the data format. Which data format works best really depends on how much data you have and what you plan to do with the data. For instance, I wrote a script a while ago that worked with a CSV file with five million entries, extracting around 48,000 of them. It took about two and half minutes to finish, but for the kind of batch use it was intended for, that was fine. I could just collect the results into a new file and use them. If you intend to do frequent lookups, it's hard to beat a relational database for speed. Python has built-in support for SQLite3, a lightweight relational database. A simpler option that avoids extra software is Python's module; see $URL$ If you intend to pass the data round over a network, JSON is a good choice, and you can store the JSON in SQLite or Postgres or MongoDB or numerous other places. There might be cases where XML is the best choice. It really all depends on what you want out of your data store. There are lots of cases where CSV files are perfectly fine; they have the advantage of being human-readable and very easy to parse, for instance. 

In your main program, you can catch the rethrown exception and print its message. This is better than a version without a / clause because we can add information to the exception about what went wrong to make it easier to debug. This is better than the version with a print statement because callers of the method can decide how they want to deal with this, instead of being forced to have a print. It's also usually considered bad style to use a bald clause. For debugging, just let the exception stop your program. Printing is not very informative, and doing so can also mask the real cause of bugs. Look at the following highly exaggerated code: 

Your capitalization convention strikes me as odd, not just for Python, but for any language I've ever used. Not only is it hard to read, but things cased LIKE_THIS are usually constants in Python, so this usage will confuse Python programmers. Many other things about your code formatting are also confusing or unconventional. Please do check out PEP-8. Your function is quite long. I'd recommend trying to split everything under into its own function. Also note that the comment marker in Python is . The syntax is for strings. Python allows you to put one of those as the first thing in a function or class, as a documentation string. You can then read documentation interactively on the command line. If the triple quoted string isn't the first thing in a function or class, it's just a string literal that never gets assigned to anything and disappears. As a personal request from me, please don't document your code like this. The performance hit is probably negligible, but it's just weird and wrong. Stick to a doc string at the start of a function or class, and regular comments for things that aren't going to be part of the code. It's more common when you have a script you want to run from the command line to write it like this: 

For the most part, I don't believe in catching exceptions unless you're going to do something about them. But re-throwing with more specific info is a perfectly valid thing to do. Also, I don't like to have functions other than printing to the console. I'd prefer to re-throw with a new message, catch the exception in , and print the message. Related to this, I see the following code in : 

I wrote an implementation of the Karp-Rabin string matching algorithm in Java 7, based on the discussion in Section 32.2 of Introduction to Algorithms (CLRS). Clearly, I need more experience with numeric programming, because I spent two days wrestling with overflow issues and floating point error, but I believe it works now. Of course, anything goes, but I'm especially looking for feedback on the following points: 

It's a bit shorter than . (I like Java well enough, but it sure can get long.) Here's the entire code sample with my suggested changes, including the one that eradicates and boosts performance that Chris Hayes suggested: 

I translated the given C# code to Java, and timed it on my machine using the Unix command. It ran in 0.161 seconds. Your original code ran in 1.023 seconds. Here's the Java translation of the C# code: 

I've assumed some parts were moved into helper functions. In particular, I'm envisioning as a single function which takes into account everything that affects the power, and the whole part that calculates the effect of the Enterprise's attack on the Klingons has gone into . I once again rearranged the code to return, essentially, a diff between the old state and the new state, which can be used to modify the global state at a higher level. I find this a bit cleaner and more purely functional than using directly inside the function. I just recently discovered the function myself. It's exactly the same as , except it automatically removes from the sequence, so you don't have to do . There's also to replace . At the very highest level, I recommend finding an alternate scheme for the game state. James Hague says "In a functional language, the worst thing you can do is create a large 'struct' containing all the data you think you might need for an entity", and argues why, in Purely Functional Retrogames Part 3. His performance argument is not totally applicable to Clojure, because of structural sharing and transients, which the compiler uses to minimize copying and allow some mutable state. His arguments about flexibility and clarity, though, are worth considering. Using a global game state is inflexible because I have to figure out before I write a single function how I'm going to store that state, since I have to bake how I access it into every function. With your current code, if you decided to change from using an atom to using a ref, or a record, or just a plain map, or a Java class, you'd have to go through and change every single to something else. The state access API I suggested (the and macros) helps this a little, because you can just change those macros. But using a global game state is also unclear, because seeing that a function takes the game state as an argument gives me no insight into what it's actually doing with the state and what parts of the state it really needs. When I see the call , I gain no insight from the arguments into what does, whereas I do get some insight from or . My first thought for how to represent data would be something with deftype or defrecord. These are lean, vaguely object-oriented structures which can be used much like maps, but can also implement protocols, which are sort of like interfaces in Java. I might have a record which holds essential state like energy and damage, and implements a protocol that contains various functions which calculate other pieces of state, like power, the raw damage its weapons can produce given the current state, and whether the ship is capable of going to warp in its current condition. The Enterprise would be a single record of the type. I might also have a record that implements the protocol and the protocol, which would create functions that only enemies need to have. That way, we have functions that take or instead of just . 

This is a really cool project, and I don't think the non-functional aspects are as problematic as they might seem. One of the things that makes Clojure so flexible is that it lets you be imperative, or even object-oriented, when it makes sense. I think most of the messiness in this code comes from insufficient generalization, rather than being imperative. If you do want to make it more purely functional, James Hague has written some really interesting essays about game programming in functional languages (he uses Erlang, which is even more purely functional than Clojure); the most famous is Purely Functional Retrogames, where he takes apart the process of implementing Pac-Man in Erlang in a purely functional manner, without passing around a "game state" variable. He also argues in Functional Programming Doesn't Work (and what to do about it) that even in a purely functional language, there are certain situations where an imperative "pressure relief valve" is extremely useful and that we shouldn't contort ourselves trying to avoid those. We Clojure users have it good here, because Clojure has high-quality imperative pressure relief valves like the reference types. I've never written a game in Clojure, but I'll try to offer some suggestions based on general principles and my understanding of Hague's advice, starting at a low level and moving up. In general, I think you could clean up your code quite a bit if you had more small helper functions. For example, I would put the calculation of in into another function: 

I feel there are other places this code could be tightened up, but without knowing what it's supposed to do, I don't want to suggest anything that misses the point. 

I ran your code and messed around a little with it, and it works pretty good. You also have a pretty cool idea here, that I might have to steal next time I do a TKinter GUI. As far as high-level design, I agree with your decision to have each entry line be its own object—it's much easier to think about than the other approach you described, with the class directly managing the TKinter objects. You've added enough behavior that these things aren't really the same as their constituent objects anymore, so it makes sense to make a new class that deals with that. I don't really like your list approach, though. It looks to me like you're doing parallel arrays, something that gets used in C a lot since it doesn't have a real dictionary type. You rely on the keys and values (entries) being at the same position in two different lists. Normally, I would prefer dictionaries. If order is important, you can use the class, assuming you're using Python 2.7 or above. (It looks from your TKinter code like you're using Python 3.) To me, an ordered dictionary feels cleaner and more Pythonic, and there's no danger (however remote) of your keys and values getting out of sync. (I say this as someone who spent a year coding all my dictionaries as parallel lists because of the habits I developed after taking C++ at university.) As I mentioned in my comment, I have some issues with the way you've named things. Per PEP-8, the standard is to use CamelCase for class names and snake_case for functions and methods. I realize that is horrible, though; in Java they would write , but PEP-8 prefers that you keep fully capitalized acronyms fully capitalized. To get around this, I'd recommend just changing the name. If I'm reading the code right, is a container for instances, so you could call it something like . I'd also recommend changing . It's a pet peeve of mine, but I hate it when people name things with "my". It seems to be a Perlism; in that language, you declare variables with the way Javascript and Scala declare them with . I dislike "my" because it makes names longer without really adding more info. Really, what does have that doesn't? As far as I can tell, two extra letters. Finally, I'd recommend a cleaner way to manage conversion functions inside . What you have now is basically a giant switch statement, which somewhat defies extensibility. Functions in Python are first-class, so you could instead store your conversion functions in a dictionary. I tried it out, and it looks like functions are even hashable, so you can use them as dictionary keys if that's what you need. Your dictionary values could be tuples or dictionaries which give the settings of variables in each case. Let me know if you need to see an example, and I'll edit to add. This approach would also strip out a lot of code in your function working with . This is good, because it's usually considered better style to keep your function lean. If you need to do something complicated, you can write helpers (which would be private in Java) and call them from . It could use a little cleaning up, but you've got some pretty well-designed code here, and a good idea for a helper class to speed along GUI development.