Code that form the same command but are on a different line should be 8-spaced, or 2-tabbed. Java Naming Conventions specify that variable should be . 

You have some lines with spaces, some lines without. Choose a style, and stick with it. I suggest the spaces version, because it is easier to read... Spacing here: 

Though, as mentioned in the Bugs section, it doesn't really work. In Hmm... Here you don't do ... Also, here: 

A couple of problems: Line 1: Space between and Line 1: No extra spaces before and after Line 1: Space before brace Lines 4-5: Should be combined Line 5: Space before brace Result: 

Coming from a language without the ?? operator, I find this even easier to quickly read and understand the intent of however I recognize that is probably just because I'm not used to reading ??. 

Regarding documentation, I have found Eclipse and other tools to utilize the following style of doc-blocks. The @return is especially useful for code-completion of methods available on the returning object in my IDE. Documentation tools tend to have built-in support for other tags like @author as well. 

First off, as a disclaimer, I don't code in C/C++, so I may critique some common practices that are considered acceptable as it's the norm. Nevertheless, a few things stand out. Comments Comments should be used to describe why something is being done. The code itself should be self-descriptive as to what it is doing. 

Rather than moving the balls around, we can move buckets. That is, I will mark 3 balls with an 'x' and that ball and the balls to the left of it (until the next 'x') are part of the bucket, (since all balls are in a bucket, the right-most ball must be marked. So we get: 

I make use of an NChooseK function so we can determine how large the string[] needs to be to hold the results from the subproblems which will be carried out at the next level down in recursion. Full Code with Timing Code 

Basically the code is using i,j, and k to mark x's on the balls, and then we get the number of balls out. We don't need to remove any duplicates, since we generated just Combinations, and not permutations. This code works for 3 buckets and n balls. But because of the 2 hard-coded For loops this won't work for more or less buckets. Using Recursion to Infinitely Nest the For Loops The real difficulty here is that each possible combination needs to be written as a line on the console. This means that our recursive function needs to be able to return multiple lines, and add to each line as the recursion comes back. The Base case of the recursion is easy, if there is just 1 bucket, put all the rest of the balls in it. Otherwise we loop through the number of balls we can put in the first bucket, and recurse with a smaller problem size, then add the first number of balls to each of those results coming back. We use a recursive function which is called by a helper function so that we can move the timing code into a separate place. Code to solve M buckets, N balls 

Depending on the size of the application, it may make sense to take this one step further and take advantage of object-oriented programming. 

Part of the goal for using the Repository pattern is to separate the storage from the domain. By passing the IDataReader in to a Foo object, I feel like the domain gains too much knowledge of the underlying storage mechanism. So, between the options listed, I prefer setting the object's properties in the Repository. That being said, if the object doesn't make sense without a certain property, it should still demand it during its creation. However, even in this case, the Repository would still be responsible for setting all the properties requested. 

This is one of the cleanest code I have come across in a while. Congrats to your lovely, well-written code! Just some points: 

I don't see the initialization of ,, or . If they are class variables, that's fine, as long as it is meant to be a class variable. If they are outside the method just so that another method can set the values and have the current method run, then it is not okay. If they are class variable just for the method, have them as method arguments. Here: 

After all, who wants to do that? I don't see any point in making a separate class for finding the deepest node int the tree. Why not just put it under one class? There is a better way to do it with recursion: 

Assuming you're protecting yourself from SQL Injection and the like, there are just a couple things that stand out to me: 

For example, could this variable be renamed to make it self-descriptive? Perhaps . Perhaps something else that would eliminate the need for the comment. One File Per Class Generally speaking, you want one file per class. I also believe it is common practice for C/C++ programs to have one file for the header and one for the code for that header. Maybe something like and , as well as your . Scope Why are your Tpacket_list variables protected? Is there a reason they aren't private? Also, list_head is declared in main, then freely accessed as a global variable within the Tpacket_list class. Rather than do this, it is considered better practice to use Dependency Injection. Pass this variable in to the class that requires access to it. It will make your code far easier to maintain later. It will also open up the possibility of unit testing your class. Random Thoughts 

I think it is worth mentioning that for large data a different approach could be used, since keeping exact frequency counts of words is too time consuming. Streaming Algorithms like "Count Sketch" makes a single pass over the data, uses low amount of space, and based on the amount of space you allocate to it, can guarantee to get the Maximum Frequency Word with say 99% probability. Algorithms like these are used every day in routers to approximate which IP addresses are requested the most frequently, given that routers do not have enough memory to store everything it sees and only sees each IP address once. For large data, I would recommend this approach. Not sure if 10 GB of text counts as big data for this problem though, however if every word in the file was unique (except one word which occurs twice), you probably don't want to try storing them all in a Dictionary :p. As an aside, Multi-threading may be able to help give a speed-up, although pulling data from a single .txt file seems intrinsically IO bound. It seems possible to pre-partition the .txt file into parts for each thread to process independently, using "unsafe" code with pointers directly at the partition locations in memory, and writing the line parsing yourself from the bit representations of chars. I doubt the above would be worth doing in C#, since you might as well manage memory as well using C or another low-level language for that extra gain in speed-up. Multiple threads would exhibit higher speed-ups on certain processors like the intel i7 which has 3 channels to memory, and this is a highly IO dependent task. If it happened to be hundreds of thousands of 10 GB .txt files across a cluster of computers, I would consider using an approach utilizing MapReduce on a distributed file system. 

Anything in the square brackets, if not said by the player, will be said by AI. No matter how you play, the AI will win (as long as it starts). Concerns: 

The separators will be the upper limit of the bucket right before it; and the uppermost bucket will catch everything that is larger than the largest bound. Now for the actual code: 

Your code at the current state looks very slow. Partition sort (or quicksort as it is generally known) is supposed to be faster than Bubble Sort. With my quicksort and bubble sort code, here is what I get for a 1000-element array: 

In your setUp() method, you call several other tests to prepare future tests. With unit testing, you want to keep the tests separate. In your code, if testNewObject2() fails, testGetSuffix1() will also fail, even though it is unrelated. To reduce code duplication, use private methods for specific needs. Maybe something like this: 

Also, I would add that some very notable programmers have emphasized the rule of a single assertion per unit test. As such, give some thought to this as well. Lastly, I would recommend being a bit more descriptive than object0, filename1, etc. Try to give more meaning to the variables. It'll help immensely in 6 months when you look back at your code and sit there wondering what the purpose of this or that was.