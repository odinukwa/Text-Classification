I don't see anything in there which forces the use of TLS (HTTPS). It could be that you're certain that the page can only be accessed over TLS, but even so it's good practice to double-check. The reason for using TLS on login pages is that it prevents the password from being sent in plaintext (e.g. readable by anyone on the same wifi network). If TLS just isn't an option, you can at least use HTTP digest authentication. MD5 isn't considered particularly strong any more, but it's better than nothing. See Apache's mod_auth_digest. As a bonus, you can replace your session include file and login page with a trivial password file and a couple of lines of Apache config. 

I agree with the other existing answer (by R Sahu) that is not a great option here, but I disagree on the best option. In my opinion, since the only use of is to compute powers of ten, it would be best to simply compute an array of powers of ten from to the largest one you'll actually need, which is the length of the input plus or minus one. I would also consider whether would make more readable. 

Enough depends on your requirements, but the answer to the question "Is it as efficient as it could be?" is "No". has to shuffle along every later element in the list. In the worst case the random number generator will return a long string of 0. The standard solution is a swap. 

That's a pretty concise routine there. If you had to change it, I would add methods to parse the user input so now your program logic is less nested and we get back to the good old principal of each method having a single purpose. Normally in a simple app that has a menu structure I would say use case logic instead of if statements as this will allow you to easily extend the options later, but your cleaver use of the dictionary of functions does away with this altogether. 

See my response to question 1 from a purist point of view your Value Object is a complete package, it has a dependency on Currency, but is easier to lock down with unit tests and to distribute in a utility assembly for reuse. It's up to you to evaluate the cost of developing this solution and refactoring existing code to use it. Certainly follow the advice from @t3chb0t, you've gone to this much effort, implement your own contract definition for the response from CalculateDenominations, a key value pair response is too ambiguous for users know how to use the response, it's the missing bit of "self" documentation. 

For mutable types it's only at the point of execution that the validation matters, the code that interacts with the instances of this class should be free to instantiate the object and react to its state at a later point in the execution. It is hard for example to check the state of a Value object if we failed to create the object in the first place. 

Here are some minor suggestions in addition to t3chb0t's: Using var could easily be and not lose any readability at all. Nesting All that nesting can sometimes make it hard to follow scope. In some cases you might choose to flip your if-statements and return early. This doesn't work perfectly for all cases but I think it would work just fine here. would become and now your entire try-catch is no longer nested further to the right. 

I probably got the purpose of the magic numbers wrong, but I think you get the point. Make them have a meaningful name. Worst case scenario you give them as good of a name as you can think of and place a comment above the const/variable declaration describing its purpose. Minor Suggestions 

All this does is make it to where you have to type less, there will be some cases where you won't want to do this. I feel like the best way to know is experience :) Doing something like this might make your code a bit more concise (and therefore readable) since you don't have to create a new ServiceResponse multiple times a function as you are doing now, which is multiple lines of code. Hope these tips help or give you some of your own ideas! 

Disclaimer I just want to start by saying I don't recommend doing this and you should go with unholysampler's answer (or your current solution; You're not saving much code there). I'm posting this possibility to show you what could be and why you shouldn't do it. I was once in a similar place to you and thought it would be great to do something like this, but it was not worth the time or effort (though it was a nice learning experience). "Solution" Okay, so you can technically make a function where you build the expression from a property selector, operator (enum), and value you're comparing to. Downfall #1: Using this method, you'll see that you're just moving the switch-statement you're trying to get rid of. So if your goal is to reduce the number of lines of code this won't help. NOTE: This was written in a unit test class. 

To answer the direct question, the obvious way is to have an method which takes a argument. You'll still have a 30-line call, but you won't have on each line. There are potential side-benefits: 

Thirdly, the outer loop could be written as a , which is more Pythonic. Putting those together, we have 

This can be shortened and probably made faster by using a basic bitwise trick. selects the least set bit of , so 

I learnt the hard way that the problem with using in a URL token sent by e-mail is that certain mail clients (Outlook in particular) will attempt to auto-detect URLs in a plain text email, but will exclude a trailing from the inferred URL, so when your user clicks on the auto-generated link they send an invalid token. I suggest that you change to . 

Thirdly, the commonalities between the and branches could be exploited a bit more. In particular, both search for a two-byte sequence. This could be pulled out into a method which can then be optimised once. Although that would mean losing the from the loop in the case, that's a good thing because it's probably faster to use than to manually copy byte by byte. The particular optimisation which I have in mind is to only look at every other byte. If you find one of the two interesting ones then you can look at the previous/next one. It won't be twice as fast, but it might be 1.5 times as fast. There may also be ways of searching faster by marshalling to an array of a wider type (e.g. ) without copying, but I think that would require C++.Net and unsafe code. The subtlety here is how to handle overlapping from the last call. One option, which you may feel is too tricky, is to push it back into . That would give the following structure (warning: not tested): 

Absolutely, especially with currency where rounding errors can have a real world monetary impact on the user, this seems like a useful thing to know, and it is natural to expect that Currency would already have this attribute. 

Throwing exceptions from the calculation routine is an acceptable method for validation, if this was a Mutable type (not readonly) then I would argue that it would be better than throwing exceptions from the constructor which can lead to other interesting and less than satisfactory implementation patterns. 

A quick note about your validation, you hardcoded 2 as the comparison, rather than Currency.DecimalPlaces, so it should be: 

This is certainly subjective, but i'll offer this pragmatic view point. Evaluate how often this code will be actively referenced and debugged by other developers. If this code is located in an easily reusable utility assembly, and it is a realistic expectation that it will be reused, then Value Object wins for me every time. It offers more self documentation than your initial attempt which is important because you have not implemented code comments at all. At the end of the day you have to justify the time and effort required to get the code into production, code that is reused a lot, especially by other developers is worth the effort to get it right, but you have increased you code surface and will have to increase you unit test coverage to match. Value objects like this i find are much easier to unit test, and like you have said with validation, the object now has additional options for expressing it's state without blocking execution with exceptions and we can more easily inherit this structure and when we need to override specific functionality, such as validation when we as developers do reuse your code. 

Obviously readability is subjective to some degree, but I prefer the version with . I should note that it would be more Pythonic to use a double comprehension instead of a comprehension inside a loop, but I don't find double comprehensions very readable. 

To improve the readability of formulae it is worth considering which common subexpressions to factor out. Every instance of which I see is multiplied by , and I don't see a numerical-analytical reason not to factor out a variable. Similarly for . That would then automatically address the point raised in Dair's review about , because instead of you would have , and similarly for . 

Although not many people do it, it's best practice to use string literals for object keys. E.g. instead of 

(Expected execution) The file is created in the block and so exists to be deleted in the block. The block fails to create the file and it doesn't exist in the block. The most likely explanation would be that the process doesn't have write permissions for . The block fails to create the file because some other process has it open. It might then hit the block and try to delete a file it didn't create. 

Then is essentially but calling instead of doing a lookup in a map. This is arguably slightly more elegant, but does run into problems with stack overflow if is too large.