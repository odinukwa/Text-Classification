Rule of zero Addressing your first question about destructors: the general rule to follow is that you hardly ever need to hand-code copy/move constructors, copy/move assignment operators and destructors, unless your class manages resources. That's called the Rule of Zero and it helps to easily write classes. Basically, there are two kinds of classes: the ones that manage resources and only do that (a class shouldn't try to do too many things, it should focus on doing one thing, that's the single responsibility principle) and the ones that don't. Most of the classes we write don't manage resources and in this case, it's better to let the compiler generate the special functions. Design I have the feeling that your class will be hard to use and maintain in a project: you are storing three different representations for a temperature and the user has to know which was used before using any the methods. That's some strong cognitive burden for users. Ideally, you should have had a class which does not expose its representation. You should be able to tell to the class which degrees you are storing and which you want to retrieve. Basically, it would be something like that: 

Have a better look at the truth table From the big truth table we built, we can see that when \$ A = B = 0 \$, the only time when \$ S = 1 \$ is when \$ E_{old} = F_{old} = 1 \$. However, when \$ A = B = 0 \$, we can also see that \$ E_{new} \$ and \$ F_{new} \$ can never be \$1\$ at the same time. That means that once and are consumed, can change only one more time and only if is . Therefore, we can extract the part from the loop condition and apply exactly one assignment after the loop (I used a loop since the loop was becoming a bit messy for the job): 

I'm going to leave off suggesting anything about the algorithm for now as I don't fully understand what you want from it. Instead, I'm going to talk about your class in laborious depth... 

As you said that you will always have the right number of elements in the array, I would suggest the following: 

I'll answer your primary question first - Why is it producing 1 char and then immediately consuming that char? Look at the producing code carefully: 

Or name your constant. E.g. . Anyway, the code looks good - nice names, nice spacing, great formatting in general. I'm assuming isn't one of your own interfaces? So, on to some dangerous hand waving. I feel like you need to make the seperation between displying the buttons and wiring up the command a bit more obvious. I think the way you can achieve that is with the mediator pattern. You basically have a central hub that sends messages to the right things to do the right thing. All of your buttons could then do the same thing - send a message to the mediator. 

You don't use the result so I can only assume this persists something somewhere - that's not obvious at all from the code. Parsing This sort of code: 

Computationally speaking, I don't have anything to add what has already been said. @amon did a really comprehensive review of your code. However, there are some serious sociological and/or ethical flaws in your code. I would say that, genderly speaking, it could be made more generic: 

I was about to add more things to my answer on your previous post and noticed meanwhile that your already asked a following question (that's almost too fast! :o). I have done some additional reading about C++14 and integer sequences. And I have found some things in the standard that could help to improve your code again. I realized at some point that you were using as the of . However, you initialize your with the result of and returns a , not an . Then I remembered that, along with , there is a for which is called and which has been made to solve the kind of problem that your are trying to solve. Therefore, you should every occurrence of by and of by . 

It is a base class that uses static polymorphism. Here is an example of a user-defined derived class: 

I had some time to work on the algorithm a bit since I asked the question and tweaked it a bit. Here is what changed: A small optimization does a bit too much work: it always check whether , even when hasn't been modified. A simple improvement is to move the check inside the previous condition and tweak things a bit more to only increment when needed too: 

By modelling your stylesheet as a simple you lose the order of the rules. You have to know which rule came first to in-line the rules in the right order! That's why it's called a cascading style sheet. It looks like you're only doing a simple thing so I think you can reasonably ignore specificity and media queries. Build up the domain! 

Now you can start playing around with a board. To be completely honest, I haven't thought enough about it to figure out how I'd really want it to look but something like the following would be enough to get along with. is just a convenient wrapper around two ints (the coordinates of a space). 

I don't have any strong objections to your code and the other answer does a good job of addressing some slight naming issues. My problem is on a much larger scale - I think your domain model is far too simplistic. Consider this CSS: 

There are lots of other ways you could solve it for example, by using reflection to instantiate the class. Update: 

If you have a case sensitive collation on your SQL column you'll need to use a case insensitive comparison but I would guess you don't. Similarly, you can simplify this: 

Order of the headers You often want to add/remove headers from your code and/or check whether some header is already included. It's really easier to check whether a header has already been included or not if you keep your directives in alphabetical ordering: 

Manipulating bits One of the areas where your code may be improved is the way it handles and compares bits. Your are using strings to represent bits while you could have used values and bitwise operations to speed up most of your operations. Actually, you should even replace every representing bits by since the representation of values is known and they are the tool to use when representing bits. 

The problem is that I want to keep the user side simple, but also to avoid (hence the static polymorphism). There are three main functions in the class: * : the recursive formula. * : so that the end user can use the final instances as functions. * : helper function (same as operator()) so that the recursive formula is easier to write. It would be great if the user did not have to specialize and could just give , but I can't seem to find a way to do so. Do you whether there would be some way to ease the functor writer work? 

Now, because is an int, you can't inject anything malicious, but what if you wanted to get the operator by name? Do you promise that you wouldn't write: 

I don't want to start a holy war about it but you should know that your bracing style isn't generally the expected style for C#. It is more common for the opening brace to appear on a newline: 

I'd also consider making that property readonly as you assign it in the constructor and mutable tree nodes aren't my cup of tea. What's with the s? is generally used more. 

Notice that the explicit operator can throw as not all strings are valid Skus but the implicit operator can't because all Skus are valid strings. I feel like I've rambled, but hopefully something in the above is useful. 

You're mixing aliases and typenames. E.g. vs vs . Choose one and stick with it (and preferably aliases). 

Some people would probably tell you off for using regions. I'm not really that fussed about it but you should be aware that a lot of C# developers don't like using regions for splitting up classes. 

If you're setting the Amount from 0 to 0 no one will even notice I regularly get distracted and attempt to drink from an empty cup (sometimes even yesterday's) 

Once again, I am assuming some implementation details that are not shown though. Anyway, try check whether coud be used to do what you want it to do. Standard algorithms can often do much more things than thought. 

It doesn't seem to incur any additional performance cost or benefit, but it makes the code simpler and cleaner. The left partition is always smaller In libc++'s implementation of , the left and right partitions to merge in a sequence could have any size, so the check to know which of the partitions was smaller was necessary to always make the best of the algorithm. However, in our case, the sequence to mergesort is always split in two parts, the first one always being the smaller one. Moreover, an additional trick is used to shrink the left partition, making it even smaller, without having any effect on the size of the right partition. In the end, when is called, the left partition is always smaller than the right one, and makes the check useless. The function can be simplified as follows: 

Obviously, the best way to speed up your code woud be use another algorithm. However, the other posts already do a great job covering that part. Therefore, I will review the other things in your code that could have been done better: 

Just a flying review: Have you tested this? The equality code isn't at all right. Firstly, never override and without overriding the method. You'll end up with a check that will be different depending on which way you do the test - that's bad. Secondly, your code can't handle this really easy test: 

Your documentation comments are really not good. There are numerous typos and not a single one of them tells me more than what the method name does (which isn't much). 

is generally bad - there's no way for the caller to wait until the work is finished. You shouldn't use async void methods (except for event handlers). 

I'm coming back to F# after a long break (2+ years) so I'm not going to suggest anything else as I'm still relearning! Edit: Actually... 

I think the code is definitely much better! I wouldn't worry too much about registering the s in your IoC. After all, you're not going to have hundreds of menu items yet. Anyway, two very minor comments: 

Regarding the dependency... I definitely think you should either pass it in as a constructor parameter or create a factory method for your repository. Even when you do that, I don't see why you'd need to store the link as a field which means your implementation would be unchanged. FWIW, I would go with a method over the constructor as you're doing some work there and I don't know whether any of that takes time... Either way, by having an extra method that the caller has to know about before they can use the instance is always frustrating. You could create it as an extension method on the if you want to treat that a bit like a unit of work. You could leave your create + initialize as separate steps, or you could create a static factory method. 

The ellipsis is a GCC extension to the C programming language known as Case Ranges. Using it hinders portability since not all compilers support it (as for most of the extensions). If you want to get rid of it, you should use the function proposed by Jerry Coffin: 

You will have to write many functions that look the same, but unless you use more macros to generate the code, this is how C works when you want genericity. You should consider factoring out the parts of the functions that are likely to be repeated, such as your error message: 

There are probably other things which could be improved: make your more like a STL container by enabling a support for allocators for example (you could forward the allocator stuff directly to the underlying to avoid having to actually handle them). Also, instead of a real container, you could try to make your a container adapter (like or ) so that it can use an or an (or any conforming container). Miscellaneous C++ stuff It has been more than a year since the review, but it seems that it has some views, so I thought that it could be a good idea to complete it with some miscellaneous additional comments... 

Your code is really hard to follow, the method is a bit too long for my liking and you have a which IMO should never be used. 

You could also inject the into the classes constructor but as it is a static method and I don't know what the rest of the class looks like, I'll leave that point for now. 

I can't answer your question about performance because I don't know where your bottleneck is. If one of the API calls is taking the time, you can't really do anything using your current approach. If it's you'll need to explain more about what's in each list. 

I just use a dictionary to keep a tally of the number of edges in each column and keep the current winner in a variable. My original code was simpler (only using the dictionary) but it failed the performance requirements on leetcode so I had to manually keep track of the maximum as well. 

You also (probably) don't need to prefix with Edit: If the null coalescing operator doesn't work (which is a massive shame) why not create an extension method? 

We don't want to search the DOM for the element every time (unless it can be added/removed) so let's pull it out: