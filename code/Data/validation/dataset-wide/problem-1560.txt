If the data type is not available in your version of the .Net framework, it is open source ;): $URL$ 

However, there is still the problem with the dependencies that must be injected manually. Depending on the DI Framework, you can use a factory for creating the UnitOfWorks with all it's dependencies. Ninject for example has an excellent Extensions providing exactly that by creating a simple interface: 

That's the nice thing of enumerable methods. There are just some discrete methods available, but those can be parameterized / combined to realize the most use cases. I really like the compactness and elegance of the LINQ API :). 

From the performance point of view, there is no significant difference between the 2 solutions. Therefore, try to write the code as readable as possible. If is a reference type (and can not be null), I would restructure the code to something like that: 

I am working on a WPF application consisting of a tree view and multiple "view parts" that display details about the selected node. The content of the view parts are loaded asynchronously which may fail (e.g. some data are loaded from a web server which will become unavailable and so on). Of course, failure is an exception and should usually not happen. My approach to handle failures in a decent manner (something between hiding it from the user and showing an annoying message box) is to show an error message within the view part. For that use case, I wrote a simple control that works as a wrapper around the view part and displays the error message. Usage 

I think "BadRequest" is OK for that case. Alternative options are "PageNotFound" or "redirect to index". Some other points about your code: 

I am developing a WPF designer where visual elements (rectangles, ellipses, ...) can be inserted, moved, resized and so on. Similar to a simple PowerPoint control. All the actions should be undo-able, so all modifications to the drawing area's state are implemented as s. An operation looks like: 

I am not really happy with the method because the will be checked twice for / and /. Is there a way to realize it with only one check without creating the regex unnecessarily? As always, any feedback is welcome! :) 

Your code looks very clean and organized. Only some comments (without understanding the code in depth) 

The characteristic numbers are not always indicating bad code... However, you could do something like that to improve the numbers: 

Consider to return null if the attribute is not available. However, you should not cast () the cached value. Use either if you want to return null or throw a custom exception - otherwise an will be thrown. Example that produces an : 

However, if the constructor becomes to complex, its probably the time to split the class in multiple classes (if possible) ;). For simple constructors (with 1-2 parameters) the implementation of the builder is too much effort. But for the few use cases that remain it seems to be a good alternative to "monster constructors". :). 

A type may contain more that one attributes... therefore it is not sufficient to use the type as key. It must be a combination of type and attribute type. 

Honestly, I am not sure if a dictionary is the right data structure for realizing composed keys. At least for me it is not directly obviously how the data are grouped. I think the main issue that confuses me is, that the grouping key contains not just the values to group by, but also the column headers which is absolutely irrelevant for grouping. Additionally I have to understand the comparer. 

Even if it is possible to specify a , it would be nice to have a parameter less constructor that uses the default comparer of 

To your first use case: Even if you cancel the task, it is very likely that the server has been requested anyway. IMHO, a more appropriated approach is to wait for the server and run the last action again if there is one. The following CR question addresses exactly the same problem: Processing input in background while user is typing To your second use case: Just stop the timer before running the action and restart it afterwards. That's much simpler and takes less resources. 

General solution for "async task processing" I use the following simple solution for that kind of tasks: 

I am fine with a set that preserves the order of insertion by implementing ISet with a customized -implementation (something like OrderedSet). Whereas, an doesn't make sense for me because it would not behave like a list (see also Liskov Substitution Principle). 

Move the code from the finally block to the call of . There is no need to attach it via in the finally block. 

Your code seems not work correctly, because if is reached (which is given as initial state), the inner while loop is not entered anymore. I suppose there is a missing at the end of the outer while loop. 

First of all, IMHO the code is well written and has some meaningful comments. Visitor Pattern Actually, I am not sure if the has something to do with the visitor pattern. In my eyes, the visitor pattern can be used to add logic to a data structure by implementing visitors. A visitor visits each element of the data structure and decide what to do depending of the element's type. The can be used to add logic to an object for processing other items in a special manner. Therfore I wouldn't use the term "visitor pattern" here. OverflowingBucket 

Probably there is is more elegant way to organize the code, but you get the point... Writing maintainable code means to group code that belongs to the same level of abstraction to single code units like methods or classes. The next step would be to group code that belongs together. The description for each operation is displayed in the method but the actual logic is handled in the method . Therefore, if you want to add or remove operations, you have to change 2 different locations. That is a error-prone design because it is possible that you forget one. To fix that, it make sense to create a class Operation that looks similary to: 

Interesting try to use C#'s operators for set operations. However, I think it is not a good extension in productive code because 

I am working on a library that parses query strings and evaluates the result for a given context. The query has the format . The list of operators is constant, but the field's type can be customized (default primary types are supported right now - other types can be added). To enable the user of the library to overwrite the behavior of the operators, there is a class that evaluates 2 values for a given operator. It uses the default comparer of the type, but can be extended to provide specialized behavior. The is such a specialized comparer for fields of type string. It adds support for wildcards and regex. Operators 

All the code is structured in one big method. To improve readability and maintainability, the logic should be splitted to multiple methods (in a first step). For instance, each case should be one method; The generation of the main text should be one method and so on. Normally, if the level ob abstraction changes, a new method should be creaded. That could result in something like: 

If the output file already exists, the merged content will be appended (not sure if that is desired) 

You change tracking does not indicate changes in complex objects. But maybe that is not the main use case... However, to avoid accidentally misusage, you could restrict the types of dependent properties to types that implement . 

All things considered, I would prefer an approach where the view model is created / configured by the calling logic and shown via an generic service because it is more flexible and less distributed code. 

Therefore XOR seems not to be the best solution for combining hash codes in general. Not sure if that is true in your case because the quality of the hash functions depends on the distribution of the data. However, if XOR is still to slow, you could try to simplify the hash function. Of course, that will increases the number of collisions, but probably it performs better than a method that is much slower than . You could try something like that for example: 

Note that there is no need to pass the view model to the view's constructor because it is automatically bound to the view's data context. 

I need to compare 2 xml strings where the formatting may be different. The approach is to use the to format both strings and compare the formatted result: 

Approach To avoid conflicts as described above, a centralized locking mechanism should be introduced. The idea is, to create a file on the network share. That file contains all current locks (one per line). Format: "RelativePath|User|DateTime". Each application checks in certain intervals (e.g. 100 ms) if the file changed and updates it's internal state accordingly. Each application may add / remove entries to / from the file. Implementation The API to the storage uses the following simple interface: ILockStorage.cs 

Local functions make it possible to write succinct code (especially in combination with partial function application as you did), but IMHO it' s harder to read.... probably just a matter of practice ;) 

Sure, it is not so elegant, but IMHO for a tokanizer performance comes before elegance. Probably there is also a better solution ;) 

As smartobelix mentioned, it makes sense to distinguish between loading root elements and loading non-root elements. I would prefer to use separate methods instead of using a flag and add a "if branch" in one method. Another simplification is the usage of and instead of creating temporary lists. That makes the code slim and readable. A refactored version could look like: 

I think the prefered way to sort a list is to implement a custom comparer and using . That also supersede the ugly usage of : 

The methods should return instead of . Otherwise exception are shallowed. Alternative you could encapsulate the whole content of the method in a try catch block. 

Put all the code in a try finally block. Close all file streams in the finally block to ensure that the streams will be closed if an exception occured. 

Additional to @Mat's Mugs great and detailed answer addressing DI, I would just adding few words about alternative solutions. Because you would like to practice DI, your implementation is absolute OK! However DI / abstractions introduce additional complexity, therefore (IMHO) it should be avoided for logic that doesn't need abstractions. That is usually the case for pure functions. Your chosen problem (finding min/max value of a list) is such a pure function and therefore I wouldn't use abstraction for that logic in real-world applications. Alternatively, I would create an extension method or an utility method for such logic. Fortunately, the extension methods already exists: 

Conclusion I would really suggest NOT to use that class! There are excellent frameworks that adress the problems you are tring to solve (e.g. NInject factory extensions for creating factories, Moq for mocking objecs to enable testability ...). 

Ellipses are relative heavy objects that support layouting, hit testing, drag&drop and so on... If you don't need such features, WPF provides more lightweight ways to draw ellipses to the screen (e.g. DrawingVisual). Using such a lightweight rendering, may also solve your lagging problem (at least if layouting is the problem). 

Creating so much (partially identical) brushes is a waste of resources. Brushes can be easily cached: 

That avoids to set the last propery twice. b) If that is actually your productive code, I would recomment to use a MVVM framework that provides a more comfortable way to raise property changed events. At least implement your own base class that implements . c) In XAML, you don't need the CommandParameter binding for the , therfore I would remove it. 

Conclusion I think, at the end of the day, I would prefer a conventional DI approach to your nice query API. Instead of 

The table below displays the ellapsed time in milli seconds for each method depending on the number of calls. 

As the type seems to be used often, note that the observers/listeners have to be unsubscribed to avoid memory leaks. If that is not easy possible, one option is to store the observers/listeners as weak references so that the GC collects them if they are not references anywhere else. 

into the domain class. Imagine use have to add items somewhere else, that kind of code must be duplicated each time. 

The purpose of the class is to provide an easy way for create and verify a signed license file (or key). I am interested in any improvments / thoughts about the class. Usage: 

After discussion in comments of my other answer I did some investigation and found this interesting 5 years old article form Eric Lippert. It says 

API The API is a little bit confusing, because adding a query clears the list of parameters that was added before. That is something non-intuitive behavior that you have to know ;) If you want to create something around the regular DB-API, I would prefer to create a query object that contains the SQL and all parameters and than execute that query object in one single operation so that the connection object doesn't has a "query state". Abstraction It is possible to abstract all that stuff so that the and the may work with any database management systems (not just MySQL). If you want to support all DBMSs, just use the abstract types ( instead of , instead of , instead of , and so on). 

The looks a little bit like a mixture of a command and a view model. I think it is ok for that case. However another option could be to create a view model "AsyncOperationViewModel" with the the properties , and . 

It is a little bis faster, but not significat... However, if you have to use a binary reader for reading the other content, maybe it is a reasonable alternative to PtrToStructure. Reading the 6 mb file 60.000 times takes: 

Performance The performance intensive step is the missing one that sorts the nodes. Therefore, I would think about an alternative approach instead of sorting + recursive creating the tree. One alternative approach may be: 

First of all, IMHO it's a nice piece of well-written code that seems to be OK as it is. However, I have a few marginal comments: Contains When using a collection's method, I would expect that it uses the default comparer for the corresponding type or a custom one. There is no real problem with using instead, but actually that is a requirement of the WeakCollection's internals (which should be hidden from the user). Count Another particular thing is, that the count information is uncertainly. You addressed that by making the Count property throwing an exception. That is IMHO the right way to handle it, but it also restricts the usage of the ICollection abstraction. GetCount I would Rename the method to something that makes clear that the count information is uncertainly (e.g. ). Actually, I would drop them and add a property (That appears below the Count property in intellisense) instead. If needed, can be called before in a separate step.... but that is a matter of taste i think. CopyTo Count is often used in combination with CopyTo(array) to determine the length of the array. That pattern may fail with the WeakCollection. Conclusion I can't see a real use case for / / on a collection that's list of items is affected unpredictable by the GC. Therefore I think that the ICollection interface is not the right choose here. It is probably better to implement IEnumerable and add the required methods / / . Functions like Count or Contains, can be used after creating a 'snapshot' of the current collection - Maybe in combination with GC.TryStartNoGCRegion / GC.EndNoGCRegion to avoid subsequent garbage collection or by adding a reference to the item objects for temporary usage. 

Note that dependencies, defined in command's contructors, are automatically injected by the factory extension (Internally, it holds an instance of the kernel). The factory can be used to create the commands in constructor (or even on the fly if the command is required): 

Why is it ugly to pass reference types by ref? Because other references are not updated - they point still to the original object. The following code illustrates it: 

I like the syntax of your builder. Instead of having a contructor with multiple overloads, your builder provides a readable and very flexible solution. For instance