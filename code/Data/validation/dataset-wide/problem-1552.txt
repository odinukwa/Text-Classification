to ensure that you don't consume the iterator of multiple times - creating the iterator might be expensive or slow, say reading from a file. This'll make the output come out in a different order from what you give us - it'll be a post-order traversal instead of a pre-order one (see below). Since @coderodde has already addressed the main point of iterators and memory-efficiency, this is more educational as you were asking for a recursive solution. Although this particular solution is not recursive, it does utilize the concept of divide-and-conquer with a base case, so it should be helpful to you. About trees: see if you can recognize the tree structure in this program. Hint: it is a balanced \$n\$-level tree where \$n\$ is the number of tuples, with each node having \$\left|T_i\right|\$ children, where \$\left|T_i\right|\$ denotes the number of elements in tuple \$T_i\$. In fact, the \$i^\text{th}\$ level is just the elements of \$T_i\$ repeated as the children of every node of level \$i-1\$. The output of this program is a depth-first search with pre-order traversal of this tree, splitting the output into words at each backtrack (recursion unwind). The output at any given point during the execution is the path traversed in the tree till that point. An exercise - try writing a program which explicitly makes this tree and prints every path from each root to each leaf, splitting the output into words at each backtrack. Here's an example tree for the set of tuples (note how each required word is the pre-order path from the empty root to a leaf): 

It's not technically \$O(1)\$, it's amortized constant time (\$O(1)\$), as you distribute cost of the calculation over the additions / removals. Not really an issue, but maybe you should make that distinction in your documentation. Use instead of , as it preserves the caller's object identities that way. This would entail changing the type parameterization of to be , though. Considering comments (especially by @EmilyL), you should leave the implementation as-is, but you should put in a comment that you are only interested in the numeric value, not the actual object. Consider marking your formal parameters as , as you do not mutate them. Make 's return type , as the user has no need to get the same number which was passed as an argument returned. Rather, throw an exception, preferably if the relevant could not be found in . An alternative to (4) is to make 's return type , and return on successful removal of from the set, or if the removal was not successful. Instead of throwing an when asked to compute the standard deviation when the set has less than 2 elements, return for such sets, as in the 0- & 1-element sample sizes, the standard deviation is mathematically undefined. That does not warrant an exception, as there is a value which indicates exactly undefined: . Here I assume that the standard deviation is calculated for a sample, not a population, because in that case the standard deviation for 0- & 1-element sets would be 0 (although computation of population statistics is not common in practical usage). 

(This is in fact what I translated into Java, having coded this much earlier for a personal project). This is not as memory-efficient as @coderodde's iterator version, but it is algorithmically simpler and easier to understand, I hope. I put in a few tests in so that you can check that this code does the same thing as yours. Note that here you can replace the and with and to get an even more general version of the code which can find the Cartesian product of any collection of s. Here, you should also swap 

Instead of using , just cast the square root to an , i.e: The should be outside of the for loop You might also want to add something to catch weird input, such as -> . If you have this you can also eliminate the first part of 

What it's doing Basically, this is just going through all the numbers up to the square root of , and seeing if they divide evenly. They divide evenly if . If anything divides evenly, then the number is not prime and the function should return . However, there is no anywhere in the program, and it actually relies on undefined behavior. Try going through it yourself with equal to 9. The loop will go until , and then it will terminate because of the statement. After that, the function doesn't know what to return since there isn't any statement outside of the loop. On my computer it defaults to , but if you compile with you'll get this: 

This can be rectified by replacing the statement with , and putting a on the outside of the loop. It should be at the end because at that point the function has gone through all the possible factors and found none that divide evenly. Improvements 

Everything looks right from this, so we can call it a day. Note that if generating a list of primes like this is what this function is used for, you should consider using a sieve instead. 

I used C++ metaprogramming to build taylor series for sin, cos, and tan (not really for tan). The whole thing is on my github. Please give any feedback related (but not limited) to style, functionality, etc. Overall I think the biggest flaw is that the client needs to make their own struct with a member called , and pass that struct to the "functions." I would have just passed the double, but C++ doesn't let you use floating-point numbers as template arguments. Using a struct was the only way I could think of to get around that. Thanks! 

If the range at the end is just to demonstrate that your function works then that's fine. But if you specifically need the primes over an interval, try implementing a sieve instead. 

is never going to be larger than due to the constraints in the loop, so should also be of type . (Or should be of type ) The two statements at the beginning of the loop that check if is or are going to be the same every time, but are evaluated at the beginning of every loop for no good reason. Put them before the loop. The middle statement of the loop, and the at the end, are doing the same job, which is limiting the amount of times the loop repeats. Replace with and get rid of the at the end. I don't know what function you're using, but I'm guessing it's from . That function takes a , so either use a square root function that takes an or replace with . Mathematically, it's pretty much the same thing (though we can get rid of the unnecessary ), but we avoid using that function incorrectly. This loop will check every number up to the square root, but if has any even primes then it is a multiple of two. You check early on if is even, and then only check odd numbers in the loop. That will cut out half of the iterations with one quick statement in the beginning. 

For , an algorithm is to do it the normal, C (pointer-based way). Traverse the list maintaining references to 2 elements, the current element and it's previous element. At the element to be removed, set the field of the previous reference to refer to the element following the current element. This would work far better with loops than and . Again, imperative and functional don't really mix well in the same part of the program. Take a look here for a reasonable functional singly linked list in Scala. 

Make your function parameter . Although C++ is call-by-value, making it explicitly and mutating a local copy of the variable is never a bad idea, and it does make your function contract that much clearer. On the performance side, since on any reasonable computer will have maximally 16 bytes (64 bits of 8 bytes is the case for all common architectures, except for probably some microcontrollers which will have less, even as less as 1 byte) (note that the upcoming RISCV architecture does have a native 16-byte (128-bit) integral data type, but the 64-bit one is the default), you can easily make this function a template, such that the computation of the byte vector can be done at compile time without much overhead and incur no runtime overhead. You can probably even pre-set the capacity of your utilising . Although I'm not sure if this suggestion will work in the constraints of your application. 

You have an unrolled loop, which is good for performance (especially because in Java the size of an is fixed to be 32 bits). However, you could consider turning it into a loop if this performance is not required, that would reduce code duplication. Which means that you could also try: 

The way you do it - you are reimplementing division and remainder from scratch with a loop. This is, well, useless. The way you're doing it right now is OK if you can't use the above (course restrictions?), which would have helped a lot in this case - you could have used it to get rid of the loop altogether, just looping over the allowed prices. What can be done for your code is moving out the part which reimplements division and remainder into functions and using them, but then there remains no difference between the way I do it and the way I suggest for you to do it here. (Note that the extraction into functions is necessary for reducing code duplication and extending your code to support more prices). Here is my take: 

Style Naming: You name your side-effect-free functions in a way which makes users think that they have side-effects. Instead of naming them with present-tense verbs, name them with past-tense verbs, like instead of , instead of , etc. Your indentation and bracket usage are spot-on unless otherwise noted. Errors 

I left in the debugging print statements as I feel that they make for reasonable documentation. Side note: Please use functions and proper variable names, like the ones I introduced. Note: This has not been tested with the UVA Online Judge, only on my PC. PowerShell screenshot of timed run: 

Pattern matching in functional languages is a very powerful construct, much more so than the simple in most imperative languages. The clauses in a pattern matching expression (a expression in Scala), match the patterns in the clause against the input argument(s) (and, optionally, also bind values to the results of the match). In Scala, pattern matching clauses are denoted by the starting keyword, which often occludes beginners from the power of pattern matching. Hence, both and denote patterns to matched against the argument, which in this case is the . Now, just matches the empty , as would for an empty , and for s is the exact equivalent of for s. This pattern not only matches the "head" (the first element of a list or sequence) and "tail" (the rest of that list or sequence), it also binds the values and to the results of that matching, in respective order. So, would cause to contain the first element of the , and to contain the rest of that , allowing for easily described recursion over the sequence. Note: The for pattern matching on s in general is only available in Scala 2.10+. I use 2.11, and I guess the OP uses that or higher too. For a lower Scala version, this behaviour can be emulated by converting the to a before the pattern match with , or by making a custom implicit wrapper for containing the appropriate extractor () method.