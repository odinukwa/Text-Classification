There are many other optimisations that I have not included as the resulting optimised code is very simple and most of what you had is not needed. Testing To ensure I got it correct I wrote a test that compares your function to the new one. Making sure the results are the same, then running each version 100,000 times to get the performance. There results are 

Use a queue or stack. Place the elements on the queue you want to show and start a timer and keep it running until the queue is empty. 

2nd line, address? its a url or more apt a relative path to the image resource 1st line store it in a cache? Can't find any cache, but looking at the code I found the object which you could call a cache, and download no you are not downloading in the classical sense of the word. Maybe the following more clearly describes what the function does. 

This is true in most cases, but if the expression is a complicated on that would stretch the if statment past 80 chars then it would be best to use the variable. 

Ugly is somewhat subjective (2 spaced indents are ugly in my book), and sometimes unavoidable, as long as it is readable then looks don't matter. Code duplication is not a code optimization problem, in fact it is often code duplication that creates the optimal performance. Duplication is a source code management / maintenance issue. Case in point 10th line the join string missing a space while the duplicated line 18 has the space. Duplication is a easy place to introduce a bug, it is a place where the brain will say "same" for what is just a little different Duplication is simple to rectify using functions. You have two identical blocks of code (lines 7-11 and 15-19). You can wrap those lines in a function and call the function rather than have the code inline. You may opt to pass the function the arguments or use closure to hold the variable and access them directly. 

The function uses to get the timer index then you use the statement which fails to remove the first item in the instances array. The result is the worker is never shut down. Calling from within the callback function fails to stop the timer, the callback continues to be called. Because you set to -1 your code then tries to catch up by calling the callback at the full rate of the worker's messages. 

Assuming that if the first object has a property set to and the rule states no change then your code is almost spot on. Some minor changes 

Too complex. There is a very simple rule in all programming, KISS (Keep It Simple Simon (*)) and your code has strayed a long way from that rule. Complexity is a breeding ground of problems, it is hard to maintain, more likely to be buggy, can be resource hungry, and more. You started well by defining the , but adding a new class for each hand type is unnecessary. The only difference between them is the rate at which they move, so add that as a property or state and the element (or maybe just the style) that they use and the hand is fully defined. The CSS precision There is the problem of CSS precision but that is easily fixed by getting the time at the start of the day and subtracting that from the current ms and does not need the extra rotation counter (not sure how long it needs to run for the second hand to start playing up again, but you can just reset that once a day if you plan on letting it run 24/7). Rewrite You had about 114 lines of javascript which can easily be reduced to 20 and behave exactly the same. There is no point in adding all the const for time as they are truly constants and you will never be hunting around to change them (The irony of constants is that you define them so it's easy to change them, not because they never change). I personally would have reduced the rate values eg 360 / 3600000 = 0.0001 but that is a little obscure so left them as is. 

Pure V State There are two ways you can do this. Pure The first functional pure method first copies the array, then checks if the item to toggle exists then depending on that result adds or removes the item. Making sure that the added item is a copy, not a reference. It has no side effects but requires additional memory and CPU cycles. 

Create a projection In that projection matrix is all you need to convert from screen space to world space (the reverse of the above function). So when you define the projection matrix you also define the inverse matrix 

A rewrite This is how I would have written your code. It is just a suggestion example and far from ideal. I do not know what you wanted exposed but I only exposed what was not called internally (assuming this is a module) 

Javascript is a lot better at handling numbers than strings. Though I am not sure of the range of numbers that the problem will present. If they fall outside the precision of Javascripts double (Number) then you will need to use strings. If not then the following will improve the performance significantly by working with numbers rather than strings. 

You could not have found a worse way to do this. remember you are writing 1 32Bit pixel, but you create x,y coordinates, then copy x to an object, which you pass to a function in which creates another copy, you return the computed value and store it in yet another copy. Then do it again for y. And once y is done you make yet another copy to be pushed to an array as a reference (even more memory used) (remember that memorize will also be making a copys). X and y should be immediate, on the heap and then forgotten, no variables need be created, no object constructed, no allocation requests made. The performance rewrite. Move one 32Bit word to an array of pixels for each item in . 

For the results of n < 10 the improvement is not that great but near 25%-50% is worth the effort. The improvement for n >= 10 are well worth the effort. The new code No loops needed. Warning may need to be larger as I have not tested all possible inputs. 

Simple solution The problem is trivial as there is only one hub station. This means that there is only one root between any two stations. You need only find which line each station is on. If not the same line then find the root on starting line to the hub and from the destination station hub to the destination station. If the problem involved a configuration that allowed more than one root between stations it becomes much more involved but your code does not show that is an issue. Simplify using functions. The reason why your code seams long is because you have not compartmentalised functionality in the form of functions. You can break it down to 

Your code did not show where and came from. But they should be handled in the same way as above, without making function calls or creating objects. Everything is immediate and on the heap, and not making allocation requests. The beauty is that it is also has binned the data for you as the pixel array. You can make a copy and next time you need that data set just dump the pixel array to the canvas, in less than 1 ms 

Not much to review but A few points Too many arguments. You have a lot of arguments that could actually be passed as just the handler, and if you make the timeout callback one declared in the (rather than call ) you can close over some of the variables and thus would not have to pass them (and keep them protected). The variable could be removed as it is only used once and may be better as 

Case 2 For case 2. Do what you want its safe, but be sure you dont forget about it and use it on a public page. In other words do the first case setup to be safe. 

You only need to touch each item once (excluding the copy if you do not need the array shuffle to be in place) and there is no bias inherent in the function. The only limiting factor to the randomness is the random number generator itself. 

Each group of three can easily be replaced with one. The click functions can use the click event to get the needed information from the DOM, and the result functions can be passed an object that contain the sound, message and element to display the message. 

You should hold that reference for the life of the associated data. If the data changes you make the change to the stored element. 

Too many steps Assuming the has been "Parsed" (white spaces removed) It is only when you have two matching characters that you require any additional processing, parsing each char to a number before you know it to be part of a pair is redundant, also parsing both characters when you only need one is also redundant processing. All you need is the reduction. 

Note on recursion. Though this function is often used as an example of recursion you should avoid recursion in javascript if you are not in control of the calling code. Javascript has a limited call stack, and Tail call optimisation as yet has not been implemented by Chrome, Edge, Firefox. As you can not determine the depth of the call stack at run time any recursive code can indeterminately throw a . 

Follow instructions. Both answers (in my opinion) are wrong, as they have not followed the instructions and added additional behaviours not specified in the instructions. The question is very clear as to what the function should do 

DRY but not a desert. It is not possible to be without repeating code, sometimes the complexity of the problem makes it hard to avoid repetition, or repetition may be the quickest way to solve the problem when time is short. Sometimes when execution performance is the driving force repetition is the only way to get the best performance. The length some coders go to too avoid repeating code can become so complex and difficult to follow that they have lost any advantage they would get from DRY code. A DRY KISS is best. DRY is practical, saves you time entering and modifying code. DRY code is more compact and thus should be easier to read and understand. If this does not happen then it was best left as it was.