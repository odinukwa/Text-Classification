I've started working through a series of revisions in Git of which I'll highlight the best here. Here's the full random-schedule-generator commit log. They're in reverse chronological order so start from the bottom, each is a single small logical modification with my motivations for the change. First, it doesn't seem slow at all to me. Maybe you're confused by the behavior between and ? prints its try messages in between calculating elements of the result list. The resulting is only printed after the function returns control to , at which point it begins printing what is usually a ~37,000 element list all at once. Also, there is a HUGE difference between running this interpreted from GHCi and running the compiled version (with or without optimizations turned on). Regarding your second point, there's certainly some poor thunking behavior. What I describe above is one example, those 37,000 s are all kept in memory until they're printed out by . I'll fix some memory leaks tangentially but not generating 50,000 tries will push memory usage beneath what I'd scrape the barrel for. The majority of the changes I've made so far involve using functions out of the standard Prelude or from other modules in to clean up or entirely eliminate some functions. For instance, I ended up replacing your function with from which operates with a better time complexity and in the process threw out and . Here's my commit message with the full detail. 

If that final representation has only unique keys, then a reasonable intermediary would be one that hasn't had values which share a key accumulated yet. I.e., . 

This also pushes the site of compiler errors from where you're calling the function to the body of the function you're calling if you forget to change all of your imports or implementations. It also makes it immediately clear whether a function is working on an individual row or the whole puzzle or what. 

and depend on , let's start with the latter. doesn't mean much as a prefix to me, so I'm going to call this function , but that's a stylistic preference. Changing this function to use is straightforward. 

is a partial function, and it isn't acting much like a mapping as it only modifies the current element in your given definition. Maybe is a better name? (Or , or , or...) 

This is probably way overkill to start with, but with it you could test biased wheels, or different levels of acceptable losses, or different strategies against particular wheels. At this point also you'd want to start using type aliases, newtypes, or your own data types to disambiguate what's going on. E.g., you'd end up with... 

And assuming we have a lowercase string, it's easy to filter to just the characters we're interested in. 

Now consider intermediate representations that can get you closer to your goal. Remember that it's easy to construct a map from an association list with , so let's make that our end goal. Write out the types for a roadmap from where we are to where we want to be. 

I'd eliminate the explicit use of bind entirely though, then it becomes easier to turn this into a function that can work on directories other than the current one. 

In conclusion, Haskell is a land of contrasts. So, we learned today that there are many different ways to skin a cat. Depending on what you know about your problem domain many different complexity classes of algorithms may be available to you. And don't use linked lists for operations requiring constant time updating. 

This is good! You have restricted imports, type aliases, type signatures on all top-level definitions (except , which you should add but is at least obvious), total functions... All I've got are details. should use the type alias in its return. I.e., . I would probably also name that function “,” refers to an implementation detail; you are providing the function with what you know (or hope) is a single serialized rule to be parsed, not (say) dividing a rule off by splitting it into two. I might also reconsider your error handling with , right now your program silently discards rules it can't parse. That's certainly a valid choice but you might find that it actually makes sense to halt program execution on badly defined input, like so— 

This is now obviously a specialization of , which isn't all that interesting. Look now to the implementation of where you can see that the result of is passed to . Because the type of is given as , the compiler can again determine that must return an Integer if you change the definition of to— 

Function application has the highest precedence of any operator in Haskell, so these parentheses are unnecessary. 

I think you've missed the forest for the trees. While the origin of your list might be , there's no need to carry values around inside the monad just because that's where you found them. Write your functions as though the external world doesn't exist. E.g.— 

Are you familiar with function composition from mathematics? It's the same thing here, is equivalent to , but it puts the emphasis of the code on the composition of functions and not the manipulation of values. This is a different mindset from what you're going to be used to coming from an imperative language, but it is integral to developing the Haskell "house style" and really effectively leveraging combinators and function composition. Haskellers also love writing functions pointfree. This means leaving off the arguments that are being passed to your function where possible. Check out the Haskell Wiki on pointfree style for some motivation and examples. 

To break that down, since the list is supposed to be "circular" we safely pop the first element off the front of with (we either get the first element, or an empty list) and append that to the back of to get the wrapping property. (As an aside, this is complicated a small amount by being efficient, an equally correct solution to having a circular list would be , but that would end up checking the entire list for equality twice if isn't present.) Next we drop all elements from the front of the list that are not equal to , which either produces the empty list if the element isn't found, or the first tail of the list fronted by , i.e., , so we use as a safe version of (to again handle the case of an empty list) and end up with a list where the head element is our answer. Then produces the first element of the list, or if the list is empty. In principle this isn't much different from your original solution, I've just shrink-wrapped it down to the constituent pieces and arranged control through function composition.