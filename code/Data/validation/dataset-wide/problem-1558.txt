I don't understand purpose for your connection class. It doesn't really do anything. It looks like an improperly implements singleton. But right now, it does nothing to prevent spawning unnecessary connections to the database. If you wish to keep it, give it a meaningful name. is very generic and gives no hint that this is intended to work with SQL server. 

You should be doing field-level validation for all of your input fields before inserting into database (and possibly field-level validation in javascript to even help prevent POST from happening with invalid values). Sanitization and validation are two different things and both are probably applicable to your typical "input form which inserts into database" use case. The prepared statement will mitigate against SQL injection attacks and alleviate the need to escape characters for database insertion, but it will not do things such as: 

You are really only doing the minimal amount of data validation available when working with your method arguments. Perhaps consider more meaningful data validation (beyond just type hinting), especially on your public methods. You for example, when passing in table name as a parameter, you should likely validate that the string is not zero length. Some of your integer values might need better enforcement (positive values only? unsigned?). You should fail out of these methods early before doing things like trying to operate against the database, when you know you have invalid values. 

You may consider PHP's function which would allow you to define a validation configuration array and then execute all validation rules against input parameters in one pass. Alternately you might consider validation libraries common to most of the popular PHP frameworks. 

This would eliminate your subselect and the resulting that is happening because of it. Of course, the query above would require an index on to be optimized. This would give a result set like: 

By easily being able to throw edge cases against your unit under test, you can more easily explore what happens when unexpected (not "happy path") values are passed and decide how you might want to modify that unit to give it more resilient behavior (for example, throwing exceptions if unexpected parameter types/values are passed). So perhaps you have modified your method to validate the parameters as strings: 

Don't start your output to the browser (the HTML part) until you have done all of your primary PHP logic (i.e. validating form data, interacting with database, etc.). You will find over time in working with PHP that separating core logic from display becomes very important. Once you have started output, you will no longer be able to do things like change the response headers (i.e. for redirect). 

This again decouples display classes (like ) from behavioral ones, and would allow you to use any sort of elements - these could simply be divs or tr/td combinations - in any sort of layout. It doesn't matter, since our data attributes will tell the javascript class how to set itself up. Next, let's focus on this class (we will call it ). The thought here is that this class could be dropped on any page via reference/include, such that it is reusable anywhere in this application or other applications and is not tightly coupled with the display layout. This class must be able to understand the different element types and provide a single place to implement the code logic pieces noted above. One thing we are going to look to do with this class is to minimize the need to re-query the DOM every time a filtering operation is needed. This class will store the jQuery selection references it needs to perform actions on DOM that result from filtering operations. This would greatly increase performance in cases where you are expecting the filtering controls to be heavily used. 

Don't use . It can make your application fragile to DB schema changes and can result in unnecessary data being transferred between DB and application. 

I would consider making each counter self-contained, as there is really no apparent reason to have to couple these counters together like this. This might be something that you implement as a class in your application. Class file: 

Note, use of arrow functions is optional, but since you indicated you are writing for ES6 and transpiling, and since the callback logic is so simple here, I thought the arrow function made sense. Alternately, you might perform reduce then map like this: 

This seems like poorly named property. I would expect this to contain an array of files, not an array of ini configurations as it seems to. 

Your usage examples here are a bit trivial and using a functional approach to working with the data in the database vs. an object-oriented model approach. I would think that you need to be aligned in your approach for how you are developing your application. 

Do you really need to lock the file for reads? If you want to maintain this, you should unlock the file immediately after you make the read, vs. in various places further in the parse method (you have the same line repeated multiple times, which can be avoided). i.e. 

UPDATE Do your values really need to be stored in hidden input fields? What is the value of doing this versus injecting these values right into javascript variables? They can't hold any value for server-side validation, as a user could easily modify these so why make it so painful to extract these configuration settings from a DOM element as opposed to just: 

Neither of these is the use case here. The stored procedure is giving you no benefit at all. You could just as easily have that logic in your application and not "hide" it away from your application developer. Second, Don't use views in MySQL. They perform horribly. Finally, I have inserted code review comments into your PHP code. They are within multi-line comments below. 

Rather than using timing intervals, you may want to consider using promises/deferreds to process your queue. By doing this, you don't have wasted time gaps where you are not doing work. You could also experiment with the number of items you process of the queue at a given time to find the right balance between execution time and resource consumption. 

So what does this mean? It means you probably want to consider having a base class (typically abstract ) that is usually what is called a "model" (the "M" part of "ORM" as mentioned in the comments to the question above). A typical model class might present some skeleton functionality like: 

Let's talk about the session file save path. I know there was some back and forth on this in the comments, with me suggesting that putting these files in a web directory is a bad security practice. You are right that one could limit access to this directory in other ways, but why would you want to introduce a security vulnerability that you need an additional security measure to mitigate? You are making your application security more complex and more fragile to someone not setting things up properly than it has to be. Additionally, it just makes no practical sense to be putting this data into your application web directory anyway, just from a straight separation of concerns/access standpoint. One doesn't typically configure database files, application logging, or other similar functionality that might read-write system files to do so into the application space, so why would you do this with session data? Ideally, you write session data into a directory only available to the root user or user under which your application is running under to access and you don't let administrators working with the production system have root/sudo access in production unless absolutely necessary.