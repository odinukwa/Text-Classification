@tim has covered a bunch of what I was going to add, but here are some additional points: You should anticipate having whitespace in the input. A "simple" replace-all would suffice: 

This algorithm works in part by relying on the lexical (alphabetical) sorting of any suffix of the input word. Again, using "fubar", the code creates all 5 suffixes: 

should start lowercase. Method variables should always be, as they are never exported. I will duplicate what @cat says here... what's this? (It's a WTF in case you were wondering...): 

This relies on each step having a deterministic restoration, and the array being reverted after each attempt. A bug in the code will screw up that symmetry, so you have to be careful. Recursion semantics I am not a fan of what I call "precondition recursion" (I can't find a reference to different styles of recursion, so this is my name for it...). In your case, you are adding the strings to the bucket inside the loop inside the recursive function. I believe you should try to do that only at the "leaf" level of the recursion. Logically, you manipulate all the characters, then, when no more characters can be manipulated, you add the resulting string to the bucket. In the code it will look like: 

Comparator There is no need for your interface.... what's wrong with ? Why do you need to have your own? The reason you appear to have it is because you need to compare the against another and the generic type is not right for you, but you can solve it easily with wrapping the Comparator in your myTree class when you need to.... So, your code has: 

Inside that method I would still check before working.... Additionally, one of the features that is missing in apache's log4j is the ability to do String-formatted messages... which are so useful in slf4j... String-formatted methods are useful for things like the following... in your code you have (before your 'fix'): 

save away item 2 from listA make item 1 on listB the new item 2 on listA make the saved-away item 2 (now orphaned) the swapped list B make what was the listB item 1 the new listA. 

The other nitpick is the newlines in the block. Yeah, it's a real nitoick, but I prefer a single-line for the , not 3 lines. Still, there is only one instance of this, so at least it is consistent ;-) OK, enough about the trivials.... Minutia String concatenation to get a String value of an Integer is overkill... things like: 

I put this together in an SQLFiddle Bug When I compared my results against yours, I found my index was off-by-one. With the input you gave, I get the first index at field 6, but you have output showing field 7. I have manually gone through the parsing, and I am sure field 6 is right.... so I think you have a problem ... ;-) 

Your problem is an integration and management problem, rather than a programming problem (though there are some issues there too). Approach 3 Approach-3 is a problem, and I would not use it for your task. Repetitive tasks require a well designed and reliable infrastructure to handle them. The quirks of time are such that things like daylight-saving, system clock resets, and other issues will play havoc with things. For example, What will your task do when you 'spring forward' in daylight savings... will it fail because the next scheduled time never happens? In fall, will it go idle for over an hour when the same hour is repeated? Cron (and on many Linux distributions, Anacron) has very well documented practices and behaviours for these types of issues, and the predictable, and reasonable use case makes a lot of sense. Use Cron. Additionally, if there is an issue sending a mail, or anything requiring rescue in Approach 3, you will fail to reschedule, and your program will break. Approach 2 This is actually quite similar to Approach 1, but it just shifts more logic in to the process method, and it mixes up the responsibilities in that method. SOLID principles suggest having just a single responsibility in each method, so I don't like this approach. Additionally, you can only process one campaign at a time using this approach. Too much happening in one place, and possible opportunities for parallelism are removed. Approach 1 I prefer this approach for the relative simplicity of the single-campaign method, and the way the campaigns are processed. Improvements Having said that, there are problems still. The biggest is that your program is not defensive enough. Even though you expect only one instance of the program to be running at any one time, you should still program defensively and assume there could be more. Cron (anacron) will ensure that it does not start a second instance of the program if the previous instance has not yet completed, so cron will not cause a problem, but you may have some mix up happening in your testing, or you may run it yourself when cron has it running already, leading to problems from there. I am not very familiar with RoR, but the following looks like it could lead to conflicts and race conditions with other running processes: 

This is because all the other tables were joins, and their values are never 'selected' or used for 'projection'. Thus, they were just redundant .... 

That should not even exist on the class. It is something that should be calculated outside the class, and even then, should be called or something. I'll come back to this... IntervalCollector This class is where I feel your largest problems are. They are implementation, and usability problems. It boils down to two things, with two consequences: 

I believe your basic algorithm is fine. Shifting only 4 bits on to each byte is not exactly filling the byte, but, there are ways I would consider neatening up the process. Note that this does not change the algorithm much at all. Here are some tricks to note, though... 

Sometimes applications do this sort of thing a lot, and in those cases I centralize these micro-tasks to static classes like: 

Note above how I use the 'diamond operator'. Using the full generic type on the right-hand- side of an assignment is no longer needed. The classes ensure that the memory model for get/set operations are correctly ordered, and thread safe. As a result, the way you get and set the List in that is currently just fine. As ratchet freak indicates, you should probably be using a , and not a . A set offers constant lookup times as your set size increases. If it were me, I would have something like: 

Note, now, that to make a single change to count the number of times that the double-modulo has happened (FizzBuzz), we have added a single line of code, but also modified 2 other lines. Thus, we have had to modify two lines, and add a third, just to add one line. Now, what does this mean? It means someone looking through a 'diff' to see what changed, sees a diff on the line: 

Using the full implies there is a class called , which there is not. The subclass hierarchy is also overkill. I would prefer a single final and immutable class. There is no reason why a single and cannot accommodate both sides of the result (with, and without an exception): 

As for the data structure, since the code is a 'decorator' for an input list, you should just add the parent-node pointer and be done with it. It is something you know in your method so there is no extra work. Alternatively, just use stack, or use recursion. As for the complexity of the algorithm, it is only O(n2) if your input List is an ArrayList or some other O(1) access list. If the input is a LinkedList itself, then your complexity jumps to O(n3). You should find an O(1) way to step through the List in your method, probably using an Iterator instead of indexed lookups. An Iterator over the input is the safest way to do it, but, if you have no choice then in the method you should check to see whether the List implements , and if it does not, then you should copy the input in to an ArrayList, and index-get off the arraylist.... 

The initialize method on the Cell will calculate, and store, the array of neighbours. This will substantially reduce the number of times they need to be calculated. If you have the one-off initialization then Cell->is_sink can take no parameters again. Apart from the restructuring of the is_sink, and the persistence of the neighbours array, I have a nit-pick about some of your loop-conditions.... you often have code like: 

start at the top-left of the matrix scan every position in the matrix for each position, check whether it is the top-left of an increasing square of set values. keep track of the maximum. 

With the above code, you have now set up a general purpose Collatz Stream that is self regulating, and can be used in any way. The code is certainly longer than what you have, but, the result is a lot cleaner, and more versatile. Adding terminal conditions to a stream is not well covered in Java8. I would expect that subsequent versions of Java will have a stream stage similar to 'filter(...)' which will be called and will terminate a stream when the given condition is true. Until that arrives, we have to do it ourselves. Update: I tried to look around to see if there was a more Java8-ish way to specify the Collatz sequence, and figured the right way to do it was to create a generic class for streams that contain a self-modifying stream. Given that the Collatz sequence has a well known terminal value (1), I figured that a construct like: 

good code seldom needs comments good code must make plain what the code does without the need for additional explanation. 

I would actually restructure that loop to make it more apparent how the indexing is done... I would have: 

the top value shows that the sum of factors for 284 is 220, and the sum of factors for 220, is 284. Taking the first value, we know the sum of factors, and we take all the values that sum to that (in this case, just 284), and check whether 284 happens to be the sum of some other value's factors. Then we check to see whether one of those other values is 220. 

I realize that you were only supposed to implement the method, but, the rest of the queue is code that can be significantly improved too. Your queue is a fixed-capacity queue. There is nothing wrong with that (except that the array should be declared as ... ), and, it actually makes some things easier. Like, one of the most complicated things with a circular buffer/queue is to manage whether the queue is full, or empty. at both times, the rear and front cursor are the same. There is a really nice way to solve that problem, which is to not use a rear pointer at all, and to only use the front, and size. Now, your code has the front, rear, and size variables, and it sometimes uses the rear variable, and other times uses the size... and this leads to confusing code. The thing is, that you can easily calculate the rear from the front and size... or, alternatively, you can calculate any one of those three variables from the other two. Bottom line, is you only need two of them, and keeping the size makes other things easy. Here's your code, stripping out the entire 'rear' variable.... Other things I did are: 

Then, with that break-point enabled, you need to debug the program: Right-click on the 'main' word in the and select 'Debug As -> Java Application' This should prompt you to go to the 'Debug' perspective, and you will have a window with the 'Variables' displayed. One of the variables will be and you can expand it to show its contents. Here's a screen-shot: 

Threads In current Java versions there is no real limit to the number of threads you can have running. You are planning on about 500, and this is not particularly concerning. Obviously they will not all be able to be on-cpu at the same time, but that is OK. There is no need to change your thread model for this reason. Using the NIO non-blocking mechanisms may help you reduce thread-count, but for the past 5 or so years there has been a lot of debate as to whether there is any performance benefit from that. It is my opinion that the complexity of using non-blocking channels with selectors, etc. is not worth the effort. Allocating a thread-per-socket is just fine. 

No, while your merge sort appears to be a good implementation of the in-place merge sort, that sort has a complexity of O(n log2n ). While the complexity may look reasonably scalable, the actual surt is quite slow compared to others. Specifically, it is a much slower sort than the native TimSort used by the Collections API in Java7 and above. @tintinmj is right to challenge the use of a String input parameter for . It should be a simple input parameter. You should note that you could get to the faster by moving backwards from the end of the sorted data. If you move forwards you have to scan the entire array. If you move backwards, you only have to go as far as the matching value. OK, so the input parameters are of the wrong type, the sort is more expensive than anticipated, and the final scan could be faster ... but, the real question I have is why not just scan the data once and be done with it.... 

Overall I would have to say that this is the neatest and most clear implementation of a Merge Sort that I have seen. There is nothing wrong with variables , and . They are standard names for looped array indexes. There is a single empty line in your code which is inconsistent with the rest of the method. That is the only nitpick I can find in terms of the style and neatness. It is a tiny, inconsequential thing. The only recommendations I can make, are things that will improve performance, or will introduce some other common practices that may impact readability, though they are still more standard than what you have. First, some common practice things 

This is one way to do it, but the parsing could just as easily be done with a StringTokenizer (and some people prefer this method for a variety of reasons even though it is 'Discouraged' in the JavaDoc). I quite like the simpler process of using String.substring(...). With a simple token system (like a comma) it is easy: