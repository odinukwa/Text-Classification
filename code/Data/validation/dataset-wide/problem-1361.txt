unfortunately we find a big bug - if fails we switch user (and run out of player indices). we fix that later. we continue with 

EDIT: in your second version you use 0 as return value for a not successful search. you should use None instead as this is what you use in prev and next attributes. this would also simplify your code. 

first will always be false here. A tied game would not have continued and the current tie status is still to be checked. Also there is something like a token counter already up to date (). Again there is a superflous check when the counter reaches 9. This could be reduced to 

EDIT One important point I did miss on the first glance. You do sort optionally on conversion or by default on representation. the second one is a bad idea, as you cannot sort comparable objects by their built in comparison functions. instead you force str representation which in terms of sorting is useless. So you shall not force but have the identity function . might be a third option to sort for. To your changed code - let's assume we have to write a function like this. if we have a look at 

As there is no answer yet - some observations in no specific order you miss the top level main guard which allows the module to be imported 

We also have to remove all the column indexing offset stuff as grid is now a real representation of our data. Also we have to remove the spacing from the data values like used to test/set values. 

You already got some advice on coding style. however there is a big flaw in your algorithm which is not addressed by the accepted answer. you try to iterate downward to get an effective implementation but you got the inner loop wrong. while you expect the outer loop to do few iterations your inner loop does check relatively low numbers early. you tried to limit that by stopping the iteration at 900, a magic value without reasoning. so your implementation may give wrong results as a pair of 901*901 is much smaller than a lot of untested pairs. you need at least a check if your product is bigger than the biggest untested one 999*900. on the other hand if we do the inner loop right all problems are gone. we use the outer loop for the lower value and the inner loop for the greater one. we do not need an arbitrary limit any more and we are quite efficient. 

indices in you use a parameter choice which is one-based. most programming language use zero-based indics (offset from the first element). while on the user interface it is natural to use [1,2,3] as choice you should immediately convert this to a zero-based internal representation. this is what other programmers expect (or even yourself in a year) when maintaining your code. 

Indentation is not defined for odd Special case handling for even always prove it is necessary/useful to do extra code. the best implementation (given that it matches the requirements) is the one that is most easy to understand, implement and test. your special looks like a fine shortcut but requires extra testing odd/even. the indentation error would probably not be there when this case had been omitted. however it is needed as you copy all values from the parameter to a set. Parameter name this suggests the imput parameter is a list. however your algorithm could work on every iterable (if you omit the special case) so a name like or would be less suggestive. Copy iterable to set this is a good strategy if the operations beeing performed on the values lateron are expensive and the values are expected to contain many duplicates. if one of these conditions is false - don't do it. as your test is quite cheap (the set containment check is more or less the same as an insert to a set), you could omit all that special case handling and iterate over the parameter once. however if you work on an iterable with duplicates you have to sort out duplicate pairs by using a set as storage for the sorted pairs. also if you avoid the filtering on the input you could adapt to different problem definitions (see problem definition above) easily. 

EDIT: also, from a design point it is strange that and are returning nodes instead of values. you should get returned what you insert. 

the first definitely do not belong there, this shall be done in main or in a UI. for the latter if no user interaction is required this could be logging. if requred it should be done on the dedicated UI. getting the message there could be via return values or more pythonic via raised exceptions. so we remove the print from 

setting default values in you set a default value which is then overwritten in 2 cases. this is a common and accepted pattern if the default value is a simple value (, , ..) which is overwritten in a somewhat complicated decision tree. however in your case all three branches are of equal rank, so instead of 

The answers so far do not address the big design issues properly Separate I/O from the internal data model You have a horrible mix between internal data representation and concrete I/O formatting. contains extra grid characters for output, on the other hand there is handling the extra grid lines. This would not make it difficult to do a different output (graphic?) but also causes enormous pain in column indexing. The data representaion shall contain only cell values in a 3x3 matrix (you may stick to character representation). Drawing separators shall be pusehd to . 

here i used list [comprehension $URL$ Use the right data structures If you want to look up code for a letter you want to write which is clean and readable. so we use a dict for storing our codes 

there we again see a lot of repeated code the only thing differing is the player. we refactor and pull some code outside the clause 

I think you got the optional part wrong. the task is to reduce the given square, not to construct one from scratch. This requires you to hold the square in a representation allowing you to shuffle columns and rows. a set does not keep the order, i suggest a simple list of lists. the challenge requires sorting the first row and the first column, very similar tasks that can be done by the same sorting function if we transpose the matrix. so i suggest to start with a list of rows 

learn to write unit tests python provides built-in unit test support. it is really easy to use and of great use. what you invest in unit testing you get returned in better design, less errors, better maintainability and probably you even save time you use for debugging otherwise. again seriously, you will be a much better programmer when you have done your first little project with unit testing. finally my answer is intended to help you, not to intimidate you. try to understand and get better. if you have questions regarding my points, please feel free to ask. 

Thas limits visibility of name like or . also it adds testability. we can now call from some testcases without needing interactive user input. Further down on internal data representation When doing debugging you most probably do not want to print more likely you want to print . So why not represent the symbols as shorter characters througout the code? We improve our existing function