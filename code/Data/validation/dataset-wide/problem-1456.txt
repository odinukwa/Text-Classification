This will encrypt the string, whereas every character will become 6 characters. The 1st 2 of each character are keys that are required to decrypt the letter, and the 4th character is the actual character being encrypted except masked by a random digit (Basically the letter is converted to its ASCII number and a random number between 0-9 is added/subtracted from the letter). The 1st key (labeled prefix) lets the decrypt function know if the random number needs to be added or subtracted, the random number is passed as the 2nd character in the encryption, and characters 3, 5 and 6 are random noise characters. Note: The prefix is generated depending on the ASCII number of the character that is being encrypted. If this ASCII number is below 44, the random number is always added to the character being encrypted, else it is always subtracted. The prefix itself is a character in a certain range, if the ASCII number is below 44, a random character between ASCII and is generated, any of these characters tell the decrypt function to subtract the random number from the encrypted character, else ASCII between and will always add the number. For example, the string "Never roll your own encryption functions." may encrypt to: 

returns the result of rolling two dice. Be sure to not say that it is the sum of two random numbers. Provide the context for doing that. Explain the rules of craps inside of the function (in the docstring). 

The prompt will wait for the user to input the data, don't make the user wait. Naming conventions for example should be converted to . We don't use the for functions and variables in Python. Instead we use . 

Seems like it can be abstracted, what if the user wants to change the location? Maybe by default use this location, but allow the user to change it. Create a default argument to but give the user the option to specify it. Same with: 

Your code doesn't use pattern matching well (it is kind of unecesary the way you use it). I would advise you take the solution you have and rewrite it to use pattern matching more like the Rosetta Code solution. 

I wouldn't go as far to say that functional programming and Python don't mix, but you should really consider what you're going for while writing it whatever language you are writing in. I would not make your goal: 

I've written a function that allows you to pass an array of values, which is then shuffled and returned based on a parameter . This is the code: 

The first parameter is the array itself, the second parameter is the key that you want to group by, and the 3rd (optional) parameter is a boolean that tells the function if you want to preserve the group key in the sub arrays. Examples Let's use this dataset for examples: 

I've written a simple helper function for my helper class that allows me to check if a substring is in a string. With my function, you can supply either a single needle to check for, or an array of needles to check for. There is also a parameter that allows you to select if you want to check word boundries or not, and a parameter to allow you to choose if the search should be case sensitive or not. 

I've recently written a function that allows me to take a flat array and convert it into a multidimensional array by a specific key in the array. 

There are other small related issues. Docstrings Python has docstrings which are ways to document your functions. It isn't exactly clear what or do at the moment. You have a comment describing . Two things about this comment: 

This could be vastly simplified using JSON and the Python library. tl;dr JSON is a convenient way of storing data (in file) that roughly resembles a Python dictionary. (There are also alternatives to JSON like XML, but I prefer JSON). You can also refactor using JSON. Place stats into a dictionary. I would put the player stats into a dictionary so you can make access stats like: 

Just use . You don't use , ... that often, I would just use to save space. Although there are many reasons not to make code as terse as possible, adding lots of these variable declarations makes your code hard to read. 

Python naming conventions PEP 8 says that functions and variables should use so should be . Naming issues is the best score that you have for all the generations, name it instead. Similarly: . I think is ok. I would have used or but then again it's not really a genetic algorithm so there isn't really evolution so one could argue is better than ... 

My question(s): What shortcomings will I have with these functions? Another question I have is; how can these functions be improved? 

I know what you are thinking, it's never a good idea to roll your own encryption functions, but I'm doing this for fun and self-learning. I created a function that allows you to send a string as a parameter and it will return an encrypted version of the string. Here is my encryption function: 

This function takes the encrypted string and breaks it into parts of 6 (Because every encrypted character is equal to 6 characters) and reverses all of the randomizations that I did during encryption to return the string: 

So you can pass any array as the first parameter that you want randomized, then the 2nd parameter determines how the data is returned, then the 3rd parameter tells the function how many times to shuffle the array. I've written this because I think it will be useful for people on StackOverflow, I see a lot of questions trying to figure out how to get a random value from an array. The parameter tells the function to either only return a single array element if false, or return the whole array (with keys in-tact) if true. As you can see in my code, I have to check for the 2nd parameter twice to do actions before and after the actual array shuffle. I wanted to see if anyone had any advice or knows of any ways I can improve my code. I've been posting a lot of my code here lately, and I really enjoy how much I'm able to learn from answers. Thanks in advance! 

Because the force of gravity is the same for any two interacting bodies, I designed the methods to take another body as an argument, so we can call Distance calculation: 

When the method names you are using are meaningful, there is no need to comment code - it comments itself. If you extract a lot of statements like this, reading the algorithm becomes really easy. It becomes a short list of easy to understand calls, instead of lots of mathematical operations here and there. And if you are unsure about what a certain step does, you can just read one specific method body. A good rule for naming the method could be what I just done - just name the method just like you would phrase the comment. In general, one method should be doing one thing and one thing only. 

It's a small thing, but most code formatters will do it this way, and it is easier to read. The same goes for: 

And more... In your code, you use twice. Now, what will happen, if something (e.g. another thread) changes the after you added all your nodes, but before you started calculating distances? I suggest that you create a local final variable in your method: 

Should be at the top of the inside of the function. (Also should be .) Global Variables Global variables are typically a bad design practice. Move these: 

is strictly increasing. Calling will stop a particular iteration quickly, but really you can stop a whole cycle, switch it out with . 

Optimizations There is a lot that can be optimized when it comes to (). Recall that a number can be factorized as a product of prime numbers: $$p_1^{k_1}p_2^{k_2} \ldots p_n^{k_n}$$ The number of factors then becomes: $$(k_1 + 1)(k_2 + 1)\cdots(k_n + 1)$$ So this is the idea: 

This way we also don't need which you use only once, and is longer than . There may be some performance penalties, but it seems to run fairly well on the example you gave when I run it. 

is the name of the Garbage Collection interface module. It shouldn't matter too much, but, when reading your code, it feels like that you are asking the garbage collector to find books and then I remind myself that it isn't actually the garbage collector.