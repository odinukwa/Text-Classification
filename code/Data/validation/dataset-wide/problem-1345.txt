You'll notice that in each of the four functions considered so far we calculate and then branch based on the result of this calculation. While I can think of other ways to derive a value for they aren't as intuitive as the operator and in the end I think we would still have a conditional statement which decided the final element of the list. Other than adopting the small change suggested by function I think your code is as concise / understandable as it can be. 

Overall I'd say your off to a great start. Here are some of the changes I would consider making to your code: Formating Output When printing strings that encapsulate values/variables you have two (idiomatic) choices in Scala. Option one is to use string interpolation: 

As Illya has mentioned Regex alone cannot solve this problem. Instead, we must employ some type of stack-like data structure to give our program memory of past characters. The first three lines of the main function are just a cheap way to replace blockers with a single character. A better solution would be to tokenize so that this isn't necessary. 

Note that in the first case clause you can replace with any arbitrary constant that you want to match against. In the second case clause simply means match against the wildcard, that is, can have any value or type and the block will get evaluated. As a general Scala tip I'd recommend learning about the many other ways in which pattern matching can be used to create concise code. There are a couple of other places in your code where you could apply pattern matching, but I'll leave those to you as an exercise :) 

Return if any of the inputs are . Let the output value tell you which "bit columns" were found identical. Even if you don't need that knowledge currently, calls to the function like such, 

Use the returned by Edit: my original response directed the OP to use library to parse JSON-formatted text. That was incorrect, as the returned data was already parsed by library. The returned from your function is a of the key-value data shown in your "Results for from " section. Thus, you just need to access the appropriate key of the (specifically, the keys in the of the returned data). To access the and fields you were looking for, they are under the key: 

This cleanly separates the business logic of the game from the mechanics of running the game multiple times. Also, it frees up to return the number the number of guesses the user took, so that (or other calling code, in the future) can collect statistics about gameplay. 

Edit: Original code masked with , which was erroneous. Mask (corrected above) should be . Note: I have use casts because per the C11 standard, ยง6.5, para. 4 (emphasis mine): 

When the data doesn't have any values, my algorithm appears to be about 15% faster. When the data has lots of values, there is not an appreciable difference. This makes sense, because most of the time, every set of {a, b, c, d} statistically should contain two values. This shortcuts the differences between our algorithms, leaving only (in those cases), just checking for . 

CASE CLASS I would change to a . One reason for this change is more concise object declaration, e.g: 

Below are some of the changes I would make to your code. In my opinion one of the nice aspects of Scala is that it gives you all sorts of ways to reduce the amount of work your mind has to do in order to decipher code. As an example, one of the first things I did was declare a type that is equivalent to . I then just substitued where necessary and the code (to my mind) became more readable. The choice of was arbitrary on my part, you could if you wanted use instead. Along these lines I shortened all of you variable and value names. As the program is set up right now you don't need to pass in a array, but I left it in anyway. As you mentioned this is a homework assignment so I'll leave a bit of mystery as to why this is. And really you don't need the and the . Next note that is equivalent to . And finally (for now) checkout how I initialized and . If you still would like to use your function you should look into the method called . Cheers. 

Here are some changes that you could make to your code. I'll explain various parts of the script below. 

provide the same logical information as calling as you originally posted it like: . But with this suggestion, the following information is available: 

Because everything you want is under the subdictionary, I would just reference it () at the end of the call). Here are the combined suggested modifications (using the list that returns, and using ): 

Thus, for ultimate portability, and to satisfy pedantic compilers / analyzers, use types/casts with bitwise operators. Providing more information (return value) If you have the leeway to change the specification, you could make a couple changes to the function to increase the information it provides to the caller: 

That means there are (16 choose 4) combination = 1820 possible input combinations, much less than 65,536 (or 16 * 15 * 14 * 13 = 43,680 permutations if order matters). However, that knowledge does not change the algorithm or opportunity to improve the performance. But what about the differences between the algorithms? I ran the same test inputs (including identical random data) against 3 other functions: your (but sans checking for ); my (sans checking for ); and finally, my (also sans checking for ) but following my suggestion and returning more than just or . Here are the CPU times (in seconds): 

is undoing the work did for you (which is the entire reason for using ). Instead, you should do this: 

Well, that about sums up the changes I would make. If you have any questions, don't hesitate to comment! :) 

With the above code if I set to my run time dropped to ~70 ms (naturally this number will vary on different machines). This code is a bit more bare-bones than what you have and may not fit your style but it is quite a bit quicker than what you have posted. The significant changes are 

When pattern matching and inspecting multiple values of a sequence type (, , , etc) you can reduce the length of your expression by using sequence patterns instead of explicitly breaking the sequence up with the operator. So instead of you can more concisely use . When you want to check for explicit values while pattern matching on an object you can use those values instead of replacing them with variables that are then checked with an statement. For example can be more concisely expressed as When using pattern matching on sequences (especially when the expression goes beyond the standard ) it can enhance legibility to use single letter variable names and comments instead of long variable names. I think that we would both agree that good code should describe itself through both value and function names. However, in this case there is no way of adding intuition with function names and so all of the description ended up in your value names. Like I said before, do what works for you. If legibility was our only metric then maybe pattern matching isn't the ideal way to implement your function. It could still be recursive, but instead of s you could use functions. Do whatever suits you the best but when possible I would recommend short variable names accompanied by comments over long variable names. 

This is one of those happy instances where optimization will increase performance, maintainability, and readability. But first, Analyzing your specification With what you have described, the example outputs you have provided, and the code submitted, if I had to back-derive specifications for , this is the best I could do: 

Now maybe your use case does not care about which bit(s) is/are common. But one of the nice things about C's design, and most idioms in C, is that truth is reduced not to and ; but to and anything but . I will come back to this point in my suggestion. Recognize the opportunity to work in parallel C's bitwise operators are just parallel 1-bit logic functions, so there's no need to check for individual bit positions one at a time; bitwise operations do not "interact with" neighboring bits (unlike mathematical operators, which have carry / overflow). So, to check if any of the "bit columns" in {, , , } are all : 

Note that unlike in the case for , we must mask with (because assuming bits 4-(num bits in int) aren't set in the inputs, bits >4 will always match as "all zeros"). Below is the rewritten which matches the specifications (i.e., it returns strictly or as described above): 

Let's compare your implementation of to my functionally equivalent implementation. For testing, I created 2 datasets for input. One dataset ("Permutations") is just all the permutations of a, b, c, d (non- inputs, values ) (that's 164 = 65,536). The other dataset ("Randomization") is 65,536 randomly-generated sets of {a, b, c, d}, about 50% of numbers are , the rest are more-or-less evenly distributed between 0 and 16. I ran these datasets through our implementations 10,000 times. Here are the process's CPU times (in seconds): 

Swap a linear operation for a constant one Currently the function is appending () objects to . is a so this append operation has a complexity that is linear in the length of . You can remove this overhead by refactoring into a which can perform the append operation in constant time. If you wish you can check out this link for more details on performance characteristics of various Scala collection. A minor redundancy It looks like you could remove the that occurs within because it is called immediately before on the same object in . 

Style When you declare a type of a function, value, or variable, add a space between the and the type. 

Another benefit is that automatically becomes a field for any object (this is also possible with standard class declaration by prepending to the front of the parameter.) These two examples don't really demonstrate the full utility of so if you'd like to learn more check out this link. STYLE Current Scala dogma utilizes camelCase. So I've swapped and for and . I also added a return type to your method . A QUICK NOTE ON TYPES One of the cool things about types is that they allow you to constrain your program. For example, as your method currently stands there are over twenty different collection types (of the mutable and immutable variety) that may be passed in for (see these inheritance graphs). Long story short, I swapped for . STRING OPERATIONS Finally, to get around calling I utilized a method from StringOps called which returns if the caller and the input are equal (regardless of capitalization), false otherwise. To be honest I only changed this bit to show you another possibility. 

Not only does this tell us if any "bit columns" are all , it also tells us which bit column is all (any bits that are in all of the input variables are set in ). Note that there are no logical operators here (i.e., , , ). This is important for algorithmic optimization because logical operations can "stall" pipelining or cause branch mispredictions, which can kill performance. For checking for "bit columns" of all , we could use the same concept (but with inverted inputs) as such: . But that's not taking advantage of our knowledge of Boolean logic. Recall from De Morgan's laws that (that is, "(not A) and (not B)" is equivalent to "not (A or B)". Thus, we can calculate as: 

All of the masking with individual bits and logically comparing values really eats up your performance on the randomized data. For the ordered permutation runs, it's likely that some compiler optimizations in conjunction with branch prediction helped out your times (because every group of 16 calls to had a, b, and c identical, varying d. This is evident because for the randomized data runs, your original algorithm suffers a 3x performance penalty compared to my implementation. The Takeaway This is probably one of those cases where, if performance is really important because you're operating on a lot of data, or you need hard real-time performance, that it pays to take a step back, and reconsider the data flow. If at all possible, removing the cases where you're checking the inputs {, , , } for will yield 2x-3x improvement in the algorithm computations. Alternately, if there's another way to handle those cases (mathematically, instead of conditional-logically), then you can just operate around the issue. 

For more information check out this nice write up on Scala collections that is co-written by the creator of Scala, Martin Odersky. 

Note that in Scala you don't need to use a statement as long as the last bit of code in your function returns a new value. 

Hmm I'm not sure what the requirements for 'python koans' are, but if you are getting counted off for the conditional, here are two alternatives: 

I would say that your latest code looks fairly sharp. However, after translating your code to something I could test, I noticed a pattern that could be captured with the code below: 

That is, this solution produces the same output as yours does for the tests that I performed. The intuition: you are essentially building a grid-graph sans the middle-parts. So we iterate over the range of possible points, but only keep those which are on the exterior. 

Style Comments Methods which take functions as parameters ( and in this case) should be invoked using infix notation. That is, if there were a god of Idiomatic Scala Style he would prefer to Defined functions should use camel case, e.g. over . In general, and you will get a feel for this the more you use Scala, pattern matching is preferred over if-statements. You will notice that in your function I've swapped your if-else statement for a pattern match on the value . The last style tip I have for you is to break a chain of higher order functions over several lines. This last one can be fudged in some cases, but in general I find that it improves readability. Efficiency Comment The one change that I made in the name of efficiency was to change the container type of from to . The reason I made this change is that accessing an item in a takes linear time on the length of the list, whereas accessing an item in a is almost constant. And as you know, you are accessing elements of by index is in the last line of .