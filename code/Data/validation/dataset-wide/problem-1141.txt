First of all: It is necessary to create one table for each task? In my opinion: No You can create only one table "Tasks" where you define a name for your Task and define your standard properties of a task. Whenever you want to create more tasks, then you need to create new tables every time. As an example: If you want to save humans, you don't need to create tables like "female_childs", "males", "females", "died_females" or whatever - Just create one table "persons" where you can store stuff like "gender", "alive", "birthDay", "deathDay"... Your Question: Order of execution In this case, what you need is some sort of sequence to order your tasks. This can be stored in a new table alongside with your device, like that: 

The website (html5,utf8 all over) using the database displays those characters OK I can import the dump without issues with point (1) above still holding If i "fix" the dump - replacing the pairs with the char that should be there, point (1) above unravels - the browser now shows the familiar question marks on inverted background that is the familiar placeholder for "bad" utf8 sequences. The issue depends on the client: I can SELECT from mysql and have the double-encoding as in mysqldump; OTOH if i GET the web page (composed by php with charset UTF8 connection) I see regular (not doubled) UTF8 sequences. Even weirder, I can obtain correct looking results in mysql/mysqldump if I specify --default-character-set=latin1 (!!!). In this case, however what I get does not round trip cleanly as the UTF8 counterpart does. 

Since I encounter some performance issues on my SQL Server 2014 (12.0.2370.0 (X64)) I'm dealing with enormes amounts of different wait types. One of the top 5 wait type is "DIRTY_PAGE_POLL". I've read this wait type will only appear when I activate the "Indirect Checkpoint" feature, which is a part of the sql server since sqlserver 2012. None of my databases has set the Target Recovery Time. So, why is my SQL Server polling for dirty pages without the indirect checkpoint feature? 

Sometimes I encounter the same issue and the answer of Henry van Megen is the really last step I would ever take to fix this issue. Luckily this never happens to me. When I encounter this problem, I've got this checklist: 1.) Shrink Files, but just with [Database]->[Tasks]->[Shrink]->[Files] (You did this with a script) 2.) Backup (Full- and Logbackup) For my Full Backup, I take this snippet: 

Missing support for AUTO_INCREMENT columns in multiple-column index for InnoDB tables is a widely known limitation, as is the trigger workaround for when it is needed (see e.g this post). Yesterday, however, I ran into this thread claiming support for this feature was added as early as 5.1. I tried the following statement on my 5.7 install (mysql-community-server-5.7.19-1.el7.x86_64), and it appears to work flawlessly: 

My problem is that, for the life of me, I cannot find a positive statement of support of the feature on MySQL's documentation site - or elsewhere. I am rather wary of deploying in production something unannounced (which might be experimentally present) so I hope somebody can point me to the official status of this. Edit: It turns out that the manual contains, in parts unrelated, this rather oblique statement: “…an InnoDB table with an AUTO_INCREMENT column requires at least one key where the auto-increment column is the only or leftmost column.” which suggests, but does not state, support. Edit 2: Using information from @rolandoMYSQLDBA below, I also located this additional snippet: "An AUTO_INCREMENT column must appear as the first column in an index on an InnoDB table.". I am therefore accepting his answer. And in case someone is wondering, the multiple column index thing is needed for table partitioning - the customer has auto_increment PK on all tables and they want to partition on a date column. 

In the most cases, this will shrink the files. But there was two cases in my years of SQL Server experience, even this did not help. This was the way I solved the cases 1.) Backups (Log, Full) (Use the snippets I provide) 2.) Change Recovery Model to Simple 3.) Backups (Log, Full) (yes, again) (Use the snippets I provide) 4.) Did the file shrink? 5.) Yes -> Change Recovery Model to Full (or Bulk, whatever you had) again 6.) No -> Repeat Backups, Follow with Step 7 7.) Kill all Sessions 8.) Backups again, Full and Log (Use the snippets I provide) Now the files should be small. If not, do the method recommended by Henry. This will be the last thing 

Edit: The accepted answer is right on the money. I had since found about mojibake through different channel and expanded my woes in a blog post. 

ie: 1 UTF8-encoded char is seen as 2 L1-octets and each one gets encoded in UTF8 again, ends up as 2 UTF-8 encoded chars. So the first question is "where is this happening"? But the really funky part is that 

I'll describe right away the problem, and put details at the bottom. I am dumping a database which I am fairly sure contains (almost: a few cells have wrong, latin1 encoded data) only UTF8 data. Also I have done my utmost to ensure every part of the chain defaults/is set to UTF8. Problem: all UTF8 chars appearing in the output are screwed up as in this example: 

I think I've got your confusion about these dynamic task properties but as Basil Bourque describes, you need a "child" property table to store information like you want to do it. Your third question is now obsolete :) 

after research, I had found the answer. The Problem is the @performance_condition, my example will not work. But if I add a "SQLServer:" at the beginning of the Condition, like this: 

In many strange cases, this will not help (as your case in example, because you did this). The next Script with the "TRUNCATEONLY" Keyword was my savior. 

This is the Key to add custom warnings to Sql Server 2014. I believe this is a bug with the new SqlServer2k14. Regards Björn 

All of the above confirmed by examining outputs with a binary editor (even though i have LANG=en_US.UTF-8 and UTF8 char display is OK) What I would like to see, obviously, is a clean UTF8 mysql environment which displays the same independently of the client. This is really driving me up the wall. Any ideas? DETAILS: Running mysql-server-5.1.73-5.el6_6.x86_64 on a Centos6 machine. my.cnf (relevant) settings: 

This is what happens if - at some point - a UTF8-encoded character is interpreted bytewise as two latin1 characters which are then UTF8-encoded. Edit: What is happening is along the lines of: 

PHP connects with explicit utf8 charset and PDO::MYSQL_ATTR_INIT_COMMAND => "SET NAMES utf8" EDIT: Create table statements are like: