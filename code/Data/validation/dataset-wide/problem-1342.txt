Tests - Writing code for tests / testable code Your method exposes two public methods for populating the grids initial values: 

A few thoughts... Unreachable Code When you an exception, execution jumps to the associated block (if one exists, or the program crashes). Where you've introduced your throws in your Point class to replace logging you've left subsequent lines intact: 

I'm not really a VB.Net'er but you appear to be able to achieve what you're after using the . It allows you to make your property a Friend so that it can only be accessed from within your module. However, it's not ideal, as you have to create the widening operator in your class and any inheritted classes. Depending on the number of different field types you may end up with more typing. I found that I had to change the method to , rather than in order to get it to be called on derived classes, but that might be because of my lack of VB.Net experience. It also works by creating new instances of objects so there is some overhead. An example of what it looks like is below: 

start_listening There are a couple of issues with the naming of this method. Listening has certain expectations in TCP. Namely that you're listening for incoming connections. This isn't what your 'listening' for in this method. 'start' suggests that the method is going to 'start' something, where as it actually seems to contain the entire thread function for reading events from the socket. Both of these seem misleading, so I'd reconsider the naming. Thread life cycle You start your listening thread when the tcpclient is created and then cleanup after it in the destructor, however it is possible for the thread to terminate earlier than object destruction. Just looking at the public interface, I would assume that I could reuse the same instance of tcpclient to connect to different endpoints, send/receive information, close the socket then do it again for a different endpoint. However, once the socket is closed the first time, the thread method will end and there is noway to restart it without creating a new instance of tcpclient. static to hide implementation You're declaring comms_event and socket_ as in the implementation file. The main problem I have with this is that it is effectively turning your tcpclient into a singleton, but without being explicit about it. It would be very easy to try to create to instances of the tcpclient and connect them to two endpoints, without realising that they were sharing the same underlying socket handle. There are better ways to hide the underlying implementation. callbacks I'm not familiar with the std::function you've mentioned at the end of your post, however there are two alternate patterns that I've used with callbacks. The first is to pass an extra parameter (usually a ) to calls to callback functions, which is registered along with the callback. This allows the callback to interpret the received information, based on the the supplied value. The parameter value could be a high level connection identifier, or some classes pointer, the tcpclient doesn't need to know it just saves and passes on the value. The alternative I've used is to register an event receiver interface, rather than callback methods. So you would define an abstract base class: 

If it is only concerned by the clicks, then great, you only need to worry about clicking the mouse. If the program does care about the movement then you might want to think about using the function, which supports an additional parameter . The default speed is 20, with larger numbers being faster so increasing the number should either make the function return faster, or allow you to wait for less time before clicking. Depending on whether the movement is async, you may also find that you need to wait less time for shorter movements (i.e. the mouse will get from 8 to 7 faster than it will get from 8 to 1). Clicking the mouse After you click the mouse, you wait before doing the next thing. You may be able to make it so that you don't need to wait as long by using playing with and passing in different values for which is how long the mouse button is held down for. Alternately, depending on how your application works you may be able to detect that the mouse click has been recognised (because some pixels have changes from red to green for example). The library appears to have a few functions that might support this or would appear to be good starting points. You could then loop until the click has been recognised, rather than waiting. 

Just a couple of things to add to what @yitzih has already suggested: Watch your imports Try not to have imports in your code that you don't need. For example, in the code you've posted you've imported even though you don't need it. Split Your split line seems overly verbose. The default behaviour is going to be , so you don't need to specify it. You can get away with just doing: 

Leaky abstraction Your contains a public method which returns a raw handle to the socket. With it, a client can call any methods it wants against the socket (send/close/recv) without having to use your abstraction layer that you've built. This method shouldn't exist, it undermines all of the other protections you've put in place. This can obviously cause issues, since for example your call in needs access to the raw handle, however the number of classes that need access to the raw handle should be limited and IMO explicitly managed through the use of s. Naming is a bit too close to datagram socket, which isn't what it's modelling, it's constructor explicitly sets it up as a stream socket. I prefer to model it as such by either calling it or . Connect is an action, so is something I would expect to be used in a method name, not in a class name. Connectable would be better (although personally I would merge the functionality between and together because they both only really work on streamed sockets. ConnectSocket - DeadEnd provides a default constructor which doesn't do anything (). Why? Protected members stores information as protected members (port and addr). doesn't appear to ever be used and port is only ever used in the constructor, why isn't it just a local variable? There's a similar situation with , is never set, there is a constant that is protected (does it need to be, rather than private? does it even need to be a class level constant rather than a method level?) remove_socket It looks to me like remove_socket iterates through all of the sockets, even after it has found the one it's looking for. Are you expecting the socket to be in the list more than once, or should it return after removing the first one? 

compute_edit_distance This method feels like it could be useful in different scenarios. I wonder if it should perhaps be called and perhaps pushed out of 'main.c' into a utility file so that it can be reused. Leaking memory Your method is leaking memory. It calls and assigns the return value to which is cleaned up, however when you call , you're not using the variable you're calling the method again to allocate another copy of the value: 

SurveyMemoryContext Is this actually production code, or does it belong in your Test project because it allows you to run tests without hitting an actual database? Either way, I'd consider changing it to a , keyed on the , since Id is your main search criteria. What happens if an invalid Id is passed into delete? It seems like it should at least return the result of . 

malloc Vs calloc isn't guaranteed to return zero initialized memory. Since you're using strcat to append to the buffer, you should really ensure that the memory is a null terminated array. You can either do that by initially null terminating it (as in my example above), or by using calloc instead. 

Initialise your variables You aren't initialising . This is probably working for you, because the compiler is setting it to 0. This isn't guaranteed though, so you should be explicitly initialising it before you use it: 

Naming Think about your variable naming. You've used for your local variable, however your parameter names are and . Do they mean anything without looking at the rest of the code? Break down the problem into methods The code below looks like it represents rotating the array by 1 place. If so, put it in a method with an appropriate name, then call it. It will make the problem breakdown easier to follow. 

I've developed a spreadsheet that has evolved over several years to help keep track of the number of student contact hours that have been used to help flag up when students have run out / are running out of allocated hours (so that additional hour requests can be made if necessary). There is a master workbook, which contains the VBA (below) and several worksheets. There is a "Master" worksheet, which is used for the consolidated view. This has columns for the students name, allocated hours, total hours used and then several columns with one for each month. 

One letter variables One letter iterators are ok, however when you start getting multiple iterators in the same method it may be worth giving them proper names so that it's more obvious what's going on. This is far from transparent: 

Your method doesn't check that accessing isn't going to overflow . This seems like the responsibility of the class. I'd say, if they start adding letters after a valid pin, it should reset to not correct anymore (rather than throwing an exception that could give the caller information they might not know, such as how long the PIN is). One way to achieve this would be to add a wrap to the increment: 

They don't tell me anything about what it is you're expecting the methods to do. An alternative might be something like this: 

By definition, if is 'F', it can't be 'E' or 'D', why bother testing the isFalse condition, it just muddies the water? The is particularly confusing as to what the intention of the test is, because you're not only testing true and false conditions one one of the variables, you're also calling the function under test with multiple strings. Keep your tests simple and try to focus on just testing one intention per test. Naming Naming is also quite important in tests to help the purpose of the test across. Rather than , perhaps would have been a more expressive variable name. 

This is because your is using the return value of to indicate two things. It either indicates that has failed, or it indicates as in my case that the call to failed. min3 When I first saw your method, my initial impression was that it seemed quite verbose. You've already defined a macro in 'telephone_book_utils.c', why not define a MIN macro: 

you declare a variable , which you use to try and connect to if fails. The variable you're declaring has the same name as an existing variable declared at a higher scope, however the one you're creating is scoped to within the block. This means that when you access the variable later in main to read from the socket: 

Duplication There's a lot of duplication between your spells. You basically have two types of spells, those that change Visibility and those that change Size. If you created two base classes that allowed the target size/visiblity to be passed in, then your Normal/Small/Enlarge spells become simple wrappers that only have to pass the target size down to the base class. Spell Construction Consider passing the Goblin into the constructor for your spells (as a target parameter). If you throw an exception if this parameter is null, then you can assume that the goblin exists in your other methods which removes their null checks. Spell Stack Whilst the way you've modelled the code makes sense, I'm not entirely convinced by the non-additive nature of your spells. If I started off with a 'Small' goblin, I'd expect Englarge to make it 'Normal', then Enlarge again to make it 'Large'. 

In your while loop is redundant. The slow pointer is always going to be behind the fast pointer, which has already performed the null checks. 

Formatting The first impression your code makes is not a good one. The formatting is very inconsistent, which makes it difficult to follow and is likely to introduce bugs. If it looks like this in your IDE, then you really should expend some effort in fixing the formatting (any version of visual studio will significantly help with this). Copying and pasting the code into your questions, then selecting it and pressing Ctrl+k will format the block. Nested using statements Looking at this code below, which I've formatted: 

In order to support development, I wrote the following tests (apart from , which was supplied with the challenge). 

Is the SizeScale_ actually relevant to the test (are you testing subtraction, or subtraction for specific scales?) I think the bit that's missing for me (and is the mostly subjective bit) is that your name doesn't specify an expectation. So instead of I have to read the test to figure out what the expectation is. 

In addition to the main points already raised by @Hosch250, your code feels incomplete. You've declared as returning an , however you neither return a value from the function, or use the returned value. You may also want to consider your names for variables / methods. doesn't really tell the reader anything about what the method does. 

The server itself listens on a known port and keeps running until a line is received from the console. It consists of 4 classes: 

You only need 1 terminating null at the end of the string. This is already accounted for in the size of (since you declare it as a string initialized ). You can simply allocate: 

I've done similar things in the past, although never with a scripting language and I haven't used Pascal in a really long time, so this is more of an approach review than a code review. The action happens in : 

This could be refactored into a method that takes the winning player number. There are other repeated blocks that again could be refactored into functions to reduce the overall amount of code and make it easier to follow the logic. For example, ?: 

That way the value of the enum is actually linked to the character it represents. This makes it possible for your to become: 

At the moment, you only update the variables if the is the same as the object receiving the call... which already has those variable values. 

The line is too long and you have to scroll a relatively long way in order to find out that it's the only parameter passed to the function. If it was: