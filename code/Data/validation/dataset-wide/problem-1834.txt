Since the certificate is for mail.example.com it thus matches the name used for connection and thus the certificate can be successfully validated. The PTR record should point back to to play well with spam filters. 

Benchmarks are lies, don't reflect the reality but might be a useful tool to detect bottlenecks. But you have to understand the benchmarks. Given that you omit essential details needed to understand the benchmark results it might be that you don't really understand what might affect the results of the benchmark. Especially information about the size of the test payload and detailed CPU load information for server and client are missing. Thus it might be that you are reaching CPU limits on the client or on the server already. It might also mainly be a problem of the more round trips you need for the requests. Let's explain the aspects of HTTP vs. HTTPS in more detail: 

This tool is not designed to create a gateway from SSL to SSL. What you need in your case is just a simple TCP forwarder which can be done with socat: 

This is not a problem of using content across domains, but across protocols. Mixed content means that you try to include resources via HTTP (unencrypted) on a HTTPS (encrypted) site, no matter if this is the same host or a different host. This warning is because some of the content is protected while the other is not and thus can be changed from a man-in-the-middle. This effectively can make the protection from the original moot. 

This is not possible. To use an existing certificate to sign another certificates it must have the appropriate purpose and extension set, so that it can work as a CA (certificate authority). End user certificates don't have this extension. You would probably be able to use your certificate to sign a new one, but this new certificate could then not be validated because the issuer certificate is no CA. 

No they won't. Mail delivery between mail servers is done by looking up the mail server responsible for the recipients domain using a DNS lookup for the MX record. This record contains a hostname and this host will then be contacted at port 25. There is no way to somehow configure a different port, i.e. if there is no server on port 25 the delivery will fail. 

The only thing which matters for certificate validation is the domain name used to connect. Since this name does not change on DNS CNAME you get: 

With this cipher string you allow only ciphers which were introduced with TLS 1.2. Since no new 3DES ciphers were added with TLS 1.2 no 3DES ciphers will be used with this string. But, no TLS 1.0 or TLS 1.1 client will be able to connect to the server since none of the ciphers you offer is supported by these older clients. While modern browser all support TLS 1.2 some applications still don't. This is true especially for older Java applications or for OpenSSL based applications on Mac OS X, since this is shipping with a very old version of OpenSSL. 

Given that the device will not usually have a public domain name you cannot get a certificate from a public CA for it. And, even if it has a public domain name it is usually in control of the customer and not you so you cannot get a public certificate for it either. The common approach is to create a unique self-signed certificate for each device and expect the user to add an certificate exception. Additionally a way for the customer to upload his own certificate should be provided so that the customer can integrate the device better into his own infrastructure. 

The first line enables listening on port 443 on IPv4. The second line covers IPv6 only. Since you have only a single (IPv4) configuration it is the one which gets used if you connect with IPv4. If you would try to connect with IPv6 instead SNI should show the expected behavior. Instead you might probably use for the default server: 

You've configured to use 200 concurrent requests. The size of the request is unknown so we can assume that there will be only minimal payload. You are also using no HTTP keep alive which means that there will a new TCP connection for each request. I doubt that apache bench is doing TLS session resume so that there will a full handshake each time. Which gives you: 

Mail clients which properly check the certificate will fail but many mail clients have an option to ignore certificate failures. Most mail servers do not properly check the certificate and will accept anything. 

I did not even look at the rest of what you are doing but OpenSSL 1.1.0 simply does not support TLS 1.3 yet. TLS 1.3 is support starting with OpenSSL 1.1.1 only. See Using TLS1.3 With OpenSSL for more information. 

If you are using different certificates with different hostnames there should be no problem, even if the certificates are wild card. If you instead use different certificates with the same hostname (i.e. different IP address and server, but same hostname) you might run into problems because this setup is valid but unusual and at least security extension like Certificate Patrol will probably complain. 

If you try such requests with other servers then they would either close the connection without any error at all or just hang because they are still hoping to get a TLS handshake from the client. 

stunnel is a program to create a gateway between non-SSL and SSL. From the description on the home page: 

SNI support is in HttpsURLConnection for a while. But if you do anything more advanced you are probably using the Apache HTTPClient library and Android SDK contains only an old version which does not support SNI. To make use of SNI you have to be aware of it and then you can work around this limitation, see $URL$ 

More proof: The TLS 1.2 standard (RFC 5246) lists in appendix A.5 lots of ciphers usable with TLS 1.2, which includes several 3DES ciphers. 

Knowledge of the RSA private key is only sufficient if RSA key exchange is done. Modern systems instead use Diffie Helmann key exchange (DHE*, ECDHE* ciphers) to provide forward secrecy. In this case the private key is only used in authenticating the server but not for the key exchange and thus knowledge of the private key does not help in getting the encryption keys. Instead the SSL pre master secret would be needed since this is used to derive the encryption keys. While some browsers support exporting this secret in some special debug modes other clients usually don't. As for your specific problem I would instead to try a man in the middle "attack" which logs all traffic in plain even though the client gets encrypted traffic. This works similar to man in the middle proxies for HTTPS, only that it supports the initial plain connection and understands that STARTTLS upgrades to TLS. From a quick search I've found starttls-mitm and that sslsplit has some beta support for this. Of course the client needs to connect to the man in the middle proxy and trust the certificate it gets, which might be the original server certificate since you seem to have access to this. Another option would be to enable debugging in the specific MTA in case this provides detailed enough information for your specific problem. 

In this case you redirect from one hostname to another hostname. The target IP address might be different but it might also be the same if both names are hosted on the same system. But this actually does not matter. All what matters is that the hostname in the URL must match the subject(s) of the certificate. And the redirect changes the URL and thus might change the hostname of the URL. It does not matter if there are different IP involved or not: if the hostname in the URL does not match the subject of the certificate the validation will fail. Thus what you need is either: 

Sure, a passive man-in-the-middle attacker can catch the encrypted packet - that's why you do encryption. But because each SSL connection uses a unique encryption key the attacker cannot use this sniffed encrypted packet later to inject it into another connection. And as long as the encryption key is not compromised (which means for RSA key exchange that the private key of the certificate is not compromised) the attacker can not decode the sniffed packet. Apart from that an active man-in-the-middle attacker might put itself in-between the parties, e.g. instead of Alice talking to Bob Alice will talk to Mallory and Mallory to Bob. To make this impossible you need the identification part of SSL, e.g. certificate checking and verification of the host name (one alone is not enough). Only this makes true end-to-end encryption possible.