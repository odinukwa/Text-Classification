Ok, with the new design both services can still send messages but you can send a new message each time instead creating a new instance just to send a new message - so they are now real notification-services and not just notifications. 

You can greatly improve it by staring with proper names. The first enum is actaully a comparison type so name it like so: 

While making this work by implementing extensions for the and for the second is a nice trick the usage is very confusing. I don't know, maybe it's the example or maybe I don't get it but wrapping a with a only to be able to use it with a query doesn't sound very useful. The expression means that I evaluate each element of a collection but what does mean? What am I evaluating? Its properties? Its fields? Its constructors? No idea. The second line is even more confusing. What does mean? Am I looping over validation results? No! I'm looping over a person again! This is not just confusing, this is super confusing. No the biggest surprise, does not retrieve any but another . It's a func-ception :-] Nice work making it work but based on this example I don't see any practival uses of this pattern. 

The underlying data type is still so the interface does not protect the data from being overriden. Consider a user that writes a function like this one because he doesn't like interfaces :-) 

Here I don't like the magic and and the variable . We usually start with unless the variable has a special meaning. In this case you could even use an that would be much better (because it stands for alpha) then a which doesn't mean anything and with two constants the code is much easier to understand: 

Nothing is hard-coded anymore. The only thing you need to ever adjust in case of more social link types is probably the view but even this should render just fine without any additional maintenance. 

It's actually not uncommon that you have both the interface and a class that implements it the way you did it. In order to make the interface reusable for both case you need to make use of generics and add a new generic parameter to that the list will be using. It would be a good idea to constrain it too with on 

Parameters Use (overloaded) construtors where appropriate to create the modules and initialize them to a correct state. 

From this interface you can derive all your connections. There you can have a default constructor to create default connections or a parameterized if you need a different connection string (for example when testing): 

Notice that the method's name is now because by convention we add the suffix to methods. This is not a bullet-proof solution if you want to access the properties manually because it will throw if a key does not exist. You might want to use if you need to but it'll do for the current scenario otherwise you should implement the getters this way: 

This could simplified with which would stop checking other properties if the result of would be for any of them: 

because of the not clear intention I had a hard time understanding this short code. The descriptions says something else then the implementation. 

With encription it might be important that you don't have memory leaks. The CreateEncryptor Method () returns a ICryptoTransform Interface that requires to be implemented. For example: 

This parameter could have an interface like this one where you can pass it directory name, file extensions and whether it should search recursively: 

I'm not saying that these variable names are perfect but without knowing your exact use case there's not much you can come up with based on only a few lines of code. But I think you know what I mean. I still find this nested s aren't pretty... but at least they are less misterious now. But this is how refactoring usually works. You change your code a find a new pattern that you can replace with an ever more efficient code. So the next step could be replacing the magic with a constant and use the null operator in conjuction with coalesce: 

You can use the extension to group the emails by validation result. To access the collection you use either or . With this approach you can split the invalid/valid email handling. You also should put the very long pattern in a constant. 

LINQ with extensions The second alternative can be implemented with which agian, uses the same algorithm. 

but if you need custom event args then you should create a new class derived from and with the properties that you need: 

although this is not yet exactly what you have because this will yield only exact matches. If you want deparment-name to be null then you need a left join and I think this should work: 

I managed to rewrite most parts of it and I think it's much better now. It shouldn't be anything fancy, just a simple data validation helper that I guess most of the time will just check if something is not . Thus no stuff etc. because it should not contain any business-logic. 

or with pre-reflection you could have another function that takes a collection of properties that you want to compare: 

The method itself can be simplified. You can use to get rid of the indexes (unless performance really, really, really matters). Sometimes it's also prettier to use the + where you can assign all values in a single line to avoid duplication like: 

If you were applying for a position of a senior developer this code would be unacceptable. I would expect from you: 

Then I end up creating a bunch of similar class that mostly differ only by the name. I thought there must be some more efficient way to do this so I've been experimenting with a new idea that I call the . It is a special exception that gets compiled at runtime and contains only the most basic properties. 

I like the ternary operator but in this case I wouldn't use it because a single expression that makes sure both variables are valid and then searching for the strings is easier to understand I think. The isn't very pretty, especially the part which actually should be . You could get rid of it by filtering the array and skipping the empty and null elements. 

Finally, one may dislike the fact that useful functionality is buried in nested functions; we can pull the nested functions out: 

There is a fair amount of room for art and style in formatting, so don't take any particular suggestion as "you must do it this way" — in fact, I've mixed a couple different styles into the above example. The goal is to write code for which it is easy to see what the intention is, and without much clutter. You can improve readability further by realizing you don't need the , and can simplify to printing newline characters: 

Making a local variable will likely result in a performance increase. It would also allow multiple threads to safely invoke concurrently. Similarly, making static will increase performance. Not directly, but because the current design will tempt an application to create new objects all the time whenever it needs to perform a sort. 

If you feel it's important to write the code so as to start with an empty list and extend it, you could instead use 

This advice is likely to be somewhat controversial, but Explicitly flush when output should be available 

There are times when it makes sense to have some sort of class whose instances are objects that can perform a bubble sort. This is typically when the algorithm might need access to some precomputed data, or maybe to acquire resources that will be reused through several invocations of the algorithm, or hold configuration options, or is keeping track of performance metrics, or other such things. (but this pattern has its own advantages and disadvantages and there are other patterns that can be used to achieve that effect) However, this implementation is very much not one of those times. 

I'm going to focus on implementing the recursion. First, let's avoid the globals. The easiest way is to keep the same structure, but move it into a local namespace: 

Use the memory management tools the standard gives you In particular, should be of type , not . The memory management you are doing is a standard and common thing... and also well-known to be an extremely common place for programmer errors. Use the right tool for this job, so that it's easier to write code, less likely to have errors, and more obvious to the reader what your implicit intentions are. (and yes, you do have errors — for example, the way you wrote the code requires a destructor to deallocate the memory, and you don't have one!) You have a const correctness error is a const member, but it returns a pointer that would allow the user to modify the contents of the string! If you are going to have this function, you should have two variants 

I've mainly just made a function sets up the right arrays, and then converted the original implementation into the nested function . Notice I've created a array for storing the results. Also notice the need to make a copy of the potential answer when storing it as a result, since we will continue to modify . I've also modified the list of words so there is more than one result. I assume you want to obtain all answers; it shouldn't be hard to modify this to end the recursion as soon as an answer is discovered... however, a better approach will be described below. Given this change, the arguments to are redundant: it can be changed to the following. (if you're really serious, you should profile this change, to determine whether it actually makes things faster) 

There is a better way to implement the design you seem to be using. Rather than generating numbers and storing them in a list, just generate the numbers: 

Generally speaking, buffering is good for performance, so it's better to write newline characters rather than inserting when you don't actually need flushes to happen. As a bonus, they're less typing and usually easier to read. Of course, I/O performance is basically irrelevant here because the human delay far outweighs any other concern — but it's good to get in the habit of writing what you mean early on. Thus, the above code snippet demonstrates the general pattern: I use newline characters to write newlines, and I do something to flush the stream at the point I want to ensure that all of the output has been written. Using to do the flush isn't an option here, if I want the flush to happen at the right place! 

One issue is that your function is four functions in one. The problem is that they are four unrelated functions — yes, they all have the job of displaying results, but: 

So, in my opinion, the better habit is to flush explicitly rather than relying on implicit behavior. (the opposing opinion is that one should be much more afraid of the second bullet than of the risk of confusing/erroneous output in the edge cases) This program, I'm pretty sure, is an example of the first case, where it doesn't actually matter. 

In the source code, you can collapse a lot of the output statements to improve readability and so that they take up less vertical space. For example, 

and let manage the allocated memory, rather than managing it manually. Similarly, in , you have declared 

would be better. In fact, you might consider doing something different: you could pass around by value rather than by pointer. Passing these objects around with move semantics may turn out to be more efficient. (you should probably explicitly deleting the copy constructor and copy assignment, to indicate that they shall not be used that way. Although this will automatically happen implicitly if you follow my advice and change to be a ) 

While some would advicate relying on the implicit flushes coming from being tied to , my own observations are that: 

The usual way to implement the algorithm you're using (the sieve of Eratosthenes to find all primes up to a chosen bound) is to make an array of boolean values, so that means is in the list, and means that is not in the list. The point is that removing an element from the list only costs time, so it can be done much faster than erasing an element in the middle of the list. (and also, you don't even have to bother checking if the element is in the list before you remove it)