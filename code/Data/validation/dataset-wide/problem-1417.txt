A school of thought is that one can also use the argument type(s) to simplify the method names. In other words, if the method name says it is parsing from , why not accept a object then? 

Defaulting to properties inside the You should perform validation inside the , and to either warn callers of invalid values, if not to throw an . Even if you don't and prefer to silently use the default values, this is what you can do: 

One generic (pun unintended) suggestion: Use braces for your statements to ensure you do not accidentally introduce bugs, because it makes the presentation clearer. Minor points: 

In this approach, the second filtering condition checks if the of the 'requires map' contains the same entry that will be removed from the entry in . The first filtering condition is required to ensure at least one of the value is a , per your question. Still, this assumes that all the entries' values will strictly adhere to the general contract of , i.e. there is not going to be a case of (since ). You should also consider using a more appropriately-typed class instead of the checked . Over here, lambdas do no deal with checked exceptions, so I have used as an example. edit Since you want to also log all duplicate keys before running the value checks, you can insert a step in between your (now two) filter steps: 

edit: (prompted by OP's first comment) Wells, this shouldn't be recommended on CR but just for fun, I tried golfing your method and reduced it to a few ternary operators as a 'one-liner': 

Using a effectively Since you are already using a as the underlying data structure, you need not check if it contains the incoming number or not in as any implementation will not store duplicate values. Also, to skip the first element in the , you can do: 

This simplifies the nested s we have by flattening that multi-key structure into a single object. Achieving what you require is a simple continuation on 's , with a mapping function to turn into your required : 

If you do an early from the -check, you can reduce one level of indentation. You also eliminate the possibly redundant declaration too, when the -check holds true: 

First, there's the class that facilitates this already, so if you're not reinventing-the-wheel, then you may like to consider using that class. Other pointers: 

I'm curious as to why you need to specify the number of times (attempts?) to decode such values... Also, do you have access to ? Because if you do then it's easier and shorter to do via a simple Perl script. ;) To check for (or equivalent) inputs, I think a better approach is to normalize the casing first, then apply a case-insensitive : 

Use to convert the array of arrays to a stream. ... will be explained below, essentially we need to convert to just . Use the reflection-based method to create our generic array. is called twice, as the first time only gives us , and the second call on that will return . 

In turn, you can then create a method for that can iterate through its (assuming it's one of the Collection classes, like a ) to generate the desired output: 

For starters, using Java s will likely save you a lot of the boilerplate-like template code you have for and . Your constructors seem to be over-engineered too... what you have are just permutations of s, s and objects arguments... I suggest you pick one and stick with that, preferably just and . If your objects are meant to be immutable, I'll suggest saving its representation (used, naturally, in ) as an instance field first. In fact, you should probably go a step further and override the and methods too to simplify/standardize such usage for the class. This will be helpful if you are using them in most, if not all, classes. Unfortunately, your implementation for doesn't seem too good... First, I'm not sure what it's meant by 'fully' capitalizing a . I thought you meant converting a to uppercase. Turns out you are just capitalizing the first letter. So why not call that then? 

Your and method names can be improved, since a game is technically neither a winner nor loser, but won or lost. Therefore or may be better names here. You also have inconsistent usage of braces for your statements, I will suggest using them throughout. This is mainly because it eliminates the possibility of introducing bugs when you have introduced a second line seemingly within an existing block, but is actually not. The indentation of your methods are also weirdly left-aligned, and I'm not sure if this is a side-effect of using the Markdown formatting. Please check the indentation of your code too. 

Spelling 'occurance' should be spelled as 'occurrence'. :) Stream-based processing: Since Java 8, you can stream on the characters of a with (or if you need Unicode handling) and then count the matching ones: 

Get a by the given . each stream element to the desired representation (tip: you may want to introduce this as a method in ). each element into a by them with . 

should really be inner class within , since it it not expected to be used standalone. Also, assuming you do not want to modify your existing APIs for , consider writing helper methods for unit testing to facilitate the repetitive pushing of values into your instances: 

One significant change here: accept variable arguments ("varargs") as the name implies one can add one or more patients (of course, null/empty checks should be done here). The interface: 

and hard-coding file paths You should use on your for safe and efficient handling of the underlying I/O resource. Is there any special reason why you have went with a decidedly non-Unix line-separator () while writing to a seemingly Unix-based filesystem? Also, do consider not hard-coding the file path and take that as an input from instead. edit: Since you do intend to write to a file using OS-dependent line separator, consider using a to do so too... 

Spelling is (surprisingly consistently) misspelled as , it's highly recommended to fix this mistake. :) Stream-based processing You can take advantage of the semantics in Java 8 to express the steps in another way: 

Here, we use as a method reference, and join the elements together with the provided header and footer (assuming these are returned as s too). 

at all. What is the purpose of passing in so many arrays for the method? You can inline the call from this: 

Simply put, you only need a -implementing class that knows what lines to read as the table name, the columns and rows. 

Besides the slightly odd class name (nothing wrong), one suggestion I can make is to use some sort of a builder (or "fluent"?) pattern to construct your linked lists... Possibly along the lines of: 

If should be used only by , consider making them . Ok, so even if you prefer not to use regex (fair point), how about ? I feel that it's easier to read than the condition you have, short of the one-liner regex: 

Also, you mentioned the getters only, so I guess there's no excuse for . :) Reading it as is easier on the brains. Avoiding code repetition If you take a closer look at what you're doing now, it really boils down to these steps: 

The first step also takes care of a array, by treating it as an empty stream. The second step replaces each element with its contents on a resulting . 

Since is given in proper (for some definition of 'proper'), you may want to stick to that convention and call your class . I noticed that in your and methods, the dot () is separated from the method call when spanning across lines. I think that's slightly unconventional, unless it already is your convention. :) Also, you should be using instead of in your Javadoc for the monospaced font to be used and rendered correctly. Putting it altogether The refactored code for can look something like: 

General suggestion not related to the sorting implementation: You should be timing the time it takes to call and return from your method, not the time it takes to call and your methods as well. Furthermore, a better microbenchmark calls for running a few iterations and then taking averages to smooth out outlying cases due to "warm-up". Also, I will suggest using a instead of since your presumably do not require synchronization here, and append values one by one instead of concatenating them together: 

This is a simplified implementation, and there's definitely room for improvement for the condition checking, such as using the range of methods to test for whitespace or digits. The other major benefit to using an array is that you can loop through it too: 

Since the Java naming convention for values is and we want to display a more readable value on the GUI, we can use an to store these representations. The three s is used to store the appropriate types, and we will need to create getter and setter methods for them (using as an example): 

If you are appending a single character, do something like instead of . If you want to use , use it efficiently. Better use of 

Still, this can be defeated if there are multiple spaces and they happen to also be at the start and/or the end. Perhaps a regex solution may be better here... this shall be left as an exercise for the reader. Boolean flags Going back to your method, you wouldn't require if you have separated the logic that validates the user input and the actual work. 

This is ripe for SQL injection attacks, so let the underlying database driver handle parameters for you directly! Furthermore, comparing your and statements, it looks like the positioning of your prepared statement is different from the actual table schema returned by . This makes the code look slightly confusing initially: the user type is ed via but stored as . Standardization will help eliminate these kinds of false bugs. This has a decent example of using with a query. Reduce your scope Somewhat related to the next point, but having a shorter scope makes it clearer what methods can throw what kinds of checked s, which will facilitate understanding. Not recommended (roughly putting it in your context): 

Mathematical approach You may want to consider using a faster mathematical approach to test if the number is a positive power of two or not... 

Now, I put a (^) on the second condition, and you see that we only compare above. That is because according to your logic, we will on our loop when , and this will bypass the comparison of the two largest numbers with too. As such, our first statement inside the 'super' statement will be the condition to (note how I turn the meaning of 'not lesser' as 'greater than or equals'): 

Your approach As pointed out by the other answers, you are practically hard-coding whitespaces in your arguments, which can get non-standard easily, even in your example. Otherwise, the use of is sound, although it wouldn't deal nicely with a single value - the loop will fail as it implicitly tries to get an for it. Java 8 An alternative is to rely on the stream-based processing that Java 8 offers: