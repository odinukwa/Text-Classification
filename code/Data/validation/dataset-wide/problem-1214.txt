This will turn into . Unlike the other answer, this function supports spaces in attribute value and I have casted the value into a numeric type when it's really a number rather than a string 

Have only one class directly interact with your database. It doesn't make sense for your class and it definitely doesn't make sense for your to be executing methods. Think of what a nightmare it would be if you decided to change database drivers to or the next greatest thing? You would have to go into all your classes and even your regular scripts to make adjustments! A much better approach is to interact with the DB only from your class. Put the generic there. As much as you can, avoid writing queries in your general scripts (such as ). Instead, craft them within methods that live in the class you want info from; methods such as and would make sense. The reasoning is the same as for my last advice; if in the future you decide to change your DB table structure, or use a different storage mechanism altogether (not MySQL), it would really suck to have to go into all your scripts to change your queries. It would be much easier if your queries are concentrated in a few methods I don't understand why you didn't combined the two lines below... 

It assumes that the existence of in the session is proof of authenticity. If your user doesn't log out, anyone who uses his browser much later to come to your site will be admitted; likewise anyone who logs HTTP requests and later looks at the log will find the session cookie and can impersonate the user. To fix, store a date in the session when the user logs in. Then when you check for credentials, you only admit the user if the login validity has not expired. Your site is vulnerable to Cross-Site Request Forgery (CSRF). Suppose your logged-in user visits my website where I have something like: 

You're right, you should avoid querying in a loop as much as you can. If were 30, I would run a query like: 

Notice that this is a singleton . There can never be more than one object in memory. This is to ensure that all your scripts are storing and retrieving data to and from the same cache. You would use the static method to grab a reference to the cache. Since the method is static, you call it on the class itself (). Once you have this in place, when you need a value that may be cached, you check for it in the cache first. For instance, suppose you previously saved the sport type data under cache key "sportsType_123". In your controller's function, change your code from: 

Because browsers send cookies automatically with every request, the user's cookie will be sent to when the browser tries to load the image, and your script will treat the request as legitimate, therefore it will act on . To fix, set a token in your response headers when the user logs in, and expect the same token back from the request headers from legitimate requests. The two points above lead to a modification of . When the user logs in, you now do something like: 

You take the existence of a cookie as proof that the user is logged in. Nooooo! Anyone can send any cookie named anything to any site. There are a few good alternatives, but at a minimum your solution must ensure whatever you get from the user (eg: cookie, token) is vetted before you do anything else. You insert what the user provided directly in your MySQL queries. This is death if anybody wants to hurt you. Never trust content supplied by the browser as safe even if you wrote the website/client application. Look up and use parameterized queries. You use really weak hashing of your passwords. This is too easy to break. Use PHP's built in functions and You were smart enough to get started and build a working program, and insightful enough to hash your passwords and to realize that you probably missed some things. You'll be alright :-) 

Then when a user logs in, you verify the submitted password against the hashed password. Do something like: 

This should give you an array of rows, each row would have holding the number of days between today and last seen day, and holding the number of records that were grouped into that row. The result set is also ordered with the fewest inactive days first. Your PHP script could then use that result as needed. If you fetch the array and call it , you could do 

It's great that you use prepared statements to prevent SQL Injection, but this code is evidence that you're storing the passwords in clear text, without hashing. This means that if your database gets stolen, the thief will know your users' credentials, and can use them to impersonate the users on other services. It also means that anyone with access to the database can do the same thing. Instead, when a user registers, hash the password before saving it. 

...with equivalents that would match whether the email is lower, upper or mixed case. The simplest way is to lowercase the address before you do any processing. 

Be sure to test! I may have a bug in my code, but you get the gist. If you find a bug, leave a comment asking me to fix it. Don't do anything you don't understand. Take the time to learn what each line of code does, so you can get better, catch errors and even improve upon it. If the order of the results doesn't matter to your logic, don't use the clause; sorting is computationally expensive and should only be used when needed 

In general my approach to finding the culprit would be to then comment out individual steps of the operation and run the script, watching the memory usage. Eventually you'll pinpoint the memory hog. 

My function does not use hard-coded attributes, so it is more flexible than yours. It's also just a few lines of code (I think you made things over-complicated by having very thin wrappers for and . 

Your intuition that your script is inefficient is right, so you have good instincts. Don't worry: once you're done optimizing you'll be amazed at the difference. 

Will cause the new lines and blank spaces between PHP blocks to be echoed to the browser. Since this is not your intent, it can result in unintended and difficult to fix problems. Change to: 

Now you can safely put in your query. Suppose an attacker sent in a dangerous parameter as the such as The code below would transform these ids from the dangerous: 

You should rewrite your code to access the DB as few times as possible. Reading from the DB is an expensive operation, because it requires PHP to connect to DB, send execution instructions, wait for results, parse results and make them available to your script. Notice for instance that in , your prepared and are identical. You're forcing your DB server to do the exact same work multiple times ( is executed in a loop). Why not call once and just bind different parameters to it before executing? Better yet, can you compile all the s you need and make the query once? Start to think in this manner to reduce DB queries. When you access the DB on every iteration of a loop, you're really paying a heavy price. For instance in , you execute a query to retrieve all the data for a particular , then for each result you execute another query to count the rows in table that belong to this follower. Look around resources/forums to figure out how to do this in one query that will return . Trust me, it can be done (hint: look into SQL operations). Only select the data you need. For instance, instead of in , if all you care about is the so you can match it against the same ID in table, then use . The bigger your result set, the more memory your script will use. NEVER sort if you don't need to. Sorting is really expensive. If you only care about the number of results (in ), why are you sorting the results with ? Imagine if your boss asked you to sort all the words in this post alphabetically and report how many words there are. I bet you won't bother to sort the words; you'll just count them and report the total. Sorting is hard work.