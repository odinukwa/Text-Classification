I've guessed that the parameter was actually the rotation speed from a comment in the method that calls it. You need to improve your naming throughout. Your code is very simple but is very difficult to follow simply because the naming is so poor. 

The important thing here is that you use ReadLines and not ReadAllLines as the latter will load the whole file into memory. I'd love to suggest improvements to the part where you compute the 'strongest path' but I don't know what a 'strong path' is and I haven't been able to find a definition with Google either. One other thing I would suggest is that you don't ... use a specific exception type or don't catch and wrap them at all. 

In this case, your manual reset event will never be signalled and the code will never finish executing. Eeek! As was introduced in .Net 4 you may as well use another class that was new at the same time . 

I prefer explicit access modifiers on everything. e.g. . In Unity, with the whole public field thing, it can make the class easier to skim as well. 

Thread synchronisation It's generally one of the more difficult parts of programming and this is just wrong: 

It operates on an not just an array which makes it more generally usable. I also think using string.Join is more readable than a foreach loop but your mileage may vary. 

I'm going to disagree with everyone else about your use of the Sku struct. Well done. It's exactly the sort of thing that should be encapsulated, it's an important domain entity in this line of business. In Domain Driven Design (and other books/blogs/authors) the concept of "primitive obsession" is often raised. Let's take email as an example: 

Don't have time for a full review but hopefully this will give you some food for thought. Why add an extra variable ? Angular is more than capable of binding to an expression: 

My question is simple, is there a better way of doing this? Note that I can rely on the inputs always having a unique Id as this is an ASP.Net application. 

I can't really understand what you're trying to save the position for. Or even how you're attempting to do it. You are sending messages to the motor and it's sending things back. You get a message, you figure out what it means and act on it. You're also mixing with they both use the same underlying memory stream and you should be using one or the other - not both. You're also freezing your UI for large chunks of time while you wait for operations to complete. It's fine to accept the command from the user and then update the UI as the action progresses. E.g. show the current position as the motor is rotating, when it gets to the right point, stop it. 

It's basically the same, but it looks a little clearer to me. If you don't want to use the builder, you can at least fully interpolate your strings: 

If all of the implement how do I know when to stop enumerating? I think it's a potentially confusing API design. There's also no way to go back to the property name as far as I can tell - in your colour example how do I know what colours are in it? I don't see what all of this buys you to be completely honest. 

This is dangerous: you can't make the guarantee that the child node will be a text node. For example, say that I have this console message: 

Get exclusive access to the buffer (slow) Add a character to the buffer Increment a shared field (in a potentially dangerous way) Release the buffer (slow) Potentially throw and catch an exception 

Running the above outputs a map of "costs" that looks like this (which is obviously a river with a boat house next to it ;) ). I've used the convention of origin in the top left with increasing down and increasing to the right like it does in the html canvas. (Edit: No it doesn't! Should have used for the x axis, not ... Result is that the origin is actually in the top right and x increases to the left.) 

Did you know that blocks? Your code isn't asynchronous at all - and it can't be unless is. Effectively your code is starting a new task and then blocking while it completes - there's no benefit to starting the task at all! As a small aside, is easier than using . If I were you, I'd just remove the Task. 

That remainder 7 is bad news! That means the first 7 elements have 5 numbers that will produce their index and the others only have 4 numbers that will. I.e. your passwords aren't truly random. You can add a guard to make sure you don't use the number if it lands on one of the "unfair" numbers: 

The reason I'd do that is because you're otherwise forced to loop through the other repositories' locks which will never match - i.e. it's a waste of CPU. With the above (very rough, possibly not working) approach you only loop through the locks which are taken out within the current repository. I also removed the Lock property as I don't see why you would need that :) 

All your class is doing is keeping an array as a field and replacing it every time you modify the collection. It's not a very efficient way of doing it. As I said, you should be keeping an array with spare capacity that you resize when you need. 

You're not afraid of long names which is great. Descriptive long names are definitely better than vague short ones. I think you could probably make the code slightly easier to read though: could be ccould be or could be sounds like a bool or a method that returns a bool. The dictionary is a collection of ids to a value indicating whether it has been initialized but you don't need that. You could just try to get the value out of for the given TId and if you don't have one then run the getter function. I find and a bit odd, and might be more standard. You're mixing bracing styles here: 

Having said that is a bad name, it's too similar to and doesn't even hint at the internal behaviour. You should be checking that and . Update: If you want to catch exceptions and rethrow them as an AggregateException, add them to a concurrent collection e.g. so you don't need to worry about synchronisation. 

This will just return the filename. This overload could be used by your MainWindowViewModel (bad name btw): 

You have another problem - a captive dependency. You have a Singleton (as it's static) that holds a reference to a unit of work (through the settings service) which shouldn't be kept alive for the lifetime of the application IMO. 

By making the piece class abstract, we are saying "you can't have a generic Piece, you have to have a specialized subclass". Let's see what that some of those might look like: 

That's the essence of it. You could also use property injection but I don't know enough about Unity to advise on the best way of doing it in Unity. There's a lot of examples of FizzBuzz around (especially here) so I won't really go into detail about that. Note however, that you have factored out the strings to constants (Fizz, Buzz, FizzBuzz) but you haven't done the same for the numbers (3, 5, 15). You'll notice that they are actually paired together - might want to think about suitable structure for storing that... C# constants are generally named UpperPascalCase not ALL_CAPS_SNAKE_CASE but I don't know whether Unity follows a different convention. Anyway, FizzBuzz is generally just a test of whether you can write even the most basic of programs - if you have a solution that works you'll probably get through. Edit Just thought I'd nitpick - your comment is incorrect - it's actually