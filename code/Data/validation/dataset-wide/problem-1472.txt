On the first match, when is a , will contain a reference to the . When we get to the loop, is now a reference too. Generally, when we iterate on a reference to a collection, the iterator emits references too. Indeed, is now a reference to a . Here, I wrote to match the dereferenced value (note that this doesn't necessarily copy or clone the whole ) because we bind values, which are cheap to copy, so we bind them by value, not by reference. Finally, let's simplify these nested matches. Let's look at first: 

You don't need to do that, since returns a , and is the maximum value. A condition such as would always be false. 

Now, it's up to you to decide whether combining the two validations is worth the additional complexity or not! :) 

Here, we're merely computing a value, so functional style is appropriate here. I'm using ( is a shorthand for ) to simplify the matches where returns . I need to use a couple times to turn a into an , because takes by value but we don't own either in that function. I've replaced the loop with , which takes care of exiting early when a value is encountered. ( does the opposite.) We could also use to remove one level of nesting. 

I present you my own implementation of the algorithm, based on a slightly different C++ implementation, which is why there are so many differences compared to your version. I wrote this about one year ago, but sadly, I no longer use it. Note a few things though that are not necessarily relevant to the code review: 

Here, you know exactly how many elements the will have before you return it, so you could allocate it with to avoid reallocations while filling it. 

The problem is that by putting a lifetime on itself and using that lifetime for the returned references, the user of is free to choose whatever lifetime they want (actually, any lifetime that outlives the , since you can't pass a lifetime that's shorter than the type's own lifetime). Here, the lifetime that's used for is the lifetime of . To fix this, the returned references need to have their lifetime connected to the lifetime in the or parameters on 's methods. However, if we connect a return value to the lifetime of , that effectively locks until the returned reference goes out of scope (even if the returned reference is an immutable one, it keeps the mutable borrow active). Naturally, this would defeat the point of the interner, so we'll have to stick to . That means we'll also have to use a wrapper that provides interior mutability in order to mutate the . I'll be using below, which is fine for single-threaded usage; you'll have to switch to if you're going to use the same on multiple threads. Regarding good practices, I've noticed that you used as an identifier in . Normally, identifiers beginning with an underscore are used to suppress warnings about the identifier being unused, but you do use it here, so you should not be naming that identifier that way. I renamed and below. Otherwise, I don't have anything else to say, this is very clean code! Here's the fixed code. I've left explicit lifetimes in the code to better highlight the difference between your version and my version, but in reality they could all be elided. Note that it's no longer possible to box a while maintaining references to string slices, so I've commented out some parts of your test function. Also, my no longer compiles, which is what we want! 

The function takes a by value, but doesn't take advantage of its storage — it's forcing a move for no reason. To make the function more general, it should take a slice instead: 

The sorting part doesn't produce a value, it merely mutates an existing value (the vector), so imperative style fits best. I'm using to simplify the matches where we only do something on one branch. Other details: 

The second in ends the function, so we don't need the operator. Instead, we could use to replace the data in the variant while keeping the the same, and then just return the result of . 

This block is useless, because you are unconditionally setting to 1 after a couple of other blocks, and you don't read back the variable between these assignments. 

If you really need a , then you'd need to define as and write instead of . However, I would do this differently. I'd write a function to turn a into a slice of bytes (), which would encapsulate the only operation of the program. Then, we can use a simple loop on that slice to print each byte. 

If you want to combine the result of with the range checking in a single operation, that's possible too. First, let's look at the "lazy" way, where both error situations will produce the same error message: 

Instead of checking if the parse succeeded and then unwrapping the result in two steps, you can combine the operations by using pattern matching instead. Here, an expression will do the job. 

The parameter doesn't have to be a , it could be a slice instead (). However, if you had used a non- item type ( is ), then in order to return individual items from the input , you'd either have to the items or move them out of the (using ). You've implemented binary search by hand, but the Rust standard library provides a very flexible implementation via . 

Strings in Rust are encoded in UTF-8. Standard library functions operate on Unicode code points, so both the string and the separator can contain fancy characters. 

Here, the branch evaluates to and the branch diverges. When the branch is taken, the statement breaks out of the loop, so the expression never produces a value. Rust handles this gracefully without us having to put a dummy value on the branch just to get the types to match. 

Note that the function plays a very important role that would be lost if it was inlined (by hand): the lifetime of the returned byte slice is tied to the lifetime of the input parameter. It's as if it was written thus: 

Here, I'm using to convert the to an , because I'm too lazy to define an error type that unifies the parse error and our new out-of-range condition. Then I'm using to perform the range validation only if the parse succeeded. The closure returns if the value is in range, or if the value is out of range. Instead of using , we could also use the method provided by the crate. It takes a closure that returns a , and returns if the closures returned , or the original value otherwise. 

Here, we have three cases to handle, so I'm using a expression rather than an expression. I'm taking advantage of the fact that patterns can match "deeply" to match on two levels of enums at the same time. also has an method, and naturally, the closure must return a . I moved the closure out of line to keep the expression being matched on short enough. 

In general, using for the error type is not a good idea, because taking a decision based on the contents of a string is not very robust. It's preferable to define a struct or a enum that implements the trait. The trait also makes it easy to compose errors in a complex program. Normally, iterator adapters take ownership of the original iterator. This is true of the iterators in the standard library; for example, takes by value, and the struct doesn't have any lifetime parameters. The reason is that an iterator adapter often consumes the original iterator to perform its own iteration (assuming it is driven to completion). On the other hand, yours takes the original iterator by reference. This is less flexible, because it means that I can't write a function that returns a unless I received an iterator of bytes as a parameter (I can't return a that refers to a local byte iterator, because the byte iterator would be dropped when the function returns.) There are cases where it's useful to use an iterator adapter without giving away ownership of the original iterator. For these occasions, we can use to give a reference to an iterator to an iterator adapter. Mutable references to iterators are iterators themselves, thanks to a blanket implementation in the standard library (). In your iterator's method, the in the loop in superfluous. I only write when necessary; when I see a , I expect to find some code after it, and when there isn't any code, it makes me wonder whether I missed something. In your iterator's method, you use to refer to the encoded string and to refer to the decoded string. and are similar terms that don't carry any meaning. It might be clearer to name them and , respectively. 

When you move a value from one binding to another, the two bindings don't have to agree on mutability. It may sound strange, but it's valid to move from an immutable binding to a mutable binding. It's perfectly safe because in order to be able to move a value, there must not be any pointers to it, which ensures that you have exclusive access to the value. Therefore, you could write here instead of . The pattern is so frequent that Rust has a shorthand for it: the operator (and its predecessor, the macro). We could rewrite your program using the operator like this: 

I would call the variable , shadowing the outer variable. Inside the branch, there's no reason to access the outer variable, so why not reuse the name? Instead of a expression, you could use an expression. For example: 

If you were to take by mutable reference, rather than by value, then the original variable would indeed need to be declared as mutable. You could not invoke the function with only an immutable reference, because closures can't be invoked from an immutable borrow. If that's a problem, switch to instead. 

Instead of having a mutable variable, I'd factor out the code that decides if a number is prime in a separate function. We can use early returns to avoid defining a mutable variable. 

Additionally, considering the way you've written the prompt messages, it looks like there shouldn't be a newline after the prompt, so I suggest you change the that prints the prompt to a . Here's the revised code: 

should be a boolean instead of an integer. Rust has a built-in boolean type, , and the keywords and , which you can use instead of and . 

Here, you're not using any borrows, so we're only concerned with bindings. Note that values are not intrinsically mutable or immutable. Therefore, when you move a value from one binding to another, you can change the mutability. The methods and take ownership of the , therefore they can decide to declare as mutable, even if the original value is not declared as mutable. For example, this is valid: 

would sound better as a factory method on , i.e. . In , you can turn the s into iterators, the two iterators together and that into a new . defers to ; implements and uses the iterator's to reserve enough memory for the reported minimum number of items at once, whereas repeated calls to may need to reallocate a few times (which may mean copying the 's items every time). (Note: we don't need to call on , as will do it for us. However, you could still do it if you like the visual symmetry; it works because iterators implement .) In , you can use on the range iterator to turn it into an iterator of key-value pairs, then collect that into a . In and , you separately assign tuple struct fields to local variables. You can use a tuple struct pattern in a statement to destructure the tuple struct and assign all fields to local variables at once. (This wouldn't work in because of the casts.) The patterns could also be used in the parameter list, but I find that they're too long here. In , you repeat the condition. I would reorder the conditions to avoid that. In , you can construct by getting an iterator from the and collecting it into a . This works because 's iterators iterate on key-value tuples, which is exactly what you're putting in your vector! In , you want to order by in descending order. However, the way you do it will panic when overflow checks are enabled of the coordinate is equal to . A safe alternative is to just perform a bitwise not on the value (this is written in Rust); we don't even need to cast to ! In , you can combine the two calls to into one: make the closure return a tuple. This works because tuples implement (for up to 12-tuples). So instead of sorting by , then by , we can simply sort by . When ing on a reference, it's typical to use the dereferencing operator in the match expression instead of repeating a reference pattern on all arms. In , each arm repeats the call to with only the character value differing between each arm. I'd make a method on that maps a shape to a character, then use that method to determine the character to write. 

Don't put a space between an identifier and the colon that precedes a type ( rather than ). Put the and the on the same line. 

I am not aware of any safe method in the standard library to do this, so we need some unsafe code. In your code, you have two blocks. However, the first one is unnecessary: you can use to perform the cast, but you need two consecutive casts, because we can't cast from to directly. Actually, you should use here instead, since you don't actually mutate the referent. So, instead of , you can write: 

You use an implicit and an explicit return, but both could be expressed as implicit returns. Alternatively, change the path to use , then you don't need an block and you can reduce indentation: 

You just have to initialize it before reading from it; if the compiler cannot guarantee that the variable will be initialized at that point, it will raise an error. 

We can eliminate the clones on the addition by requiring and using addition on references instead of direct values. introduces a higher-rank trait bound – we need this because we want to implement , whatever the lifetime is. 

In , you use byte literals to check which range of ASCII codes the byte falls in, but then you use "magic numbers" in subtractions to refer to ASCII codes. You could use byte literals again; this would make the code clearer. 

This is a very generic function: the parameter is used to extract a particular field from each item in the slice. I was using this function on a slice of objects and I was interested in finding increasing values of a particular field of these objects. The function returns indices into the slice, not the values themselves. I needed to know the indices of the items in the longest increasing subsequence because I had to do something else with the items that were not in the subsequence (without destroying the original sequence), and using indices was the easiest way to do that. If I wanted to return the values without consuming the original sequence, I could have returned a of references to the items instead (). Single letter variable names don't really help to understand the algorithm. Since I was using this algorithm for practical purposes, I took the time to understand and document it. If this is just an exercise to learn idiomatic Rust, I suppose this kind of detail doesn't matter much. I like your use of a loop on a reversed range iterator at the end. I should have done that myself!