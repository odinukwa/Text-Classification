The first pass is similar to your File.eachLine() loop except it's done with Collection.inject(). The inject() method Closure returns a List containing two items: the line which matched the sourceMatcher regular expression, and a List of the entire file with a null inserted as a place holder for the destination of the matched line. The second pass is actually not executed right way. Instead, a Closure coerced into a Writable is returned for later use. The returned Writable contains the code needed to write out the changed file. Using InputStream.moveLine() With the Writable on hand, it's now possible to write the file with the line moved. But to even use the InputStream.moveLine() method the Category in which it's defined needs to be made available. the Object.use(Class) method does this. 

You can use Groovy to generate the Groovy source code. The source code generator Here's an example source code generator. 

Leverage the GDK Early in the script, you have a variable which is used to ensure all of the rows in the map are of the same length. The variable is not used elsewhere. So to limit its scope, you can refactor the validation using : 

This is reaction to comments: firda: Why do you have all those small classes connected through properties instead of using class hierarchy? I would create SearchRequest and UpdateRequest both derived from Request, while making SecondAction virtual get or protected set. Any problem with such solution? archytect: That seems logical, but it's not easy to grasp. Could you provide some code to better visualize it? 

Stateless C++11 allocators Allocators were at first (my opinion) designed to be simple empty classes / templates, to just call or similar function. They are treated this way as if copying was no-cost. I would personally design it in a bit different way, but I understand that it is what it is. Allocator must therefore be either empty (with only static/shared members) or a reference/pointer to the real logic. Using is therefore fine and satisfy the stateless requirement as I understand it (it handles the destruction as well). boost::pool as allocator This is actually something I have used myself for tiny blocks. It can help a lot if your application needs to allocate many tiny objects (2-3 pointers/integers per object). But beware... used in std::vector But vector is not so good with such an allocator, would be. The problem is that is an array, which reallocates as needed. That often means that new array is created, items copyed and old array destroyed. Container that does not reallocate its node would be better (e.g. tree or deque). In better words: would better be utilized with such "no-destroy unless deleting" container. using single allocator in multiple containers Yes, of course you can. But take care about thread-safety and copy/move constructors (which you solved by using ). the code Well, your indentation may need some improvements, your last line looks like you have the counter outside of the class. But other than that, I can see no errors. 

Since , , and are public, you can just pass the to the instead. Also, has so much functionality that it might as well be a class rather than an enum. In fact, it would be even better if it's an interface: 

After loading the parameters into a Map, a Range is created from the start and end values. The added method calculates the fizz buzz and returns them in a list. The method is used to iterate through the fizz buzz list and write it to the output sheet. Finally, the output is saved through the added (and overloaded) method . 

On the Groovy side, it would still be best to use the method because the property can get out of sync if changes. 

The program begins by applying some mixins to Groovy and Apache POI classes. Then, it opens the Workbook using the added method . This method takes care of opening the Workbook and closing it when the Closure exits. The core of the process happens within the Workbook Closure. 

This makes use of to handle most of the building, instead of looping and appending to . The only comes in during the case of 3 or more items. Revised It's possible to knock out one of the cases like this: 

And original added to destructor, similar changes througout the interface. This way, the caller is made responsible for the pointer and the object gets disposed if the return value is not used. Other pointers (like on ) are no problem. No other proposal (except formatting options for the preprocessor) was accepted, see comments at the end, if you wish. Vertical spacing Given sample of the real source code: 

Inheritance vs. Composition Composition of the comparator is clearly wrong, because inheritance is taking advantage of Empty base optimization. Protected (or private) inheritance of containers is no problem - public inheritance would be, because of possible polymorhic destruction. There is no big difference between having first protected/private member or inheriting it (except EBO). The need for GetKey Unfortunatelly, Loki just state something, which he refused to proof or even explain. I think that he just missed the method and . We don't need to get key for sorting (if we know how to compare to objects), but need some of these for the searching: 

Your code will work, but you are using events in a way they should not be used. Once they are public, they are for signing and unsigning as per user of the class (those that start the operation), not to be unsigned by the class (controller). If you still for whatever reason need to preserve the class (and its state) and call the action once, it should be a parameter of the start method: 

Templates Ideally, you'd have two templates: one for the class and one for the methods. That would avoid the clunky JSP-style programming. You can read more about Groovy's template engines here. 

With some meta-programming you can add a method to the InputStream class that would allow you to move a line ahead of another using concise code like this: 

In addition, since in the JVM is immutable, concatenation can create temporary objects which the JVM must then dispose of. It's typically better to use . Testability To make the code testable, meaning that it can be executed via a method call and the output can be validated, I placed most of the code into the method. As a consequence, I converted the closure into a method. I know the challenge states If a map is invalid, STDOUT 'Invalid map.' (That includes if the map is unsolvable). However, I disagree with using the same error message for multiple problems. That's one reason I replaced these messages with insightful exceptions. The other reason is to keep the Groovy Console from exiting. 

This has the additional benefit of not having side-effects. Another improvement is to change the location s to s so that instead of you can do . This improves readability. To build the path , I think using is better suited than because it helps clarify the code's intent. can be used on the output of , but that would have been more trouble than it's worth due to the need to keep multiple things in context (accumulator). So I used instead. 

I don't know the book but have personally written few parsers, compilers and virtual machines, so, I will answer from this perspective. AST v.s. eval() I do not fully understand why you have selected mathematical representation of numbers which can be found in set-theory. There is one element to be known - zero (or empty set) and a construct to create another - succ(zero) (e.g. set containing one element - the previous set). In classical numerical evaluation, you would have some type containing the numeric value. and would then access the value and add/substract one (increase or decrease). With your cunnert design, , but does not know , it only knows or . This way you either have to make somehow public (e.g. by public getter) or have to use the friending as you did. C++ features used It is safe to use but it would be better to have some constants and actually share them! The examle would be - looks like good attempt to share, but you'll need to make it working (trully sharing one instance, not creating new ones). But you will also need static versions and probably hide the constructor (to ensure, there is only one and only one , not multiple). The can be replaced by 

one to determine what to move and where to move it to, and another to re-write the file with the lines moved. 

The meta-programming You can start with a Groovy Category that adds the method Writable moveLine(Object, Object) to a class, such as an InputStream. 

The new property , which is maintained by the and methods, takes care of saving the current resolved client to the GORM store (database). With that value persisted you can use it in GORM queries: 

How it works It's actually quite simple. The method signatures are gathered from the class's MetaClass. Then some hefty formatting is applied to write the method signatures correctly. Also, final methods are excluded. Example 

Putting the JSONArray aside (given I don't know the fully qualified name of the class), here's a Groovy-er version: Working example 

In this example, is an interface with four implementations, (only one of which I coded), one for each of the possible directions. The methods accept a and any other necessary parameters which are not part of the . The implementations can then get , , and from the . Sure, this breaks some object-oriented programming rules, but as the adage says: some rules are meant to be broken :) Note that it still involves passing the current state of the . Alternatively, you can implement as an abstract class containing and the equivalent of the methods as abstract methods. Then, you can remove all together and implement four s; one for each direction. 

What if two threads execute it simultaneously? What you have to add is somewhere, but can the actions be executed while holding the lock? Maybe not, maybe you should examine under lock, set some variables and execute the actions out of synchronization block. 

Overall the interface looks good and I have no problem with private inheritance here, it allows you to use to export (publish) some features that are already there. Second option would be to use private member and forward everything (typedefs, methods simply calling the method on the inner variable), no win here, I would prefer private inheritance. The allows you to have those links in second vector instead of using that without problems with , but I personally don't see big problem in using or directly - it is your vector, you have the right to define as you choose and any vector have to accept integral types as indexes - again, I can see no big problem, but to make sure, would be good: 

Usage example That was not part of the code for review, just and imperfect example. The real objects are a bit different. 

If you were dealing with two properties that were in the then you'd probably be able to use a derived property. But since one of the properties in an association, a derived property won't work. Instead, you can do this: 

How it works The method iterates through the and calls a closure with an object to aggregate with and the current item in the list. Iteration begins with an empty as the aggregated object, which remains empty unless the un-matching countries are found. When a mismatch occurs, it is recorded in the . The closure purposely returns the because the output of the closure is what's fed back in during the next iteration. Finally, if the resulting is empty, then all of the countries are the same. Otherwise, the contains one or two keys indicating what the problem was. If all you really need to know is whether all the countries matched or not, you can simply use : 

You'll see the use of methods throughout. It's a practice common in Groovy that reduces the changes of leaving resources, such as files, open. You'll also notice a lack of for-loops. The and methods do the same thing; and in the case of , the index value is set for you :) Inner classes are also gone because Groovy supports multiple classes per file. The Mixins Here's the magic you can use to make this program clean and simple.