Short answer: Depends on the boss. Longer answer: The boss got to be the boss by solving problems. He was thus granted more power to solve problems. That is his job, really; to use you to solve the problems other people bring him, and to use other things he can control to solve the problems you bring him. So, the key with most bosses is to state the bad news in terms of a problem to be fixed. The problem is "we don't have enough resources to get this project done by the deadline". By "resources" I will assume you mean warm bodies coding, but it could also be expertise, or client input, or materials money (usually minor for IT jobs, but servers, networking equipment etc can be some pretty big-ticket items). When presented with a problem, the boss now considers options: 

With 1 year's experience as an Objective-C programmer, you also have one year's experience in the following: 

If you're doing the non-technical part of your job as a team/project lead properly (managing people, being the buffer between your team and the stakeholders wondering why it wasn't done before they asked for it), the junior coder's never going to fully appreciate what you're doing for them, because by doing your job you've prevented them being exposed to the consequences of you not doing the job. However, you said it yourself; staying at the top of the technical knowledge game is extremely difficult and requires a lot of time and effort. Make sure you communicate that understanding to your team members; you know they work hard just self-educating on the cutting edge trends, never mind the grunt programming work. But, you need to impress upon them how you're making their job easier, and how much effort that takes. You know what's implied in your job better than they do (better than we do, in your specific case). 

Quite frankly, as a hiring manager (who is the person you really have to impress; the HR person just gives your resume a glance to weed out the obvious lowballers), a degree from a for-profit tells me you couldn't get a degree anywhere else. Honestly, I'd rather see a community college associates', telling me you went to night school, than an online correspondence degree. Why? First off, let's review the courses of a BS in IT-SE from University of Phoenix. The degree program has very good emphasis on programming, but very weak emphasis on what you will be programming. Two semesters of Java, two of .NET, one of basic Web languages (HTML, CSS), that's all fine. But, almost anyone you are hired to program for will want you to know something about his business, or at the very least about all business. There is one course, one, attempting to cover everything you ever needed to know about business, with an emphasis on coding it, NOT understanding it. The Texas Tech MIS BBA degree path requires a semester each of finance and marketing, with two of accounting. That's on top of a general education requirement of two semesters of economics, which I don't see at all in the UP degree plan. A Tech CS degree would have given you backing in graphics and operating system programming. The program's also very light on math; only 9 hours total. A Texas Tech CS B.S. pretty much hands you a math minor to go with it; most students start with three semesters of differential/integral/vector calculus (if you have to start with college algebra a CS degree is probably not in the cards), then linear algebra (matrix math), differential equations, foundations of algebra (where they show you the extremely complex higher math behind all of the simple equations and identities they told you to take for granted in pre-cal/calculus), and discrete math (set theory, field theory, etc). Even MIS, which isn't nearly as math-intensive, has two semesters of algebra and calculus followed by a semester of stats, and then finance is algebra-heavy (accounting has math of course, but it's mostly arithmetic). So, while on the surface it looks like you're being given a solid backing on the ins and outs of coding, I would usually much prefer you have a knowledge of the actual business processes that you're automating with your code. I can tell if you grok coding with five minutes and a FizzBuzz problem, and I can tell in maybe another half hour of general questions whether you're experienced enough with .NET to not be completely useless your first day (and the UP degree program teaches VB.NET; C# is by far the more popular language, though you'll get used to it fast enough with the Java experience). What's going to be problematic for you is when I ask you what a credit memo is, or what accounts might be acceptable choices to hold the debit for a decrease in accounts receivable, or what a bond package is. In addition, you learned all this by sitting in front of a pre-recorded lecture. Most of these courses are "on your own time", meaning that passing them is a matter of hammering at it until you pass the test. Semesters of a four-year college are calendar semesters; if you don't get it by test time, you fail. Fail enough and you're out; state and private colleges aren't interested in taking your money and watching you fail, because it destroys their reputation of producing quality graduates. They will instead "recommend" that you pursue other interests. A for-profit school doesn't really care; take the class 50 times, it's just more money for them. So, a four-year degree from a brick-and-mortar college tells me you at least learn quickly enough to pass a semester class in a semester (or two; no shame in retaking a couple of courses), and can keep pace with an overall course of study. Lastly, though this doesn't really matter much to me as the hiring manager, being a "Phoenix" means you have zero personal networking. In a brick-and-mortar school, you sit in class with friends, impress your professors, and by the time you get out, you have reference letters and LinkedIn contacts which give you a leg up in finding your first job and moving up (or sideways if necessary). An online graduate has very little of that; the professors have never seen you in person, and they teach thousands of students every semester. Your entire college career is spent in the equivalent of classrooms larger than the average freshman English or Chemistry lecture course, where the prof has 5 sections of 500-600 students a day and couldn't care less who you are or how much you've excelled. Pretty much any interpersonal relationships you form with other Phoenix students are either superficial or existed before you joined. 

The first thing you can do is start working on cleaning up your credit as best you can. Make arrangements to pay any open collections, keep up with any structured debt payments that you can, and if it really is just too much, file bankruptcy. Yes, that's the blackest black mark, but it consolidates your debt under terms you can live with, and helps you get your feet back under you so you don't stay down after getting knocked down. The biggest problem with bad credit during a job search is when your report indicates you're not only deep in debt but still sinking. The second thing you can do after a financial meltdown is to look for a job with responsibilities such that bad credit wouldn't look like a bad fit. If you're not in a position where you have the ability to abuse that position for your own financial gain, a credit check typically isn't a bar to employment. Jobs that do require good credit include: 

Your salary/wage rate is nothing more or less than what the company is currently willing to pay you for your time. No more, no less. For 90% of us, our actual salary and benefits are much less than the actual financial value we provide to the company. An ex-coworker of mine, while he was a co-worker, was working within the accounting system software, and "found" $150,000 of accounts receivable that we never billed and was collectible. He got a $1000 bonus as part of our "attaboy" recognition system; the owners split the rest of the windfall. That's business; you pay money in, you get money out. Those of us who work for wages or salary see much less "profit-sharing"; the ostensible tradeoff is that we're guaranteed a return for the work we put in, while investors may see no gain or even lose money. Case in point: you get a certain salary for your job. You received the full salary last year, regardless of how much or little revenue you were generating on the other end. Your boss probably has his own goals to meet for the entire department, and a budget to boot. He may have missed those goals, or just barely eked out, and/or he may be at his budget limit. You, frankly, don't get access to the details as a working Joe; they aren't your problems to deal with (though you obviously can see the end result). Whether it's anyone's fault or not, the fact remains that your boss was unable or unwilling to give you a raise, at least until revenue picks up and he can renegotiate budget numbers with his own boss. You have your own decision; can you accept that salary, or can you not? The actions to take are obvious. 

There are a couple of dominant theories on developer workspaces, and which one you'll see at any given employer tends to indicate their general attitude toward programming. The traditional model is to give each dev a cube, or an office, in which they can get their work done in solitude. There are advantages, to be sure; it's just you and your keyboard, so you can get "plugged in" more easily without needing to actively shut out the rest of the world. However, this approach tends to create "lone wolves"; coders who go off and code for hours and hours at a time in more or less a vacuum. The solitude can also be a distraction in itself for a lot of the personalities that are drawn to coding; when the isolation and sterility of your environment is very noticeable, it becomes its own distraction (or, more accurately, you tend to invent your own distractions to make up for it). The newer theory is a more collaborative approach. Put coders in a common, open space that's easy to move around in. Encourage people to move, and they tend to do so, to pair up on a problem, discuss a design, etc etc. It's more of a "lab" environment than an "office" environment. The idea is to improve synergy by increasing the dev team's exposure to each other, while maintaining a focus on the job(s) at hand. In such an environment, it's still possible, and perfectly acceptable, to "tune out" everybody else; a pair of headphones hooked up to your computer (or cell phone or music player) is a very effective way to lose the distractions when you need to focus on what's in front of you. My experience is that most companies are moving toward the newer arrangement of a team room with no walls. First off, it's what the more team-oriented coders want, and second, it's cost-effective; a few long tables is much cheaper to put into a room than a pre-fab cubicle system. However, in those environments, it's usually good to provide some empty offices as "private rooms". You go in there to answer a personal cell call, or if you need to hash something out with other team members vocally (personal or professional), or if you just need a few hours to close the door, put your head down and code (with laptops or a hosted-desktop environment being a requisite for this ability). The expectation for any of these, however, is that it is a temporary state of affairs. In contrast to what I just said, my last job switch was from a more Agile-oriented environment with large, open team rooms, to a more traditional cube farm. While both of them took some getting used to, once I did I was productive either way. The difference was more in what I was expected to do; in the team room I was one guy out of a dozen working on the same codebase. In my new job, I've created several new applications with little or no involvement from other devs; collaboration is mostly by request. 

This experience applies in other programming jobs, even in different languages targeting different library frameworks and OSes, and you don't lose it just by walking away from one language. Moving between languages, and between runtimes and IDEs, can still be painful, but you still know how to write code. 

Basically, the decision at play here, that your superiors would have to make when deciding to promote you into a position where you might interact in person with customers or business partners, is "do I want this guy meeting the money people face to face?". That is a question that requires a look at various aspects of you from both a personal and professional standpoint, including your speaking skills (including impromptu), your wardrobe choices, and personal hygiene and grooming. There are plenty of very highly-skilled, talented members of the workforce who don't give a flip what they look like or even what they smell like. As a senior manager, you generally do not want these people representing your company in person, however high the quality of their work is behind the scenes. This is where this kind of thing becomes a bar to advancement. Various things come in and out of fashion; facial hair is one of them. Clean-shaven is pretty much always fashionable, while facial hair runs on about a 30-40-year cycle. Facial hair denoted the hippies from the "normies" in the late 60s, then mustaches became fashionable in the 70s, then it was back to clean in the 80s and 90s, and then a close-trimmed beard with various amounts of trimming work started coming back into fashion in the 2000s. The driver of this current trend is a change in the perception of wealth over the last couple decades; "new money", the dot-com startup types and young celebrities, cultivate a look that says "I'm wealthy enough, smart enough and busy enough to not have to care whether I shave every day". Therefore, while fashionable, it still gives the impression that maybe you don't care how you look. That's typically not a good image for a business type to be projecting. So, in summary, the expectation in most of the business world is to look clean and presentable. Beards are generally acceptable as long as they look well-groomed, but getting and keeping it acceptably clean-looking could be more trouble than it's worth versus just running a razor over your chin every day.