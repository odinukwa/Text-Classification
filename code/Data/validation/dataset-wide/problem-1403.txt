If you don't want to go to the extent of making a separate class for it, there's not a whole lot that can be done. 

And our calls would happen outside this class. The class doesn't care where the input came from, it cares what input it got. Similarly, the should not appear, instead you should and let the caller decide what to do with it. This way you take the responsibility of acquiring input and delivering output away from the method, which can now be named to et. al. Next we are still in that same method, because it still does too many things. Let's break it down further: 

While it may be a "valid" implementation, it is not the best, and could stand for several improvements. I've outlined a couple. 

Welcome to the world of OOP — hopefully there are a few things we can teach you. ;) I'm going to show you an alternative implementation first, to help you see how OOP truly should be used, then I'll discuss your specific issues. 

Your code review Don’t write . You can, however, in a CPP file (not H file) or inside a function put individual etc. (See SF.7.) 

That might be how you are used to doing things in other languages, and it works as you expect for values. But that’s not the normal way to use the container. On the other hand, pre-allocating it like that makes it simpler to do without the hand-written loop: 

Whenever you need to write an iterator, start out with Boost.Iterator. It has a and class that makes short (and accurate) work of it. If you never store the combinations at all, but compute them on the fly, what you really have is a Range Adaptor. If you have a function that maps input (index?) to outputs, it is quick work to use an existing library to do that. Calculating changes with ++ and −− rather than computing it from scratch is more difficult, and I think can be done with where you just supply increment and decrement functions. 

Multiplying each digit by a different power has the same number of multiplications as multiplying each partial sum by 10. But if you look at the generated code, as I found in this post (see function ) that multiplying by 10 was done with two simple instructions: multiply by 5 is adding via the addressing generator port by using scaled indexing and the index and offset being the same register; then multiplying by 2 is folded into the += with a similar trick. Multiplying by the various other values will probably not use such tricks, but will need the regular instruction or a longer sequence of adds. Another thing I found (in that article) is that using 16-bit ints is slowest! The x86 is especially slow for some operations in 16 bits. Using 32 or 64 (in a x64 build) is the fastest. So, I suggest simply changing your data type and running the timing again, to see what happens. I’ve also found (see this post) that some operations have different speed for signed and unsigned of the same length. Meanwhile, I see presentations that show examples of how unsigned generates worse code with less room for optimization. So, explore different types and chart the results. 

You asked if you should set up an array to keep track of things. I find math is sometimes much easier to keep a count of things. I do so in the code below. I have set this up with the following (somewhat standard) folder structure: 

This is made possible by Player and Referee They are not both classes, as you can see in the code above. Here is 

You require pry, and you don't seem to use it. Perhaps it is being used for troubleshooting, and the or other code, has been removed. In that case it may be more appropriate to simply use the option as in . Then you don't have to remember to remove that line, just the troubleshooting line. (Or even better, set up a system that lets you leave things in but turn them off and on from an option in the system call. Perhaps -w or -v flags. Perhaps an environment variable. A line in with this in mind may look like this: And a ) Looking at your tells me that you have an infinite loop. But you have a well defined exit strategy, there is no need for an infinite loop. Using something like will run the block at least once, and will stop when your method returns true/truthy value. You also call 'play' from inside the loop inside of play, but it is already going to start from the beginning of the loop. If you had folders , , I would expect some of the code in your file to be in maybe . The equivalent for sure. This will allow you to use the file in a way that someone that requires that library would expect. Right now, you are unable to require that library file without starting the game. The interface of using words like seems clumsy and error prone, even if it is nice. Creating a numbered or lettered menu or presenting the grid with numbers or letters could make play easier, less typing to do, less error prone. Perhaps a lettered 'x, y' grid. Presenting that grid would also document the game play, and make initial play more straight forward. Your "choose_character" method does two things, it prompts and processes the choice. The @player_character and @computer_character is repetitive, confusing in a way. Simply having @player and @computer is probably clear enough. @player.character might be better, though I think we consider that letter a 'marker', as the player mark may be 'X' and the AI mark may be 'O'. Looking at you could be using the new named arguments in Ruby 2.0. In the Board file you can likely use the Enumerable method, if an array has the markers that match the current players marker, then that player is the winner. 

Now… you notice that the only things you do with the parameters are getting the iterators into them. You do not rely on any members of at all. So, is would be perfect to use the rather new (C++17) here instead. 

⧺C.149 — no naked or . You should probably make this a as a drop-in replacement without otherwise changing the architecture. 

At its simplest, it’s just a number assigned per-object. But I’ve also made systems where this was an RAII object and destroying the ticket would revoke the callback. 

You take by value in all the functions. What if is a substantial type? You want to normally take it by const reference, except for functions that will create a , in which case treat it as a “sink” parameter. 

and by using you won’t have this unsigned to signed implicit conversion cluttering up your warnings window. You do compile without generating warnings, right? 

render Same lessons explained already. Now how do you make a return value that can be a or nothing? . This function is too long. The body of “visibility state changes to visible” can go into a helper function. The body of the next statement is huge; it can probably go into its own function which can then be split up into others. Every time you have a comment header explaining what the next block of code does, you are “naming” that block of code and indicating it has a purpose distinct/different from other such blocks. A block of code with a cohesive single purpose and a name— what’s that normally called? Closing remarks Your code is a lot better than most of the code posted here. There are a lot of things about how-to that you already know. Your fluency in the language indicates that you are new to it, but you are learning from more up-to-date material compared with a lot of newcomers’ code, so good show there! Is there a book or online resource you recommend for this? 

Though I would probably do away with the variable named result, this would be a clean way to do this. In other words, regarding the variable assignment, don't conditionally assign a variable through all conditional paths. Just assign it the result of the condition one time. 

Given that on some file systems a directory is simply a File with special attributes (or to put it another way a specialized file), does it really matter? Unlink it if it can be unlinked if that is what you want to do. If it can't be unlinked, why would you bother? And why would you care what it is? If you care what it is, then use If the inode can be unlinked, unlink it. 

This will only use 4000 arrays, converting the array into an array of arrays containing 2 elements each, given the 8000 element array you mentioned. I have not timed it though. 

As you move other things out of the more of the game mechanics may be managed by the Referee module. There is still a lot of work to do in these files, and you will rearrange things as they make sense to you. I spent just a few minutes on it this afternoon, but I hope it helps.