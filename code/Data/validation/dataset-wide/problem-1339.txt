I'm not quite convinced that a python script is required here as a shell one-liner would probably do the trick ( would be a good starting point). Your python code could be improved by using Generator Expressions : 

takes a linear time in the length of the string. Thus, will call it times and the result will be quadratic. Changing this and a few other details (moving stuff to the smallest possible scope) and you get this : 

Please note that if you were to define a function/macro, it could be useful inside the loop too as it would become : . 

Your code is easy to understand and just works but it can still be improved. Documentation It could be nice to add some documentation to tell which values are expected. Domain When I tried with as an input, I got a . This is because the recursion calls go deeper and deeper into negative numbers without reaching a stop. Adding : 

g) It would probably be worth defining a method taking a string as an argument, prompting it to the user and asking him for a y/n answer until a proper value is given and return a boolean. 

The same kind of issue appears with calling which itself calls . Also, because of all these recursive calls (direct or indirect), you have hidden problems in your current control flow. For instance may end up calling directly more than once. This leads to a situation where the user wants to stop playing, yet another game is launched. Getting rid of the recursive with more simple solution like loops is an interesting exercice (actually, more than an exercise, this is definitly the best way your code could be improved). Return or update - you have to choose (and document it) At the moment, the takes as input, updates them (or not) and return them. It makes the function weird to use: as a user, am I suppose to rely on the fact that data have been updated properly or should I rely on the data returned. The good thing is that it seems like you've chosen to rely on the data and be consistent on this. You code could be made more concise but maybe not clearer by stating clearly (in a function docstring for instance) that the input is updated and that the return value is only the new count (because integers are not mutable). Another way of doing things could be to say that the function does not need a as a parameter, only a card and a head. Then, you'd write something like: 

Python 2 in 2018 It is probably a bad idea to write new Python 2 code in 2018. You should try to write it in Python 3. 

Types You do not need to convert your original into a list : and will work just as well on a string. Similarly, you do not need to convert the guesses into a list. This makes a lot of code removable : 

You don't need a class I highly recommend the Stop Writing Classes presentation. The typical situation it describes : a class with two methods, an init and a run is exactly what you've done. Changing this already makes your code much simpler. 

This code is still not optimal but because it corresponds to the "basic" version, I guess there is no need to try to make it too much better. Additional note In my code, I've been using and as I am used to switch between Python 2 and Python 3. Depending on the version you are using, I suggest you have a look online to see more details about this. Just keep in mind that you should try to avoid creating a list when an iterator is enough for you. 

Different algorithm Generating sequences and counting how many of the elements are in the right position gives you an 0(nÂ²) algorithm (at best). A different strategy could be to look at the shift required for each number to be in the correct position. Because all numbers are in , you can compute the shift with a simple substraction and a modulus operation. Doing this for all numbers can be easily done : 

You naming convention does not follow PEP 8. Try to follow it as much as you can as it helps having same consistent guidelines all over Python code. 

Making your solution better You won't get a huge performance boost unless you change your algorithm. Anyway, let's try to see what could be done to improve your code. You are playing with a variable . It is easy to check that a few properties hold (cf statement): 

Distinction between computing a value and setting the field It may be interesting to make a distinction between functions computing values and functions setting the different fields. It would make things less verbose in the various small functions and more explicit in the functions. For instance: 

Micro-optimisations As a reference for later, on the computer I am using, your original code ran in 5.55 seconds. The precomputation of factorial is a nice touch but you can make it even more useful. Indeed, instead of going through the "hassle" of decomposing and computing the factorial for each "decomposed" number, you can use the fact that the conversion from int to string pretty much gives you what you want (and is expected to be optimised). Once it is done, you just need to compute the factorial for each character. Writing the precomputation of the factorial for the different characters gives, with a dict comprehension : 

On such a dataset, I can already see the benefits of the idea described above. Correspond code looks like : 

Bug found As I was looking at my original implementation, I found a bug which happens to be in yours too : try with . 

Code organisation It can easily be seen than nothing will happen for a given if it is already in . We might as well extract the corresponding logic in a single place : 

Now, if I was to write such a program, I wouldn't even create a class ( you can have a look at $URL$ ). A dictionnary to map club names to score is pretty much everything you need but that's a different way to see the problem I guess. Edit : Actual tested code added. 

Separation of concerns Your functions does way too much : file reading to get input, getting solution for the problem, printing out the answer. It would be much nicer to have this splitted into individual functions. Among other things, it would make your code easier to test. Code-challenge are very good candidates for unit tests because the algorithm involved is usually pretty tricky, the input and ouput are usually pretty clear, no side-effect is expected and you are provided some simple tests with the problem. Rewriting this gives : 

Parameters It could make sense for not to be responsible for chosing the file path. This could be provided as a parameter. Disclaimer: I have run (pun intended) none of the code above. 

(I just realised that I forgot to extract stuff from but you get the spirit.) Avoid useless string manipulation You have a dictionnary where values are strings and these strings are later one used to retrieve the relevant function. It may be easier to just map keys to functions. You simply get : 

Disclaimer: Current version of the code seems to be very weirdly indented. Some comments might be wrong because of some misinterpretation of your code. Style Python has a style guide called PEP 8. It is usually a good idea to try to stick to it unless you have good reasons not to. In any case, it is definitly worth the read. You'll find various tools to check compliancy. In your case, the main issues would be : naming ( is recommended for function names), spacing (whitespace around operators), indentation (4 spaces) Design Your function returns either a list of food or is there is no food. This seems to be more complicated than it should be: it could return a list of food (empty is there is no food). It makes your function easier to use, easier to explain and more concise: you can simply remove the condition. From the Zen of Python: 

Simplification probably means because the length is integer non-strictly positive. Also, PEP 8 suggests: 

This is known as the LEGB Rule (Local Enclosing Global Builtin). It is hard to tell whether this is relevant to the problem you are trying to solve but if you do, and would interest you (I haven't found a way to access the variables in enclosing scope). I've played with this as part of one of my pet project. Here's the parts that could be more relevant to you: 

Same logic but different The logic to check is the list is sorted and the logic to find first item out of order from the left look the same but shaped in a different way. Actually, a closer look shows that the logic itself is different in a subtle way: identical consecutive values are not handled the same way in both places. This can be shown by writing more tests with equal values: 

You have a O(n) algorithm, that should be fast enough (and it is easy to see that better complexity cannot be achieved). 

should provide you some hints. I'll go deeper in the code once you confirm that my understanding is correct. Edit : I have to go, no time to run benchmarks but here are the improvements. I kept different versions to that you can take ideas out of it.