Even this is out dataed because of all the container classes, and generally using pointers is frowned upon in C++ because it is error prone. Declare Variables When Needed In the older versions of the C programming language one had to put the variable declarations at the top. The current versions of C and C++ allow variables to be declared as needed. An example of this is to move the variable to be within the for loop. Limit the Use of std::endl It would be better to use '\n' to insert the new lines in the loops because std::endl does a file flush each time it is called. This makes it an expensive operation. Use Boolean Variables In the C programming language there is no bool variable type unless one includes stdbool.h. In the C++ programming language it would be better to implement the variable as a bool variable rather than as an int. Then you can use and rather than 1 and 0 respectively. 

since (answer == 1) is a Boolean condition. The second is unnecessary since it is an unreachable statement. 

Reduce Complexity, Follow SRP The Single Responsibility Principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. 

hides the fact that cin, cout, vector and stack are coming from the namespace std where cin, cout, vector and stack are used in the code. This can cause confusion of where the code is actually coming from. As the software becomes more complex and uses more libraries this becomes a bigger problem. For a more detailed discussion of why it is a bad idea to use see this stackoverflow question. Just Include the Necessary Headers The code starts of with 6 C++ header files. At least two of those headers, and are not necessary, since the code isn't using old C style I/O and it isn't using any of the old C library math functions. Including too many header files can slow the compilation time, and it may reduce the names you can use in the code. Meaningful Variable Names The problem statement does use symbol names such as n and q, however it also states than n is the number of brands and q is the number of buyers. Single letter variable names don't help others reading and maintaining the code, but descriptive variable, function and class names do. If you are programming in a team, someone else may need to maintain or update the code you write because you are busy doing something else, or on vacation. The term buyer is completely missing from the code, and I'm not sure what the variable represents. In some languages such as C which is closely related to C++ the following code would be broken because the variable is defined multiple times within a loop where i is used as the loop control variable. 

Variable Names While the original code had the variable name ANTS for the array of ants, the C coding standard indicates that constants should be defined using all capitals and variable names should be a combination of capitals and lower case, but mostly lower case. In the ant.c file the variable might be better named ant, and the struct might be better name Ant. this might improve the readability of the code. The field in the ant structure could be name position if the struct position was renamed to Position or the variable could be named either location. or pos. It's not clear in the code what and mean in the kinetix struct. Are they vectors or velocities? In physics or math the shortest form of change in location might be dx and dy for and In what exactly is ? The second page of the PDF coding standard in the cited in the first section provides some good tips on variable naming. MAGIC Numbers There are already symbolic constants in use in parts of the program, however, their use could be expanded. It is unclear what the numbers 2, -2, 320 and 240 mean in the functions and void Draw_Ground(void). It is also unclear what the numbers -2 and 2 mean in the function . Symbolic constants help programmers in a number of ways: 

The function copy_max() is mis-named, No one maintaining this code would know from the name of the function that the string is being shortened by the . Copy does not imply destruction of the source, move might be more appropriate. You may also want to consider the Single Responsibility Principle and break copy_max() into multiple functions. I see at least 2 functions there. This loop is complex enough to be it's own function and can be called from copy_max() 

Global Variables The code contains the variables and declared as global variables. Global variables are generally frowned upon. 1. As programs get more complex they are created in multiple files, global variables are very difficult to find when used in multiple files. 2. Using global variables makes it harder to maintain the code. 3. Using global variables makes it harder to debug any problems. 4. Using global variables may prevent adding external libraries. Variable Initialization in Constructors In both of the classes the variables are initialized within the body of the constructor. The more accepted way to do this is this way: 

Interesting problem you addressed there. Definitely a nice question. Other than Optimization and the number of comments I will address things that @RolandIllig didn't address. Optimizing for Performance The C programming language can definitely generate fast code, but as Roland Illig indicated the -O switch needs to be used to generate the fastest code, the -O3 switch will generate the fastest code. Also as Roland Illig indicated, optimization should always be the last thing considered. These are two articles on when to optimize the code are good references ACM The Fallacy of Premature Optimization and Premature Optimization. The primary concern is to write robust code that is easy to debug and modify. Once an application is release for use by others there will always be feature requests so easing any future modifications is the second most important thing to consider. The most important thing to consider is writing robust correct code. Make sure that any input is checked for errors, provide easy to understand error messages, make sure to handle any possible errors, especially user errors. When the application or program takes noticeable time, or uses too much memory then it can and probably should be optimized. When the code is optimized, the first thing one should do is profile the code to see where bottle necks are. If the code spends 90% of it's time in one particular function, that function should be optimized. Reduce the Complexity of All Tasks in a Program It is easier to write and debug software when the complexity of of each and every task is reduced to an atomic level. The Single Responsibility Principal is an excellent software design principal to follow, it states: module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. Any function that is 157 lines long is TOO complex. The main() function is 157 lines long, without the unnecessary comments (as Roland Illig pointed out) the main function is still 128 lines long. Almost all functions should fit in a single editing screen of whatever editing tool is being used, my arbitrary limit is about 40 lines. The main() function should be broken up into multiple sub-functions that are all atomic. The main() function should not contain the actual implementation of the algorithm, that should be one of the sub-functions. What the main() function should contain is a function that gets the user options, a function that sets up the necessary conditions using the user options, a function that implements the algorithm, and a function that cleans up after the algorithm is finished. The proper definition of main() In the code the function is defined as int main(void) { } This is actually an error, whether the arguments are used or not, main is always passed arguments from the operating system, the definition of main should always be: 

It might be easier to read, understand and modify the outer loop if it was a do while loop rather than a while true loop 

This allows the maintainer to know the type of variable without jumping all over the code. BUGS This code may work due to the specific compiler you are using, but the fact is that you create the company array at least 3 times. Once in every loop that I see. The variable com1 should be created once at the top of main where count, num and option are created. 

Reduce Complexity, Follow SRP In both this question and the Binary Search Tree in C++ struct definitions have been embedded within the class definitions. This goes against good object oriented programming principles, specifically the Single Responsibility Principle. One of the basics of object oriented programing is to be able to reuse objects in multiple programs. Each object should be defined separately so that one builds up a library of objects/files that can be reused. In C++ a struct is a class where all members are public, since they are classes they should be defined on their own. In this program it would be better if there be three header files and possibly two source files, one for Graph and one for Vertex. Vertex may not need a C++ source file since it is fairly simple. The color class also deserves it's own header file. In the Binary Search Tree question Node should be defined separately from BinaryTree. You might also want to look into SOLID programming principles (the is the Single Responsibility Principle). The Single Responsibility Principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. 

The second brace on the last line of the original is problematic, it is not immediately clear when reading the code. Keep it Simple The function contains the code 

Note: in C++11 initialization uses {} rather than (). Comparison of Different Types The reason for my comment above is that the following code compares an int to a size_t 

Error Handling The function returns allocated memory. The pointer is never checked to see if it has value before it is used. Witin the function there are 2 calls to . The function returns NULL when fails, but the return value is never tested. There are a number of ways to handle issues like this, in a program such as this one it would be best to report the error and quite the program. Some changes I would reccommend for main.c are: 

Meaningful Variable Name: The variables i and k don't tell the reader anything about what the code is doing, initial and cnt are better, but spell out count. The variable gamewin is very clear, but use camelCase, gamewin => gameWin. Meaningful Comments: You don't need anywhere near the number of comments you have, the code itself should clearly explain what it is doing. Comments should explain the why, not the what. The best comment in the code is 

First it looks pretty good for a first time C program. Nice question! It is very nice to see a first C program without MAGIC Numbers. The variable could probably use a more descriptive name. The program could be more general. If the number of strings in the file increases the program will index past the end of the variable . To make it more general, not waste space if there are less strings and not produce unknown results if there are more strings, the array could be implemented as a linked list. This would perform better than reading the file twice to get the size. The code never checks the value of counter to make sure it stays below 1388. The code depends on working. There should be error checking for opening a file, reading from a file and writing to a file. Technically there is nothing wrong with the switch statement in load_data(), but it would be better to have a default case that identifies what should if line[j] is not A, T, C or G. 

While the compiler will correctly optimize the previous statement, someone reading or modifying the code may wonder why the code was written this way, especially someone unfamiliar with C macros. When optimizing C use registers as much as possible rather than normal variables, this makes the code smaller, and registers are faster than normal variables. To make the code more portable perhaps the use of typeof can be changed to . You are probably aware that typeof is a compiler extension and not defined by all C compilers. 

In C Always Initialize the Variables In C there is no guarantee that a variable on the stack is going to be initialized to zero or NULL. To avoid unknown behavior and unknown results initialize all variables when they are declared. This has saved me a lot of debugging over the years. When I was writing code that integrated many libraries this was one of the type of bugs I often had to track down. 

It might be better of the number of arguments was checked prior to calling so that could return NULL if there was an error. That way the call back would not be necessary. The function also contains the lines: 

but it would be better to explain what the two patters are. The code here is pretty clear, you don't need the comment: 

Nice Question. I would hesitate to port the code as it is currently implemented. For Portability Don't Ignore Warnings When the library will be distributed on multiple platforms it might be better to use the -Werror flag to make all warnings into errors. Any warnings may become errors on other architectures. At a minimum when compiling for a portable library the -Wall flag should be used. Using Xcode on El Capitan (Mac OSX) I got multiple warnings about integer versus long mismatch. It might be better to change the length parameter in these functions to take rather than unsigned int: 

Now in your code below, it is somewhat obvious what 1 and 2 are, but generally switch statements use enums or symbolic constants. 

Performance First, the best way to optimize C++ code is to compile it -O3. Then profile the code to find out where the bottlenecks are. In the bad old days when inline functions needed to be explicitly declared, incrementing a pointer through an array would have been a good way to speed up the code, iterators are preferred over pointers now. Using iterators would mean changing from the C style integer arrays currently used to the C++ container type std::array. After utilizing iterators you can then look at the STL algorithms and see if any can help. All of the STL algorithms have been optimized as much as possible to make the STL library perform as well as it can. It might be good to think about data heuristics in . Rather than starting with 9 and working down to 1 it might be better to find the most common number and solve that first. After that solve for the next most populated number. For example, the hard Sudoku has three 4s, two 1s, two 2s, two 7s and two 8s, try solving for 4 first. Try solving the 3 x 3 square that is most populated first. Algorithms will supply faster solutions that optimizing the code. Add Test Cases It might be good to get multiple hard puzzles, get all the times and average them. Maybe have 3 loops of tests that have averages. An average for easy puzzles, and average for medium puzzles and an average for hard puzzles. Remove Unused Code The functions and are unused. It might have been better to remove these functions prior to the code review. Unused code can confuse anyone that needs to maintain the code or review the code. The function is using pointers. The use of C style pointers is discouraged in modern C++. Style Improvements It might be better to have one declaration and initialization per statement, someone that needs to modify the code might miss part of this line in the function : 

Reduce Complexity, Follow SRP @VTT is correct about the function it should be broken up into multiple sub functions, it would have been easier to read, write, debug and maintain that way. The Single Responsibility Principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. 

This is my first hand crafted makefile in quite a while. I thought it might be useful for anyone who wants to review the Knights Tour - Improved Refactored Recursive Breadth First Search. I believe there is a lot of room for improvement on this makefile. The C++ source code as well as the makefile can be found on github.