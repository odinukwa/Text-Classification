The steps are not necessarily in order. It relates to your recursive call of the solve()-method the stateExists()-method and the addState()-method. I'd expect following structure of the State-Class to use in the generic path finding algorithm: 

The parameter is not technically connected to the return value but semantically. You can see the strong relationship between those return values. They were built to present text. 

Unified representation of ONE semantic If "strRequestedReportID == null" and "".equals(strRequestedReportID) have the same semantic this should be unified as early as possible in previous code (maybe where the request occured) so the provided method and maybe all other methods need only to handle one case. I suggest to use an empty String that is the neutral element for String operations. Responsibilities Throwing an ExceptionInvalidReportRequest is not the responsibility of this method. Why ask for the usage of a cached ReportBean when it is not even passed in as a parameter? This should be handled before this method is called. Multiple return statements Try to avoid multiple returns. Breaking the control flow can hinder you to apply refactorings like extract method. So you should be sure that your code does not violate SRP or it will never change again when using multiple return statements, break or continue. Code in guessed environment As only one method for review is provided I can only guess how the environment looks like. So I made up a setup to include the method with the semantic I analyzed. The point is: The method as provided is effectively one line. For me it makes perfect sense that "A cached report bean should only be used if it is the requested one". All other stuff I think does not belong to this method. Therefore it must be located in the environment I made up. 

Currently you are copying Bank objects several times at different places for your simulation and to avoid side effects (e.g. State, solve()-method). Instantiate Bank-objects once and never copy them. Use Sets to represent state instead. Always make defensive copies of the Sets. Omit Element.FARMER You also see that I omitted Element.FARMER in FINAL_STATE as this element is not an element like the others. You see the special nature from the Element.FARMER in the take()-method and the drop()-method which is leading to special cases. Introduce a boat A good way modelling the problem is to represent real involved objects. In this case you are at least missing a boat. 

OR-mapping You fall into the object-relational impedance problem. RawNode seems to be the same as Node but they are totally different in purpose. This doesn't even change if you use an OR-Mapper like Hibernate. The following definitions assume you do not want to have an anemic domain model. RawNode (mapping object) It provides a concrete representation what came from the database. It is a datastructure only with no logic. It abstracts from the raw resultset where you access columns via column names or indices. A RawNode is used as a datastructure to communicate with the database through the DAOs in both ways. A RawNode object is a value object. It has no assertion to consistency. You may check the values for consistency (e.g. Java Validation API) and get a list of constraint violations. But the current state of the object may be inconsistent. OR-Mapper can do validations but as they are not able to enforce business rules I would not rely on this. Equality of these type of objects should be checked either be on all values or on none. Node (business object) Equality of a business object is checked on a global unique id. This is a real business object. It has the assertion to be immutable in the current version. If the non unique values are different but the id is the same you have a different version of the business object. But it is the same object. A business object is ALWAYS consistent in respect to the information it provides. If it is not this is an error. Business objects enforce business rules and consistency when you try to make a change. They will process validation and structural checks to keep the whole system consistent. Useful assertions As you remap the business object to the mapping object in the DAO you can be sure that the communication object is consistent as the business object was consistent. As you remap an unmodified mapping object from the database to a business object you can assume consistency. Your code Avoid continue multiple return, break and continue are not refactring-friendly. They make it hard to extract methods if you want to sub divide a method. What kind of exception do you expect? You have all transient datastructure available. Do you expect a NullPointerException because a parent that was defined could not be found? If that is the case you should fix the algorithm that produces that inconsistency and not try to straighten it for further algorithms. The decision to fix the data is depending on your influence on the data holder of course. Extract methods Extract the following responsibilities into separate methods: 1. Build Nodes without parents and children from RawNodes 2. Build a temporaray map with Node by Id 3. Set parent child relationship 

I could tell something about conventions e.g. you should name "DOMAIN" and "URL" to lowercase. I could tell you about creating a real class out of AbstractAuthenticationToken. I could tell you to extract some magic values to meaningful constants ( ... , true, true, true, ...) 

I think if you continue this path you violate the "interface seggregation principle". Try to separate the interfaces. Going with your semantics I expect interfaces like ParameterAware or Storable. Then you won't get into such a semantical trouble. As you have less semantical problems with your interfaces you will face other challenges that have to do with the implementing classes and your algorithms using and working with these seggregated interfaces. But you cannot escape it and the effort and it is justified. 

Overriding hashcode and equals on mutable objects will lead to unaccessable elements within hash-based datastructures like HashMap or HashSet. Always make sure your objects are immutable when overriding these methods. Furthermore your implementation of equals is semantically wrong. This is because you make "equals" dependent on hashcode only. Maybe you can precheck the hashcode to avoid a complex equals-evaluation if the hashcodes aren't equal. hashcode has a totally other purpose. It provides a value that is used in hash-based datastructures to balance lookup tables to increase lookup performance and minimze the binary search path. You may say that Integer.hashcode(int i) always returns i. Yes, but you depend on implementation details for a totally different semantic. A correct implementation for your SomeInt: 

Those methods should delegate their requests to the controller and the controller should tell the UI what to do. For example: currently you will confuse a developer where to put the logic when adding a requirement that will avoid closing under special circumstances. 4. Make the controller the responsible to orchestrate The controller should be responsible for requesting the UI to put itself in a specific state. So the controller should be the constructor parameter of your UI and it should not be set by a setter. The controller lives first, then the UI. This is because it may not be necessary to show a UI through business rules of the business model the controller asked for. Remove "void addController(...);". 5. Avoid "System.exit(0);" This statement makes either no sense or it is hiding programming errors like running threads that have been forgotten to shut down. To make it clear: System.exit(1); can make sense if you want to communicate an error state to the OS. Use following to let Swing disassemble your UI when the closing request was initiated via X: 

The idea is to have every class that writes or displays the result depending on the model class "Calculator" because this class is producing the result. Why should Writer depend on Display or vice versa? The Listener-interface should look like this: 

Learn the theory of sequence, selection and iteration Train your algorithmic thinking by solving problems with the elements of 1. in a programming language of your choice by increasing difficulty Get familiar with the language mechanisms Apply programming paradigms like functional or object-oriented programming Formalize you code fragments by learning the currently identified 26 design patterns and learn to to apply them in the correct situations Organize your code by following the correct semantic of each code fragment and learn and apply the SOLID principles as they guide you through the jungle of design decisions Learn the restrictions of the language you use for a problem. Maybe in another language you are able to express the solution in another way that is more elegant. 

What you did right is the separation of the threads. You use Platform.runLater to update your UI. "Long running" business tasks like "Converting ascii to binary" you put into a background thread. 

General This looks much better as the initiallization of every component is glued together and at one place. Adding components The components should not add themselves to the parent. The should not know the parent explicitly. Add them in the constructor like this: 

Composing the elements Now we have all responsibilities together we can couple them. I was really astonished as I found a proper application for streams. This is a JAVA 8 style solution: First we create a stream of keys: 

You parameterize your factory methods with a string. Don't do that in this case. Passing a parameter to a factory may be possible but the products should be "strong" related to each other. Everybody who wants to know what your factory can produce should see it by the method signatures provided by the abstract factory and not guess (or read in the documentation... urgh). If you want to produce two different items, create another factory method. For a factory "FactoryX" this should look like this: 

As some other stated I am also convinced that there is less or no beneficial usage for enriching a simple associative map to throw an exception if an element is not found. I suggest to go with a use case specific exception handling as the context is important where a not available value is an exceptional case. 

Do I violate the law of demeter with "price.getPreviousPrice().getRegion().getValue()"? Why should a previous price have no region where it is valid? 

Changing the key stream to a parallel stream will cause concurrency. Noticed the synchronized method in the KeyGenerator to work properly in parallel? 

Multiple return statements Avoid multiple return statements in a method. It hinders you to apply refactorings like "extract method". Parameter pass-through Do not pass an object reference in and return it again if you in other cases create a new object to return. The problem here is that the caller is not aware of this assumption. This can be a pitfall if the caller want to work with the result AND the parameter because in one case they will differ in object identity (size >= 2) on the other case it's the same object (==) (size <2). Do not work on parameters This belongs to the category of defensive programming. The caller may not be aware of that you change the passed in complex parameter "Stack" AND return an alternate object. A method should have only one expected type of outcome. The "final" key word does not hinder you to change contents of a stack. If your parameter is a String then you have no side effects because of immutablitiy of String objects. But if you use "final" (as you do) you cannot reuse the reference. Move to object scope Although you have no object "state" you should consider this for future extensions. Object scope enables you to test selective parts of your algorithm. With static methods you are only able to test the whole call stack. Of course, if you want to test static methods you may mock descending static methods with PowerMockito. Extract methods To adress the SRP try to identify the responsibilities and extract them in separate methods. Hard borders (pedantic) This something I call "Using hard borders". This is because you need more assumptions than necessary. Use "x <= 1" instead of "x < 2" because you introduced a hidden assumption: This work great with the Integer-Type. The Code 

I think here the pattern is not appropriate and not implemented in the way it should be. The Update()-method for example has nothing to do with any builder pattern. A guess on the intention As you mentioned a "repository" you are dealing with some kind of persistence context. In your implementation the build()-method will create a new object in the repository and the update()-method wil update an existing object in the repository so far I understand. Proposal, creation and result The design I would follow is a natural approach. If you want to create a new resource then you create a proposal object that contains data that may be considered during a creation process. The proposal object itself may have been constructed by a builder pattern. That depends on the purposes mentioned in the first place. After that the proposal object is passed into the creation process. It will be validated and checked against internal system consistency. The creator object is well defined as the responsible for the creation of the wished object (SRP). If no validation errors occured and it is not violating the systems consistency the object ist created AND persisted. The object may be internally (in the responsible object) constructed through the builder pattern. But that has nothing to do with persistence. Proposal, update and result The same with the update. The only difference is that you have an update proposal, an existing object to update and a responsible object that will to the update process. Now it's getting interesting. The result of the update can be a versioned new object xor a cached old object. This depends on if you want to work with immutability or not. As you have an "id" I suggest to have the objects cached and mutable. Nevertheless you have to override equals and hashcode in both scenarios. But be careful: two objects of any version are equal if their id is equal. Conclusion 

We developers try to produce models od reality as well. But there are developers that do not care about reality as there are people who do not care about the reality that science try to evaluate and describe. The point is: We as developers can make up fiction in the programm in our programming languages as long as the interfaces produce beneficial results to those who hired us. We can unneccessarily iterate over a collection twice but returning the correct result. We can build up huge structure and destroy them instantly. I have to admit that my models are bad in contrast to the models that science produce. Doens't matter if it the fault of the programming language or my cognitive troubles. So we as developers build models... May goal is it to have the model matching best with reality AND the code we produce matching best the model. Currently object-orientated paradigm is seen as the best paradigm to model real world elements. You have a car in reality, you create a model of a car, finally you get an object of class "Car" in your object-oriented language. A car in reality can be started, so you may have a model of starting engine of your car that may result in a method "startEngine()". And here comes the problem: The more specific AND the more abstract the things are we have to model: I think we get cognitive troubles. This unfortunately also correlates with the persons perceptions on reality. We have one great advantage over the management: We can only be tracked by other developers that are familar with the our code. This has been discovered at a point of time when software came up that could not be developed by one developer alone. Collaboration was neccessary. The problem: The different perceptions of reality of the different developers (persons). Todays approaches to solve this problem are to have experience, IT expertise AND high social competence. I personally do not care about social competence when I answer questions here. So I put out the sharpest sword have to argue with to pass it to you: The SOLID-principles together with the Law of Demeter. I am convinced under the assumption I made (reality, semantics etc.) these principles will improve code quality on the semantic level and reveal things that compromise reality so you are able to adjust your model to fit reality better. The SOLID-principles will lead to a domain model that clearly is NOT an "Anemic Domain Model".