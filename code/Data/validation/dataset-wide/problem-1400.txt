It's a value object so recognize the immutability and hashcode/equals overriden. One other thing is the invert method which is a convenience method to express the other side around. You may consider to use "real" objects to represent "Rock", Scissor" and "Paper" instead of String-Objects. Introduce class "Result" It represents the outcome of one round. 

Then you can wrapp this JSONObject into your own object and have the getters returning their values directly from the JSONObject: 

Your UI should implement this interface and register itself as a callback in your "business logic" (thats not really true as it is the use case layer). Then you UI gets notified and you can process the proper UI modifications: 

Your original code is the best to start with. There is only one little issue. I would not expect to have the logging before the throw clause. And that is because you may introduce unneccessary redundant logging in the code that will catch the exception. So the right point to log is when the exception is caught. 

This parser searches for numbers and returns them. Whitespaces separate numbers as whitespaces are allowed to occur multiple times. If you input alphanumeric characters the machine goes into the Error-State. As I kept it simple you will have to distinguish several other states when parsing expressions. For example if you have an + operator you may have a stack on which at least two numbers exists. Some other things you have to consider is an appropriate abstraction. For expressions you may have "Expression" with an evaluate-method. Numbers is this case will evaluate to themselves. There are a lot of other things to consider. As I said: You picked one of the most difficult task in computer science for a hobby project. 

What's this all about? My view on this is: There is a lot of confusion about adressing the correct level of abstraction. I have two glasses to put on. The "language mechanical/technical" and the "semantic". If we talk about datastructures that support speed then we are on a technical level. If we talk about a disjunct set of countries we face the semantic level. Technically using a String would do the job for some situations and maybe these are the only situations the use case describes. Semantically you have a subject. Because the semantic is not modeled into an equivalent datastructure. Nearly every answer provided adresses this. The semantic of your String is not "a set of countries". It's "a concatenation of country names". As some answers pointed out the "vulnerability" of this approach. The reason for this vulnerability is exactly the datastructure that does not match the semantic. After all this may be not a problem if you intentionally use a structure that deviates from the semantic to improve performance. But you have to know that any deviation from the real structure goes with drawbacks. You get redundancy, vulnerability, inextensibility, unmaintainability and all the stuff that code quality decreases. These drawbacks may be jusified to the goal you want to achieve. BUT: This does not release you from the responsibility to provide the "correct" datastructure representation of the semantic as other algorithms maybe want to work on it. You should always provide a sufficient correct model of the part of the reality the use case needs. After that you can think about mapping it to a datastructure that may have drawbacks but the algorithms will work under certain metrics. So my core statement is: Beside ANY performance subjects I do not want to adress: The String will technically do the job for ONE use case. But you have to expect drawbacks in OTHER use cases as the datastructure representation does not match reality as use cases came from reality. It is a distorted model of the reality and this is expected to be acceptable for a small area but error prone for other areas. Metaphor Think about a chair and a desk. You may have the idea to omit the chair in your model because you can also sit on the desk AND you have al lot of space left to put other things there. So why use a chair anyway? Technically you could put everything on a table. Semantically a table is not meant for that because both and a chair may have properties that are not that obvious but the algorithms want to work on it. One person may sit on the table, two or three will certainly break it. One person may sit on the table for an hour but not for a whole day. You will have drawbacks if you use objects in a way that they are not made for. So the concatenated names of countries. Suggestion Not that surprising: I would go for the "Set of Countries". But if you think the perfmormance can be better with another datastructure you should map the correct representation to the datastructure that provides more performance WITHOUT touching the model that represents reality best as you do not want other algorithms to take the burden of the drawbacks. 

You should always let hashcode and equals methods rely on IMMUTABLE values. In complex environments you will have a hard time to identify such problems. I already faced such a problem in a serialization/deserialization process as not all objects were deserialized again. Semantic of class "Contact" That relates to the previous point. Either you do not provide setters for "name" and "phone" OR you should rely on other attributes. I suggest to NOT override equals and hashcode and externalize the equality check into a separate method or class. "Contact" in business application seems to be a "business object" or a "domain object". Overriding equals and hashcode using all available fields for evaluation will implicitly make an object to a "value object" with "immutable values". Every business object has its own identity NOT depending on attributes under change. They have a unique id. If you have consistency requirements like "unique name" you have to expernalize this check as a "constraint". Most developers go too fast with hashcode and equals. And if it applicable it is not used. This is because the decision when to rely on hashcode/equals mechanisms is very difficult. Comparator Separate the concern of comparing. Prefer Comparator over Comparable as you will be more flexible to add comparison aligorithms that compare your object under a different aspect. 

Another point is that you should have a symmetry in creating and closing a resource. Your LogService is now responsible to close the Writer but it doesn't create it. Either you provide a factory for the resource so the LogService is responsible for creating and closing it OR the user of the LogService that passes in the Writer should be aware of creation and closing. Nevertheless the maximum proximity for those operations is the goal. State handling Currently you micro manage the state handling (running/stopped). You should consider implementing a real state pattern as a great concept to make clear when which method is allowed to be called. You have some semantic things I find confusing. Logging is allowed only when the service is not stopped but you may always start and stop the service. Thread interrupt Your thread should not be stopped through the interrupt method. Try to reformulate your communication with the thread to stop without using such harsh mechanism that throws an exception. Restarting You do allow starting the loggerThread although this will cause an exception. I would expect either NOOP or a domain specific exception as the caller is not interested in a thread specific exception. Should the caller even know that a thead is working? Another possibility is to start over with a new thread. You already handle state so the obvious functionality for calling the start()-method on a stopped LogService is to start it again. Personal opinion As this is I would trust neither one nor the other implementation as they are riddled with semantic ambiguities, concurrency issues and micro management of state. I suggest to rethink the concept with real state handling and a proper monitor definition. Code State The state pattern will cover three methods: 

Missing model You are totally missing a model. I don't know if you have the intention to introduce one. But setting the text and the background color of "b1" directly in the ActionListener is across country. I'd expect the ActionListener call a model that will change. The change will be populated to "b1" again through another listener mechanism so the ActionListener isn't aware of what has to be changed in the UI. You really see the missing concept of a model by looking at following statement: 

RssParserService should NOT know concretely about its observers. It would be nearly the same as letting an abstract class know its derived classes. All your decoupling benefits through abstraction/dependency inversion (here the observer pattern) would be gone. On the other side your own observer implementations relies now on a dependency injection mechanism (@Inject) AND service construction (@PostConstruct). This looks really elegant at the first place. But me, I wouldn't make MY observer implementation depend on OTHER mechanisms. What you are missing is a model where your services depend on. In the use case presented you will never have any real problems. But if your code grows you should ... 

Standard Stack Try to use the standard implementation of a stack like java.util.ArrayDeque. You have reinvented the wheel here. State Pattern Introduce the state pattern. I here provide you an example. 

It's a value object with hashCode and equals overriden. With this object you are able to simulate situation of a Bank as mentioned previously (isPermitted()-method). You also print out intermediate information while processing the solve()-method. Try to separate this concern. What I really mean here is not that the representation you chose, it's more separating algorithms. You mixed a general path finding algorithm with a concrete problem solving algorithm and displaying information. Break the whole problem in smaller pieces and separate concerns. I suggest to make the path finding algorithm generic and introduce the listener pattern to separate the display of information during path finding. Miscellaneous Try to avoid multiple return statement in a method. Multiple return statements (continue and break as well) will hinder you to apply refactorings like "extract method". Do not compare Banks to each other and do not provide a copy constructor. This is not natural. Try to preserve object identity for "business" objects. The North Sea is not the Baltic Sea even if you cannot see the difference. And you will never try to make a copy of one of them. Try to develop in an OO way. You have to introduce a variable "currentBank" and an algorithm that switches between the two Banks as a transport simulation. Finally you are transporting the elements the selected valid State-Object contains in the field "elementsToTransport". 

As you are dealing with whole numbers and remainders do not use floating point numbers. It's inaccurate and furthermore confusing because others may think that the result may be not a whole number. As the solutions will get very high very fast consider to use BigInteger During calculation make sure your divisions will always be without rest Avoid return statements within the loop. Programmers have to search for breaking conditions through the code if you do not provide them in the loop header. Beside readability unexpected return, break or continue statements cause serious problems when extending the code or applying refactorings like "extract method". Use lazy evaluation of boolean operators (&& instead of &). In complex evaluations you give other developers the chance to count on the evaluation and produce side effects. Separate responsibilities. Currently two algorithms are fighting against each other. One is providing a factor and the other is using the factor to try a calculation. But maybe the second algorithm is not satisfied by the factor what is evaluated during calculation. This should be modelled explicitly.