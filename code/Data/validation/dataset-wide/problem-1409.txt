You can derive from the model class without any problem your attributes will get applied in you view model also (not every but for exmple the validation attributes will). I also recmommend to have copy constructors becouse they can help you a lot. Beside this my opinion is that no need to worry about display/display format attributes in you model classes it doesn't feel an incorrect way and it helps to keep things clear if you have a lot of derived classes. 

I'm mostly with Heslacher's solution but in don't let to any of the collections to be null and i'm preparing to have null values in the collections. To spare some time i don't bother to create arrays from the input sources too. I also renamed the extensions method to EquivalentWith because SetEqual means a different thing. Tests I have used the provided unit test as base to write my ones so here are they: 

Yes, there is: create a stored procedure and UNION the result sets then sort the records and return them to PHP. 

This is from my library it's similar to the other solutions but it's using a little hack: the array_key_exists() is a slow function so i execute first an isset() 'function' and if it's says "yes, it exists" then i don't have to execute the array_key_exists() function. The reason why isset() is not enough is the isset() will return FALSE if the key exists but the value is NULL. 

Generally, when you free something, it's a good idea to null out the pointer afterwards. While in a program this small, you'd be unlikely to make a mistake, when you null a pointer, most platforms will terminate the program rather than have potentially undefined behavior from a dangling pointer if you accidentally reuse it. You should get in the habit of doing this. There is a function called realloc that performs a malloc/memcpy/free cycle for you on your behalf. Some platforms can also resize the memory without moving it (assuming enough contiguous space exists after the allocated memory), which can be a performance benefit. You should use realloc instead of malloc/memcpy/free, because it will always be at least as fast, and often faster. That said, your code appears to be free of memory leaks, accessing invalid memory, buffer overflows, etc. There's a lot of minor optimizations that could be recommended, but this code is at least logically sound. 

Under the covers, each matching element will get its own closure, and therefore operate correctly. I'm assuming in this code that one div is contained within the other (there's no HTML here). It's pretty trivial to use other methods, such as finding siblings, etc. In an absolutely worst-case scenario, you can use data attributes on the clickable element to target other named elements, or you could make a named map: 

The second one seams to me a better approach but you say that the ManID is a primary key, so why are you handling it as a non primary key and using the query result as a sequance? 

You can't find the correct answer until your code is just a bunch simple PHP scripts. The ultimate solution would be is to use a dependency injection container and resolver where sou can say for example a PDO instance to keep in use until the request ends (in PHP this would be a singleton behavior). If you can't rewrite your whole system to have an object oriented design to have the ability to use a DI container then the only thing you could do is to create a class loader in your bootstrap section to load a factory. A Factory is a simple class which can build object instances like a DatabaseFactory::CreateNewConnection would return a new PDO instance. You can create a static factory but that would be as flexible as the pig-iron. A recommend you to have a static DatabaseBuilder class there you can register a DatabaseFactory class instance as the default database factory and your factory can hold a database class instance until the request ends. Here is the skeleton: 

Where 's' is the starting point, 'e' is the goal, and # are the walls (basically, similar to the format you have now). I'd also include a title, but that's a personal preference. In this case, I'd read the first line from each file while displaying the menu. Alternatively, to avoid reading tons of files, you might just have an "idx" (index) file (e.g. levels.idx) that contains some format, like: 

This design violates first normal form, which is a concept that states that each data field should contain an atomic value (using type and ID together makes this a composite value). This makes certain types of queries more difficult, and you'll use more database space and suffer query performance. Store the type in one column, and the ID in another. If you have many tables, you might consider breaking it out so each module type has a corresponding "likes" table (e.g. and . This uses significantly less space and makes maintenance easier, but makes some queries harder (such as "show me all my likes"). Using a single-table notation is acceptable, but by breaking the type and ID out, you can use an and an instead of a , which will improve query speed on full-table scans, and use less space on disk. 

Question #1 No. You do not need to ref the connection object in your methods' parameters - think object oriented way not class oriented. Question #2 The only way is to make this as a non static class. Avoid always statics when the current problem contains some kind of state management like a MySQL connection. Question #3 No you don't but you should implement the IDisposable interface and apply the correct disposable pattern. 

var_dump($zones); HTML After viewing the results you can create your own view to display the date without having queries and other not view related stuff between your HTML stuff. (I'm sure that i have made some typos in the code but it should work after some fix.) 

If this query performance slow then check the indexing on your server (EXPLAIN). The important thing is that with SQL server we have to work with small number of huge result sets instead of a lot of small subqueries. 

The construcotr may not contain any business logic/work process Your logic is not enough clear to me (hard coded WHERE clause first [id=2] then in getNumVisits() is just a simple select all query, etc.) No they should not be used in classes, force to inject them into the worker methods (ISession interface) Clarify your logic please Just read the common OO and SOLID principles, search for Martin Flowler's name 

Using this design means that you could literally edit levels into the data folder and have them appear when the menu is displayed, and offer (potentially) unlimited levels. Since we're talking about C++, the files could be simple, something like: 

I'm sure this could be optimized even more, but this answer was meant only to illustrate the use of to minimize the amount of code that has to be written. In this case, using just one single function with some prepared data greatly reduces the amount of data that's necessary. Further optimizations would be to use objects instead of just plain arrays to associate the data. 

One file per level still applies, though, as it will reduce loading time and memory usage (not that either is significant in a game this small, but the principle is important). 

Using method will have an side-effect if is modified. This is because arrays are passed by reference, and so any changes to will be visible to the caller when the function returns. Use if you need to manipulate id or name, unless you intend to return the modifications to the caller. Example: 

Of course, you could instead use std::swap. However, given all the alternatives, if performance was a non-issue (e.g. absolute clock cycle count was unimportant), I'd impress simply using std::min and std::max. 

You can found a lot information about what is dependency injection and with the example above you can use any existing DI framework (or create your own) you only have to do is create an adapter (Adapter pattern) which is implementing the IDependencyResolver interface and working whith the current DI framework implementation. 

Multiple problems Why is static? Why is the database hardcoded in the class? Echo or return? Neither Exit? Direct $_SESSION write (super global) HTTP stuff in an Auth class? Why is static? You are using stuffs in static where you should not have. Handling database through a static proxy? Untestable, unreadable and what happens if some forget initialize it? Same thing applies to your class which is handling the authentacation. Why is it static? If you wan't to access it whereever you want then create a static facade class and keep the main logic in a separated non-static class. Why is the database hardcoded in the class? What happens if you don't want to use anymore a standard SQL database to store your users? You will rewrite the whole class to achive that? If you create a new class as i described above leave out this hardcoding use constructor injection instead: 

ordering the available routes: by the static parts (fix parameters not pattern elements ({})) and by the constraints (in a route i can set up constraint like the id onyle can be in the range of 0-5) [static length descending, constraints' numbers descending] iterating through the ordered rules collection and trying to find out which one will be the first mach by using regular expression (the Route contains it's pattern translated into regular expression), if a match found i try to fill the pattern with data; if everything is in place i've founded otherwise continuing the search. 

Which basically moves all of your if-else logic into standard library calls. By the way, a popular method for switching numbers in place without a temporary integer goes as follows: 

This final version allows new .toggleable elements to be added to #parent on the fly, and they will also react correctly (assuming they are styled, loaded into assoc, etc). 

Load From Data Files Instead of Source Code Once the user selects a valid level, you can then have the function start by loading the level, when repeatedly drawing the map and polling user input until they win: 

And so on. Your selectLevel function could open the data directory and read the list of files (it doesn't necessarily need to actually to read the contents of the files, just a directory list). Use Structs/Classes To Track Data You can make your design simpler by having a struct that contains the game state. You could even eventually add a save/load routine later by isolating the game state from the rest of general memory. Here's a suggestion (feel free to modify as desired): 

You can bind a single click to many elements using a class selector, etc. refers to the element that ended up being the target/srcElement for the event.