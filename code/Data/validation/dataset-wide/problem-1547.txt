I have the following code that allows easy creation, pulling, and deletion of Tickets in a CakePHP application. 

However if I pass back 1000+ records then the JavaScript struggles and it takes a few seconds to do it and causes the browser to lock up. Any ideas on how to improve this code? It seems to be the line where I append the rows to the page: 

This way we just return the partial or redirect depending on if the request was via AJAX. The former seems to be the standard Rails approach (according to most docs) but I find the latter far cleaner as it means I can handle how the response is handled as it just returns HTML rather than having the actual handling of the response being returned with the response. Is there a better way to handle AJAX responses? Or reasons why my approach would be considered bad practice? Of course using the first approach means using Rails UJS and my own uses custom JS to make the request and handle the response. 

They both check that the post exists first and then creates or destroys the like record containing the post id and user id and redirects to the post with a message depending on the outcome. In the Like model I prevent duplicate likes with: However the methods feel quite bloated... is there a better way to handle this? 

The Ugly Nothing is really ugly here. For that you'd need a helluva lot more Clint Eastwood. Breaking Down Your Application Into Components To really organize your code, you need to break it down into components that focus on one specific task, for example, adding a category. Looking at your code, I can see the following tasks: 

The hardest part of managing HTTP requests is that there are a million ways for these things to die. Any assistance you can give for error handling will be appreciated by all who use this class. 

This allows you to centralize all your AJAX calls, yet keep things strongly typed enough to make your code easy to follow. Edit: This pseudo code uses the Promise/A+ API, which browsers have native support for now in ECMA Script 6. Related pollyfill: $URL$ 

The name of your class is a generic name, yet it is used for a specific kind of request being that the and parameters are hard coded. I think what you want is a class that encapsulates specific AJAX calls. For this, the Repository Pattern would work well: 

If using actual private variables in my class, create get/set properties for those I want accessible to the outside world: 

The form would need to instantiate the user permissions service with the proper user object before the method gets called. 

When you change anything with categories, you need to refresh the category list. Same thing with bookmarks. For this you can use events. Controllers would publish an event, say "category:updated". The would subscribe to "category:updated" and refresh the category list. Same idea with . Now the AJAX functionality is currently all global. I usually go for the Repository Pattern to encapsulate AJAX calls. For that you would have two more classes: 

I have the following two methods which handle the liking and unliking of posts in my Rails application: 

The idea is that if a query string named 'next' exists and has a valid hostname that matches the actual sever hostname then send the user to that location otherwise send them to the default location. It should also handle really bad formatted urls by the parse_url method returning false. Can anyone see any issues with the above code? Or offer improvements? Thanks EDIT The next parameter can be added manually for example on a login link, but is also created automatically on the redirect when a user tries to access a protected action. The reason for adding the is because the session also contains the app url, so if your app is on a subdirectory e.g. and you try and access you will get redirected to the login form with which will then send you off to: adding /myapp twice! Doing the full url instead STOPS this from ever happening and doing the parse url prevents a malicious user from creating a login link with their own url as the return. 

I have the following snippet of code that redirects a user to a specific page on successful login to the application. 

But as you can see, the code is HUGE in comparison! Can anyone suggest some better ways to handle this, as I can't believe that PHP can do all of that in just one line compared to all the crazy MapPath and converting of dates etc. 

The purpose of these two classes (and hence why I am including them together) is to allow you to create a , that indicates a "render zone", and track an object in this , so that when the of the changes, the changes to reflect that. Ignore the unimplemented method, I've yet to decide what to do with it. GitHub link to this version: , , . The class: 

Overall, good work. Hopefully this is somewhat educational for you and not just a bunch of random nonsense. :) 

The difference between and is beyond the scope of this answer, but it changes how C# will likely treat the object and any implementations of it. You asked specifically about in the form class: 

Generally, we want as little whitespace as necessary. I don't ever put whitespace after a or before a unless that body is blank, and I don't ever use more than one line. 

The table has no indexes on it, apart from the PK. This is for SQL Server 2012. There are two records in , and almost 22k records in . When both filters are applied, both records in match , and ~17k records in are returned when the filter is applied. 

Second, what are you using a new DB query for? Does not have our student already? Next, you can write one abstraction now that we have in a list instead of having to write an block for each combination. 

I tend to gravitate towards making everything public, and part of the prototype. As a personal convention properties and methods prefixed with an underscore are not meant to be called publically. Some people force encapsulation by using private variables, but this always feels like I'm trying to fit a square peg into a round hole. Unless you jump through hoops, everything in JavaScript is public. Embrace it. It makes unit testing your JavaScript code easier as well. As an added benefit, most browsers have optimized the Constructor Function + Prototype code by generated classes behind the scenes for your JavaScript "classes", making property access in JavaScript almost as efficient as native code. Browsers haven't done much to optimize Constructor Functions that use private variables --- which is not to say that kind of code won't ever be optimized. It just isn't optimized very much right now. Edit #1: From OP's comment below: 

This way all of your rule classes are hidden. All of the validation rules are portable because they are created inside a model specific class, and it's easy to use an IDE's auto complete feature to discover which rules are available since the RuleBuilder class has strongly typed methods encapsulating each rule. On top of that, the IRule interface just accepts a value and not a model, making each rule unit testable to ensure your validation library is functioning properly. And for those who do some .NET/C# development, this pattern probably looks familiar if you've used the FluentValidation NuGet package for Visual Studio. Say what you want about .NET development, but there are some gems out there. I do like the pattern that FluentValidation uses. 

There was an interesting idea brought up in The 2nd Monitor where one of our regulars was trying to split a bunch of strings into a specific format. The format should be similar to the following: 

This will make it significantly easier to add support for additional properties in the XML. Comments, etc. (Not sure what else you would need, but it's a start.) I would also change: 

Of course you could also remove the type-safety from and eliminate by returning an , but then you have to type-case and such. Since you mention (in comments) that you have no idea about the return type at all, I've come up with a modification that works for both scenarios. We had the which would take type and find the method that had the best return, well now we have a which does the opposite: given type find the best method to transform it. 

Why is that a single line? Let's break it up so that we don't miss that bit that gets hidden by scrolling. 

I'm not going to talk about your algorithm and whatnot, instead let's discuss abstraction and SRP for a moment. Yours isn't bad, but it could use a few tweaks. First: 

Regarding the , I would consider moving a lot of that method to inside , as a method. Or at least this bit: 

Permissions are better handled by a service, so that you can more easily unit test that layer, plus the permissions logic becomes portable between presenters to promote DRYness of your code (Don't Repeat Yourself). 

Notice in this variation that the property is now defined as part of the prototype since it has no special logic around getting or setting its value. Now the and properties are read-only, maintaining the relationship that is the Document object that contains , and is the Window object that contains both and . 

This way all AJAX is centralized and abstracted away. None of the rest of the application even needs to know AJAX is at work. You could rewrite your repository layer to use asynchronous calls to the browser's IndexedDB for an offline application and you wouldn't need to refactor any of your other code. Controllers Over the years I keep coming back to this basic pattern when creating controllers in JavaScript. Controllers: 

As an added bonus, adding a new decoration/drawing style becomes trivial. Add a new value in a attribute, and then create a new function using as the name of the function. No need to update . 

Separating things into these layers makes them testable. You could write Jasmine or Mocha tests for your controller and repository layer: 

Or if I want something to be read only, I'll use a combo of private variables and public getters (Example: Viewport on GitHub): 

Your tag opens in the wrong spot. You have two tags that appear before it, which is very illegal to the spec. You can fix it as so: 

Generally, we recommend to use the alias type for all work instead of the strong type. The only time this occurs is in when you use , usually we would use . 

Let's talk about SRP for the moment (I'm not going to cover anything else but this). SRP (or Single-Responsibility Principle) dictates that each and every component of code should have exactly one responsibility. So we're going to look at all your code top-to-bottom and determine what responsibilities we have in each method. We'll start with : 

Do not that and are different classes between GitHub and Bitbucket. I'll not bother posting any models, as they don't do anything except contain attributes and properties which those attributes apply to. One of the things I thought about doing is making an class to handle all these event args. At the moment I have like 20+ files that all look like does. 

It doesn't matter what you do with this code, the can always be accessed in the . As a test, here's what you should do: Launch your application outside of Visual Studio. Take a new instance of Visual Studio and go to 'Debug' -> 'Attach to Process...' and then locate the process for your programme. Once you have done this, run your programme until the SQL point, then hit the 'Pause debugging' button in Visual Studio. Once you have done this, go to the Diagnostic Tools and take a memory snapshot. While it's paused you can view the memory dump of the snapshot. You should see a record appear in the 'Memory Usage' tab of the diagnostic tools, click the 'Objects (Diff)' link. 

Basically, the code just looks consistently written. That being said, it's not really organized. The Bad 

Really, all of my objections are related to this tenet of software engineering, and especially object oriented programming: Do one thing, and do it well. Putting validations into your domain objects means they are serving a dual purpose: Hold data from a storage medium AND ensuring it is valid. Do one thing and do it well. The domain object should hold data. The validation layer should ensure things are valid. Putting validations into your storage manager means it is serving a dual purpose in the same manor. You should be able to swap out one layer for another with minimal refactoring. If you have to copy and paste of rewrite lots of code, then your application needs additional layers with looser coupling. 

I know this is a lot to throw at a code review, but this does allow for loose coupling, plus all the functionality is componentized and reusable. Since each class has all of its dependencies as public properties (like the ) it becomes easy to mock up those dependencies for the purpose of unit testing. 

This breaks the relationship between and because we assume is the document object that contains . Instead, we want to create delegate properties for and so we can maintain that relationship: 

Since all the functions take the same arguments, create an object that references each function, then construct the method name based on the attribute: JsFiddle: $URL$ Basically, after all the *Rect functions: