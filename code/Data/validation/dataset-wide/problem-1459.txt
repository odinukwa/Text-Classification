Naming: Surely the parameter you've called ought to be named ! The word "limit" implies an upper bound, as in "speed limit". In this case, the "limit" on object size is . The parameter you've currently called is the thing you're supposed to be comparing to the size limit. What it actually represents is just a size. Separately, are you at all worried that repeatedly ging (only) huge objects will be a bad debugging experience? Or do good browsers already handle huge objects just fine? 

A number with prime factorisation (where are primes and their exponents) has a number of divisors equal to . A triangle number is equal to . These factors have no prime factors in common and only one of them has a factor of two. This means that the number of divisors of a triangle number can be factored in the number of the divisors of and . 

This way, when I see the call site, my first question isn't "what is ?" (could be a local variable, a function in this file, etc. etc.); instead, my first question is "what is ?" (which I generally know off the top of my head because it's the name of a module, and it's easy to remember all the modules I'm using). Plus, if I ever need to use any other functions out of , they're all at my fingertips: 

I am in the process of learning Python (background in C++ and R). So after the obligatory "Hello World", I decided that my first non-trivial program would be a port of a Java implementation of the counter-factual regret minimization algorithm for a simple dice game called Liar Die [original source, Joodle online compiler]. The program runs a million simulations of the dice game and computes the optimal bluffing/calling frequencies. It does this by creating class instances for all decision points in the game, and keeping track of the various actions the player to move can make, as well as the expected values of those actions. I then tried to translate this into Python as faithfully as possible: 

and likewise every other time you load an atomic variable without a memory order. As I said, normally I advise not to use memory orders other than at all; but since you are using them, maybe it would be a good idea to mark every single load and store, consistently? I also suspect that that particular load could be maybe, but seriously don't quote me on that. I have no idea. 

Live Example. The implementation is a lot easier than your classes: it consists of a single class template 

Note that the variadic constructor allows linear scaling of constructor delegation in the user-defined class template . One minor wart is that this constructor does require passing all parameters (but otherwise, different constructors have to be written). But if any of the traits variables evaluates to false, the corresponding parameter and call to the base constructor will be optimized away. And because also has a trivial default constructor, POD-ness of user-defined classes is preserved by inheriting from it. Obviously, over-use of inheritance has to be avoided, but the above design does avoid quite a lot of code duplication. Oh, and I haven't tested this with virtual functions, virtual base classes and what-not. I just use this for assembling value-semantic classes out of conditional building blocks. Question: what other design / usability issues could there be with the above code? 

This makes it much more obvious that the load of (inside the loop) is completely unsynchronized, and therefore unsafe. I'm sure there are more (non-obvious) bugs remaining to be found, but this one is sufficiently fatal that I don't mind stopping here. 

Having to write that function signature made me notice that your function's parameters are named and , which makes no sense to me. is a name usually reserved for the "this pointer" in OO style, so from the signature of this function I'd be expecting the equivalent of 

Your approach is not very idiomatic. It is very hard to read, and reason-about. Spotting mistakes is not easy. I will not even attempt it, as I think some major rewriting should be your first priority. I think your current approach of trying to solve the entire problem in one big function is a big part of the reason why you had to work so long on it! Of course, algorithms are hard, but you can use well-known building blocks to build larger ones. I would try to mimic the Standard Library / Boost as much as possible. This means using divide-and-conquer to split your problem up into manageable pieces, each of which are easy to reason about without knowing too much of the rest of the problem. 

Taking the latter approach (two values by return) and applying all our rules except "no raw and ", we end up with this: 

The idiomatic C++11 way to write would be to have it make a copy of the passed-in Container, so that you could just pass in an anonymous (rvalue) Container and not have to worry about lifetimes. The itself would own and manage the lifetime of its Container. 

I think this problem screams out for Boost.MultiIndex. It allows to add multiple indices to a container. In your case, you seem to want both a and a interface. In Boost.MultiIndex, these index types are called and . A simple template definition would be 

Here's a two-line solution using some of the standard algorithms: first a copy of the string, then use to determine if any adjacent characters are identical. If there aren't, will return the iterator of the string copy, so you simply compare against that 

First of all, let me just say that is a really bad name for a generic function. I would have called it... ! In fact, I'm going to do that in this answer, because it'll make the code a lot easier to read. Well, I'll call it , because we'll be including , and I don't want any confusion over whether we're accidentally referring to the standard library's 2-argument .