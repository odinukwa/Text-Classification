Library: (Client) Pretty simple. Until you get to the other player, which is in a different project: 

You should always keep the first parameter on the same line as the method/assignment/etc. This keeps things in a logical format. It makes them easier to read in the future. 

This also means it's simpler to click buttons from anywhere in your code: simply call , instead of . 

This tends to make it more readable. Of course, if you move the file paths to the XML, it won't be a problem. :) 

This also means, that if you wish to use the release version of , but the debug version of , you can! Just include the appropriate path name! This is generally the best-practice for this situation, as the "location" of a DLL file is a configuration aspect, rather than a programme aspect. Only in certain situations (with things like dynamic plugins) would you use a hardcoded (absolute, virtual, or relative: any of the three) path to get to the DLL's. And that would typically be something like . 

Usually I would omit type-annotations, but when building a generic, multi-purpose module I always keep them. We could define an file instead that would contain all the signatures, but that's beyond the scope of what I wish to explain here. Finally, we're back to our code, you had: 

Alright, on to the fun stuff: tail-call recursion. We're going to start with the loop, as it's the biggest kicker, and we'll go from there. Your while loop depends on a few things, including all of the following: 

Some C#6.0 Stuff Whether or not you have access to it, I find it helpful to include these things so that other developers can be pointed to a good example of what C#6.0 can do for you/them. For methods that only have one statement that is a , and for -only properties, you can use expression-bodied members to handle them. 

Why with a ? Because and are codependent: each one can affect the result of the other. So we want to take both into account idiomatically. 

And it also sets us up for parsing things later on down the road. (Since we don't care about values, we only care about terms, a parser just has to define a term as it goes and supply them as arguments to the next term.) 

You can reuse (and pass) the object to other classes/methods, so you should only ever need to create one of them for things to work properly. You can also do much more with it, like passing a validation method to ensure that the user only enters the numbers you expect and such, so I leave that for you to discover. 

This is a tool I needed for some other things (it's incomplete, but almost done) which is essentially just a text-editor that has two text-boxes: the left being the binary view / raw bytes, the right being the text when the bytes are decoded with the specified Encoding. The only features it doesn't yet have that I need to add are , , and for the most part. (Maybe a couple others that may be handy, but not necessary right now.) It's entirely in WPF / XAML / C# using MVVM for everything. This first bit is the , there's almost nothing to this part except setting up the : 

Now order doesn't matter. Just define with the position that the stat is in. You could rewrite it so that is the position, either one is up to you. This also means you can add, remove and change them easily, really easily. 

I leave building a query up to you, once you have it I recommend posting a new Code Review question. :) 

Alright, not bad. Better than when I was at work but I'm on a significantly faster PC. So, Your code runs 1/3 of the time of the base on my system. Great. Next, x86: 

Readability Apart from the few micro-optimizations above, one of the issues I see with your code is just how packed it is. For example, this is hard to read: 

And can't help but wonder what the bit is because I see no reason for to be a strong type. This entire method: 

So, we've improved everything you've got going, but there's still one more improvement we can make: convert all our operations to a dictionary. What do I mean? Well I'll show you. 

: what is ? : what is ? Is it the same as #1? : what is ? Is it the same as #1 or #2? : what is ? Is it or something different? : what is ? : what is ? : what is ? : what is ? : what is , is it , is it the from #8 / 2? 

Lastly, we're going to modify the algorithm in just a bit. Instead of making three cases, we only need two. 

Obviously we want to cut down on the work we do, always. I'm going to assume that is a class. In this case, we can immediately reduce a lot of the work we do right off the bat. 

The first thing that stands out there is that the latency is 35-88 cycles. That means the result will be valid after that cycle-count passes. That's a lot. Let's look at : 

This code is for dispatching and handling certain events from GitHub (and also Bitbucket). Things like pushes, issues, etc. can be handled by this system, and strongly-typed objects will be returned. I left the XML docs out of all these, as somewhere from 2/3 to 3/4 of the files were XML docs. (We all know how much I love my XML docs.) The first file here is the which is what handles the event dispatching. This is a common interface between the GitHub and Bitbucket dispatchers. On GitHub: . 

I gave and a only to prove a point, because my serialization mock is pretty lame and I didn't want to build actual serialization as it doesn't matter: 

All-in-all, very good start. Hopefully you learned a lot from this answer and can apply some of it to future applications. :) 

It makes everything more meaningful. If it's WebAPI you probably don't have access to the source for these attributes, but you can probably wrap them with a new one to add support for this feature. (Adds a little complexity, but should be really awesome to see happen.) 

Usually when I see your questions there isn't much for me to say, because you usually flesh everything out really well. :) (Probably why this has been unanswered so long.) That said, I think I do have one comment here: If you have support to edit the or the , I would consider replacing the , (etc.) format symbols with a named format symbol. 

By using an accumulator, and making the call the very last thing the function has to do, it can now use tail-call recursion to optimize itself into a cleaner loop. I'm quite certain this follows the functional paradigms much more appropriately than the original. 

Generally, it doesn't matter which style you use, though using the pipe-right (or pipe-next) operator has a better readability. Consider the following snippet: 

Is generally bad. What happens if, for some reason, you have to change the on only one instance? You have to alter the class, recompile, and remember to change it back for something different. Make an instance class, instead. Then, pass that instance to each class that needs it. (Yes, it's more work, but it's also more extensible, more maintainable, and follows more best-practices.) Yes, you want the singleton design, but you don't have to have everything as a singleton to satisfy the idea of the design. Some things, are just bad as singleton's. 

The above code is invalid, because the argument is expected to be the array, and the argument is the int, and the array is expected to be the int argument. 

What does any of this prove? When the OP's code is optimized it results in a very nice benchmark, but it also requires a different set of work to add new types. Once we optimize everything, it comes down to what you want the best. Do you want one class that magically handles everything? A class you have to derive for each type you need? A single class with no additional references with a magic type applied to it? 

So, we can see (it's heavily demonstrated) that there are far fewer allocations with this version, and in some cases it's significantly faster than the original version. These next tests use far more iterations. If we fix : 

This makes it much more clear to the compiler as to what type you expect, and tells future programmers that you do know what you're doing. 

Is this long? You're darn right it is. Is it necessary? For my plans, yes. I only implemented the four most common types, but adding the rest is trivial. So once we have this class (and an as you see) it's easy to use: 

The first bit is to create a (or , etc.) struct that wraps every numeric type into a consistent struct. 

You could also, potentially, make this a enum, which would mean that error codes could be easily combined and used together to indicate multiple errors occurring at a time. This will allow you to make more certain that the user doesn't specify a bad error code. Use braces even when not necessary, they won't generally prevent bugs, but they will help prevent bugs. Just as well, do not inline an // statement when not using braces. Typically, when I see one of those, my eyes immediately follow the next line. I didn't notice on your in until I realized there was not a statement below it. 

Why make it overly complex? Besides that, why do you violate SRP so drastically? You should be breaking your code into methods with a single purpose/responsibility each, not creating one massive super-method. 

Second, the only issue I see with your code is the order of arguments. When writing functions it's nice to be able to use the pipe-right operator () to push the left value as a parameter to the function on the right. In the case of your function, if I were to try to pipe an array to the right, it won't work. This is because the pipe-right (or pipe-forward) operator pipes the left side as the last argument to the right side. 

I almost missed that call, let's break that to a new line. You can always run a minify-script later to shrink the byte-size. 

Do the cast immediately, but then filter out all non- items then cast. By doing it like this we eliminate the double-map, and do a single map to if and only if it is a . More interesting: we can add these two methods directly to the module just as if they were extension methods: 

You should, ideally, create a dictionary and put each row in there, then select the row from the dictionary using LINQ, but I'm writing this entire answer outside of an IDE and it's been some time since I've done VB.NET. The same principle applies to and . Then, you should make one more method: which is similar to the follows: 

So we still have three major things it does that can be abstracted, which we should do. It may not seem like much, but failing to extract this processing properly can create unmaintainable code. Each method should have one responsibility, if it has then it should have each responsibility split to a new method, and then make calls and transfer data between those methods. This way, when we debug our code and find something that's wrong, we have a method to narrow it down to. (Especially once a released version is out, and someone says 'I got an exception that mentions the method', well that's bad right now because we have no way of telling where in the method the exception happened.) 

So it doesn't look much different, but you can see that it's just a bit shorter. The expression-bodied method syntax, the dictionary initializer, and the operator. But what really makes a difference is the / of the TPL. This starts making our code come alive. With the proper implementation, you can leverage / to really bring a good flow to the asynchronous nature of your code. If properly implemented on the method, you might get away with something like: 

The Method I would refactor your method a little to use more descriptive variable names, and store the new values added to the in another variable, just to make things more maintainable. (And perhaps a little quicker, as well.) Start with: 

This method looks like a lot of 'arrow code' (that is, we indent level-after-level-after-level-after-level...), we can clean that up a lot with some basic guard clauses. So let's look at it bit-by-bit: 

Why is this a superior solution? Because you can adjust just how frequently you write to the buffer. You could also extract this further: 

You could also consider (that is, if you have the ability to modify the webserver) using Data Contract to dynamically serialize and deserialize the data. The is very powerful. 

You could get slightly closer with the command pair. It's actually quite trivial: Add an indexer to your class () and put your loop in there. The indexer would look like: 

Finally, after a lot of thinking, I managed to rewrite the function with tail-call recursion, instead of the original method (which didn't use tail-call recursion). 

It has no effect, because you never use or after your loop. You don't even need them after the loop, so we can integrate them like we have the others: 

We're going to start with this block as it made me the least happy when I saw it. There are four glaring issues here: 

One of the more recent functions I've needed for personal and work purposes is to split a string on a delimiter, but while ignoring the delimiter when inside a quote. Just as well, if within a quote then two adjacent double-quotes () should be treated as a double-quote escape, and as such should be output directly into the resultant string. 

Now, ignoring the lack of a class that does this work, I'd love any suggestions. It would be a class in the real-world, and I understand that, I just didn't make it a class because (again) I'm lazy. Also note that this is probably a hell-of-a-lot-slower than the built-in decoding, and I make no claims for either case. This is just a really cool experiment that also demonstrates the self-synchronicity of UTF-8. Test case: 

And effectively be the same thing. The compiler would try to inline the method body instead of the method whenever possible. This should help performance, while allowing you to move some of the more mundane code away from the main area you would be working. Note: this does not guarantee that this is the choice the compiler would make, nor does it preclude you from doing other optimization strategies. However, for a method this small and simple, it would likely make that choice in the end. $URL$ This means, that you could essentially do: 

The first thing I would do is break that up somehow. Define a to encapsulate the three common properties between each stat: 

This was more confusing than it should have been, so we'll correct that as we get to tail-call recursion. 

All-in-all this was a very well-written programme, I actually learned a lot from it and it forced me to think functionally for a moment, and helped me remove that mutable variable with a little effort. Very good job! :) 

Any/all comments to speed/clean it up are well appreciated. Ignore the fact that both the extra and are in the class. In the real application they would be separate, but far too small for me to do so here.