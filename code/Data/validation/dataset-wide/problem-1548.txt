The performance might be improved if you used more efficient synchronization mechanism. The directive is notoriously inefficient. It's pretty convenient way of doing mutex lock, but there are more efficient alternatives. A common pattern is to use dedicated GCD serial queue to synchronize access. Even better, one can use the the reader-writer pattern: It's a concurrent GCD queue where you to read operations to enjoy concurrency on read operations, but use to write). See the discussion of this pattern in WWDC 2012 video Asynchronous Design Patterns with Blocks, GCD, and XPC (it's in the latter portion of the video). A couple of other reactions to the provided code snippet: 

If all you're trying to synchronize is , and if that's a simple data type (e.g. an integer or float, not an object), you can just define it as , and it can be safely read and updated from multiple threads, with no custom getter required. This is one of the very few situations where can be useful for synchronization (and it's remarkably efficient). By the way, if your property has a public interface that is , make sure the private class extension redefines it as so the setter is synthesized for you. And make sure that you only set it using the setter (not bypassing it and using the instance variable directly). 

But the basic approach of creating custom objects is a very solid notion. Having said that, this seems more applicable when reading data from some web service. If you're really reading this from your bundle, I might be inclined to making my objects compliant, and then save this collection of objects using a and then the app could instantiate the with a single call to . See the Archives and Serializations Programming Guide for more information. Or Core Data is another approach. This approach of parsing the JSON and then reprocessing the array seems cumbersome if dealing with some resource in your bundle. 

You can improve performance by reducing the batch size. In my testing, if I saved these in batches of 1000-2000, I got the best performance (and it's also more memory efficient than doing all 220,000 objects at once). You might want to try different batch sizes and see if it differs given your object model. I also, personally, wrap each of these batches in an autorelease pool, which ensures that memory consumed by autorelease objects is recovered. I would not, though, generally have an autorelease pool for each object saved. Just one autorelease pool around each group. (The objects are held in memory until it encounters , anyway, so there is modest benefit in having more frequently than that.) 

(Note that if an block has a return in it, you don't need to follow it with "else"; you won't get to what follows the block unless the condition was false). As for the function, you don't have to loop through every integer up to sqrt(n), you just have to loop through primes. Your and functions are rather useless. Just do and , and then use and instead of and (note that is a reserved word in many languages, so it's probably a good idea to not get in the habit of using that as a variable name). Instead of doing , you can just replace with , etc. You could rewrite your function to add neighbors according to various conditions, rather than having a separate dictionary for each case. e.g. 

So .. you're repeatedly subtracting a number from another number, and seeing how many times you can do that without going negative? There's a word for that: division. EDIT: Since you want the actual code 

In English, this is "possibility is the list of all words in dictionary such that all letters in the word are in bString". 

Generate list of boggle words, and check each one to see whether it's in the dictionary. For each word in the dictionary, see whether it's in the boggle words. Generate boggle words, but stop once you reach something that isn't the beginning of a word (for instance, if an actual human were playing boggle, and they saw ZK, they wouldn't try to find any words that starts with the sequence, because they would know there aren't any such English words.) 

You're not using integer properties of ; you're just checking whether it's equal to a comparison value, not doing math on it, so there's no need to convert to . If you are going to convert, do it after you've checked whether the input is valid. You can use modular arithematic to get rid of some statements: 

Most of your code is just repeating the same instructions over and over again. Define arrays newStats, deltas, and statMinimums, and your entire LOSSES block can be collapsed into one line of code: However, before you try to figure out how to implement what you want, you need to clearly define what it is that you want. What exactly do you want as far as the distribution of stat changes? There are several different methods, depending on what distribution you want. For instance, if there are n stats, you can: 

Which method to use depends on the size of the inputs. If you know that each word is at most five letters long, then you have N*M candidates for beginning letters, four more letters to find, and at most eight choices at each letter, so in this case that's an upper bound 9*8^4 = 36864, which is a large number but doable. For a larger board, and longer words, this can easily get unwieldy, though. If the inputs given are representative, then with only four words in the dictionary, the fastest method is to just check each word. So, for instance, for the word "geeks", you would first get a list of places where the letter "g" appears in the boggle, and for each location you would get a list of adjacent "e"'s, and so on. Note that you will have to keep track of what letters you've used in a word; if one of the words in the dictionary were "gig", your program shouldn't use the same "g" twice. As for your code, it doesn't seem to check multiplicities or adjacency, so the following is somewhat moot, but most of your code can be replaced by a single line: 

should almost always be avoided. Try to return from async methods so they can be awaited by the caller. A should be returned from and have it's method called. 

EDIT What I think Mat is getting at, is that this solution is localised to this usage, and may not be suitable in an application that frequently needs to generate parallel lines. If this is the only place in your app that you create parallel lines, then keep using it (YAGNI). If however you need to create parallel lines a lot, you could make your implementation a little more general. One way of achieving this could be through extension methods. Consider the following 

Cool question! In addition to t3chb0t's great comments, I would suggest using a instead of a . It has additional support for blocking and bounding so you don't need to poll the queue manually, and you can limit the number of "in-flight" files. This could be used to make sure you don't read too many files into memory at once. 

Assuming that you do indeed want a mutable triangle class, then you could extract validation into a method and re-use it from your constructor and property setters like so. 

Streams implement IDisposable, and should always be disposed of when used. Typically this is done with block. 

is not a builder, it is a factory. It's job is to create instances of . This shouldn't be done in it's constructor because then you need a new factory, each time you want a new . 

There is an abstraction that will automatically have any config updates when injected, so you don't need . I believe it is scoped per request, so changes to the config will not affect in-flight requests (you may want to double check this). To deal with updating the , you can write a small, thread safe that will always return the same client for a particular base URL. This would be registered as a singleton, and could be reused for all the clients in your app. 

The equivalent C# then becomes . Equation Depending on what you are doing, you might want to consider creating an class with a method and override . Failing that, you can at least pull the equation logic out into separate methods. 

Results Using the above short helper methods, you can rewrite your method to be much shorter and more readable. 

There is a lot of room for improvement here, both in terms of performance and readability. You should start to worry when you see code forming an arrow shape - there is almost always a nicer way. The solution below is one way of tackling this, and also offers a large performance improvement (around 19.4s to 3.2s on my machine). 

What is your desired output? Your function has no return statements (other the one commented out), and the only print statement is in the block. Have you run this function? Unless I'm missing something, it won't do anything if you input 0. And when you strip out the last digit, you don't actually store it anywhere, so it's just gone. You seem to be doing double tabs for your indents, which makes it hard to read once you get several levels deep. Also, you can save yourself an indent level after the block; since you have nothing but an block after this, you can put a return at the end of the block. Then you won't ever get to the block unless the condition is false, making the redundant. So you can get rid of that and move everything in an indent level. You don't show what face_value is, so it's hard to evaluate your code when it comes to that part. Also, unless I'm misunderstanding, the block should be something like this: 

Putting an function inside a list comprehension seems a bit iffy to me, especially since you don't seem to close it anywhere. List comprehensions are generally better than for loops. The name is a bit misleading, as it's the filename, not the file object. So alternative code would be: 

One thing to think about is what is being run how many times. That depends somewhat on the use case. No matter what, you're performing the check every time you run this function. Instead, you can just separate the words by length up front; create a dictionary where keys are integers and the values are lists of words of that length. The next question is whether you envision this function being run once for a puzzle, or repeatedly every time a new letter is guessed. If the latter, @200_success 's answer will be recreating regexes for each letter that are only slightly different from the previous letter, when you only need to check the new letter. So suppose you have a function that returns a list that is empty if the puzzle is finished, otherwise the first entry is the last letter guessed, and the second entry is the positions that letter appeared (if the letter didn't appear, then the list is empty). 

This turns any number from 0 to 99 to words, no recursion. It can easily be extended to -999 to 999, and a little more work would get it to, say, -10^33 to 10^33. 

I found that the time taken varied a bit, which is odd since this should be deterministic, but on average this took about half as much time as @Eric Duminil 's solution.