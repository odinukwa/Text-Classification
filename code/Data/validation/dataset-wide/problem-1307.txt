Admittedly, I don't know much about Drools, but guessing from how the rules are defined here, using this class, rules can be defined like (this is not Drools syntax): 

This way, the code structure itself imposes the rule on what values are valid. In addition, by doing this, you won't have to specify the validation rules elsewhere. As for your class, I think that it should be something that captures some form of playing strategy. It can be as simple as one move player like what you have here essentially, or something more complex. The simplest modification I have for this would be to restructure it the following way: 

If we're speaking of actual efficiency (as in performance) though, I don't know how much more efficient pattern matching is compared to iteration of characters. However, this is much more readable. In any case, notice that the actual translation logic is wrapped inside the condition that the input string does not contain a number. This way, you return from the method as soon as you determine the input is unacceptable. To check whether the input string starts with a vowel, you can also use pattern matching like: 

This way, you have more control over the internal state of a given class within the context of a given method, while limiting the method's behavior to something that's more specific. It also makes the code a little more traceable in that if there is no requirement that says a completed can go back to being non-completed, you don't have to enable such state transition. I think it's also somehow more "poetic" to have an invocation like compared to . 

Context I'm trying to write a function that drops a list of tables from a database (e.g., tables A, B and C). This function has the following type, it returns a list of booleans indicating whether each table was successfully dropped: 

HTTP and Web Api The route does not seem RESTful. RESTful APIs are resource-oriented - a more natural way would be to simply issue a POST requets to . If you're using Web API 2, your method could be re-written to leverage the family of classes 

I then tried to generalize the core algorithm, and remove all references to tables and database connections: 

Also notice how you're returning a 200 OK response, even if the request failed. This is definitly not right. You should serve a 500 Internal Server Error instead. 

The same goes for properties - so should be named Coding Style You could mark your private field . People often also explicitly mark them as though it's not entirely needed. The type doesn't really represent a role, does it? The name seems misleading. I think would be a better fit. Why does have a parameterless constructor? Using that constructor would result in s being thrown, since would be unassigned. This cast is unnecessary: 

If you take a look at its implementation, you'll notice that it's very similar to yours. It might be just a tiny bit less efficient - so if performance is an issue here, measure both approaches, and then weigh readability/maintainability vs performance gains. On a different note, I would rename the method to and consider it a "specialization" of for lists. I would also consider throwing an exception if either argument is null. This would be consistent with the BCL's own extension methods (, , , , , , etc). 

Normally, I do this for methods I have yet to implement while I work on specified methods one by one. 

To me, this is a very simple construct that captures the essence of what a Player is: an object that returns a when it s. With interface like this, you can define many different types of Players, like, for instance, one that plays randomly. For example: 

Hopefully the class illustrates my point about classes being in charge of their own state, actions, etc. Lastly, about , I will also say that this class is weak, and overly transparent. My idea is that once a object is created, it will never change. Because of this, I think that should be defined this way: 

Ideally, class should be itself the , but since Drools seem to rely on POJOs and, the constructor for can't be made private, I think this is an acceptable compromise. With this, there probably won't be a need to have separate rule for validating unless there are expected, more complex checking. Also, since the application is checking an external file for values, there isn't a need to recompile or rebuild the code when a new Move like Jedi is introduced into the system. As for the rules on game proper, I'd say they should have been applied to a and not to separate players. The system doesn't even seem to be interested enough in Players to give them names like "Player 1", or "Player 2"; they merely carry a Move in them. A contains 2 objects, each from 2 opponents. The fact that there is a class seems to suggest there should have been a class to begin with. 

I would consider setting the value to something else other than the input value an unexpected result. In other words, it violates the principle of least surprise: 

I wrote a method called , which moves an element to the first position of a sequence if it exists; otherwise, is returned. If appears in the sequence more than once, only the first occurrence is moved. Sample input/output: 

In a sense, your usage of properties is somewhat incorrect. From the book Effective C# by Bill Wagner: 

I could have easily defined these as extensions on or , but I wanted to try and define them for the most abstract type possible, . For this, a is needed (I think). Code: 

Now, imagine table C depends on table B, i.e., table B cannot be dropped while table C exists. The function will be able to drop tables A and C, but not B, and so it will return . So, I wanted to write a function that takes a list of tables, and calls . If any of the operations fail, it calls again but this time only with the tables that could not be dropped in the first iteration. And so on, until either all tables have been dropped, or progression halts (i.e. all operations in a given iteration fail, due to e.g. a connection being closed) This was my first stab at it: 

we arrive at "a matrix is feasible when there exists a feasible column, i.e. a column containing no significant zeros" (significant = q < 100). Finally, use to print s and for unused : 

which reads nicely as "there exists a tuple such that the second element equals zero". Then, using the fact that sorting lists does not change the elements, i.e. the outcome of , get rid of all sorting 

I'd consider the code there to be "correctly written" (I'm in no way linked to the code nor its authors.) If you want to rewrite your method to work directly with s I'd recommend using their full power: 

Personally I like leaving out the parameter (a.k.a. eta-conversion) to facilitate moving functions around (as we'll be doing shortly). This is a disputed topic, however. Similarly, can be rewritten: 

As this algorithm is tail recursive lets tackle another problem: having recursion instead of loops often makes it easier to reason about a single step but more difficult to see whether one step is (partially) undoing effects of the previous one. Here, the remaining are ersed in every step. This is an O(n) operation (n = length of the list), doing this in every step means the overall complexity is O(n2). It seems the result could also be computed by 

On my machine, (10k) takes about the same time as (1M) (less than a second), whereas (100k) doesn't even terminate within a minute. Note that we can now also any list, not just s (due to the removed type annotations). If you want to pass an empty list in F# interactive, just use . I reversed the accumulator and 'real' parameters to make use of the concise ality. 

I don't know what field represents, but I kept it. However, due to the fact that it's not readily understandable, you should reconsider why it's there in the first place. In any case, notice that there are only getters for this class, and no setters. This is because, like I said, objects most likely won't need to change, there's no point enabling the state transitions in them. Rules Integration I missed a critical aspect of the problem you're trying to solve with your code, which is the rules engine primarily geared towards not-so-technical people. However, I still think that having those rules in the system does not mean we should completely forget about good OO design. I believe that rules should augment your design, not hijack it. Since having a enum is quite restrictive, my idea is to define it instead as a value object: 

This has a single move strategy, which is what you set to it upon construction. Structuring the the way you did is, to me, a little weak because the class doesn't seem to be in charge of its own state; it seems to rely on some external component in deciding what to do next. In some way, it can be considered an anemic data model whose only purpose is to carry data instead of representing an abstraction or a concept. Going back to my point about the class representing some playing strategy, we know that, conceptually, there many ways a player can play. What I suggest here is that instead of making a Java class, declare it to be an interface instead, like the following: