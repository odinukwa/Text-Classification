If you are logging to HTML purely because it's easier to get the data that you want, you may want to check out . That will give you more verbose output that you can log. 

You do two things here. First, the Java standard prefers that you always use braces (although the language allows the other form. More seriously (at least to me), you are mixing styles in the same control statement. Even in languages where the single statement form is allowable if not preferred, it's better not to use both forms in the same / construct. As Laura noted, really should be a method on the class, not the search class. Another thing is that you shouldn't need to do on each call to the function. Check if a board is solvable before passing the board to search at all. 

The will trigger any resizes that may be necessary. You don't have to manage the number of open tags yourself. 

I don't know the answer to this. For a definitive answer, you'd have to ask the interviewer. If you told us what the book actually says, we might be able to give you some guidance. As a general rule, it's good to ask the interviewer questions that show you understand the problem. Asking if it is all right to use the method of is perfectly reasonable. Another question that is relevant here is if you are allowed to change the existing order of the . Clearly it must be mutable, as you have to remove duplicates. It's not as clear that order doesn't matter. It might or might not. Complexity is an \$O(n \log n)\$ algorithm in terms of time. The rest of the method is linear (\$O(n)\$) in time. You iterate through once. This makes the method \$O(n \log n)\$ overall. In terms of memory complexity, the iteration is \$O(1)\$. It adds three variables, regardless of the size of . The is more complex. It can use up to \$n/2\$ new object references. That makes it \$O(n)\$ in memory complexity. This might be a violation of the "no temporary buffer" constraint. Testing It looks like you tested this code in place in the method. It probably would have been better if you could have written this as unit tests. As it is, each new test obliterates the old. 

The initialization for the second loop is tricky because you want it to start on the last odd number. If there are an even number of elements in the , then the last odd index is the last index: ; otherwise, it is one less than that: . After that, you just need to copy the new over the old: 

This is a little harder to follow but it now makes it if . Another way to put this is that it is now in the opposite direction. 

I have a problem with that I didn't realize when you created it. It looks like it is a list that assumes that it is indexed the same as nodeTiles. This is fragile. If you accidentally add an F-value out of place, then your code won't work. It would be better if F-values were either part of the class, so that each would know its own F-value, or if the F-Values data structure were a from to F-Value. Either way, you'd avoid the errors that could arise from having two parallel data structures. You can actually avoid all this by making implement the interface. Then you could just say something like 

But that also makes it run out of space to hold the sum sooner. Conversion to String unnecessary You have a method to add the digits in a string, so you use it twice. However, the second time you don't have a string, so you convert the number into a string. Consider the following: 

Why do we need so many columns? The assignment is to return the movie title and reviewer name, so let's just do that: 

As a general rule, you want to put the interface on the left side, not the implementation. This makes it easier to change the code later with a different implementation of the same interface. 

I remember when I tried building a program in a constructor for a class, but it's generally best to keep constructors as short as possible. They should allocate memory and initialize variables. They should not ask the user for input. Constructors should be independent of anything outside the constructor. If you have a class called , then it should manage objects that represent a currency. What this class seems to be is a . In the following code: 

This uses a single subselect to replace from step 2 with a new version that only includes those / pairs where the second rating was higher than the first. 

It's generally better if you choose one style and stick with it. It may make sense to mix the first and third lines in the same program, but the first two lines should not coexist. I would use the second and third versions, but if you like the first, you could use the following with it: 

Another problem is that you apparently want categories and percents to be linked, one percent per category. So the C++ way to handle this is to make a class, but in this case, let's make a struct instead: 

If you don't mind that it checks more things than just POST and GET, you can use the superglobal instead: 

This seems a bad place to use move semantics. Note that the point of move semantics is to avoid doing a copy when you don't need to do so. However, here it may create a copy that you don't need. Note that your algorithm passes an rvalue reference to the function but returns an lvalue. If each recursive call triggers a full copy on return, your algorithm goes from \$O(n^2)\$ to \$O(n^4)\$. You might be able to fix this by saying 

so that it has a variable to reference. This also brings up another problem. The function will return a reference to the underlying data structure which can then be used in assignments. If the caller does this, they can bypass the bit mask that you use in assignments. For that matter, the caller could store a non-integer in the array. So maybe what you want to do is