This file had some singularities: 1) The information about each candidate was separated by '/' and not by new lines. And each information about the candidate (ID, name, exam note, composition note) was separated by ',' 2) new line characters were spread randomly throughout the text (I think that was caused by the Notepad or by the PDF program auto-break line) 3) The page numbers of the original PDF remained in the text file, and could be found beside the ID number, one of the grades or between parts of a name, surrounded by new line characters like "\n26\n". The page numbers ranged from 15 to 26. This is a fragment of the original text as read by Python: 

You could check if countto are allowed numbers using your own function getInput. For that, you can change: 

(You may note that there's a page number between the last grade of one of the candidates and the ID number of the next one right in the beginning of the fragment) So I had to find a way of detecting and removing the new line characters and the page numbers, and put each part of the string in the correct place taking into account that the names of the candidates could be of any size (Like "Anderson Soares Freixo" or "Maria Auxiliadora da Silva Santos Xavier". I came up with this code: 

Other suggestions Well, the code has some bugs and I agree with what Fac Pam said about splitting the code into more functions since it's a little hard to follow it's flow. 

2) When the program asks for a value to the extra bum, it says you can choose 0 for no extra bum, but you set the minimum input allowed to 1. So you must change min to 0. Answering some questions: 

I'm not an advanced programmer, but I have some suggestions I think could improve the performance of your code: 1) In the first line you make and then you use this variable 3 times calling . Instead, you could use , so you'd call this function just once. 2) I don't understand the use of here. At least in Python 3.5.2 I ran the code wihout the and it works just fine. 3) In the first if statement inside the for loop you test the minimum and maximum values of inp[1] twice. You probably wanted to test inp[2] in the last part. 4) Here: 

The code works, but I'd like to know if it could be improved (is there a clever and cleaner way of doing it?) and if the style is good. Thanks. (Here is a link to the original PDF file: $URL$ 

5) You made a while loop that evaluates true and put an if statement that may break it right after it. Instead of doing that, you may test the condition of the if statement in the while loop itself writing and removing the else statement that breaks the loop. 6) (edited) That k variable is actually unecessary. If you set j to 0 in the beginning of the first for loop, and add 1 to j in the beginning of the while loop, you will get the desired result without the need of an extra variable. With these modifications, the program would be like: 

I made this script to carry out a specific real-life task, which was to sort a list of candidates in a public competition by grade. The file with the informations consists of a text file copied from part of a pdf with the ID, name, grade in the exam and grade in the composition. There are a little more than 1,000 candidates. I needed it sorted by the final grade, which is obtained by the formula: 

I know these are minor changes, but I believe some of them may save some CPU and I hope they're useful for you. 

(I used .format here because it's the way I know, but it's not ok to mix format and "%" styles in the code. You should change that for the sake of coherence!) 

The requirement doesn't state what's the behaviour when there are no cans, so I assumed it is nothing. If you know what the requirement is in this case, I'll update my answer accordingly. Looking at your current method, I think the requirement is not reached. First you erase the old amount of tokens with then you refill the vending machine with 50 cans when it is empty, which looks really strange and induces an unexpected side-effect (see Principle of least astonishment for details). The requirement also states that you should be able to only retrieve one can at time (and not many). Here is how I would implement 

contains only notion of blocking until the value is not computed. How the value is computed is totally abstracted here. 

If the rules are likely to change, it would also be possible to refactor this code and take the "final predicate" as a constructor argument. Extracting "standard" logic In your case, it is only the rule that assert the password and the confirmation password are equals. This is not a business-specific rule but rather a commonly accepted rule everytime a user creates a password. Moreover it seems you have a "validation flow" defined (first check the equality between the two password, then check if the password in itself is valid) that can be extracted into a separate class 

Beyond the requirements The two setters are superfluous and can be removed. Also, Java class naming convention is CamelCase so you should rename to . Since your class is not meant to be inherited, you can mark it . Here is the full resulting class 

Class is open to modification should be closed for modification, this is the OCP principle. If it's not, its behaviour can be altered (by inheritance for example) and can lead to an unpredictable behaviour which make it rather difficult to test and maintain. How to achieve that ? Mark . Executor never shutdowned Once started, the executor can never get shutdown, which causes the task to be run indefinitly. How to achieve that ? Create a method: 

I also voluntarily removed the log statement. I'm not sure it really add any value when only logging "Create File". Either add more information such as where the file was created, with which name, etc. or get rid of it. In the end you could use these methods like this: 

is fine. The resulting string in is misleading. The is the amount of cans the vending machine currently holds and the is the number of coins that have been inserted. You should also directly return the string instead of creating an empty variable 

I see at least one big problem in your method: there is no separation of concerns. Everything is mixed into this method: common rule for password double-checking, business rules for password validation and UI calls for user response. Extracting the business logic The business logic in your case if the password validation specific rules, as you named them rule1, rule2a, rule2b, rule2c and rule2d. Everytime you will need a password validation, you will need these rules to validate a password, therefore I would extract these rules into a BO. 

There's still a bit of duplication between the but I think you get the idea. The goal is to avoid duplication in order to have tests that are easy to understand and maintain (clean tests are as important as clean production code). 

At the moment there is an method. However since you should add cans and not set cans, you should rather take as an argument the number of cans you should add: 

This parameter is the thing that bothers me the most in your class, and also the one who gave me the most trouble when trying to remove it. Why does it bothers me ? Everytime you have a in a method (or constructor), it's a sign of poor design because the class/method should do 2 things now (one for each boolean's value), therefore violating the single responsibility principle. It makes your code hardest to test and to maintain because of the conditionnal logic flow. If I understand correctly, the purpose of this flag is to avoid client code retrieving a when calling because the cache has not been updated at least once. I would rather resolve this problem by blocking in as long as the cache has not been computed once. In Java, one have the who is a thread-safe class able to fulfill this responsibility by blocking only until the cache is computed the first time. I came up with the following wrapper to achieve that: 

Your code has a call in the loop, I would remove this from production code on your website. It's test-code at best. 

But, I just wanted to make a point on these: ing: Triggering the inner lines, as well as the lines terminate the function, so the loop cannot be executed without returning. Meaning the usage of in these situations is entirely extraneous. Additionally, when you encounter duplicate code like that, try and make it more dynamic and able to accept both conditions (As Barry's version shows) 

That is, simply an improvement of what you have: IT IS JUST AS SAFE AS YOUR IMPLEMENTATION, WHICH IS: not very. 

The four opening statements' contents are double intented, this is an incorrect level of indentation. 

: You should be using the second parameter when using , because you need to provide the numerical system you're trying to convert into. If you're using base-10 / decimal, you should use instead, as it is more clear and without unknowing side-effects: 

There's only two states: not spectating, and spectating. What happens if I want to simply switch between players? Do I have to stop spectating, and then select a new player to spectate? Why can I not just press lmb and go to the next? 

Additionally, instead of direct string concatenation, I'd recommend using instead, this can give you better control in more advanced situations: 

Onto code, in , you initialise an array, build to it, and then proceed to it. However, in , you initialise a string, build to it, and then return it. In , it'd be better if you just built to the string instead of an array. 

chain: Instead of using these unlinked functions inside a big script, connect them all as a chain: Effectively looking something like this: 

Your code is really nice, and your use of generated property keys is really good. There's a few things you can improve upon: 

It's better to use an object here, as later you can extend it without having to spend pointless LoCs on s and ing. 

In , you could improve . Why don't you just set to instead, seeing as you don't use other than for that? In you should also improve your line spacing as well, as it seems a little strange. 

If you want to reduce the code indentation level, then you should use separate variables to store each step in the process, or just simply use a standard loop. 

This is very confusing. While I'm sure each of the letters have relevance to what the variables contain, you're effectively trading like 7 letters for readability: 

: Using the way you did is literally pointless. I don't know whether you're a Python dev and that feels familiar, but that's wrong. 

Using jQuery jQuery is a framework used by many to simplify processes, but do you really need it? An important question to ask yourself when designing / architecting a new system is whether you need a library or not. If you're building a slick, lightning-fast mobile site, you may not have room for massive libraries like jQuery. Luckily, people realise this and write helpful companion sites you can use like YouMightNotNeedjQuery.com Consider carefully whether it's better to write a little more code and not use jQuery, or whether it's better to lose a little performance. 

; With ternaries in PHP, if you don't need one of two results, you can reverse the if condition and use . 

Here, you're defining multiple cases that have the same result. There's two ways to approach this problem, while the first is better for readability, it's redundant in this case not to use the second statements use fall throughs, which means, if you don't explictly declare , it will keep falling down and down. Take this snippet for example: 

On the subject of , in general you shouldn't compare to , then it. You should leave the check empty (checks if the variable is ) like so: