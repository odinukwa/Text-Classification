It seems weird that in the login would return multiple rows. I would expect only one user to be associated with a particular emails/password login. In your controller you have duplicated this code three times: 

Your new approach is much better than the previous one. Instead of deriving from and using to hide the base class implementations you create a wrapper around a implementing - this is a much more robust way. However there are a few oddities: 

If you use strings like "star1" and "star2" in multiple places then consider making them public const fields of a class rather than sprinkling string literals around everywhere. If you ever decide to change them you will have to change a lot less code. 

First and foremost I think your implementation is broken: returns the original value at the location. So in your lock methods you should spin until the original value was and not . As for your first question: Besides that "better" is a very vague term - no I don't think making it a is better for the simple reason that you have a mutable structure (it can change it's own state between locked and unlocked) and mutable are generally best to be avoided - the value semantics of it can trip you up pretty quick. For your second question: As per MSDN all Interlocked methods make use of the appropriate barriers. In general: 

Consider forcing the error by causing the div by zero right there or changing the interface of the method to: 

First: I doubt that creating a new object creates enough overhead which has measurable impact on your system so unless you can prove that it's a problem don't worry about it. That being said: The classic solution to that problem is lazy instantiation. As you have a property already this can be easily achieved by: 

If you have followed the suggestions above you will now have a array as well as the with the removed. This should make building the matrix easier: 

I can't help with the security aspect of it because I don't know enough about it. So just same general code review things: 

You re-compute every time is called. Since should be considered an invariant you could do this just once in the constructor Hidden in the comments inside the implementation of is the requirement that the passed in modulus has to be a Mersenne prime. This should be at least documented in the constructor invariants. Since there is a reasonably efficient test for Mersenne primes in form of the Lucas-Lehmer test you could test this in the constructor. Now obviously if the passed in prime is reasonably large then this could prove impractical but I suspect your implementation would run into other issues in that case as well. OTOH there are only 49 Mersenne primes known, so you could store the exponent of all of them and test if (based on ) is in the known Mersenne exponent list. Means you'd have to update the code if they find new ones but this seems to take quite some time these days :) 

Well, you could build a dictionary for the temp array but it depends how often the key (index 1 of each temp row) is repeated. If you have very few repetitions then it could reduce the time because it only has to search through a subset of the 1000 temp rows. Something along these lines: 

Use: Throw a with the message as the failure reason and catch it when calling the validation method and log/display the message to the user. 

The first option is cheap and will reduce some of the code complexity ( as opposed to a multi-line LINQ statement) so I'd do it anyway. 

This might have been mentioned before but here it is anyway: You should format your code. Badly formatted code is hard to read - it might be the most efficient code in the world but it's still hard to read and maintain and easy to miss bugs or easy to add bugs. It also shows a lack of attention to detail and programming is all about attention to detail. It basically demonstrates that not much care has been put into. Whenever you write some code imagine you'd have to show it as an example of your work for your next job interview. You should name your classes and variables better. While is acceptable for a loop variable , , , and should be renamed to reflect what their meaning is. It is especially confusing since suggests to have a similar meaning to and while it actually is completely different (it represents a form of input rather than a number). You should use an rather than a fixed size array to store the divisors. If someone inputs then your program would try to allocate an array with 2,147,483,647 elements - approx. 8GB of memory even though it's a prime number. If you change this then your check for the common divisors need to check the common subset s of both lists instead. Your two loops do the exact same thing except on different inputs. They should be refactored into one common method which performs the calculation and gets the number to check as input. Your algorithm is buggy. For example if you check and you will not find as a common divisor. 

Update 2: To complete the example (based on your pastebin, note I changed the method above to accept a filename rather than a directly) 

Avoid throwing generic - be specific. In and it would probably make more sense to throw an . You should try to bail early. Right now in and you perform a bunch of operations just to potentially reject the post later. Something like this would seem to make more sense: 

Depending on how the objects are used rather than building two inheritance hierarchies (one for request and one for parameters) you could make the request objects generic. So something along these lines: 

You should use to read an entire line. If you pass in a pointer it will manage the memory allocation for you (you just have to remember to it later). You check for and but then later subtract the magic number . You can subtract instead which will make it clearer what you are doing. Same goes for subtracting instead of . You could sprinkle a round a few more spaces to make the code look less squeezed: 

Now all you need to do is to check if there is a solution for with where is a whole number which ultimately boils down to finding the smallest where 

Regarding the performance: I hacked a version together based on the standard which turned out to be about three times slower however the code is vastly simpler and shorter (Note: I added an interface to make testing easier): 

Both and are and should therefore be wrapped in a block to make sure any unmanaged resources are properly released. Prefixing all your local variables with smells like hungarian notation and is generally discouraged. It adds not value and just clutter. Your variable names should indicate what they represent and not what type they are. In C# land the common naming convention for methods is and not . It pays to stick to general naming conventions for the ecosystem you are working in as it will make your code look more familiar to other developers. 

I can see two reasons why your program might be slow. The first one is that for each row you allocate memory and then free it. If you move the allocation outside of the while loop and reuse the memory then this will get rid of a whole bunch of unnecessary memory allocation operations. The second one is probably more important: MPI stands for Message Passing Interface. This means that communication between nodes is done by passing messages around. The easiest to imagine an MPI program is to assume that each node is a computer and that the program is running on all these computers in parallel and that the programs can exchange messages over a network. Hence one goal for a performant MPI program is to minimize the number of message exchanges while maximising the work each individual node is performing. What you have done is to split your problem in very small chunks which you are then distributing to the workers. What you should do instead: If you have N workers then split up your program into N parts and send each part to a worker. This is essentially the minimal number of messages to exchange if you want all N workers to participate in the solving of the problem. So rather than sending one row at a time send rows to each worker, let them compute all of them and gather the result back.