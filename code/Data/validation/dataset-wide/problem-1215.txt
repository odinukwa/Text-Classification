Disclaimer: No actual kittens were harmed while writing this program. The number of iterations is held in the variable . I know is a more fitting name, but that's already claimed as a type. The above is compiled using the latest lci using the 1.3 specification (thanks to Pimgd for the link). Since the 1.3 specification doesn't contain every feature of the language, see the 1.2 specification as well. I don't think LOLCODE has templates or the likes, so getting all the output on screen is a bit tedious. Output: 

Basically, it works like a charm, the result looks like a charm, but the code itself could use some serious clean-up. 

Poof! No more . But wait, this still doesn't solve your TLE problem! No, I'm afraid not and I'm going to tell you why. The author of the problem has made the constraints so narrow that the only acceptable solutions are those which use the Convex hull trick. It basically boils down to checking whether a value is instead of . I'll leave the actual implementation of said trick to you. Feel free to post a follow-up question once you've implemented it. 

Don't Repeat Yourself Generally this adheres pretty well to the Don't Repeat Yourself (DRY) principle. One place where I see repeated logic is in the check for the exception you're describing in the question. This can be moved out to its own method: 

IEnumerable Okay, the above is a bit ugly- lots of fiddling with enumerators, and unhandled error cases (what happens if you reach the end of a finite collection of integers?). But this is because we're missing another trick: itself is a box you can pull s out of, so it should itself be an . The structure of just repeatedly asking for a "" value very closely matches how is laid out. So that aforementioned ugliness is a code smell specific to C# hinting at this to us. So, making that adjustment, we end up with: 

This then wouldn't be evaluated until the collection was enumerated over. However, I think that's probably more confusing/unexpected behaviour than the simple eager . 

Probably the best way to decide what extension methods to include is to look at LINQ and decide what methods are applicable, and whether they need to be renamed. For example, is useful, but might be better named . is also useful if we think of it as (in the same sense as null coalescing). However, we're sort of cheating here. By making internal, we can write the extension methods we need, but only in this project. By contrast, lets anyone extend it by exposing the underlying properties needed to use it. We could fix this by just exposing , but this again is potentially confusing to consumers, and could be thought of as an implementation detail. It's somewhat a judgement call, but an alternative would be: 

However, I vaguely remember you're not supposed to use in JavaScript unless absolutely necessary. What would be the more idiomatic approach for this loop? 

And all of a sudden, a black ring appears at coordinates 50, 50. Now, you can re-use your code without actually touching your old code. All you need to know is you can use the function from the file and what arguments it takes. Noticed the docstring on top of the function? It's there for (among others) exactly that reason. Telling your user (or future self) how to use the function. On default arguments: Default arguments (default parameter values) help with setting a default ring. If we 'just want a ring' and don't care about it's size and color, simply calling the function will do. They are the values used if no other values are provided. Basically, giving a default gives you the option of making that parameter optional instead of obligatory. If it's missing, the function will simply take it's default instead. Note: is probably your radius, diameter or a value derived from either of those. Renaming it to something more sensible would be beneficial. 

A bit cumbersome in English, but the above is actually the exact basis of what you did. So the next task is to translate that as plainly into code as possible. First, we look at "I check each multiple". That doesn't say "I check 1 * the row count, then I check 2 * the row count, then I check 3 * the row count". It expresses all of those in a single statement: each. So translating that as literally into code as possible, it's not a bunch of statements, it's a single loop: 

Something as simple as for your method might be more appropriate. Going by LINQ conventions, is also a more idiomatic name than . 

We can take the same approach with the other input/output sections, to now get a clearer version of your algorithm: 

As a more general design note, it might be preferable to do this validation at a different point in your process. For example, s can be set to require a particular , and can also be told whether or not to accept null values using the property, meaning the table will largely do this validation for you. 

was provided, as was the empty function (and no, it is not allowed to pass as an argument to the function). The required code is as straight-forward as it gets, but I feel there's a more proper way to do the string formatting. 

One of the projects that have been on my to-do list since years involves controlling a number of Inter-Integrated Circuit (\$I^2C\$) peripherals. Lately I've been turning everything into it's own library and I'm wondering if I'm doing it right. While the libraries are usually called by a server-like script, they all have a demo function as well. My goal is to write a production-quality library for multiple controllers. To make sure I didn't make any silly mistakes, I put one up for review. The following library will control a LED-shield connected by I2C to a Raspberry Pi (B+). Registers 2 till 8 are responsible for the lighting and take values from 0 to 255. Overflows (values above 255) are not a problem, since only the last 8 bits will be saved in the hardware. However, this is potentially wasteful on the bus. There's one method of setting the white LED and two methods of setting the red, green and blue LED. The latter can be set by using RGB or hue, saturation, brightness (HSB) values. The library makes use of the System Management Bus (SMBus), which is a simplified version of \$I^2C\$. Since nothing time-critical is going on, this does suffice. A library should have docstrings just about everywhere for introspection and plenty of other reasons (see PEP 257). Those get tedious quickly, and can probably be improved. The docstrings are explicitly up for review. Led.py 

I agree that having to throw that exception to appease the compiler is ugly. There's also another bit of unpleasantness which isn't quite so egregious, but helps point to what's actually wrong here: Your while loop condition is 

In this case would just calculate the big primes from the small ones, probably using a recursive inner function. A useful technique to allow you to do this without any state mutation is to have an accumulator collection as a parameter to your recursive function (often called ). Then instead of having some list you repeatedly add results to, you pass a new to each call of the recursive function, created by prepending the result to the previous one . So as an example, instead of: 

The timer/half-open logic would go inside , and hopefully the rest is clear just from the code. I'm not suggesting this is exactly how you'd write it, just giving an outline. This would be a very simple implementation, it would only require this one public method, the enum and the two private methods. So, quickly running through programming principles, is there any where this falls down compared to the larger implementation? Going with SOLID, it conforms to the Single Responsibility Principle. Liskov Substitution, Interface Segregation and Dependency Inversion are irrelevant. But there is one problem point: the Open/Closed principle. Clearly, most changes would require going in and modifying existing code, probably really getting our hands dirty mucking around with that logic. But now that we've identified that, there's two follow-up questions: 

It's at the moment. But what if you want to support more or less characters? A different character set? You'd have to change those hard-coded values every time. 

As you can see, I'm inconsistent within the functions and there's needless repetition. I'm also hacking my way into the library where I feel a more OO approach would look better. I think separating whatever you want to send to should be done by comma's whenever possible and concatenation should only be used if there's no other way. Since I have to print the name of the book between , I picked concatenation for whenever the usual style (comma's) wouldn't work. Now it looks like a mess. Should I've switched to concatenation the moment one part of the string is using it? Does JavaScript have something like a or would that make it look worse? I'm not sure this is the idiomatic way of retrieving all the elements from the library either. Or hey, I may just be over-thinking a simple challenge. 

That's 3 counts of per call. It's obvious you're translating something, but the rest is vague. Afar from that, are you familiar with the Python Enhancement Proposals? Some of them include style suggestions, most notably the PEP 8. You might want to take at least a good look at it. The most notable violation of your code against the PEP 8 is your lines are too long. Long lines are hard to read, hard to parse by humans. The readability of your code will improve if you split them up logically. The ugly way of breaking-up lines is with line continuations: