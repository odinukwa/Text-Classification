The latter is nice because you are certain you won't have any attributes from the last run leftover, messing with your methods, the former is nice because you don't have a multitude of instances (I am not sure what happens with the first application when you create another one, since it isn't stored anywhere). Not exactly knowing which way was the cleanest to do this, I asked a question on SO about resetting classes. It seems that calling or any -methods directly is bad form. We could however move the definition of the class attributes to and do the following: 

I am currently learning C# since the last week. I have little to no prior experience with any of the C family of languages. I implemented the Nelder-Mead algorithm for numerical optimisation of a function. My implementation exists of a function that takes two arguments, the function to optimize, and the amount of dimensions that the function has. So for a function that goes R^N -> R, the second argument would be N. The implementation is based on the algorithm shown in the linked article. Along with the algorithm, I also implemented two functions for evaluation of the algorithm: The Himmelblau function and the Rosenbrock function. 

This post is specifically for the GUI, since this is my first time working with PyQT, so I am not sure if all is done properly. The file with the file with the classes Query and Universe and an example JSON file can be found on GitHub. 

I found myself wanting to use Linq to map void methods to an IEnumerable to modify all items. The existing Linq methods require a return variable when mapping, since they are based on . So I decided to try my hand at creating some extension methods myself. This is the first time I've done anything like this, so if there are any pitfalls I'm missing, please do tell. I created two extensions, one which applies a foreach loop to all elements, calling an for each. The second one is basically the extension, which allows for two s to be iterated together and again maps a to both of them. 

is not returned or modified, nor should it be. As such, it should be declared , so that the compiler may make optimizations and assumptions around the fact it will not change: 

Factor has really slick builtin unit-testing. Here are the docs; I'll pull an example from my directory: 

Avoid global variables, as implicit global state should be avoided whenever possible, especially in small programs that have no need of it anyways. Additionally, the descriptiveness of a variable name should scale with its scope. , , , etc are good for loop counters (especially since programmers know and will be loop counters); for function scope, depending on the inteded lifetime of the variable, you should use at least a word or two, perhaps shortened. For global variables, especially those globals that have little cause to exist, you should justify their existence with better names. could at least be , but that's still a little vague for a global. I'd go with () and (). Finally, is a god awful variable name for any scope or lifetime longer than a couple lines. 

Well, now the program aborts 100% of the time, and it will take you a couple minutes to figure out why because of the tricky indentation. If you had used braces, this would have been avoided: 

C is very cool in that you can do this in one line, but that doesn't mean you should do this if you don't have to -- and you don't have to. Here's one possibility: 

Perhaps this might be regarded by some as a non-issue, but for my workflow when I just want to test something quickly, it's really handy. The functions: 

If the input is not numeric, you return , but not when your input is outside of the range. You might want to add a check for that as well: 

However, in most cases, only one of the points of the simplex changes between iterations. So only one point needs to be re-evaluated. Conveniently, this re-evaluation is already done in the previous iteration: 

is defined, but used nowhere else. Also the use of is bad (was an oversight). Indirectly still iterating over 

With advancing insight I have found a few issues with the code. Check for convergence doesn't work properly 

This checks if the minimal and maximal function values of the simplex are sufficiently close together, but an easy counterexample shows that this nowhere near guarantees convergence: Consider the function . Of course this is trivial to minimize, but using this algorithm, we would have a simplex of 2 points. Let those points at some point using the algorithm be and . Then the functionvalues will both be , and the algorithm will stop. Instead, I changed this to checking the value of the centroid of the simplex. 

Only during shrinking do we have to evaluate more new points. So we can extend the code where we break the iteration with a modification of the array and move the loop evaluating the simplex to outside the while-loop. 

Since that improves the naming, and removes the need to keep the attribute around. So we can turn that into a regular variable without the . Expand the methods to also allow for removing of that item. This is mostly relevant with the GUI in mind. It contained a bit of a workaround to be able to remove tables and columns from the Query. So I added an argument to the methods to be able to set to remove instead. 

This scalably-threaded server has endpoints at and . This is just an example of how to use antiCSRF and you should never ever keep reusable, long-living secrets in your users' browser history. In the real world, instead of negotiating over , use with JSON or URLEncoded data, like me. I'd especially appreciate guidance on improving the threadsafe aspect of the library, but of course all recommendations and criticisms are appreciated. Finally, I fully expect to be told this is an insecure and wrong implementation, so tell me how I can write it better from an internet security perspective. 

Ahh, maybe it should be called or so? And why does get a name while and the other operators don't? No apparent reason, so far. 

I was irked by the amount of typing in that, so I wrote a couple of tiny functions that live in my , so I can just do (for example): 

These are poor variable names -- you are not limited to 6 characters, like assemblers of old! Seriously, there's no excuse for these to be named this way. I can only guess that is the determined type of the input, is the determined resultant operator, and is the raw input string, but I shouldn't have to guess. Use better names, and then use comments for more complex ideas. 

must be declared except if its return type is omitted, in which case it's inferred to be by the compiler. Compliant programs declare . Since C99, need not explicitly return -- if you omit a return value, the compiler will insert at the end. 

The second option above only works because you run the entire functionality of the class from within the method (which may or may not be bad form). When the new instance is created, the back and forth prompt is executed right away, so the moment it would go out of scope and get deleted (because it isn't assigned anywhere), is only after you are done with your input and output (and possibly been given anyother option to reset). 

You don't do this in though. If you have a list of length 4, the call will look past the end of the list. That's a problem. One that's easily fixed by the same checks as above. You probably also want to validate the input for . You don't want a position as input, and neither do you want an input past the end of the list. 

Because I am new to C#, I am interested in advice/commentary on good form, but I am also interested in the efficiency of this implementation. 

In addition to the other remarks: does exactly the same as , so you could either call that directly: 

Length You provide a method to calculate the length of the list. But from the moment of creation of the list, you should be able to track this length. If you add a private counter, increment it whenever a node gets added, and decrease it whenever a node gets deleted, you should be able to instantly provide the length, instead of having to compute it each time the user requests it. Repeated code You provide methods for deleting the first node, the last node, and any node. In the first two methods you kind of repeat the code of the latter method. You could redefine those by calling the latter: