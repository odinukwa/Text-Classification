This is what I assume your thought process was, so I will review based on that assumption... Interface First up, the interface idea is a good one.... but the varargs parameter is a problem. You should only have a single argument. Also, since you want to keep the input argument anonymous ( instead of ), you should have some exception handling for those times when invalid data is supplied.... The reason for suggesting you have only a single input parameter is because the logic for choosing which instance is used for the transform is not easy to specify when there's multiple candidate input values. You should let the calling code make the decision as to which instance to convert from (note, this is related to a second problem I will address again in a moment) I would also recommend renaming the interface method to something more verb-like, such as instead of Bottom line, I would recommend an interface like: 

Similarly, another bug that has 'creeped' (crept?) in is you change the 'p' parameter after the request is posted.... 

The above solution will not overflow. You should, when partitioning the data, consider values equal to the pivot value, to be either left or right of the pivot. Your code you use a strict or depending on whether you are on the right or left. One of those should include . Your code, as it is, will run through the actual pivot value and do some funky business with it. You end up moving the pivot around in various ways. You have a potential overrun (buffer overflow) in your loop conditions. It is posible, when you get to this line in the pivoting: 

There are a number of things that could be improved here. You're doing the right thing with the pre-compiled regular expression/pattern, but, you have fallen victim to the little-known auto-format-muck-up-monster, and what I consider the magic-value-overcompensation issue: 

Bottom line, is your code only works for limited use-cases. I would much rather your code had a 'sentinel' node, which was never null, and then your actual data follows from that head position. That would reduce your code, and make the insertion process simpler, and also fix both issues above. Note that the 'head' node would be kept as part of the class fields somewhere, not passed in as an argument to the (recursive) method... in fact, the method should not be recursive 

This bit representation of our three-bit number shows the possible combinations! If we take an input data set of {a, b, c}, and then use the bits in the above counting to indicate whether the data member is 'in' the combination, or 'out', then you can do the following: 

There are two problems here... both related to datatypes. First, though, I don't believe you can get much more in the way of performance. Make sure you have adequately warmed up your system before you take benchmarks though, the Java runtime will get faster with successive compiles. Make sure you are benchmarking it at it's fastest. OK, now the problems: First, the inputs are double values, but you are calculating int values for the rectangle. If you input the data as ints, it will be faster. The second problem is that, if your input doubles have a fractional component, then your bounding rectangle is wrong... it shoudl be on the outside of the points, but, because you are doing integer conversion, it will not bound the points on all sides, but will sit inside of what would have been the rectangle if the rectangle's coordinates were double too. I would guess that a large part of your performance hit is from type-conversion. Finally, it may not help, but I have had success before, from converting the method, and all the values inside it, to be final. This may help the Java JIT compiler to inline the calls in to it's compiled code. Try it, and benchmark. Edit: More about the double/int bounding rectangle. If you have the points and then your code will compute the bounding rectangle as , but it should be ... (or should it)? 

The reason it will fail is because the method trims the line terminators off of each line, so, the input to the regex will be just , etc. Since there's no whitespace after the , the match will fail, and the method will return null. You should consider an alternative approach of doing a limited split, and returning the first value: 

Assuming the transformations that you do in each of these are similarly expensive to do computationally, then you can probably make your system go 5 times faster by doing them each in parallel. Five threads: 

In each of these cases, the code should be 'exemplar', and you should clarify exactly why this code is needed... but, if the answer includes the 'parallel execution' reason, then the concurrency had better be accurate. forEachRemaining() one of the performance advantages of Spliterator is the method, and you have chosen not to implement it. Why? Queues are Queues Your code really boils down to being a queue processing tool. The is a queue, you have content on it, and you process it from the beginning, and add stuff to the end. Occasionally you split the queue. Use a Queue (Deque). Specifically, you should probably use an LinkedList (which is a Deque). If you use a queue, there is no need for the variable, and code like the trySplit becomes (here, is an LinkedList`): 

But, does not mean array length, it means "end-exclusive", or "ignore-from" or something. One of the common tricks in the quickSort is to use the actual index of the last element in the partition, instead of the length. For example, you call the method with: 

That parser can identify lines that interest it. If the line can be parsed, it is fed back in to the parse method, and all following lines until the parse method returns true. A simple exception is also useful. Making it a makes this easy tp put in to streams at some point too: 

The two sorts are \$O(n \log n)\$ performance, so this is, so far, significantly less complicated... now, how do we compare? Well, with a 'simple' loop over all the lookIn characters: 

What is the monitor used for that? Well, it is the class itself: . Now, this may not seem to be a bad thing, but, what if someone else does: 

Then, create an implementation of the factory for the current version of the web site (because you will need a new version when it changes). OK, so now you have a simple factory implementation for the data interface. The benefits of this are: 

General I am not happy with the variable name , it is too similar to which I also use. I have the code here in Ideone too: 

Uninterruptibly My preference is to wrap interruptible calls with the uninteruptible caller. You have implemented the calls two ways, and that duplicates a lot of logic. Consider this instead: 

In this case, I would consider using a CTE to contain the columns you are interested in. This saves having to declare the variables, and also saves the inserts, etc. The basic concept is the same as your second query though... 

So, the above code uses scalable structures to do the algorithm, but incurs the setup cost for the Set. After that, the scalability is about \$O(n)\$ ... In my testing, for data of sizes less than about 10, your code was faster, but, after 10, my code was faster.... and, when you have sets up to 80 or more, my code was 1X faster, and up to 400, my code was 12X faster. To make things work even better, I added this function (BOBW is 'best of both worlds'): 

If you are familiar with regular expressions they can be helpful in cases like this too. A file extension is anything after a that's not a and is not at the string's beginning. So, this requires a pattern that uses a positive lookbehind, and then a generic match on the extension: 

By using a to contain the collection of distinct values used in the input array, you get O(1) performance (on average, slightly worse in the event that the dictionary key values become congested - which in this input example is very unlikely. By combining the identification of the left-portion with the full scan, you can reduce the number of iterations (though it is still \$O(n)\$). Here's the resulting code: 

Create a Tile Object for each Tile. The instance will then just become a loose collection of Tiles. Keep the tile location embedded in the Tile instance. Treat the empty space as a tile, and the 'rule' is that the Empty tile is the only tile that can swap positions with it's neighbour. You can embed the logic in to methods on the Tile to identify the tile position and directions. 

Then, we loop. In the outer loop We know exactly how many loops we will do because it is \$3^2\$, 9 times. That's how many passwords we generate. The interesting part is the inner loop. On start up, is . We treat this like an index in to the characters, and we increment the right-most one. Let me lay out all the increments for you: 

Finally, when monitoring things this way you always have a fencepost problem. Your work is the space between the fenceposts, and the fenceposts are the messages you write. You always have one more fencepost than space between them. You will need to have some message outside the loop. In your case, you do 100 items of work, so you will need 101 messages. I tend to chose to print the progress message after the work, so I tend to pre-print the first message before the loop. Also, you should have a simpler system for mixing the work (the ) and the messages(). Consider the setup: 

What the recursion shows is that you repeatedly have to solve the 'tail' of the process each time you solve something near the head. That's a lot of repeated work, what if you could 'remember' what you have already calculated? Where does that lead to? It means that the temporary int array should be used to keep state, and used to optimize the process. Here's a hint.... If you start at the end of the data, and work backwards, you can count how 'long' the sequence will be from that point, to the end, if that point was included in the result. "Remembering" things like this is a concept called 'memoization'. Since this problem suits memoization so well, it seems natural to include it. To implement it, you have two loops, the outer one counts from the last element to the first. In that element, you scan the next elements looking for the value that is larger than the current element, that has the longest 'chain' to the end. The loops are simply: