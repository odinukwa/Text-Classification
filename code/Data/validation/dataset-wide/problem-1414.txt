Easiest to right after main() is entered. You don't need a switch to convert a random number to a value. You can calculate it (or with enum cast it). 

If you are using C++03 then is still acceptable. But nearly all implementations now accept . This is better it is type-safe. 

OK. In a tree the ownership may seem obvious. But I would prefer to ownership explicitly defined by the code (this will prevent mistakes later). Thus you need to use smart pointers so that you explicitly define how ownership of pointers as they are passed around. 

Higher Level Functionality You should also note that C++ now supports much higher level constructs than threads. If you use it will effectively add to a background system threadpool for you. Things to read about , , Review This is a C header 

This removes you from the list, but does not reset your own left and right pointers. This is OK when you call it from the destructor() or join(). But what about release()? Lets look at release(). 

I would adapt these rather than making your own set of variable names. 4: Commands Standard conventions means that variables should be in all caps. 

As both the others have said use if you are going to dynamically allocate space. Its not going to be worse than your code;if your compiler implements the small string optimizations its actually goinf to do better than your code as no dynamic memory will be used. 

I would rather change the interface so that the caller of does the actuall delete of the manager object. 

Or you could use a memory mapped file: Its been a while since I did this. Here are some instructions. $URL$ 

Also note that serialization (printing/streaming) is normally done with in C++. Stop this one liner stuff. It just makes it hard to read. 

This is declared way at the top. You should declare variables just before you need them. This helps in the readability of the code (as I don't have to scroll back to the top of the function to find out what the code type is). Also it prevents you wasting an instruction initializing a value that you will never use (here you init to zero but is that just a waste). If you declare at the point of usage you avoid that waste. 

In all three of your examples you limit yourself to using arrays. This is not very C++ like (even if you templatize the object). I would change the interface to use iterators. That way your sort can be applied to any container with a random access iterator. 

Don't use single letter variable names. If your function is only slightly larger then looking through the code and finding all the uses of can be hard. Give it a longer more unique name. 

I don't think the sockaddr_in is structured like you think. I don;t believe (I could be wrong on this) you can assume it is an integer. The on;y way I know of setting the destination host is 

So passing a 1 here is wrong. As you will never find the first element. You should have noticed there was not check for . You can't find this person if you search from as they are in position . Unfortunately your check loop also started at 1 so your code missed it. 

The difference is that will also flush the buffer. This makes using streams very in-effecient. You practically never need to flush the buffer manually. Rather than using a manual loop. Prefer to use an algorithm 

For the is is unnecessary; as they are held in the tuple by reference. So here does not buy you much (apart from me scratching my head for 10 minutes :-) On the other hand it does seem correct to pass by r-value reference, but because you don't use they are decaying into references when you pass them to the constructor (I could be wrong on this last point (still getting my head around this new fangled stuff). 

In both this and your bubble sort implementation you need to start using C++ idioms (otherwise this is just C code (that's fine C is a great language it's just not C++)). I would say this is the perfect C implementation of insertion sort. But usually when you implement these kinds of algorithms in C++ you use iterators to specify the range (as this allows you to sort several types of container including arrays). Rather than: 

That way you don't copy the parameter just make a copy into the new object. Also you may want to look at the opertunity of moving the object into the node. 

Notice: rather than to prevent white space being skipped. Why are you treating a file output differently to output to std::cout? 

If your code never returns anything but then it has become convention not to add the return 0 to main. This is an indication to a reader that this application will never indicate a failure to the OS. The dangers of unsigned You should probably always use signed types when working with numbers (save unsigned types for bit fields). Yes I know that the standard library uses unsigned types for and stuff like that. But believe me the standards committee regrets that mistake and have publicly said so. BUT they are not going to change it (too late). The problem comes from C (and thus C++) automatic integer conversions. If you pass a signed value to an unsigned parameter the compiler will silently do the conversion (even if the value is negative). The problem is you can not detect the conversion and your bounds checking will suffer: 

Which brings me to your formatting. Your code is really hard to read. Use the same rules for parameters that you would for normal variables. There is no extra points for minimizing vertical size. Your fourth constructor is good. But to be complete you may want to add a fifth to handle the nullptr (as it is not a pointer type, just convertable to a pointer type). But 

To do this properly you should have had a public interface that does not allow the user to specify an parameter. All this does is delegate to a private method and default the value to . 

The difference between the two is a flush of the stream (done by ). Flushing done by the user is one of the main speed slow downs in C++ code over C. The streams will already flush themselves at the optimal time, so a manual flush will usually retard performance. Prefer to use automatic variables. 

This only needs to be done once in the application. So you can move this out of the function. Don't need to close a connection that was never opened. 

Overview Its an improvement over the first version, but still some work to go. I think most of my comments below are relatively minor and the worst ones come from assuming the type being sorted is an . The other major flaw is still efficiency (though it has improved considerably). First prefer move to copy. But you also allocate a vector on each recursive call down . That can be made more efficient by only doing it once at the top level: