(Okay, seven problems. I was close with "three".) Removing this one line (and moving the function into a unit test) would fix all of these issues in one fell swoop. 

Taking the latter approach (two values by return) and applying all our rules except "no raw and ", we end up with this: 

As you might have guessed from that pull request, and from the observation that move and destroy must appear in pairs, IMHO it is good practice to combine them into a single operation, whose widely accepted name is . However, you'll still need a type-erased operation as well, to call in your actual destructor. 

Nit: is technically the wrong name for a single dimension. Also, by capitalizing the template parameter, we've freed up the shorter name (or ) for the constexpr member variable. You never have to use a tediously long name like if you manage your naming real estate effectively! 

(Oh yeah, I think your use of in this function was bogus and could result in dangling references. Certainly would be fine, so I recommend it.) 

and possibly throw in the since it's pretty easy to express; but bearing in mind that when you provide an explicit return type you enable SFINAE on that return type, which could theoretically turn some wrong code from a compiler error ("call to is ambiguous...") into code that happily does the wrong thing (since one of the candidates is now SFINAE'd away). That's highly theoretical, though. Now, how do you make this function a of ? That's easy; just define it inline! 

Using a dictionary/ hashtable would make more sense than using an array to store the frequency of each number. I'm not sure if creating an array then setting the 10,000th index (eg, if var A=[10000, 1, 1, 5]) as something takes a lot of memory (I don't use js a lot). 

Formatting. Your indentation is all over the place. This is probably due to the copy paste into the text box, but if not this is the biggest thing to make your code more readable. 

I'm not going to make arcAlreadyInAnyGroup, it can just be some linq to check if arc is anywhere in arcListOfList. 

On top of the other answers, I think in an interview it would be a good idea to use "main" to set up variables and call a function which encapsulates everything. The question asks to find the common element from 2 Arrays, not a hashset and an array. I would edit the code to make a function which takes in 2 arrays, converts one to a hashset, then calls a second function which takes an array and a hashset (like the one you have). I think this would appeal to interviewers. You're showing them that you can be given a task like this and write it so it can be useable very easily by others (abstracting out complexity). You're not just proving you can code, but that you can be used (as a resource) by the company in an efficient manner. So your "main" becomes: 

to check if the proposition is logically valid (true for all possible inputs) to check if the proposition is false for all possible inputs. to check if two propositions of the same number of arguments have an identical truth value given the same inputs. 

Now the first line says this: is of type , as long as the constraints in what we call the context are met. Here the context is what comes before the , and what it says is that , the type, is a member of the typeclass. This means that we're saying that any type which maps a to any type of is itself an instance of . Why are we doing this? Well, let's start with the simplest case. is an instance of typeclass , because we defined this 'base case' explicitly. Okay, so then is also of typeclass prop, because we said that any type is in class . This gives us the functions which take in one boolean argument and return a boolean. Examples: , , , . (In fact, these are all such functions). How have we defined whether to determine whether one of these functions is ? Our definition says that 

@LokiAstari hit pretty much all the points I'd have made, but I'd like to expand on one point and then make one philosophical point: 

It's bad practice to call the user-provided function while holding the lock on . Consider what would happen if tried to take the same lock: 

On these two different models, your algorithm performs very differently. On the latter, you do well: . On the former, you do poorly: . This is kind of like asking for a compression algorithm that compresses all possible inputs. You can get compression for some inputs only at the expense of others; the art is deciding which kinds of inputs are "interesting" and which can safely be blown up. In this case, you can get sub- performance for some inputs only at the expense of others; the art is deciding which kinds of inputs are "interesting", which is to say, deciding on a model for your "average" or "expected" input. EDIT: My analogy above is flawed, as indicated by LinMa's comments below this answer. See, if you can get performance on your "expected" inputs while blowing up the "unexpected" inputs by only a constant factor (e.g. " plus a constant number of comparisons" or " times two"), then you can keep your algorithm's worst-case big-O "constant" while improving the best-case. Hope this helps! 

I'm going to assume there's no rule against having multiple arcs going in/out of a single point, as there's nothing stopping it currently. If it's possible to have multiple arcs entering/ exiting a single point, we need to change: 

So now another dev can come alone and use without worrying about doing any of the messy converting to hashsets etc. 

Lastly, a few comments and better variable names could really help. "A" should be something more descriptive. Ps: The variable A in 

I like your answer. It looks a bit like a counting sort, which is very fast. I expect it's faster than a few of the other answers, although Joseph's answer is cleaner and more readable for sure. If I'm not mistaken your implementation is O(n) (which is excellent). A couple (minor) things: 

I'm sure there's a few code smells in there, but you get the idea. Just traverse out from one arc, and add any connected arcs to the group. The runtime here could also be improved a lot I think. 

That's about all from me... I don't code a lot in js, so any comments are welcome if I've made mistakes above (but I think most of it's pretty applicable). 

Also notice that I'm using instead of . Always prefer to use and instead of raw and — again because it helps avoid subtle exception-related bugs which if you're lucky you'll never see in the wild; but also because if you get in the habit of never writing or yourself, you'll be able to spot more easily when other people's code incorrectly uses or . Ideally, you want to get in a situation where you can install a git commit hook that does a and fails if it finds any! 

As for how your list of handlers should be defined: almost certainly you should just use a list of handlers (i.e. — or if you really want to keep your original design's ability to have handlers drop out of the list at random). I don't think that a ought to have any idea of its parent; unless... do you think that the parent of a given handler is part of its "identity"? For example, in my example above, do you think it does actually make sense that if an 's dies, the would have no way of contacting his late 's , so certain requests would go unhandled? If that really is a feature-not-a-bug, then okay. 

It says that a boolean function of one boolean is valid if and only if and are both valid. Of course, the validity of boolean is just that boolean. So in this case, can be thought of as being a bit simpler: 

It won't be very often that a number is , so let's tuck that check away so that it only fires if the number passes the check first: 

The first thing you should realize is that in Haskell, typeclasses are basically the same thing as Java's interfaces. They define a contract of behaviour which instances of the class must obey. In this case, the typeclass I'm calling promises the user three methods: 

Not that you need these grade messages, but that's an example of the power of holding on to the type rather than converting the grade directly into a . Sorry if I've made syntax errors as I've not used Java in a while. Edit: Just realised that you might like to put , and into the itself as static methods. 

What we're doing here is creating a new typeclass called Prop. We need the syntax because we need to define the behaviour of an instance of the class. If we don't introduce a symbol for it, then how will the compiler know what we're talking about the in the typeclass definition? For example, the line says that for every instance of typeclass , there must be a method called which maps to a boolean value. Likewise, there must be a similar method for . Now the line may cause some confusion because appears twice. It's important to understand that , being an instance of a typeclass, is a type. There are no "objects" as in object-oriented languages. Remember: is a type which satisfies the typeclass contract given by . The Java equivalent would be a class implementing an interface . What we're saying here is that for type which implements/is a part of this typeclass , there is a method called of comparing them. And its type is meaning that it takes in two expressions of type and returns a boolean indicating whether or not they're equivalent. 

fails, because the template expects its parameters in the unusual order "destination-type, operands" instead of the usual "operands, destination-type" (cf. , Concepts Lite syntax, function declaration syntax). I strongly recommend reversing the order of the operands. Plus, if you do that, you can collapse the versions into the other ones: . "Has an convertible to bool" is not quite the same notion semantically as "Has an "; but the difference only shows up in fully generic contexts. Another option (requiring even more metaprogramming, sadly) is to special-case as meaning "has of any type". (I say "requires more metaprogramming" because for some reason is usually false.) 

Here I would worry that the programmer didn't know that arrays in C and C++ are passed "by decay to pointer". I would prefer to write this as 

Nice to see you again! :) As with your deque from last time, I think your coding style is very good but the actual design is a bit questionable. (Less so than last time, though.) Consider: 

Could you add some more explanation of what kind of pattern/construct this is intended to replace? I played around with your Coliru code a little bit, and it seems like this is the thing you're replacing: