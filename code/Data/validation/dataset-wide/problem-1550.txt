note: in C++ it would be easy to make the computation of the array of the perfect squares at compile time. Maybe also in C it could be possible (using #defines) but not as easily. 

I don't like too much the names of these functions. I know that also python uses ugly names (words without any separator) but I think you could improve this... for example: or seem better to me. About the functionality. Managing dates is a quite difficult task. The python library in my opinion makes a great job in distinguishing and datetimes. Your wrapper module simplifies this by considering each datetime as a localtime (if I understand it correctly). I think it is not good to hide this decision in your code. Explicit is better, even if it could me more verbose. Also I think you missed the function, which could be used in your code. 

even if you have only a single option it would be good to write your code as if there were many. This could be simpler to understand and easier to extend. I would keep the options (in your case which you could transform in a boolean variable ) as global variables, and parse them in a dedicated function. Once you have extracted that code from the main function you will feel more eager to add other options (for example --help to print the usage message). You function is definitely too large. Extract the arg parsing code. Put the logic into a separate function and let main just be glueing code. Here you are reinventing the wheel: 

I would extract the code which draws a single star in its own function. Also I think it is important that such function will draw a star centered in the current position and leaves the turtle in the same position it has found it. Otherwise I think that the stars you are drawing are not centered exactly around the center of the screen... or at least it is not clear to me why they should. 

this is not a good starting point. Your implementation is very far from being comparable to any database program. What you are doing: 

which can be achieved if you define a dictionary of classes. The code could become even longer, but separates more clearly the logic of your Range class by the information about different Tokens. If these Tokens have other functionality using a class becomes even more convenient. The definition of token is clearly separated and does not interfere in the logic of the application. Also, adding a new token is a matter of defining a new class and registering it in the dictionary of tokens. Similar token could benefit in inheritance. For example: 

This answer has two parts. First part to show some suggestion to your code, keeping the same algorithm performance. Second one to suggest a \$O(n)\$ algorithm (where yours is \$O(n^2)\$). PART ONE The function can be written as: 

This check is non very useful. It does not decrease the algorithm complexity. In particular the check is wrong... you want the function to fail if the arr is not a list, otherwise you hide possible errors in the caller's code. 

: There is no reason to use dynamic allocation, and are constant expressions!. Just use or better . That said you usually want to have dynamic sizes or your matrix may be larger than the stack limit. Then you should use . C-style arrays and dynamic allocation should always be limited as much as possible. Using proper class objects wrapping them is much safer. will take care of all memory management for you. If you are concerned that will layout rows non-continuously, then use instead and properly access the elements by . Also, in C++, you do not use and . Instead you use and . The difference is that not only allocates memory but also constructs the object in that memory. In most cases you would need to manually construct the object in the allocated space (although for double it is technically ok here). You should not declare a method, but rather everything freeing memory belongs in the destructor, which is automatically called as soon as the object itself goes out of scope or is destroyed: 

and should be . You need to to use . You are defaulting the copy constructor and assignment operator, but not the move constructor and move assigment operator. That's fine because the defaults are generated anyway, but it is inconsistent, I think. What is the point of ? should be . You don't want to have users create s. does not actually own the pointer it holds. It is copyable and will just copy the pointer it holds. It also does not create anything or delete anything in the constructor/destructor. Nontheless you provide a member. That seems very wrong to me. You don't know how the memory you point to was aquired, it could be with static storage or an array. In both cases calling would cause undefined behavior. The object creating the pointer with should also be responsible for ing it. Calling on two copies of also causes undefined behavior. The fact that the pointer is not owned seems to be a major flaw here anyway. Currently the user of your class needs to gurantee that the object pointed to keeps in scope until all 's holding it are destroyed and then it has to take care of proper deletion. Using it outside of is not allowed. So why not move the responsibility of managing the pointer to ? The same holds true for the lock. Currently the user needs to provide a suitable lock and keep it live until no references it anymore. Why not create the lock/mutex inside the constructor from pointer? Though I realize if you do it like this you need to manage references to the lock and you end up with fully reimplementing . Therefore I will just assume that this wrapper is explicitly only about locking and not managing ressource lifetime and that the user is required to run the destructors properly. is fine if copy elision is performed (not required in C++11, but in C++17), but is not either way. The object you create in is destroyed before the function returns. That means that is called before the caller expression using the pointer ends. currently returns a copy. It should return a reference. At least that is the usual way this operator is interpreted. In general the approach with and has some limitations. You may not call either twice in one expression or you have deadlock. But you are also not allowed to save the pointer returned by or a pointer/reference to the object referred because these are not guarded any more by the lock. I guess it would be much better to let the caller call a which returns a . Access to the holding pointer is then only allowed via and of this . As soon as goes out of scope its destructor releases the lock, similar to . This still allows the user to misuse a saved reference/pointer to the raw object, but at least more than one usage can me made in the same lock aquisition. An implementation via C++11 standard library would be similar to this (not tested): 

You should notice that square numbers between 1 and 1000000000 are "only" 100000 and among them you can imagine that very very few can possibly have all perfect digits since the condition on every single digits are probably independent and hence you expect 1 every 2^10 perfect squares with perfect digits. So you could compute them all at once and, possibly, put them in your code (you find they are only 121 numbers). Finally you can find how many of them are in a given interval with a simple linear search. On my laptop, with the worst case input, your code runs in 2.871s while the following one runs in 0.017s. 

Here the complexity is too much... we have four variables plus the three of the enclosing function: very difficult to keep track of all of them. is repeated. should be the return value. 

The execution is much faster, even if the input is only 1000 names (1sec vs 1min). And gives 5910 as a result (vs 995). 

(added: the difficulty to achieve a DRY result is an indication that the variable could better be an integer in which can be used as an index in the "OX" string.) Two. This: 

It is more clear and less error prone to first make the search in the table and then fallback if you don't find the character. I would use an empty for the search, this might be controversial: 

I understand you are asking for a function to check if a point is on a line. The question itself is ill-posed: because the representation of points and lines on a computer is only approximate and if you approximate a point on a line you probably get a point which is no longer on the line. A typical example is to check if the number satisfies the equation . Even if we expect to find a solution to this equation (because we use the real numbers as mental representation) there is no floating point number which solves such equation. Hence it is almost always wrong to check for equality of two floating point numbers. In this cases what you are looking for is an appropriate approximation. So instead of looking for one is happy enough to solve . The small value is somewhat arbitrary, and can depend on the problem you want to solve. So my suggestion is to implement a function which computes the distance from point to line $URL$ and use it to check if the distance is small enough. There are many other factual problems with your code. Here: 

Just a funny note: I asked my students to write their own implementation of Player... but I was disappointed to see that most of them were beaten by my Random player! 

is a thing I would avoid. Since the program is so clean and self contained, I would keep it as abstract as possible. Maybe in 5 years there will be an OS which could run python happily but which does not have a 'clear' command... what a pity if your program will break for such a triviality! And if you insist in using a system call, wrap it in a function, don't write it twice!