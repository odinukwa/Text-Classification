lock the put/tack Lock atomic get on the count atomic update the count unlock the lock lock the other lock signal the other lock unlock the other lock. 

they can be compiled, which makes them fast, and reusable they can replace what's between characters, not just the characters themselves. 

Your Monster class should have very few, even no static fields. All static fields, if any, should be constants only ( ). What you want to do is separate the definition of a monster from it's implementation. Also, the implementation of the monster should be based on a template that sets it's characteristics. The Definition can be that template too. So, consider a class that is something like: 

When presented with problems like this it is common to decode/encode the input characters once, and store the decoded output in a structure that helps you on the presentation layer. First, though your control loops and input management... User Interaction I recommend you create a single class to encapsulate the Scanner instance that should only be created once, but which you create each time you need to get user input. A instance that allows you to query the user actions would be so much better. Consider: 

Update: I assume, based on the variable syntax, and so on, that this SQL is not a direct query, but is rather the input to some string substitution that expands the variables. This is potentially vulnerable to SQL Injection attacks. Are you sure you shoud be running your SQL this way? Have you considered prepared statements? Is this a prepared statement? 

That is an amazing amount of work to do in 600 instruction cycles.I would expect the various object creates (three BigIntegers, two arrays, and a Buffer) are the most expensive things to do as they require multiple instructions, allocations/reservations, and registrations in the object creation, including CPU/cache management, etc. Frankly, what you have is pretty good. You could reduce the amount of work you are doing by completely removing the ByteBuffer from the last section. This code: 

By taking the address of the var and giving it to flag, we can then use the variables as-is later without having to keep the pointer handling at all, so code like: 

In general, I would suggest that you are approaching this problem with the wrong object model. Your model is: 

Edge Cases Orders larger than 10 will effectively truncate to , which makes Integer.MAX_VALUE an interesting input..... An order of 10 and an input of Integer.MAX_VALUE, would normally imply an output of , but you respond with Name The term "clamp" is often used when confronted with this.... where a value is clamped to be within a range, or limit. I would use that as the function name. Solution I would recommend transfroming your internal logic to use long, and be done with it... ;-) 

Using two stacks to implement a queue is not a logical data structure as far as I am concerned. There are many better ways. 

With that CTE, the only answers returned are ones that are valid for the input conditions on who to report for. Note that it only selects the two columns needed for the remainder of the query. Selection Your column selection returns the Comment text twice, once as a link, and again for the text. In some conditions this is useful (like getting the data as a CSV report) but I don't believe this is the intention here. Additionally, you do not report the actual User who created the answer either. I would find that useful. SEDE allows you to return the Id for the user, but display the name (as a link). Your regular join to the Users table is not necessary for that. So, with the previous Answers CTE, I would have the much simpler final selection as: 

Pairing combinations like this is a very common thing to do in any language. There's a very 'idiomatic' way to do this type of operation: 

I would initially agree that the complexity of your solution is O(n), though, there are extreme cases where the performance of your could be greater - is 'average case constant time, worst case linear', I don't believe a worst-case situation would happen for you. Note that you have a very complicated equality-check comparing your two frequency-maps.... you have: 

To put things in perspective, on a 64-core computer (128 hardware threads), a program that was able to run at 80% CPU (i.e. 100 hardward-threads running at 100%) was reduced to about 3% CPU when about 1000 traces were taken each second. This sort of performance is highly dependant on the JVM version, and the vendor. Stack traces are considered to be part of exception handling, and building the trace is not supposed to be fast. Questions about Trace versions (FYI, this may, or may not help you): 

The above code will be far more efficient than the substring option as well. It is also 'fail-fast', and exits on the first non-palindrome characters. 

Using a should always be your preferred choice when doing String manipulation. It does not always make sense, but almost always. Additionally, indexOf takes a 'from' location, and it makes the whole thing easier.... Convert both inputs to lower-case, then do the matching using the lower-case versions, but the substrings using the unknown-case. The complicated assign-in-where-condition logic makes the loop conditions easier, but you do need to understand what this does: 

This is much simpler code to read, and understand, than the previous version. The singleton can probably be improved slightly by removing the Config calls from the declaration, and putting them in the constructor. Similarly, calling the would be useful in the INSTANCE constructor too. The semaphore and channels should also be final.... A system like: 

In the past (before the case statement was available) I used to do calculations like the above, but depending on the circumstances, it can be less readable than the case. In this instance, I think the case is still better. 

Then, if you want to, you can add them to a structure like a TreeMap, that will sort them for you. Something like: 

Initialization Your should be a private-final instance field. Right now it is not final. Same with the port. The problem is that you have added an method instead od your constructor. Put your initialization in the constructor where it belongs, and it reduces a number of other problems. Static Hosts You maintain a static list of hosts. This is modified without any regard for concurrent access. If you have multiple ProxyServer instances then they will overwrite each other's host list. Since you have only one proxy server, you should just make the host list an instance (rather than a static) field. Threading As was mentioned in the comments, the connection you accept is processed in the same thread as the server. As a result, you cannot be listening for new connections while also processing a proxy. Additionally, your is fishy: 

Follow the same pattern for the other bits... This is a relatively concise way to do things, actually, and you only need to keep one 'dimension' (the length of each data value) of the problem in your head, and you can ignore the offset. This leads to fewer bugs, and better understanding and readability. I cannot find a definitive reference whether PHP supports a definitive assignment operator. If it does, the lines can be replaced with 

This optimization optimistically expects there to be a relatively small set of unique colours... but, even with worst case large colour bit-depths, and ranges, the dict will be not much larger than the values that are similar to the margin test anyway. 

looks at the monitor location for the code block. checks to see if any other thread has the monitor locked. waits until the monitor is unlocked gets a 'clean' copy of all the variables used inside the code block from a "good source". runs the code inside the block updates the "good source" with the new values for any variables changed inside the code block. unlocks the monitor 

Note how you can use the blocking nature of the actions queue to handle most of the logic in your code. 

The above code is cumbersome. When you have a return statement inside an if-condition, there is no reason to have an 'else' condition. Additionally, when you are using early-returns anyway, there's no reason to have such nested code blocks.... Alternatives I can see multiple options to this problem. I would recommend testing them to see which performs better for you. The Regex option may in fact be faster if the pattern is reused often. On the fly In your own answer, you suggest on-the-fly building of the string, and ending early. This is a good option, but I would do it differently: 

The algorithm you have chose in is fine, and both other answer recommend using streams, but I disagree (hence my answer). So, your user-inputs are not validated, and your code can throw more than just , but also and so on if the file name arguments are not given on the commandline. You8 need to validate these and throw appropriate exceptions. Further, you just print stack traces for , but the program exists with code 0 - a success condition. If you're just going to print the stack trace it makes more sense to declare that the exception is thrown from the main method (and that will automagically print the trace and return with a non-zero code). Other answers have pointed to the method, but I think you should consider the instead. Note that and methods will both trim the whitespace at the end-of-line. This may be a problem. Regardless, Files is a good class to know about. Consider this code: 

The above code can be used for both the input files, and only writes out the word if the word has not been seen before. This way you have only one set, and you do the merge at the same time as the reading. Also, you should be using Java 8 streams..... hmmm... that would be nice. 

If your comment about the not being a cycle means that if a node points back to where it came from , it's not a cycle, then I recommend passing in the 'source' when you walk the graph... for example: 

I recommend you make the changes and see how it works out for you. You will find that the logic and flow of the structure is neater, and more manageable. 

Other problems related to code-conventions (like the upper-case B in , and D in are not as significant). Case statements in Java are 'fall-through', and you need to break unless you want the following statements to execute as well. Timer In Java, the right solution for any timing problem, is to use the library timer functions. In recent Java versions, the right tool is the . This service allows you to schedule tasks in the future. I would build it something like: 

A useful first step for you to take is to separate out 1 item of functionality in to a class. Your method should be broken up in to several classes, but you will get the idea with just one. This one class, call it for want of a better name, will be used like this: 

If I have one complaint about your 'style', it is that your comments are too verbose... As for your question about the hashCode of Collection-like data members.... I have inspected the source code for both ObjectNode and ArrayNode. In each case they implement reasonable hashes given some constraints. You need to answer three questions: 

Additionally, if you are concerned about the actual performance of the , (and if you actually read the full Javadoc of the FastDateFormat class you sent me... ;-) you can replace that one method: 

Going through this code again, it appears there are a few things that could be improved. Use #Temp Table for User Selection Instead of doing a cheap-shot UNION select to get the set of users to process, the right way would be to create a temp table, and then conditionally populate it: 

When scanning the data, you can calculate the 'direction' of a point, and then reuse that direction for the next test as well. Java has a 'compareTo(...)' concept which returns a positive value if the first comared value is larger than the second. It returns a negative value if the first value is less than the second. It returns 0 if they are the same. For integer values, this is easy to do with: . Using that, we can simply do: 

Naming methods in Java are a signal to programmers that you are returning a property on the instance. You get a Name, a value, a property. In your case, though, you are computing something based on an input value. A name like: 

OK, so we have two helper functions here. How can they be used? Part of the logic in the NQueens problem, is to take one partial solution (not all the rows), and for the next row, identify which positions are safe. For all the safe solutions, 'yield' them as a new collection of partial solutions. In your code you have this in the qu function: 

there's no generic type for the Multiton. This is expected. All it needs is the public method, and the generics for that method are determined by the call arguments.... which is point 2.... the generic type of the values are declared on the Creator (which is also the key). In other words, each key knows what the type of the value should be. This means that the generic type is 'recorded' at create time, rather than retrieve time. There's no need to pass a class in to the call since the class is actually part of the . I created 2 'helper' classes that are Creator instances. These classes and are simpler ways to actually create anonymous, or Java-8 based Creators. 

From the way you describe the problem, it is clear that there only needs to be one method. That method is supposed to: "... prompts the customer for the car type. ... Your method will return a valid car type". What you have presented here, is the guts of some code which prompts the user for a character value, and then another method which converts the to a type. From what I can tell (and filling in some blanks) your code looks functional, but I am not certain it satisfies the requirements (for just one method). I would start with the 'specification' for the method, and use that as a template for the code. I will make the assumption (as you have) that the method should return the 'full' name of the car type (i.e. return "Economy" instead of 'E'). The good things in your code are the use of the block. You have a good loop there, with good conditional exit criteria. You have not shown us what is so I will assume it is a on . If we wrap the code you have there with a method that makes sense, it would be something like: