I am concerned with that fact that your model (which should represent a single instance of a given object in database) would have the ability to switch insert id's. Is the class a provider/factory or a model? 

Was your interviewer perhaps botherer by the fact that you did not handle type conversion? When mapping those values to an object, you make and implicit cast of the numeric value to a string, so if you are later asked to output the original values with tally for each, you might have needed to convert back to numeric. 

To your question about how to call model dynamically while avoiding having to set , you could use something like: 

I very much question the optional "nullable" thing here. First of all, name-wise this doesn't seem to make sense as typically when you think of something as "nullable" it means it is a variable, property, field, etc. that is allowed to be set to null. You are not setting anything here, so the terminology seems weird. Perhaps it should be called or something that more directly ties it to the return behavior of the method. I would however get rid of it, as it will become a source of fragility to calling code, as in some cases (including default case) your calling code would not be able to distinguish a false "hit" result from a false "miss" result. Let the calling code deal with converting to if it needs to send up the call stack. Don't obfuscate the result right here in this class which is designed to own this determination. 

Here I have shown a theoretical class/object where you could encapsulate your logic related to: current localization being requested, localization to be served, outputting localization info to browser, etc. 

For something as important as a remote server connection, I would want to make sure that you have covered the appropriate magic methods such as and to make sure you have enforced behaviors to close connections when the object is de-referenced, prevent attempted object cloning, etc. 

Consider moving your javascript classes/functions into separate files than the javascript that actually performs logic on the page to bind game play to DOM elements. 

In your one public method, you do nothing to validate that the parameters passed are reasonable for use with this function. You should validate and fail out (ideally with some sort of exception) if proper dependencies are not provided. You should definitely not be setting up dependencies in your private methods as you are often doing (reading user input, instantiating related objects, etc.) Your public methods are your contract with the caller. Your caller needs to give you all the dependencies you need. You need to validate those dependencies within the public methods such that the private methods that might be called from there know with 100% certainty that their dependencies are set up exactly the way they need to be. Otherwise, you get into having to have validation code sprinkled all across your class methods. 

I honestly don't see what value you are getting from this class. It looks like you are trying to build an object relational mapper and a database connection management class without really doing either successfully. I don't understand the desire to make this overarching class that can perform all database insert and update actions. You are making your code much more complex and obfuscated by trying to have one class that can interact with different records representing different objects (i.e. database tables) in your systems. For example, what if you changed the schema on one of your tables to or remove a column. Rather than making a similar change in a single class associated with that table, you now have to search all around your codebase looking for all places where this more general class is used in order to determine if that particular usage is impacted by the table change. This is very much a concern for application maintenance. You also have a very simply use case here. What happens when you need to do things like insert timestamps on your table records (a very common operation) and deal with more field types than the ones you have considered here? You well continue to have to branch you code to handle more and more edge cases, adding complexity. There is absolutely nothing wrong with having specific database model implementations for each table/object type in your application. This makes it much clearer to the developer as to what the expected fields and behaviors are for each individual object, as opposed to them having to go review a database schema to understand what fields are available. I would suggest an alternate approach to the object relational mapping functionality you are trying to achieve. You might start with an abstract DBModel class that can be inherited by individual classes specific to each table. This abstract class can require that each inheriting class implement their own logic for CRUD operations. Perhaps that abstract class looks something like this. 

The design seems questionable with regard to the static interface. This function seems very odd in that what you are doing is trying to, in essence, create state on this static interface. If this is the case, should this really be a static implementation or should you be working with concrete instances? I think you don't have a clear differentiation between what behaviors might exist in a class that operates against a collection of user records in a database (i.e. like a factory/provider), versus what might need to exist in a concrete class instantiated from a DB record. This shows up in your code by the fact that many of your methods to get user information from a database based on a user id. Why should you have to keep doing this over and over again over what may be the course of several calls to determine if a user exists and/or comparing password. Perhaps password comparison and password changing methods should live on a concrete class, where you already have property of user available. For simple read use cases, you should not have to query the DB more than once for the user id in question throughout code execution. 

Since this is such a simple aggregation use case, I would consider aggregating this information in MongoDB rather than in PHP. As far as code review comments go, I would state that for a simple section of code, it is kind of a mess stylistically. You have: 

UPDATE To answer your question about how to get rid of your anti-pattern around id properties. Consider an element that looks like this: 

You might be able to optimize for performance and/or memory utilization by implementing loops and counters, but you must decide if it is worth it. 

That's it. The router is basically used on a single line in your main execution path. Here all the information about the HTTP request (including URI) could be injected into a controller object, which then takes over application control. In this case, the router needs to know absolutely nothing about what dependencies that controller has. It typically just needs to know how to map the request (oftentimes just the first segment of the URI) to a controller to be instantiated and hand off the request information and application control over to the controller. In your case, your router actually does the following: 

Why does answer class use ID values as primary key while question class uses title? You mingle , and just as nomenclature in the question class which seems extremely confusing. These sorts of inconsistencies probably make it harder for you to see the fact that these classes should probably inherit from a common ancestor with properties like: 

As noted in comments, you should begin to work with prepared statements when querying the database. I would also suggest using mysqli in an object-oriented fashion. 

When you take out the comments from the suggested coding approach I noted above, you can see that the calling code (index.php page) would now need to know very little about the underlying mechanisms for managing the user login, the database, etc. and now only contains a handful of lines of code to get your user information set up in a state that is meaningful for the page. Login/registration 

Bad function name. There is no sorting happening. Here you are actually applying the previously determined sort to the layers. Perhaps or similar would be better name. Why do you need to pass any parameters to this method at all? You already have necessary data available to this function scope. If using a key-value store for your layer objects, this function might look like: 

Other points of feedback: You do little to validate that the parameters being passed to your public methods are acceptable to work with. You should strongly consider beginning to apply type hints into the method signatures such that exceptions are thrown when unexpected values are passed. For cases where type-hinting can't help you (like when passing string or integer values), then some basic validation should be the very first thing that you do inside the method (i.e. non-zero length string required, positive integer value required, boolean value required, etc.). Fail fast with an InvalidArgumentException or similar when these criteria are not met. Also, consider asking the caller to be more specific in passing certain parameters. For example, on your method, you allow a variety of input types. Do you really need this flexibility (and the added code complexity)? If the code can operate against anything implementing , why not just put that in type hint? Why check for both and when implements this interface? Do you REALLY need to accept arbitrary input and the edge cases it might expose in your code? Like right now, what happens if I pass a value of to this method? It falls through your conditional and gets set on the property, because it and is not DateTimeInterface object. You probably don't want to have to write 15-20 lines of guarding code for this simple setter operation. Similarly, with methods like (bad camel case here), you should enforce a boolean parameter as being passed rather than casting the parameter as boolean and potentially introducing unexpected "truthy"/"falsey" behavior. Right now, I could pass an object to this method and have that evaluate as truthy, making this cookie HTTP only, even though the caller's method usage was incorrect and should have caused an exception in your system. Be very specific when you set up the interactions between your classes and class callers. The looser you permit these interactions to be, the more problems you will have with bugs in your code and being able to quickly debug that code. 

Where might have some branching or variable injection via PHP, but that is it (ideally you eventualyl get comfortable with working with templating systems that allow you to fully separate the logic from the view). 

You should verify password before activation status. You don't want to leak account verification status data to a user making request with bad password. 

First off, Wordpress is an awful platform when it comes to separation of business logic from display logic. If you expect to continue working in it, you can expect to continue to feel the pain that you are feeling. The thing that concerns me the most about your comments, is that you say you cut/paste this code repeatedly. That immediately screamw out for putting this code into a widget or function so that it is reusable. Think if you had a function like: 

From looking at the rules in your class, I actually question if there is really much value here, as really the only validation rule you have here that could not be better fulfilled by built-in PHP validation functionality is you validation. You could just as easily use or here. For example: 

This code seems off to me. Perhaps controller needs to keep a map of equality callbacks for the various properties that may be used with this filtering function. I don't think these should be hard-coded in the filter. 

Some good commentary from @Iwresteldabearonce so I won't get into any of those points. I think you are missing some higher-level concerns: 

I guess I don't really see what value you are getting from these functions. Isn't the following in essence the same thing without ~100 extra lines of code that don't really do much other than provide some error handling. 

That gives you the ability to easily iterate over this object to create transformation strings. An example of this iteration might be: 

I am just generally worried about your thinking of including this within other files "as needed". That tends to make me think that you don't have a good strategy around managing your application dependencies (such as database connection). Just sprinkling includes/requires throughout your code can really make your code fragile and hard to maintain. If you really want to take you application coding to another level, I would suggest familiarizing yourself with dependency injection, both in a philosophical sense as well as from a practical standpoint looking at typical PHP libraries that do this (Pimple, PHP-DI, or pretty much any popular framework has some level of dependency injection strategy). Hopefully your ini file is separate from your codebase (i.e. not under revision control) to where you are storing your DB passwords in your code. If that is the case, consider taking the next step and have the ini file parsed in a different process such that this particular code is not responsible for reading configuration data from files that should perhaps should just be available in environmental variables. 

What values does nesting everything under key add anyway? You are just adding an unnecessary level of nesting to the response data structure. The caller already knows they are getting a response :) 

I also don't understand the conditionals around the debug logging. I would think you would just always do the logging and just have it properly logged using or Conditionally logging in your code just means you are now adding your own log level concept outside the framework of the logger. 

Consider changing method name to and to as I think you would find these more typical method names for setting and unsetting items in a store or cache.