Yes. The other answers do have very good points, but I don't want to repeat them. I only could add that renaming your variable to would match the task description better. 

No. You have coded it so that , , , and are global variables (or properties). If you would have used strict mode, this had thrown exceptions. You would avoid this by not using the keyword in anything but constructor functions and instance method, and use statements everywhere. 

Instead of filling that array, you could have mutated the original one (for a tiny bit of better performance). But creating a new array is fine. However, when creating a new array with one item per item from the original array, the method helps a lot to remove the boilerplate loop, array instantiation and pushing. 

Disclaimer: I've only commented on the code layout, I haven't actually read what the functions are doing 

Binary trees are a wide field :-) First, I'm missing some other basic operations like searching, traversing, and deleting. If you have mastered these, you can go on with optimizing your tree, e.g. making it a balanced one. 

A node stores its data in a member of type . Should I replace with and use that as a generic pointer to data? What do you think? There's a comment on -correctness in the header file, literally: 

Is it OK to use as a template parameter? That makes it more generic, but the error messages are way more complicated and point to stuff deep down in the implementation. (Granted, you can't say my implementation is anywhere close to "deep," but this is more of a general question.) Passing a , where is some alias for a type, would also be possible but not as generic. also uses the template parameter, though, so I do so as well. Is my use of iterators alright? I tried to keep the interface clean with iterators for interaction with standard containers, but the implementation also uses numerical indices when it's more convenient. is ugly: there's an infinite loop with a condition and it basically finds the largest element out of three while checking that they are within range (i.e., ). I have a feeling this can be beautified both syntactically and semantically. Some hint on that would be appreciated. The implementation is supposed to work with bidirectional iterators. doesn't work because subscripting is not supported, it's not efficient for , etc. Should I replace subscripting with to make it work on at the cost of performance guarantees? would work, but it might be frickin' slow asymptotically. 

then everything would have been fine. Notice that, as @Flambino mentioned already in the comments, you can shorten the part where you install the event listener to 

Since you specifically asked about doing it with less code: use less variables. If you only use a variable exactly once, the expression might as well be inlined: 

You already have declared them, they are hoisted and everything is fine. However, even if you did use function expressions: 

Which of these is clearer would depend on the readers familiarity with functional programming and the underscore library. 

That's not really necessary. You can used indexed access, a property and the same iteration on the string itself. 

Don't do that trickery with the accumulator that might be an object, just always have an accumulator value. And don't treat the first invocation as a special case: 

We don't care. There's not much going on here, there are not thousands of elements in the DOM, and there are no tight data processing loops. If the UI feels sluggish, something must have been gone horribly wrong. However, there is one inefficiency in your code that matters: The JSON file is fetched on really every single click. I'm pretty sure this is not desired. It would be OK if you expect it to change really often (that is, < 15min); or if the response would be dynamically created and you did transmit the currently selected option as a parameter. 

I've started Python some days ago and wrote a small Telnet implementation according to RFC 854 and RFC 5198. It is pretty low-level and sending messages directly isn't even supported. The highest abstractions are commands and user data where commands include negotiation (like "Do") and "general-purpose" commands (like "Go Ahead"). The best thing about it is that, using the method, these data can be converted to their binary representation and directly embedded into a data stream using TCP or just storing it temporarily, making it very flexible. Code (): 

I've written a small implementation for doubly linked lists. While actually intended to be only used by me in subsequent projects, I wrote it as generically as possible. Maybe this'll be advantageous. I tested the implementation and resolved as many bugs as possible but maybe there are more lurking somewhere in the code. Also, the implementation is supposed to be usable for different lists at the same time but operations cannot be performed on one list simultaneously. I'll have to add a spinlock to the list and alter the code a bit for that. The list works as follows: the first () node has the field set to , the last () node has the field set to . A field counts the number of nodes in the list. If , and of this lonely node contain and . If , and are indeterminate. Code Header ():