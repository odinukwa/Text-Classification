We execute the function twice for each value and time only the second call â€” this is a non-rigorous attempt to prime caches and such to get a more accurate measurement. Some results for your original code are: 

First, we can see that the third numbers, the function results, are identical to those for the original code. This means that either the new code is also correct, or both versions are incorrect. As you can see the execution times are greatly reduced from the original code for all values of greater than 4. For the smaller values, the original code is faster because it doesn't have any caching overhead. But for the larger values, each increment in results in only a small increase in execution time. For of 12, the run time is only 2.68ms, which is roughly 28000 times faster than the original code. With the revised code, calculating takes only 2.8 seconds: 

As a rule of thumb, when you use a jQuery selection more than once, you should cache its value. When you do , jQuery now has to go find that element in the DOM, wrap it in the jQuery object and return it. If you save what it returns, then you only do the search once - not every time you use it. The hard part is caching . This is relative to where you are in the code, function, callback, etc. and changes to provide context. For example: 

- Variable Names: If you want anyone else to provide you input on your code, they have to be able to understand it. You should use variable names that will make sense to anyone reading your code. Yes, in this simple example one can deduce the what and why you named the variables the way you did and we can sort of follow along. But when you start working on large scale projects, things can get out of hand real quick. Take for example your variable. The keyword can refer to any element that goes through the which might not be a in the first place. What if it was a or any other element. In that case, the name would no longer represent what is actually stored in there. Anyways, try to use meaningful and descriptive variable names and stay away from names that might not exactly represent what is stored in said variable. - Cache your selectors: As a rule of thumb, if you use a selection more than once, you should cache it. What happens when you use is jQuery has to jump into the DOM and look through all elements that would match that selection. So you should really do a search only once, and save your results for future use. This way you can look and play with them whenever you want without having to try and find them again. Ex: 

On my machine, this overhead is ~1.20s. The original solution for input with 9000 entries and 3 lookups takes ~6.25s, while the solution I've posted here runs in ~1.23s, which means it imposes hardly any overhead over that of the VM startup and shutdown. 

The first value is , the second value the execution time in microseconds, and the third value the result of the function for that value. For values greater than 2, there is roughly a 6x increase in run time at each step. For of 12, the execution time is just over 75 seconds. Here are the results for the revised code: 

I created an input file containing 9000 entries to be stored and used it to measure this solution to be about 150 times faster than solutions that read the input line by line, as measured by running the solution on the command line in a bash shell like this: 

When you have code that repeats itself like that, you want to try and separate the logic from the values. Something like this would work, and you just have to add more to the settings object when needed. It's not jQuery that's badly written, you just have to change the way you're using it. $URL$ 

This code handles a response from an RSS feed. It organizes and appends to content. If there's a video embeded then separate it from the rest of the content. I would like a review mainly on performance/efficiency but I'm open to any other suggestions as well. That star selector is really nagging me but I don't know of a better way to iterate over all the contained elements. 

This is a lot of code to review so it might be a good idea to break it down into separate parts. This way it'll be easier to give a more detailed and tailored review. But anyways here are a few things you can do that should help your performance: Minimize Paints and Reflows - Might seem like an obvious one but it's one of the most important. Especially in your function which from what I can tell does most of the animation grunt work. An easy way to optimize this is if you need to read data from the page, read it all at once, then repaint/edit layout. Save yourself some code - There are a few spot where you can bring down the size by joining operations. Something like this: 

The code below first reads all the input in chunks of 4096 characters, accumulating a list of chunks. It then reverses the list, flattens the list into a large string, and splits the entire string on newlines. After that, it converts the first element of the resulting list to an integer , and then processes names and numbers from the remainder of the list by storing them in a map. The value stored isn't just the phone number, but the required output string . Once all the entries have been processed, the rest of the input is queries, which are then processed one-by-one against the map. Query processing uses with the string used as the default for lookups that fail. This allows the return value from to be unconditionally output directly to stdout. 

Caching is definitely appropriate here as well. You can carry a cache through the calculations using an Erlang map. I took your original code and made the following modifications: 

OK so use an article when you have stuff that goes with your site but is independent from the rest of the page. If you use an article element within another element, that article element's content should be related to the parent element's content/stuff. From what I can tell your it for styling and positioning, so it should remain a . You got that sidebar element well, and the content inside is should be in the element itself, or if you have content that is groupable and related, then a element inside that would be appropriate as well. 

That just makes the syntax so easy to remember as well as provide you with enormous control over your events. If you're going to use jQuery on a regular basis, I recommend that you take some time and read through the source code of the methods you're using. To find them quickly just use and type . That should jump you straight to what you want to know. This way you can understand what and how they are doing things, and even find better ways to do them on your own. Also if you see something you think should be done better or differently, you understand how it works and you can contribute to jQuery. 

First of all, you are using some kind of C# code style in your typescript. I suggest the command-line to conform with typescript/angular code style. Moreover prefixing interfaces with is not a typescript convention ($URL$ I think the difficult part of your code with rxjs is how to know which room we have to update when we receive a status. I find a way to keep track of the room without changing the api of the via zipping the observables returned by the with an observable containing the room. Here is a proposal with rxjs, I tried to fill the blanks in your posted code to make it run so focus on the function and the method: the component with the dropdown: 

As you can see, it's quite different from the promised code, but you will see with practice that observables are more powerful than promises. You can easily limit the number of calls to the tracking service: 

It's all probably a lot more complicated than this and articles like this probably explain it all a lot better. As you progress in plugin development you should start to think about implementing design patterns. There are almost endless options of patterns you can use and some you can event make sort of a hybrid pattern. Don't feel overwhelmed with all the options pick out a couple to start with and try them out. I'd suggest the Module Pattern (another good article) since you've already sort of implemented it in this plugin. Also look at the Observer Pattern (aka Pub/Sub) it's great for dealing with custom events. This video by Jeffery Way does a great job of explaining the concept. I'd recommend you'd watch the rest of the episodes from that series as well because he does cover some good ground on plugins. 

I wouldn't rely on $.noConflict - Chaining: As pointed out in your question, you should be using something like that. jQuery is particularly good at this and you should make the most of it. Ex.: 

The final clause is where all the interesting work occurs. It first calls with a default value of to check if the value tuple is present. If it's not, the default value of is returned, and the case clause for creates a new list of value tuples based on the incoming values of , , , and and passes it to a new call, setting the initial sum value to 0 and passing the current cache. This call returns a 2-tuple comprising the sum for that value tuple and a new cache. The final line in this case clause inserts the sum for the value tuple into the cache. The case clause for when finds the value tuple just returns the cached sum and the current cache. The result of the case expression is stored into , and then is called recursively with , which is the tail of the value tuple list, a new sum which is , and the new cache . We can run the code in a list comprehension to calculate the running times for values from 1 to 12 using like this: 

I'm currently learning JAVA in a class and we're using the ACM Graphics package. I wanted some pointers on my code. To provide some context here is the assignment: 

The way you have your function set up, you're appending and changing the DOM each time that loop goes around, and it goes around for every image. That's not good because DOM manipulations are quite expensive performance wise. So if you have 100 images, you're append one at a time - 100 times. The better way to do that would be do all your stuff and save to a variable, string, or object, then append once outside the loop. Here's an example of what I mean: 

It was fun going over your code. I haven't played with 1.4 for a while. Well here are some suggestions: 

Depending on when you want to make the ajax request, you'll need to modify the first line of my example. Currently it just gets all of them. You might want to change it so that it gets only the div that was clicked, or whatever. Anyways here's one way you could do that: