Only your viewmodel should implement . That's kind of the whole point of mvvm. Normally, your viewmodel properties wrap your model properties. Also, it is your model, that should contain all the business logic. Viewmodel should know nothing about or any other details of implementation. Viewmodel should only manage interactions with UI. Being said, you should have something like: 

It also feels like you are overusing keyword. Why is static? Why are timers static? Why is list of processes static? Can they be made non-static, without modifying the rest of the code? If they can, then you should do so, it will greatly increase reusability and testability of your code. If they can't - then this is clearly a design issue. You should not rely on some global state in your code. The rule of a thumb is: 

Check synchronously first. If it already exist then you can return early, and there is no reason to await anything. (Note eurotrash's point about thread safety). If value is never set, never returns. Instead of waiting for separately, you should check the timeout inside 's body and return once timeout is exceeded. 

Do not hard-code settings. Store IP, port, buffer size, etc. in configuration file and load those settings from it. (Not that important for sandbox projects) You should not reopen every time you send a message. Instead your class should open stream once and only close it when the client is closed/disposed. should re-use existing connection. Always sending bytes is clearly not the best approach. It bloats the traffic if message is smaller and cuts the message if it is larger. A simple solution is to prepend size to the messages you send. Use when variable type is obvious. Consider using methods (e.g. instead of ) to improve responsiveness of your apps. 

UserScripts should follow the format, so that TamperMonkey, GreaseMonkey, GoogleChrome and the other installers can pick up on the fact that it's a UserScript, the GitHub file does not. 

When you declare and , you also declare as an empty variable. Don't do that. The loop can declare it you. 

: Your usage of the variable is a little bit inconsistent: Some places you use it, and some places you don't. 

As shown in the example above, you should put whitespace between your operators, for the purpose of improving readability. Also, during mass assignment like in the example above, you should space out all the operators & variables, so that they're vertically aligned. Whoops, this isn't entirely correct, PEP8, the official style guide for Python says you should have whitespace before and after Binary operators, but not keyword arguments. See here for more information. 

Feel free to take the user input as a string/letter instead of an integer, makes everything much clearer. On a related note, an exit function would be nice too. 

Note: This code DOES not map multiple, I am not asking how you can map multiple, I am asking for suggestions on my working code. 

Your comment openers/closers (, ) should always be on a different line than the comment content. Also, misspell. 

It would be nice to also have a method that would call internally. It will make probably the most common use case more accessible. 

Then you should probably cancel incomplete processing when input changes. If you are going to discard the result anyway, then there is no reason to wait for completion. 3s is a lot of time. I don't have a clear understanding on how recursion works with . It can behave differently. Maybe you should take extra precautions to make sure that stack can not overflow. I'm not a fan of prefixes. But that's a personal preference. name is a bit confusing. I think something like would do a better job at explaining what this flag is for. Also postfix is unnecessary, prefix already hints, that it is a field. 

I'm not a fan of lazy initialization, but it is fine, if you use it to instantiate one or two actual services. Laziness is justified in scenarios when there are high chances that method will not be called at all by your software. 

I think you can just inherit from if all you do is wrap methods and override . Recursive methods are hard enough to understand and debug in their own right. When you add enumerator which you move manually to the mix, it becomes even harder. I think you should come up with non-recursive solution. Here is a solution I came up with (which might not cover some edge cases): 

Considering those changes along with a few more in the code, your code would look like the following: 

As of ECMAScript 5, the default radix used in is supposed to be \$10\$, before that, \$0\$ would get parsed as a octal number instead of a decimal number, and, as it seems, you can just omit that optional argument entirely. Although, as @EthanBierlein pointed out in the comments; MDN recommends not to omit it. 

I can't really comment on your structure in Razor, as I am unfamiliar with that framework, however, your replacing structure could be improved. By using a function, alongside a dictionary, you can simplify this greatly. 

A is specifically for un-ordered lists, which seems to best fit the context of what you have. They have a structure like: 

I would consider taking a look at Caman.JS, a image manipulation library with similar features to the one you've made. 

That's not really how you're supposed to use internals and variables. Consider using the chain instead. 

Use braces You should wrap your code in braces, so you don't cause any bugs unknowingly: For example, you (or someone in future that maintains your code) might think this wouldn't log anything, however, is logged. 

jQuery: You use jQuery for , and , I would recommend removing it. Using a library of jQuery's size for those three functions is just pointless when you can use polyfills from vanilla JavaScript. 

Overall, i think unless you are doing it for studying purposes, you should just grab an existing DI library, as you've metioned yourself :) 

Your class looks fine to me. I think every project have a variation of it. A few minor issues i see: 

implement one of those for every token (or every group of related tokens), and you should be able to rewrite as: 

Reactive extensions with + combo. It will take care of throttling text changes, overriding previous results and scheduling tasks. Rx API is not for the faint-hearted though. See: $URL$ . TPL Dataflow with + combo. It will take care about everything except for throttling. You will have to initialize those blocks with correct buffer sizes and degrees of parallelism. 

etc... If you want an easy access to some parts of your data, you should implement additional methods on highest level. For example, to iterate through s, you can implement following extension method: 

- i think you should either change this property name, or change type to . Semantically cell being a winner doesnt make much sense. In general i am not sure i can follow how will you derive from . implementation for small board doesnt make sense (shouldn't you check for winner instead?). Same goes for for large board. I have no idea how is going to be used for either boards, and what means (not very descriptive). Etc. As for i have a few minor concerns. a) I hate s, s, etc. with all my heart and soul. :) THey have this ability to turn even simple code into a mess. This is probably a matter of taste, but i think a simple arrays would be much more readable. b) I do not like multiple , it makes code hard to follow. A simple would be better. 

Security: When using a fixed salt, if they managed to break the compilation of the code and retrieve the plaintext salt, it would render the encrypted password down to a matching of common hashes. Use a different salt for each user (make a random integer, more than 10 digits even), and store the salt beside the password inside the database. 

for magic numbers (unexplained numbers meaning unexplained things), it's best to declare as a , but your version of JavaScript may not support this, so you can also use . 

You don't want to have it so either of those flaws totally screws your site, you want it so in the event of disaster, you can fix the vulnerability and keep your data intact. If your database is compromised, the attackers can use a rainbow table to test for possible passwords, however, it's a potentially long process. If either was compromised, you ought to change the hashing algorithm. 

The implode string could also be with an extra space, or even a unicode long (or not long) rightwards arrow: , along with the extra space, visually output would be more readable, and better looking. 

: It's not really an accurate name, there's not a 'calculation' done, you just start the FizzBuzz process. : Really just or works fine. 

If you want to keep the two lists (otherwise check Hackworth's answer), the best solution would be to use LINQ extensions 

It looks like you are wasting your efforts on premature optimization. Which also results in a quite ugly code. I think you should separate your grid-filling logic from csv export. There should be no memory streams, steam writers, etc. in your first method. Also notice that you have code duplication in it, so you might want to extract label creation logic to separate method. Ideally you'd want to remove this logic all together and use WPF (or ) with data-binding instead. As for your second method - you do not need any buffers. Just iterate through your data, create strings and write them directly to your . You might also want to encapsulate this logic in some separate class and perform it in the background thread so your UI does not freeze for large data. 

can work with so its not necessary to pass list to it. Same goes for : you do not have to call at the end of your first query, you can loop through initial enumeration. With LINQ you can join strings like that: 

You might want to abstract your filters out. It does not require that much effort/extra code, yet it improves readability drastically. 

: JSON files can get very large at times, so it's best to keep this in an external file in the same directory, and use the magic of the UserScript header: 

Your comments seem a little basic, at that, maybe write more than the basic reasoning of each function/execution, etc. 

You should have whitespace in between your , rather than none. You should have spaces between commas You should have spaces in between your binary operators You shouldn't have whitespace before and after your brackets 

Instead of the negatively recurring loop, consider using a length subtraction operation instead like in the example below: 

Clarity: Your program is unclear, the variables are named with single letters, which is bad practice as it is unclear and potentially hard to maintain in the future. Consider using entire words instead of letters. 

HTML building The way you're doing it at the moment is simply not right. There's two other ways that immediately come to mind on how to do it better: 

If you want to reduce the code indentation level, then you should use separate variables to store each step in the process, or just simply use a standard loop. 

When you are going over items in a dictionary or array, you can the comma on the next line, so that it's easier to understand. However, trailing commas are not against Python, so leaving them as they are is no problem. 

Why are those methods public? That does not feel right. Anyone from anywhere can call any of those methods in any order. That's sounds like a disaster to me. 

You are hooking method to event though. I don't quite see at which point you are going to pass the parameter to command and what it is going to be. As for the way you create menus... conceptually it looks about right. At some point, you are going to have this place, where you explicitly add items to menu in desired order, I doubt there is a pretty way around it. There are different ways to approach this though. You could, for example, create a generic add method: 

I won't comment much on your game logic or design because I don't understand it. All I can say is that it looks weird. You are using a high level programming language with powerful support of OOP, yet you are using... 2d char array to represent a board? 2d int array to represent a piece? Imagine if you, for example, had a (or even regular ) as your board representation. Then your method would look like: 

I would also recommend replacing loops with loops for better readability. Apart from that, you algorithm looks OK to me. Linq-based solution is way easier to write: 

Note, you could string concatenate the selector inside the function, but that limits the use case that you select another DOM element. 

you shouldn't skip a few characters at the expense of readability: Instead of , use (assuming that's what the abbreviation is for) You should add whitespace around your operators to improve readability: 

: Like I said above, I would place limitations on the variable that means it cannot be decremented, only incremented. Otherwise a simple interval hack is possible. 

But, I just wanted to make a point on these: ing: Triggering the inner lines, as well as the lines terminate the function, so the loop cannot be executed without returning. Meaning the usage of in these situations is entirely extraneous. Additionally, when you encounter duplicate code like that, try and make it more dynamic and able to accept both conditions (As Barry's version shows) 

I would suggest using a function for that, and passing in the specific variables that change: like for example. 

It's pointless to prefix your variables with , as it's superfluous. If you really wanted to, you can turn variables names like , into things like: . Which would be better on readability. 

It's better to use an object here, as later you can extend it without having to spend pointless LoCs on s and ing.