Your function could check the first heuristic and then fail over to the second heuristic if the first wasn't detailed enough. 

This will usually work but can cause problems if the number of rows is large. You are essentially reading the entire result into memory and then processing it later. If there's a relatively small amount of data, this is fine. However, if there is a large amount of data, then you can overload the server if you have this happen in too many results at once. For this reason, it is more common to allow the caller to take care of the while loop portion. The caller can either save the data or use and discard the results immediately. I don't want to say a lot about this, since you already noted it. It's worth repeating though. You would generally be better off using either mysqli or PDO to do this. You might even find that they offer enough that you don't need an intervening class to manage the connection. 

First, this would be easier if you named things more descriptively. I don't know enough about to suggest a name. For though, it should be called something like . For , something like if the array is still named . You are calling on every member of your collection. This could potentially do two calls and a memory allocation for every member. Instead, should do the same things that does only it should do it for the entire collection at once. That gets us down to two calls and a memory allocation total. 

Now I can easily see what I'm printing. Using and didn't tell me what they actually were, but and do. Move Semantics 

It doesn't make much performance difference, as you don't call the constructor enough to matter. However, you repeat several calculations unnecessarily. 

You know that the user has a score, because you found it in the first query. Therefore, you don't need a . A regular is fine and will be considerably faster. 

See how much simpler the function is for an array? You could also replace the loop with a here. I only stuck with the as it was what you had. The loop can be easier to read though. The spreads the loop definition across multiple lines. Some compilers can do faster than , so it can be advantageous to get in the habit of writing unless you need the behavior of . This won't affect performance much generally, but it also doesn't hurt anything to prefer . The is equivalent to . Use whichever you find easier to understand. 

If the string begins with a , then we don't care if none of the rest have a . Fulfilling the Problem Statement 

This is safer and more robust in the face of code changes. It will catch circumstances that a straight equality check would miss. 

I just made them members of (which I renamed to ), but you could also put them in or a new class if you wanted. I would tend to think that should be in while should be in a separate class, but it really depends on how you use them. There's an argument that should handle making inferences in which case would be redundant. I wrote out and to make it clearer what each represents. What are and ? Longer, more descriptive names would make the logic easier to understand. Notice how none of the variables defined in the first function are needed in the second (with the exception of which is actually declared in ). This is a big part of why I felt that they should be in separate functions. Now knows that it needs to read input and make inferences, but it doesn't need to know how to do those things. Ontology 

In your for loop, I don't see any reason for the inconsistent variable names. Why tries and attempts? Why not 

There's a significant security issue in this code. Note that you are getting the player ID from user input. What if player 100 submits a bid for player 200? This might be safe ( is forced to be an int previously) but is definitely squirrelly: 

Why name these ? That says laugh out loud to me, which doesn't really seem to match the descriptions given. Why not name them , , and ? 

This will turn the named variable back into an rvalue reference. We shouldn't need to pass by value inside the recursive function. We can work with the actual matrix. We need to make one copy at most to avoid changing the variable outside the function. 

This statement appears in every branch that does not return false, nine times. Once seems to be enough. 

In the first line, we can access our object directly. The is a little more complicated, so we rely on the fact that it just adds a prefix to the of the object. We get the by calling and use string concatenation to form the of the . Note: I haven't tried to run this. Apologies in advance if I missed the syntax somewhere. 

Try to avoid naming things in the markup (HTML) by where they should be. Instead focus on naming what they are. For example, would be a bit better than , but would be even better. Then could become and could become . 

is an implementation detail and your caller doesn't need to know it. I also changed to . I think it better represents what the holds. I'm not sure that I'd call these brute force versus smart force. A brute force algorithm is one that tries every possibility once. A brute force solution would be to generate all \$10!\$ solutions and then randomly pick one. Your algorithm can actually iterate an arbitrary number of times (in fact, it's not guaranteed to finish). I might call it naive rather than brute force. 

You don't need this in a file that is all PHP code, and it can lead to problems if you include it. In particular, extra whitespace after closing the PHP block can lead to being unable to redirect to a new URL or otherwise creating headers. You'll get the error, "Headers already sent." The standard is to only use this in files where PHP is embedded in HTML. There may be more things that I missed. 

This is a Factory pattern. I'm not sure that I'd call it the Factory method pattern. Look at the Wikipedia example for C# -- this looks like the before version. If you were doing the same thing as the after version here, you'd have 

This returns all ratings where the same person reviewed the same movie more than once, but that's not what we want. We want all the ratings where the same person reviewed the same movie twice, giving it a higher rating the second time. 

Note that if were the inner loop, we'd need to do this for every iteration of the outer loop. So in whole, that gives us 

As a general rule, try to avoid calling functions multiple times with the same parameters in a loop. 

The last two statements appear in all nine branches that do not , but we now we do them only once. If I counted properly, this replaces twenty-two statements with eight. 

Although that's a bit long and complicated for a single line. Note that we can rewrite the first line as 

But the solution is probably different. Perhaps simply rename that to . Alternately, you could make a new class with a function, or a higher level class like , , or with a method. Of course, if you follow this advice, you will end up with a much larger number of small classes that basically exist to wrap the method in each. You will probably have to pass your to each the way that you already pass a . 

That way you don't have to specify that the tile is moving to the empty space and the caller doesn't even need to know where the tile is located. You move a little bit of code out of the two callers and into the function. 

Note that res can contain all the permutations (of which there are \$n!\$). This is what gives you your \$O(n!)\$ time. Note that it's actually \$O(n^3n!)\$ time, but the \$n!\$ eats the \$n^3\$. 

This saves calling on each iteration of the loop, plus it eliminates the calls. The whole TrieNode.java using a rather than an : 

Your Javadoc is out of date. It still thinks that you are returning a tree. As a general rule, you should return a (the interface) rather than an (the implementation). This will make it much easier to change the implementation in the future. You are missing an 

While the compiler won't care, adding spaces between the function name and the parameters list makes this look like something other than a function to me. I.e. I find this notation confusing. 

This has some separation between HTML and SQL (as mentioned in the comments). It's obviously missing most of the page code (no html tag for instance) but hopefully gives you the idea. You should have all your data accesses (SQL queries) before you output any HTML. Some other changes that I made: 

Given this example, you don't need any variation of the Factory pattern. You could just create the objects directly. As a general rule, you shouldn't look to use design patterns. You should meet problems that can be solved by the design pattern. You don't have a problem that needs a design pattern to solve. Example of a problem that needs a Factory pattern solution: given a passenger count and a cargo weight, return an object representing a plane that is capable of carrying those passengers with that cargo. Example of a problem that needs a factory method solution: define an interface for a plane and another that will allow you to create a plane object. Give the interfaces to two partners. Have one write a that implements your factory interface and the other an . Both should return plane objects that implement your plane interface. 

Note that and would probably be enough, as "saved" and "current" are implied. I also added whitespace between tokens. The compiler won't care, but this often makes it easier for humans to read. 

You would then have all the values at once, rather than making multiple database calls. Note that I used a nowdoc to hold the multiline SQL string. 

is probably more correct. Remember that the probability of finding a combination without a collision is . So the first iteration through the loop is the 2nd, and the iteration is the combination. Now, if instead of the birthday problem, you are looking for the chance of a match to an already existing combination, then this would be closer. However, that problem would normally not care about collisions in the match tries. So it seems you should either change the upper limit in the loop or swap out the loop for 

As a general rule, you want to avoid calling a function on every loop iteration which always returns the same value. 

The makes it clearer that all the cases are based on the value of . An / is more flexible. Final Version 

You have a field, so you should update it in this function. Actually though, you can write this function more simply: 

Again, I could easily tell that these stored Peggy and Sam Nodes. What I don't know at this point of the code is what a Peggy or Sam Node is. This suggests to me that this is the wrong place to be declaring these variables. You may want to thing about how you use class fields. I see no reason why any of these couldn't have been set in the methods where they were used. As a general rule, shouldn't need class fields. If you do need fields, perhaps you should have created another class where fields would make more sense. Perhaps . Your depth-first search and other methods might make more sense there as well. 

One of the problems with C is that the at the end of a block after an may mean that you are done with the or it may mean that there is an . The C compiler won't care if you have a hundred lines of whitespace before the else, but people have a reasonable expectation that done means done. Please either cuddle the or at least make it the vertical equivalent: 

If is greater than the recursive result of calling this function on the rest of the array: increment a variable; print out a statement describing what happened; return because it is the largest member of . 

For #2, you have to enclose all the content (including headers and footers) within the tags. You put non-content like CSS and meta tags in the section. You can also put Javascript there, although you may not want to do so. For #3, breaks? Do you mean the tags? You can eliminate those with margins (especially margin-bottom) and/or positioning. For example, try 

What's this cast out of and then back to get you? If it gets you something, this would be a great place for a comment. 

Separating a closing from its succeeding will only lead to tears. In general, I find your comments to be simply English versions of what your code does. Whomever is reading your code should be able to make that translation without comments. You should save comments for explaining why you are doing things, particularly if what you are doing is clever. Example: