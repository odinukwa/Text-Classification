That saves using the and combination, so you save a process, but the code is a bit more complicated. 

Now, I also changed to , and I added space around the operators and between loop keywords and braces. But, the above, is really your code, reformatted. After that neatening up, there is one more things that need to happen: Variable scopes. Variables should be as narrow as possible. The should be declared as part of the for loop control system, and the should be declared inside the loop. This is the result: 

The right tool for this job in Java6 and newer is the combination of a and a EDIT: You should also consider changing your Process-running code.... consider creating a function: 

This would be a good opportunity to learn some performance features and limitations of the Java Virtual Machine, and the available libraries. I want to take your code, go through a staged progression of optimizations that will improve the way the code performs, and, while it will not change the runtime 'complexity' \$O(n^2)\$ of the insertion sort, it will improve the actual runtime. As Nick has suggested, your variable names are not very meaningful. He's suggested and . I can use those, they are good. So your code becomes: 

is called from a new thread, but it affects the List which is shared on all threads. But that instance is neither synchronized nor concurrent. There will be corruption to that list at some point. Out-of-place logic 

I would normally return this as a raw array - I like arrays. It also makes it clear that it is a defensive copy of the data. If you want, though, you can wrap that array in a different format: 

Because the Node is currently public, and especially because you 'leak' the node with the method, it is is possible of anyone to break your list, by getting a node, and then messing with the node internals. The other concern is the value in the node. It actually serves no purpose. You do not use it for anything, and you can do all the math you need based on the loop counters and list size. It is a lot of work to maintain, and it adds no value to the result. 

Then, when you construct you should also add all the thresholds and messages that are needed in the class. By doing this, the actual implementations ( , , etc.) become simple classes with just a constructor and no methods at all. The Base class does all the heavy-lifting, and the code is in one place only. 

There's no notion in the above of the internal implementation of the pool. That's a good thing. You use basic Go mechanisms like slices to aggregate functions to run, and you use basic go parameter manipulation to expand the slice for entry. I played around a bit, and settled on this function: 

Correct use of each of these 'systems' will allow safe operation. Problems start to happen when things get non-standard, and flow against the standard usage patterns. When people cannot 'see' the concurrency-controls, that's when bugs happen. Your class imposes coding practices that are unexpected: 

You have a number of missing links in your code, which makes a review hard to do. Your ServerSocket code at first glance looks OK, but it is actually broken. 

Now, this is great, it will populate a list, but, in the world of Java8, with Lambda expressions, it is 'fun' to do it the streaming way too: 

Your code looks functional. I quite like the idea of splitting the data in halves each time too. There are some things I would do differently, though. First-up, the 1-liner if statement: 

All in all, the only things i can find to criticize are some naming conventions, formatting, and some pedanticness that is really minor. It's a great solution to the problem. Thanks 

When I have encountered this type of problem, it typically involves creating some ugly code in your method to do that iteration. In essense, there is no way to do things any differently, you have to iterate, and collect the UUID's (but, you could wait for Java8 and do lambdas ..). But, there is no reason why you have to do it outside of the class. A trick you can do which keeps like-code together, is to put a static method on , which does: 

None of them are 'nice'. Large Constructor Your code is an example of the large constructor. Post Construction The post-constructor modifier system will have a bunch of 'set' methods, and you call them like: 

use a loop that counts back from the end of the input/output. Then you don't need special odd-length input handling. identify whether an input char is going to be a high or low nibble in the result. use a lookup table (low/high nibble) to find a byte value for that input. use a bit-wise OR to add the low and high nibbles together use bitwise AND and bitwise right-shift to convert the input character to the output byte/nibble position. 

If you want to pull an event from a listener, you can easily do so by adding a listener. If the listener feeds events in to a (blocking) queue, you can iterate on that queue, and pull events as you need them. One thread parsing the files, and other threads waiting for the needed data. That's the way I would do it.... Actual code I would start off with an interface like: 

That will, for example, return 0.0 for ..... which is not the double you are expecting. Secondly, catching division-by-zero using exceptions is a poor way to do it. You should instead just pre-validate: 

Minutia A table called ... really? Columns and .... why are you using example tables? In your setup you called it but in the code you called it ... Normally we require that code is real code, not 'example' code. In this case, it seems your actual code is 'real', just the tables it works on is not. IDENTITY columns IDENTITY columns are generally there for one reason only, to create a unique field that is fast to use (insert/index/join/search). These properties are guaranteed in all uses of the field, including concurrent modification of the data (two processes inserting data at the same time will each generate unique ID's still - guaranteed) You want to have the added use for the column: to ensure there are no 'gaps' in the sequence. This is not what IDENTITY columns are for. IDENTITY columns, for performance reasons, generally allocate a 'pool' of numbers to each process that's adding data, and as each number is used from the pool, the pool shrinks. If the pool is no longer needed, then the pool is 'returned' to the system and another process can continue with it. If two processes are inserting data at the same time you will often get gaps between the numbers because the pools are different. Also, if there's a "hard crash" on the system, the pool is often completely 'lost', and you could have large gaps in the ranges. This is the compromise that IDENTITY columns make. They sacrifice sequentialness for performance and concurrency. Solution There are two solutions, the easy one, and the hard one. The easy one is to accept that there will be gaps, and move on. I strongly recommend that you revisit your requirements, and see if you can just use the IDENTITY column and move on. The hard solution is to build your own system for number generation (although it will still not be perfect... if someone deletes a record, you will still have gaps). Your solution is too simple, and also too slow. It is, essentially, broken. If two processes run at the same time, they will allocate the same numbers for records, and you will have duplicate insert situations in to your table. This is because you do not have any transaction handling for your statements... they are all independent. You need to have a table-lock on the table so that no other process can add records while you are finding the max value. The lock is needed for the entire process of finding, and deciding, and inserting the value. You will need to read up on "with holdlock" for your select statements otherwise the lock will not be maintained: See the HOLDLOCK and other documentation on transactions. Then, after the manipulation is done, you can commit the transaction. Your performance will suck because you will be locking a lot of data, etc. The better solution is to have a separate ID table for your key field. A simple table like: 

I am worried that this is a typo for as you tanslated the code.... If it is, then you will be repeating all the reports in each thread..... it should be: 

That makes the return criteria clear. Now, the regex should probably be anchored.... but worse than that, the expression is a double-negative - if not the char is not a letter/digit.... do something. Now that I look more closely, it does not work at all..... it will never match anything. The needs to be inside the character class.... hmmm... have you tested this? The search will always happen because the single key-press will never be a single-character and a backspace.... so, the ajax call will happen whenever a non function key is pressed..... I would make the code: 

That function has a useful name, I have made it static because it does not rely on any instance data/fields, and it is a simple stateless function. Now, we can reuse that in the main method. All we need to do is separate the first and last names..... and a simple enough way to do that is your call. 

and that atomic may not get the value that was previously set. So, you have a potential race condition in your atomics. That's why atomics are not the best choice here. Now, you have a second bug in here. If your computer has 2 CPU's, the threads doing the work may be running on different cores, and have different memory caches. Consider the one thread does the add at position 4, and the other thread does it at position 3. Since the add to position 4 is in one thread, and that access and assignment to the array is not in a memory-controlled block, there is no reason for anything happening on the other CPU to get the updated 'copy' of that array, and you may lose that setting at position 4. Any access to a variable/array that happens in one thread may not get the same value as what's in another thread unless the accesses are all done via the same memory control/lock/monitor. In your 'read' side () you synchronize on the array, but, since the writes were not synchronized, there's no reason to expect the reads to get the written values. In other words, what you put in to the messages array may not be there when you read from the messages array. Other Issues 

There are two issues with your code which should be addressed. The first is the heavy cost of all the conditions you are performing each time you run. @200_success solves most of that problem by using a lookup table. It saves a lot of runtime code by replacing it with pre-computed code. The second issue is the handling of unexpected characters. You use the call to determine if the character is a letter, but this call is defined to include unicode characters "OTHER_LETTER" and also "MODIFIER_LETTER". These will all be translated as the value in your code. There is a mathematical way to compute the results you want, with one exception. The trick is to identify that there are three keys-per-number for all keys, except key 7, and then there is an exception case with input Z, which is an overflow. If we calculate a 'value' and an 'offset' for each letter, and then do an integer truncation on it, we can convert it directly to a specific number. The trick is to find the constants that are needed. I did the calculation as: 

That makes the conditions simpler to follow (no else statement). Similarly, when you have a return statement, there's no need for an else, this code: 

What I am trying to show here is that you essentially have a while-loop that uses the stack to check the end condition. For a long input, your code will fail with a stack-overflow exception. Iteration When you have linked data like you do, the natural solution is to use iteration. The example I have above shows how it can be done. I am not sure why you are using recursion at all. Actual Recursion If you really want to use recursion, the right way to do it would be to recurse down when you encounter a value, and recurse up when you encounter a Each recursive level will make sure it has a matching parenthesis.... it will look something like: