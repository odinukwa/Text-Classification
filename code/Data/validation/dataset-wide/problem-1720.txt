This is normal and expected behavior. Remember that sanitizes the environment when switching users, which is why you end up with a minimal default PATH. The remainder of the items in the PATH come from shell startup scripts, which are not being run when you (or rather Ansible) call , because it is not asking for an interactive or login shell. If you have to run a command which isn't in a default location, supply its path explicitly. 

You are running opcode caching, right? It used to be APC that was the go-to here, but it's been a buggy piece of for quite a while, and has been superseded by Zend Opcache, which is now part of PHP since 5.5, and has a backport in PECL for 5.3 and 5.4. 

The hard drive manufacturer decides what SMART attributes they will expose to you. If they decide not to track or give you that information, you can't really get it. As for how you determine what attributes are available, you look at the output, just as you already did. 

Amazon Linux is not a supported operating system for VirtualMin. You should expect breakage if you attempt to use this distribution. The specific problem here is that only a previous version of Amazon Linux (2012.03) is supported by VirtualMin (and as Grade B), which Amazon no longer supports. This makes it Grade N, not supported by the installer. To resolve the issue, use an operating system listed by VirtualMin as Grade A Supported. 

While this is really a minor issue for me, since I could go live without IPv4 DNS updates (it's nice to be 100% dual stack) it's still annoying to not know what's going on here. Perhaps there are logs that I missed that would shed light on the situation? (Oh, and yes I turned it off and on again.) 

Use a status code other than 503 for your "maintenance mode." As we can clearly see, users don't actually get served a 503 when you are using "maintenance mode" anyway, so there's no benefit to using that status code internally in your configuration. Make up another code (593?) and use that. 

You can specify multiple environment variables on one line with , and you can even give the option multiple times if you want. For example: 

Your PHP runs in a chroot in , but your document root is . So when you load up the becomes . But, in the chroot this doesn't exist! It is at instead. What you can do is to change the directory here so that it matches the view from the chroot: 

You can't use LLMNR in that scenario because it was introduced with Windows Vista/Server 2008. Windows XP does not support it. Since Windows XP is end of life, and nobody should be using it anymore, (though some are) you can use LLMNR once you have completely eliminated XP from your environment. 

You need two networks, not just one. The VM connected to both networks must then have two virtual NICs, each of which is connected to one of the networks. 

It's most likely that a user did this manually, or that a script running on the system sent a signal to PID 1 (possibly by mistake, intending some other PID). You may want to look into the two root user sessions that were open at the time of the shutdown. 

nginx is fully capable of caching proxied (or fastcgi) content. In this case you will want to adjust your directive (or ) to reflect the circumstances in which you want to serve cached data. 

You will find, on close inspection, that these are the commands your distribution's networking scripts are using. 

KVM is just the hypervisor itself. It allows overcommitment without any artificial limit. The limits are provided by any management tools installed on top of KVM, such as OpenStack. 

Since you're binding to a port below 1024, it must be started with root privileges. Try something like: 

This means that nothing is actually listening on that port. The most likely cause is that you didn't actually start the service. 

You have both the 32-bit and 64-bit packages on your system now, so in order to update them you must update them both at the same time with the same invocation. 

Your locale is mis-set. You have defined as , but everything else is defined as . These are rather different, and mixing them will cause all sorts of weirdness. Do what the error message told you: set to the correct locale (and set all the rest of them too). 

Most current hypervisors that run on Intel hardware use CPUID leaves 0x40000000 et seq. to pass information about the hypervisor from host to guest. KVM, Xen, VMware and Hyper-V all use this method. This is in addition to the hypervisor feature flag set in CPUID leaf 0x1, which indicates that the machine is a virtual machine. It's therefore trivial for a program which can call the CPUID instruction to determine whether it is running under one of these hypervisors. Recent versions of KVM include a command line option to disable the CPUID 0x40000000 leaf, . 

You still have the MariaDB yum repository on your system. As long as you do so, MariaDB will continue to replace MySQL. To resolve the issue, remove the MariaDB repository. Do this by locating the file (it may be named something like ) in the directory. Once you locate the file, you may remove it, or you may edit the file and change to . 

There's no pre-existing variable, no. But you can use whatever socket you need to use, so long as the socket file exists, and php-fpm is configured to use it. 

You can still host your web site with AWS, and you can even still host your DNS service on Route 53. The list you linked to is a list of domains which you can (or cannot) register with Route 53 as a domain registrar. 

Place your extension in the correct directory. PHP looks for extensions in the directory specified in the directive in php.ini. The directive simply specifies one or more extensions that PHP will attempt to load, relative to the path. 

But, that's not how you should fix the problem. This has a further problem, in that the http to https redirect is inefficient. This has to be evaluated on every request, and the has a gratuitous regex. See Taxing Rewrites for more information. Instead, you should have a completely separate block for HTTP versus HTTPS, and remove the / from the HTTPS block entirely. 

Not being able to resolve hosts is the issue they'll face. This means they won't seem to have Internet connectivity and will get strange errors like: 

I presume you're using some sort of cheap SOHO router. In this case you must plug its WAN port into the office network, and no other ports. 

NPM isn't packaged for EPEL 7 yet. Give it some time, they are having to update thousands of packages already and had to wait for the CentOS release which was just a couple of days ago. I suggest contacting the package maintainer (who appears to be patches) as they may not be aware that CentOS 7 is released and that they can now build their packages for it. 

You are using a wrong directory for . You should not store MySQL/MariaDB's data under . For security reasons the database is not allowed to access user home directories. In order to accomplish this, systemd runs MariaDB in a container, which cannot access . The "standard" place for the datadir is . Change the datadir to the correct value and try again. 

OK, here we see that the dependencies are trying to bring in , which depends on , which is the wrong version; I would be expecting , and possibly packages to be pulled in here. This isn't something you can really resolve; the repository you're trying to install from has broken packages. (Unfortunately this poor quality packaging is all too common with Amazon Linux, which is one reason I recommend against using it.) You'll need to contact Amazon, or better yet, use anything but Amazon Linux. 

Actually it is definitely the fact that you're running nginx on Windows. It has some serious limitations, chief among them that it uses for connection processing, and only runs a single thread in a single process. This means that, while it technically can 1024 simultaneous connections, it can only do actual work for one request at a time. In your case this means Windows is absolutely positively inappropriate as a development platform. Your best bet, if you really want to continue running Windows, is to run the nginx server in a Linux virtual machine. You should also consider the advantages of running a Linux workstation. 

In this case we see from the third field that it is an NFS mount. Your file will tell you exactly what is going on in your case. 

This means the drive was unable to read from a sector of the disk, and in this case, was also unable to reallocate a good sector to take the place of the bad sector. A URE can cause the drive to appear failed to a RAID controller and putting your RAID array in a degraded state. After the next read error on any remaining disk, you lose all your data. So you should replace the disk immediately. (And woe to you if this isn't in a RAID...) Despite the "pass" from SMART, you should be able to get a warranty replacement when your drive is showing any number of unrecoverable read errors.