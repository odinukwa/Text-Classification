One assumes you have a Java background. If you don't need your object to live beyond the time span of the function then you don't need use new. What you need is just create a local object. 

You should probably have iterator with a lowercase . This is because a lot of the algorithms will use the type. Good start. 

In main if you don't explicitly return the compiler inserts a return 0. Thus if there is no possibility of an error state for your program then don't return anything (this is an indication that it will always work). 

This will allow more readable code below. AS a personal preference I allways have my types begin with an uppercase letter. This helps me distinguish types from data in an easy way that is not intrusive. This becomes more important when you start playing with templates. Try and limit global variables. 

Currently your iterator can only be considered an but given its simplicity it really should be . $URL$ Which means it needs to support the following: $URL$ Accesses Currently you only have const accesses: 

This is all wasted code. If the map does not contain an element then then operator[] will auto insert a default node using the default constructor for the value type (which in this case is the empty set). 

Why are you building the tests into your main executable? Should the test application be generated as a seprate application that includes the normal objects (apart from main) and the test objects. Why do you have libs outside your lib variable? 

Your check for invalid characters is Windows specific. The OS will usually have a platform or OS specific set of functions for checking valid characters. 

You declare way up the to tof the function. But it is only used deep inside a nested loop. Just declare variables before you use them. Then it is easy to see the type information close to the point where they are being used. Return value One of these two things is not returned. 

But why have the loop. Why not generate a random one smaller than the max than add one. Also why are you creating a new random number generator on each iteration . You just create than once (in the entire life cycle of the program) then use the instance every time. 

OK. I am going to ignore this and assume it is a work in progress. Otherwise your application can only have one list. 

Read all the user input find the maximum value. Generate the factorials for all values upto the max Note: Saving them as you go: Print the factorial values by looking up the result you generated in 2. 

This should probably be a . Once you do that the rest becomes irelavant and all memory management issues are solved. 

If this was asked at an interview then as the person asking the question I would have expected you to ask a couple of more questions about the input format. What we have here is relatively clear for the simple example but there are some subtitles that come out form this that we need to tease out from the input format. 

Use initializer list in the constructor (and comments like that are usless I can see they are constructors). Comments should be used to explain the how (or why) code is doing what it does. The code should itself be self documenting (ie use good variable and method names that explain what is happening). 

Any well constructed C++ class should behave just like a normal built in type (and everything in the standard is well constructed). As long as you don't use new/delete it should feel no different to you than using a built in type. 

new will not fail The function will never return . If it fails it will throw an exception. As a result there is no need (or point) in checking the return value of . 

Standard algorithms. Your code will be optimal when you use the standard algorithms. Its worth learning what is available. $URL$ See section 5 I showed you how to copy all but the characters you want. But there is one to remove all elements in-place. I'll let you experiment. 

Don't believe that line actually needs a cast. If it warns you about loosing precision then by then you should use a cast (to let the compiler know you know what you are doing and are willing to loose precision) but it should be a 

for each iteration of s[]. What you want to do is iterate over f[] once and save the state of each character. So that you can just look up the answer in one step rather than an iteration. To do this we hoist this loop out of the inner loop and allocate an array for all possible values of char, then mark any we find in f[] as true in our allocated array. This is what mine would look like (actually mine would look slightly different as I would have written in the C++ style but I have translated into C to make it consistent with the question). 

There are a lot of similarities between a Player and an Enemy. You should probably pull all the same code into a common class so that you are not repeating code in two places. Reducing Code You fixed up nicely. You should probably move the rand number dye roll down close to the point it was used. But you can apply the same solution to . The functions and look very similar. Is there no way this code can be generalized so that it works the same if you are fighting an enemy or another player? The functions and also look very similar. Again can you not generalize these function into a single function? In fact I am pretty sure that if you have a common base class for Person and Enemy then all the above functions will very quickly simplify themselves. 

Also You can improve your search. Rather than using std::vector use a std::set. Then a find will automatically do a O(log(n)) search of the data. 

Getters/Setters Getters and Setters break encapsulation. They expose the internal implementation details of the class. If you see the pattern 

Order Of Creation Personally I would not create the node until I had successfully completed the two sub-trees. Less objects to release if something goes wrong. 

The one issue I have with this is that it does not provide the strong exception guarantee and you can't fall back to the original state if something goes wrong. Though this is correct. I don't like the copy constructor not explicitly initializing the members. Have to go check the rest of the code to make sure the members are initialized reeks of doing things in multiple places. Move Semantics The source of the move can be left in an undefined state (as long as it is valid). I don't see the need to values from the source object. just move them. Poping them adds extra work that is not required. The destructor when called when do all the cleanup required. 

Always use the '{}' to surround a statement block. This will save your ass one day when you use a crappy macro the expands into several statements. 

I am sure if you play around with this you should be able to get it working. Sorry I can not be more exact but that would require using the same product as you. 

It all depends how you define word. But lets assume "white space separated". There is a function to detect white space So you can simplify your test. 

As this is reserved for the implementation in C++. Also the term BITMAP is very generic and you are very likely to clash with other libraries try and make it more unique to your project. You are assuming that a char is 8 bits.