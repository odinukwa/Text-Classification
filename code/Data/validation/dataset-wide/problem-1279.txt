What should I do if I want to refactor this class? I've been thinking of treating it as just a simple data structure instead of like a class, since all the does in the file is hold data about the client, but I'm not pretty sure of what to do here. There are 17 classes, and each one holds a different number of members, which stand for "fields." I'm also thinking of eliminating the extra class, since I feel it does nothing to improve the design. My intention at first was to have different kinds of "fields" like , and so on. 

I'm working on an important project. We're an IT services provider and we have a project where we have to build a new system to process data from a specific client. The problem is that usually we process their data, but they send us a pre-processed data that's easy to parse, but this time around, they're trying with a new format, which is extremely weird. Anyways, there were two senior programmers that didn't want to mess with the project, and it's been on hold for one whole year. I'm a junior programmer and I managed to build a system that kind of works as intended but I want to improve on it. I don't like the way it ended up, even if it works. The thing is, this format is for generating account statements for a local bank, and they're sending in RAW data. I managed to read and parse the data by using a configuration file that's able to read the data from it's position on the file, which can have up to 500 MB of text data. I built a method that uses reflection to fill in the data in the different classes. The data comes grouped in s, which have many fields. Each holds specific information, like transactions, client info, balances and stuff. I created a superclass called , and then made the other corresponding types of register extend from this superclass. The thing is that there are 17 different kinds of registers, and a can have from 1 to more than 30 members. I only use one from the superclass, and using reflection I can set the member variables for all the other registers. I feel that my approach is kind of stupid, even if it works, and I'd like to improve it and make it more clean. Right now the whole system has like 25 different classes and I feel that my solution is too disorganized. Any advice on how to improve on my design? I'm going to just include the code for the that contains the information for the client. We are talking about bank data here, and this code is used to generate statement accounts. Please note that the class was designed this way because that's the way the customer documented it, and the way the data is arranged in the text file we receive: This is FieldParser class: 

I assume you intend to be using integer division here? Ie, ? Also.. why are you repeatedly declaring different variables with the same values? 

Comparing different data types in Javascript involves the type coercion system, which in javascript is a Bad Thing -- you're basically putting yourself at the mercy of an extremely unpredictable system. But, beyond that, it's not even clear what your intention with this line is -- how does it make sense to compare a float to an array? 

If I understand what you're looking for correctly, it's the cheapest rate for a particular phone number. If you already have the rates of each operator as a dictionary of key/value pairs, then you don't need a regex at all. The following code finds the cheapest rate in a set of dictionaries: 

We've already used datetime.now(), it's both simpler than timestamp.strftime and it's nice to not have to introduce new functions unless necessary. There's an even shorter alternative you could use, which trades off a little readability for space: 

If you actually need to parse strings such as '46732 1.1' into dictionary key/value pairs, a regex would be a good fit for solving that problem. A little quick fiddling suggests that something like would capture what you're looking for. This RE matches: one or more digits, zero or more whitespaces and one or more digits followed by zero or one decimal points followed by zero or more digits. You can use this pattern by compiling it, folloed by python's method. 

Also, it's generally considered bad practice to use : if new fields are added to the model they will be rendered for the client by default. It's much safer to use explicitly whitelist fields using the attribute of the meta class. 

That decouples the interface of the function from its implementation. One nitpick about your above code, which I only noticed noodling around with it now in a shell session: That's a very long function name. It's generally good to be longer than shorter and more explicit than less, but also consider it can be tiring and people have to remember the names of your functions. Try to find the shortest name that accurately and specifically describes what the logic does. I would probably name that logic something like . 

This implementation renders the formatted strings and table borders as whole strings. Probably rendering the each cell separately might be a better or more optimal idea, but I don't know how it would affect the character then. I don't know how fine is the implemented spliterator, especially its method. I'm not 100% sure if dynamic expanding the array is a good idea. For example, I would assume that the collector must only expect well-formed data, and detecting jagged rows is basically out of the scope of the collector (simply speaking, it probably should always expect for n x m matrices). Well, a collector that produces a stream. 

Note that decorator (basically a result can be immutable, as it's just a snapshot of a given XML) "protects" the aggregation result directly from elsewhere, however in this case it can be modified using the handler methods, but you can make rework it to build a result object with defence-copied maps so no handler interaction could change the result maps. I'd recommend the class and the strategy method to be fully extracted elsewhere. Note that the implementation above can be tested, in principle, using unit tests during builds (except of that would throw a stub exception, but this could be worked around using the Strategy pattern). 

First, in Java 7, I'd abstract the parser component and let it just parse and do nothing else. Don't use the class to the parser as this is not a necessary thing here. You can easily use just an you could obtain from anywhere, not necessarily an input stream from assets (this simplifies unit testing very much). 

Note that I prefer static factory methods and hide constructors as much as possible. Also I think that static inner classes are better because: 1) you can extract/move such classes easier than non-static ones; 2) you control what it gets, hence you don't capture that outer class reference and all of its fields. Also note that I use intentionally here for a few reasons (performance in general, compiler can trace code execution branches [let's say, you can switch to over rather than and configure your IDE to show a warning that not all values are covered]). Second, this is how the handler is defined: 

Importing is generally considered bad practice, because you don't know what's being imported into your local namespace. For you case, I believe you can get away with just doing . In the general case, if you only need a few things from a module, you can do: 

I think there's serious readability issues with this, and I also can't think of any time I've ever seen a function/method being called inside another function's signature. I'm going to go out on a limb and say this is a Bad Idea -- for one thing, I suspect that automated code documentation tools might have trouble parsing this. More fundamentally, a function/method's signature is its interface with the rest of the world. It just seems like a very bad trade off to muddy the readability of a signature in exchange for saving a couple of times of code. I would refactor to something like: 

You could also think about how you actually initialize this script. You mentioned you're running it as a cron job, so I think this layout makes sense, but you could also rewrite this as a class and place the init logic into the method of the class. 

At the end of the file. This allows the file to either run as a script or to be imported into other modules. For example, if you wanted to reuse your function in a different project, you could then do . 

This looks pretty good -- views should generally be pretty minimal. These seem pretty short, and most of what you've done so far seems appropriate. One pattern you might think about is using a mixin to dry things out a touch more. Eg, you have all your methods decorated . If you created a LoginMixin, with and just decorated the method there, you could loose a few repetitions. Mixins are also nice to have, as you can stash other repetitive elements in them as needed.