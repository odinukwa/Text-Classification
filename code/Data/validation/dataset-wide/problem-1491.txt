Since you should have a swap method anyway. This also makes writing the move constructor more intuitive as you can also just use the swap method. Also note your move constructor has undefined behavior. 

You are correct. You could have a normal parameter. Questions from above: Mainly looking for feedback on: 

You can get rid of both the above. The compiler generated versions work fine. For the assignment operator. Why care if it is self assignment. In this case it makes no difference. But why are you only copying the string. Don't you want to copy all the members? In There is no range checking for rank and suit. What happens to if I call: 

These last two are huge functions. Way bigger than they should be (I am betting that is to keep the member in line correctly. I have not had time to digg into them and find the problem yet. But I will come back tonight. But lines like this scare me: 

I would put a "\n" on the end of the line. It makes the questions on the terminal look like the question is on one line and your answer is on the next which in my mind makes it easier to read. 

Deprecated Code: This code was obviously writte to conform to the original (rather than the more modern ). You can tell by the use of . 

This is not exception safe. If the code in throws an exception then will not be executed. Now you think none of this code throws exceptions and is a C-library so it will not. But I bet Tidy allows you to register callbacks. These callbacks can throw exceptions and eventually you will add one to the code. Example: 

If it does. It is not doing what you think. It is calling a constructor that will convert the NULL into a Vector object. If this is happening I would try and find which one and make that constructor explicit so the compiler can't do that. Because it is probably not doing anything good. This is not doing quite what you think. 

namespace Usage This type is in the global namespace. Why not make it part of your namespace? All your definitions should be in your namespace. 

Upps. That is definitely a bug. Because other threads can modify finished it must be accessed after a memory barrier to force synchronization across threads. There are a couple of alternatives. 

As a physics persons. You may find that -500 is too low a value (you can not cool things to that temperature ( 0 Kelvin is the lowest temperature theoretically (though there have been experiments that show a temperature a few fractions below this but that has more to do with how we measure the temperature and people are still arguing about it))). 

Is trying to compensate for endianeess. I would rather see a standard function here. Something like or an equivalent. I assume there is a reason that the padding starts with: '\x80`. It would be nice that is in the comment. There must be a technical reason you are not '\0' padding the string. 

Here Key and value are moved into place (which is generally less expensive than a copy). If you want to go super new age you can construct the value in place: 

You can even optimize checkForWin() by passing in the player that made the last move and the position they played in (as the winning move will include their last move). 

It still seems to work (even when the stream is std::stringstream), but I am a tiny bit surprised. You are supposed to return the value of the iterator after putting stuff on the stream (not the original value). It seems to work anyway because the iterator changes the state of the object that it is putting stuff into. 

They are a cognitive drain and less intuitive to read (unless you are yoda). Prefer the more traditional style as it makes it easy to read fof developers. 

Print more efficiently. This is probably the most inefficient way to print the string. You are calling the output operator for each character in the string. Also the stream operator is already overloaded for so you can do this with a single line. 

Rather than have SieveHelper being declared once and then updated each time through the loop. Just create a new one each iteration. The actual cost of construction will be optimized to zero and it becomes easier to read. 

The reason for this is that you use different techniques for both cases by only using one you make sure your code is DRY and consistent. 

The blocks waiting for one of the file descriptors to become available so that a using it will not block when it is used. But you are blocking on the so you are not gaining any advantage to using select here. The point of is when you have lots of sockets with lots of data being read/written. Then allows you to continuously read from sockets that are ready and not block waiting on sockets that have nothing yet. Remove from this context. Printing error messages This code is way too low level to be printing error messages. 

I think that auto hurts the reader of the code. This is an external interface. If I am going to use your class I don't really want to know the internals I want to know how to use it which means I need to know whats coming out of these functions. To actually I work this out I need to generate some compiler errors or look into your code when I just want to read the interface. In this case I would expect: 

When inserting a child into the middle is it intentional to only set the index of the inserted child? 

I hate all the faffing around with the bad bits and the clunky handling of the rest of the line. Yes there is a slight possibility of inefficiency if there is a bad line that is exceptionally long. But under normal operations I would not worry. When reading formatted input with efficiency is not usually your biggest concern. When you are reading then its (efficiency) definitely not your biggest concern as the user types very slowly. I would also say it is the easiest to read out of the three solutions. Comments on original Code Things that stand out in the original: 

This works. But it is a bit verbose. In C++11 we made this easier with which makes the compiler do the work of working out the type. 

You don't need that lamda in the your main function. You just did not specify your comparison operator correctly. 

But these are used so often I will not complain. I would have preferred it if you had not polluted the global namespace for everybody (in this file). All caps identifier are by tradition reserved for macros. Macros have no regard for scope so you are putting yourself in a dangerous position using all caps for constants. 

Is your class taking ownership? If the answer is yes (you take ownership and thus control lifespan). Then you should pass the object using a smart pointer that allows transfer of ownership. 

What I would take away from this is how the standard library does this. It disassociates sorting algorithms from specific container types (by using iterators). Then you can write the sorting algorithm in a way that is independent of the actual container type. What I dislike about your code is that when you move elements you basically re-order the list (you actually move the nodes). This is a complex operation taking many checks. Personally I would leave the actual nodes where they are and move the values between nodes. std::swap() can be used for this. This: 

Personally I add a debug suffix (and a C++ version suffix). So that debug libraries have "D" (note not all platforms generate compatible binaries for debug/release so you don't want to mix them up). Even if they were compatible you don't want to accidentally link against a debug library when you are doing performance analysis so if you are explicit you will not accidentally get them mixed up. At the end my libraries I also have a "03" "11" "14" or "17" suffix to show which version of the language they were built against. Maybe a bit paranoid. But I have been bitten by this once so I automated it so it would not happen again. 

Also by using this convention you get rid of a lot of extra (+1) and (-1) from your code and it looks neater. 

Most languages have decided that exception specifications are a bad idea. In Java they devolve (over time) to throw Exception and in C++ the only useful one we found was the specification that said this function does not throw. 

On startup a lot of the code is there to deal with making sure that threads don't start work until the SimpleWorkQueue object is correctly initialized. This work is not related to the work queue and should be factored out into its own class. The concept of a barrier was mentioned in the question comments. So here it is. A barrier is a thread concept that blocks all threads that until the specified number of threads have all arrived then they are all released simultaneously. This is often used for synchronization. A simple Barrier 

Here $(TARGET) will expand first (to CLIENT or what is set on the command line) and then $(CLIENT_NAME_DIR) will be expanded. So you end up with only a few variables specific to the Client/Server and all the other variables are generalized based on that. The same then applies to all your build rules which can be collapsed down into one set of commands (rather than two).