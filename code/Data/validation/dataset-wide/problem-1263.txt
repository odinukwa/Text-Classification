I don't agree with the explanation you've provided inside the file that naming those numbers and calculating them would be messy - it's exactly the opposite. I, for one, don't find the explanation given in this file satisfactory - it's not always clear to me what they mean and how they've been derived. You should avoid situation in which someone has to read the code and try to figure out the meaning of the values. The less time spent on understanding the code the better. I'd say it's generally dangerous to assume that something is obvious or needs no explanation "if you know the structure" - it's always trivial to the person developing the code and not so trivial for people trying to understand your way of doing things, including you from the future. Also the idea of giving people hints in the comments regarding where to look for the explanation is fragile. It's very likely that you restructure your code in the future and forget to change comments like this. Besides I had to read all the code to get to this comment, and how would I know looking at only part of your project that there is this one comment in this one file that explains the numbers used in several other files? Prefer return value over output parameter This function: 

See this link for further information on this topic. Also, there are some benchamrks backing up this approach on SO, e.g. here. Usually you don't have to care about the performance of I/O streams that much, but several times this trick helped me get to the top of the shortest execution times in coding exercises like this. Also it does make a difference if you are printing thousand of lines. Don't use using-directive file-wide It's considered a bad practice to put e.g. on top of the file as it may introduce subtle bugs when you use functions of the same name coming from different namespaces - it also requires manual checking to see from which namespace a particular function comes. It's not a problem in a simple program like that of course, but it's good to nurture good habits. Put your code into proper function Again, maybe you know it and it's just because this program is just a small competitive programming task, but usually you want to put your code inside a function of proper name, avoiding putting too much bare code inside . Make variables that are not to be mutated const and are set once and never changed. Making them would prevent you from accidentally mutating them while you expect them to hold their value. It also shows their role in the code better. 

Use enum class instead of raw integers for the variable within the function since now it's not immediately clear what option each case refers to. Also it reduces the risk of error and makes input sanitizing easier as by using enums you are constraining the range of values passed to the function. Also see the point mentioning magic numbers. Don't put your functions/classes/variables etc. within the global namespace. Create your own and put them inside to avoid possible name clashes. Namespaces are also important if you are using templates heavily (you don't right now, but it's yet another reason to make it a habit to use your own namespace). You are using a lot of magic numbers that make it harder to understand the code, for example: 

In general this code looks nice, it's easy to read and understand, except for a few things. Eliminate magic numbers The one thing that strikes me the most is that you are using magic numbers a lot. Use descriptive variable names instead as it makes your code hard to understand in some places, e.g. here: 

the names of the variables and start with a capital 'I', whereas it is a common practice to start the name of a class with the capital letters and start variable names with a lowercase. You are also following this convention correctly throughout your code, except in this part. Const correctness You don't always adhere to the concept of const correctness: your operators don't modify the argument and thus it should be passed as a const reference to avoid unnecessary copies and make room for possible compiler optimizations. Code lines' length In some places in your code, you are writing very long lines, such as: 

You are mixing responsibilities within your functions. Almost all your functions handle user interaction, operation on files and internal program logic in the same time, whereas their names suggest that they handle only one of these things (and in fact they should handle only one of them). For example, looking at the signature of the function most people would expect that it takes the directory name and returns it as string, but this function, apart from doing what the name suggests, also has some unexpected side effect, which is creating a file and writing to it. The code related to file handling should be moved to a separate function - that way not only is your program structure cleaner and easier to debug, but it's easy to imagine that you may want to reuse the function that writes text to a file later in various contexts. Also, if you realise that your approach towards file handling needs improvement, you won't have to correct your code in multiple places, which makes the code easier to manage. The previous point leads to a conclusion that you should separate functions responsible for user interaction from functions handling internal program logic. Apart from easier code management and development, this makes your program more versatile, enabling you to use it with different libraries. Why not name , and in a way that explains their context, e.g. , , ? That way you don't have to explain it in the comments, and it's instantly clear what they are for when someone sees them used in the code, whereas right now it's necessary to go to their declaration and read the comments. Use clearer function names. For example, ideally it should be clear what the function does just by reading its name, and I don't know if "give" in this context is about writing the report to a file, printing it to console or saving it to some variable to be used further within the program. The comment above the function doesn't explain it either. Group your headers with respect to the functionality they refer to - it's easier to identify unused dependencies that way. If you have headers placed in no particular order, it's easy to just forget about one that you don't use as it "blends in". It's also clearer that way which libraries you use for a particular feature. Make the functions as stand-alone as possible. Right now you are making assumptions within function bodies about the activites performed before the function was called - it is best avoided. For instance, some of your functions begin with the line as they assume someone had hit "enter" after providing some input and before they were called. It's not these functions' responsibility to care about this - the function using for input earlier should clean after itself with that line. By composing functions the way you do now, you are significantly limiting the context in which they can be used - what if you change your program flow and decide to use some of them before the user enters some input? What if you decide to read the input with instead of ? The input becomes corrupted as would "eat" one character. This opens many possibilites for hard-to-track bugs. 

It is a good practice to use a named variable instead, whose name would explain what this value is. It's also good to comment why this particular value has been chosen if the name itself can't explain it fully. 

you are restricting the use of your class to console applications. Things such as text display should be moved outside of your class as the responsibility of your class is to calculate numbers, not display them nor interact with a user via an interface. Unclear variable names Tha name is very vague and it's necessary to read the code to see what it's supposed to do (assuming it is used in the intended way). I'm not sure what is its purpose anyway since it's only set and not referred to anywhere in the code. I also suspect it shouldn't be a static variable. Organizing code into headers and implementation files Don't put all your code within your main.cpp file. It's more versatile and easier to manage if you separate it and put declarations in headers and definitions in .cpp files - you'll see that as soon as you decide to separate the text display functionality mentioned above from your main class. Inconsistent and uncommon naming convention Here: 

Even though most modern IDE's have built-in line wrapping, it's a good practice to write your code in such a way that a single line comprises approximately 80 characters. It's more comfortable and faster to read and comprehend the code if you are not forced to scroll it or move your eyeballs repeatedly from one side of a wide screen to another. Also that way you have control over where you wrap your code, whereas line wrapper functionality may visually organize the code in a way that makes it less readable. Also it's easier to use diff tools and open several editor windows side-by-side if you stick to this rule. See the discussion e.g. here: $URL$ Redundant variables It seems you are not using anywhere in your code right now and even if you do use it in the future, it is probably to serve exactly the same puropse as , so it's better to convert one type to another instead of keeping both and using only one of them depending on what's passed to the constructor - right now you would have to double your code by checking which variable is set inside each of your functions. I would ditch vnum and use snum everywhere instead as is a semantic equivalent of , except you can benefit from small string optimization. 

Apart from what the others have already said, it's a bad idea to return a non-const pointer via the method as it breaks encapsulation - it's unclear now who owns the object and who should free the buffer memory. If you check how it's done in , you'll see that and methods that are more or less equivalent to your both return . C++ designers some years ago actually made a mistake of returning a non-const from the class. See here why it resulted in this class now being deprecated: $URL$ 

should return instead of taking it by parameter. That way it's more obvious what it does. It's also easier to use, since you can write a one-liner initializing it: 

I don't see how this could benefit from C++11/14 techniques much - modern C++ gives you more tools mainly in terms of template metaprogramming, container algorithms, functional programming etc. You are dealing solely with primitive types and operate on streams, and newer standards haven't brought a revolution to these areas. The code is clean, variables have proper names etc, and that's why I'll stick to some general remarks. Optimize I/O streams usage Since you may possibly print a lot of information to , it might be a good idea to decouple it from the C streams. Synchronizing with C streams is associated with a significant performance hit, but necessary if you try to write to the stream concurrently or mix C and C++ streams - you are not doing any of these things though, so it's safe to do this at the start of your program: