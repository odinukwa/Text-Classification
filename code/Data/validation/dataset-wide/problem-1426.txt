But the starting tree height is 1 no matter whether the cycle count is 0 or not, right? So we can move that outside the statement. And once we do, immediately it becomes clear the statement doesn't need to be there at all. If the cycle count is 0, then the loop will never be executed and you'll stay with the default value of 1, which is what you want. There's a bit more inconsistency here too. Like you needlessly call on an integer, and in once place you assign it to a variable with another name (), and in another place you keep it as . This may be left over detritus if you refactored from passing in as an array of strings. Extract one more method At this point, you could happily stop and you'll have a nice piece of code. But there's one more thing that may be an improvement. This: 

Note that I renamed to , since that's what it is. Now we've found the desired , and we know that to do with it: 

And finally... From that last version, you can see that once we've made these changes, there's no need to have an abstract class anymore. We're left with just signatures, so we can change to an interface. This also means we can consider not writing at all and using a mocking library instead. 

Other than the above alternatives, your code mostly looks good. One thing I'd do is scrap the variable, and return directly from inside your statements. The prefixes are also unnecessary for PascalCased method names. 

One thing this doesn't address is the leading zero for minutes < 10, but this can very easily be done in a few extra lines. It's hard to do a line-by-line comparison of this to your version, because it's quite structurally different, but the key is to see how we've separated out each individual question we need answered into its own piece of code, and decoupled those questions from each other. We don't do a check like: 

The first has a little more to it. I think it's worth special-casing the situation where everyone can fit on the rollercoaster: 

In C#, in general you should use these kinds of enumerable-manipulating methods (found in the namespace) instead of loops as your first port of call. They usually lead to terser, easier to read code. Only occasionally are loops easier to read. 

Here, success and failure value are the values of the products you get for each result, and is the probability of failure. Note that this is something that depends only on features of a single level. So you can calculate individually for each level whether or not to use the crystals. Putting it together So putting that together, can have a method which uses the above formula to determine whether or not it should use Crystals, then an method, which would be a simple calculation of the expected profit including both success and failure possibilities, along the lines of the one you do in your code. With that, all you need to do is construct the instances for each level of your item- or items of interest, and then the rest is extremely simple. If you wanted to know the total expected profit upgrading to your highest level, you could just use a loop (or stream function) to total up the average profit at each level. If you wanted to know the optimal level to stop upgrading, it wouldn't be much harder. (As a side-note, one assumption I've made is that you can buy and sell items at any upgrade level, and that the level will be reflected in the price. I don't think much of what I've said would be very significantly different if that wasn't the case, but there would be some alterations) 

There's probably a lot more things to point out, and I'm sure other answers will. However from my perspective, these are the two key high-level concepts that will help you progress at this point. 

The first simplification is for the check. All you need to do here is check that the value is not null, you don't care about the type. Then you can do the type-specific check later. So remove the outermost and simply have: 

For an example of how you might use some validation with this class, consider adding the rule that the salary must be non-negative. You can do this by altering the property like so: 

Shouldn't this be the version, rather than the one? At least you can take comfort that this bug is a demonstration of one of the advantages of the strong-typedness that you get from the generic approach! 

The decorator pattern has opinions about almost all of those questions (and probably more I haven't thought of!), whereas writing a minimal implementation, decoupled from any interface like does not. That's adherence to OCP- writing code that won't have to change no matter what the answers to those above questions turn out to be. Pulling it together At some point, you will have to write code that handles all the responsibilities associated with reading code files. Hopefully the examples in the previous section have convinced you that trying to come up with a design which can handle arbitrary changes in responsibilities is impossible. But by having a design that: 

That's not a full example, but it'll be refined later. Hopefully you can see how this has now separated out different responsibilities into their own classes. From your mention of in a comment, I assume you're using Entity Framework. EF actually already provides you with a class that will serve the purpose here, which is . You should be able to get that from your . That class will handle operations like Delete for you. So in fact the only class from the above example that you actually need is the class. (As a side note, this is an implementation of what's called the 'repository pattern'. If you look this up, you'll see it's often recommended that even when using Entity Framework, you add your own repository class on top- in the above example. I wouldn't worry about that at the moment, it adds another layer of abstraction which can be valuable in some cases, but don't do it without understanding why. It's more important to get the basics in place.) So finally coming to whether and are redundant. Yes, they are. Once you remove the persistence logic from both of them as described above, you're left with nothing but a property bag which is identical for both of them. You should delete , and push down into your data layer. In fact, in large solution you could push futher- have a "Core" project referenced by both the UI and Data projects which contains your domain objects like User. Data would then reference Core, and UI would reference both Data and Core. In your case, actually structuring your solution like this is likely to be unnecessary, but it's a good way to think about it conceptually. So, finally, with all of the above applied your code might look something like this (again this is omitting some details like construction, just leaving you with the key bits): 

Allowing you to completely remove your s (they're also used in , but I'll go into that later) Creating s There are a number of issues with how you create jobs: 

Note that this does have a potential performance overhead, so you should check anywhere that is being used in a tight loop (which will generally be if it's being sorted). One potential performance improvement- if the , and are immutable- would be to store the tuple in a private field so it does not need to be regenerated each time. 

For , you're again increasing the complexity by completely changing your data type, from a list of factors, to a map of factors to the count of those factors. This isn't actually that hard. For a single number n it might look like: 

Only if this presents a noticeable performance issue should you worry about trying to implement your own- premature optimization is still premature optimization even inside a method! 

And here's the initial shift in perspective: don't call that a partially-implemented . Call it a fully implemented . So what does that achieve? Well, it means the class you just wrote is definitely going to adhere to the OCP- you can be as confident as it's ever reasonable to expect to be that you're not going to have to go in and change- or even decorate- that class. Fine. But it also seems like an exercise in rug-sweeping: what happens when you need some code somewhere to handle additional responsibilities relating to reading code files? Well, here's where the second perspective shift comes in. You should not be trying to create a high-level design in advance to meet all possible future requirements. As an example, let's take the again. Now imagine I gave you the following new requirement: 

This is somewhat a matter of taste, but I know I'm not the only one. Generally I'd only put both parts in-line without braces if they're both very short. Putting the statement on a new line without braces is generally considered poor practice so I won't recommend it, though it is actually my favourite in terms of readability alone. So two remaining options are: 

However, this method actually uses tail-call recursion, meaning that if it ever performs a recursive call, that is always the last operation it performs. For this reason, if the language supported tail call recursion optimization, a stack overflow exception could be prevented by moving down by one stack frame before entering the recursive call. (Alternatively, it could be converted into a loop, but I won't be worrying about that) While this is not supported by C# (see below), a method that uses tail-call recursion can use a construct called a "trampoline" to run a recursive method without growing the stack. My aim was to create a trampoline which: 

I added some formatting to that nested ternery to try to understand what it's doing, and it still took me a while! 

This isn't very easy to do neatly. As you've seen, if you pass the into your repository, then mocking the just for querying is a bit nasty, and you'll run into further problems if you want to mock the context to check if is called. I'm not fully up on how people tend to deal with this, but one strategy might be to define an interface like: 

If the answer to question 1 is no, then you're done. A nice simple design along the lines of the previous outline will be fine, and anything much more will be needless complexity. If the answer is yes, then the second question becomes relevant. So a focus for the rest of the review will be ensuring the answer to that second question is no. Adding a success threshold and subsequent refactoring One difference between this implementation and the description in the article is that in this version, the circuit breaker can only ever stay in the half-open state for one execution. If that execution is successful, it moves to closed, otherwise it moves to open. In the article, the transition from half-open to closed has a success threshold just like the transition from closed to open has a failure threshold. This is something that really should be in the design, in addition to being an illustrative driving example for refactoring. So how would this be done with the current design? We'd have to add three members to the interface: , , . Then we'd have to update the circuit breaker concrete classes- or potentially a base class if we had one- to implement them, as well as the private backing field. And the only class that will actually want to use this isn't the circuit breaker itself but the . This smells of feature envy. A good option is the usual one for feature envy: move the members that only particular states care about out of the interface to the state class. So let's go through the interface members one by one and see what can be done with them: 

Depending on your wider design, this might be enough. However, since you asked about extensibility, you can see that having to build predicates isn't the nicest business. For example, you had your 'less than 8' predicate. What if elsewhere in the code you wanted 'less than 7'? You'd have to repeat the (albeit very simple in this example) logic, just with a different number. If you tried to refactor this to adhere to the Don't Repeat Yourself principle, you might then end up with something like a class which exists purely to build common predicates based on parameters. But this isn't fantastic design either. It would likely end up as a monolith of public methods without much cohesion, and violate the open/closed and single responsibility principle. A better option might be to create an interface like: 

In fact, at this point the exception type is really just a particular piece of human-readable information, and the stack trace is just further information about where the problem occurred. So really, all three are the same thing- diagnostic information for the person who has to come along and understand what went wrong. So here, the purpose of wrapping an exception is to provide better diagnostic information. Maybe there's some variable which is likely to be relevant to trying to work out what happened. Specifying a specific type of exception could give important information too (knowing, for example, that the problem arose from the database). With this in mind, let's compare the two exceptions in your example: 

Equals You have a bit of repetition between your methods. Since no instance is equal to , you can replace your entire overridden method with: 

A note on OO One last thing, since I noticed a few other answers mentioning taking a more OO approach, I'm going to disagree. In my opinion one of the best ways to make sure you misunderstand OO is to apply it where it's not appropriate. Here your entire application is concerned with input/output to the console, the only real behaviour it has other than UI concerns is a single very simple calculation and a greater than check. Trying to "object-orient" that is much more likely to baffle than teach. Understanding OO is a very important part in becoming a proficient Java programmer, but I'd say that you definitely took the right approach keeping this particular program procedural. 

Another point for your original code is naming. Your instincts are good in that you're allowing your names to be as long as they need to be for descriptiveness. However, names shouldn't actually say more than is appropriate for the context.