If you want a product id to return a list of products use a non-zero id. For delete, return an error status status on zero the same as if it were an invalid product id. 

I will address your question on the . Which is now moot because it never should have existed at that point. The short answer on removing the unset is the unset destroys the variable $iii if the unset are both in global scope. If this were an include called from a function and $iii was not declared locally to the function, then it will be locally destroyed but not globally destroyed. No matter what, you should not have unset it. Especially as you are using it in the next routine. How a variable is destroyed is a compiler decision. Sometimes the value is set to NULL, most times the allocated memory for that variable is freed to be reallocated for other use. Even if you were not going to use it again you still should not have used . Because it is an integer uses minimum memory space, the CPU cycles use to destroy it would be a waste of resources. A well designed, compiler would ignore your unset. Because PHP is an interpreter and not compiler it does not have the luxury of doing iterative optimization parsing as a compiler. The question that comes to mind; Is your first and the used after using the same physical memory location? Probably not. But when you remove the unset it will undoubtedly remain the same. Your $retval (most PHP programmers use $result) should be "unset" if it is considerable in size. When a variable is large enough to consume RAM that may be needed before the end of script execution, it should be unset, except in the case of mysqli_query Result instead use . When and When Not to use unset When and When Not to use is not always an easy decision. Static variables are where the data type and amount of memory required remains constant throughout its use. This also means the amount of physical memory allocated and it location (physical RAM address) remain constant. Where in physical memory it is stored depends largely on scope. There are languages that require the number of elements and data type of the array's elements, and maximum string size be fixed throughout their use. Many, if not most, languages do not allow type conversion of variables. There are very valid reasons for doing it this way. PHP is very flexible with arrays and variables allowing the executing code to change the the size and data type of variables. There are performance penalties for doing it this way. The other factor is scope. Why scope is important goes beyond knowing where the variable's value is valid. It also has an major impact on performance and memory usage, particularly the read and write. Allocation of memory, static vs. dynamic, and scope go hand in hand. In general terms, global scope the variable is declared and its value can be used and its value changed anywhere in the application. Module variables are defined to be used in a subset of procedures and functions. And local scope that are only valid with in user defined functions / procedures and their subroutines. The way current Intel processors work is they have separate memory pages for instructions and data in the cache memory. Cache is where you want your variables to reside. The only better storage location would be in one of the processor's registers, but that is a decision for the compiler. Compilers may store a copy of the loop variable ($jjj) in a register and then write its value back to it memory location at the end of the loop. (reason loop is faster than in PHP) Use local variables rather than global where possible. If you keep your local variable storage requirements small and well organized you stand a good chance of all your data residing in L1 cache. Same applies to the number of machine instructions required for your executing code. Declare all variables, by data type and size, before the code. Using unset() and declaring new variables within the code will fragment memory. As an example of good memory organization and allocation, I declared as a 32 byte string. and as 16 byte string. If I thought a field name would be longer than 16 characters I would have declared it as 32 byte. On the extreme side but efficient. Going even further, I could have used the results from and initialized to the type and size or the columns using $col instead, . It is a good idea for programmers to understand the basics of microprocessor design. Especially the instruction pipeline, cache, and microcode execution. It's all in Intel's 64 and IA-32 Architectures Optimization Reference Manual: Intel's 64 and IA-32 Architectures Optimization Reference Manual I recommend Chapter 3 and all "User/Source Coding" Rules. 

in this case and out only parameters. and you need say to caller - which api need use for free returned buffer. 

interface of course also must be absolute another. here faster need export class with virtual functions. class implement cmd exec and write commands to it. virtual callbacks with read data from cmd. you inherit own class from this base interface class, implement your own on read data handler and cmd exit (disconect). some basic implementation of class: 

ansi function usage. such as CreateProcessA this is very bad. windows is unicode (utf-8) system. almost all api implemented as unicode. the ansi (A) api - is shell over unicode (W) api. the A shell convert input ansi strings to unicode, call W api and finally convert out unicode strings to ansi. this is very not efficient. more bad that use ansi strings simply wrong by design. ansi code page is not invariant. it different on different systems. if you hardcode some ansi string in code, which use characters > 0x80 - you got different unicode strings after convert, on different systems. finally not any unicode string can be converted to the current ansi code page. use ansi code page for cmd is wrong. cmd use for pipe input/output not ansi but oem code page. this is different code pages. when cmd read multi-byte string from stdin file - he convert it to unicode via with . and when he output something to stdout file - he translate unicode string to multi-byte via with . so until he output characters in range you not view different. but if will be say "not english" file name in output, or you pass some command with "not english" file name - will be error - because you and cmd use different code pages for translation. you pass him ansi but he wait oem. he pass to you oem strings, but you wait ansi. also note about inherited handles - begin from vista better use also with for restrict list of handles to be inherited by the child process - not all inheritable handles, but only one pipe handle. yes one but not two as you use. 

While the arrays may appear to be a lot of overhead, the processing is so much more efficient. When the arrays are local and somewhat small the data is in L1 cache of the microprocessor. The L1 cache of an Intel i7 is 32KB Data and 32KB instruction. If the data is less than 32KB then it will reside in L1 cache. Data access should be grouped together. Data writes should be segregated from data fetch. Data access should be segregated from computational code. Processor branch prediction is an important consideration for efficiency. In my code I use the structure 

Takes the expanded section and puts it at the top of the Browser window. When all are contracted, it scrolls to the very top or the page. The reason I use an array for the toggle is to eliminate the else if that would otherwise be required. 

The point: Branching, as in if else, is very inefficient. It helps to understand how the micro-processor's microcode and instruction execution blocks function. All programmers should be familiar with Intel's 64 and IA-32 Architectures Optimization Reference Manual at this link: Intel 64 and IA-32 Architectures Optimization Reference Manual This is mostly for compiler programmers but there are many optimizations for other programmers in their "User/Source Coding Rules" The most important Source coding rules pertain to Branching (if else), Loops (while), and variable declaration and organization. You don't have to read all 642 pages. At a minimum read Chapter 3 

Check validity of all passed parameters. Then determine the best, most specific and user friendly response. The best user response is to fix the error when possible. If a parameter is missing, add a default. If you had an HTML error on your web page, do you expect it to render? Would you like it if a single HTML error returned a 404 response? If a Browser was that rigid it may not get much use, same goes for your API. 404 is not an appropriate response when the document URL (index.php) is correct. Additionally this will confuse some users as to why. They may just think your server is down and they go somewhere else. Consider using an alternate response such as 409. You want to make it as easily as possible for the user to understand what their mistake was. 404 should be reserved for an error in the URL Also for diagnostic and support issues, use various response codes for different issues and document them for the user. You could use a text header and a message identifying the specifics problem with an error message. 

then look for (full nightmare) ; you all time read to to buffer begin () and never change . so what sense try reallocate buffer if you any way try read only bytes. then you all time read to buffer begin - so new read overwrite previous data. you use wrong and senseless , , instead of . for what you use before ? when you try reallocate buffer after every read ? even if still exist free space in current buffer ? on which size you try realloc buffer ? on 1 byte ?? and every time anyway try read constant to begin ?? for dynamic buffer buffer usually used 2 strategy: allocate memory chunk (usually 0x1000..0x10000 size). read to this chunk until exist free space in it (of course not all time to the begin of chunk but to the begin of free space inside chunk). when no more free space in current chunk - allocate new chunk (not reallocate existing !!) and so on. but not copy anything. when read will be completed - once allocate new buffer and once copy content of chunks to this buffer. for example. 

if buffer not big enough - error is returned - (in case no valid data in buffer at all) or - in case exist some valid data in buffer, but need large buffer anyway. anyway you need here additional out parameter allocate buffer yourself 

then reallocate caller supplied buffer - this is very bad idea. for reallocate you need exactly know how caller allocate buffer. you must add to interface contract - how caller must allocate initial buffer and free final. which concrete routine use. say for example caller must allocate initial buffer with and free with . but nobody do this. usual used 2 ways: 

here - in/out parameter, but in only - if you reallocate user buffer - you must return new buffer size to user. may be next signature: 

another way - use for buffer. windows let reserve memory space. we can reserve tens of megabytes how minimum. this operation not allocate any memory but simply mark memory region as reserved. then we can already commit memory to region begin. when, after read, will be not enough committed memory - we commit more and so on. advantage - we from begin will be have contiguous memory - we never will be need copy/move/reallocate memory with this way. this solution is better when we assume big enough final data. example: 

This is easier on the memory allocation, memory bus I/O, and retyping a variable from string to array. 

Create a product with a product id of zero with a description of 'Invalid Product ID" and process it just like a valid product or process the same as an invalid product id number. 

While on the subject of parameters I would suggest using integer parameters over string whenever possible. Integer is compact keeping down the Request Header size, is the easiest to validate, and makes comparison functions faster. Example: On a string true false parameter , no need to do it's not there it's zero. And it resolves typing between numeric 1 and string '1' when it is used as an array dimension. Instead of this: 

Because the day of the month is no an issue I used 13. Not that it would but in dates the month and day can cause problems. By using a day of 13 it cannot be confused with a month. If a date were entered as 13/4/2015, it would not be difficult to understand 13 is a day and 4 is a month. Oct, Nov, Dec would still be ambiguous if entered as 10, 11, or 12. 

I would make the code function correctly within the definition of the rules. Although I would expand on it. I would NOT use the Request Method to determine any functionality. The API should be architected where GET and POST Types can be used interchangeably. I would NEVER use them to select view, save, delete. 

Takes the expanded section and puts it at the top of the Browser window. When all are contracted, it scrolls to the very top or the page. The reason I use an array for the toggle is to eliminate the else if that would otherwise be required. 

UPDATE After further review of your code, delay is likely in the . That is where I'd look first. For purposes of locating the delay, bypass . You could hard code the device name and to run the code without getting the list. And / or when making your list of ports, save the time it takes for each iteration of the loop. Associate the times with the port name. You may have a port(s) with a long timeout introducing the delay. You may want to add port status to the list of PORT_SERIAL ports including open/available, DSR and CTS. About the Flow control in my previous post. I did not see anywhere in your code you turn off hardware hand shaking . What is your flow control? Even when Hardware Handshaking is not used by the device most PC's still support it. The reason I suggested what I did is because I was thinking the delay was likely a hardware/firmware port setup issue or a client initialization issue. The serial port must still have the hardware handshaking disabled (not recommended for diagnostic purposes) or have the signals driven active in order for the UART to work.