Your method works, but it's not really concurrent. As Forsvarir mentioned, there are different approaches to the critical section problem in concurrent programming. Pick one and implement it. As for the use of , your host environment determines whether you should use it. See the note on the reference page: 

Initialize variables as you need them. C++ does not impose the same restrictions as C89 did. You can avoid two-step initialization by passing the file you want to open to the constructor. 

Do not abuse directives and declarations. Importing everything from a namespace into the global namespace causes pollution which could result in name collisions and ambiguity for the compiler (an imported function is found to be more viable even if not correct). 

Doesn't make any changes to the itself, consider -correctness. If the denominator ever became negative, do you plan on simplifying (normalizing) the sign to the numerator? 

Again, polluting the global namespace. You can avoid many common errors by not importing the entire standard namespace and just qualify your types/functions with . 

In the event of a item with a duplicate code, the new entry is simply discarded. Perhaps it would be better to merge the two records? 

Don't say in comments what can be clearly stated in code. Compilers don't read comments. Comments are often less precise than code. Comments are not updated as often as code. A pure abstract class has only abstract member functions and is intended to define an interface to be inherited by concrete classes. A way of forcing a contract between the class designer and users of that class as the users of the class must declare matching member functions for the class in order to compile. has both concrete member functions and data, which implies the class is an implementation and not an interface. 

Does case-sensitivity have anything to do with your stated goals of calculating and serializing the frequency of characters? It depends on the context in which this function is used. Case-sensitivity isn't always required. If you really want to provide a mechanism for case-insensitive frequency generation, consider a toggle parameter or another function that transforms the input then calls this function. 

Always ensure that the allocation functions and friends succeed. These functions return a pointer when they are unable to allocate memory. If the environment isn't configured to guard/crash when fails, then you have a bunch of pointer dereferences causing undefined behavior. 

Be aware that including in your headers may transparently inject a static constructor into every translation unit that includes it. This is very common in C++ implementations. 

Package meaningful operations as carefully named functions. Code becomes more readable, more likely to be reused, and be easier to test. Your functions essentially search (by value or index) then insert (after node). Return the correct types. C++ has the for returning or . attempts to cast an to whatever is, which could fail. If you need to return to the callee the state, consider an enumeration or one of the error reporting strategies listed below. Check to make sure your preconditions are not violated. Should the default behavior for passing an out-of-range index into (either too large or negative), result in a new node being appended to the end? 

If you pass zero arguments, nothing is evaluated. If you pass in arguments, they are each forwarded to the single argument helper. You should be aware of the following with this method: 

Don't just name the guard after the filename. Append differentiators (file path, GUID, date, etc) to minimize the chance of collision. An example 

For input parameters that aren't modified, only pass cheaply-copied types (2-3 Bytes) by value. Pass anything else by reference to . There are exceptions (sink or copy required params). 

Stacks only provide access to the last element inserted, so a function that displays the content of the stack is unnecessary. If you need to verify data is being entered and stored correctly, use testing and a debugger. Be aware that statically initializes the standard streams (, , ). Rather than directly including in headers and incurring the initialization costs on users. Consider including and pass streams through referencing parameters. Be aware that 

Prefer as it's self-documenting and will appropriately use bulk copy instructions like / instead of multiple individual assignments. 

Note: The third parameter in the detail functions utilizes integral types for priority tag dispatching. 

Functions that are short, simple, and focused on a single logical operation are easier to understand, test, and reuse. Your program already indicates these logical boundaries (, ), you just need to refactor your code into those abstractions. The C++ standard library comes with some nice abstractions (see ) that you can use as building blocks for more powerful functions. 

That's fine. I was just pointing out how to use the adaptor pattern. In my example, I could use any container with , , etc (like plf::list). 

Use RAII to encapsulate your resources into objects that enforce the create/destroy pairing. You can write your own RAII wrapper objects or (better) use a resource factory that creates /'s. A concrete factory for arbitrary SDL resources: 

Your function is just a reimplementation of . Make sure you include everything (missing ). Assert liberally. See the CPPCoreGuidelines. 

Smart pointers are fine for ownership, but do you really need a to represent its structure? coupled with a non-owning pointer (raw pointer, C++17s ) can represent the ownership abstraction for a doubly linked list. Be aware of how smart pointers behave with the compiler generated operations. With , the destructor recurses \$O(n)\$, which could consume the entire stack. 

Requires a single-pass algorithm. Single pass algorithms have special rules associated with them, like only accessing the current element once and only moving forward. Your implementation exhibits multi-pass behavior. 

Don't repeat yourself. You have some duplication in the digit check between the first character and the rest of the string. may have null characters embedded in its contents. Unless you intend to read up to the first encountered null character, prefer to use the / member function. 

Prefer high-level abstractions over low-level handcrafted code Functions that try to do too much often become hard to read, extend, test, and debug. Functions should be focused and short. An easy way to tell whether or not you should refactor your code into smaller functions is the "And"-test. Describe what your function does. If your descriptions uses and, then you should consider splitting the function into its parts. For your selection sort, you would describe it by: 

Prefer to avoid redundant repetition of type names. In generic programming, prefer non-member functions to member functions. Member functions and are fine when you have container types that adhere to the standard. Some containers just don't provide those facilities (like C-Arrays). C++ provides non-member and to help with language container types. To support user container types with non-member /, ADL can be used. 

If you explicitly define any of the special member functions for a class, you must define them all. The following five are considered special member functions. (see Rule of Zero/Three/Five) 

Note: While the concept of is being added to the standard in C++17, a isn't being added. Dispatching on will use the optimized call to the contiguous operations of for all random access containers except . is not guaranteed to be contiguous and would fall back to copying by element. 

The SFINAE maybe be cleaned up by using some existing traits. (c++17) is a shorthand helper variable template. For the invoke-able return type, rather than working through values and expressions, you can use only the types through (c++11). It also has a helper type of (c++14). Note - was deprecated in March's Kona meeting, so you'll need to use the less fragile version (c++17) once P0604R0 is implemented into Clang. 

Some algorithm comments. Your Fibonacci table is incorrect. See wikipedia. \$F_0 = 0\$. While it actually doesn't affect the solution, it is just a minor detail that should be corrected. Even Fibonacci numbers have their own recurrence relation if you only care about the even values. From the definition of the Fibonacci sequence, we know 

Defining the interface is the most important step when designing a function. Doing things that are different or surprising will confuse and annoy users of your functions. The name of the function doesn't match what going on in the body of the function. Copy is a non-destructive action on the source. When you copy one item, you have two of that item. What you are actually doing is copying a subrange then destroying the subrange source (effectively moving the subrange). Whenever you are writing functions, prefer to write parameters in the order that replicates similar functions from that language's standard library. Most users of your code are more than often going to use standard library code than handwritten code. Having to deal with alternating order of parameters is annoying if your function wants destination before source in the arguments while the majority of code is using source before destination. What does really represent? Semantically it refers to any type . As a user, I would have to look into your implementation and dig through the documentation to figure out what exactly represents. Be explicit. Expecting a container type? Call it (or if your coding standard allows localized shortened variables). Specify immutable variables with (or for literal types). Must the types for and really be the same type? Perhaps it would be better to loosen that restriction to the underlying types being convertible. Your return type narrowly converts from to . 

The general advice is to avoid defining any of the special member functions if you can (rule of zero). If you need to define any of the special member functions, then , , or provide a user definition for them all (rule of five). 

For potentially expensive to copy parameters like , prefer to pass them by reference (to if immutable). Be consistent with your spacing, i.e. vs . 

Organize your includes. On a small project like this, it's really easy to make sure you've included everything you want. On a project that has 30+ includes from various sources (STL, Boost, LLVM, your own stuff, etc), it will be difficult to make sure you've included everything and there are no side-effects like cascading dependencies. You should order your includes by reliability of source then name.