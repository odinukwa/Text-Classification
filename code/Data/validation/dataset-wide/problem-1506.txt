Given a boolean 3D matrix and a set of actions specifying bit flips at certain positions, a set of resulting matrices can be obtained, one matrix for each action, as if executing each bit flip individually. A statistic (feature representation) defined on a matrix which for each row, column and depth counts the number of active bits at the same depth within some hexagonal distance in the first two dimensions of that row and column. What's the fastest way of getting such a statistic for each of the resulting matrices (afterstates), given the previously mentioned original matrix (grid) and actions (, and )? For example, given , , the first afterstate of can be obtained by . Actions are guaranteed to be bit flips. If the feature representation for is known, the feature representation for can be derived and need not be found from scratch. In the code below, the naive approach () and an incremental approach () are given. The naive approach should be easiest to understand. This is the hot hot hot path of my system and I want to make it faster, but I'm no speed demon. Any tips and comments on anything else, small or large, is also appreciated. Below the code is some background which is not required reading but may make things more concrete. 

On surface it's a well laid out code with bunch of helpful comments and good method names. However, looking deeper the data model of this game looks rather odd. Instead of storing the game state in a simple 2D array as such: 

Then produce HTML Normally one would now transform this list of tokens into a tree structure, but as the BBCode-to-HTML conversion is very one-to-one, we don't really need to, and can pass the list of tokens directly to another function that converts it to HTML: 

Usually the first approach is better and requires no extra tooling. If you decide to go the mocking route, my personal choice is the rewire library, of which there exist various versions for various environments (e.g. for Babel). Regarding specific tests Avoid temporary variables when you can write the values inline. Instead of: 

This algorithm sorts a list of Individuals, each with two fitness values, into what's called non-dominated fronts. A non-dominated front is a set of individuals where none of the individuals dominate each other. An individual is said to dominate another if is equal or lower (<=) for all fitness values and lower (<) in at least one fitness value. And so dominates both and , but neither of the last two dominate each other. The rank of an individual indicates which front it is a member of. would have rank 0; and would both have rank 1. Non-dominant sorting is a small piece in bigger puzzles such as multi-objective optimization with genetic algorithms. If you are interested in how the algorithm works you can check out Jensen 2003, but I'm completely new to Haskell so I'm sure there's a lot to pick on without understanding squat about the actual algorithm. Here it goes: RankSort.hs 

Your sorting of cards to buckets takes a lot of code, which is because the names of your buckets don't match with the names of cards. The cards have just numeric values (10, 11), while buckets are named with words (ten_bucket, j_bucket). I would represent the cards as such: 

First off the code is hard to make sense of, because I only see part of it. Most importantly I don't have the source for SessionsStruction class, which you are extending, and the name "Struction" doesn't make any sense to me (is it even in dictionary?). It would also help to have a code sample of using this class. The class also has no documentation describing its purpose - and after reading it all, I'm still wondering what's this all about. Some immediate problems I see with this class: 

The code below is the core of a Genetic Algorithm (NSGA-II to be precise, without crowding-distance calculation), but I've taken out all the GA-specific parts and made a generic example. I think I've carried over most of the principles/'constraints' from the original algorithm, but I might have missed something. As you can see in , I need to convert a nested list (2-dimensional) to a flat list pretty often and I'm curious of if there are any better ways to do it. I've added some so that it's easier to follow the size and type (nested or flat) of the lists. Since expected size of input is m=100 individuals () for 500 generations (loops), speed is important. Memory usage is not that important (although knowing how to reduce it would be interesting), but execution time is. Any comments performance-related or otherwise are appreciated. 

I am trying to represent questions in quizzes. The database is Mysql but I am using fairly generic sql. The assumption is that varchar cannot handle more than 255 though, so I am supporting longer text by having multiple text components. There are four primitive kinds of questions: multiple choice, multiple answer, fill in the blank, and editText. Multiple choice have multiple answers, with one being right. Multiple anwer have multiple answers, with some being wrong and some being right. The student is expected to pick multiple answers and avoid getting incorrect ones. Fill in the blank allows a string answer which is compared against the answer (or answers). For editText, a block of text is loaded and must be modified by the student. An edittext can exceed 255 characters, so cannot use a single varchar. In addition to the base types, there are also multi-part questions where each part can be a question. My approach is as follows: A Quiz is a collection of CompoundQuestions in a particular order. This table is not included because it is not relevant to the rest of the question. A CompoundQuestion is a sequence of text, graphics, and questions. Some compound questions could have zero questions (text only) while other CompoundQuestions could have many. Most will have just one. 

I'm completely new to Javascript and NodeJs and functional programming in general. The code below scrapes a torrent-website containing movies, gets info about the movie from the OMDb API and lets a user choose a movie to watch by streaming the torrent. Any feedback appreciated. 

I have implemented two genetic operators, which is really just a fancy way of mangling lists. In particular OX-1 (illustration) and displacement mutation. I found it necessary to extract out the randomness from the algorithms in order to do unit testing with some known examples. Is that a decent way to go about it? Any comments on performance, structure, clarify and so forth is appreciated. 

Well... now that you've learned how to use loops, why don't you just throw it all away and try to write it from scratch. Often it's easier to rewrite the entire thing instead of trying to improve the existing code. Don't be afraid to delete the code. You've learned a lot by writing it for the first time, it will not go to waste - you'll be smarter now, and it'll be much easier to write it the second time. You can back up the original code, so you can always safely return to it when your rewrite fails for some reason. There's nothing to loose. 

Well... this function doesn't really do what its name says. It in itself does not process the arguments, it only create arguments parser. I would personally suggest implementing so that it actually processes the arguments and returns them, so you can pass the result directly to : 

naive: 10.82 incremental: 4.74 There are some asserts in the code which all hold and might help you read it. The given benchmark parameters and grid are all typical of my simulation. Background: Imagine a geographical area divided into disjoint regions (cells), where each cell has a base station which provides service for cellphones within its area. Two mobile callers within some distance of each other cannot use the same radio channel, lest their handsets will interfere. When a new caller requests service, we must therefore find the set of channels that are free in the cell of the caller and the neighboring cells within some given distance. We can represent such an area and the channels in use with a boolean 3D matrix where the first two dimensions represent the geographical position (i.e. the cell) and the depth represents the channel. Cell areas often are circular in the real world, and we can approximate them as hexagons instead. Finding the neighbors of a cell we must therefore use the hexagonal distance. Assigning new calls requires to find the channels that are free in the nearby area (eligible channels). However to select channels that will optimize grid usage as a whole, statistics, i.e. the feature representation, are useful. So when an action happens, i.e. a caller terminates a call or a new one requests service, there's a set of legal actions to take depending on the action type ( or ) and the grid. The afterstate is how the grid would look after performing an action, and the feature representation of that afterstate, when compared with the others, informs the decision making. 

In the code above you first set and then inside you set again. These two are not the same variable. Do not define instance variables outside class methods, unless you want to do some meta-programming with them. You define method for accessing the variable. As this is such a common pattern, Ruby provides a helper for generating such simpler getter methods: 

We could write a separate function that eliminates undefined values from our input array and then feed the result into order checking function. Well, we don't even need to write our own function for that, but could use _.without: 

Java doesn't allow you to implement it like that, but you could implement a swap function like that: