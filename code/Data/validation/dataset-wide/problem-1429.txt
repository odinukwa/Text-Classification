What is the purpose of shortening the term "Prime(s)" to Prim in your method names? IMO and are more readable. The same is true for etc. can simply be Your spacing is inconsistent. Generally, it is recommended to leave a space between a control structure (, , etc.) and its following open paren, which you adhere to exactly once in , but not elsewhere. The same applies to operators: Write instead of . Your method is grossly overcomplicated. First of all, you check every number up to for divisibility, while it should be obvious that there can be no divisor greater than . Still, if you think about the problem, you will soon arrive at another conclusion, which is that you only need to check numbers up to , because you can write (with and being positive integers), which is to say that and are divisors of . Now, letting , and by thinking about how multiplication behaves, we can conclude that either or must always be lesser or equal to while the other must be greater or equal to , because when either or is smaller than the total product would shrink unless the other one grows to counteract this fact. The next problem is your use of a array, which is completely redundant. You do not need to store the result of the division test for each number separately, but you only have to keep track of whether you have found a divisor for (=> is not prime) or not (=> is prime). All in all, I would rewrite the method to something like this: 

which features a simpler for-loop body in exchange for some code duplication (which could be reduced by a -function if desired). Gain some, lose some. I personally prefer the latter version, but ultimately this is just a personal preference. You should refactor and . Currently, both methods have 44 lines (counting empty lines), of which 37 are the same. This makes my DRY alarm bell go wild. Although the situation is somewhat difficult, the most concise way to join these methods into one generic implementation would be to either use a macro to determine whether you want to move in clockwise (i.e. have all relevant lines be of the form ) or counter-clockwise (i.e. have all relevant lines be of the form ) direction. There are also other alternatives: For example, you could pass the nodes through a callback instead to determine which direction the rotation should move in, or you could join the two functions into one by adding an additional parameter which tells the direction and just have an on it. 

Do not use because it always forces a flush in addition to a new line, which can degrade output performance. Prefer over wherever possible. For example, in you use instead of . The reason this is detrimental is that performs a bounds check (and possibly throws an exception if the bounds are violated) while does not. Since only ever takes values smaller than , you do not need . Prefer for iteration variables. may be to small to hold all indices for very large strings. Don't use in a loop head, because may be executed every iteration. If you know that it value does not change throughout, store its value before the loop into a variable. can be optimized. Since you only return whether or not the difference between characters is one or less, you can return false as soon as you have found more than one mismatch. Although you do not give the definition of , it can be assumed that it is of type because of the iterator you are using. I would recommend replacing it with a if you are not doing a lot of insertion and deletion at random positions, because profits from cache coherency. 

There is really no reason to save the whitespace, neither around the operators nor after the ; it only makes your code less readable. Prefer the C++ equivalents to standard C functions. There is no reason to use when does the job equally well but safer (what if you made a mistake in the format string?). There are times when is indeed the right choice, but simply printing a string usually isn't. Use your s. Why make a type called if you still pass a (instead of a ) to ? Declare variables in the smallest scope they are used in. Concretely, do not define variables in file scope unless there is a good reason to do so. , for example, should live inside . Having be an is overkill. There are only 10 distinct digits, so the smallest type that can take 10 different values should suffice (usually, that would be or ). Single-character variable names are terrible. , for example, should be called something like or . You state that you want your program to be able to work with "a generic target number, operators, and number of input". Currently, your program can do none of that, because you hardcode everything. You should read your numbers and targets at least from standard input. You can omit in ; the compiler adds it automatically. Do not use float for integer calculations (see Toby Speight's answer). 

which is not only shorter, but also more efficient to compute. Why do you define almost all your variables at the top of your function, although they are not used until much later? This is a bad practice, because it increases the mental load everyone reading your code has to deal with. I don't want to remember the types of eight or nine different variables while focusing on code that doesn't even use them. Just define them right were they need to be defined. Overall, you use too much. Only use when you are working with characters or single bytes, otherwise use , and everything larger or equal in bit size. You are not gaining anything through your use of except a high chance to trigger ub several times over in your code (You are likely not even saving space because of alignment concerns on most common modern platforms.) Don't a single character; that's wasteful. Use for that. Don't include . Unless you have a concrete compilation performance concern, it won't do anything for you. And even then, it is not standard, and most people who use compiler other than MSVC will likely complain about it. Split your code up into functions. is not the right place to write problem-solving code, only to put things together. Do yourself a favor and organize your code a little more, it will help you keep a good overview over which part does what and make other readers not turn away on sight of that huge god-function. 

Design issues Apart from your program having undefined behavior currently, the thing that I most dislike about it is that your queue offers basically no usable interface. First of all, if I wanted to extract the size of a queue, I'd currently need an ugly template hack to get the second template parameter, whereas you actually should provide a getter. Secondly, the mechanism you devised of "get a single pointer to an element, then increment the position of an internal offset to the next element" is about as clunky an interface as I have ever seen. Neither can I get more than one element at once, nor can I go backwards, nor can I do random accesses, although the underlying container supplies all of this functionality. For a start, you should offer an iterator interface. Iterators are one of the core mechanisms of the STL, and enable your queue to work with most of the algorithms it provides (you'd likely need two different iterator types, though, one for read-only and one for write-only). Another feature that I'd really like to see is an interface separation. Basically, your class offers two different interfaces: One is read-only, the other is write-only. However, these interfaces are mixed together in a single class, which potentially allows somebody to do illegal actions, such as writing from a read-only thread. To prevent this, and enforce separation of concerns, it would be really nice if you had two interface-like classes (i.e. and ) which only export their corresponding half of the whole interface. Another point I want to touch on is the whole issue of copying and moving. As is, you simply deleted move constructor and move assignment operator, but this is lazy interface design in my opinion. There is no reason why copy should be forbidden (unless you can provide one), and even much less reasons why move should be forbidden. Neither of those two things seems particularly hard to implement for a data structure like this. Finally, I can not really come to peace with the design decision to force a double pointer indirection for the sake of avoiding copies. Of course, there are cases in which this is totally fine and appropriate, but in those cases you'd simply make the content type of the container and would have basically the same solution to the issue as you have right now. Since you seem to be very focused on performance, here is a point that might convince you: Forcing a pointer means forcing another level of indirection. Chances are, all those objects you create with are living in different parts of the heap, which makes it nearly impossible for the cpu and data prefetcher to get all those values into cache in time, meaning you are probably going to end up waiting a lot of cycles on memory. The more your data structure is fragmented, the bigger the chance that you will completely kill your cache and end up taking more time just waiting for data than it would actually have taken to copy all of those bytes over. In addition, if you consider move semantics, you can actually avoid a lot (if not all) of those copies and turn them into (comparatively) cheap moves. (Disclaimer: I haven't done any benchmarks on this. This is how the situation might pan out on a modern x86_64 processor, but I don't guarantee that any of the possible effects I've listed will be observable.) 

This answer turned out to be kind of a massive wall of words. Most points I mentioned are opinion-based to a certain degree, so please take most of these as a 'Please consider...' instead of a 'Do!'. However, there is a single point which does have this imperative nature, the first point mentioned under Includes. If there is only a single thing you consider from this answer as a whole, please make it that point, since it severely endangers the validity of your program. 

First of all, as πάντα ῥεῖ already stated in the comments, using is not a good idea, and doing that in a header if a lot worse. You're begging to introduce subtle bugs into your code as time goes on and things are added to your project and the standard libraries. Typing a few times is not going to kill you, I'm sure. is a code smell; relative paths in an include often indicate that your project structure is not good or your compile flags are not complete. You should specify all necessary include directories in the compiler invocation command line. is not portable and should thus not be used unless absolutely necessary. Is this the case here? I don't think so. Make users of other operating systems (i.e. operating systems that aren't Microsoft Windows) happy and remove that line. What happens if I enter the string to your program? Whoops, undefined behavior! Why? requires to be at least two characters long, which in my case it simply doesn't happen to be. You should add a check to verify that this condition is satisfied. seems redundant and superfluous. All of those includes should be at the top of your implementation file, not in the header. All includes that are not used (e.g. ) should be removed. The function doesn't serve any real purpose, except obscuring the fact that something throws and exception, which can lead to people wondering where those exceptions come from. Also it isn't used, so it should be removed as well. 

These are the pitfalls and dangers I spotted. There is a lot more to say about your code, however, but I will leave this to somebody else. 

Conclusion Overall, your code is not bad. The thing that bothers me the most is lack of structure, which is the core issue you should attack. I didn't spot anything that would require immediate intervention, such as UB (except for your includes, maybe), which is a great sign that your code is pretty good. 

It is important to note that the least significant byte has the index 1, not 0, because we reserve 0 for the occasion that no bit is actually set. Alternatively, if you use either gcc or clang, there is the builtin which returns the number of leading zeroes, greatly simplifying the computation: 

However, as you might have already noticed, we're wasting something here. In particular, we iterate through the whole string although we actually only need to check up to the middle. Thus, we adapt our code accordingly: 

You are passing by value where a pass by would be much more appropriate since you don't modify the string. Prefer early return over putting your whole code inside an if-else construct. To my mind, at least, 

Since "formatter" with two 't's is the correct spelling of the word, you might want to change you variable name. Another comment of yours reads 

Is it good practice to have a debug function that is dependent on preprocessor flags defined in the normal header and source file, or should such functions only be defined and implemented in test files? Are there better alternatives for error handling? I realize that passing two callbacks to a function is not the optimal pattern, but just logging to cannot be the right way, and integrating an error code into the return value would mean adding another layer of s which does not seem desirable either. In the same line of thought as 2., should a library-like function like this just be allowed to call when encountering an error that makes successful program continuation extremely difficult (such as an out-of-memory error), or should the task of terminating the program be left to the calling function? If yes, how should the information that such an error has occured be passed back? 

Flexibility You have fixed your data type to be . What if I want to store, say, a double, or a in my list? Fat chance. Instead, you should make both classes templated, so that you can have lists of whatever type you want. Interface I'm sorry to tell you this, but your linked list is basically useless. Why? Because you don't offer any interface for iterating the list. So what can be done with it? Currently only two things: It can be printed and you can calculate its sum, so not very much at all. What you're really missing is an iterator interface here (although a pointer interface would be a start, I guess). Although iterators are kind of cumbersome to implement, they are one of the most useful features of modern C++ and required if you want your class to be able to operate with standard algorithms. For example, there is which makes your function obsolete (and is also more versatile). Furthermore, you have a lot of and methods which are hardly necessary. You should take a look at what offers as an interface and orient your code at that. Another thing which is really important is that you disobey the rule of 3/5/0 (depending on the C++ standard you're targeting). Although you do implement a destructor, things such as copy- and move-constructors are missing, which makes your class hard to use (making copies is basically impossible). That also answers your question of what you need to do to be able to pass your list as an argument to functions: implement all required special member functions. Lastly, we need to talk about error handling. A method such as has a huge problem: You cannot really signal an error. Although you were farsighted enough to take care of the fact that your list might be empty, you didn't find a good solution to that problem: Just returning -1 is bad, because as a user you can't distinguish were this number came from. After all, it might just be that the first element in the list had the value of -1. Luckily, C++ comes with a special error handling feature: Exceptions. Instead of returning you could just throw an exception and have the error be unmistakably passed to the caller. However, exceptions are expensive and should be used sparingly; maybe you'd want to consider having as a return value instead (if you are using C++17, of course), or remove the check altogether and make it the user's liability to check the size first (In fact, ) General Hints and Tips about Coding Style