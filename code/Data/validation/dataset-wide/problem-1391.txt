Both loops look almost the same with the exception of whether or not a collision check is performed near the bottom. I could have one loop that has an internal check: 

But I am just guessing as to the private setters. Use what your app requires. Numeric Type Designators should be Uppercase Change the to . Really doesn't affect your code here but the reason for this guideline is you ever use where a lowercase could be confused as a numeric , but a capital would not. Always declare accessibility modifier Instead of simply use . When I see a missing, I assume a newbie coder has forgotten it, which leads me to wonder what else he or she has forgotten. Variable declaration and scoping As mentioned at the very top with , you should limit the scope of a variable to where you need it. In my example, was placed inside the block and declared immediately before the one place where it was referenced. Someone reading your code doesn't have to remember where it was defined, or worry about it afterwards. 

Over the years I’ve seen many C# sieves and despite their varying internals all that I have seen invariably are a static method that returns a , perhaps with the occasional rare exception of an . This is fine for small collections. Granted relatively speaking for some people a 1 million item list is small. But if dealing with very large upper limits, say , you could run into an out-of-memory exception fetching over 105 million items. So I wrote a sieve class that has these highlights: 

I've got a version that is slightly faster. I'd like to think the whole algorithm could be improved but it's too early in the morning for me to concentrate on that. What I would caution you is that sometimes casting can hurt performance, most notably if you are casting hundreds of millions of times. That said there are lots of implicit castings going on in your code. A couple of examples: 

Example Usage Here’s a simple example that counts the number of primes found and finds the largest one. 

I would suggest there are better ways than using the libraries. This isn't just because you are using C#; I have given the same advice many times in the past to those using VB.NET. There are a lot of links on how to read text with .NET. Here is one using : $URL$ To split the fields, there is the String.Split method. For reading the specific fields, see the answer from @Heslacher. Pay attention to his other tips such as naming, etc. Speaking of naming, is not a very good name. I would suggest something simpler and more direct, such as , or , or . I note you are reading one line at a time, and posting one line at a time. You may consider doing this in bulk, in which case you would want a (or ). 

On one hand, this is proper to be a method in that it must take a wee-bit of time for . On the other hand, if was to be small enough, you may consider making it property. Note that "Count" in the beginning is a verb and "Count" on the end is a noun. Color: A verb or a noun? Speaking of nouns vs verbs, for the method, I take issue with the name since whenever I see I tend to think of a the Color structure. Perhaps or are suitable as action verbs. Granted “color” can be a verb or a noun, but again most developers may think noun. That said, I don’t see where you do anything useful with . Looking at it further, there is no need that should return a value. That would shorten up code in the (or ) method. 

The thing that screams "BEGINNER!" is the fact that you've placed everything in the Program class. Igor's opening remark touches upon this, but he doesn't do anything beyond giving it a mention. My remarks below may be used in conjunction with all the other answers. As written, your code is extremely rigid. What if you ever need a different height or width? Or node probability or interval fraction? Those 4 properties seem to define a very specific grid. This is achieved by creating a class with an appropriate name, perhaps Grid or GridMap or something else as long as it is a meaningful, clear name. You have 4 main properties (previously mentioned) that help describe the uniqueness of one grid over another. At a minimum, you would have a class defined as something like: 

Since that AtBash Cipher is a simple reverse, you don't need both and . There is no reason for to be at the class level; it should instead be locally defined in both and . You may even consider doing away with having a class instance and instead make the class and its methods static. If you keep as a class instance, could be simplified to simply returning !!! You should be sure to set the input string to lower case in case someone enters "Hello". Something like: 

Couple of things caught my eye. The constructor for and can throw an exception if a is passed in. Just looking at the plus operator, there is a bug if equals in which case neither is less than . Also for subtraction, multiplication even by -1 seems heavy-handed. Perhaps: 

You may consider making to be if it doesn't change within the instance. EDIT More about throw\catch Another suggestion is to keep your blocks but don't use . Instead you could have a public property called Exception, such as: 

Worst Case Scenario: The will have a Length of 1,073,741,823 bits, which is 128 megabytes. This will yield 105,097,565 primes. If you want to store the primes to a , the code is quite easy: 

As shown in @Denis's answer, and echoed by @Corak, is the method could be made slightly faster and shorter by reducing the logic inside the loop: 

Enums should be treated as enums and not numerically. @TopInFrassi touched on this too briefly when he said not to use byte. That doesn't mean you should use for the enum either. Rather just use the enum as is, particularly with well chosen phrases as it makes your code more readable or less cryptic based on magic numbers. Example 

In addition to @Aaron's answer, you can also use bit shifting. Also Naming Guidelines would expect the method to begin with a capital letter. This could also be reduced to a one-line method: 

There are a couple of advantages doing it this way. For one, I have a timing mechanism in place. And two, whatever is particular about problem 7 is isolated into its own class. I don't just have a single method. I have 2 examples: and . Let's look at my class: 

As of this writing you have a very good detailed answer, and you've already updated your code as answer as well. The new code looks a lot cleaner but both the old code and new code - particularly your build methods - require a server parameter. Just one example of the many: Old Code: 

Update: You can explore with whether the collection of triangle numbers should be an array, a list, SortedSet, Dictionary, etc. I don't think the collection should have a value for , or rather my code below would need to be changed. Still, a should not be included otherwise you risk accidentally counting the and backtick characters as triangle numbers, when they should not be. The aforementioned characters immediately precede and . Instead of Dictionary One option instead of the dictionary would be: 

For readability, I also use better names IMO, e.g. CritterTracker rather than Classy. I even define constants for better readability. Using @outoftime's , I run this in about 0.25 milliseconds in Release mode for 1M moves using @outoftime's . For better comparison, using @outoftime's method takes me 170 milliseconds. HOWEVER, the problem is that my code correctly finds criss-crosses and would return find an answer in the first 10 entries out of 1M. When I created a custom 1M item list without any possible collisions, it's taking minutes (as I type and still am waiting for an answer). If time allows tomorrow, I may try to optimize this to not be as embarrassingly slow. Explanation of my code So a critter starts at a point of (0,0) and moves in a given compass direction to land on a new point. A segment is formed by 2 consecutive points. Given the app, a segment will either be vertical or horizontal. Except for the first segment in a collection, a segment's Point1 is the same as its immediate predecessor's Point2. I store all the moves in memory, but will only create points and segments as I am looking for any crossing or collisions. If you have 1M moves but a collision is found on move 6, processing stops. I keep a simple . My class is not static. The constructor accepts an for the moves, which works fine with arrays. My solution method is named . While I could have kept it or what happens if someone asks what's that last index where a crossing occurs? The spirit of CR is to provide more meaningful names. Comments about your code Better naming ... a class of doesn't tell me much. It's a critter tracker, why not name it ? Likewise . a dictionary named , and an input array named make the code terse and less readable. Straight-forward names are recommended: , , and would be suitable replacements. One-liners ... many at CR think braces should always be used with one-liners, e.g. 

If you do find a matching vehicle, you add it. Then you continue checking on the same vehicle instead of breaking out of the inner loop to fetch the next vehicle. Reflection is sluggish. I would suggest having the class determine if its matches a search string. That would mean having a method such as: 

Your methods should be singular in purpose. In your OP, finds the solution and also writes to the console. It really should be just to find the solution, and let take care of the display. And it could be much smaller. Taking @Pimgd 's suggestion, the code could be reduced to: 

My (also now deleted answer was): is a and its checked to see if its lowercase. If it is gets the value of . If not, gets the value of . It is equivalent to this: 

Avoid Too Many Threads As I’ve seen on SO and CR, parallel processing can easily be done wrong and take much longer than simple serial. Inside my loop, there are only a few, fast calculations. It would be a performance drag to create a thread for each (worst case is over 700 million). This normally is a great candidate for a range but I need more than a simple range. Consider a simplified example where the domain of is 1 to 100 inclusively, which is to say that is 101. I also want to generate no more than 10 threads in this example. I do NOT want ranges like: Range 0 is {1, 2, 3 , …, 8, 9, 10} Range 1 is {11, 12, 13 , …, 18, 19, 20} . . . Range 9 is {91, 92, 93 , …, 98, 99, 100} I want series like: Series 0 is {1, 11, 21, …, 71, 81, 91} Series 1 is {2, 12, 22, …, 72, 82, 92} . . . Series 9 is {10, 20, 30, …, 80, 90, 100} Square Root Corner Case There is a special corner case where returns the wrong value. This is not the fault of itself but just the nature of the (implicit) cast of to a since you have an integer value fully and exactly represented by 64 bits but you are squeezing them into a 64 bit floating point approximation. This corner case is easy to detect and just as easy to correct. The key is to be aware of it in the first place. Performance [Edit: I erroneously listed the 31 & 32 bit times as seconds. The correct unit is milliseconds.] On my 8-core laptop in serial only mode: Largest 31 bit prime takes 0.17 milliseconds. Largest 32 bit prime takes 0.23 milliseconds. Largest 63 bit prime takes over 13 seconds. Largest 64 bit prime takes over 18 seconds. In parallel mode: Largest 63 bit prime takes 6.6 seconds. Largest 64 bit prime takes 9.28 seconds. Questions Being this is CR, there is always an implied question of “Do you have any constructive comments?” While I have used many times before, this is my first implementation where I had to create a specifically arranged series rather than a simple range. Is this done correctly and/or could it be done better? Other than using Miller-Rabin techniques, can this be made faster? I’ve used more threads and less threads - or really what I call and assuming that each chunk gets its own thread - but on my laptop the fastest times consistently were when I used a chunk count equal to my processor count. 

Finally without getting into too many specifics, I'm not thrilled about the class as it does too much. Typically one would see a and enum, and then a would be an individual card containing a rank and a suit. Put many cards together into a class. An individual card cannot be shuffled. Rather a deck of cards is what is shuffled and dealt from. You can go even further that there is a standard deck of 52 cards (perhaps a static method), or you may be working with a deck consisting of 4 or more standard decks. 

That is our launching point. Let's build from there. We will add a few more constructors. You have a few spots where you use Magic Numbers (example: see generateNodeAmplitude), but you also have spots where you define some static readonly fields. As these are value type fields, you could make these constants. 

Note use of above. Maxscore isn't used Therefore it is dead code and should be removed. Scoping The comments says is a global variable. First of all, it isn't. Rather it has class-level scoping. More importantly, it does not need to be at the class-level. You only reference inside the method so it should be local to that . Explicit access modifier I encourage use of or , especially when I deal with entry level developers as I tend to wonder if they forgot to put it in. i.e. did they mean for this method to be be omitting the modifier, or did they forget? When I see it explicitly, there is no doubt. Dictionary Not Needed The dictionary is not needed. Granted its not very big either. But it doesn't help with performance either. IsWordTriangleNumber As is your does 2 things: (1) it builds an array, and (2) checks to see if the current wordVal is in the array. What could help with performance is building the list of triangle numbers ONCE rather than for each word. This again would be scoped just to the method. This also helps to separate concerns. Building the array and checking for something in the array are now 2 different things. Also this block of code: