Because the code you write is to be used for teaching, the importance is not on performance, but on correctness and readability and understandability (comphrensiveness?). So basically... 

And these are the writes. Seems like we're only ever accessing and . Do we really need an array, or can we just work with "current" and "previous"? 

Note that function names make good comments. Instead of we just put . I recommend you start comments with why, and then with how. How-comments should eventually be removed (you can read the code), and why-comments should stay, but when learning how to program, having the explanation next to the code just helps. It also promotes micro problem-solution flow (in my opinion), which is what you need later if you want to split up code into smaller chunks or problems. And this loop here... 

You should fix your indentation. I want to review the code, but a lack of indentation makes it really hard to read it. You use Eclipse, so use this to format your code: 

It fails this check, but that's not required. As is not overridden, it can't violate that contract. Do not lie in the comments, for it is worse than having no comments at all. 

You know how long the list is going to be, so why not ensure the capacity beforehand with ? Aside from that, there's really not much to say about such a short implementation. 

Although maybe it'd be better to just calculate the offset; in that case you could invert to get the cartesian view. 

You'd be better off defining the function outside of the loop and calling it by passing it parameters. What the warning is referring to in this case is creating a new function object in a loop, meaning you create several anonymous functions, where 1 function would do. Creating a new function object in a loop like this can hurt performance. 

I'd wrap the in a tag. Maybe you want to add more attributes to spells later. In fact, I'd probably make and . I'm also thinking you might be better off here and there by using some sort of "quantity". Lets say a spell had 10 components (for some arbitrary game design reason)... 

It'd be nice if I didn't need a whole lot of boilerplate to define an enumeration. If I must write boilerplate, then I'd prefer to write such boilerplate once - adding values should be easy. Same goes for removing values. With that in mind, I have managed to create the following... Base class 

And column 2 we stop because 11 beats 3. The only problem with this approach is that you need to be able to have a sparse array, otherwise you run into memory issues. This solution is \$O(n)\$. 

This comment doesn't say what the function does. It's also contradictory to the function name - "game start up" and "start player turn"... When I start up a game, I grab a deck, maybe shuffle it and give people cards. Your IDE generates things like and . These are for documenting your arguments or "parameters" and your return value. So a comment like this... 

It seems this was already pointed out to you, but still, I would say that this is a positive change - it's a simplification and the old situation doesn't make more sense from a semantic view point. It really is "and now, the next item needs to go in the other list" rather than "if we added the item to the left list, it now needs to go in the right list, and if we added the item to the right list, it now needs to go in the left list". 

The while loop has no inside of it, so the only way you'll get past the while loop is by having equal . Which is what you check for afterwards. That if check can go, as it's always true. Similarily, later on, you check for again. Since there were no alterations to the variable, it's still going to be null. Remove the if-check. 

Another suggestion from a linked question is that all primes are expressible as "6x+1" or "6x-1", so you could use that to perhaps iterate over every 2nd number, or over every 6th number -+1. 

With a similar enum for Float values and Integer values, you could make everything compile-time safe... at the cost of so much flexibility that I personally think you'd be better off just... using a regular class. I mean.... you have a bounded list of fields. You can literally store everything in a class, add getters and setters, and then just use the appropriate and call. If you can choose runtime, you cannot validate compile time. 

To me, it reads quite a lot better; and that's just by pressing auto-format button on the IDE. Next, since we're assuming you have no time, just insert whitespace. Whenever you start doing a different thing, add a new blank line. 

So, now we are done, right? Well... not quite. You see, what would happen if the thread that wants to restart the application is the application thread? Well, we'd go through , and wait for the currently running thread to... die... Yeah, that's not going to work! In that case, we can use to compare! If we find that the thread that is restarting the application is the application thread, then we don't need to wait for it to die, we can just set to true again, because we know it is still in the while loop and won't go out of the while loop whilst we are setting the variable. 

And then went on to show a picture of a grid. They're not talking about an Ocean. They're talking about a grid. You can't have the same grid represent two different moments in time, for the grid will have changed. You need two grids to make a timestep work. The last part of the sixth paragraph hammers this point home: 

You're not closing the output stream! If that doesn't fix your issue, you'll have to post more contextual code, because after you free the output stream, the rest of this method should just free its resources after it is done. 

Which divides the money like so: 1 for me, 1 for myself, 1 for I, none for you. 1 for me... I'd recommend in this case to fall back on relative percentages: that is, sum the percentages and then set the cut to be the percentage of the summed percentage. So 10, 5, 5 = 20 total, 10/20 = 0.5, 5/20 = 0.25, so it's 0.50, 0.25, 0.25.