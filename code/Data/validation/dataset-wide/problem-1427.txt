The method itself can be improved. The method creates a new in each iteration. Better create only one and append all elements (similar as on your function): 

I would probably name the methods differently. What is generally missing is a way to bind values to prepared statements, which is important to avoid SQL injection attacks. 

The repeated creation of mutable arrays consumes much time. This can be avoided by modifying the existing arrays ( and ) before entering the recursive step, and undoing the modification on return. For the beads array, you can remove the first element and later add it at the end, so that it is not chosen again: 

Of course you can also define protocols for both the node and the stack type. Now the node protocol should contain all required properties and methods: 

We know that the fetch request returns an array of objects, the cast cannot fail. Therefore the second half of the method can be reduced to 

You should make your type conform to so that printing an ordered dictionary gives a nice looking result. A simple implementation would be 

Finally: There is nothing in the implementation which is particular to strings. You can make the class generic so that it can be used with other data types as well. Only minor modifications are necessary: 

One thing I noticed is that calls with exactly the same arguments. So you don't need two separate methods but just 

without the factorization . Generally a better method would be to determine the factorizations without duplicates in the first step. This can be done recursively as follows: 

If you want to be computed from then it needs to be a lazy property, otherwise you could make it a stored property as well: 

is not needed anymore. At each point in the algorithm, it is known to which group a participant belongs, so there is no need to search it in a group array. Also sorting the groups from within that method is confusing. Using all that, the main Secret Santa method can be written as 

is an array of dates in that month, this can be used to compute the number of rows in a section and for the method. 

Further remarks and are equivalent notations for an array of integers, but I would suggest to use only one of them consistently. The comment in 

which tests and unwraps the optional result as a single action. Inside the if-block, is the unwrapped . You can do the same with the items: 

It is not immediately obvious that finds all factorizations and removes the duplicates, so the names could be chosen better. (And I would use "factorizations" instead of "possibleProducts"). Your code is ineffective for two reasons: 

because that contains the main logic, then mention some other points, and finally present an alternative solution. 

This reduces the time to 4.6 seconds. But any “real” Eratosthenes sieve is much faster. As an example, with this one from Rosetta code 

As with the labels in the enum definition, they have no meaning, and the calling code becomes better readable without them. Define custom operators 

It remains to find the longest sequence of consecutive numbers (ignoring duplicates) in that array, i.e. no date/calendar calculations are needed from this point on. This should be done in a separate function, which could look like this: 

Second, copying a vector copies references to the elements, which is not to be expected for a value type: 

About Version 1: has a time complexity of \$ O(min(a, b))\$ and requires an array for intermediate storage. You could get rid of the array by iterating over the possible divisors in reverse order, so that you can early return if a common divisor is found. About Version 2: has a time complexity of \$ O(xy)\$ and requires two arrays for intermediate storage, so this worse than version 1. You could improve this by pre-computing only the multiples of one number, and then test the multiples of the other number (in reverse order) until you find a common multiple, and then early return. Common issues: 

Here values are multiplied and the result converted to the type of . This turned out to be faster than multiplying integers or instances of . This is more than 4x faster compared to and needs only a single type conversion: 

then the force-cast operator will cause a runtime exception. The correct way is to use conditional casts and optional binding: 

A safer (and actually shorter and easier) approach is to define a string-based enumeration, which implicitly defines the conversion to strings and back: 

the conversion to is not needed. And what if is ? Your code would crash in that case. But my main point of criticism is how the bucket is computed. A day does not necessarily have 24 hours. In regions with daylight saving time, a day can have 23 or 25 hours if the clocks are adjusted one hour back or forward. Applied to your code: A week does not necessarily have 604,800 seconds. The proper way to compute calendar differences is to use the methods and : 

Another possible improvement could be to check in if the observing object still is alive, and remove it from the list otherwise. 

A different question would be how "good" the hash is. The Swift language does not make any requirements here. Always returning would be valid, but of course ineffective when building large dictionaries. It may be interesting in this context that the hash value of the Foundation type is simply the number of elements, regardless of the contents. In your case, the DJB hash function is a well-known hash method for strings, so I do not see any reasons not to use it. 

Determining the matching open bracket for a given closing bracket can be made a computed property of this enumeration: 

This reduces the number of iterations again. But it is still \$ O(N^2) \$, and I doubt that much more is possible with this algorithm. As you already noticed, sorting the array first and then taking the middle element is faster. This is no surprise since sorting can typically be done in \$ O(N \log N) \$ operations. 

is from the Foundation library and works with instances. The previous method works because the value is automatically wrapped into an object when added to the counted set. This conversion can be avoided by using a native Swift dictionary instead, which makes the code much faster: 

I wouldn't care much about performance here, since a view controller hierarchy does not have hundreds of elements. But some things can be simplified. First, 

Finally an alternative approach, which might be simpler for the usage as a table view data source. The initializer (introduces in Swift 4) 

Always use curly braces with if-statements, even if the if or else part consists only of a single statement. That helps to avoid errors if the code is edited later. 

Finally note that your function considers all number below the given parameter, so you should either call 

because compiler diagnostics and autocompletion works better with struct, but that may be a matter of taste. Finally note that essentially does a mapping from a range of integers to a sequence of strings, so the same would be achieved with 

This is my attempt at the May 2017 Community Challenge in Swift, with a chain consisting of rigid links. I took this as an opportunity to learn SpriteKit, Apple's framework for 2D games. At least Xcode 8.3.2 with Swift 3 is required to compile the code, it runs on both macOS and iOS (instructions below). VectorUtils.swift – Some helper methods for vector calculations. 

so you can use the same test to update either or . You compute both a sum and a complementary sum at once, which is a good idea to cut the (maximal) number of iterations into half. But the loop 

Your implementation is correct but not efficient, as the number of loop iterations and remainder operations is equal to the input number. The count of divisors can be efficiently computed from the prime number factorization: If $$ n = p_1^{e_1} \, p_2^{e_2} \cdots p_k^{e_k} $$ is the factorization of \$ n \$ into prime numbers \$ p_i \$ with exponents \$ e_i \$, then $$ \sigma_0(n) = (e_1+1)(e_2+1) \cdots (e_k+1) $$ is the number of divisors of \$ n \$, see for example Wikipedia: Divisor function. Example: $$ 720 = 2^4 \cdot 3^2 \cdot 5^1 \Longrightarrow \sigma_0(720) = (4+1)(2+1)(1+1) = 30 \, . $$ An implementation in JavaScript would be 

Your printing of the numerical IP addresses with does not work correctly, the second argument must be the address of a and not the address of , for example: 

Declare variables at the narrowest scope where they are used, and not at the top of the function. For example 

This has about the same speed as your method when applied to an array, but works for arbitrary character sequence. You asked: 

That looks like a clean implementation to me. One minor thing: I find it more natural to assign the new index before the array is extended, so that you don't have to subtract one: 

If the purpose of rounding the number is to present a result to the user up to a certain precision, then it is better to use a number formatter instead, for example 

Similar changes can be applied to the class. Reading the response – Thou shalt not force unwrap! This refers to the force-unwrap operator and the force-cast operator , both easily cause fatal errors and unexpected program terminations. There is a lot of force-casting in the completion handler in the function, starting right at the beginning: 

There is still too little (horizontal) whitespace, I suggest to check your code against the PEP8 coding style, for example at PEP8 online. Also function and variable names should be according to PEP8. More suggestions: 

In I would use a switch statement to handle the possible inputs, and a boolean flag for the "running" state: 

The solution is easy: change the parameter to . Btw, this makes the method faster. Problem #2: The method is an extension of , but it actually works only for s. For arbitrary sequences of characters, the optional cast fails. This is silently ignored and the separator not inserted: 

which is simpler and a bit faster than the original one. This can further be improved by avoiding the conversion of each character to a string and the array, and operating on the UTF-16 view of the given string directly: 

because is ("not a number"). But for non-negative numbers below \$ 2^{52} \$, your approach should be correct. Swiftyness is not mutated, therefore it should be a constant (with ): 

From this representation it becomes obvious that your implementation is correct: It is computed from the property, so equal objects have the same hash value. The computed property can be simplified using , note also that for a read-only property, you need not put the getter method inside a block: 

I usually assign the sort descriptors to separate variables first. This may be a matter of taste, but it avoids too long statements if there is more than one sort descriptor: 

fails. You want to create a which – when bridged to – becomes . The difficulty here is that the value type of the Swift dictionary is an optional. But it is possible, using : 

This should be used as the basis for implementing an function. Have a look at $URL$ if you want to implement the yourself (for educational purposes), for example 

(Remark: I am using println() for diagnostic output in this review instead of your log.atLevelDebug(). The reason is that I wanted to test the code before posting an answer.) That seems to be working code (with one exception, see below), but there are some things that can be simplified or improved. is a possible value for any , so you can simplify your initialization, for example: 

You use the 's property to identify from which button the action method is called. This is OK, but note that (zero) is the default tag for all views. It is therefore better to tag the buttons with instead of , and adjust that in 

The Swift standard library does not have a built-in method to access the n'th character of a string. It is tempting to fill that gap with a custom extension like you did, but the problem is that 

Finally, the calculation of the number of consecutive weeks where the goal has been reached can be simplified to 

If your intention of is to avoid global variables and to provide a “namespace”: This can also be achieved with a case-less : 

and compute the next value of from the previous value, instead of calling again. That is one multiplication and division instead of . 

returns all primes below . That might be unexpected. I would suggest to change the function so that the upper limit is included, and give the parameters a more descriptive name: 

You check if is not nil, but even then can be nil and the force-unwrapping causes a crash. A safe and concise solution is to use optional chaining 

Using a property for the boolean attribute is fine. Properties have many advantages: they encapsulate an objects value (i.e. the actual implementation is hidden from the outside, it need not be an instance variable), they are public (instance variables are by default not visible from other classes), they can be observed (via Key-Value Observing). In the ancient times of Manual Reference Counting they made the memory management easier. In the case of a "simple" attribute that is only used within the implementation the difference is small and (in my opinion) a matter of taste. But if you use a property then you should use the property accessor methods consequently. 

would be easier to understand and also makes the variable obsolete. The iteration over all possible start/end positions is better done with a for loop. Avoid unnecessary conversions In your code, the big number is converted to a string repeatedly, it would be sufficient to convert it only once. You could even provide the given number as a string directly. The substring is also not needed because we can access a character from the original string directly. Putting it together Summarizing the suggested changes so far, the generator-based version could look like this: 

However, that function seems unnecessary to me, since nowhere in your program an invalid location is created. 

To find duplicate factorizations, you split the string (e.g. "60x2") to an integer array , sort the factors () then concatenate the factors again ("260"). This is used as a hash key to eliminate the duplicates. This is quite computing intensive. In particular the hash key 

I would even go a step further: is useful in connection with optional binding (to avoid the "optional binding pyramid of doom"). In your case, the same can be achieved with a simple statement: 

Defensive programming (never force unwrap, no forced cast, ...) is good and important to handle "runtime problems" gracefully: Unexpected user input, failed network connections, I/O errors, and many more. But programming errors are a different category. Example 1: If 

According to the problem description, is at most 20, so using is good, an is only guaranteed to have 16 bits according to the C standard. But is an and if exceeds the number of bits in an then the behaviour of is undefined. So 

There is one error in your implementation: The test must be , otherwise the returned values are not correctly distributed according to the given weights. You can check that with the input list 

On my computer (a 1.2 GHz Intel Core m5 MacBook) this reduced the time for processing the above file from 24.5 seconds to 4.4 seconds. Putting it together With all those modifications, we have 

There is still a caveat: Your constructor allows the denominator to be zero (and the function would throw a "division by zero" exception in that case). You should check the denominator in the constructor and throw an exception for invalid input. You might also want to normalize the fraction and make the denominator positive, in order to avoid a result like . The function itself can be modified slightly to work if some arguments are zero: 

The first thing that I noticed is that you have three view controller classes (, , ) with identical code. You can reduce that to a single view controller class (perhaps ?) which is the custom class for all three view controllers. The method in then simplifies as well: