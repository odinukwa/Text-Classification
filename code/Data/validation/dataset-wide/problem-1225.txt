I think throwing a seems like a good idea. Alternatively, you could also store default values somewhere and return those (eg "missing", "n/a", "", "invalid column", etc). Misc 

The only reason you have all these methods in the first place is because it's unclear how to use the method. If you would just document it properly, you can remove all the other methods that don't actually contain any logic themselves. I'm unsure what the difference between amount and rent is, but it may make sense to have two methods: and . If both are needed, you could also just query once and save the result in private fields. What you definitely do not want is what you have now, where you add a method for each amount of rooms you expect. That's what method arguments are for. Security You are vulnerable to SQL injection. Never put variables into a query directly, always use prepared statements. Naming 

Goto Honestly, I didn't even know that PHP supported labels and goto. But this is how the manual for PHPs goto starts: 

The same is true for . I think writing it this way is clearer (and also shorter), but it's probably a matter of taste. Misc 

No, putting everything in one giant class is not a good idea at all. It makes it impossible to reuse part of the code in other projects, it makes it really hard to find the code you are interested in, and it will also make it very hard to add new functionality later on (because you can't just concentrate on the relevant classes; you only have one class, so everything is relevant all the time). A class should ideally only be responsible for one thing. So you might have a model class, which holds the entered text, and offers methods to manipulate it (such as search something in it, replace, etc). Saving/Loading should also happen in a separate class. And you could separate some gui elements into their own class as well (such as main menu, toolbar, search-and-replace window, etc). You should also definitely split up your actions class. Give each action it's own class. And never use strings like this for program flow (if you must use your approach, use enums). 

Security You have an auth type that is called , but which doesn't work on cookies, which is odd. Apart from the added complexity (you have to add it to every form yourself), this is also bad as you can't make POST data httpOnly. It also doesn't make any sense to me (it doesn't work as a remember me token or anything). It's also very unclear to me how you match a "cookie" to a specific user, as it's just random data. If you deviate from the standard approach of sessions and remember me cookies, you should really properly document why and how exactly your mechanism works. 

Protected Field vs Getter and setter I prefer to not access fields directly, because it's difficult to use and not very flexible. When I need to implement a new fileservice, I just need to know that I need to define a field called . If you do not thoroughly document this, implementing new services in the future will be a pain (and even with documentation it's not ideal, as nobody really reads it anyways). The second problem is that I can only define a string as file extension. What if I want to create an image file service, that allows the uploading of jpg and png files? I would need to dynamically set , and the only place I could do that is in or , neither of which should really be responsible (and even though it may work right now, it may easily break once you change your base class). It would be a lot better to just add an abstract getter for the file extension. The same problem exists with as well, and also works the other way around: in you work directly on , instead of using some setter method. Field location It is odd that you store the in , but the and in . Just put them all in to simplify things. File class You may also consider creating a class, which could hold , and , as they all belong together. It may also contain common functions such as the one to get a filename (without extension). Various Store Methods I think that it is not ideal to have and in your base service. What if I only want to save the file in the database, but not the server? Instead, I would have a generic, abstract function in . Need for abstract ? Of course, if you follow the advise above, it's not clear that is actually needed as an abstract class. The only thing it does is provide a function to get the name of a file (which may as well be a utility function in some file utility class, as it is likely used elsewhere as well), and a function to save a file to the server (which is really just a call to a different function.) If you expect more common functionality in the future, this isn't really a problem, otherwise you may consider changing the abstract class to an interface. Misc 

Return Early If you return early, you can avoid nested if statements. It even fits in very well with the comment you already have: 

Your code looks mostly good to me. One thing: Functions can help increase readability of your code, and reduce the amount of duplicate code. Additionally, they make testing and (re-)using your code easier. Your main method should only be an entry point, it shouldn't really contain any logic itself. Your main method might look like this: 

Structure I think your interface is slightly confusing. Classes should be reusable without actually looking at the code; the method signatures and comments should be self-explanatory. Without actually looking at the code, here is what a user of your class would see: 

Comments Inline comments should explain why the code is written the way it is written. These comments however do not clarify anything, they are just confusing: 

But I would actually make more methods out of this, because it seems like two different activities (check if it can be parsed as integer, and check if the integer is below 3). I would create a method (or just use a try block), and then a method (or not. if you separate the functionality, it becomes easier to see that the functionality actually doesn't need to be extracted to a method). Declare Variables in smallest scope You should always declare variables in the smallest scope possible, that way a reader only has to have them in mind when they actually matter. for example is defined at class level, but only used in . Misc 

Now you don't have to pass empty strings to the function (which is really confusing to use), and the functions have a proper name as well. 

Without loops or similar "advanced" structures, there isn't much you can do to simplify this. You could save the duplication in extra variables. It might look like this: 

No and no. Non-Random Token: Login as anyone The only data you store in your cookie is the username*. But usernames are generally not considered secret, and are relatively easy to obtain. Because of this, an attacker can just calculate themselves and log in as anyone. You definitely always want at least partly random data in your cookie. 

I would either define these strings as static fields (), and then use them from outside the class, or do it how PHP does it for eg by using to create a global variable (I would actually prefer the first approach). Still, good documentation would still be nice, I would add an example case to the PHPDoc (the current isn't helpful at all). Misc 

[*] should be ok for , as it is very unlikely that the function will be changed to return anything else than or in the future. On the other hand, it is PHP, so who knows. And , , , , are all . 

The first is obviously the name, but after that, I would need to look at the documentation or code of the food constructor. There are multiple solutions for this. You could use the builder pattern, you could combine parameters into objects (min and max cap for example might be a range, and beginList and describeAmount also seem to belong together), or you could just reduce the number of parameters by removing unnecessary ones (is there really a reason to pass rand in? Should the name of a burger ever not be burger?). Is there a reason that the Food class doesn't build the behavior? It seems to be an action that is common to all foods. Your play method is a bit long for my taste, and does a bit too much. I would move all the printing into their own methods (like displayIntro, displayWin, displayInput). The logic could likely also be improved. Is there a need to check foods for removal for invalid input? It doesn't seem like it, so your code may look like this: 

Order of expressions in statement Your code would be more readable if you would be consistent with your ordering in the if clause. You have 

When outputting, you know the context, which is important to defend against XSS (is it inside script tags? inside a HTML attribute? What attribute? A JavaScript context attribute? Are there quotes around it? What quotes? ...) You really can't be sure when outputting data that it was previously secured (can data get into the database in other ways than GET/POST? etc). Your data will not be clean anymore, which may break your website (eg when sending an email, or when using passwords (with your function, would become )). 

It's not that important that it is internal. You may be vulnerable to CSRF, XSS, etc (not in this piece of code, but maybe somewhere else), which may allow an attacker to attack your internal website (they would need some information about the infrastructure, but you already posted part of the source here, and your security shouldn't rely on the secrecy of script names, source code, etc). But no, there shouldn't be any way to attack your server. You removed all your SQL queries (or did you just not post them?), the filename that is written to is hardcoded and cannot be overwritten, you don't echo anything, don't use any dangerous functions, etc. The only thing you do with user input is to write it into a .json file. So as long as your server isn't configured to interpret .json files as something else - eg PHP files - (which it really shouldn't, and no server would be configured like that by default) there is no danger in the code you did post (but I'm guessing it's just a very small part of your program anyways). Misc 

Of course, only uses pseudorandom numbers anyways, so the slight bias might not be all that important. Pass by Value Strictly speaking, Java is pass-by-value, but you could still to this for example (because references of objects are passed, and thus changes to an object affect the object outside of the scope of a method): 

Yes, you really should move away from . It's deprecated for quite a while and not secure. And there isn't that big a learning curve. Once you actually parse user input instead of having hardcoded values for testing, your code will be open to SQL injection. You shouldn't put variable data directly into queries, but use prepared statements instead, either with PDO or with mysqli. Includes 

Unit Tests This is probably going to be a major rewrite, so the first thing I would do is write unit tests for it. That way, you can confirm that your new version actually will do the same thing as the original version. Naming The current names don't really tell a reader all that much: 

Readability and Performance Some methods, especially take a while to understand as they are quite complex. If readability and maintainability are concerns, I would write it something like this: 

Further Simplify if statements You could also save some comments and an if-clause if you save the conditions in variables: 

Formatting You should always use curly brackets, even for one-line statements. If you absolutely think that you need to omit them (you don't), be consistent. This for example isn't easy to read: 

Security: Credentials in ENV It is less than ideal to store your credentials in environment variables, as they may easily leak. for example will print all environment variables. Of course, you don't want to allow access to phpinfo to just anyone either, but it may still leak, and not everyone who should be allowed to see phpinfo should be allowed to see the FTP credentials. Security: Directory Traversal which may lead to Information Leak and Limited DOS An attacker can delete arbitrary .docx files in arbitrary locations because you never check the input for directory traversal. The problematic code is this: 

So no, this would not be secure. And there may very likely be more severe problems than the ones I described. But even those are enough to show that there are problems in the algorithm. [*] 

It's really hard to see where what ends. You can fix this very easily with any IDE. Duplicate s It is odd that you ask in your main method , and then call , where you again ask , etc. Just ask once, and create separate methods for , etc. Misc 

User-based salts are managed automatically for you, and it uses multiple rounds of hashing, slowing the process down, and thus increasing the resources an attacker needs to crack your hashes. You can still use a pepper with bcrypt if you want to. For more information about password hashing in general see here. Misc 

Each of the method calls is optional, and it's clear for the reader what the query will return, without looking up the documentation for each method. 

Remove Duplication and further simplifications Currently, your visibility check and your one long echo line are duplicates. You can extract these to functions: 

Although I would assume that that is not actually what you want, as it adds two additional ANDs in case neither phone nor email is empty. It also seems like an odd query in general. You are fine with a wrong phone number as long as the email is correct and vise versa? Also note that you don't actually need , you can just use , it will not generate a warning. 

There are probably more irregularities, but I think the point is clear: A user cannot figure out what exactly went wrong, and sometimes cannot even tell that something went wrong, which will sooner or later lead to bugs. You should throw exceptions on invalid input stating what exactly went wrong (eg wrong action, cannot base64 decode, etc), and check the output of all the functions you use. Invalid Output 

One thing that directly jumped out at me is that it's really hard to see how you make the sounds of different instruments. It seems to depend on the passed in . The call of that depends on the order of instruments in the constant, and that it is in the correct order regarding , and displayed in the same order inside the GUI. It's never a good idea to put that much weight on the order of different lists being correct (because those lists work independently of each other). I would introduce an explicit class, which has a and a (if key is the technical term). I would then pack the whole thing into a class as well (because of my lack of music knowledge it's hard to say how. Some ideas: Could a list of s be part of an instrument? Or could there be s which each own one instrument?).