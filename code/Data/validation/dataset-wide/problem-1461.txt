I got it down to \$O(n)\$; complexity. I'm not fluent in Python, so this solution is in JavaScript, but it's reads fairly easily (especially if you're familiar with C-like syntax) 

Let's bust some myths: ES2015 is not supported in all major browsers I will use ES2015 (commonly known as ES6) in my answer. Everything I tell you is supported by the latest stable version of Chrome and Firefox. Also, I'm fairly certain that most of the features I'll discuss have support in several versions back of Chrome and Firefox. It's worth noting that most of the features are not supported in IE, so if you absolutely must have it, use a polyfill or older tech (i.e. instead of ). I need jQuery for JSONP requests No, you do not. JSONP is a hack to get around the API author's decision to not supply CORS headers (For whatever reason). So JSONP wraps the response with a function call (of your choosing; example), so it becomes valid JavaScript code. Then all you do is append the code to the DOM with a element, and your function is called: 

This User object is different, it doesn't know where the details come from, they are injected from that magical place outside of the object where it doesn't know anything about. This User could have come from a database, he could have come from session, a file, a REST api, or I could have just made it up for testing purposes. So how do you get the details from the database? You use the Data Mapper pattern. 

Cosmetically speaking, you can use the ES6 destructuring operator to make your arguments a bit more readable: 

You are tying yourself to a specific environment, that's not good. A better approach would be to make sure that the class file sits under the path you expect it to, relatively to a file you know where it is relatively to the project. 

Instead of trying to purify the category for the user, which may or may not have unexpected results, you should simply reject everything that does not conform to your level of standard, and let the user fix it: 

Your current abstractions don't really add value to an application. Why would I use your class over plain 'ol PDO? Yes, it should, and I'll explain. When you create an object, it should do one thing and one thing only. Your user object should be responsible for keeping track of data about the user. It's an object that represents a single user in your data model. Your user should not be aware of its own means of storage. A user specifically can come from many places. It can come from a register form, it can come from a database, it can come from a migration CSV file containing hundreds of users to be inserted at bulk. As a result, your user should be storage agnostic, it should not care where the data came from, it should just accept it in the constructor, and work with what it's got. 

In your case, the context is a MySQL query, you're trying to prevent SQL injection. The solution to SQL injection is not validation. It's prepared statements. So: 

See the fetch API for more details. I need jQuery for collection iteration No, you do not. Mapping over arrays is easy. Mapping over objects is also quite easy. I need jQuery for this other thing No, you do not. Unless you need older browser support (Older = IE8 and below), you almost certainly do not need jQuery as a hard dependency. 

All in all, you must improve your code-style. Your code is extremely unreadable and will be hard to maintain in the future. Aside from that one XSS vulnerability, it looks good to me, but again, it's hard to tell just with the code you've given. 

Now, your object can hold an array of other objects, who he's friends with! You can do all sorts of cool stuff with that, like listing mutual friends (since those Users have their array too!), displaying a list of friends on the page, or just figuring out who has more friends. The object is commonly known as a Domain object, it's an object which is part of the Domain Logic or Business Logic, i.e. the actual application, the actual purpose of the application, the part that does the actual work. 

So you see, it's nice to have a FileHandler helper to do some tasks, but it all comes down to how things work together in your general application sense. 

Other than that, if you're already defining all of the CSS rules in your template engine, why not use HTML to begin with? There's no point in complicating things with yet another syntax. Write valid, proper HTML from start to end, and be done with it. 

JavaScript already has a number parser. This will allow values like , , , , etc. All valid Numbers. And it passes your test suite better than the original: $URL$ and $URL$ 

If you're passing information, pass only information, not markup. Alternatively completely generate the HTML markup on the server-side, and just apply it on the client side. There's no point in combining the two, and if done wrong you could cause double escaping issues. Second, don't use as a debug function. Use and use your console. 

Well, it is unlikely for the countries to change much, and even if they do, you might as well change it in HTML rather than in PHP. It really doesn't matter much, there's no point in abstracting these. I'd go with making this static HTML, and save some performance (although probably negligible). 

Also, if you're trying to move to the top or bottom layers, your method will never reach. You should add a check against to not be undefined. 

What if you want to run this function in a different DOM? You can't, you're bound to elements with specific IDs. What if you want just the result? You can't, because your function doesn't return anything but explicitly mutates the DOM. It's unclear from the signature what your function needs to work (i.e. available DOM with elements with specific IDs). Functions normally declare what they need in the form of parameters. 

If a object represents a single User, you would want one instance per actual user you are working with in the application. For example, say your user might have friends: 

Slightly longer version: Don't be a smartass You don't need to dynamically call , it's pointless and unreadable. Just call and when you need it. It's unlikely for the function names to change. 

should only be a property if it's shared between all the methods. You should ask yourself Does it makes sense for this object to remember ? Passing around is perfectly fine. If your function needs a string to do work, it should ask for it in the signature. 

All of the above were reported by my IDE as soon as I pasted your code. Consider using a linter to ensure high code quality. A few other things I spot by reading: 

And have the PHP handle the serving of the requested file. Getting Fancy You can even use and to rewrite URLs like this: 

This is assuming that your original data is in that variable. Please tell me if there's something you don't understand, and I'll try my best to explain. Notice how I'm chaining my calls to map, filter and reduce. Both and return an array, so the chained call is performed on that newly processed array. A fancier way of writing this would be factoring everything out into functions, and then having a oneliner: