Note: it is not final or most optimized version ever, I have tried to show you set of approached you might want to know to optimize your code even further. Benchmark using browser Just open console in your browser and paste following code 

You can use 2 custom attributes instead of one. In this case you should not swap value, just replace it. 

Nodejs and preallocation Lets start with this test where we conditionally switches allocation from static to dynamic. 

field has standard $URL$ for it's numeric value. class property can make some troubles if future, when you'll need to make some manipulations with this list. But in this case it is acceptable solution. there is library called cities_light, it has states and some additional properties. Cons of using it - it require to download it's database (about 400MB) during migration. overuse of property. You should use boolean field and then adopt data presentation on form. Also, you probably wish to separate this huge model into few for performance improvements, but this require some profiling workaround. 

Performance improvements related to approach Interger base For better performance we can split number not by every digit but by set of digits with given base. Look at Number.MAX_SAFE_INTEGER and some math \$ max\_number = 2 ^ {53} - 1 = 9007199254740991 \$ \$ digits = \lfloor \log_{10} max\_number \rfloor \$ \$ base = 10 ^ { digits } \$ Note: base will be lower by one if logarithm gives interger. What I want to say? \$ max\_number \$ can hold \$ digits \$ digits to be able to handle overflowing during additions. What meaning of \$ base \$ ? Currently you are using algo with \$ base = 10 ^ {digits} = 10 \$. Here you are performing modulo operation with base equals 10. Which means you are storing array with numbers that consists of single digit. But allows you to store up to 15 digits. Execute in you browser to find this value (do not forger to take floor of resulted decimal). Look at c++ example at e-maxx.ru for idea how to implement this. I have not found good enough english article, but you can use google translate. Benchmark base \$ 10^1 \$ vs base \$ 10^{15} \$ 

There is no need to make public. and need it but client of your library doesn't. So consider hiding it from him. For example by defining within the class. 

Unused local variable. I would write instead of . Feels more natural. But in the end there should be no difference. You are making no check against exceeding maximal positive value for . Change argument to if you are pre-C++11. Otherwise use move semantics when constructing from . And also possibly add overload anyway. 

It could be useful to forbid copying of objects as it seems there is no use in that. To do that use if you have Boost. If you don't then either explicitly "delete" copy constructor and assignment operator (if in C++11 or above) or make them without defining them. 

You should properly define copy constructor and assignment operator. Or at least forbid them (as already mentioned for ). Consider adding other constructors. For example from a range of elements of other list (by positions or by iterators). 

It would be cleaner if would be set to (if in C++11 or above) or / (otherwise). There should be no use for default constructor anyway. (See below notes on .) In fact use of this constructor requires type to be DefaultConstructible while there is no need to require that. 

Instead of writing to use exceptions. There are also other means (like returning error code). But outputting to is of no use. (And seems more adequate anyway...) in loop condition is risky. Once you change to () (as commented above) for would wrap around and result in maximal positive value. The loop would be go crazy (although it would not be infinite). Instead of that you could start with . In loop use rather than . On modern compilers with integers it doesn't matter really. But it is cleaner to write so. And could make a difference if would be an iterator rather than integer. So it is better to have good habits. You could extract the loop fragment to separate () method which returns of given position. It would make code somewhat cleaner. And also you could reuse the method in other functions that I recommended to add (in comments above). You should first store in a local variable. Then set to . And only then the local variable. Current code uses of already deleted object and sooner or later will crash on that. I would write instead of . Feels more natural. But in the end there should be no difference. This method is badly implemented anyway. For example on a list constructed with the single element constructor calling will actually the node from but will never update member. Maybe changing the condition to (and next to ) would correct it. But since the idea of is likely wrong this method would change anyway. 

UPD: With single attribute you should create singleton, which will handle synchronization. I had try to draft singleton, but it is not so easy for me. It should be responsible for removing duplicates from task queue and watching on data consistency. 

Theory Fist of all check this article about memory management, it will help to find leaks if any. Look closer at this part 

You can find full list at codeschool At least you can replace your div#some_id with section#some_id which brings more semantical meaning. Если можно, я буду писать на русском (: 

Complexity Sequence definition $$ F_{n+2} = F_{n+1} + F_n $$ which means that your complexity is \$ O(n) \$. Matrix definition $$ { \left ( \begin{matrix} 1 & 1 \\ 1 & 0 \end{matrix} \right ) } ^ n = \left ( \begin{matrix} F_{n+1} & F_n \\ F_n & F_{n-1} \end{matrix} \right ) $$ As you can see with matrix definition we can improve complexity using exponentiation by squaring which tells us that $$ A^{2n} = A^n \times A^n, A^{n+1} = A^n \times A $$ Which means that complexity using matrix definition is \$ O(\log n) \$ Big integers Fibonacci numbers are fast growing sequence, so in order to store values you have to use arbitrary-precision arithmetic. 

You can modify example above to return tuple with 2 params: subtree and number of nodes. In this case you should not evaluate number of nodes on each iteration using . Can be done like this: 

As you can see, is much faster than implementation. Actually, if you are using cpython you do not really want to reinvent standard library functions because they are pretty nice optimized by c compiler and you code will be interpreted instead of compiling. In case of pypy you probably want to make some research, because JIT interpreter have a lot of different corner cases. 

Use member initializer list instead of assigning to members in constructor's body. It would be cleaner if would be set to (if in C++11 or above) or / (otherwise). Change argument to if you are pre-C++11. Otherwise use move semantics when constructing from . And also possibly add overload anyway. 

in loop condition is risky. Once you change to () (as commented above) for would wrap around and result in maximal positive value. The loop would be infinite. On the other hand note that alternative results in infinite loop for being already maximal positive value. (Which however seems less likely than being .) In loop use rather than . On modern compilers with integers it doesn't matter really. But it is cleaner to write so. And could make a difference if would be an iterator rather than integer. So it is better to have good habits. 

There are also other possible extensions. For example you could add allocator support. Or allow in-place construction of elements. But those are more advanced topics. Maybe save them for later. 

As you noted yourself your iterator differs significantly from what C++ considers and iterator. This means in particular that it will not be usable with any STL function. Or other libraries that use "normal iterators". As a side note I will mention that makes it much easier to write proper iterator. But it requires use of Boost. With your current design as it is how will you know that the iteration ended? There is no method in that says that. With your current implementation (of cyclic list - see comments in ) any iteration would be infinite unless you would count elements yourself during iteration and stop at . 

Second quote sad that it is enough to be unreachable from so called roots objects to be collected with garbage collection. So if you follow all recommendation and memory still leaks, than there is one of problems: 

Here, you will receive which is not very informative, probably you would like to make your exceptions for such situations. Performance of string concatenations As you can see from this post, most efficient methods are using , and list comprehension with . I recommend you to rewrite your method to use list comprehension and make all required checks in the beginning of the method. Sanity defaults 

Binary power improvements Well, you can improve module operation, full description can be found there $URL$ 

IMHO: first way is preferable, because you can see objects signature just by looking at constructor with no need for overview whole source file. Just don't forget to sort methods and properties in alphabetic order for quicker search (it really helps, do not ignore). 

Improvement You don't need to make loop at all. You need random generator that will provide 2 values at each iteration: 

Code as is Constants should use upper case notation. should be . If it is not constants it should be assigned from constant. One more hard-coded constanst can be found there: 

But, as you saw before, you have to optimize frontend and backend in different way. How to solve it is up to you. 

But, memory get free only after 3 minutes in my Google Chrome 43.0.2357.125 (64-bit). I was looking in htop, so chrome could free objects instantly, but return to system only after 3 minutes. Profiling If everything looks impossible, you can always try experimental way, using profiling. There is awesome article about profiling in Google Chrome also Firefox Developer Tools. I have applied chrome heap profiles for my example, and it says that data object doesn't exist in window scope any more after pressing "delete" button. Hopes it will help. 

Consider having also a which uses and returns from . This would allow to iterate over object. With some template magic this could be done with single implementation. 

From implementation it seems to be a cyclic list. Was this intended? I don't follow the idea behind node. I think that it is not needed. Not to mention that it's value could be undefined while it will show up during iteration. The class would be a bit more usable if you could add element at arbitrary position. Given by integer (to make your design consistent) or iterator (to be consistent with previous comment). The class would be a bit more usable if you could remove element based on iterator. Or else allow the iterator to return it's position as integer. But remove by iterator is more in line with C++ (STL) style. The class would be a bit more usable if it allowed also iteration. So should have a overload returning iterator (as commneted above). Size in C++ is usually expressed using type. So should be also positions in your case. There should be a default constructor making an empty list. 

Consider making it so that it cannot be used for conversion. Add also second argument being count of initial elements. And default it to . It would make the constructor a bit more flexible and little cost. (And also it will match typical STL container constructors.) Change argument to if you are pre-C++11. Otherwise use move semantics when constructing from . And also possibly add overload anyway. Use member initializer list instead of assigning to members in constructor's body. 

parameter is just a length of the , so it can be computed in the method. Because method is not the static method, you already have initialized class instance so you can use array received in method in case if the user does not provide to the method itself. For an example, you can write something like: 

Then continue refactoring method be method, you'll probably spend a lot of time, but you code became much easier for reading and making changes of any difficulty. As you have constructor, all methods should in it 

Garbage timeout Look at dummy example of garbage timeout at fiddle. I'm creating array of 30M elements of , that are binded to root object - window. 

You will get with keys of your letters and values - their positions in the letters iterable. So you can find out position and find is character found in your characters set with 

Fixed size value in binary file It is not a problem if you have binary file with fixed size data. In this case all you need is to copy your input file into output (or any other way of allocation equal amount of data) and then make to next value you need to write. Maybe it will be faster to change reading curstor instead of writing cursor, it this case you have no need to preallocate large sized file, just add to the end off file. Varies size value in text file Have no idea how to implement than in memory and perfomance efficient way. So if you can make some restrictions on input data, let it be binary file, in other case try to find out some other restrictions that, perheps, give you some advatages. BTW: if it wont be critical you can try converting file from text to binary for transposing and back to text after that. Explaining Lets look at the followig matrix $$ A = \left[ \begin{array}{ll} a_{11} & a_{12} \\ a_{21} & a_{22} \end{array}\right] $$ $$ A^T = \left[ \begin{array}{ll} a_{11} & a_{21} \\ a_{12} & a_{22} \end{array}\right] $$ Your source file contain matrix \$A\$, while your destination file should contain \$A^T\$. To write data into destination file in direct order you should jump over source file to read each element from current column.