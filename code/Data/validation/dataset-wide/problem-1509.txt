Couple things to look at here. First and foremost is ssl. If your server is hosted on https, then you can be assured that all communication with that server is already encrypted. It doesn't matter what the client site is hosted with as when it initiates communication with your server, your server dictates the terms. SSL support is widespread so you can be 99.9% assured that your clients will support it. Further to the SSL point is that major players like Google are pushing for an https only web. With free SSL certificates available from Let's Encrypt, there's pretty much no reason not to be on SSL. You're looking out for everyone's security by requiring SSL, and it's best to be at the forefront of this. Ok, the rest of this is assuming an unencrypted http connection. You don't provide many specifics on the initial authentication where the server provides the UUID to the client. If you aren't hashing this initial authentication, then the credentials are exposed and no further security will matter. I recommend you drop the client id from the post data. Since you have the UUID as a token, the client id becomes redundant. It's a best practice not to transmit any part of any user credentials after authentication because tokens can easily be changed, whereas credentials cannot. Credentials require a person to change them, whereas a token can be obtained automatically. Your description mentions that you're hashing the post data with a private key, so this isn't critical but is still a best practice. With regards to your 'private' key, do you perhaps mean a 'public' key? Typically a public key is distributed for encryption. This allows for anyone to encrypt their data in such a way that it can only be decrypted by a private key. This private key is locked away on your server where it as safe as possible. This is how all SSL communications work and why it is so secure. If you're not going to https, best to mimic what is already best practice. For your code, I have a bit of a concern with your hashing. The description states that you're hashing the entire post array with the private key. While it indeed look like you're hashing everything, you're only setting the result to another key in your array. That means that all the content in your array is not encrypted and can be accessed. That's great that you can verify whether it's been tampered with or not, but it won't stop someone from stealing the data; in fact it will have the terrible result of helping someone to break your encryption. You have handed them the code and the result; a Rosetta Stone for your private/public keys. To fix your code, hash the array just before transmission with a public key and set it to . Then send the hashed to the server where it can be decrypted with the private key. To wrap things up, you have some good parts here. You've identified that you need a unique UID for each authenticated user, and you've got some additional timestamp and one-time use checking. I'm not going to touch on those but rather leave you with a basic checklist of things to consider. You can then run through your own process to see if you've missed anything. 

It's a simple concept that will reduce the amount of work the browser has to spend on your handling. Adjust the timeout interval based on what kind of response time you need. The other thing you might want to consider is using css for your width checking instead. I notice in your example that you're setting a boolean based on the width of the element. You can use css media queries to adjust the styling of elements based on certain parameters, including screen width. If you can use this in some of your use-cases, then it will reduce the amount of watchers you need to register. 

Lastly if you're interested where the term debouncing comes from, it comes from electronics. When you push a button it actually bounces a bit before it settles. The bounce is very fast and short lived but at millions of checks per second it's easy for a microcontroller to detect. To prevent the bounces being interpreted as dozens of quick button pushes, the programmer adds a delay during which button changes are ignored. 10-50ms delays are typical. 

Seems like a simple straightforward solution. Nice job using pushState for browser history. Here's a couple quick things I noticed. I would put your index script in the head tag. Most browsers don't care where it is but it's still good practice and it makes reading your code easier. In your ajaxapi.php file you've got the './' path prefix on your require. You don't have this elsewhere so best to be consistent with your paths. I've also run into problems with this prefix before when trying to adjust the php include path. It's not likely to be an issue for you but it does go to show that you'll have more success without it. Since you don't need it anyway, I'd drop it. You don't need the 'var ActiveXObject;' in your 'navegacion' function. Doesn't look like it's being used. Also not sure what the purpose of 'var urlPath = dashboard;' is in the same function. I never use strict mode though so maybe it has something to do with that? I've never had any trouble on any browsers with ajax not in strict mode, so I would consider simplifying your code. Depending on the size of the rest of the content in your template you may want to consider dropping the js in favor of a pure php solution. You've already got the code in your index file. The js is cool but if the browser is caching most of your content anyway, it might be better to simplify your application and just reload the index page each time. This would negate the need for your back button history management, especially if you used GET parameters instead of POST. Typically I use ajax for small content updates relative to the rest of the page, or if I want to preserve some other data. Without knowing more about your app though, it's hard to say what's the best tool for the job. 

In case someone is interested, here's a follow up to MarcDefiant's comment about using . It's fast if you're already using it for getting the file list as well. Here's a snippet from the in my GitHub filebrowser project. It's certainly not on the same level as Flysystem but I enjoyed working on it :). 

Good clean code with good object structure; you made a good transition from php objects to js. There are a few tiny things though to do with consistency you might want to clean up. You don't have semi-colons after all of your object functions. JavaScript isn't all that picky about them but good practice is to be consistent in whichever method you use. This is especially important in js since not all browsers parse in the same way. By being consistent you'll ensure your code either works or it doesn't, and you won't have to track down elusive bugs. You don't always declare your 'for' loop variables using the 'var' keyword. Again not critical but it would be best to be consistent. 

In terms of the php code itself, the only thing I notice is your use of the $_POST superglobal in your class. This isn't wrong per say but I typically try to avoid use of $_POST in my objects, and instead pass the data in via parameters. Keeping all of your $_POST access in the same place makes it easier to manager changes, especially this the contents of $_POST is so easy to change. Same is also true for $_GET and $_REQUEST. The same is also kind of true for the $_SESSION variable. It's not as important where it is, but stick to access within a limited set of locations. Here's a few points to consider in terms of how you've constructed your class. They're not really php things, more good object construction practice. Make sure you're always returning something from your methods. In many you have a return if things go right, but nothing if things go wrong. This will result in a NULL being returned but it's better practice to define this for reliable and consistent operation. To take a more MVC approach, and to make your code easier to change and maintain, you shouldn't be echoing your errors in the class. Rather set the message to an error variable that can be retrieved by the calling code if needed, and then return FALSE. Echoing the error as it happens can be good during development but I recommend against it for production. If you still do want to see the error, best to handle it in the calling code so that you can easily change how the error is displayed. You could use a debugMode flag in the class if you want the best of both. Your code indenting could really be improved. 

Really your question boils down to whether or not there is a better way to set a custom function. That's hard to say because your approach will work fine. Really any kind of answer your going to get is largely subjective. For me I tend to avoid the prototype method for objects unless I'm overriding or extending some other function or object. You started on the right track with your declaration of the SliderControl object; you can incorporate your prototype into that method declaration as well to greatly simplify and encapsulate your code. It could use some cleanup I'm sure but here's my quick take. 

Now above and beyond your initial question... To make your slider more portable (and practical) you should also create the dom structure in the object so that all you have to pass in during initialization is the element you'd like to put it in. You'll also want to add the ability to set a default value, in case you're loading and editing preset data. I would also suggest removing 'actionWhenActive' and 'actionWhenSet' and replacing them with your existing 'action' and a new 'actionSet' function. You can check if one or the other is null or undefined to give you the same effect as the booleans. This will also give your slider the ability to perform both operations (ie displaying a value, and then saving it when done). 

Your code is very to the point and efficient. I like your method of using the global event which the elements 'register' for. While the browser likely does something similar for its event handling, your method puts you in complete control and ensures efficiency. I do have a couple suggestions though. First and simplest would be to add some debouncing to your event handling. If you're not familiar with this, the concept is to add a delay on your handling to prevent excessive processing. Something like this. 

Based on your example I would suggest you spend some more time on plain MVC before you try to work with a service layer. Something else to keep in mind is that the requirements of the application you're building determine whether you even need a service layer. In your example you don't. Actually since you're not really retrieving any data, your example doesn't need the model either. The simplest way to describe the relationship between the controller and the view is that the controller does all the work and then sends data only to the view. The view then takes the data and displays it any which way it wants. This is valuable because it means you can make serious changes to one or the other or both without there being much risk of the changes causing undesired effect. It makes maintaining and expanding code much easier. In your example you don't really make a clear separation between the view and the controller as far as the actual execution code goes. I would take a hint from MS.Net MVC and make better use of objects to separate the roles and interfaces of each layer properly. Take this over-simplified example based on what you provided: 

Let me first say that any answer you get here is going to by biased by each person's personal preference. What you're doing isn't dangerous or breaking any rules, so it's 'fine' as far as that's concerned. So with that in mind I'll give you my opinion on a few things to consider, and you can decide from there. Returning true and false to me is a bit old-school and doesn't take advantage of php's flexible variable type handling. I typically return FALSE if there's an error, and return the results if not. The calling code can then just do a and you're good to go. The other thing to consider is the format of your return data. One method is to dump it into some predefined objects. This is a very clean approach that makes code reliable and easy to read, but it isn't always that easy to implement. I would only do this if you're going to be creating a large and complex project. If you've got a simple project, then returning arrays is the fastest and easiest way to go. It's a little less reliable if your database is likely to change, so watch out for that. I typically massage my arrays in the method prior to returning them. Since in your example you're breaking out specific operations, you can do custom data formatting in each. This is encouraged since it will make your calling code much easier to create, read, and maintain. Lastly I wanted to talk about your error handling. What I prefer to do is return FALSE on error only, and return data every other time. You've chosen to return FALSE if no results are found which makes a bit of sense as it will simplify the calling code. The change I would suggest you make is to remove your method and instead set the error message to a class variable that can be retrieved by your calling code. Your should then return FALSE after the catch. This will allow your code to fail more gracefully and also give you more control in your calling code as to how to handle the error (think MVC). Of course I am making some assumptions as to what does. I see you have an variable so perhaps you're already on that track. If you are then I recommend always returning FALSE from the method after an error, and adding and methods to your class.