You are using both the and operators for assignments. I'd recommend you pick the one you prefer and stick to it for consistency (for info, the community standard is to use ). returns a data.frame so was not needed. Your data is only numeric (even integer) so you could have chosen to store it into a matrix rather than a data.frame: . Matrices can make many operations faster, though not the ones you are using here. 

Finally, a recommendation. Be careful using single characters as variable names, since R already uses a few of them for built-in variables or functions. You could for example confuse your variable for the function for transposing data. Other single character variable names used by R that come to mind are (concatenation), (quit), (TRUE), (FALSE), (inhibit). Anyway, it is always better to use descriptive variable names and that usually implies more than one character. 

It is more clear and less error prone to first make the search in the table and then fallback if you don't find the character. I would use an empty for the search, this might be controversial: 

is a thing I would avoid. Since the program is so clean and self contained, I would keep it as abstract as possible. Maybe in 5 years there will be an OS which could run python happily but which does not have a 'clear' command... what a pity if your program will break for such a triviality! And if you insist in using a system call, wrap it in a function, don't write it twice! 

Then, it is also a good idea to write a separate function for each of the fixes you have. It makes your code easier to test and reuse. Also, when using appropriate function names, it makes your code self-explanatory and can replace all the comments: 

I would only have put the input directory in its own variable so you have more direct access to it if you decide to change it later. Also, you could have chosen to and used within . 

I would use a matrix multiplication. It is both efficient and leads to much shorter code, as you can see: 

Note that it's better to use instead of to check if a character is whitespace. If you need to count how many times each character occurs in the string, simply replace with a which maps each character to the number of times it occurs (as shown in @TobySpeight's answer). 

Check the length before sorting It takes constant time to determine the length of a string but is \$O(N\log(N))\$. If the lengths don't match then you don't have to sort. 

Not only is this an opportunity to refactor that code into a function, but the numbers and (arguments to here) appear multiple times in your code with the same purpose. Instead, define a constant (e.g. ) and use that constant. This means that if you ever want to change that value you'd only have to change the value of that constant once (the value of the ) instead of trying to find the literal all over your program. Use meaningful comments Your functions are commented as so: 

The output is a matrix where each row contains the distances between one main station and all the local stations. Next, we go from a distance matrix to a weight matrix: 

Notice how I improved your code regarding the use of , since you had not accounted for the possibility that your user does not have the package installed. If you want to make the package a requirement, then calling is prefered to , the blog here $URL$ offers a nice explanation. If you absolutely want your function to allow to pass "minutes", "days", etc. (though I would stay away from it), you can do: 

You are using the float value -1000.0 as a sentinel to represent null values. In a real project this is a very dangerous design choice! Your program will give unexpected result if -1000.0 is a value coming from the interpolation or from user input. To overcome this issue you could use two varibles and to mark the interval of non null values. Otherwise use a FLT_MAX instead of -1000.0 as a sentinel. This is very unlikely to cause problems. 

I think that the data structure and the organization of the code is far from optimal. You are making an interpreter with some sort of precompilation (the function which searches for brackets). The data structure used to store the "compiled" code is bloated. You have a doubly-linked list for something that will never dynamically change. The pointer is never used. The pointer is rarely used. What I suggest: 

This also makes your code robust to the special case where would have a single column (I let you see how your code would break in that case...) The second alternative would be to replace the double loop with a call to . It is a little slower but see how short and elegant your code becomes: 

What is slow is to create . Take the example where is 298,716,239: you are asking R to create a vector of nearly 300 million integers. It chokes. Instead of looping over sequences created in memory, it is easier to just keep the current value, increment and limit in memory. See for example: 

A couple of years ago I wrote a pair of class templates to encapsulate specifications which have one or more of a minimum, typical, and/or maximum value, e.g. on a datasheet like this one for the 741 op amp: 

But there are a lot of instances where needs to be replaced. At the very minimum you should define 4 as a constant and use that constant in the code: 

I frequently design classes which model an object that has multiple submodules of the same type. For example, I have a class for a Printed Circuit Board (PCB) which has multiple subcircuits (I will call them "ports"). The class for the PCB () uses a container (e.g. ) as a member variable to store the subcircuits. Client code needs to be able to iterate over the ports to query the state of each port, control the port, etc, so I need to provide iterators for the ports. In general the board may have multiple subcircuits of different types (and therefore multiple member containers that need to be iterated over). For example, the class might have a for the ports, a for a data bus of voltage signals, etc. Thus I cannot simply provide and member functions -- I would need to call them something like and to differentiate the container of objects from other member containers. Such non-standard names would prevent me from using range-based for loops (which depend on functions named and ). I searched around on Software Engineering SE and Stack Overflow to see if there was a standard solution for this, and I found a couple of interesting suggestions to create a container class that privately inherits from the appropriate standard container (e.g. here and here) and makes the accessor functions like public. However, this seems to go against advice to favor composition over inheritance (e.g. here and here) when composition is possible. Below is a solution for a class that has multiple objects stored in a container called that uses composition instead of inheritance. and are simplified from the actual code, and for this review I'd like to focus mainly on the container class and the related accessor functions for it in . (Note that the first port is numbered 1, not 0, since that's how the ports are numbered on the physical board's schematic.) Board.h 

(added: the difficulty to achieve a DRY result is an indication that the variable could better be an integer in which can be used as an index in the "OX" string.) Two. This: 

I understand you are asking for a function to check if a point is on a line. The question itself is ill-posed: because the representation of points and lines on a computer is only approximate and if you approximate a point on a line you probably get a point which is no longer on the line. A typical example is to check if the number satisfies the equation . Even if we expect to find a solution to this equation (because we use the real numbers as mental representation) there is no floating point number which solves such equation. Hence it is almost always wrong to check for equality of two floating point numbers. In this cases what you are looking for is an appropriate approximation. So instead of looking for one is happy enough to solve . The small value is somewhat arbitrary, and can depend on the problem you want to solve. So my suggestion is to implement a function which computes the distance from point to line $URL$ and use it to check if the distance is small enough. There are many other factual problems with your code. Here: 

For the conversions, is intended to be specialized by users if desired for specific time periods. Here is a little demo program demonstrating the conversions and a specialization of for a time period corresponding to a day: 

I'm looking for suggestions regarding the class design, naming, etc. Also, a few specific concerns that I'd appreciate reviewers to comment on: 

I've developed a set of functions to convert a or to a or insert it into a using . They are intended to be part of a larger library of conversion functions so I've included a few additional functions in the library for demonstration. There are two versions of each function: the normal one in the namespace, and one that uses a compact form of a string in the namespace. For example, the ratio is normally converted to the string and its compact form is . Not all conversions have a compact form, so in those cases the functions in simply call their counterparts in . Conversions of s take advantage of the conversions for s if the period ratio matches a typedef provided by the standard library. Similarly, proper conversions are implemented for period ratios which match a typedef provided by the standard library (e.g. and ). Here is the header file of functions, convert.h: