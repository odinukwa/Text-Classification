Since you know have complete class information, I have updated my answer to give more specific review comments on your code below. My comments are within multi-line comments. 

What if property does not exist? Should you throw exception? This condition would likely mean caller is accessing this class in unexpected fashion and should probably fail loudly. 

Start with the query and work backwards. A poorly-written, poorly-performing query is not a good foundation to build on. Here is your query (re-formatted to more readable) 

Look at ways to minimize code nesting and code path. Inverting conditions, early exits, and removing unnecessary conditions are all strategies in keeping your code nesting/branching to a minimum, meaning you have less complex code that is easier to read, maintain, and test. 

This sort of code is overly repetitive. Consider a method that can draw X number of cards at a time. Your class should probably contain all the methods related to dealing cards. Wouldn't this look a lot nicer? 

This minimizes your number of code paths making your application less complex, easier to debug, and easier to maintain. Actively try to design away conditions, as they are usually avoidable. 

I don't understand the need for two queries. They seem to be retrieving the same exact result set, so why query twice? 

I guess I am not sure what the function is intending to do if the validation happens before you even call that code. The essence of your problem is that you need to handle different events on an arbitrary set of fields that need to trigger a validation event. That means, all you really should need to do from an event binding point of view is something like this 

To present this in terms of operational complexity (Big O). Your current methodlogy does this (here n would represent number of layers) 

See link above in comments for some more elegant solutions. So I am not going to focus on algorithm, which I think can certainly be improved. Some thoughts on your code itself: 

I like the fact that you seem to want to provide good comments to your code. I would suggest you take it to the next next and actually use proper PHPDoc comments. Working with your class in an appropriate IDE will become even easier with proper doc blocks in place. 

I am concerned that you have config files buried within your code base. These typically should not be part of your code package (other than maybe providing a template). For example, you should not be including DB credentials within your repository at all (and you absolutely should not be using DB credential for an application EVER) (note to other readers, this was seen in GitHub repo, since code is not here). You have you DB credentials out on GitHub!!! Change them now and get this file out of your repo! 

here is, in essence, a class constant. Don't hide this value declaration away in a method, declare as a constant for the class. 

Use single class for these options to use as a selector rather than your convoluted id-inspection approach. Your approach of storing info in the id adds no value and potentially makes it more difficult to work with these items as a collection. Also, consider storing an actual string data value in option value. You are getting nothing from storing this whole long URI in value that only differs between options based on the actual data and time. That might have your HTML looking like this. 

Don't nest your conditions like this. Validate the input up front and fail out if need be. For example that might look like this: 

What are you building here? Are you building a framework or an application? Your file structure of most everything living in an directory seems at odds with your decision to have some classes nested underneath labelled within a library. If you have a framework, should that not exist outside the construct of any given that that leverages the framework? I think you could benefit greatly in continuing to understand the proper use of Composer with regards to library/dependency management (including frameworks). If for nothing else, it would be useful to understand good patterns around structuring your frameworks/libraries/dependencies relative to applications that use these dependencies. You might ultimately find yourself building your framework as a totally separate codebase from your actual applications that use them. This is a proper separation of concerns to allow you to maximize re-use of the framework parts. Additionally, you should really look at PSR-4 compliant structuring of your code to allow for autoloading. This prescribes a particular scheme for structuring your code and naming your class files. You are almost there, but your classnames are wrong. 

This should be the last line in your constructor, after you have validated the connection (and throw exception in cases of errors). 

Why are you storing authorization info (your trusted users array) in this file? Why should this be hard-coded here? Do you really want to have to change and redeploy this file just to make an authorization change? Why are your randomly choosing a "trusted user" for use in this script? This logic seems odd. 

Note that we are pushing the render operation down into the InfoWindow object where it probably belongs. Also note that we have removed the hard-coded template names from this class. Maybe they truly belong here, in which case maybe they should be class constants rather than buried in a method. But, depending on how you are using these InfoWindows, perhaps this should be passed through as configuration. My comments on would be similar to those for the . Namely, I would rather see a class like structured like this: 

Really think about whether magic getters/setters are what you want here. As noted above there are a lot of trade-offs in terms ability to validate data, make properties truly private, etc. that come with giving property-style access to protected/private properties through magic methods. Again for your use case here, I don't know why the properties wouldn't just be public, because that is exactly how you are treating them. 

Really good thoughts from @200_success so I won't rehash the prepared statement and eliminating thoughts, which I agree with fully. You do also seem to have a cross-site request forgery (CSRF) vulnerability which you should be aware of. Right now any attacker could simply make arbitrary posts against your endpoint, causing email address to be added to your database. Typically, this is mitigated by using a session token placed in a hidden form field and validated against when POST is made. 

To see this might be used, let's take a step back to where you bind your event handler for the dropdown menu (something you are not showing in your code) That might need to look something like this: 

Pay close attention to the advice from @janos regarding your SQL injection vulnerability. I agree with that assessment and so won't he-hash it here. 

You have unreachable lines of code in . When is called, any lines of code after that call in that code path will never be reached. You should never have unreachable lines in your code. 

I would consider using SPL's RecursiveDirectoryIterator and RecursiveIteratorIterator for this. This would eliminate the need for the function itself to be called recursively (which is generally a good thing since PHP does not perform tail call recursion optimization). 

If you were following this standard, your function definitions would be in a totally different file. 

The two different code examples are not the same in that the cart array is build differently in each. The first would build a numerically-indexed structure at like this: 

I honestly don't think this code is a good candidate for refactoring unless you are wanting to replace with an ORM of some sort against which you can simply make calls like , , etc. If you look at the other answers here, where refactoring is attempted, you will see examples that are (IMO at least) more complex and harder to understand than what you have now. They also don't do things like handle the various DB response which will differ greatly between SELECT, INSERT, DELETE, and UPDATE operations. You potentially need to evaluate the DB response differently for each of these query types to determine if operation was successful. If you had the proper error handling for each of these scenarios in a common function, you would get some complex conditional branching. My main comments in reviewing this code are: 

I will simply build on answer by @Flambino who gives strong advice on code formatting and some of the math concerns. I would like to add a few more thoughts: 

I don't see what API key is doing in this class, as it is not used anywhere. I would also question why an API key would migrate as far down the call stack as where this store probably lives. Typically, if you are exposing a service for 'ing, 'ing, 'ing, 'ing data in a store, end user authentication via a mechanism such as an API key would be one of the first things done in validating the request. If the key is not valid, you should fail out the request with a 403 or whatever long before you get to the point of trying to set up data storage objects such as this. 

If you are going to use doc blocks (something I would encourage), you should, at a very minimum, include annotations for your public methods (but ideally for all methods - this helps you when working with the class in a modern IDE). 

Just remember that as soon as you modify an array assigned in this manner, you remove the ability for PHP to perform it's behind the scenes memory optimization. But really you should not be relying on this anyway, as IMO it is bad coding form to be relying on some hidden, undocumented and possibly subject to change optimization for your code to be working in the best manner. Alternately, instead of associative array for data, why not use an object (even ), then you are always working with reference to the object (unless you specifically clone it)? For example: 

? I will skip similar comments about other method names throughout classes, I generally think there is room for improvement to more meaningful/specific names. I would say that perhaps the most problematic name is Does this delete the whole file? (no it does not, but you wouldn't know without reading into the method signature or documentation) 

This reduces your problem to only having to figure out how to populate the value into , not trying to determine this directory when you are at the point of trying to conditionally load configurations for various components in the application. This could be hard-coded (not ideal) which is quick and dirty, but you might consider an approach that allows you to conditionally determine the include path. For example, if you control the environment, you could modify your Apache config to inject an environmental variable holding the include path or, if missing, perhaps looks into a file that you specifically deploy onto your shared host to determine how to get to that include path for the host you are on. So perhaps something like this near the beginning of your application bootstrap process. 

To me the code is a little hard to read in that you have an initialization function, metadata around events to be bound, the binding function, and the callbacks all at the same level in your object. How is this any better than just defining all the event bindings within a typical block? At least there, all your code for each binding is kept all in one place, rather than spread out across the different properties in this event object. To me, something like the following is simply clearer (and would actually be more concise in terms of total characters needed to implement the functionality): 

Or, if you don't want to refactor then combine the conditions in a single filter. This may or may not work depending on the my very first comments around method logic. 

The nice side-benefit to this is that now your solution becomes scalable for any number of data elements. 

Why would your main application class ( as currently named) live in a directory? Don't confuse main application functionality with models used within the application. 

Don't output errors directly to standard out (browser) from within a class such as this. This class is designed to connect to a database, not output to the end user. Leave the error messaging to logic further upi the call stack that is better positioned to provide a more user friendly message. You current approach can also be a huge security vulnerability. 

You have both CSRF and XSS vulnerabilities in your code. You should be using form tokens as mitigation against CSRF (this also means you need to be using sessions). And you need to consider cleansing text input before insert (for example failing if you detect tags or other XSS vectors), and at point of rendering (where you are also not even rendering proper HTML entities.). 

There is no reason to ever perform two queries in . The first select is just a wasteful query against the database and it seems your code just assumes the record will exist anyway. You can go directly to trying the update (after validating and sanitizing input of course), setting the new values based on the old value. That query might look like the following (of course you should parametrize this): 

There is a distinct difference between sanitization and validation. You seem to be using the concepts interchangeably. I would say this class is a validation class not a sanitization class. 

I agree with comment to post about potentially investigating web sockets. I guess the decision on what approach fits best would really be based on how frequently your data changes. Even in thinking about the AJAX approach, I would say the same thinking also applies to how you decide to call the backend. Does each component in the UI have data that changes with different frequencies? If the components are highly related perhaps it makes sense to just call a single service endpoint every X seconds to get a single data feed you can use to update. Conversely, if these outputs all change with different frequencies, maybe they should each have their own polling intervals. In the latter case, you may even go so far as to begin to think of applying a more proper component architecture in the UI, where each component has it's own view definition, data bindings, etc. There are a number of UI/javascript frameworks out there that are designed specifically for this use case - React, Polymer, Angular, etc. That being said, what you have works, and so long as you do not have a bunch of browsers open and you have your backend scaled appropriately, the number of queries you are making against the database should not be problematic. Since you are loading each component asynchronously now, you might even consider adding a "jitter" to your calls so as to make the query load less spiky against the database. For example: