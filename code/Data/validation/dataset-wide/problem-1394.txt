Before I go into details, I feel obliged to say that your project is fairly ambitious for a C beginner. I have several criticisms, which I hope you will receive as constructive, but overall, your code makes me suspect that although you are new to C, you are not new to programming in general or to multi-threaded programming in particular. If I am mistaken about that then please take it as a complement. Data races Your code contains some data races involving the manipulation and testing of students' variables. The main thread modifies these as a result of command input and at shutdown, and each student's thread both reads and writes that variable for its own student. Some of the student threads' accesses are performed under protection of the mutex (those in functions from gym_routine.c), but others and the main thread's are not. Since these variables are written to by at least one thread each and read by multiple threads, every access must be appropriately protected once the per-student threads are started. You've apparently chosen to use a mutex for that, which is fine; you just need to be sure to protect all accesses. Busy loops You use high-iteration-count busy loops for making the and functions consume non-trivial time. At minimum, you'll need to greatly reduce the iteration counts when you correct the data races there, as locking and unlocking mutexes is costly. Really, however, you ought to choose a delay mechanism that doesn't consume CPU. provides one such mechanism, with the advantage that another thread (e.g. the main one) can interrupt the wait if needed. That could be made to work in concert with resolving your data races, by giving each student its own mutex and condition variable to protect access to the student status. That would also allow you to set the durations of the workout and rest times in terms of machine-independent time units. Unnecessary dynamic allocation There are many good uses for dynamic allocation, but it's complicated enough and easy enough to mismanage that you should not use it where you don't actually need it. In particular, just because you need a pointer to something does not necessarily mean that that thing needs to be dynamically allocated. It's not uncommon to use a pointer to an ordinary local or file-scope variable, obtained via the operator. In your code, this applies to most (but, oddly, not all) of your synchronization objects. For example, I recommend changing the member of from a pointer to a plain . (It will then need to be handled slightly differently, but mainly the dynamic allocation will go away.) Similarly, there is no need to dynamically allocate your object. Just declare an instance. Input handling In your main input loop, you should account for the possibility that returns (indicating end-of-file before any input is read, or error). On the other hand, you probably do not have to account for because always copies at least one character from input to buffer upon success (provided you specify a buffer size of at least 2). Literal characters in the input could conceivably trip you up, but if you need to accommodate those then you need to handle input altogether differently. If you mean to accept only one command per input line, then I'd recommend consuming the balance of the line, up to the next newline, at the bottom of each iteration of the input loop. The one thing to watch out for there would be input lines containing a newline at index 1, which your current code will reject as invalid, but for which the trailing newline will already have been read. Issues with headers and #includes As a matter mostly of style, each of your headers should those headers defining constants and identifiers used directly by that header, if any, but not any other headers. (Each C source file should do the same.) Do not otherwise have your headers include other headers; it is unnecessary, and under some circumstances it can be harmful. For example, given it's current contents, your is right to include and , but there appears to be no reason for it to include . On the other hand, I would encourage having it include for the definition of , or else to combine those two headers into one. As a separate matter, it is a good idea to ensure that each source file and header that s headers includes them in the same relative order. This is less important for standard library headers, but there's no good reason to distinguish. It can be the case that changing the order of headers changes their interpretation (which would be a weakness of one or more of the headers involved, but sometimes that happens). In your case, your files differ on the order of and . 

... does not perform well. Regardless of the details of the palindrome-checking algorithm, it is performing far more work than it needs to do when used this way. In particular, it is very wasteful to test every deletion candidate, and it is slightly wasteful to test separately whether the full string is already a palindrome. For each string it tests, your code may perform work proportional to the square of the length of the string. Instead of testing every possible deletion, simply scan each test string from both ends until you find a pair of corresponding characters that differ. If the string can be made a palindrome by deleting a single character, then that character will be one of those two. They are the only candidates you need to consider. By limiting yourself to considering only those as deletion candidates, the maximum amount work performed by your code is only linear in the length of the string. (Also, if every corresponding pair of characters matches, then the string is already a palindrome, so you don't need to perform a separate check for that.) 

Concatenating I generally recommend avoiding forming strings by concatenating several smaller ones via the string-concatenation operator, at least in frequently-executed code. It used to be that doing so would definitely produce unneeded, short-lived temporary objects. That's only somewhat better now: more recent Java reduces it from a certainty to merely a possibility. Too-narrow i18n There's a bad code smell to internationalizing on a word-by-word basis ("to", "from", "no") instead of on a message-by-message basis. On one hand, you risk running into trouble when different messages that both use the same word (e.g. "from") in the default locale require different words in some other locale. More generally, you probably won't need to sample too many locales before discovering one where the message overall needs to take a different form, such that just substituting one word for another is insufficient. You have five different forms of message you want to be able to present. I would recommend providing internationalized format strings for each whole message, which you then use with to produce the localized messages. Guessing a bit about how your method is intended to work (or could be made to do), that might look something like this: 

General comments Be aware that there are other C dynamic array implementations available, including at least one other I can think of that is implemented entirely with macros. I am uncertain, however, whether there are any others that attempt to cleave so closely to the C++ interface. I am by no means convinced that that's a desirable characteristic, but neither am I criticizing the project on that basis. Macro form The usual convention for the form of a macro that must provide a code block is to use / , not / : 

I raise this because you consistently declare function arguments to be , except those that are pointers. You do not need to do this to avoid the possibility of functions modifying the callers' copies of function arguments. You also do not need to do it to accept actual arguments that are declared . The only thing it does for you is to help you enforce a stylistic constraint against functions modifying their own copies of those values (and although some favor such a constraint, I see no particular point to applying it as a universal rule). Note also that you are a bit inconsistent with this ness, because you do not apply your convention to pointer argument (which is a different consideration from the ness of those pointers' targets). 

to clarify what it's doing. If you wish to have the ability to signal an error, then you could consider using an return value to signal the status, following the model of many standard library functions. 

Missing features You asked about missing features. I can imagine a lot of things that you could provide, but here is a fairly minimal list of additional things I think you should provide: 

(See the Linux Kernel style guide, or this one from CMU, or this one from multiple parties including Bell Labs and UC Berkeley.) Following convention will make your code easier for others to understand and maintain. It will also avoid various compilers emitting unused-value warnings for uses of your macros, and since some projects are very particular about avoiding warnings, the warnings caused by the present form of your macros could be a deal-breaker. Multiple evaluation More importantly, however, most of your macros evaluate one or more of their arguments more than once. This makes them very dangerous to use, and if I were evaluating your macro set for use in a project of mine, that by itself would be enough for me to reject it. As long as you are accepting dependence on , however, I think there is a workaround that will work for most of your macros, along these lines: 

When I read "algorithmic complexity" I immediately thought asymptotic complexity. But of course, improving asymptotic complexity would require choosing a better algorithm, and I am disinclined to believe that that's what you were trying to do. On the other hand, it's not actually what you said, either, so I guess I'm just saying that your wording could have been better. 

I think there are several issues around your code's dependency on and its characteristics, and around uses of that type. Inasmuch as you have made it clear that the whole bit is a placeholder for an alternative internal representation, however, I'll not devote time or space to those issues. I mention it only to clarify the scope of this review. In addition to @chux's astute observations, then ... Character class assignment You perform character class assignment via a big statement in function . I suggest instead implementing a (bounds-checked) table lookup, which you clearly know how to do. All of the characters you assign to classes other than "other" belong to C's basic character set, so they are guaranteed to have positive values even on systems that have signed default s, in case that was a concern. You could even eliminate your calls to that way. Also, it might be convenient in this and other respects to declare so that corresponds to the value 0. Globals As @JS1 remarked first (and since deleted), reliance on file-scope variables makes your code non-thread-safe. There's no particular need for that -- yes, if different functions need to access shared parse state then passing around a pointer to a local struct that contains the needed state variables is a reasonable solution. As a bonus, the compiler may be able to optimize the thread-safe code better. Half-hearted use of enums You go to the trouble to declare enum types for input classes and machine states, but you then use only the declared enum constants, not the types themselves (you declare objects expected to hold instances of those types as type ). It would be clearer and would afford compilers more opportunity for type checking and optimization to declare objects as the appropriate one of those enum types wherever that is in fact what they are expected to represent. Numbers with trailing garbage Your specification says that the input must start with a floating-point number, and parsing must fail if it does not contain a floating point number at the beginning. It appears, however, that the program will report an error for strings that start with a parseable number, followed by a character from class "OTHER", even though it seems from your description that such inputs should be accepted. Similarly, but separately, your code rejects any input that causes the machine to transition to the state, even if the input parsed before that state is reached constitutes a valid representation of a number. This, too, seems at odds with the specification. Signature of If you really mean it about parsing a number from the beginning of the input, as opposed to parsing one from the whole input, then you should consider adding a mechanism for telling the caller where the parsed initial substring stops. You might emulate in this regard, for example. Modifying the the input You modify the input string via function . This is inherently undesirable, if only because it means your function cannot work on strings, as @chux already observed. Even if strings were not a concern, however, modifying the input still needlessly narrows the use cases to which your function can be applied. Returning an indication of the extent or end of the parsed portion, as already discussed, combined with the changes necessary to accept inputs with trailing garbage, would provide a reasonable alternative. Return values of and When these functions detect that the sum (difference) would not be representable as an , the former always returns , and the latter always , regardless of whether the result over- or underflows. That's a bit surprising given that both alternatives are possible for each function, and that you seem to take a different approach in . You already signal the error by setting , so these return values convey no additional information in the error case. You certainly can and do work with the implementation as it is, but this is the kind of little quirk that breeds bugs later. 

I would suggest instead, which should be sufficient for any representable string, but if you prefer something that may be a bit smaller (at the cost of restricting its range) then you could go with (from ) for the smallest an unsigned integer type with at least 32 value bits, or for the fastest unsigned integer type with at least 32 value bits (these might or might not be the same type). First implementation Use of a file-scope variable This version of the function relies on file-scope variable . Being declared a file scope gets it free initialization, but relying on that makes your function a one-shot. Even if you reset the contents of this array on each function call, relying on it makes your function non-thread-safe. I recommend switching to a local (array) variable inside the function. If (and only if) you continue to use a file-scope variable then at least declare it to give it internal linkage. Questionable data structure The type on which this version of the function relies seems a bit of a miss to me, for, as it is used, the value of member is completely determined by the index of a given instance within array . This member is therefore redundant. See also my previous comments about using type for your character counters. Second implementation Make use of initialization You declare array without an initializer, and then manually loop to set its initial contents. Given the data type and the initial values you want to set, it would be clearer and potentially more efficient to instead declare it with an initializer: 

They are both clear and largely superfluous. You've chosen reasonably good names for your variables, so the meaning of the code is fairly well readable from the code itself. More generally, I rarely think it appropriate to comment every single one of a series of simple statements. It is more effective to document at a somewhat higher level: if each statement reads well in and of itself then document the purpose of groups of lines. Also, I prefer trailing comments to be very short. If you have something longer to say then put it on its own line or lines. Additional comments Clearly your class is constructed for the express purpose of demonstrating , as it is missing methods that one would expect a general-purpose list class to provide. That might or might not be an issue if you were to present such an answer in an interview. Note that you could provide a full-featured implementation of by extending and implementing its method. On general principles, the inner class should have a constructor with which its field and maybe its field can be initialized. It may be appropriate to make the value , too, as @forsvarir also suggested -- this is possible only if you provide a constructor.