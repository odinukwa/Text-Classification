Putting in s everywhere makes your code look somewhat cluttered. Instead, use Python's support for raw strings, in the form . Note the prefix before the double quotes. That's what designates the string as a raw string. In raw strings, each character is stored WYSIWYG, which means that linebreaks in the string are preserved. Avoid the burden on the user of the script for choosing the correct clear-screen command. It is possible to detect the OS in Python via: 

This will result in for Windows and for a POSIX system like any Unix derivative, including Linux. Using the above data, you can decide whether to use or . You might then consider renaming the import to something other than , or not renaming it at all (like I showed). Reduce the number of unexplained "magic numbers" in your code. You hardcode 10 for stuff like the number of rows or columns, etc. Replace these with declared constants or function parameters, and follow the PEP8 naming conventions. You hardcode a lot of checks, preventing scalability to larger grids. Using loops and boolean accumulators for checking conditions, especially for can be helpful for this purpose. Loops can also be used to generate the necessary format strings for output. Maybe you should include some sort of command-line help (especially about how to play)? 

First of all, it's very good that you read about the evilness of . Avoid it at all costs :) As for your solution, it's not thread safe, in terms of functionality: Thread A tries to add an object to id = 123. Since this object doesn't exist, the returns , so the false part of the condition takes place. Then Thread A acquires the lock and starts to add its object. However, Thread A hasn't yet completed its processing, and the system now switches to Thread B. Strangely enough, Thread B wants to add its own object with the same id = 123 (!). And, what do you know, since Thread A hasn't finished its processing, Thread B asks if the dictionary and gets . That's the problem. Even worse, when Thread B starts its processing of adding the object, an exception would be thrown, since there's already a key assigned with 123. So, no, the suggested code is not thread safe. That's a classic race condition. How to resolve this? Option 1: Double check on read operations Inside the lock, you can call again to the , which is a read operation. MS provided a cheering statement, that read operations on its data structures (dictionary, list, etc.) are all thread safe. Update: from MSDN: A Dictionary can support multiple readers concurrently, as long as the collection is not modified (my emphasis). So please ignore this option. Option 2: Use ReaderWriterLockSlim Class This class is optimized to the scenario of multiple reads / seldom writes. So when you want to write, you upgrade your lock to have "write" scope, and you continue your code. Option 3: Use a simple lock on the entire method. This is very straight forward. All options are fine, and my personal bias is towards option 2. Update: see also a related post at Ayende: Why is this not thread safe? Good luck! 

Edit: Dunno what PCG is and don't want to read the paper? Maybe this video of Melissa O'Neill (the author) explaining things will be palatable instead. Original: I attempted to answer this question last week and was thrown off when someone mentioned in a comment that my method would show bias. Eager to prove the naysayer wrong I discovered that things were even worse than he suggested as certain ranges will cause things to break down entirely. So I decided to start from scratch, do some more research, and try again. Performance was also much more important to me this time around so I decided to try and find a way to avoid calling to generate every single value. Eventually I settled on PCG as an appropriate modern algorithm. Floating point math has also been entirely avoided while working with integers in order to avoid the sorts of issues I encountered in my previous attempts. Looking for potential ways to speed things up or simplify the code; the branch statements bother me quite a bit but can't envision a better way to include the full range of values without them (the upper bound cannot be generated by the method). Haven't been able to find any bugs so far but that doesn't mean they're not lurking either... 

first element is 19, since abs(20-19) = 1 is the nearest distance to 20. let's find 19 in the sorted array: 

Just a direction, not a full solution, but anyway... If limited by space, you could directly calculate each item in the matrix, given its indexes and N. So eventually you could have a function with the following signature: 

and the rest is obvious. Again, this has nothing to do with Python in particular. It's purely an algorithm to be implemented in any language. This algorithm takes O(n log(n)) in time, while the one suggested by the original poster takes O(n^2) in time. 

I wrote a simple class in Python, which controls code invocation, in a multi-threaded environment, with the following logic: The class' main method, named , takes two function pointers as arguments: and . In any point in time, only a single thread can invoke code the function passed as argument. If a specific thread tries to invoke its code, but some other thread is already invoking its code, then the is invoked instead of . If there's an exception in the code being executed, it should raise to the calling context. The code: 

I also went ahead and hoisted up the into a static field since there's no real security benefit gained by allocating a new one on every call. Usage in your current function is straightforward: 

If you're going to spend the time abstracting things then you probably want to invest some effort in refactoring a lot of your common logic into helper functions. Starting with the very first issue, a hard-coded connection string, we can create a function that'll build one out of components: 

There are an infinite number of ways to do this but one possible approach would be to use a dedicated hash function to compress your inputs; out of sheer laziness and convenience I chose to use the built-in for my example. To improve the performance characteristics of your code I hoisted the construction of the hashing class up a level and use so that we only have to instantiate it once per call instead of once per string. I then chose to sample the first three bytes of the hash result in order to come up with values for , , and . 

It's not clear to me what are and ? If these represent the radius values (like C1-P1 line for ), then perhaps (and ) would be a better name here. I'd create and use a data class for each point-radius pair. Say, class with and or something similar. I'd separate constructor and results. The results are calculations that should not be part of the constructor. Take, for example, the class named in .NET: you can construct it, change the inputs, and only when you call the property named - you get the calculated uri. The same should apply here, too. Constructing a class gives us an instance with a valid state. Calculations - in their own methods or property-getters (that are practically methods, by the way). So should be the returned type of a method (or maybe if this pattern apply here), and not part of the class' state. 

What if the script renames file "a.zip" to "b.zip", and both files "a.zip" and "b.zip" exist in the same directory? 

Try using and it's method instead of repeated string concatenations. As an additional point, you could set the capacity of the on instantiation to the maximum expected size of the output, to prevent array reallocations. That is, replace where is a , with where is a . s are mutable and avoid the object allocation overhead of concatenations. 

to ensure that you don't consume the iterator of multiple times - creating the iterator might be expensive or slow, say reading from a file. This'll make the output come out in a different order from what you give us - it'll be a post-order traversal instead of a pre-order one (see below). Since @coderodde has already addressed the main point of iterators and memory-efficiency, this is more educational as you were asking for a recursive solution. Although this particular solution is not recursive, it does utilize the concept of divide-and-conquer with a base case, so it should be helpful to you. About trees: see if you can recognize the tree structure in this program. Hint: it is a balanced \$n\$-level tree where \$n\$ is the number of tuples, with each node having \$\left|T_i\right|\$ children, where \$\left|T_i\right|\$ denotes the number of elements in tuple \$T_i\$. In fact, the \$i^\text{th}\$ level is just the elements of \$T_i\$ repeated as the children of every node of level \$i-1\$. The output of this program is a depth-first search with pre-order traversal of this tree, splitting the output into words at each backtrack (recursion unwind). The output at any given point during the execution is the path traversed in the tree till that point. An exercise - try writing a program which explicitly makes this tree and prints every path from each root to each leaf, splitting the output into words at each backtrack. Here's an example tree for the set of tuples (note how each required word is the pre-order path from the empty root to a leaf): 

Over the weekend this article inspired me to write an ASCII string implementation that avoids memory allocation during basic operations like and . It's still a work-in-progress but I think this is a solid foundation to build off of and wanted some help checking my logic/maths. The main method of interest is the overload of that accepts an offset and a count since most other methods are implemented by calling it. 

Combining all of this with your original code results in something like the below; there are still some opportunities to improve things even further (for example, code duplication exists in the and methods that might be worth refactoring into a separate method (especially if one were to add more robust logic). 

No need to implement on every DTO, nor is a common interface required. Use generics and a lambda to access a property of a given : 

One could get doubles for RGB by using a provider that returns at least 24 bits (such as ) combined with some altered sampling logic: 

The way you do it - you are reimplementing division and remainder from scratch with a loop. This is, well, useless. The way you're doing it right now is OK if you can't use the above (course restrictions?), which would have helped a lot in this case - you could have used it to get rid of the loop altogether, just looping over the allowed prices. What can be done for your code is moving out the part which reimplements division and remainder into functions and using them, but then there remains no difference between the way I do it and the way I suggest for you to do it here. (Note that the extraction into functions is necessary for reducing code duplication and extending your code to support more prices). Here is my take: 

The keyword before the method parameter - which I named , because that makes more sense than : it signifies to the method which called that it will not change . Note that this modifier will also prevent any reassignments to , which is OK as you don't reassign it anyway. The spacing, bracing and indentation illustrates my above points. 

I believe one can avoid the bias problem by generating a random float between [0..1) and then normalizing the value between x and y instead of clamping: 

Finally, we can add some helper methods to simplify the creation of commands, execution of SQL, and retrieval of single values: 

Updates: I have refactored class based on a combination of all of the feedback here, on the linked question, and a lot of benchmark results. The current implementation has been split into and and drastically simplified from the original; a change I didn't like when first suggested to me but experimentation proved it to be superior in the end. The compile-time safety suggestions ended up being ignored simply because the original requirement was for based access and one can always add such a helper via a simple extension. Now, about performance. I was quite surprised when I loaded everything up and learned that @MarcGravell's implementation was roughly 4x faster than my own; I knew he'd win but I was shamed to lose THAT badly. It turns out that there were a lot of little details that were getting in the way. I believed that one huge advantage he might have is that he's emitting IL to build a delegate while I was using expressions and so I spent the time figuring out how to emit the IL I needed. The problem? Once finished I only gained maybe 5 ns, he was beating me by at least 20 times that amount! This is when I learned that the slowest part of the entire process is not executing the delegate but extracting it from the cache. I was using and wow is it slow! Really slow, even calling is at least 3 times slower than the normal class. Don't just take my word for it either as others have documented the same experience and I suppose it's not surprising giving the promises that the class has to fulfill. What surprised me more however is that itself is quite slow when compared to the pattern of . Anyways, I was able to refine enough edges and end up with a property accessor that is consistently 3ns or so faster than FastMember. If my math and analysis of our code is correct then this delta is purely a result of the fact that he has a cast to in his IL and I do not. The cast to object allows him to have a single point of entry and exit via a lovely indexer which I was forced to leave out because I wasn't clever enough to find a way to have my cake and eat it too. Benchmark Results: 

Having so many operations -- seems like you'd want to use some kind of a factory, injected in the constructor, or the instances themselves injected in the constructor, instead of constructing the classes inside the constructor. 

From the algorithmic perspective, I'd like to suggest another solution (regardless to Python as a language). Here goes: let's assume that all items in the given array are different. the other case has a similar solution, so let's focus on the algorithm itself. 

The math behind this function is not that simple, but it's not that complex, too: You should calculate the shell's index, according to , , and . Then you should calculate on which side of the shell are and ("North", "South", "East" or "West"), and calculate the "distance" (in steps) of the current item from the shell's start position. All this is pretty much mod calculations. Once this method is done, you could simply write a nested loop (N by N) with and , and print the function's value, without having to populate a matrix before that. The calculations in the should not take more than O(1) (in space and time), so eventually you could have a solution of Θ(N) in time, and O(1) in space. Just an idea, though.