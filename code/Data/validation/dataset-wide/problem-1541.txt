I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Project Euler: 

The code above has got more operation than in the first part of this riddle. But it's way faster and shorter than the functional approach of the 1st problem (Advent of Code 2017 Day 5 (part 1) in Functional Programming (FP)). My FP solution: 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Advent of Code: $URL$ 

For the cross product I used this code snippet: $URL$ Slow as hell but seems to be fp with vanilla JS only: 

I wanted to practice functional programming (FP) without using any library but using vanilla JS only. So I took a problem from Advent of Code. $URL$ 

I have implemented several lock-free algorithms to maximise throughput but have always baulked when performing a spin-lock. I can usually convince myself that this is the only way but it still nags at me that a spin-lock is a terribly bad idea. I recently came across a FIFOMutex code fragment and thought perhaps that would be a solution. I have hacked it around a bit because I don't want mine to consume interrupt exceptions but essentially it looks like this: 

I am no expert in streams so this may not be an ideal solution but here's a moderately streamed version. Essentially, the game is a stream of objects which are evaluated, grouped by the result and counted into a Map. Most of the streaming is in the method. 

I would recode the list of s into a list of tests and implement them as an . There are other techniques but s offer a nice succinct way of doing this. 

I wanted to practice functional programming (FP) without using any library but using vanilla JS only. So I took a problem from Advent of Code (the 1st part of Day 5): 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Advent of Code (the 2nd part of Day 5): $URL$ 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took the a problem from project euler: 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Advent of Code (the 2nd part of Day 2): $URL$ I'm doing the 2nd part of Day 2. You can only access the 2nd part once you solved the 1st part. To access the 2nd part type in this number or check out the solution here: Advent of Code Day 2 (1) in Functional programming (FP) 

There is a neat fact about the Java LinkedList. It implements the Double Ended Queue or Deque interface. This means that it can be walked in either order (end backwards or start forwards) so in this case you actually don't need to find it's length, you just need to walk both lists backwards. Here's an implementation of what you are trying to do. 

I totally understand how exciting it is to make full use of the richness of the Java language but sometimes you must stand back and decide whether you have don good or bad. Here I think (and this is only my opinion) you have not done good. My problem with this is that it is not obvious how to use the mechanism. I would suggest that the transform mechanism should not reside in the enum, it should be in the . Something like: 

Is there a better way to write it in FP with pure JavaScript, i.e. no additional FP library? Any improvement suggestions are welcomed. 

I wanted to practice functional programming (FP) without using any library but using vanilla JS only. So I took a problem from Advent of Code (the 2nd part of Day 6). You can only access the 2nd part if you type in the solution for the 1st part: or look at my solution for part 1. 

Is there a better way to write it in FP with pure JavaScript, i.e. no additional FP library? Any improvement suggestions are welcomed. 

Is there a way to write with less parameters and still be consistent with fp? Any other improvement suggestions are welcomed as well! 

Is it possible to solve this problem yet still be consistent with fp, i.e. no mutations and no loops? And of course: Any other improvement suggestions are welcomed. 

Note that this is cut down from the real one but only to remove features such as auto-configuration. The use-case that fails occasionally for me runs like this. This special table can be updated by other parties so customer needs a regular full refresh of the cache. To achieve this I use a method that always checks to see if the cache has expired and if it has, rebuilds it. To detect a timeout I insert a pill into the cache under an ID that will never be accessed otherwise. To ensure no clash with other threads I also use a to forestall other threads trying to read the cache while it is being rebuilt. 

and everything still works. Why This solution demonstrates that if you write your code in certain ways it is naturally malleable in certain directions. In this case, by using an , a change in requirements that add new specials can be accomodated trivially. I suspect the interviewer could clearly see that your code was not malleable in any way - as demonstrated by the fact that you had to duplicate code in several places. Adage: If you've duplicated code (or any other code smell) you've probably got something wrong. Fix it before you present it to the interviewer. 

I'm doing the 2nd part of Day 5. You can only access the 2nd part once you solved the 1st part. To access the 2nd part type in this number or check out the solution here: Advent of Code 2017 Day 5 (part 1) in Functional Programming (FP) First my procedural solution: 

As you can see, it is not consistent with the idea of FP. First I wanted to write it using recursion but I hit the stack limit. Therefore I used generators (and loops). That was the only solution I could come up with that resembles FP. Any suggestions how to write in FP without any additional FP-Library (i.e. in pure JS only) is much appreciated. 

First I wanted to solve this using recursion. But I reached the stack size pretty quickly. Therefore I opted for generators. But I'm not satisfied with my solution especially because of the generator: 

My conclusions - this code is almost right but I have missed a situation that can leave the cache almost empty even though I have added all items to it. 

There are many edge cases to e-mail address structure that you will exclude if you try the simplest approach. One I use that accepts most of the reasonably acceptable e-mail address looks like: 

I use EHCache to maintain a mostly read-only cache of results from database queries. It works perfectly for over a dozen queries. However, there is one table which needs an odd access method that is causing me grief. I hope someone with a knowledgeable eye could see what I am doing wrong, if anything. Note that these classes are marked because I have torn them out of live code and put them all into a single class - just for you. :) Here is the object which wraps an ehcache object. It works fine in all case except my special case I will post further down. 

Is there a better way to write it in FP with pure JavaScript, i.e. no additional FP library? I have problem with the lookuptable . Everytime I "add" a new element to the scoreboard, I had to pass the new scoreboard along. There is probably no other way around this in FP since FP functions have to be self-contained, i.e. every new value that needs to be calculated have to passed along. But I still wonder whether there is a nice FP solution to that. Any other improvement suggestions are welcomed. 

Is there a better way to write it in FP (without any libraries and with vanilla JS only)? Also any improvement suggestions are welcomed! 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Advent of Code (the 2nd part of Day 3): $URL$ I'm doing the 2nd part of Day 3. You can only access the 2nd part once you solved the 1st part. To access the 2nd part type in this number or check out the solution here: Advent of Code 2017 Day 3 (part 1) in Functional Programming (FP) 

This seems to work fine under normal load - however, a recent high-load period caused everything to fall apart. We even interfered with other hosted apps. Not sure what caused the interference but I want to be sure this side of it is done right. The exceptions I saw were: 

Note also the and methods that avoid your manual creation of the lists. Note also how I calculate the carry rather than explicitly set it to or . It is calculated to be the value remaining after the digit has been extracted from the divided by . Finally, see how using s allows you to interrogate each list to see if it is exhausted and, if it is, use . This way we don't need to special case one being longer or shorter than the other. 

Once you realised that you were permuting the characters you should have stopped there and worked out how to do that in a general way. Here is a base class for permutations iteration: 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took the 4th problem from project euler: 

The FP solution is longer and slower. I couldn't solve it without recursion. After a while you hit the stack size. Thanks to Thanks to @Blindman67 he suggested a workaround with . Do you know an FP approach that is faster and shorter than the procedural one? 

I got 2 while loops that are nearly identical. Is there a way to refactor them? I tried to refactor them into one function. But that function takes and returns 4 parameters: 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Project Euler: 

Running this code with in normal mode will create a . I had to "cheat" by running this code in : (node 6 supports Tail Cail Optimization (TCO) when the flag is turned on). I also tried to cache the but this didn't help either. I got the feeling that big size Input is the limit for FP.