removes the unnecessary numbers and mapping from your solution. NOTE: Code is data and data is code. You can tread functions like data in a functional languages. Building a list of functions is a perfectly reasonable thing to do. All that said, Haskell's library provides the function you really want: 

Your code is full of conditionals and duplicated code. This makes it both fragile and hard to read (and, as a result, hard to verify visually). This problem can best be addressed by splitting it cleanly into two functional parts. 

Similarly, the second transformation could throw an exception if the input doesn't match and the third could complain if the divisor is 0. Another way to add useful information to error reporting would be to add as a new, first transformation so that the number of the line in the file is available. Note that combining two or three of the transformations into one would make the error-handling pattern matching more complex and fragile, although not combining them would make it more complex to report the line number and line content if the failure was in the later transformations. There are more functional ways to deal with errors but that's a more complex topic. 

With the apply method added, will return with no need for . It's a minor convenience, in the case of your simple class, but feels more natural. Note: It would also be very useful to add an method, for pattern matching. Ask if you need details. Implicit conversions This is not necessary for the scope of your current, simple code but if you intend to do more with your , it may be useful to be able to add fractions and integers and get fractions as a result). If you add one simple method to your class... 

This looks as if it is part of the upgrade code itself. I think you have too low a level of abstraction in here and you are also mixing different concerns. Also, your workflow just seems fragile. Cars and certificates You check that there is a car, then you check that it has any certificates, then you pass the rectification to . Either you only need to pass the certificate list or you don't need to do the "has car/certificates" check yourself, since clearly has to do that itself to be able to return a CarPassCertificate (or ). (Since starting this question, we've discussed this issue in comments and I see you've agreed that only needs to do the check. Nice.) Workflow How can a rectification be both open and in progress and yet not even have a car? Even if it is legitimate to have one open with no car, I can't see how it is valid for an in-progress task. I really think your type hierarchy may not properly model your workflow. If a rectification may exist for a period without a car (let's think of it as a rectification request) but 

You have the right basic idea - pass a list of conditions - but the implementation is wrong. Yes, you should avoid ; it is a dangerous source of potential error (and performs poorly as a non-bonus). You might put anything in there. You might not even notice a typo which caused nasty side effects, since Python has a very tolerant definition of truth and will be happy as long as the expression evaluates to something. Instead, why not pass a list of lambda functions? Then you just call each function in turn. Much safer. For example, you could build a list of tuples (condition, error message) like this: 

It still gives the same results. The other big point to make is that while Scala is a functional language it is also an Object Oriented language. Those DFS and BFS methods should belong to a graph object, preferably at least derived from a generic class. Something like this: 

Starting with some minor style point... In Scala code it is traditional to name lists xs, ys, as, bs and their contents x, y, a, b and so on. So the first 3 lines of your function would, in that common style, look like 

then it will start by applying all 3 transformations to the first line. If that line is "3/0", the program will halt without touching the rest, saving a lot of time. 

You are doing the same thing in case of failure at any stage - returning an empty list. You should use a for comprehension to chain these stages; if any one stage returns None, then the other stages will not be followed. If you do something like this: 

Like many algebraic data types, a binary tree is a recursive type. A node is a tree (one which can hold other trees). Nil/Empty is a tree. Instead of working with that, you have an inflexible wrapper class Tree and a set of case classes which implements nodes. That incurs many penalties. For a start, you have no representation in your type system of the empty tree. Secondly, you lose the ability to create simple, elegantly recursive methods for your case classes. Look how much simpler your code can be if you work with that, rather than fight it: 

Take the smaller of the input lists and create a map of values and their number in the list, as in your code or mine. Filter the larger list to remove any items which are not keys in the map generated in step 1. Create a map from the larger list. Iterate through one map comparing its counts with those in the other map Proceed from here... 

I'm going to concentrate on the Scala rather than the maths side, because that's my area. The internal helper function doesn't need two parameters, since the value of x never changes; pushing x repeatedly onto the stack is a waste of time. Also, better to use a case statement than a chain of - much less error prone. 

This can be optimised to remove the duplicated iterations of fast.next but I left it like this for greater clarity. 

Although this may give you concise code at the expense of flexibilty, particularly if you want to report meaningful errors (more later on that). 

and nothing would break, because in Scala implements the trait. Any -derived type will have , so there is no reason for this function to demand one. That gives you much more freedom in the rest of your code. If you decide to switch from arrays to sets or lists, this function does not then have to be rewritten. Note: my pattern-matching variant on your explicitly recursive function can also be rewritten to be more generic. Can add an example if you want. sumFractions is redundant Your class deals with a particular representation of rational numbers. I've already mentioned that it might be useful (via implicits) to make them work with integers. However, if you go further and do the work to make part of Scala's Numeric type class, then pretty much anything you can do with a sequence of (or or other numeric types) can be done with a sequence of . If you do that work, you can simply replace with . Here's one way how 

Add a DefaultParameters method which returns the set of default parameters. Add a HasNoParameters method. If you like, it could simply return ! HasParameters (or HasParameters could return the negation of hasNoParameters Change CreateDefaultParameters to a method which takes the output of DefaultParameters and inserts it into the collection. You might want it to clear the existing contents first. Change the line in your code which calls CreateDefaultParameters to this: 

Compare this with the complexity, lack of clarity and fragility of your if...else if chain. It is hard to compare your different conditions, hard to see if you have been comprehensive and nothing about an if chain even compels you to be testing related conditions - you can have anything in each condition. This is a naive example but it is a good place to start. That said, Ben's is the best answer. There is a very small amount of code duplication in this version. The final three pattern matches do the same thing with only a minor change to the input parameters. In such a small, easy to read set of code this is really not a sin (and addressing that would make the function structure more complex and less clear). Replacing the recursion with a fold, however, would remove the duplication, because the fold would take care of the repeated application of the function,which could be reduced to a simple closure adjusting the level. Other notes about this solution: 

Which hopefully makes the structure clear. If your framework works with yield, all you need to do is add @ in the appropriate places. If it does not, you might have to do something like this: 

splitParameters Same as the other two, but multiple recursive applications of is even more expensive. This can be rewritten safely as 

Add the current stream item to twice the accumulated sum. If the resulting number is not a key in the map, insert `list(index-accumulator-value)' into the map with that newly-calculated number as a key If the resulting number is already a key, add index-accumulator-value to the list stored under that key (important: cons it to the list, do not append). Increment the index accumulator by one. Add the current stream item to the accumulated sum. Return 

The Range protocol used to be in the core library but is now an add-on, hence the reference needed before you can use it. That said, it's a more idiomatic, expressive and robust way to deal with simple ranges. loops are even more fragile in Io than in C-like languages, given the optional parameter and Io's blithe tolerance of extra parameters. I don't like chained if-then-elsif in any language, even when it's a function and not a keyword. One alternative would be to use 

Some of the individual gsub calls are fragile in themselves but none of that compares to the basic flaws of the approach. Having said that, the way you are using regexes is duplicating code. You have typed each matched pattern twice: first in the regex, then in the closure. This would not be necessary if you used capture groups and back-references. 

This is the benefit of the functional approach. I have no code duplication at all. I just apply one function to the output of another, in sequence. This makes it 

Now all I need do is create functions which can add to, prune or walk the tree. These will do so recursively, using pattern matching to do the appropriate thing depending on the type of the node. There is more than one way to do this, but first let me say a few things about the example code above: 

My example above is probably a little over-specific. It would be more flexible just to have a conditionList onto which could be pushed a sequence of functions returning booleans. But you get the idea. By the way, I used traits in case you wanted to be able to create classes which did radically different things but also implemented checks. However, if you made indexCheck a class rather than a trait, you could do things like building maps of anonymous classes, like this: 

Minor point - don't use an old c-style for loop to iterate through an array unless you absolutely have to (and you don't have to here). Please, this is 2013 not 2003 - generics have been here for a decade. You can use foreach: 

Your second option is a little more legible than the first but the best way to improve both the legibility and the clarity of your code is to completely separate the code which generates the default parameters from the logic which decides whether or not to add the default parameters. Consider the name of your method: CreateDefaultParameters. This name is misleading. It will not always do what its name declares. Another consideration is that you have mixed different levels of abstraction in this method (the low level work of generating each parameter and the higher level logic). This is only made more clear if you take Ben Aaronson's good advice and create a function to check the parameter status. My advice would be to 

Which would give you N copies of the number 1. That's one step closer to what you need. But you don't want integers, you want your function. By now, you have probably worked out that 

You deal with this by carrying all of your state forwards, making your code more complex and hard to read than it needs. All you need is a nice functional way to return 3 states and your code can become much simpler. You must have been introduced to the Option monad by now. All you need to do is have your helper function (which should be hidden inside your hasSublist function, by the way) return Option[Boolean]. Now you can return 3 states: