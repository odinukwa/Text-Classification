Private initializers. I try to not use them if possible, but I do understand that they have a place. When code is short and simple (like this project), then I find it much easier to read if all of the UI components are setup directly in the constructor. I've found that it's easier to understand what is all happening and build a proper UI hierarchy when they're setup sequentially. A little documentation of what is being setup can go a long way as well. Plus, any variables that need to be accessed elsewhere in the class can still be final since they're initialized in the constructor. That said, in a very complex and large class it can be more readable to break apart the constructor work into some private methods. But even then I might argue that your constructor is doing too much, or that your class is responsible for too many things. 

can be removed Instead of using a for loop and iterating with a counter, you can use the built-in iterator and iterate over . 

Back to the class, and the GUI class. Do away with . I view your UI as having rows. Each row is for an instrument, and each row has some checkboxes which represent beats. To model this, we can make : 

Now, you might be wondering how that helps at all. For one, it abstracts out (to a reasonable extent) all of the work needed to create a row, add the label, handle changes to a checkbox, etc. This also helps with extensibility. Say you wanted to add a button to your app that adds a new instrument (or even one to delete). Previously you would've had to do a bunch of work to update and maintain that 2D array of objects. Now, all you would need to do is add a method to your UI to addInstrument(), which would create a new InstrumentRow instance and you're all set! I won't go into much detail on this, but one thing that is also a good practice is to separate your view into an interface and an implementation. The implementation would be specific to the UI framework that you have chosen. For example: 

Resulting Code With all of the design changes in mind, here's what the result could look like: BeatBox.java 

No need to say the method name again - the method name is automatically part of the Javadoc. What are the parameter constraints? (To be fair, you don't enforce any constraints in your code, so it makes sense to not mention any in your Javadoc) That said, you should at least have some minimal constraints on your public methods and constructors (eg. The GUI constructor takes a object - do you want to allow a consumer to pass in ?) When are your exceptions thrown? I see lots of classes which throw a , but as a consumer of your code, I would want to know what causes that exception to be thrown. Private methods. It's not wrong to add Javadoc on private methods, and some people will argue that every private method should have Javadoc. I don't necessarily agree (Feel free to come to your own conclusion on this one), and I am of the opinion that if a private method is so long that it needs documentation on what it does, you should probably clean that code. 

A few. Sorry it seems boring, but there's not much better you can do. The biggest change might be to make this into a generator function, which may be a tiny bit neater. 

Your use of the dictionary seems to be a way to allow the numbers to arrive out-of-order. Rather than sort them, you seem to be trying to use a dictionary (and associated hashing) to maximize efficiency. This doesn't really work out perfectly, since you wind up doing sequential searches for a given value. Hashing a low:high range (a dictionary key:value pair) to avoid a search doesn't help much. Only they key gets hashed. It does help in the case where you're extending a range at the low end. But for extending a range at the high end, you have to resort to searches of the dictionary values. What you're really creating is a collection of "partitions". Each partition is bounded by a low and high value. Rather than a dictionary, you can also use a trivial tuple of (low, high). To be most Pythonic, the (low,high) pair includes the low, but does not include the high. It's a "half-open interval". Here's a version using a simple of tuples, relying on hashes instead of bisection. A binary search (using the module) may perform well, also. It would slightly simplify adjacent range merging, since the two ranges would actually be adjacent. However, this leads to a cost in restructuring the sequence. You start with an empty set of partitions, the first number creates a trivial partition of just that number. Each next number can lead to one of three things. 

You still have the calculations. You're just giving them names and keeping them separate. Giving them separate names makes them more reusable, easier to test and easier to find. The most important thing here is to avoid creating a (nearly) useless class who's only job is to contain a bunch of functions. Your code uses no instance variables and simply uses another function that happens to be in the class. Both of these could be method functions. There's no reason -- in Python -- to create a class unless you have instance variables and a change in state of some kind. [In Java, you must often create "all-static" classes because there's no other place to put stateless math like this.] You can simply put these functions into a simple module and avoid the class definitions. 

This may be better than a list. A list where the order of the arguments is critical is a bad thing waiting to happen. Code like is utterly opaque. It should be replaced with so that the meaning is obvious. Also, once you have an class, your separate function becomes needless. You can subclass like this. 

I prefer to accomplish this by creating the view, and injecting it into the controller in the constructor as follows: 

MusicInfo Class Long story short, you don't need this (I also think there's a better approach than using a 2D array, but for now, let's assume the array stays). The 2D array that's being wrapped here is a UI component, so it can easily become part of the GUI class. The methods in this class are just syntactic sugar, and really don't provide any additional benefits. Plus: 

BeatBoxConstants Constant Class (of Interface) are a bad anti-pattern. Instead, we can easily just pass in the number of beats to the constructors! 

Your MVC usage is a bit skewed. We have the GUI class (clearly the View), MusicInfo (Unnecessary model that the View uses, but is also passed to Midi?), Midi (Controller, but is also directly accessing MusicInfo which should be internal to the View), Instrument (A model) and BeatBoxConstants (More on this later...). In the MVC pattern what is supposed to happen is this: 

Instrument Class Why not make this class an enum? By declaring the display Strings and key values as static variables in your class, it's already constant. For example: 

Just to reiterate, the view should be a very thin layer of the application. It does not have any business logic, and it should be the only place in your code where UI elements (AWT, Swing, etc. classes) reside. That is, no other classes should have ANY knowledge about what UI framework the view is using. Why? Those classes shouldn't care! (Separation of Concerns) 

Again, maybe just personal preference, but I find this approach a bit easier to see how the hierarchy is being built up. 

In an example workflow, let's say we're playing a track and click the reset button. The view added a listener to the reset button, so that listener will fire. The implementation is simple and only notifies the views listeners the the button was clicked (the view is supposed to be dumb, remember?). The controller now is notified, and it is smart so it will know what to do! The controller takes charge and stops the sequencer (updating the state), and then tells the view to reset itself. And that completes the cycle! (Interact with view -> view notifies controller -> controller modifies state -> controller updates view) 

Added bonus: You can select new check boxes and the player will now start playing the new track without having to pause and restart the player InstrumentRow.java 

Use static variables that are already part of the Javax MIDI library. For example, your and magic numbers can be replaced with and respectively. This applies for the message as well. I'm not sure what that's for or why it's necessary, but I'll take your word for it :) Similarly, that magic can be made a private static final variable on the class. And the . I'm not sure what that does either. Velocity? Let's go with Velocity. 

This is a pretty radical rethinking of your algorithm, so it's not a proper code review. Assembling a string with separators is simpler in Python. For your example of ","-separated strings, always think of doing it this way. 

This can't work unless you stipulate a specific size for the partition and do not grow it. You can't discard any value from the input sequence or you won't get the actual maximum. The fact that you're popping a value means that you may be discarding a proper part of the solution subset. Consider a slightly contrived example where X = 0.25. The initial state is to process 1/X items (4 in this case) of which 1 is maximum and 3 are discarded. The values were 100, 99, 98 and 97. You keep 100 as the 25% maximum and discard 99, 98, 97. (You could try to keep all 4 or even the first 25 values. It doesn't matter how many you keep initially, the logic problem will still arise as soon as you pop a value. I think the contrived example makes the logic flaw easier to see.) At some point, you've seen 7 values. The maxima subset has 1 value (100); the remaining values (99, 98, 96, 95, 94 and 93) have been discarded as not part of the maxima set. You get value 8, it's 92. You need to append this to the top set. Yet, sadly, you discarded a value larger than this. When you get to value 12, you again need to expand the maxima subset. However, you will have discarded values that may be larger than the 12th value in the sequence. You cannot do a from the maxima subset unless you can prove the value being popped must be less than all future values which may arrive. 

Once you have that, you're simply making a sequence of details. In this case, each detail is either "x-y" or "x" as the two forms that a range can take. So it has to be something like 

In this example, I've shown the format as an in-line . It can be done as an expression, also. Given your ranges, the overall function is this. 

Do not use a database for this. Use files. A single file with one tweet per line showing User Name, Tweet Text and whatever other information you have. You need to sort the file by user. Use the OS-level program, don't write your own. Once the tweets are sorted by user, you simply read and count. 

These aren't "utility" functions. They appear to be central to your app. There are rarely "utility" functions in any app. What we used to call "utility" functions are almost always part of a standard library.