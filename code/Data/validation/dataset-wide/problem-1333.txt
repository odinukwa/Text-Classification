Let's turn to the method . One of the first things I notice is that you have chosen the name for your display string. But why ? What does it stand for? Would it not be better to pick a more informative name so that it is immediately clear what the string is supposed to be? Personally, I would just call it , since it is supposed to be a display string. Make it a habit to choose clear, informative names -- it will be so much easier for yourself and others to read and maintain your code. But, on second thoughts, is it really necessary to initialize a string here? After all, you are not trying to build a string to be returned from the method -- is set to an empty string during each iteration of the loop. So I would rewrite the method as follows: 

But if (for whatever reason) you do want to keep a record of all the random indices, take note of @Loki Astari's suggestion that you should initialize a vector with size instead. The general idea, which is applicable regardless of the programming language you use, is this: In programming, as far as possible, avoid magic numbers (i.e., values with unexplained meaning) and hard-coded values. It will make refactoring far easier and less bug-prone. E.g., if you ever want to change the default value of to something other than 15, you will not have to dig inside the method itself to change the array size of . It is inconvenient when you remember to do so, and troublesome when you don't. You want to write your code in such a way that you are not required to read through the entire method whenever you want to change your input values. Second remark: Always favor using informative names over adding comments. E.g., why is the second parameter named ? Would it not be more reflective of the purpose of the method if it is named, say, instead? If I am a first-time caller of this method who has never read your code or comments, I would find the parameter name uninformative/misleading. But why should I have to read your code to understand what is going on? I just want to get a randomly generated string -- I don't care how you do it; I simply want to know what information I have to provide, and you should make things easier for me by choosing informative parameter names. Similarly, would be better named as , and so on. Choosing good names will significantly cut down your need for writing comments. As far as possible, try to make your code read like regular English. This is how I would write your code: 

Firstly, as @Loki Astari pointed out, you can do just one iteration to both generate a random number and retrieve the character located at the index specified by the number. It means that you can get rid of the array entirely: 

There is no need to expose the user of your program to unnecessary details regarding how you intend to parse his input -- he just wants to play FizzBuzz; he doesn't care about how you design or implement your program. Now let's look at the method . It is already very evident from its name that the method runs Fizz Buzz using inputs provided by the user, so there is no need to include 'FB' in the variable names -- it is redundant, and does not convey additional information. So I would suggest that you instead rename 

Notice that you can pass a value of type directly into . :-) I hope these comments are helpful. It is very nice to see such good effort from you; I am sure that you will keep getting better. :-) 

@Heslacher has given some good suggestions, so I won't repeat what he wrote. Here are some additional comments: Firstly, I would encapsulate everything in your wrote in into a private static method named . Inside the method itself, there will be a single line of code: 

Firstly, underneath everything Javascript is an event driven language so I do not think that there is anything wrong with using an event driven design pattern if you are comfortable with it. Events are a great way to be able to interlink different components of your system without exposing the inner workings of them (loose coupling) and they add queuing by default. However they are more complex, they make it hard to trace behavior which in turn can make them hard to debug. I think that you would get a cleaner interface by developing using something called the revealing module pattern, there is an excellent resource on various design patterns by a guy called Addy Osmani at adyosmanio.com and the revealing module pattern specifically here. This (or a flavor of it) is commonly used in jQuery plugin development which you can see on the jQuery advanced plugin development page (see Keep private functions private). By following these principles you can keep the private stuff private and only expose the functions that you want the calling code to have access to. You mentioned specifically , and so a quick example of how that might look. 

Now what you really want to do of course is collapse down that loop. I found that if you have LINQ (which I see you do not) you can use the operator, very simple e.g: 

So, if you're clever about getting an index in there you could write the algorithm (without validation) in just 3 lines and you'd have done a bit of functional programming which sets you up nicely for playing with a new language. 

For reference you can also check this excellent article from Smashing Magazine (check the author) and related GitHub repository. 

Caveat: I've never written a line of C#, nor do I know anything about its compiler. I think that the approach taken in your code could be considered the more modern approach. It is definitely more suitable for human consumption, and it makes it more easy to test individual parts of the algorithm. With luck it will compile down to very similar byte code too. But, your code is inelegant in that you loop twice skipping alternate elements. You also have a bit of smell where you have the code . I'm not sure what the accepted usage of Tuples is in C# but for internal use I'd have thought a single function that returns you an (insides, outsides) would be acceptable - if not a little helper class with two elements. This would modify you code to begin (pseudo-ish): 

Firstly if you are going to be passing objects of type around I guess you best be prepared to do a few casts here and there. You can achieve this using a simple interface and templates quite easily. Interface: 

On the whole it's not at all bad, I find it readable and I'm sure that it does the job (one caveat to this is how does it handle cases where you have multiple instances of the same point e.g. {{1,1},{1,1},{1,2},{2,1}}), a few things that you could do to improve it.. 

If you cannot rely on a selector (like I used above) to find the elements that you are interested in, or if you cannot add classes to the elements when the page is assembled then you could add the class in code: 

If there is other code and you need all the features of a TreeSet great, otherwise delegate to a TreeSet member variable. Your code is somewhat superfluous because of the next test 

Then onwards. Arguably this is borderline procedural but with these few steps I think that is acceptable. Edit: Less readable, more old school 

-. When you are coding your method start thinking in templates. Sure it's not necessary now, but it costs nothing to write and you've got a utility function you can use forever. One thing that would concern me about this method is the Cyclomatic Complexity due to the number of loops and conditionals. Consider how you could break things down, e.g The content of your loop can be broken out into code which finds/verifies the rectangle is complete. As a rule each method should have a role as discrete as possible, again this makes things more testable and more readable (when coupled with sensible naming).