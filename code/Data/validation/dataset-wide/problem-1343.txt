You have some methods to copy individual elements out of the array containing the encrypted data (, ) but you manually fill it in in the encryption method. Also you have delete the IV and tag to get just the data. I would encapsulate this in a class where you can set these properties individually and it deals with the layout of it. Something along these lines: 

Note: Never in this context means I killed it after 10 or 15 seconds. So it's not surprising that a list with 50,000 random elements can easily yield in a higher setup time than 100,000 depending on the distribution of the values (the algorithm attempts to re-create the table everytime there is a collision). As per given example it's easy to generate inputs which will make it run for a long time for very few values. Given the problem restrictions I'd say you can get away with the fastest perfect hash function there is: Identity. You could simply use a bitset with the values as indices and flip the bits on of the value is present. This requires a bitset with 10^9 bits - approx. 125MB of memory which is not all that much these days at least on desktops. Resulting implementation: 

You have a method which I assume provides a prime number between the two bounds provided. Yet you do not use it and call directly in . You should either get rid of the wrapper method or use it consistently. Braces are used inconsistently: 

You pretty much want , except that one has all of the argument orders and pair orders backwards, or the monad, except that one passes its state to the right. We can define our own : 

and both call their argument , leading to mixups. maps the integers to , not . You are looking for . 

I don't see the definition for , and your first code paragraph doesn't look like Haskell to me. You have one more place where you could use your . Both uses are for , so you could instead wrap in your name for it which returns a . Assuming a lens into the content field of : (note that ) The source of $URL$ seems to want to give you the attributes in s too. Maybe they have reason for this - should you also retrieve that in ? If so: 

I now notice that list comprehensions don't actually use the instance of lists within let expressions. Ah well, since the instance for happens to make smaller than anything, I can get rid of the list comprehension again, and restore maximumOn! 

is subsumed in , the chain length is monotonous with the set size, and do notation feels like it might help with include. 

Successive elements of the list returned by genPositions and xs are zipped together; captures this pattern. i is now not needed in its non-rooted form and I recommend changing the interface to take N as an argument instead. Non-square arguments can currently crash !! anyway. genPositions is only used once, therefore I inline it. 

This removed some distracting clutter and lets the reader focus better on the actual functionality of the method. 

This loops over the string once and you don't need to collect all the indices. is your friend when implementing this. 

Apart from the comments provided by @lol.upvote: The code as you have posted it does not compile for two reasons: 

names are typically only used for macros and not for typedefs. I don't quite see the point of returning a value from insert. You always return -1 anyway. Personally I'm not a fan of implementations where an element of the data structure is used to also represent the entry into the data structure. You are effectively leaking the internals if your implementation to the user. An alternative API would something like this: In your header: 

Bug: you assume that the result will never be longer than the original string while in fact it could be twice as long. For example would yield . Instead of using to initialize you can also initialize it to 0 like this: 

looks like a C++-ism. In C# you have value types () and reference types (). is a class and thus passing it by doesn't gain you anything unless you want to replace the list object with a different one. If anything should create the list, fill it and then return it. could be better named like . As @rolfl pointed out you don't actually need to store all the numbers - you can just generate them as a sequence with an enumerator and then do your processing on the resulting sequence: 

You can use the comma operator, which takes the value of the last expression. It's not used very much, so may make the code less readable, but if you wanna make it one line, this is the way to do it in a single statement. You need parentheses because of operator presedence. If you omitted them, the comma would be interpreted as a separator between variable definitions. 

You've declared your function as , but what information does the returned convey? You're always returning , so no information is gleaned from the returned value. I'd suggest redeclaring your function to return and remove the statement. This goes for a few of your other functions that return . If you're always returning the same value of or , just remove the return statement and declare the function to return . Here's the list of such functions which I've changed below. 

Here you throw a string. You can throw any value, but it's more helpful for debugging purposes if you throw an object. Just pass this string into the constructor to make your own error message. 

I've created a function that takes an integer greater than zero as an input and converts it into its corresponding Roman numeral. If you're not familiar with Roman numerals, you can read about it on Wikipedia. I've tested this code with some examples, so it should be working correctly. I'd be interested in hearing about any general improvements I could make on the code. Nitpicky details are fine as well; whatever you have to say I'm willing to hear, but I hope your answer is more substantial than that. I suppose my main concern is whether this is sufficiently efficient or if there is a way I could improve on that. Also, do you think I've used the correct data structure in this situation? I can't think of a better data structure for what I wanted to do, so that is why I chose arrays. 

You basically pass them as a string which means that whoever provides them very likely already has a list and needs to concatenate them together and then you have to split them again. You rely on the fact that there are the same number of column names provided as there are column values. Your code will crash if that is not the case. If a column name or value contains a you are in trouble as well. Probably unlikely to be the case for the names but values might be more likely. From experience it's not a question of "if" but of "when" this is going to happen. It violates the Single Responsibility Principle to a certain degree. This becomes apparent when you write unit tests because now you have to write unit tests to check that it can parse the names and value correctly - a functionality which is not really related to the actual purpose of the class. 

is not a good name for the function as it does not say what it checks. It returns false if all numbers below are present and otherwise. So a better name might be . You can make your loop body a bit shorter by inverting the condition: 

This could just be put on the stack with (the proper term is actually automatic storage duration which in most cases means it ends up on the stack). This normally avoids a call to and you don't have to delete it explicitly. I'm not too versed in COM programming but if could throw an exception you might want to wrap it into a in order to ensure the cleanup of the and COM resource is done regardless. I know it's just a quick mockup but could be reduced by using Linq: 

Your use of for memoization can be extracted into . If one can stop instead of having negative balloons decrease score, can be condensed into one case. 

is . points out some redundant brackets and suggests using in . , and are superfluous once-used one-liners. All the passing can be abstracted with the monad. For example, becomes (I assume reversing the order of adding does no harm) and can be inlined. And s are , so no need for . And becomes and can be inlined. (I note these because it might otherwise look like I'm rewriting the code from scratch as opposed to reviewing.) 

is from Control.Monad.Random. Stuff that you only ever plan to use once and in one place should usually be inlined. allows us to abstract away the passing around of the blacklist. replaces this recursion. Your into an if is subject to Boolean Blindness and should instead be done via a uniformMay combinator. It's a shame it doesn't exist. Let's make a pull request to MonadRandom and pretend it does. reduces naming further. 

(Edit: Actually that one throws out the first of each two equal elements, not the last. Here`s one without that problem: 

Since you only use call the nonpartial case of and only use it once, you can inline it. Pattern matching is better than ///. 's can be used again. 

Here's how to use to brighten the day a little. You may have hoped for a way to do only once after combining the s with ... but I also don't know how to do that. If went to arbitrary MonadError instances, could have been more concise. 

Reduced from 30 down to 19 lines and arguably easier to follow. In I would condense the three function pointer checks into a single check since they all test extremely similar conditions. Eliminates another 10 lines of code. The check-and-update-minimum-node code appears at least three times. It's sufficiently long and gnarly to read that I'd extract it into a separate method: 

you are converting the to and then the result back to . The classic way to calculate where is is to simply do so in your case 

This code appears four times (in other places or are used instead of but the assignments are the same): 

Your users will only ever get the but your implementations ( and ) will implement . Update Looking at it again it don't really see the point of the . If the user will have to call the manager in order to save the preference then why don't make the method public in the first place - so you end up with only one interface. Then the user can call (the arguments he'd have to supply anyway when calling the manager). 

If the control doesn't exist then returns . Passing to should be "save" in the sense that it won't crash - it will return and will be returning an "Invalid Handle" error (or something like that) (can't find any docs for it but that's the behaviour I've seen in the past). A remark to your code: 

You might appreciate taking advantage of some ES6 features. You're using an object literal like a map, so why not use a real ? Speaking of ES6, since you're a beginner, you would benefit from taking the time to learn it now and save yourself the headache later. As others have noted, you can accomplish finding the mode in a single for loop. 

Maybe use some array methods like ? This will add up all the elements, starting with an initial sum of 0 (the second argument to ), then the sum is divided by the array's length to compute the mean. 

Your code grabs the from the then converts it to an , therefore treating a as an . The function you defined swaps the values in the s, effectively swapping the first bytes of your s (most likely the members). I'm not sure if this was intentional, but it certainly is pretty unintuitive and most likely unreliable. Instead, I would change your code to this, then redefine your function afterwards. 

It's easy to see that there's a lot of code duplication going on here. What might not be easy to see is a nice way of condensing it. One way to start is to see the similarities and where the lines of code differ. It appears you want to perform an action on each of the four directly neighboring cells and something separate for the center cell. A nested for loop could help tremendously. The only thing to consider here is ignoring the diagonal neighbors. The other piece of duplication shows up where you do one set of actions when the argument is one value, and an almost identical set of actions when the argument is the other value. The only place the repeated lines of code differ is at a single hard-coded value. If you just set a variable to be the correct value for either case, you don't have to repeat yourself. Something you may have not considered is trying to index the array past the boundaries. You should avoid it so you don't encounter errors. Simply add a check for this before indexing the array. I've split this check into a separate function because the boolean expression is quite lengthy on its own, let alone compounded with other boolean expressions. Another tip is to handle all the cases. If you use a , use a at the end. If you have an , use an at the end. Even if you just want to ignore the case that didn't match the other cases you do handle, you can just write a comment, log a message, or even throw an error.