The first thing you can do is assign all the properties for a thing in one line using an object initializer. The following: 

I don't know much about making numbers random enough, but I have some other suggestions. Instead of checking if a range of integers contains a number you can just check if the number is >= the beginning of the range and <= the end of the range. So you can replace this: 

For , you can filter out the indexes that are out of bounds instead of hard coding the indexes for each edge case. So we get the indexes that are in bounds, iterate through the combinations, and ignore the combination where the indexes equal row and col. 

If you have a group of related constants, and it doesn't matter what their values are, you can put them in an enum. So the values could look like this: 

Since the loops are similar, you could extract one into a method and then replace them with two method calls. I'm going to replace the loops using LINQ. This requires 

If you want, you can create a class to store a spell, its cooldown, and its cooldown number, so then you would only need to create one array. You can use modulo arithmetic to make sure a number is within a certain range. can be written like this: 

LINQ's method syntax (which uses lambda expressions) is not that good for this problem because the problem has nested loops, and it would be nice to store intermediate values. LINQ's query syntax is great for both these things. First we create a helper method for calculating the product of a collection of integers: 

One optimization is to skip sequences that contain a 0. Another is if the previous sequence doesn't start with a 0, calculate the current sequence by dividing the previous product by first digit in the previous sequence and multiplying by the last digit in the current sequence. I hope you had code to convert the 1000 digits from the string into an array of digits. I know you're going for speed, but a lot of times readability and maintainability is more important, and in those cases you'd want to calculate a product using loops or LINQ instead of coding an increment to the index 13 times. You should also calculate the currently hardcoded value of 987 using something like . 

This uses Enumerable.OrderBy() and Enumerable.ThenBy(). Edit: If LINQ isn't allowed, here is an alternate solution: 

Method names should be UpperCamelCase, so should be . I'm guessing you want to access a child's property instead of the method because the method is private. 

As D. Jurcau mentioned, you can move that first block of code outside of the if and else and only write it once, and you can handle the min or max checks with and . To combine the second block together you can write a Clamp method that makes sure a value is between two other values, like this: 

Have a consistent parameter naming convention. has an underscore, but the other parameter names don't. I prefer to only use underscores for variables declared within classes but not within methods. should be lowerCamelCase. That is, . If will always be zero and will always be array length - 1, declare them in the method body. Don't make the method caller do unnecessary work. Use descriptive variable names instead of single letters. 

In terms of speed, your solution is about as optimized as it can get. In terms of readability, your solution has much room for improvement. I prefer readability over speed. You should try to make your code as readable as possible, then, if you have performance issues, search for bottlenecks using a profiler and optimize them. The method body of can be made into a one-liner, which happens to be slower but is much more readable. 

If you want to use LINQ to create an array with an x and y, you can use jagged arrays instead of multidimensional arrays. 

You can use the code from the horizontal method and modify the property calls to use the boolean. For example, you would replace with and with . It can then be used in your previous methods: 

You can create a list before creating the parent thing so you can assign in the object initializer. I don't think your code works currently because you're not specifying the DTO in the foreach loops and not getting the values from the dictionary that's passed in. If the object initializer is too long, you can expand it to multiple lines or create and use a constructor for each class. 

I agree that the method has significant room for improvement. The major thing I notice is the method name is plural, yet the method only returns a single item. I would return a collection of suggestions and order them by score or something like that. Why doesn't your code handle all the categories? Method names should be UpperCamelCase. That is, , , and . The spacing is messed up in many places. For example here: 

Method names should be UpperCamelCase. In C#, the standard way to allow public access to variables is using properties. Your class would look like this: 

I try to avoid implementing because is verbose, and, as Zack mentioned, you also have to override and . Instead of implementing and writing this: 

Because rectangles with the same X position weren't matched before, won't contain , so if it has a length of 1, that 1 element will be a different rectangle, but only the original rectangle will get added as a group. In the inner loop, the body of the last only adds the initial rectangle, but doesn't do anything about the previously added s, so it's possible for the loop to add a bunch of but only add the initial rectangle. If you get a list of the rectangles ordered by their X position right away and loop through that instead of the original list, you can take some shortcuts in the body of the loop. Edit 2: You should add more descriptive names. I don't know what , , the nl in , etc. stand for. Short names are okay for lambda expressions and loop variables, but even then you should stick to , , , , or a letter that relates to the object. I think it would make more sense to use for a rectangle than . 

This implementation is a little different in that the backTests are ordered in reverse. I think this makes it easier to see what the order of things will be, but if you want to keep the original ordering logic you can make the required adjustments to You can then use in the method: 

The main reason to have a as a parameter is so you can specify different predicates. If there's only one predicate you'll be passing in you might as well just move that logic inside the method and remove the parameter. Then, in your case, you may convert the array of tests to an array of abbreviations of type string and use simpler logic for finding a common string in two arrays. looks at two collections and returns the items that are in both. Then you return true if the intersection has any items. 

You probably don't want to call in . Instead you can declare a class level variable and assign to it using in . It's your choice if you want to refactor the code into more methods. The main reason I declare more methods is if I can use a method multiple times, reducing duplication. It can also help with readability. 

I don't have any advice for dependency injection, but I see some other improvements you can make. These changes require . In , you can replace most of the code by using : 

Note that arrayD does not get shuffled each time. I'm not sure if that will affect the randomness. This: 

Here's an alternative way to write . It's shorter and uses expressions instead of statements. You can't do as much in an expression, so I use them instead of statements when possible because there's a lower chance of things going wrong. Readability is more important than those things, though, so I recommend using what is most readable to you. 

You only need one class, and then you can create four instances of it. Your "Spawn" methods can be extracted into a single method, with parameters to handle the differences. For example, because not the same for each obstacle, you can have that be a parameter or a variable in the class. 

The returned function takes an item and returns its sorting order, ranging from to , with 0 meaning it didn't match any tests. You can call the method like this: 

Note that the second parameter is the count instead of the end number, so you'll have to keep that in mind when replacing a loop. You probably shouldn't hard code the logic about things being multiplied by 10. Instead you should use a constant for 10. That way it's easier to modify if you want to change what things get multiplied by and it's easier to tell what the code is doing. I'm going to use the naming convention for constants, but you can use another one if you want. First declare the constant: 

gfv posted the optimal solution, but there is also a lot you can learn from finding out how to improve your code. The most important thing is correctness. As AlanT said, you don't have to write special code for the cases where the array has 0 or 1 elements, and your special code for those cases is incorrect. The code for assigning is incorrect as well. The range to check against should always start from 1 and have the count be . So you don't need to sort at all. And if you did want to get the minimum value, you can just call instead of sorting and then calling . should always contain exactly 1 element, so you don't need to check if is equal to 0. If the count is 0, then the input or your code is incorrect. Calling and is wasteful because it causes the calculations to populate the to get performed twice. If you have to call two methods that cause an to get enumerated, you're usually better off converting it to a list or array first. 

There are magic numbers everywhere. If you decide to change the size of your board, you are going to have to change a lot of numbers. Normally you can just declare them as constants privately in a class, but because they are used by multiple classes I recommend extracting the magic numbers into a class. You shouldn't have public fields. The following: 

In , the lambda expression only needs to be written the way you wrote it if you want to have multiple lines of code in the body. A simpler way to write it is like this: 

It looks good! I only have some minor suggestions. You might want to not have the LINQ expression all on one line. Right now I have to scroll to see it all. An alternative is to use to create a range of indexes: 

If you can only change a bool once, and the entire purpose of a loop is to set the bool, then you should just exit the loop after the bool gets changed. There's no point in looping more than you need to, and you also don't have to worry about the bool getting switched back. So you can write your example like this: 

The class should have better naming. Properties should be UpperCamelCase, and constructor parameters should be descriptive: 

I think your version three is still better than my alternatives, but you might prefer one of them. is nice for replacing loops, and query syntax is nice for declaring intermediate values (like ) and replacing nested loops. But the method that takes a lambda that includes the index as a parameter is very nice for this situation. With enough practice you can get to the point where your code looks like version three right away. I rarely write loops anymore. I actually find them tougher to write because they make you focus more on "how" than "what". 

You can declare the possible values outside of the loops because they are going to be the same each time: 

The method can be improved. It doesn't check if or are equal to 167 or 334, so, for example, if and were both 334, then and would both be 0. I recommend checking for all values you don't want in the first statement. So it could look like this (remember to use constants): 

Alternatively, you could have functions as parameters for selecting the properties, like using a lambda expression in . Edit: as for the first method itself: In the following line of code: 

If you wish to keep the speed of your original solution and increase readability, there are many improvements you can make: 

The only thing that changes for each statement is the index is incremented, so we can replace all of the statements with a loop: 

Both LINQ methods are quite a bit shorter, but the tradeoff in this case is they're kind of tough to read. Moving logic to the constructors could help. 

Variable names should be lowerCamelCase, so should be . Method names should be UpperCamelCase, so should be . 

You can have a boolean as a parameter and select X or Y and Width or Height based on that parameter. You can declare the method like this: