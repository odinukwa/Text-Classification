Have you considered using Conditional Formats as your rendering cathode ray? I've just thrown this together, so it's by no means complete or optimized, but by assigning sprite arrays of values to specific ranges, I avoid the need for any calls to the of a Range. This approach might also solve your dilemma, as you can just write over the top, or you could even to blends! It's fast. So fast I can't tell if it's even rendering on every frame, but I do see lots of movement. It runs about twice as fast if I omit the removal of the prior sprite location. Theoretically, it's 1500 frames/sec with sprite erase on each frame, or 4000 frames/sec if I omit the sprite erase on each frame. Set up the screen Apply 3 different conditional formats for values 1, 2 and 3 

You could also omit the variable, and just use the count of the controls. But you might consider using a 2D array, or maybe a dictionary to keep track of the names. Referring to the Form Designer/Controls You use as the type of the Form, when, in this case, it will always actually be a , but you don't actually ever need the form... you need the . And the are enumerable so you can use 'For..Each`. 

That can be confusing to read, and difficult to debug. Consider using independent variables Magic error numbers You've done half the work of creating custom error numbers: 

The file has nearly all duplicated records, so I'm pushing the limits on the unique key approach. A file with all unique values will perform differently. Using your code against the 5MB file, it runs in 6.18s. If I only read the file, it reads in 0.11s. If I only read the file, split each line and build a key, it runs in 0.76s. So approximately 5.42s, or 88% of the duration is related to dictionary manipulation. So, what can we do in VBA, to improve your code Option Explicit You haven't included it in your code, so I assume it isn't declared. Declare As String The variable isn't declared, although you may have declared it at global scope. Option Explicit shows e this right away. 

For the line and the line are connected. will throw an exception if it is not guarded by . This is a simple example. In more complex cases the maintainer of your code might move some pieces around accidentally breaking the code. If we apply that to splitting the documents into the two datastructures it would look like this: 

The class contains quite a lot of public members that are not really suited for public use. It's a good practice to mark methods as private that are only for internal use. This has (at least) two upsides: 

You don't bother users of your class (yourself) with the internal details It allows you to easily identify which members can be safely refactored 

A few general notes I recommend you to reverse the general order of your code. Most important (or less detailed stuff) at the top. It's easier for readers to zoom in and see the important (public facing) bits. So if you have a program in a single file, put the App on top. Within the app, put the stuff that actually does something at the top of the file. I now have to scroll down and skip a lot of noise before I get to the actual stuff that is being done. 

It seems there is a clear relation between a and a , it seems reasonable to expect a factory method. 

In a sense it's strange that a contains a document title. If you look at the method you see it's actually used in a (somewhat) arbitrary way. From the outside it's unclear which document title is returned. Another indication is that the document title seems not to be used in the indexer, it uses the given document title. You might want to consider some members to be lazy. You are now doing work on construction while it might be much later that a value is actually used. Note that this depends on the usecase. 

Collect all the Widgets Then we need a class to hold all of the widgets. The all important method for enumerating the collection is which has a special attribute set. The class also has a factory method for creating a Widget (Without actually adding it to the collection). 

Properties in Standard Modules Standard modules can have Properties, but as @Rubberduck pointed out, they're not necessarily intuitive (although they do force you to qualify a call with the module name, so there's that as a redeeming quality). You could write public methods instead, but you could also create a class, and if you wanted to avoid the need to it up, you could give that class a attribute. A class would better reflect the stateful nature of the settings, and would give you the flexibility of abstracting the persistence of settings from the retrieval and usage of settings. Right now, your approach looks up the value from the underlying table every time, and writes it to the table every time. That's time consuming disk access and page locking. It might be better to load the settings on demand, use/change the settings, and then save them on exit. Variable Names is presumably short for . Why not use the full name, or better still, something like ? could be confused for the statistical term , or a user might infer that the is Hungarian notation, but guess at what type that notation represents. SQL Injection Kudos for using the (presumably from @Mat'sMug's CR question), but you're building a SQL statement on the fly, and a malicious user, or inadvertent user could cause an error, or worse, by providing a parameter with a single-quote in the . What happens if the user supplied ? At the very least, sanitize your inputs. Better still, parameterize your queries and leave a sign up saying that Johnny DropTables isn't welcome. LateBound `PageFrame` property You're explicitly returning an , which forces usage of the property to be late-bound. You probably know the type of the return value, why not use it? If you know the return-type will always be an instance of , then return that type: 

With a case class you say: this class is defined by it's values. With a Traversable you say: this class is defined by it's contents. To me that is a bit confusing, is it about the parameters passed in, or about the contents? 

To me it's unclear why the method contains the code it does. It seems the code could also be in the class. Or, the other way around, the code for analysis could be in the factory (or another class). I would not use mutable structures to split the document space and documents containing a word, this is more sensitive to programming mistakes. On top of that it disconnects two pieces of code that are connected, forcing our brains to do more work. A simplified example using option: 

I would also change to a normal class without title and a lazy field. About the and the , they seem to be the very related. It seems you can construct an instance from an , this would make the an ideal candidate for the factory of . Such a factory is commonly at the companion object. Note that I would personally introduce a case class for document. 

It's clear that you took some time to polish your code, good job on that. I like how used method names like , the allow for very readable code. My suggestions (note that none of the code was tested or compiled): It's 'weird' to combine a class and a . A case class gives you a few things for free: 

The method has a comment, requiring the user to do something before it can be used. Most programmers will not read a lot of documentation (apart from Ikea manuals) before using a library. In this case it might be best to help users of the method with an explicit type. 

But the would ideally be defined as a constant instead of as a magic number in inline code. Check bounds before using 

Unique keys and Dictionary usage The code to build a unique key and populate the dictionaries is the most expensive, so let's be careful about checking the smallest dictionary more frequently than the large dictionary. Also, there's no need to and then back, when we can just increment the count of the existing entry. 

In this instance, the statement does away with the need for the statement, but if is an empty array, then you'll get a subscript out of range error when you try to ReDim with an upper bound of -1. It may be the cases that will never be empty, but it is still good practice to check. 

If you absolutely need to use your Find approach, or if you'd just like to see a centralized error handler, as per you question, then you can use a variable to store the custom error message, and then refer to that variable from the error handler: Also, in you On Error statement, you don't need the trailing ":" as that indicates that the line will have another statement following the ":" 

Hex to String - Preserving the leading 0 Hmm, I think I can use a bit trick to make the Hex conversion more efficient. 

Using `Val` The function can run into problems when converting string values, depending upon the locale of the user. It is generally safer to use , but it will depend on the input. See Internationalization Tips Indenting/Line spacing Your compiler directives follow on the immediate line after the function signatures, which looks a little cluttered, and hard to spot the beginning/end of the compiler directive. I'd like to see an extra line before and after the compiler directives. Enum ordering I'll let you off the hook for the inconsistent casing of enum members, as I see that you're trying to implement a consistent style, but also trying to maintain the Win32 capitalizations. But, you are using inconsistent ordering of the enum members - sometimes the members are alphabetical, and sometimes they're by hex value. In my experience, it is better to define the enum in hexagonal order (as it's easier to spot omissions), and then rely on the Object Browser/Intellisense to render the enum members alphabetically. Magic Numbers/Constants There are numerous references to magic numbers (like for Office 2000) and string-literals (like ) throughout the code. These would be much better defined as constants (with a view to allowing multi-language support). You make the effort on occasion, but not on others. You also use magic numbers like 240 and 480 (for x and y), but without adding comments (or descriptive constant names) to explain why. Passing 0 to GetDC Your function accepts a Long/LongPtr, but you're passing a integer-literal of . You can avoid an implicit conversion, by using instead of Backward Portability It seems this would almost work in VBA6 hosts, but the compiler constant wouldn't be present. For portability, it might be nice to add a commented-out compiler constant of: 

I recommend the same structure for classes: public (and most important) members at the top. Then (in usage order) the other members. This is ofcourse personal preference. In some cases it's not needed to specify a type. For public facing members it's good practice to write down the full type. For private (and function local) members it's not needed and might actually introduce noise that harms readability. I noticed you are using and a lot. I try to not use them as they require the reader to backtrack to find the type of the tuple that contains them. There are a few techniques you can use to avoid their usage. 

The type is now modelled as a tuple. I would recommend a case class for it. That allows you have the code in search be more readable. 

Note that for the implementation of the implementation of (without title) makes things a bit tricky. For that reason I would add a relation in the document space, either with a or a pair. This would result in to be a map . As a result it would remove the call in which could then be renamed to allowing you to remove the comment. The two most common errors by Scala developers are the usage of on options and on futures. The only place these methods are allowed to be used is in test code. If have (to date) not found a valid usecase for either one in production code. There is a small problem in your method: is an integer and thus could result in . In the (and to some extend in the ) you have mixed statements in your code. As a separation of concerns those should be moved out of the code performing the operations. The functional programming paradigm is really strict in this sense and some of their patterns can help you to do that. The book Functional programming in Scala contains a section about this exact problem. Note that I would personally keep the statements in the app constructor and only remove the ones from the document loader (which I would place in a different class). As with all things, always search for a balance between effort and 'ideal world perfection'.