By synchronously locking on the object, if a second thread tries to call at the same time, the second thread's execution will be blocked (i.e. hung) until the first thread's call to is complete. The problem with this approach is that, at least to some extent, it defeats the purpose of multi-threading because only one thread can do that part of the work at a time. The second way to fix this would be to have each thread create a new object so that they don't interfere with each other. For instance, instead of having the object declared as a class-level field, you could just create a new object inside the method, like this: 

The beauty here is, you are free to implement these printer classes however you want. If some of them all work very similarly internally, you could create a base class for them that those classes derive from. But if you need to make a new printer class, sometime in the future, which doesn't work the same way at all, you're free to implement it anyway you want. As long as it implements the interface, that's all that matters. It doesn't matter what class it derives from, how it works, what namespace it exists in, or even what library it comes from. So, for instance, if you do have a bunch of printers that all work by sending the same kinds of basic commands, you could create a base class, like this: 

To quote an ancient truth, "To every thing there is a season, and a time to every purpose." There is a time to fancy-pants-code, and there is a time to cowboy-code. Experience is what has to guide you in determining which method is better suited for a given task. There are many things that can impact that decision, for instance: 

Let's say that in the above example, the method is called from two different threads simultaneously, and the order that the lines are processed is like this: 

Immutable structs Yay! ✓✓✓ Format provider It seems odd to see a format provider in a constructor, and stranger still to store a format provider for every fraction instance. Think of the memory overhead -- imagine a use case where I perform calculations on millions of fractions, but only want to print the end result. Whoops This will not terminate: 

(I've made a few assumptions, so please correct me if I'm wrong.) Let's suppose we have the following types: 

This implementation of Quicksort has poor performance for arrays with many repeated elements. From Wikipedia, emphasis mine 

It might be worth introducing an abstraction for the type of piecewise linear functions that bound your intervals. For example (warning, there might be errors) 

makes me wonder. Did you look for a faster way? Did you try other ways? Why is that comment there? If I wanted to be really picky, I would question you about the lack of access modifiers and a namespace. Why did you make these decisions? A bigger concern is a lack of methods. Use methods to decompose the problem into smaller problems, and reusable code. The only time you can dump everything in is in a programming contest. My biggest concern is that your solution is overly complex, using both a and a . This suggests a lack of familiarity with the standard libraries. So let's break this down, starting with . I would expect it to look like this. 

You're creating a new for every node in the tree, which is a lot of garbage for the garbage collector. Each value will also end up getting appended to many temporary lists. Let's kick the can down the road and assume that the work of creating the list has been taken care of for us. We take the result list as a parameter and append to that 

However I would suggest that regular expressions are the wrong tool for the job, and you will find it faster to use a with a specified encoding. There is a method that does the following: 

Then, you could implement all of your command-driven printers using that same base class, like this: 

When you think about it, it makes perfect logical sense. In the real world, you'd never even think of designing a car that creates it's own engine--that would be a nightmare. You of course would build a factory which would create both the car and then engine, and then put the engine into the car (inject it). The equivalent in code, would be to create a factory class, like this: 

If each ID1 can only have one valid corresponding ID2, then I would recommend using a dictionary object to store the valid combinations, like this: 

The advantage of doing this is that, just as in real life, you have made the situation much less complicated, and much more flexible, by separating the business logic (i.e. how the car actually functions internally, what it does, or, more simply, what makes it a car), from the construction logic (i.e. how to build the individual parts and how to wire them all together). You'll notice that in the DI example, the car and engine implement interfaces. Interfaces are very important in dependency injection. The point is, that as long as all engines implement the same public interface, the car shouldn't care which engine is actually injected into it. As long as they all serve the same purpose and are called in the same way, their internal workings are irrelevant to the car. In other words, as long as when you press the accelerator, the engine speeds up, it doesn't really matter if it's a jet engine, an internal combustion engine, or a hamster in a hamster wheel. In other words, the car's engine is plug-and-play. Their are many advantages to this methodology. For instance, DI is used heavily by unit-testing enthusiasts because it makes it very easy to test each class in isolation. For instance, if you want to test the car class, you are in full control of what you give it as an engine. You don't even have to give it a real engine at all. You could give it a fake (mock) engine that just reports back to the unit tester whether or not the car was sending the correct signals to the engine at the right times. Another major advantage of DI is that it avoids spaghetti code and buggy-ness in the long-run. For instance, lets say, in the future, you keep adding more and more different kinds of engines to your code. With DI, you'll possibly never even have to touch a line of code in your car class to do so. The less you have to modify the code, the less bugs you will create. The alternative is to have, right in the middle of your business logic, a whole bunch of construction logic which keeps growing in complexity with each new engine type that you add. Your Project, the DI Way So, what does this all mean to you in your situation? Here is a basic idea of how I would implement it with DI principles. First, I would create a simple interface which would be common for all of your printers: 

At this point we can remove altogether. Next up is . Here's a good example of us being interested in local operations -- we can remove the parameter. 

Here I'm assuming there's a method to extract the data as in your code. It might be more performant to write your own extension method to do this for you. Here I've provided an overload that allows you to specify the comparison, but you might not need that. (You would also want to add argument validation if this is being used in the real world.) 

I'm going to throw my hat in the ring with the iterative version of Heap's method of generating permutations. It took me a while to get right, as my reference source has a typo in the algorithm -_-. 

If isn't being used elsewhere in the class, move its declaration inside the inner loop, or just use it in the function call. Now your method looks like this 

You can see this quadratic behaviour by running it on the input , for example. In fact, you'll most likely get a . Now in your test data, you have \$10{,}000{,}000\$ elements, but you're only picking random values in the range \$[0,1{,}000)\$. So... you have lots of repeated elements! Let's run it as-is on my computer (I didn't run insertion sort, as it's too slow) 

Having worked on a similar system, I came up with a very similar design. So either we're both doing something right, or we're both doing it wrong :) Here are some things I would change, but obviously different requirements call for different decisions and may not all be applicable here. Remove class I don't think you gain much from having a base class here. Now your inspections look more like this 

is not guaranteed to be thread safe, so calling it in is problematic. To illustrate the problem, try running the following code 

Then, you can check to see if the currently selected values are valid by simply comparing them to the valid combinations in the dictionary, like this: 

By doing it that way, you only need the single statement. Another side benefit is that you can now store the list of valid combinations somewhere else, outside of your code, such as in a configuration file or a database. Then you could load the data from that data source into the dictionary at run-time. 

But again, the point is, you don't have to use that base class at all. At that point it's totally up to you how you implement each printer class. They may all share the same base class, there may be three different base classes, or you could implement them all separately with no shared inheritance at all. In fact, rather than using inheritance, you may want to create a separate helper class which includes all the common business logic, and then just inject it into each of the printer classes that need it, for instance: 

Then, you would need to create a separate factory class which creates all of these objects and wires them together properly: 

Simply put, from an idealistic standpoint, fancy-pants code is always better than cowboy code, but from a practical standpoint, fancy-pants code can sometimes be much worse. So, as a general rule-of-thumb, I would say that you should always fancy-pants-code unless you have a good reason not to do so, and you should accept that there are some very good reasons not to do so, sometimes. I have a lot of experience with this, and I can tell you, designing code well up-front, is WELL worth the effort. It's true, as you said, that good design has more up-front cost, and poor design has more back-end cost, but to say that the two are equivalent, because of that, is fallacious. It all depends how much back-end work will need to be done. As you say, a simple statement isn't really that bad, and if adding more statements to the statement is the worst of the back-end cost that you are going to incur, then it's really not worth the time to add a bunch of complication to avoid something as trivial as that. But if the project grows and changes over the years, a little shortcut like that, to save a few hours of development time, could potentially cost months of development time in the long run. It all depends. Another issue which often muddies the water is that not all fancy designs are actually good designs. You could develop the most impressive fancy code in the world, but if it doesn't actually solve any problems, such as making the code more stable, flexible, or maintainable, then you've actually made the problem worse by all your fanciness. As much as I am a believer of good design, I am also a strong believer in the YAGNI principle. If you haven't read the wikipedia page on YAGNI, I'd strongly recommend it. YAGNI simply means "You aint gonna need it". Simply put, don't add features and complication that you don't currently need. YAGNI does not preclude good design, but it does preclude unnecessary fanciness. Again, the issue isn't whether or not the design is fancy, it's whether or not the design is good. A good design will follow the YAGNI principle. It is definitely possible to "over-design" something. All that being said, if there is no good reason to cowboy-code on this one, as it sounds like their might not be, allow me to offer my perspective on what a good fancy design might look like. My way is by no means the only right way, but hopefully it will be helpful to you. I'd like to think that my fancy way of doing it does solve a lot of future problems and would therefore be worth the relatively small up-front cost. My Way to Do It (Dependency-Injection) Your first instinct was to think that the Factory Pattern would be a good solution to this problem. That was a good instinct, but I don't think it quite goes far enough. Dependency-Injection (DI), which relies heavily on factories, is perfectly suited to this type of problem. Personally, I think it is well-suited for almost all problems, but there are certain problems, like this one, which just scream dependency-injection. In general, the principle of DI is that a class never creates it's own dependencies. So, for instance, if you have a class, and it needs an object, you wouldn't have the class create its own object. Instead, you would have the class request that the (it's dependency) be given to it (injected), usually in its constructor. For example, rather than having something like this: 

However, you can generalise your data structures. I think the key insight is that you're not searching through an array, you're searching through a sequence. The interface then makes it easy to express the solution. 

That's not an appropriate use of , "The exception that is thrown when there is an attempt to dereference a null object reference". 

The solution can be made cleaner by re-arranging the order of the arguments and using pointfree style. 

makes no sense. The question states "Given an array of digits (1 to 9) as input...", yet your test input is . 

My first reaction is: don't do this. By creating your own encoding for an array of strings, your XML is not going to be (easily) consumable by other programs. By Base64 encoding your strings, your XML is not going to be human-readable. These are two major benefits of XML, and if you're willing to sacrifice them, maybe XML is not the right format. If the serialized data is only going to be consumed by the same program, binary serialization would be a better option. That said, if you want to serialize a list of strings to XML, this is what I would recommend: 

In type annotations, it's conventional to have a space on either side of the , for example instead of 

There's a typo in the setter, it should be . As it stands, calling the setter will cause the program to crash. You can avoid typos like this by using auto-implemented properties, e.g. 

@tim suggested a way to do this with less memory by sorting the array. There's another way to do it with less memory without needing to sort. Let's say that \$k\$ is the duplicate value in the array. Then we know that the sum of the elements in the array is equal to \begin{align} 0 + 1 + 2 + 3 + \cdots + (n - 2) + k = \frac{(n - 2)(n - 1)}{2} + k, \end{align} where we're using the identity \begin{align} 1 + 2 + 3 + \cdots + n = \frac{n (n + 1)}{2}. \end{align} So if is the sum of the values in the array, the duplicate value will be .