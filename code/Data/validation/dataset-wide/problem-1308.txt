If shape and number of polygons do not change (or at least not often), I would add an extra step (the new first step) to your algorithm. Calculate the center and radius of the smallest surrounding circle for each polygon. This way you can calculate in a minimal and maximal distance of all vertices from the given position in one run without iterating through them. If the minimum distance for a polygon is greater than the maximum of an other polygon, no vertex of that polygon can be the nearest => we can ignore this polygon. Than proceed like you did before. 

Not sure if my explanation is legit, but when you give a thing to another function, this function can do whatever it wants to this thing: it can take it as mutable or not. That is not anymore the problem of the previous owner. 

then I read that Haskell people prefer to compose functions and then pass the parameter, not doing the forward thing. What do you think about that? Also, I searched over the Internet, and I found some divided code, more like that: 

I recommend to do the in a separate method (or simply use I recommend to use instead of I recommend to return an array with the size matching the new number of entries. even if might be cheap to compute, you should avoid computing the same over and over again in the loop-condition. 

I think speed will only increase a bit, if at all, if you use arrays (The List implementation you use may already use an array). But you will reduce memory consumption if you switch to an array based implementation if you reduce the number of objects used this way. You should profile both implementations to compare speed and memory consumption. 

The point of an interface is to abstract away the implementation details from the client. has the method which publicises exactly what the implementation is. This is called a leaky abstraction. When writing an interface, think about what other implementations might look like. One thing that you do know about all implementations is that they are going to need a file path. An alternative interface might then look something like this 

to a method passing true or false as a parameter and reuse it instead of having nearly exactly the same code twice. 

REMARK If there is any rule for the distribution of the intervals, you might be able to calculate the correct interval (or at least calculate a good guess and search from there). 

If possible I would try to avoid a method like . If someone manages to manipulate the this becomes a classical injection problem. If you do not need the flexibility to make any kind of db requests, use prepared statements for specific requests which only get some parameters. 

I am learning Haskell, and what is better than advent of code to do so? The day 1 problem is about adding together the digits that are followed by the same digit from a "circular" string (the next of the last is the first). My solution is the following: 

You better express your attempt with this. Also, you do not need to put the type of depth, this is by default. If you want to run at least one time the block, this is better (in my sense) to write this: 

by an Enum which would add typesafety and also helps your IDE to detect e.g. if a state is not handled in your statement. 

In my point of view you cannot implement and any clearer or simpler. In the method I would somehow separate the values and also not print two times and not at all. Here is my suggestion: 

You can move your method to a Utils-class and pass instances of different Classes all implementing the same Interface. e.g. Based on your parallelizationEngine #3: Utils: 

If you only need to read one line from a file that will not change at runtime, you can use As already said, the whole program can be simplified a lot using a functional programming style on iterators: 

My question is not only about the algorithm (I think that it is ok, and the problem is not that difficult) but also about the "haskellish" style. Because I am used to Rust/Ocaml/Elm etc., at first I wrote: 

Streams implement IDisposable, and should always be disposed of when used. Typically this is done with block. 

Cool question! In addition to t3chb0t's great comments, I would suggest using a instead of a . It has additional support for blocking and bounding so you don't need to poll the queue manually, and you can limit the number of "in-flight" files. This could be used to make sure you don't read too many files into memory at once. 

Explanations: gives you a shifted string. makes the iterator cycle infinitely, remove the first (replace it with for the second part. You the zip the two iterators: one on the string, one on the shifted string. Then you keep the pairs with same numbers: Then you convert each to and you discard the failed conversions. Then you make the sum of all the numbers. If you want to do the two days in one like in your code: 

There is an abstraction that will automatically have any config updates when injected, so you don't need . I believe it is scoped per request, so changes to the config will not affect in-flight requests (you may want to double check this). To deal with updating the , you can write a small, thread safe that will always return the same client for a particular base URL. This would be registered as a singleton, and could be reused for all the clients in your app.