This could be an important issue if you were looking to manage a cross platform serialization. If you make a data file on Linux and copy it to Windows, it may not display completely correctly. Even if Windows handles the display correctly (many apps are becoming more line separator agnostic these days), it's still technically bad code hygiene. I have two suggestions for the above code: 

The is signed variable length encoding integer and maps to scalar in C++ and primitive in Java. The is a plain and simple in C++ and in Java. The last field accepts some slight overhead to simplify the code by encoding the field as an array. The option on the end configures the library to pack in the values as tightly as it can. This is for simplicity's sake, and if you require anything more granular than that, there is always the type, which maps to in C++ and in Java. Finally, you'd use the command to create C++ and Java libraries that will handle the serialization for you. will generate the and files for the C++ bindings and a class with a special object for Java. The best part of this is that protobufs support plenty of helpful features to let you add or remove fields while maintaining a degree of backwards compatibility. Need to add a new field? Just recompile the bindings. The older versions of bindings will gracefully ignore any data fields they don't care about. Extensibility can be a big deal if the data has any chance of being modified in the future. Google uses this as their "lingua franca" of data serialization tools, both for storing data and encoding RPC requests. (My examples use protobuf v2, but they now have a v3) 

Result The problem states that all strings that are not already palindromes are only off by one character. Our loop moved and such that if , then the string is a palindrome. It has also moved these indices such that if the string is not a palindrome, one of them is 'pointing' to the character that needs to be removed. To figure out which index is correct, I chose to compare the character pointed to by to the character pointed to by . 

Palindrome Function You don't need this function at all because we know that if the string is not a palindrome, it is only off by one character. We were able to figure out the index of this character just by moving and Anyway, since the function returns a boolean, it should be named 

I would also say that the user should have no idea about . A practical reason for this is that I, as a lowly stack user, have no idea what the most efficient is. The OO reason for this is that this is a detail that I do not need to care about. All I need to know about a stack is that it is a FILO container. I would expect it to have push, peek, and pop functionality. I don't care if it is implemented as a dynamic array, or a linked-list, or whatever. 

As a side, your if statement isn't doing anything because both cases assign the value to configOptions. 

The stack should be an incomplete type to the user. This is going to allow you to hide all of the implementation details of the stack. Right now, it is possible for the user of your stack to change the variables contained within the struct. 

This works fine on Linux machines, but Windows uses to denote line endings, and Mac traditionally uses for line endings (though I believe this is relaxed a little). If you were to run this code in those environments, your outputs may look strange or not separated at all. You can save yourself from some confusion down the road if you modify that line to be : 

I'm assuming that the reason for needing this is for some form of interoperability between a Java process/routine and a C++ process/routine. For the sake of having a more robust solution, have you considered using some form of serialization library to handle the byte array format for you? For instance, Google's Protocol Buffer project is perfect for creating a single definition of your data model, and then creating bindings for different languages (Java and C++ supported) so that you can serialize/deserialize that object from any source. Essentially you'd create an definition of the data you want to represent in a file (like so): 

This may sound really picky, but if this is actually some library code that you would like to reuse in different environments, then you might run into minor issues because of the line : 

What if you eventually want to serialize data that contains newlines? If the data you're about to serialize contains a newline, instead of throwing, you could simply replace it with a magic character that transforms back into the correct newline character for your system when you deserialize. Using is technically fine in the scenario that you're only looking for a character to delimit values, but if you're expecting that the serialized data is human readable on any system that it's created on (or copied to), then you might want to consider changing your delimiter to be something more platform friendly like a comma () or pipe () character. Alternatively, if making it readable isn't that important, possibly a non printing character? The Character is noted as a "Record Separator" in this symbol table.