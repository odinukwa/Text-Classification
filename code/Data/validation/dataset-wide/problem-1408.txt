Your not yet real observables are the POCO objects that implement the interface. You can turn them into observables with helper factories that can derive an from the event pattern. 

I would then make the shortcuts configurable via the app.config or any other configuration. The key would be the command name and the the value the keys: 

A similar rule applies to LINQ chanins. Either no line breaks or all line breaks. Mixed styles are difficult to read. 

Always use . You can save youself hours of debugging because without them it's very easy to make a mistake. 

If you made the method an extension too, the method could then be reduced to just a few lines of code of mostly LINQ: 

Lastly don't do it like this at all. Create a single repository where you put all the queries you need and you're good. There's no need to create a repository for each entity type. I bet most of the APIs you'll never use anyway. Entity Framework is already a repository so creating a CRUD wrapper for all entities is just a waste of time and having repositories just for the sake of having implemented the CRUD repository pattern is pointless. This repository virus spreads like a disease infecting all projects. Everone thinks they need a repository but they don't. What they need is just a bunch of queries to get the job done. 

Likewise is this method doing too much. It not only creates a base64 string but also replaces some characters. This should moved to a new method like or whatever it does. It can be but this kind of custom processing should be encapsulated. 

The first thing you should improve is to split this method into two methods, one for parsing the input string and one for building a new query. Doing both in the same method isn't a good practice. This means that the first method should return a collection of columns that the other one consumes. 

There is always one message that can contain any number of nested elements. Desclimer: the class names are not random, they are industry standard element names like stands for Inbound Flight Information or stands for Operational Outbound Flight Information and so on. I use full names in the production code but used the letters for testing the tree algorithm. The is rather straightforward and just implements the interface (nothing unusual here): 

This way you can configure each parameter separately without having to set other parameters explicitly to null: 

Categories I suggest changing this design before it's to late. Having a table (?) with separate columns for each category (, , ) is a very bad idea. What if you introduce a new category? You need to change the database model. The categories build a tree. This means you don't have to store each category id with a listing. You know the parents so they are automatically selected if any child category was chosen. 

Is this an overkill? It might be but it shows me that you are able to write modular and testable code. Writing short code is a good thing too but if you write only five lines inside a in a job interview, you'll go home without any prospects of getting the job. Again, in an inteview you should sell your coding skills and not show how smart you are in solving something with a fewest possible lines of code that no one can verify. 

Decorator I find the decorator pattern would be a better choice here. With a decorator you would define an interface like 

At the same time you use a little compile trick with the to get the property name and based on this the actual query string name that will be the key of the dictionary that the class is derived from. It also overrides the method to generate the query string. Lastly you need a downloader to get the data: 

In your case creating this dummy and not actually used objects may hurt performance because you add a lot of garbage to collect. You could replace it with a simple instead and avoid the entirely. 

I still need to clean-up the container configuration but this shouldn't be easy done with autofac-modules also exchangable for testing. 

Here the main class is the with only two public APIs - that splits a cron expression fields and call their factories - that passes the to each field that evaluate each date-time-part 

In your example calling is unnecessary too. The group is already created and calling just enumerates it again. 

This shouldn't be there. You either need another method that sets default values for uninitialized properties so that the user knows his objects are modified or... you need another really safe approach. This means you need a special comparer that you can use with the 

If you used the enum instead of just calling it like that, your methods might have be implemented as: 

This will give you a much better performance for large maps because it will create the nested objects only once unlike in your current solution where it creates each object everytime you call any of the factory s via the / etc. properties. If you have any loops that traverse the map it will be created over and over again. Here's shortened example: 

The components necessary for the changes I describe here are not released yet and the new features are still in beta but they are very interesing and worth trying. 

Single Responsibility Principle Always keep in mind that each class, method etc should be responsible for only one thing. This means that your test server shouldn't be printing anything to the console. It may log something but let it log to an abstraction so that you can attach any logger to it. Now the no longer depends on the . 

It's supported by two other utilities. a - its job is to create the context that must have a constructor accepting a connection string name. 

If you are applying for a position of a junior developer I'd forgive you some of your beginner mistakes that are: 

The main class is the that encapsulates the enitre setup process that I had to repeat for each query/database. Most databases that I use are readonly so I do not need hte change tracking and thus the property allowing to disable it. I use model-first for all of them. 

In other places like where you use there is a danger that if an exception is thrown the bits won't get unclocked anymore because there is no block e.g. the method should be implemented this way: 

Everything else you can track with the . I added a new property that is nullable and empty if a notification couldn't be sent. 

If you need more control over the replacement process you can use the . This will allow you to evaluate each single replacement. This is not exactly what you are doing in your code but in case you should need it here's an example: 

Database model Let's simplify your database model first - which I find is a little bit strange. The doesn't need anything but those two properties: 

Without manual casting you are guided through the creation process so everything stays fluent. Or maybe there are better ways to suggest the fluent path? 

It calls a resource at via GET. This example does not override anything but should I need it or add some query-string parameters, I can do it inside any extension for the rest-method just by changing the uri-builder of the configuration: 

Even though it turned out that is inspired by a similar SQL function I think the C# edition should be calles FirstOrNullIfEqual. I always fould the SQL one a little bit counter-intuitive and incomplete becasue every time I see it I'm automatically asking myself null-if what? As far as the API is concered I think one more overload allowing to specify a custom would be useful in many cases: 

This seems to work even better then the original method. It correctly recognizes invalid syntax where the original one thinks it's valid. 

Example This nicely works for all types that support the required operators like for example a fibonacci sequence with a time-span. 

It is also not necessary to use the with the becuase each inner already runs in parallel. That's the whole point of it. But still, you need to test it first. Like I've said, only if the resizing process takes a lot of time this might be worth parallizing. 

I've been working on another timesaver because I really really don't like to type all those validation s and exceptions over an over again. What I came up with this time is a set of validation extensions that make use of expression trees even if very simple ones. 

If you cast the into a it would be a big surprise to the user if the resulting array looses it's sign. I think the parameter should either be a or the conversion needs to take a negative value into consideration. 

It is not easy to follow and you won't know how it works or what it does because the names are really messy and when you see the code in a while you'll be asking: 

Injecting the doesn't seem to be of much use here as you are setting its to a hardcoded string of the . The whole point of DI is to inject an already configured rest client so that you can test it against various targets that you pass via DI. The same goes for other things that you setup in the constructor. Currently no matter what you inject the result will be the same. ApplicationException You shouldn't throw this one. Create your own that by its name already names the reason for the exception. 

You use the the twice here but you discard the first one. I think using a to collect the s would be enough and then you can use this list to shuffle it and create the navigator. 

I also suggest moving the object creation into a separate method so that you don't have any nested loops like this: 

Usually it's better to define the variables nearest to their usage. You don't need them globaly but only inse the block so define them where you actually start using them. 

It doesn't matter unless you need to optimize it for speed but you do this only for parts that you have and can measure. You don't optimize code that you believe might by slow because someone heard from someone who heard from someone else that something might be slow. 

I cannot comment about the speed because I didn't benchmark it but there are two obvious improvements. 

You now want to list all categories together with their listing-counts. If you keep it simple you can achieve this with a join. I assume you have these two tables: 

You can the return value and the new value so that you cannot by accident modify it from outside. Everything else is beyond its responsibility scope. 

I don't think there is any other way to solve it. By using the event and initializing a you do it just the way it should/can be done. You may however consider renaming the interface to and the method to which more clearly describes what you are doing. You don't create any tabs, you initialize them so name the interface and the method accordingly. Internally you can use a boolean field so that the method checks it and doesn't initialize your tab-page multiple times. Then you just do: 

From the technical point of view you could implement both interfaces at the same time but you'd have to implement the method explicitly and without repeating yourself it would go like this: 

This should be called as this is what it does. It does not search for instances of the subclasses but it creates them. 

In addition to @AdrianoRepetti's suggestions I find that the only method you have there, the , does not require an instance. It could be just an extension for the collection and it could be implemented purely with LINQ in a lazy fashion: 

You could iterate over the only once with the extension where the first collection starts at the first element and the other one at the second element with . This will produce tuples with pairs such as & . Now you can filter it and pick at the same time the element that satisfies the condition: 

This method does not need to check for because it should initialize it. This means it is definitely so just create a new instance of the dictionary and add the items. The modifier needs to be changed to . There is no point in calling it again by the user (I think) but if he did it, then it will crash because it'll try to re-add the already added keys which is not allowed. 

As far as lists and arrays are concerned there is actually only one main difference betwen them: arrays cannot change its size. Use what is more conveninet. If you have fixed collection of items the I'd probably use an array an in all other cases I guess I'd chose a list. Alternatively you can use as a return type and since most collections implement this interface it doesn't matter what the underlying type is. 

I suggest reading about XSLT - Transformation first. With this you can write a script that will transform your input to another that exactly matches your classes. 

here you can even remove one using as the can take the response stream as a parameter in its constructor. I don't understand why you are copying this stream twice - for caching and for validating. You can do both, just rewind it after you've validated it with MemoryStream.Seek. 

I measured your code and this score is 8. There is a way to improved it if you encapsulate the code creating the paths. Currently those two lines cannot be tested so you actually have to debug or run your application to be able to verify that both paths are the ones you expect. If you put them inside another tool like a 

We need also an enum for the directions. You already have one but let's fix the naming that should be PascalCase for public APIs: 

you use the constraint to be able to create an instance of the generic argument that at the same time must implement the interface below that requires one method for searching: 

I cannot tell you whether it's 100% thread safe and correct but I had some general comments on the design. 

There is not much to comment on. In general the code looks fine. I can only suggest making the shorter by using the (coalesce) operator 

Next I'd create specialized queries where each of them does only one thing (currently your query is able to do four different things) 

Just create the dictionary again. It has only 10 items. This will probably execute in less then 1ns. Instead of setting each value manually consider creating the dictionary dynamically: 

I think you are not testing everything. The API should create a user but the only thing you assert is the 

I start the application from the where I initialize the processors and the (from ). Then I wait untill they all are done or cancel the one that might be either hanging or working with too much data at once. 

I usually don't like the but in this case it looks like a perfect example where I think you'd be much better off if you used one instead of the (that I'd name ). The already can do all the equality stuff so you don't need to write it yourself or you can derive your class from the so that is supports the operator. 

To me it looks fine. Just some minor adjustments: I think it would look even nicer if you defined constants for the magic numbers.