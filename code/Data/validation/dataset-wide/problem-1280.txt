You iterate over all books in the library, and if one book matches, you return the whole library. That's not, what you intended. And more Do not return ! Please, never ever! That doesn't make any sense and leads to excessive use of Guard Clauses against . It is a clear antipattern. In Java8 there is a nicer solution if you want to hide in an optional. Say, your teacher asks you to look for a specific book on the shelf and you do simply nothing - what does that mean to your teacher? A) you are deaf or b) you are dumb or c) you are neither, but there is no book. If someone asks you for a list of books, when there is none, simply return an empty list, and say politely: »Sorry, the list is empty, because there was no such book«. 

I do not get the reason for having two functions for asc and desc ordering. In principle, if asc is a call to a function , then desc is nothing more than calling the same function with reverse order of parameters . No need for code duplication. As far as I can see, the only difference beside calling your sort function with different parameters is, that you in the asc-Version have lines, which contain and the desc-Version calles . You could refactor this out into a call resp. . Besides that this code has to be broken down into smaller easier to understand sections - I really do not want to get my head around this - you have to avoid code duplication by all means, since it is the N°1 source of errors: if you change a statement in one place, you have to make sure, it is changed in every further place. 

I understand you are asking for a function to check if a point is on a line. The question itself is ill-posed: because the representation of points and lines on a computer is only approximate and if you approximate a point on a line you probably get a point which is no longer on the line. A typical example is to check if the number satisfies the equation . Even if we expect to find a solution to this equation (because we use the real numbers as mental representation) there is no floating point number which solves such equation. Hence it is almost always wrong to check for equality of two floating point numbers. In this cases what you are looking for is an appropriate approximation. So instead of looking for one is happy enough to solve . The small value is somewhat arbitrary, and can depend on the problem you want to solve. So my suggestion is to implement a function which computes the distance from point to line $URL$ and use it to check if the distance is small enough. There are many other factual problems with your code. Here: 

You should change your algorithm. First note that triangle numbers can be written as: \$ T_n = \frac{n(n+1)}{2} \$ then notice that \$n\$ and \$n+1\$ cannot share a common divisor. So you can find all the divisors of \$T_n\$ just by finding the divisors of \$n\$ and \$n+1\$ (and removing a factor 2) and multiplying them together. This alone should greatly improve your algorithm turning it (the part inside the main loop) from \$O(n^2)\$ to \$O(n)\$. Then you could make a table of prime number to quickly find the factorization of \$n\$ and \$n+1\$. Once you know the prime factors of \$n\$ you can find the number of all divisors of \$n\$. See, for example, here: $URL$ addendum First advice is actually enough. Here is the code (I don't know C#, hope it compiles): 

I've seen, that you made up this code as an example, so I hope, that this is not your production code: 

I think, there is room for some improvement: 1) You are mixing OOP with procedural code If you choose one paradigm, you should stick with it. Besides: why are you abstracting into a class and not the whole ? 2) DRY - Don't repeat yourself 

Even better: you have microtemplating on board, which means: You could define HTML including placeholders within a script-tag 

First: I have to admit, I do not know a single line Elixir. But on the other hand, I think I get, what the code does. I can not give you advice, how to implement the improvements, but I hope to help you anyway. In the description you have the following definition: single minutes: When it is 1 minute past the hour, YOOO is returned. When it is 2 minutes past the hour, YYOO is returned. When it is 5 minutes past the hour, OOOO is returned. single hours: When it is 1 hour past, ROOO is returned. When it is 2 hours past, RROO is returned. When it is 5 hours past, OOOO is returned. What both have in common is the pattern and the result . That should result in one function, which takes the following parameters: number,Symbol and produces the according output. Your code has: 

for performance reasons. Does it makes sense? More context: is guaranteed to be non negative. The code is used to fill a circular buffer of length , is first incremented and then the check is performed. depends on user input. The code is an interview exercise so there is no clear context. 

This check is non very useful. It does not decrease the algorithm complexity. In particular the check is wrong... you want the function to fail if the arr is not a list, otherwise you hide possible errors in the caller's code. 

which can be achieved if you define a dictionary of classes. The code could become even longer, but separates more clearly the logic of your Range class by the information about different Tokens. If these Tokens have other functionality using a class becomes even more convenient. The definition of token is clearly separated and does not interfere in the logic of the application. Also, adding a new token is a matter of defining a new class and registering it in the dictionary of tokens. Similar token could benefit in inheritance. For example: 

use a bytecode to store your compiled code. The only thing you need is to replace the brackets with some sort of jump_if statement. No need for linked list... just a buffer of bytes. write a function to compile BrainF*** into your bytecode. Just copy the source code and put the current address on a stack whenever you find an open bracket. Write the jump_if statements when you find the corresponding closed bracket. define a data structure for the state of your virtual machine: data pointer, program pointer... and that's all. write the interpreter as a function accepting the virtual machine. 

This gives you nothing in terms of performance. It would be optimized away by the browser. 2) Chain-calling 

Why only compare the title? There are at least two books calledFrench Kitchen, but they are not the same, since the authors differ. 

I wouldn't say, mine is better, but I prefer it this way: 1) One entry, one exit 2) One variable changed if needed. 3) Easy to follow. 

I can't find any reason for your global variable. As far as I can see, it is declared and overridden in the success handler of your ajax request. So why not declearing it inside the success handler? Next: Why didn't you use a parameter in 

Besides the nice OO-solution, another (procedural) solution to your looping problem is possible: If you have cases, where you iterate over a collection of and only the first element needs special treatment, you could it off your collection, treat it like you intended to and iterate over the rest, so in your case: parse the text until "headline" is reached and iterate as intended over the rest. You could make use of to shift the first element. Pseudocode: 

is in fact a model with a key called "content" (e.g. {content:"blah!"}), which is used to render the template, so that <%= content %> is substituted with the actual content. And many more stuff to discover. Referring to your problem - you could abstract your problem with backbone like the following: Every tab you need to display is a view to which belongs a template to determine its html as well as a model, which represents the content of the tab. You could embed each tab in another view, such that you have one embracing view to control the whole tabbing system and nesting views, which represent each individual tab. You could write a custom show() method to show an individual tab and a method which coordinates which of the tabs is shown and which should be hidden. So instead of doing the annoying work yourself, it may be a good idea to use a library to help. Some places to start (besides the official API and documentation): $URL$ $URL$ $URL$ $URL$ 

I would extract the code which draws a single star in its own function. Also I think it is important that such function will draw a star centered in the current position and leaves the turtle in the same position it has found it. Otherwise I think that the stars you are drawing are not centered exactly around the center of the screen... or at least it is not clear to me why they should. 

You code is quite efficient and well designed. I think you can get a little bit more efficiency at the cost of making the code more specific to this particular task. In particular there are some shortcuts: 

even if you have only a single option it would be good to write your code as if there were many. This could be simpler to understand and easier to extend. I would keep the options (in your case which you could transform in a boolean variable ) as global variables, and parse them in a dedicated function. Once you have extracted that code from the main function you will feel more eager to add other options (for example --help to print the usage message). You function is definitely too large. Extract the arg parsing code. Put the logic into a separate function and let main just be glueing code. Here you are reinventing the wheel: 

Besides what Flambino wrote I have a small remark to (3): Why are you storing unnecessary information in the DOM? I would prefer a solution, where you use a simple variable to keep track of whether the button performs an action or not. So you wouldn't have to update the DOM twice for nada. The DOM is a bad place for storing the state of your application. 

You have a instead of a plain variable. This helps you to encapsulate: 1) The name/filename (in case you need it somewhere else) With the constructor, you are free to define a naming scheme for your files. For the sake of the example, I simply used ".dat" as a suffix. 2) The actual datastructure (here for the sake of the example a list named »array«) 3) The calculation function This is, what OOP was invented for: keeping together data and functions, which work on that data. In the -function, you see, how you set up things: 1) the are made of a simple tuple, holding the name as the first element and the function as a second element 2) the configuration of your "variables" is done via list comprehension . For more complex tuples, I would go with namedtuple which allows you to reference the content of the tuple via proper names than indices, which would result in better readable code. But in this scenario, the indices do the trick. Your -function should take the list of objects as a parameter. And you are done. 

A documentation string here is important. The names of the variables are so vague that even knowing the task in advance is difficult to understand their meaning. 

note: in C++ it would be easy to make the computation of the array of the perfect squares at compile time. Maybe also in C it could be possible (using #defines) but not as easily. 

(this is something one can learn in algebra courses but which is very commonly used in elementary school maybe under the name of "casting out nines") or more literally: 

(added: the difficulty to achieve a DRY result is an indication that the variable could better be an integer in which can be used as an index in the "OX" string.) Two. This: 

If is the length of the text and the length of the pattern, your algorithm is while this one is which cannot be improved further. 

this is not a good starting point. Your implementation is very far from being comparable to any database program. What you are doing: 

For each token you are describing a triple of sets (pairs,suited,off_suite) which are parameterized over a value. It would be nice to have a code like this in your :