From a SQL Server Perspective if you are doing the to allow for dynamic passing of parameters and skipping a parameter from being evaluated, I would suggest you read a couple articles from SQL Server MV Erland Sommarskog. His approach removes the need to do some other tricks inside of dynamic SQL (like the construct or using a construct). The the 1=1 shouldn't cause performance issues as @JNK mentioned (I've +1'd his answer there and that is the one that should be accepted), I think you'll find some good tips from Erland's article around Dynamic SQL and you'll also see he still uses the one for the cases where no parameters are passed but he avoids them for individual parameters that aren't passed, he simply doesn't mention them in the resulting where clause at all. 

I see this question is a few months old, but I wanted to tell you about a great update from Microsfot if you've missed the news. On November 16, Microsoft announced the release of SQL Server 2016 SP1. Along with the normal things found in Service Pack releases, they also included CREATE OR REPLACE functionality. And, really important for your question, they've made quite a lot of the features that you can develop for available in editions other than Enterprise. Most critical for you here is the availability of the Always Encrypted feature in SQL Server 2016 Standard and even Express starting in SP1 of SQL Server 2016. You can read about that here on Microsoft's blog post. 

If you are going to drop a database, you have to be the only connection to that database. If any other connections are there, you can't drop it. From the error message (that error means your database is in Single_User mode but there is already a connection so you can't connect) my assumption here is that you tried to set it to Single_User mode and then attempted to do the drop but either you grabbed a connection that you didn't know about, or some other process has. The fact that restarting SSMS worked for you tells me it was probably you grabbing that connection. So here is how you can fix that. Logically you have to put the database back into multi_user mode so you can then put it into single_user mode again (but this time you'll be in control of that single connection allowed and drop the database before something else connects) and then your database will be gone. In code here is how you need to do this (but first close your query windows that are connected to that database. Restart SSMS and make sure you don't select this database in the object browser): 

When you get this message it can be a few things. Some examples: 1.) Read Only Marked Files 2.) Insufficient permissions to the files for the SQL Server Service account 3.) Insufficient permissions to the folders the files live on. You indicated in our chat that this was not read only. You also verified permissions looked like full access. That ruled out these three items. The fact that, from our chat conversation, you were not experiencing this issue when you properly detach a database using sp_detach_db - which actually changes permissions around a bit on the files led me to suggest trying to run SSMS as administrator. Why? Well this article gets into a lot more nitty gritty about some of the impersonation issues here - but my understanding is: 1.) When you just stop the SQL Server Service and move the file around. The owner of the file is the service account that created it. 2.) When you detach the database - you'll potentially notice a permissions change. The owner has changed basically and the file is not really associated with that SQL Server service account the same way. 3.) So it works when you try to attach because the permissions can get assigned, because the security of the file allows it.. But if you just stop the service the security hasn't changed, and you can't attach that if you have UAC enabled unless you are impersonating administrative access. I've probably made the file ownership and access more confusing here but the article I shared probably does a better job :-) But one slight moral is - do a detach next time ;-) Or just be prepared to run SSMS as administrator from time to time when interacting with the OS in various ways. 

In Short: Everything and Anything. And Nothing. But seriously: A few thoughts about changing the SQL Server service account: 

Shorter answer to the title of the question: No. Why would you want to lose the ability to treat a date like a date. So important for sorting, date functions, etc. A few thoughts to get you started at least, not sure which DBMS while answering, answering based on my experience with SQL Server: 1.) GUID as a Primary Key is generally not a great idea. Not in SQL Server especially. What's wrong with an Integer primary key? Yes whatever your Primary Key is becomes your Foreign Key in the child table(s) so that is large and probably not necessary. 2.) I would use a regular datetime column. Performance wise, if you are well indexed, you shouldn't notice a difference here. And a datetime column is more versatile as, well, a date. You can ask questions of it that you can't ask as easily of an INT column with built in datetime functions. If you don't need time and you are on a DBMS or version that has just the DATE you can use that data type. 3.) Yes. Especially if CustomerID is a foreign key to a Customers table. Good to index. Whether or not you need to make an index on CustomerID AND the Date column depends on how the queries will typically look. If you are often querying joining to customer and specifying a date range you may find it beneficial to have the date. You may find it beneficial to include some other columns to cover other queries as parts of the key or included columns. It really depends on your queries and data, though. As far as clustering on the date column. That's a hard one. If this were a fact table in a warehouse and every single query was always on a date range, then there are some benefits there. If this is an operational invoice table, I imagine your app also joining into invoices in other approaches also. I also imagine invoices being queried by invoice IDs stored in other tables, etc. So I don't believe there is enough to determine clustered key. I'm of the school that prefers a simple surrogate key for OLTP tables. An InvoiceID INT (or BIGINT if you really would blow out an INT) setup as an identity column so it is always increasing and avoiding page splits. But I don't know if there is a definite wrong answer here (well there are many, but you haven't proposed any of those) 

The Wizard is really just a listing of backup history records in MSDB on that local server. This wizard is not necessary to do backups. In fact, you should run a process to purge backup history on a regular basis. When I do a SQL Server Health Check for a client, I consider it a finding (relatively minor but still a finding) when this history is purged. I am wondering if you are attempting to restore to a different server which also has that database on it? Instead, choose Device and browse to your backup file. You'll see the right backupset to restore to inside of that backup file. The dialog here is sort of a helper if you are restoring on the same server where your SQL Agent backups are taken but if you take backups in different ways, if you clean up history or if you are restoring to a different server, that dialog is likely not so helpful.