Now, your tests for all of your classes are reduced to the task of generating the input test cases and expected states they will generate. For the , that could be easily expressed in two arrays; you might want something different for your more complicated rules, since the criteria are presumably individualized per object for those subclasses. I might go with something like a generator. The concept of a class is helpful for BDD when you have specific class invariants, but with javascript you are by no means limited to a one-to-one correspondence between a class (constructor/prototype) and its defined behaviors. Like anything else in software design, you can tell your unit test is wrong as soon as you type the same thing 2 or 3 times. Usually, you can fix the repetition by making the object of your suite (parameter to ) something more applicable than the name of the constructor. 

I see some opportunities for improvement, which will get this up to about what we expect from a . First, the imposition that the stored elements are is not optimal. Sooner or later you will want non- elements, and you will not want to write and maintain another for each data type you want. is, in fact, the least useful element type I can think of. The solution is a class; instance objects would be declared ; a programmer will expect this syntax and the reusabilty it produces. Second, there should be no method as it is unclear where the new element is added. Instead, we expect methods like for O() insertion at and O(N) for what you are currently doing with . Third, you may recognize your as being O(k); this is because you've actually written a queue (with minimal modification, a deque), which extends a real . A real has no need of a tail pointer ( here). 

That would be a really tough thing to change, and ultimately a matter of documentation more than quality, so let's move on. The fact that your involves a by value that doesn't have an accompanying buffer of elements is somewhat of a misuse of the structure. I can see where it looks like it might be necessary in order to have and take and/or return a , but you can make those functions and the structure simpler and clearer by eliminating the from . Instead: 

You can override to perform the same function as in your code. Then, you could override to get the quantitative part and append the unit name. For the purposes of outputting your measures to text, and for debugging with e.g. Firebug, that would be a plus. As for factoring, it would be more flexible if you kept units of length separate from units of time. 

/UPDATE In a more inclusive sense, the pattern you're describing breaks a lot of the functionality that JavaScript provides natively when you use established idioms for creating objects. You lose , you lose , you lose , you lose , you lose , and you lose either lint or . You're also forfeiting your IDE's documentation and code completion for your classes and constructors (unless you're writing code in notepad anyway, or something). It comes down to priorities: how desperately do you need single block "classes" and reflection, and how certain are you that this is the only way to do it? 

I did something very similar to this in assembly a looooong long time ago, so I'm going to compare and contrast for the sake of nostalgia. And helping you out, that too. The main difference in our top level designs is that I was storing values as elements of the , whereas you are storing . The reason I didn't always store was that it didn't require any additional memory management for consuming code by default. If I needed to do memory management separately, I could do that by making it a queue of pointers. In your code, you must either store pointers to static data or and each element separately. I see those two possibilities as a hazard in the case that the consumer doesn't yet know whether dynamic allocation is necessary, or worse, if to static data and to something on the heap have been mixed in the same somehow. The end result will be an error (trying to static data) or memory leaks (not ing heap data). It's especially error prone because if you need to , you have to do it soon after you dequeue it (possibly happening in many functions) or it leaks, so switching between static data and heap will be hazardous. On the other hand, believe me when I say you've avoided the following headaches by storing only : 

UPDATE Using a function as a property key, while it may work as expected in whatever environments you've tested, is a risky proposition. According to the ES5 standard, all property keys are strings. Even array indexes are required to behave as if they were first coerced to strings. Any non-string used as a property key to a plain object is implicitly coerced to a string by calling its method - you can verify this either by reading the standard or by adding at the top of the function and observing the error. is defined by the standard as returning "an implementation-dependent representation of the function..." that "...has the syntax of a FunctionDeclaration". According to the definition of "FunctionDeclaration", it is permissible for an implementation to return for all functions, i.e. you have no guarantee that the key will involve the function's given name, the function's given formal parameters, or the given function body verbatim, or at all. Some fairly common patterns are particularly potentially brittle: 

ing a register with itself is such a common idiom that some processors use it as an optimization hint. All it does is set the register to zero, with a smaller opcode & operand. The after the makes the register all 1 bits no matter how many bits your register actually has. Some day when all of our GPRs are 128 bits, some poor sap that is updating assembly code will thank you for that =D. Alternatively, you can forget about being a limit altogether. No matter what arbitrary limit you set on the size of the string, it will either (1) not be big enough for someone someday, or (2) be small enough that an access violation (or worse: no access violation) will occur before you actually reach that limit. Either way, that is really only a nominal protection of data integrity. Now, the string. There seem to be some inconsistencies in how you're treating its terminating null character. You're using to find four bytes of 0, then using to only copy/advance by 1. Normally, strings are only guaranteed to be terminated by a number of null bytes equal to the character size, although in practice there are probably at least 2-3 to get the next datum to be dword-aligned. What that means for you is that your code will fail to detect the end of ~3/4 of normal, null-terminated, ascii strings, and keep copying until it finally causes an access violation. But that's not all. Notice that you're fetching a dword at with the instruction, and that advancing that pointer by 1 at every iteration will make the pointer not dword-aligned 3/4 of the time. Loading non-aligned data takes two fetches instead of one, so for every 4 bytes of string, your instruction alone needs 7 fetches from memory. Furthermore, after fetching the data and discarding it with , you fetch it again with , a total of 11 memory loads per dword of data. To reduce that number, you should load the data into a register, do your test for the null terminator on that register, then store the data to the destination. I see that someone else has pointed you to the bit-hack that will let you test all 4 bytes of the dword at once, so if you can follow that, do so, but here's a less efficient way that demonstrates my point very clearly: