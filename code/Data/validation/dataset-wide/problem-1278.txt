Instead of choosing a random chore, you could just shuffle them all beforehand, that way the randomness task is done. 

Since I misunderstood the question. I offer up a second take. I have not convinced myself that log10 will increase the efficacy of the script but I use it anyway to show the concept of using math instead of len on strings. 

Valid. But your code is messy. You are taking one step away from the original traditional problem, and that actually becomes a problem form your code. Your actually better off with the one dimensional arrays then the two dimensional tuples. Tuples may be the wrong data type to use for your problem to resolve itself nicely. 

For a course I'm doing I need to get up to speed with Java, but unfortunately only Java 1.6 - here is a topological sorting algorithm in said Java version, for practice reasons: 

The idea is that this code check if the is at most 100 days in the future from a given date. It can be assumed that both dates are in the same timezone. The dates should be compared only on day basis, that's why the time objects are reset to 00:00:00 time. Still feels a bit clunky and not sure if it's clear that the comparision is done based on full days only. Any comments appreciated. 

I like the idea of this utility class, but there are a few points I would like to mention. Let's start with naming. I would rename the class, probably, to one of the following , , or . The rule of thumb is to put the / nouns in the end of the class name. Personally, I like the first two. Then come the constant fields which could be shorter. For instance, they could be named as instead of and instead of . That is, the 'BETWEEN' part is redundant because it's already obvious that a separator separates the one from the other. Two other fields would be better named as and , which is more intuitive. Another thing is that you have two separate methods for adding the field names and values and then you check that there is a corresponding value for each field name in the method. You also check for indexes and arrays' length in the method. All these checks are error-prone, but they could be eliminated by enforcing the one-to-one correspondence rule of the field names and values in a single method for adding those fields and their values: 

I wanted to write an implementation of Disjoint Sets with path compression and ranking based on the components' size. In my general approach I followed the description of the data structure in a lecture note I found. I will use this structure later in another component for connected components, where I want to merge connected cells in a matrix and keep track of the minimum label for each component. Therefore I added another map that keeps track of the minimum label for each component. An example of what I want to do - consider a matrix of 4-connected components like this (note position is the top left corner): $$ \left[ \begin{array}{ccc} 1&2&2\\ 1&3&2\\ 3&3&4\\ \end{array} \right] $$ Now we make position (has the label 1) the parent of position (has the label 2). Now a) both positions are in the same component and b) both are tracked with label equal to 1, because . 

Whenever you are dealing with user input which needs have to follow certain rules, it will always makes sense to separate it from other parts of the code like putting it in a function. So by my interpretation of your code in which I started with your code, with out being as nice as you are, would be this. 

the obscurity magically disappears. This method of commenting your code is called annotations and is commonly used in python, I like them a lot. 

Now what I would do if this was for someone new to programming is relay on something else then abstraction of the init and abstract in something like biology: 

I would also suggest that you look into some popular MVC frameworks (Zend Framework 2, Symfony 2) to get comfortable and confident with the concepts. 

I think it's a matter of taste and preference. In either case, you would have to duplicate something. But, there's something that drew my attention. I don't claim it to be correct or be a solution to your problem. Hard to say without knowing the context and data structures that you use. Anyways, here we go... I noticed that in both cases, whether or not, you pass the same arguments, though to different methods. I suspect that this checking might occur in many other places as well. So, what if we create a method (e.g. ) and move this condition statement to that method. And the method would internally decide whether to add a new or modify the existing one. Somewhat similar behavior may be observed in the method, where the method checks if the element has already been added to the and then returns without adding it twice... Then, we end up with something like this in the client code: 

without the much expressive comment is that you wast a lot of space and make your code more hard to read. Of curse you should comment your code, but you don't have to comment on what the names of the function, secretWord, lettersGussed already states. But we don't know what type the parameters is from the names, but annotations can do that. Comments should contain information on not told by the naming or annotation. Don't repeat yourself applies to comments as well. 

In python, the ";" that you use in the end of some of your rows does nothing, python instead uses line breaks and indentation. You use very many variables, and you probably don't have to, and it seems that you are repeating yourself. If you want to do it that way, there are a better way. Function naming conventions in python is not camelCase, but instead function_name, camel case is reserved for classes. variable naming conventions in python is always lower case, and not B1, that looks to me as a poorly named class and not a button. You should write you variables after your functions, and not into right after your imports. When you top-down a piece of code, you make it dense, and hard to manipulate and read, break it up into functions.