DBCC CHECKDB can indeed affect system performance - CPU, disk I/O and memory can all be affected by it. Here are some documents from Microsoft that outline how DBCC CHECKDB can affect the performance of your system: $URL$ $URL$ Microsoft's general recommendation is that it should be run during low usage times - so once overnight or something like that - not every 15 minutes every day. 

In order to use a SQL Server other than the pre-installed SQL Server 2008 Express, you must install Search Server in server farm mode. 

Close all instances of Reporting Services Configuration Manager or SQL Server Management Studio. Open a command prompt and type wbemtest, and then click OK. Click Connect in the WBEM tester dialog box In the Namespace field, type the following string, and then click Connect. The namespace you specify should appear in the WMI Tester dialog box. If you see an error message instead, the WMI namespace for Reporting Services is not registered correctly. To resolve this issue, follow the procedures later in this article for registering the WMI namespace for Reporting Services. Click Enum Classes, and click OK in the Superclass Info window. In Top-level classes list of the Query Result window, double-click the MSReportServer_Instance class. Click the Instances button. You should see a Query Result window that shows all the instances of Report Server on your computer. If not, the Reporting Services WMI provider is not communicating with Reporting Services Configuration Manager or SQL Server Management Studio. To resolve this issue, follow the procedures later in this article for registering the Reporting Services WMI provider. If you successfully resolved the issues in the WMI Tester dialog box, restart Reporting Services Configuration Manager or SQL Server Management Studio to determine whether that the error is resolved. 

Here is how I would approach this problem - keep in mind I haven't done this before, it is just concepts that I tested out a little bit in my dev environment. You should be able to setup a pretty robust framework using this and some scripting in your language of choice. Basically we are going to setup a ghetto load balancing environment and use that to switch between the new site and the old site. To get it setup, you are going to need: 

The SMTP server installed with IIS is not a full fledged e-mail server. It is used to send/route email, but does not have e-mail boxes. Windows 2008 does not include the the POP3 services that would be required for what you want to do. (It was included in Windows 2003, but removed again in 2008) Microsoft obviously wants you to purchase Exchange licensing, but if you google for something like windows mail server you will be able to find some free alternatives that should fit your needs. 

I have experience with myPassword, which does web-based password resets, password changes and account unlocking. It works pretty well for us with very little administrative overhead. It works by having users setup a profile with a series of "security questions" and then uses those to verify a user before allowing them to do anything with their account. It is a commercial product, but I am not sure of pricing details since that is handled by other people. The same company has another product called rDirectory that has even more self-service capabilities, but I am unfamiliar with that. 

For web parts, you need to make sure that you keep track of what web parts have been installed, and in a disaster scenario, you re-install them (after re-installing SharePoint, but before restoring your content). For the other things - any changes you make to the SharePoint 12 hive () or to the IIS root for your sites need to be backed up at the filesystem level. In a disaster situation you can then restore the customized files (again, probably after SharePoint install, but before content restore) and you should be good to go. Mentioning the IIS roots also reminded me - you can also dump the configuration of your web sites and application pools from IIS so that you can re-import them after a rebuild. This is far easier than having to remember any IIS-level customizations you may have done. 

If you are setup with the Windows authentication method, that hooks up your authentication to the AD domain that your WSS server is in. Typically you will want to use Integrated/NTLM authentication so that people on computers in your domain will be automatically logged in with their machine credentials. (People not in your domain or not using IE will need to type in their username/password) Your users should not need any specific privileges on the Sharepoint server - but you may need to add Domain Users (or nt authority\all authenticated users) to the Users group on your SharePoint machine. Here is Microsoft's planning guide for WSS authentication: $URL$ 

Request Filtering does not have separate logging. Using the Advanced Logging extension (with its filtering capabilities) could get you there though. I think the lowest level of granularity you can get is the error sub code. Everything rejected by Request Filtering is a 404.x, where X is the reason that Request Filtering denied the request. This page contains a chart of the reasons. Since everything from Request Filtering is just a 404.x response code, you can use IIS custom errors to replace RejectResponseUrl. Already answered above. 

This is a very open ended question I think. Use your favorite search engine to search for: "iis7 hardnening" or "sql 2008 hardening" (etc.) and it should get you started. Here are some examples of good hardening practices: IIS 7 SQL 2008 Windows Server 2008 DotNetNuke 

Doing it from the command line probably won't be an option if you want to account for checked out files. This means you will have to resort to using the SharePoint API to dump the files out. There is a codeplex project called SPIEFolder that will get you close. It is missing 2 features that you need, but if you have any .Net coding experience (or know somebody with such) it should be a pretty simple change. The 2 limitations in your situation are: 

My favorite one is this: $URL$ But some people find that a little too technical. I have also used the following in the past: $URL$ $URL$ $URL$ 

Piggybacking a little on Richard's Powershell answer, I've found the Powershell WMI Explorer to be a great utility for browsing around to find thing within the WMI structure. 

There are some restrictions from both a licensing perspective and a technical perspective. The basic licensing restriction is that whatever is installed must be used for your web sites that are in use on that machine. So for example, the SQL Server you install can only be used by the web sites on the server, not by sites on other systems. The SMTP server can only be used to send emails from the sites on the system, not by other servers, etc. From a technical perspective, the 3 big limitations I can think of (that probably don't affect your use case) are: 

In your particular case though, this wouldn't work. doesn't allow you to use a port below 1023 - you would need to fall back on the operation : 

Microsoft still recommends 15 characters or less. If you give a recent computer a name longer than 15 characters, anything more recent than Windows ME/NT 4.0 will be able to talk to it using the full name. Older than that and you need to truncate to 15 characters. When you are setting a computer name, if you go into the "more" button it will actually show you the NetBIOS computer name if it differs from the standard name. Here is a KB article on the different limitations for computer naming: $URL$ Also, here is the Windows 2008 R2 computer naming recommendation: $URL$ as you can see, still 15 characters.