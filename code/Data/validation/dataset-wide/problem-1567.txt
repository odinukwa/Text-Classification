In addition to the other comments, I would also use a different naming convention for types and objects. For example, this looks unconventional. 

is almost always a bad idea. Even in small programs I would avoid it. Your algorithm for is just plain wrong. The area of a triangle is half the length of a side multiplied by the perpendicular distance from the third vertex to the base line, not the distance from the vertex to the mid-point of the base. (Think of a triangle with vertices at (-1,0), (1,0) and (1, 1). The area of this triangle should be 1, not sqrt(2).) Reviewing your class, the default constructor doesn't initialized the member variables. This may be acceptable for performance reasons - for example - if you deliberately want to be able to create large arrays of uninitialized but it's often safer to explicitly initialize all class members in a constructor. Having both getters and setters for and effectively makes them public data members. The only functionality that has is but this can be provided as a non-member function. Once you've done this your class provides no functionality that a simple doesn't. In addition, you can use aggregate initialization for a which can be useful. E.g. 

This is unnecessary. Without it, it will propagate the exception up, the same as manually rethrowing the exception. Remove Unneeded Controls You seem to have both a radio button list and 4 radio buttons. We really only need the radio button list. There are also a few panels that aren't needed. Use ViewState Instead Of Session Instead of using the session to store data between questions, we can use the ViewState. The ViewState doesn't persist the data on the server, but rather stores it on the client side. Since we don't need to make use of the internal state data (such as the current question), we can store it in the ViewState. Using ViewState also allows a user to have multiple question sessions going on at a time in separate windows, whereas the session data would otherwise be mixed between them. We can also use properties to simplify this access. Instead of using strings to access the variables, we can implement the access in the property, which will prevent us from accidentally using the wrong key. For example: 

If you can pass in the subroutine it makes the code a lot simpler, you also don't have to deal with an unknown string format as the subroutine itself has been passed in. 

If you are using the standard library classes of the same name, I would give the following names the correct namespace qualifier: , , . In C++, this works just as well, IMHO it's mildy more idiomatic. 

Otherwise I think I'd go with with a hash of subroutine references. It's easily readable and simple to update. 

One disadvantage is that you can't easily construct a temporary with explicit initial values. If you need to do this you could consider a helper function analogous to . E.g. 

Being a trivial POD-struct, most compilers will have little difficulty in eliding most of the implied copies. There is some argument that deserves to be a class as you have no setters for its members, but given that it has little behaviour and the behaviour it has can be provided by free functions I would keep it as a POD . Clients can choose to make a instance should they so choose. Also, I don't see any need to make take a reference to a . It can return by value for more readable code. 

We can also store the entire current question in the ViewState to avoid having to store individual properties of it, such as the answer index. We can do this by adding the attribute to the QuestionModel class. Note that if we do use the ViewState, we should also encrypt it to avoid disclosing the answers and other internal information. To do this, we can add to the Page directive on the .aspx file. Also note that we'll need to find a way to provide access to the correct count to Results.aspx. For simplicity, we can use session data for this specific case: 

Putting It All Together With all of this, we end up with the following. Notice that we've reduced the size of the class by almost half and made it a lot more readable. CodeBehind 

I don't think that your solution looks bad. I would probably use a temporary variable to make the line length a bit more readable. You could consider from the module. E.g. 

It's just a convention but being able to easily spot names that denote types helps if you start to use more complex expressions. For example: 

Personally, I would also avoid . You need to either or to use it. Although the system call itself is standard C++ (from the standard C library), what you pass to it is system dependent. In general I don't believe you should make your programs stop artificially. If they are designed to run in a terminal then the terminal user will be able to see the output even after the program exits. 

Because either is technically acceptable, you are right that it is a style issue and simply a case of choosing a coding convention. However, I think that you have hit a very important point. So few other languages that use parentheses for functions allow a parameterless function call without parentheses that it can be very surprising for developers unfamiliar to perl. This point would sway me in favour of always using them and, indeed, I always do so out of habit because I use other languages a lot and it just comes naturally. 

Only Handle Answer Checking on Next Click There's no good reason to check anything about the selected option when it's checked; we really only care when the user clicks next. This greatly simplifies the logic, as we can remove all of those methods, and implement all of the logic in the next button click method. For example: 

Factor Out Constants Several of the numbers used are constants which could be factored out, such as the difference between Kelvin and Celsius (273.15). This will prevent typos from causing calculation errors. Something like the following: 

Two items I would have a look at in terms of the actual calculations. Use Full Names in Methods For clarity, and because the few characters are inconsequential, I'd prefer to see the full names of the units being used in the method names. This will improve readability and understandability of the code.