You could consider creating a class that holds the indices for a larger amount of text (for example a paragraph or a section or a subsection in the text). That class would have the absolute index for where in the file it begins and relative indices within the paragraph/section each line begins. Whenever a new line is added or removed only the lines within that paragraph/section would have to be updated and the absolute start index of all the following sections as well. (I don't know what text you write or what you use the line starts for). You could still find a specific line very easily (and probably very fast) by enumerating the absolute indices of the paragraphs/sections and when you find the right section enumerate it's lines. 

I'll review this in two steps: first the body of and then the higher level structure/architecture. The selection sort implementation Swapping elements First of all, there is a bug (the only one I could find) in the code that swaps two elements that sometimes loses elements while swapping them. The smallest example where I can reproduce this is by sorting which results in , losing the . Looking at this code: 

The second one is a bit trickier and highlights some constraints in how can be extended to support other sorting algorithms. To make support any kind of collection, it would be natural to also make it generic over a type that is a Swift collection: 

If you're following along step-by-step you'll notice that the of the enumerated array is now unused, so you can change it to only loop over the : 

However, with this change the selection sort algorithm can no longer be used because is a method of rather than . It's possible to constrain the to be a mutable collection, but what if another algorithm has another requirement? With this strategy we would end up constraining more and more to the sum of all the different algorithms requirements. A better alternative is to keep as broad as possible, but to supply no sorting algorithms by default. Instead each sorting algorithm would be added as an extension only where the generic placeholder types satisfy those requirements: 

This change is only syntactical. Going even further Realistically I would probably stop here, but I'm going to continue to show more of this process and other implementations. Considering the goal of that loop, what it's really doing it "finding the index of the minimum element in the rest of the elements". There is two ways we can approach this goal. The first approach is by first finding the minimum element, and then finding the index of that element: 

The first is pretty straightforward to address, by making the struct generic over an type that is constrained to be and by using arrays of that type: 

i.e. if the product id exists in then it should be deleted. The implementation of may have to go through the array of ids but it should in most cases quickly discard an object based on its hash which should make it faster. I also find it more readable than an explicit loop. I'm not sure what the method does in your case but it's not safe to add or remove objects from an array while enumerating it. If that isn't the case for you then your code could can be simplified like this: 

I see that you're reading the from the array as you're enumerating it and writing that at the , presumably to avoid having to get a to swap the two elements: 

Other than the minor syntactical difference, this means that the type of is an associated type of the collection being enumerated. This has no benefit for arrays, but will be important if you want to be able to sort other collections. Secondly, since the loop body is only executed when the element at that is smaller than the element at the current I would possibly move the inner if-statement to a where clause: 

Don't worry about the temporary variable. The compiler is going to remove that and it helps with readability. If your delete operation is safe to run concurrently on many objects then it may be slightly faster to run it like this: 

For the same reason as before, it's safe to force-unwrap here. The slice will never be empty. Higher level structure/architecture At a high level there are two limitations to the struct and its underlying implementations: 

Finding the index of the smallest element I'll make two small syntactical changes to the code that finds the , partly to leverage Swift features but also to prepare the code to be generic (which I'll discuss later). First, I'd like to describe what this loop is doing as "iterating through the indices of the slice of elements starting from the current index". In code I'd translate that into: 

This change was greatly simplified because I had already moved away from the assumption of indices and instead got the index type from the collections associated type (implicitly). In other words, here is of the type rather than . With this strategy each sorting algorithm can be added separately with the type constraints it needs, and a user of this API would have access to only the sorting algorithms that are available for the type of collection they are using. At this point I don't see any value in the wrapping struct, since these algorithm could be added as extensions to the collection itself in the same way. This solutions also has a more convenient and more "swifty" call site syntax 

Consider using more of what Core Graphics gives you. There are methods along the lines of , and that does that kind of basic math for you. It reads cleaner and other coders who are used to Objective-C will immediately recognize them and understand the code. Also, there is some code duplication where you calculate the center x twice and the center y twice. You can introduce two private methods to get rid of that duplication (I've also removed the "get" prefix as it is not commonly used in Objective-C and switched to instead of ). (If you really want to get rid of code duplication then you can create a method to get the bounds of the main screen. I did so in the code below) 

You might appreciate taking advantage of some ES6 features. You're using an object literal like a map, so why not use a real ? Speaking of ES6, since you're a beginner, you would benefit from taking the time to learn it now and save yourself the headache later. As others have noted, you can accomplish finding the mode in a single for loop. 

In that example, is 7, the duplicated number is 1, and the missing number is 6. So you get the formula . We can solve for by adding to both sides, leaving us with ! Let's do that. First, you can calculate the expected sum from that formula, . In your loop searching for the duplicate, you will need to keep a running total (and don't break early). After you find the sum of your list and identify the duplicate number, you can calculate the missing number using the formula we talked about in the above example, . Also, you don't need to record the frequency as an integer, you can just keep a list of booleans for numbers already seen. I've also taken the liberty of cleaning up the indentation issues and renaming some of the variables for the purpose of readability. Here is the solution: 

There is a shortcut you can take to find the missing number after you've found the duplicated number. You may have come across this fact before, where the sum of the numbers 1 to is . We can leverage this along with the duplicated number to find the missing number. If you add up every number in your list and subtract that from what the expected sum would be from 1 to , most of the terms will cancel, leaving you with . You can visualize that with an example: 

You pass an immediately invoked function expression (IIFE) to the push method, but this is totally unnecessary. You can execute the code above the push method and make things considerably more readable. Also, you redeclare the variable inside this IIFE and use it for something else, which is pretty confusing. It'd be better to use a different variable name. Time Complexity Your current algorithm is O(n2) because of the nested for loops. A more efficient algorithm would be to step through both arrays at the same time, adding the next smallest element to the merged array. This approach would be O(n), so an improvement! Changes Altogether, this is how I would restructure your existing code: 

It's easy to see that there's a lot of code duplication going on here. What might not be easy to see is a nice way of condensing it. One way to start is to see the similarities and where the lines of code differ. It appears you want to perform an action on each of the four directly neighboring cells and something separate for the center cell. A nested for loop could help tremendously. The only thing to consider here is ignoring the diagonal neighbors. The other piece of duplication shows up where you do one set of actions when the argument is one value, and an almost identical set of actions when the argument is the other value. The only place the repeated lines of code differ is at a single hard-coded value. If you just set a variable to be the correct value for either case, you don't have to repeat yourself. Something you may have not considered is trying to index the array past the boundaries. You should avoid it so you don't encounter errors. Simply add a check for this before indexing the array. I've split this check into a separate function because the boolean expression is quite lengthy on its own, let alone compounded with other boolean expressions. Another tip is to handle all the cases. If you use a , use a at the end. If you have an , use an at the end. Even if you just want to ignore the case that didn't match the other cases you do handle, you can just write a comment, log a message, or even throw an error. 

In this function, when you are passed an invalid , you return . This works, but is not the best way of doing things. This function is supposed to return a , so you should be returning . You've used elsewhere in your code, so it is helpful to be consistent. 

This is a good first attempt, but you have a couple things wrong with it. If you look at the for loops, you'll see it's adding each element to the nav in the same level (rather than nest them inside each other), but then proceeds to move it to the correct place with the inner for loop. That's the second problem. You rebuild the nested element structure each time you iterate over the array. You should eliminate all this unnecessary work, and you can do it in all plain JavaScript without using jQuery. Edit: changed function to accept any number of elements as arguments to nest (e.g., ). 

You initialize and , then you reinitialize in the outer for loop, then do nothing with in the inner one. You don't need to write an initialization step in the for loop if you don't want to. 

Maybe use some array methods like ? This will add up all the elements, starting with an initial sum of 0 (the second argument to ), then the sum is divided by the array's length to compute the mean. 

You can use the comma operator, which takes the value of the last expression. It's not used very much, so may make the code less readable, but if you wanna make it one line, this is the way to do it in a single statement. You need parentheses because of operator presedence. If you omitted them, the comma would be interpreted as a separator between variable definitions.