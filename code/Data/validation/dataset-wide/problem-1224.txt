Tunaki makes a very good point that your and groupings should not be part of a card instance. However, I disagree that they should be kept as strings. I would make these groups into an . 

A year or so ago, I wrote a checkers game for the Universal Windows Platform. Now, I wrote a web-based version of it hosted at $URL$ This is the first of a series questions about my best practices. Related to Checkers Board Editor, but web-based. The requirements of this system are to allow the user to place checkers on a board and get the FEN value of the board for a given variant, which they can then use to create a game from that position. They can also choose which player makes the starting move and choose common board positions to start modifying from. 

Not used variables You don't use , , or , so you can remove them. Naming Your variables names should tell the reader about itself. doesn't tell me anything about what the variable is or its purpose. Indentation Your indentation is somewhat sporadic. You should indent one level for each loop, if, function, etc., which will help improve readability, which helps prevent bugs. I'm not an expert on VBA or Excel, so I'll leave everything else to the experts. I just learned what I know by working on the Rubberduck VBE addin. 

Sixth, you might as well use HTML5 formatting. This would change the into a . Then, just change the name of your style to: 

I'm not sure why you continue finding all the small factors when only the largest prime factors are needed. In fact, if you are going to do it manually looping over each number, you should start high and work toward the smaller numbers. A better way to do it, however, would be to use the Sieve of Eratosthenes, as mentioned in the comments on your post. 

is undoing the work did for you (which is the entire reason for using ). Instead, you should do this: 

I had basically written everything Zenohm wrote (but way too wordier). I would like to suggest the slight change to Zenohm's code. Remove the end of , from on, and move that logic to : 

Let's compare your implementation of to my functionally equivalent implementation. For testing, I created 2 datasets for input. One dataset ("Permutations") is just all the permutations of a, b, c, d (non- inputs, values ) (that's 164 = 65,536). The other dataset ("Randomization") is 65,536 randomly-generated sets of {a, b, c, d}, about 50% of numbers are , the rest are more-or-less evenly distributed between 0 and 16. I ran these datasets through our implementations 10,000 times. Here are the process's CPU times (in seconds): 

Because everything you want is under the subdictionary, I would just reference it () at the end of the call). Here are the combined suggested modifications (using the list that returns, and using ): 

Note that unlike in the case for , we must mask with (because assuming bits 4-(num bits in int) aren't set in the inputs, bits >4 will always match as "all zeros"). Below is the rewritten which matches the specifications (i.e., it returns strictly or as described above): 

That means there are (16 choose 4) combination = 1820 possible input combinations, much less than 65,536 (or 16 * 15 * 14 * 13 = 43,680 permutations if order matters). However, that knowledge does not change the algorithm or opportunity to improve the performance. But what about the differences between the algorithms? I ran the same test inputs (including identical random data) against 3 other functions: your (but sans checking for ); my (sans checking for ); and finally, my (also sans checking for ) but following my suggestion and returning more than just or . Here are the CPU times (in seconds): 

In one method, you use parenthesis around the expression, and in another, you don't. In one method, you use spaces around the operator; in the other, you don't. These methods could also be improved by using C# naming conventions: should be named with PascalCase as at a minimum--writing out the full word "function" wouldn't hurt (although technically, this is called a "method" in C#). 

I really like how you use the HTML5 element instead of using the old style When people write CSS, they often format it slightly different, like this: 

Even though there is only one parameter in this method, I should provide the argument name so the person debugging doesn't have to look. This is done in .NET 4.5, which I am using, as: 

This makes fewer (by half) the lines of code to maintain, not counting braces. Also, notice how I put braces around my code to help prevent errors. Romoku also make very good points about renaming your variables to reflect what they are doing better. 

Your CSS is validates perfectly, you can validate it at the W3C CSS validator here Your HTML has a few problems the validator finds here. First, you need to specify a doctype, like this: 

Thank you for this interesting problem. I think your code is good to go, although it isn't quite how I would do it. First, avoid using unless you absolutely need to. is much easier to manage, which compensates for it's nominally larger size in memory. You can then get your data in one pass because a list is resizable. 

Now it only signals that values are selected and should be removed when the Remove button is clicked, and the WindowClosed event fires to handle the window being closed: 

This seems very WET, but after thinking it over, this seems to be the best way because only what these methods do is the same, the details are just a coincidence. This is the code fix. Again, I provided overloaded methods: 

I have implemented two genetic operators, which is really just a fancy way of mangling lists. In particular OX-1 (illustration) and displacement mutation. I found it necessary to extract out the randomness from the algorithms in order to do unit testing with some known examples. Is that a decent way to go about it? Any comments on performance, structure, clarify and so forth is appreciated. 

Given a boolean 3D matrix and a set of actions specifying bit flips at certain positions, a set of resulting matrices can be obtained, one matrix for each action, as if executing each bit flip individually. A statistic (feature representation) defined on a matrix which for each row, column and depth counts the number of active bits at the same depth within some hexagonal distance in the first two dimensions of that row and column. What's the fastest way of getting such a statistic for each of the resulting matrices (afterstates), given the previously mentioned original matrix (grid) and actions (, and )? For example, given , , the first afterstate of can be obtained by . Actions are guaranteed to be bit flips. If the feature representation for is known, the feature representation for can be derived and need not be found from scratch. In the code below, the naive approach () and an incremental approach () are given. The naive approach should be easiest to understand. This is the hot hot hot path of my system and I want to make it faster, but I'm no speed demon. Any tips and comments on anything else, small or large, is also appreciated. Below the code is some background which is not required reading but may make things more concrete. 

I'm completely new to Javascript and NodeJs and functional programming in general. The code below scrapes a torrent-website containing movies, gets info about the movie from the OMDb API and lets a user choose a movie to watch by streaming the torrent. Any feedback appreciated. 

Now maybe your use case does not care about which bit(s) is/are common. But one of the nice things about C's design, and most idioms in C, is that truth is reduced not to and ; but to and anything but . I will come back to this point in my suggestion. Recognize the opportunity to work in parallel C's bitwise operators are just parallel 1-bit logic functions, so there's no need to check for individual bit positions one at a time; bitwise operations do not "interact with" neighboring bits (unlike mathematical operators, which have carry / overflow). So, to check if any of the "bit columns" in {, , , } are all : 

Use the returned by Edit: my original response directed the OP to use library to parse JSON-formatted text. That was incorrect, as the returned data was already parsed by library. The returned from your function is a of the key-value data shown in your "Results for from " section. Thus, you just need to access the appropriate key of the (specifically, the keys in the of the returned data). To access the and fields you were looking for, they are under the key: 

This cleanly separates the business logic of the game from the mechanics of running the game multiple times. Also, it frees up to return the number the number of guesses the user took, so that (or other calling code, in the future) can collect statistics about gameplay. 

When the data doesn't have any values, my algorithm appears to be about 15% faster. When the data has lots of values, there is not an appreciable difference. This makes sense, because most of the time, every set of {a, b, c, d} statistically should contain two values. This shortcuts the differences between our algorithms, leaving only (in those cases), just checking for . 

The code below is the core of a Genetic Algorithm (NSGA-II to be precise, without crowding-distance calculation), but I've taken out all the GA-specific parts and made a generic example. I think I've carried over most of the principles/'constraints' from the original algorithm, but I might have missed something. As you can see in , I need to convert a nested list (2-dimensional) to a flat list pretty often and I'm curious of if there are any better ways to do it. I've added some so that it's easier to follow the size and type (nested or flat) of the lists. Since expected size of input is m=100 individuals () for 500 generations (loops), speed is important. Memory usage is not that important (although knowing how to reduce it would be interesting), but execution time is. Any comments performance-related or otherwise are appreciated. 

naive: 10.82 incremental: 4.74 There are some asserts in the code which all hold and might help you read it. The given benchmark parameters and grid are all typical of my simulation. Background: Imagine a geographical area divided into disjoint regions (cells), where each cell has a base station which provides service for cellphones within its area. Two mobile callers within some distance of each other cannot use the same radio channel, lest their handsets will interfere. When a new caller requests service, we must therefore find the set of channels that are free in the cell of the caller and the neighboring cells within some given distance. We can represent such an area and the channels in use with a boolean 3D matrix where the first two dimensions represent the geographical position (i.e. the cell) and the depth represents the channel. Cell areas often are circular in the real world, and we can approximate them as hexagons instead. Finding the neighbors of a cell we must therefore use the hexagonal distance. Assigning new calls requires to find the channels that are free in the nearby area (eligible channels). However to select channels that will optimize grid usage as a whole, statistics, i.e. the feature representation, are useful. So when an action happens, i.e. a caller terminates a call or a new one requests service, there's a set of legal actions to take depending on the action type ( or ) and the grid. The afterstate is how the grid would look after performing an action, and the feature representation of that afterstate, when compared with the others, informs the decision making.