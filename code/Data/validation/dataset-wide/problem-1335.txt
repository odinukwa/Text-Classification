Injectable I am very positive your component does not have to be annotated with , therefore it should not be. The component is not really being injected anywhere, right? 

Add one tool at a time to your toolkit and start harvesting the fruits. Polish your skills over time and they become your second nature. Experiment with what you've learnt. Keep investing into the tools (in other words, make sure point 1. is repeated). Retrospect and notice how the practices/aspects can be efficiently combined together. Often the case it happens intuitively without intentional search for it. Be patient... PROFIT! 

Array-based N-stack When we want to implement three or more stacks using a single array things become trickier. This is because we don't have a thing which will work as a clear bottom for the 3rd, 4th, and all the remaining stacks. Even memory allocation scheme Of course, we could "allocate" arrays space to each of the stacks simply by evenly distributing the space segments among them. Say, if we have 4 stacks and an array of length 100, we could say: "Segment from 0 to 24 is dedicated to array #1; from 25 to 49 — to array #2; from 50 to 74 — to array #3; and the remaining 75 to 99 — to array #4". If I am not mistaken, this approach is taken in this question, which is about exactly three stacks via a single array. This certainly would work, but this is only a great solution for the case where all the stacks are populated evenly. However, if one of the stacks is very long, and all the others are very short, we can easily run out of memory for the first array. In general case, not knowing anything about the data, we should not assume this is a great strategy. Non-even memory allocation scheme 

Feedback I am looking for Here's the list of things I am interested to hear back (in order of significance): 

Sample In your case, the transformed solution could look similar to this. Please understand this is not 100% working code, because I am not familiar with the particular API of that your code deal with. This is more of a sketch to show the direction. 

Therefore, if you have no special reasons, you should subscribe the least number of times. In your case, a single subscription is sufficient. You can still use separate functions to delegate them the actual work (, , ). 

Became (longer because of the name, but the branching is almost eliminated by a ternary operator that cleans the input): 

Naming Things One, two, very-few letters long variable names are a bad practice. Even the things like indices can and should be given a real name. If something is called an , or , or , it should be treated as if the thing does not have a reason to exist. If a variable or a parameter exists only because it's enforced by a library/language (e.g. will give us an index and an object args), it is possible to explicitly show which of them are unused by naming them . This is a common practice in functional programming. A very nasty side effect of names like , , , is the added code complexity which appears out of nowhere. The code is not self-explanatory anymore, and dealing with it requires constant on-the-fly translation, which in turn makes the reader think about unnecessary details rather then the intent of the code. This is even applicable to the innocent looking variable/parameter, because without looking around nobody can tell what does the belong to... DOM and JavaScript Depending on the context, it may or may not be a good idea to manipulate HTML DOM directly via JavaScript/JQuery. Say, in modern single page application frameworks (like Angular, and similar) it's considered a bad practice to deal with DOM in the way it's done in the sample code. Even with these frameworks, there are exceptions of course, like the cases where one builds a widget library. Reduce Mutable Things Try to declare all your variables as when possible. Otherwise, make them be . Practice shows that the side effects and nuances of are in the best case not obvious to the most of JavaScript developers, and in the worst case -- very confusing. Terse Code Assuming it's okay to use relatively fresh features of ECMAScript 6, certain things may be written more compactly without losing readability. Syntax constructions like "fat arrow" (), spread operator (), string interpolation, etc. are extremely powerful. The fat arrow may be very effectively combined with /, , , , and many many other functions that can accept lambdas. Here are a few examples of slightly improved function. Notice that even this code may be further polished. processData 

Your service looks perfectly fine to me. As far as the component goes, I can only recommend one thing. When is executed, a reference to the subscription is being returned back. Ideally, the reference should be kept as long as the component is alive. On component destruction, the subscription should be released by invoking . 

Instead Of Intro I am a .NET developer who has recently moved to front-end realms. Unit testing was never a strong side of mine, but what I learnt is that the test code has to be of highest quality possible (follow DRY, SOLID, etc). Otherwise, the code faces rapidly increasing risk of rotting since test maintenance becomes burdensome. Not having experience with JavaScript/Jasmine makes me write C#-ish code in real system and tests. Getting some feedback should help in long run with keeping project in a good shape. Code Class under test () declares several methods which are made public for now. Each method is essentially a pure function, so it's really easy to test each of them independently. 

The fact that the returns a result that does not fit into the expected use cases, suggests that there is a design issue. In other words, it is a "hint" that is not really a in terms of OOP. Why so? Because it does not follow the intuitive contract in which the method returns same exact type of the vector as the one on which the method is being invoked. Things will only get worse if one will need to work against a , , etc. There's whole bunch of sources that explain how inheritance is very often not the best way to create new types nor reuse code. If I was to design the , I would make it wrap the class rather than inherit from it. 

Overall, the code looks pretty good. Definitely much better than many other JS examples in CodeReview. A few minor points can be made though. DRY - Don't repeat yourself At the very minimum, you can reuse some code by encapsulating it into a function. You can define which will be responsible for the details of showing/hiding a section. The decision on whether a button/panel should be visible or not remains in the control of the caller... Variable naming Similarly, I'm unsure if the selectors and more than in one place... I personally am a big enemy of variables like , , , and so on. It's not so difficult to spell it out: . IE is a beast As far as IE page renderer goes, I can't provide much feedback because I don't deal with it. 

Why Abstract Class? is declared as an abstract class that has only one method. The method itself is abstract too. I don't see how is it better than an interface, since no base implementation is provided anyway (and I'm a big not believer of implementation inheritance as a way to create new types). 

As you can see, as long as you know the , you control the sequence of randoms. And if you know both the and , you can easily get the specific value of random for this combination. In other words, your Game should pick a new on every new map it's trying to generate. The value of will let you "teleport" anywhere within this particular map. Update 4 - To Address Concerns About Randomness Here's the exact code I used to generate some consistent but random number sequence. The resulting sequence can be downloaded from here. 

They are simply redundant as long as is enforced by base class/interface. @t3chb0t's answer with switch works as long as you know define all the branches properly. Meaning, you must know all implementations ahead of time (i.e. at compile time) which is a huge design limitation (imagine you would want to have plugins that provide additional operations in run time, or combine operations into complex ones). You will also have to not forget update this dispatching method every time you add a new class that implements... @Peter's implementation of relies on same assumption that we know all special classes ahead of time. Should I Be Constructive? I think, it would be better to have each child class (, , and ) define a single method that works against the parameter. There are no visible benefits in having triplets in addition to this one. However, it's totally fine to keep the triplets though and use them for result computation. For the consuming code method is 100% sufficient to achieve the result. The consumer will never want to, nor should be responsible for picking up a specific implementation to make a call. P.S. This answer is written in a review manner since we're on CodeReview SE. If the question is really about "how to make it work" rather than "how to make it object-oriented", it would make more sense to ask in StackOverflow. 

It is really hard to solve the problem since the question is not providing all the necessary details. Assuming you have a factory for your Http observable (call it ) you may do something like this: 

After some consideration I decided to reshape it. Here is the generalized, yet more specific definition: 

Here's a single-pass example. Very similar to @janos' code (which has a good complexity analysis). The only difference is in how various cases with are treated. 

Lastly, I don't see why do you need to use any string representation at all and go through unnecessary steps with which make your function computationally heavier. Please consider accepting the answer as it does the job, OR carefully describe the acceptance criteria. Your problem statement is unclear! Update 3 Okay, you updated the question with the important info, which I quote here 

As others (@conor-mancone, @jasoninvegas) have pointed out, the code is having bigger problems than purely syntax related ones... 

Guess, I must start with a disclaimer again -- after multiple rereadings, still unsure what exactly the code tries to achieve. The big confusion (of mine) There's one thing I really don't like about , namely the ad hoc-ish mapping to collection entries by index. The consumer of the class will have to know that implementation detail, right? Don't have a C# compiler in front of me at the moment so I could play with things. Is there a way to keep and the as close together as possible (meaning, in the same class)? Not sure if it is achievable. On naming the lambda parameters As a minor thing, I'd note that is a bit confusing. Bet, you know we can write . Readability I know that fluent syntax is very well known, I haven't really seen that working with a collection (non-scalar) object, though. In other words, while you're not inventing anything new with this idiom, it's still a bit unintuitive to me. Please disregard this comment if you find it a subjective thing. :) P.S. Good question, just like many others that you post on CR! 

The end-to-end test was not meant to be exhaustive. Unit testing can be dome much more thoroughly here. It just was not my goal (rather, to illustrate how the things work). If I had written the code as TypeScript I still would NOT mark array as . With data structure implementations I really want the internals to be directly available for observation from test — I'm very firm, it's fine to have internals open this way for consumption in tests. (I'm in agreement with Mark Seemann's thoughts on structural inspection not necessarily breaking encapsulation). Nevertheless, in real production code (if at all) I would add interface and use it everywhere to access the . This is to prevent the accidental undesirable data access by the consumer. 

If this assumption is wrong, and you'll have various s that run steps in different order, than your tests should indeed make sure that the prescribed order is followed. Your current code is using the mock that intercepts the method invocation. I think, this is still checking the implementation detail. Instead, I would expose the collection of steps as a read-only/immutable property. Then I could do something like this: 

Another variant of the code I took your second (more functional) example and polished it a bit. *) The keyword is used instead of the in two places. This prevents accidental/undesired re-assignment of a value to a local variable. **) the type of the and can be inferred. ***) The is simplified, since already returns you a map object. 

This is not following RESTful approach. This will be invoked if your code could not update a question. Meaning, the service was not able to fulfill a request. The correct HTTP response code for such situation is 500 Internal Server Error. You should only return 400 Bad Request if the request was validated and there were issues with the payload (request body received). In such case, HTTP 400 is truly the best option, but in order to improve user experience, you should also provide the information about what exactly was wrong with the request. E.g. HTTP 404 + response payload 

You will not like my answer. TL;DR: I could not find a specific point where a code change would lead to performance improvement. I have, however, noticed some correctness issues. 

Syntax-wise I only can suggest a little improvement if you have a luxury of ES6. Screw the old school endless chains. They don't allow immediate assignment to the target variable/constant. In fact, that construction enforces using or instead of a (which helps avoiding bugs). 

Possible bug This seems to be a bug, but could be that I simply misunderstand the intent. The construction is strange and not idiomatic (usually, we either see or ). 

, , should be spelled out. Shortening does is not helpful. Also, you probably don't even need to have all three fields (, , ). In your particular case, it seems to be more reasonable to just have a field for the call result: 

The test that almost precisely repeats the code under test indeed does not provide much value and is tautological. 

I tried to rename things and format it differently as per my understanding of readable code. I'm still struggling with a few names as you can see, but this is just to demonstrate the ideas in actions, anyway... First, and . 

Clean up I don't know why it had to be so long and to have so many temporary variables. So I shortened it to make sense out of it. Here's what I got. 

Design decisions and improvements (as in "better approach(es) performance- and memory-wise"). Code readability. JavaScript (ES6) language idioms. Whatever you find important to say that does not fall into three categories mentioned above. 

used to be a field that is assigned in three different places: one in and two in . Each of these places could have a bug, and this code was scattered. Now it's calculated on the fly: 

There's function that takes a predicate to filter by. It's funny that your question mentions the filter word which happens to be the name of the function. Here's an example of usage: 

"Caching" an Observable is by default a singleton in Angular just like any other service (This is thanks to the way dependency injection container works in Angular). This means you don't need to have the class fields as . Make them instance fields instead: 

Update 1 - Test Results This is what Karma test runner will produce as a result of the test suite run, by the way. 

This code has to be declared in an function or arrow function to work. Otherwise, it's still a perfectly asynchronous code... 

Translate dates into a sortable representation (one time). Use . Do the sorting with . The values will be put in a lexicographical order. Translate the sorted dates back into original representation. 

Update 1, for those who are unfamiliar with functional programming. If ternary chaining was that bad, it wouldn't be mentioned Mozilla Developer Network 

Please notice that the code above is for illustrational purposes in your specific context. Any more or less real project will use directive to iterate over some data source to construct the boxes dynamically. Something like the code below. Do not worry if you don't understand it yet. You'll get there later with a bit of practice. 

Disclaimer This is by no means the best approach I recommend to use generally, but I think it's better what you have now. Especially, since you identified a very important problem of Card/Question quantity growth. My solution is much more scalable, but it too has its limits. If you apply this for now, and see some other issues coming, feel free to post a follow-up question with a specific ask. I hope this helps.