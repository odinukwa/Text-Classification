You're stating the obvious and forgetting the important things. Yes, is the command line arguments, but that's standard for the Java main method. I'd suggest documenting which command line arguments you actually accept - namely only one, and it should be a file path! Additionally, some of the code in the methods below looks like it could use some commenting as well. It looks complicated. Maybe I'll understand it if I look at it in greater detail... Throw exceptions when it matters 

It's still not clear enough. That's because I have no idea what means! Additionally, we still didn't get it clear enough. 

At this point, you could consider shifting certain parts of the logic towards a function which does simple calculations. Your call. I'd prefer that to this inline logic, because if you use the functions, you can write this function on a different level of abstraction. That is, you can write English code consisting entirely of function calls. At that point, if you made a mistake, you'll spot it instantly. Because if you have a function that looks like this... 

GenericAll is a list of substrings to be stripped from each string wherever the sub string appears in the string. GenericWhite is a list of substrings that are stripped only if they are surrounded by whitespace. And the function that implements the clustering 

ClassList is a list of Stripped Class obejcts created from the unique strings that are to be clustered. Threshold is the threshold above which strings will be clustered when distance between the centorid and the string being evaluated is calcuated as the jaro-distance. Lastly I wrote a function that sort of combines all of the above, but also clusters the clusters, and calls the clustering function recursively until no more clusters are found. It also references the data frame from which the strings are pulled. In theory, if two non-indentical strings represent the same undelying reality, this third data point should be equal for the non-identical stings that are above the Jaro-Distance threshold. This function directly modifies the data frame from which both the list of unqiue strings and the verifying data point are drawn, until no more modifications are possible. That looks like this: 

I've used some tricks there you might not have seen before. You'll have to google to find out what they are, but I'll help you with the search terms and short descriptions: 

As output on the screen, you enter a number, you get a square. Program 1 will print a square. And seeing something like 

I just added new lines, see? The purpose of these new lines is to show that there are different parts to your code, so that if you come back to it later, it will read better. When you don't have time, goal is to both get the product out; but also make sure you can still clean it up later. Keep it salvageable. 

I have a pretty simple problem. A large set of unique strings that are to various degrees not clean, and in reality they in fact represent the same underlying reality. They are not person names, but they could be. So for example Dr. John Holmes and Dr. Jon Holms are more than likely the same person. From the list of unqiue strings I want to cluster together those that possibly match the same underlying reality. There is no restrictions on the size of the cluster (i.e. I am not expecting only one match per string). I calculate the distance between strings using the Jaro-Distance with jellyfish in python. But then I wondered how I cluster them together? I was unable to figure out how to do this using scipy clusters as I am working with strings, not floats, so I decided to work according to the following algorithm. 

I think a MenuOption should be a separate class. A MenuOption has a name, a pick function, and a way to call functions on your Main class where you have all your business logic. Right now you have duplication in the numbers for menu options and in the handling of menus. 

You could choose this way of writing things or you could just directly return the response. That said... 

Failing that, at the very least remove it from the else case - you KNOW it is true, there is no reason to set it to true again. 

Wait, you only have one? ... You're missing the test cases where you add multiple values to the map and see if it actually can store multiple values. But no, don't inline. That'd be annoying. 

Also, I decided to strip out generic components of the strings to improve the matches. In the name example above, this would give Dr. John Holmes, and J. Holmes a better chance of matching if 'Dr' is stripped out as a generic component. I created a Stripped Class that has an attribute that is the original unique string, and then attribute that is a stripped version (stripped of the generic components). This is becasue once stripped many of the strings could have exactly the same values, and I need to be able to identify which original string they identify. The code is posted below. It works well, except that the size/number of clusters is not independent of the order in which the strings are evaluated. So the results do differ. In the final function, the SLink fucntion is called inside another function I would specifically like to know if anyone knows of a better way to implement this type of clustering? If anyone has comments on how I could improve my code, and if anyone has any information about clustering strings in scipy. In an IPython notebook I go through in more detail how I could refine this system, including using another function to verify the clusters using alternate data points relating to each string (such as age). If anyone would like to view that and offer guidance, then please see the following link: $URL$ I think as the functions were somewhat trial and error and unplanned, they may have got a bit out of control. Any guidance appreciated. I am a researcher living in Bangladesh, a total programming data tripper sadly, but trying to get better every day. 

It's most likely faster (one never knows with micro optimizations when one just looks at the code, profiling works better in these cases). New snippet: 

By using a specialized style for constants, it's easier to see that it's a constant, and not some local variable. 

But I'm of the opinion that you don't need to add a comment for the ending braces of functions or the sort, because, well, that's what your brace-style is for. My point is, due to inconsistent formatting and a weird brace style, you have managed to improperly indent your code and caused confusion about which scope a specific line is executed. I had trouble looking at your code. The lack of semicolons and the weird formatting style made it hard for me to properly look at the content. So this is a review just about the formatting.