in general it is better to write functions that do not force the user of them to look at the implementation in order to figure out how to use them. your function allocates memory and returns a buffer that the user needs to free. this fact is not obvious from the function name (it could have returned a ptr to a static buffer for instance, or a pointer to a global array whatever). 

You could have added the sign at start of while loop instead, seems more clear somehow but that is just a matter of taste. 

you malloc should just take as argument i.e. the rest makes it just look difficult to read and in this case is wrong, same applies to . 

There are several style guides (e.g. google has one), it is up to you pick one or do your own but there is no universal style guide. Important is just that you are consistent in your code so that you don't use different styles in different files, that is confusing (irritating) I find your code looks fine from the style point of view. Normally one would avoid (if possible) to include the headers like Hangman.h and CharReader.h in your header GameManager. Instead you declare them as pointers in the header and remove the headers. 

that way you are more independent from the compiler version/options. when reading a value from keyboard use instead the more robust fgets to catch the input, even better put it in a function: e.g. 

There are magic numbers in your code 2,3 etc. try using constants for those values with descriptive names. The function is arguably a bit long and has quite a few if-statement levels, better to split into several functions that you can parameterize. You may also want to present public functions to the user that do not have all the arguments then leave the original protected e.g. 

Initialize all variables: , , etc. your function has some issues You do a call to download (asynchronous call), but you do no attempt to wait for it to finish - instead you directly try to open it. If for some reason the download takes longer then it will fail. If your function fails you get a crash since you do not handle the return value of . I think the better approach would be to split it in two functions, one which does the download and returns when the file is there, alt. timeout with error code. Second part to open the file and returning the file pointer. E.g. 

Producing sample output on STDOUT, according to a command-line "count" parameter (this is not nice code, it's just here for reproducibility). Obviously, the performance of the filtering algorithm will depend not only on the number of sets, but also on the number of possible different names from which the sets are drawn, and the size of the sets. Smaller numbers of names make some approaches pathological; larger sets create more work for most approaches. Original program Your original program did not run as-is---it seemed to rely on a few parameters provided elsewhere, and a particular directory structure. So I modified it a little to accept a filename as its first argument, and output to STDOUT for easy testing. I also moved around the manipulation of the variable, as that seemed to either have the wrong indentation or be in the wrong place. 

(I'll mention how to generate this simply in a moment). You would then want to modify this to also pass through the row header, so you have the selector: 

Convention violation: logging to Your 'default' log destination is . For a well-behaved program, a more natural logging destination would be . Nonsense: checking assertion conditions after an assertion The fragment: 

is a little easy to misread. I'm always very tempted to use a loop for this kind of thing (also various kinds of pointer manipulation of a similar form) but it tends to end up being rather awkward. 

the macros and get expanded to the filename of the containing C file, and the line in that file at which the macro appears; then you can pass them through to the function, which could then log something like: 

I find this makes it easier to cope with C's lack of 'real' namespacing. Dependency-management suggestion: include your own header first Opinions vary on this, but if you start your implementation file (e.g., ) by including your header file (i.e., line 1: ) then you can tell immediately if your header file has an accidental dependency on some type or macro introduced by another header file you're including. I prefer to make my header files self-sufficient; including them first anywhere guarantees this. Subjective layout suggestion: implement top-level interface first This is overwhelmingly subjective, but I would at least consider the overall layout of your implementation file. Personally, for a module like this one, I would prefer to forward-declare the functions, then define them at the end. This way, the file reads top-down. In other contexts, that might be less clear, and it is more typing, so it's a judgement call. 

your function can fail in a few ways but you only set the when malloc fails, you may want to add some more error codes like when nothing is read. 

Comments You have using namespace std before the class declaration, normally you would place that in the .cpp or even better using statement in the individual functions where they are needed. Initialize all member variables using an initialization list 

can be replaced with (or fputs), puts has the advantage that it cannot be hacked by putting in a format specifier so avoid using when you don't have to. 

These comments apply to your question, not your answer. Using strings as arguments seem unnecessary, it would be better to use bools or enums, that way if you one day change strings (e.g. another language) it does not affect the print function. 

general impression overall the code looks clean and tidy so it is quite easy to follow some comments/suggestions MISRA and other coding practices recommend to always use compound statements after conditionals to make the code more clear and more foolproof for maintenance 

sidenote: when you declare functions that do not take parameters, write as argument. In C when you write e.g. it means that the function can take any number of arguments (as opposed to C++). Writing makes it clear it takes no arguments. get_slices There is no reason to declare as static, better to have a local variable that you return. You should also check return values of allocations, they may in some cases return NULL so that must be handled. also again, lose the gotos generally speaking it is good to check arguments to functions so that they are sane. e.g. with asserts 

it is a common defensive programming technique to put asserts at the beginning and at the end of a function to ensure that the functionality is as expected. first you check if the caller contract is fulfilled, then that the expected result is reached. 

EDIT to the actual code review: writing to calculate size is unnecessary and is hard to read, just write size. i.e. malloc(size) initialize all variables, one day you may change the order of the statements and then you may end up with uninitialized variable during runtime BTW I don't think your code works, when is successful you never set str to point to the new buffer i.e. temp_alloc so by next fgets on the same line (by lines larger than ) you are in uncharted territory. 

is quite a common one when using test suites that don't support expected exceptions, and it isn't particularly unpleasant. On the other hand, JUnit 4 does support expected exceptions, so you can just write that test as: 

Others have already given excellent reviews of the implementation code. I thought it would be worth giving some review comments on your test code, as you posted it. Very large tests You have two very large tests; each contains many assertions and can fail for many reasons. Smaller, more granular tests (each with approximately one assertion) are easier to read, and provide more useful feedback when they fail. To manage the initialization code for such a large number of tests, you probably want to use the annotation to define common setup code. Used well, that approach makes tests sufficiently "cheap" that each one doesn't have to do very much. Verifying the standard library In some project contexts, it makes sense to check that the language and standard library are behaving as expected, and to . I don't think this is one of those contexts. The first half of (up to the creation of the combined iterator) is just testing the behaviour of the iterators for and ; it's probably reasonable to assume that those work as intended. Checking for thrown exceptions The pattern: 

(assuming you have already filtered your tokens using or similar). List comprehensions List comprehensions are one of Python's most pleasant features. They're far too large a topic for me to sensibly explain in an answer here; that link will give you a good introduction, and there are many other articles and introductions around. Roughly speaking, list comprehensions (and their cousins, generator expressions) are a nice syntax for creating sequences from sequences, doing "something" (transforming, selecting, etc.) on the way. For example, you could write a list comprehension like this: 

From the tenor of your question, I'm going to just give some high-level suggestions of approaches you might use to make your code simpler and more manageable, rather than an in-depth line-by-line review. Performance You expressed a few concerns about performance and mentioned design decisions you'd taken for performance reasons. I wouldn't worry about parser performance too much: partly because premature optimization is sadness; partly because in this kind of application, parser input is generally small and parsing is relatively infrequent; and partly because optimizers are generally quite good at optimizing well-structured code. Unless you are using your calculator in some surreally absurd way, parser performance is not something you should be worrying about. So I would suggest that you not make your life more complicated for the sake of performance. Parsing balanced expressions You have a lot of special-case code and state flags to handle being in particular parts of the expression (like , various checks that is a particular kind of character, etc). All of this stuff would be easier to manage with a less ad-hoc approach to parsing. A recursive descent parser would probably be the easiest approach to get started with, but generally thinking about the grammar of your input language and looking at "standard" approaches to parsing should lead you in a helpful direction. I'm sorry if the above seems a little vague---it's quite a large and broad point. But I would suggest you read up on parsing. Parsing numbers Numeric literals (in every context I can think of, and certainly as you have implemented them) form a regular language. You will probably find that the easiest way to parse them is either to use (simple!) regular expressions, or an explicit state machine. There are a number of standard implementation techniques for implementing finite-state machines; the state pattern is one obvious choice, although for a language this simple I would consider a simple conditional/switch statement implementation. Input representation Your parser currently expects to be given a string which exactly contains a literal. This means that you effectively have to parse everything twice: once to determine the boundaries of the literal, and once to determine the meaning of the literal. This has a minor performance impact, but more critically, means that you have to smear multiple versions of your parsing code all over the place. I would expect that you would find things more straightforward if you allowed parsing functions to greedily consume as many characters as they felt appropriate from a "stream" of input characters (either an actual stream, or some arrangement with string+offset, with each parsing function updating the offset). It should not be too difficult to arrange your language such that greedily consuming characters is always correct (although you might need a few characters of lookahead). Evaluation You have a little throwaway comment about an evaluator that takes a String and produces a String. I suspect it would work better if the evaluator took either a string or a parsed representation, and returned some richer object as a result (e.g., a `Literal). Character identification You have a lot of code like "c == '{' || c == '[' || c == '('" etc. I expect that you would find it easier to work with sets of characters, either represented using Java , or, for convenience (with small sets) strings; then you could just ask . On a similar note, a function like that returned for , for , etc. would simplify various things. 

Having user/pwd in code, especially in clear text is a bad idea. If you still want them in the code at least encrypt them in some way. As they currently stand anybody can with a hexdump program read them. 

that may make its use less confusing than keeping track of all possible argument combinations. You may also want to include the stream to print to as an argument to , that way if you can alternatively print to a file instead of . 

You class contains a number of raw pointers e,g, LineCodeGenerator* which could be replaced with smart pointers to make ownership clear and memory handling easier. 

whether ownership is to be passed to it or not, using a smart pointer eliminates that need. e.g. here you directly that GenGenParse only shares the object, it does not delete it. 

returns the same value regardless of what error occurs in the function, it is better to create an enum with various error codes so that the caller of the function can determine what went wrong and give a suitable error message. In the same manner remove the fprint-out in the function, let the caller worry about showing an error message based on the error code. 

Prefer references instead of pointers when you pass arguments to functions, that way you are sure in the function that they are defined and not null. Also you see that it is not clear from the function prototype 

I would introduce a layer in between your threads and the file. E.g. have a thread that handles all writing to the file, it holds a mutex protected queue which is written by the other two threads. That way you have a layer between the physical file (slow access) and the queue (fast access). You then do not have to lock the file in any way since only the thread that writes the file needs to have access to it. 

that way you will be sure it always works even if you change the size of one day. using meaningful variable names and functions would be better, is not very descriptive. To use boolean include instead stdbool.h