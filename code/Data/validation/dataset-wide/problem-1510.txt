This not only increases general readability but quickly allows you to establish order (and verify that it is correct). 

I would have made that return true if there is available memory. Not if we ever successfully allocated memory. But I have not read the standard allocator documentation. So that may be what you want (though I doubt it). Why are you using ? 

Again. Not used in this class. If this is the only method in this class. And it is this simple. There is an argument for including it as part of the class declaration (so you don't need the cpp file. 

Let just say when I first read the question I was very impressed by the graph. Well done. Small mistake in reading the file: 

It is also immutable so you should not have used to set it up. Should have used the maps constructor. But it would have been even better if you wrapped this functionality into an class. What happens if I type a 200 character expression? 

I have a generic build file that I have all my rules built-into. $URL$ $URL$ Note: It is not perfect or great (but does what I need). But have a look and pull anything you need. This allows my actual makefiles to be very simple: 

Public Implementation: Bad No. You are basically allowing intrusion into the implementation details to implement anything. 

causes undefined behavior. This is because when is deleted you delete the pointer as a char pointer (it was created as an int pointer). Thus the runtime memory management will probably get the size of the block wrong. If you ever use a C-Cast then you are probably doing something wrong. Always use C++ style casts. Then it is easy to spot when you are doing things wrong. 

That should solve your memory problems. Looking at your code we could go into your design of MyStack (but I think that is superflous). But some common rules: 

One Up'ed me Well you have gone one step further than I have. I have been planning adding the "Make-Depend" step but have not got around to it. Layout One thing you don't do is build your executable/objects in a different directory that the source. This is generally best because debug/release binary are not guaranteed to be compatible and thus you should compile them into their own sub directories to make sure they do not get mixed up. I have found separating my header files from the source a pain. So I keep these with the source and automatically install them as part of installation. Any header files I don't want installed go into sub directory called details. So my structure looks like this: 

Why you ask is this second case a big deal. Well there is no constructor on Cont::iterator to create an object of type . So in the first test above there was no way to convert rbegin into the correct type. BUT there is a constructor on that takes an object of so in the second condition we could be in a situation where is auto converted into and the expression would compile. But luckily for us the designers of the STL decided that was a bad idea and made the constructor to prevent auto conversion and thus prevent the code from compiling. OK so why is in Dangerous Its also hides errors. The above code will generally generate a compiler error (so you spot it and correct it quickly). But lets dig in and build the code as suggested by @vinipsmaker. For this to work there either has to be a conversion from one iterator to the other or as he suggests a base class and a derived type. 

Without the container code its hard to tell if you can use the same iterator for both const and non-const iterator types. So sometimes its useful to provide const overloads of the above (but that will depend on usage). see: $URL$ You classify your iterator as 

You are now messing with everybody else code that uses your header file. That will not please them and can lead to issues down the road for them for wich your name will be cursed for a thousand years. No need to make the public. The poeple using your class do not need to know the internal workings of the class. 

Overall Its pretty good. Your main issue is just deciding who owns object (do the register functions really need to dynamically create objects). Can you have stateless plugins? Once you have decided on ownership then you have define the semantics you want to use to describe the ownership and thus how to enforce it. Note: Ownership semantics is all about who is responsible for deleting the object at the end of its life cycle. 

In this context you are guaranteed that there is no out of bounds access as you are already checking that is smaller than . Thus you are effectively doing the check twice. Don't use C style casts. C style casts are hard to spot. 

The problem here is that you are likely to get a couple of cards that are the same (thus stacking your deck slightly). What you should do is generate all the cards you expect to find in the deck then shuffle the deck to get a random order. 

It is easier to create normal objects (then you don't have to delete them). If you must create them then you should wrap their usage in a shared pointer. 

The requirement is that the object that was moved is left in a valid state (Though indeterminate). I am not convinced this is valid state. If I call methods on this object it should not cause bad things to happen (though I should not expect to know what could happen). Currently: 

Not a big deal but prefer pre-increment. The reason is it does not matter for POD types but for user defined types it does (or potentially does) matter. If a maintainer at a latter stage changes the type of the loop variable then you don't have to go and change any of the code the pre-increment is already the correct type. 

There is nothing wrong with assigning the result to answer. It will make absolutely no difference to the resulting code that is generated and it helps document the code by explaining what you are doing here. Another added advantage is that when you are debugging, you can hover over the variable and see that it has been correctly defined. 

Does this include the headers. If not why not just let them call and get the length of the string. It is considered bad practice to use . 

With a bit of work you can separate the allocation of memory from the construction. Thus only call the copy constructor on each member (thus reducing the overall load). But this takes a bit more work than I want to do just now. Alternatively you can and this problem goes away. Copy and Swap No need to test for self assignent when using the copy and swap idium. 

Why not. Does it really matter in any modern PC. OK for embedded systems maybe (but you obviously are using WINDOWS) 

Since this is a call to the previous that already tests for assignment of self there is no need to call here. Simply call and the child version will test for self assignment. Prefer not to use 

The addition of std::string will make this code ten times more efficient for the simple reason you will not have to re-compute the length every few iterations. Getters are a sign of bad design: 

Check the version of your compiler. That should not happen in C++11 compliant compiler. So I suspect that this is something you are doing wrong. 

Now if I change the list type from to none of the other code needs to change. I can even change to without any change in the rest of the code. Standard Patter for Iterators The standard pattern for iterators is that returns an iterator to one past the end of the container. While looping you can test an iterator against this value to see if you have reached then end. You seem to have added a special method to check for this: 

Note: That should work. Its been some years since I was digging around in this code. But I seem to remember that once any in/out operations have been started on a stream then an attempt to modify the local was silently ignored. Now this may no longer be true (or it may have been a bug in the implementation I was using at the time or the locale librarys are so under utilized that nobody knows how to use them correctly). I see what you are doing with there very nice. But it would be even better if we can take that one step further and do this: 

General Comment Stop trying to re-invent the wheel. Or at least go look at a more interesting wheel that has not been optimized to the point were you can't do better. Code Review You are calling std::end() every iteration of the loop. Its not a very ineffecient call. But its still doing work they you probably don't need to in most containers. 

Each controlled by a different container type. So I would guess that you probably want to use two different kids of iterator. 

You forgot to check that both cache and key are not NULL. The following will go wrong if either fail this test. 

Print the list where? Usually when you print something you are printing to a stream (std::cout). Usually you want to make sure you can pass in a different type of stream so it can go to a file or be serialized to a string for transport. SO I would have expected a print statement to take a stream object so the stream could be printed. Also in C++ objects are usually printed via the << operator. But it is acceptable to put a print method in the class to act as a helper for the operator. The stream operator may be something that will come latter in the course. 

Assuming that constexpr forces that expression to be evaluated at compile time and thus removes that whole block of code. Then it should compile. Review You and I differ on how we like to express the return value. I believe we have already had the discussion. So I just want to point it out for other readers. 

When you have a derived type deleted via a pointer to the base class you need to define a virtual destructor. This also applies when you are using . 

Pointers have no concept of ownership semantics (which means who owns the pointer. The owner of the pointer is the person responsible for calling delete). So you have no idea if you should be deleting the passed pointers or leaving them alone without digging into the code to find out. This is a very error prone proccess in anything larger than 100 line program. Luckily for you the use case is obvious but its something you should not be doing. Error Message? 

Also your bounds are a bit funky. You do beginning to end. Normally in C++ we do beginning to one past the end. If you want to be consistent with C++ usage you should adapt this methodology. Written as: 

Now we just need a definition for a . This is basically an object that is convertable to and when used with reads a line of text. 

It expresses intent more clearly and also will remove all the casting issues that you are going to have in the rest of your code. Never use C casts. Always use a C++ cast. They are easier to spot in the code and express intent much better. 

So you can write these functions that look like conversion operators that all give you a unit of length back. The other things is extracting the value in a particular unit of measurement: 

Rather than assume you will print to std::cout take a parameter for the output stream to be used. It can default to std::cout but this gives you the flexability to use other streams (like files/string streams etc). Also in C++ it is standard to define an output operator to print an object. Prefer over . The will also flush the stream which will usually make the code sub optimal. The stream is already flushed automatically if needed and if not needed will flush at optimal points so there is no need to manually force a flush. Prefer the range based for loop if you don't need the index (currently your loop is wrong (you should print the value at each index).