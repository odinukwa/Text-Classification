If I rm() the dataset containing the imagine data frame at this point, it still won't let me delete the working file. Has anybody solved this? Or anyone more familar with R offer any assistance? 

A good trick to use when coding, which I tend to do automatically now, is as soon as you use an "OR" anywhere in your code, then add some parenthesis to make it totally clear. Even if your where clause is simply: 

I'm working through some example code from Microsoft's documentation, to work out how to use R to plot graphical output - which in my case will ultimately be rendered in SSRS reports. It all works. Great, smashing, super. Here's my stored procedure: 

Here's the trick you're after - use the CTE to build a list of each region, cross referenced with every region which counts towards it: 

OK, just to follow up my correct (yay!) comment answer - in my experience almost everything along the lines of "weird issue" involving data selection, involves a rogue, unparenthesised "OR" somewhere in the where clause. It's always the first place I'd look. Typically you write some code along the lines of: 

During the last step, all of your SQL is run through the Optimizer, which takes into account all of the statistics and various paths that the DB2 engine could take to fetch your data. It then chooses the path it came up with that has the lowest cost associated (with newer versions of DB2 [DB2 10 for z/OS], it may decide to take a "higher cost", but "lower risk" path). Once the path is selected, it is compiled and becomes a package, which is stored in the catalog (you can see all of your current packages with (z/OS)). Finally, there is a last piece that allows our programs to reunite with their packages, the . You create a plan by doing another BIND (). A plan is a collection of packages that the program is allowed to look through to find the package that shares the same name. With COBOL, you specify which plan the program should search in in your JCL. 

The function will ensure that you'll always have at least 14 characters (it implicitly casts the first argument to , and then pads on the left with the last argument to at least the number of characters specified in the second arg), which the function can then cast to a . This won't work if you're on the Mainframe DB2 (the only type of generated columns DB2 for z/OS supports is identity columns, row change timestamps, or rowids). I'm not sure about DB2 for iSeries. 

and then when you look at the code your mind kind of fills in the parenthesis where you think it ought to be. Whereas order or precedence rules actually perform it thus: 

I've used SSRS for a subset of this kind of activity. It's not great for using as a full-on data input program for obvious reason, but there's no particular problem with running insert/update/delete statements inside datasets. What I've tended to use it for is more "clicky" kinds of updates. Where clicking on a hyperlink within a report causes something to happen - be it insert something in to the database, update a value somewhere, etc. And the activity that happens is controlled by the hyperlink passing in the various parameters to control that. I've tended to use a report where the hyperlink runs a new instance of the same report, but controls what gets updated by passing in new parameters. Mainly so that all the code is in a single report. I've made a quick demo report to demonstrate the technique in action, if that'll help? Available at: $URL$ You can do quite sophisticated stuff within the confines of this technique, but it's definitely not a data entry portal for entering entire rows of data. I'd be interested to hear if anyone's really used it for that in earnest. 

I think you should be able to use the command to set up your connection in SSMS. Create a shortcut on your desktop (or wherever), and set this as the target location: 

I see you already have an answer, and I see that you can't change the table definition because of other programs that use the table, but can you add in new columns to the table? Are you also on DB2 for Linux/Unix/Windows (tested on 9.7)? If you can, and you are, then I might suggest you create a to create a column, which you could then index for searching. 

While @user22610's answer will work great if your DB2 platform is Linux/Unix/Windows, it will not work on Mainframe DB2 (z/OS). If you're using that platform, this would be your command: 

Edit (update for comment): If you are using the command line processor, you can pass in either a single bind package (), or a list of bind filenames (). If you pass in a list, the filename has to be prepended with a (e.g. ). Inside the .lst file, you can either put each package on an individual line, or you can separate them with : 

Knowing, and understanding, different options to obtain the same results is key to getting familiar with SQL, IMHO. No matter how obscure and esoteric the problem might be. Anyway, I know I'm late to the party, but here's a different take on a subquery method.. 

Yeah, SSRS can be a little cumbersome with its handling of empty/null values. Try adding an explicit isnothing() before the yellow option: 

Horses for courses. Works pretty much the same as your method. I'd write it your way in this instance if I were me. But it IS a good conceptual exercise to try to think of and compare different approaches like you're doing. Keep it up! :) One thing to note: you should really reference the source table in the SELECT clause. To avoid ambiguity or future complications: 

You're cross joining to your "inp" query, but then using the results from that in the where clause for the subquery of your main where clause. Effectively then the subquery will run once for every row of the zip table. Which will slow things a tad. I'm slightly rusty as to what you could achieve with any PL/SQL around this, so in pure SQL you could write it as: