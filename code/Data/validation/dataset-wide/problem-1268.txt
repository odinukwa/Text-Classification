And we now have a subroutine that fits on a single screen without scrolling. We could probably extract another method, but this is good enough for me. The code below does exactly the same thing your original did. 

I'm really not sure that I would handle that in your grammar. The logic is convoluted (not yours, just leap years in general) and I'm pretty sure this will match a few leap years that aren't. Much better for this one to be validated by your parser if that's possible. 

If fails, you could return the original string. If you don't want the original value if it's not a number, you could use and catch the appropriate exceptions. TL;DR I don't think you need to do this at all. Sorry. 

I like that you didn't bother with the extra join, but if you're going to use integer key values in your statement, you should clarify what the value represents. Otherwise, the person looking at it will have to figure out which table the key is stored in and look it up to figure out what it represents. 

Readability Note: This code has a lot of one letter parameters. I would try to expand them a bit for readability. Of course, that's easier said than done when we're talking about primarily mathematical functions. 

The second thing you can do is manually short circuit the logic, but you'll have to sacrifice some DRYness to do it. 

This involves unnecessary over head. You see these kinds of things in code that is being manually tested instead of properly unit tested. 

Simple enough, but my first version stuffed everything inside of , which I don't care for. So, I wrote a second version that nicely separated the concerns. The problem with that, in my eyes at least, is that it now does exactly twice the amount of work as my initial "naive" version. Does the benefit of separating concerns outweigh the performance hit on an already exponential algorithm? Also, I don't like this snippet (that exists in both versions of the code). 

Note that I gave the join conditions some breathing space. It was really difficult to understand as a one liner. In SQL, new lines are your friend. Use them liberally. Personally, I like to make sure that all keywords are the first word on a newline. I'm going to pick on just one more alias... 

I'm not a fan of creating new objects in constructors. The Sprite is a dependency and dependencies should be created outside of the class and injected in through the constructor. However, it looks like the creation of the dependencies is pretty complicated, so I do see why you chose to consolidate it in one place. The constructor just isn't the place to do it. Consider making yourself a factory class or using an inversion of control container. 

In my opinion, if you're going to implement a contract, you should fulfill the contract, even if that means doing nothing at all. There's little more frustrating than getting an object that you believe implements an interface only to find out that it doesn't really implement it. Oh no, this implementation throws an exception when I call that method. Now, my nice clean code that, previously, didn't care what concrete type it was passed has to type check it's args to make sure it's not an instance of this class you've created. Ok. So I do know how I feel about it. I hate it. I really really hate it. I'd much rather that you fulfill the contract by truly not implementing it. 

This allocated memory, only to instantly overwrite it with the value returned from the static method. This whole thing could be simplified down to a single line. 

I've been working on a COM Add-in for the VBA IDE with a friend. The idea is to search the active VBA Project for "magic" comments and create a task list much like any sane IDE would have. This is my first "real" project in C#, so I'm feeling like this code could be better. The code below is all in the code behind of my , which I don't much care for. I was told that using a Model View Presenter pattern would help me out with that, but I don't see how I can decouple the control from the object that it parses and uses to jump to a specific line of code on double click. I'm also not very happy with the private method. I just can't shake the feeling that there's a better way to return a marker. The control gets embedded into a native window and looks like this. 

Similarly, I don't like having the entire statement on one line. I usually put the statement on the next line, indented one tab. 

And create a class that manages what Message to return based off of the value of the passed into its constructor. Reducing the above code to 

The first part of the if , so there's no real need for the . Like I said, that's pretty nit-picky and could be considered to be a matter of preference. I don't much care for the style here. 

It's a touch convoluted because I would expect to be a member of , but it's not. It's the method'd argument. I think some careful renaming and perhaps a comment will help here. 

If you don't like that, perhaps add the parenthesis to make it a bit more clear and explicit what is being returned. 

Like statements are expensive. I don't think it will make a difference in the query plan for this particular case (it's already scanning c.Serial_Number anyway), but the last two should use an equals. At the least, it's more semantically correct. 

Now, you could repeat this process for , but it's not nested so badly now, and the function is pretty short and concise as is. You know what though, I'm not quite happy with it... I think this is a case for . It's shorter and undoes the nesting, but does sacrifice a little bit of "understandability" (as any ternary operator would). 

Summary Original Question here. Updated GitHub link here I've taken an interest in lower level data structures and I implemented an 'Ip4Address` to get familiar with Explicit structure layout. It turned out to be an exercise in properly implementing a struct in general, but I digress. The idea here is that each Octet of the IPv4 address is represented by a byte in a single 32 bit unsigned integer. Things I've addressed since last review: 

I understand that there are only two choices for direction, so it must seem like a Boolean is the right choice. What does mean though? Doesn't that read oddly? If you stick with a boolean value, I would go with or instead. I think reads much more naturally. (Please note that I didn't take the time to figure out if it should be horizontal or vertical.) I would also extract the logic that returns the random coordinate into a function to remove the duplication. You should end up with something that looks like this: 

It looks very much like this is a requirement. It's poor practice to select all fields from a table using the notation. Doing this will force the RDBMS to lookup the table's meta data. I've found that it's pretty rare that I'll need every column from a table. It's best to be explicit about what you're selecting, even if you're selecting everything. Any performance improvement from this will be marginal, but it has the benefit of protecting your code from breaking if the underlying table changes. 

Well done right there. All too often there is no documentation about what references a piece of code needs to work. Someone will thank you for that someday without a doubt. 

First, stop using as an all purpose variable name. It makes your query nearly impossible to follow. Using lambdas does not excuse us from using meaningful variable names. Next, take note that SelectMany takes an , so you don't have to materialize the query by calling . You should be able to simply call it on . Which in turn makes me wonder what exactly you're trying to flatten here. ??? Something doesn't quite sit right there. Typically, you'd call on the property of an item in your enumerable, like in the doc I linked to above. On the same note, this call is completely useless. 

Also, although the factory was a nice idea, you're using an IoC and can do the same job with Ninject by telling it what constructor arguments to use. This means you can completely remove the factory class and interface. 

The "Happy Number" code is tightly bound to your main routine and user interface. As it is, you couldn't take the code and plug it into another program. It would be best to break this code out into its own class and call it from . 

Not perfect, but better. Remember, it's not necessary to cram all those lambdas onto a single line. Is there a reason you're calling ? That forces the execution of the query. If this is hitting a database with a lot of records, that could be potentially expensive. You could also potentially clean up the second query a bit by moving the "converts" to the the prior queries.