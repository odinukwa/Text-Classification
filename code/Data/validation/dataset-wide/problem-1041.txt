The trick here is to not to get overwhelmed by the fact that there is a spatial datatype involved. Then it becomes a fairly simple aggregate query over a join between the pricing table and the catalog table where the join just happens to be a spatial intersection. 

Here's a variation on how I have tackled this in the past. I have added a grp and seq columns to the @Geo to demonstrate how to build multiple lines and get the order of the points in the line correct. The seq could alternatively be datetime. 

The other common query for this type of thing is to return the n closest points, otherwise known as a nearest neighbour or knn query. 

Also note SQL Server let me build a spatial index over the geometry column that contains mixed SRIDs, but it is of limited use. Even if there was a lot more data, the index would be of limited use. I would suggest to make life easier that you pick a single projection to use across all you data and transform geometries to that. This can be done alongside the current geometries or replace them. Also if you choose a Lat/Lon projection, use the Geography data type. There is an open source project, SQL Server Spatial Tools, that has some tools that will allow you to do projections. You will however have to know the parameters for the projections you are using as it does not appear to have a list of projections to work with. I can't advise how good these are, as I haven't used them. 

Why do you want to partition? Is you performance not good, or do you have other reasons? I don't see an index for the lastupdatetime column, and you wrote that you query for it a lot. An alternative to partitioning could be creating tables for each year, and use merge tables to access the subsets you need. Would have just left a comment, alas, not enough reputation. 

As you see from the explain output, mysql does a full table scan on table t4 (rows: 2374015, keys: NULL). Adding an index just for networkAccessMode will probably help - depending on the value diversity in networkAccessMode. How does the explain change when you don't specify the indices explicitly? 

Perhaps naming the columns "hired" and "fired" instead "start_date","end_date" would be more accurate, because a person in vacation hasn't been fired, and indeed is still employed. Same with "firereason", which is misleading, a simple "reason" would be more accurate. 

I have been asked for recommendation on the optimal RDBMS for a large amount of data. The largest table would contain 2TB of data. My own largest table is only 400GB (mysql, performs very well). The individual rows are going to be short, no blobs/etc, just a lookup table. Is PostgreSQL nowadays performing better than MySQL? Can I ask DBAs with tables in this order of magnitude for their experience? Oracle might be considered as well. The available hardware is probably a standard linux box with about 64G ram. 

I get 93ms, 4ms and 93ms respectively, removing the TOP 2000 from the queries causes the price filtered query to blow out to a minute or so. Are you able to give more details (execution plans, DDL, etc) to help us replicate your issue. My initial thought was that the was hiding the underlying problem. I think that may still be the case. 

I've done this using a CTE query as I find it easier to follow and explain. The first CTE is just your data. The second CTE ranks each row of the data using based on the ordering of the . I have include the in the order so that if there are duplicate the first occurrence will be picked. In the final query we are using statements to pivot the data and aggregating the result for each with to create a single row for each . This query can be run over multiple 's 

There is a couple of approaches that can be used here depending on the exact requirements. First of all you will need to create a spatial index on the Landmark table 

Dividing by 365 is slightly incorrect, because it doesn't take the leap years into account. Another problem with this answer is, that overlapping hire/fire periods are ignored. For example, if an employee was employed at 50% time from Aug to Dec, and additionally at 30% time just in Dec, the query would fail - but you don't take percentage into account anyway, so I assumed that the employment times don't overlap. This has been confirmed by the original poster. For more date functions, review the documentation: $URL$ The different date/time functions will also help you answer your other SQL question. 

From the MySQL documentation: The NULL value means “no data.” NULL can be written in any lettercase. A synonym is \N (case sensitive). $URL$ 

I went through the PREPARE and EXECUTE, because LIMIT doesn't work directly with a variable, this is a workaround. Now put it back into codeigniter: function reports_median() { 

Not being familiar with codeigniter, I am doing this first in SQL, and then make a guess on how to translate it back into codeigniter: I translated your query to SQL first" 

This is my interpretation of your requirement.As a simple query, this will return what you want, however you will probably want to try other options to make it perform. I don't use MySQL, but in SQL Server I would look at trying CROSS APPLIES or some sort of grouping option. This query will return all the dates on which the minimum or maximum occurred. You can of course then filter that to suit what you require. 

Then to incorporate the scaling factor into the sum you can use a case statement in a subquery, similar to the following 

Then to query for all points within a specified distance you can do a query similar to the following 

This is generally the way that I tackle rebuilding spatial indexes in a consistent way. This assumes that your geometries are all in the same projection and have already been indexed. It will exclude the usual ESRI Geodatabase System tables. I avoid having ArcGIS create or maintain indexes. They never seem to get nice extents on the projections that I use. 

This gives a table of 1,000,000 random points with a 2 x 2 degree spread. After trying a few different options on it, the best performance I could get was forcing it to use the spatial index. There was a couple of ways to achieve this. Dropping the index on LegendTypeID or using a hint.You will need to decide which is best for your situation. Personally I don't like using index hints and would drop the other index if it is not required for other queries. The queries stacked up against each other