But the above code seems to carry little logic. I think you were looking to nest the color classes after parent element like this: 

Semantic elements are completely supported by almost all browsers except some versions of IE which does not include support for element. Going by the flow chart here: HTML5Doctor Semantics Flow Chart, you can replace the images with tags and associated . You can also make appropriate usage of wherever needed. Remember that we will be/are using semantic markup in order to feed the browsers to read the page more accurately. 

You have used JavaScript code to load the images in middle of the page code. The readability is disturbed. It is better to create a separate file say , write the program inside a function and load it into a div specifically in the file. My edit on your post was rejected because I tried to modify the white-spaces in your code. I would like to add one more thing here. Please try to avoid using so many white-spaces in your code. Although it maybe useful for you in development version for editing, it adds to the bandwidth in your production environment. That is why CDNs serve minified version of the code. Same applies to your HTML as well. Even if you want to implement in dev environment, use the code guidelines I mentioned above. 

It makes perfectly sense to make that not cachable. You want the result based on the actual exchange rate, and this changes every second. What I really don't like: Your interface has a HttpClient and is therefore coupled to implementation. This should be moved to the actualy implementation. The next thing: You're caching is also coupled to the technology. So if the backend changes, let's say you get it from a database, the caching mechanism is not reusable. I think it's okay for your case, and I wouldn't bother too much,... but, if you consider testing, you actually can't unit test the caching. 

Einstein was awesome Considering the solution to any problem, Einstein said: As easy as possible, but not easier. And to be honest, that's what your solution lacks the most. Here a general (and of course debatable) idea of how it could be implemented much easier: 

Looks decent! Some smaller things: The is declared as . Always declare it as , since is an "implementation detail". If you'd switch from an ArrayList, you might have to change an awful lot of code. Also, it's name is , I would have used . Also, you want to think about if is the best type. Suggestions: Use a , where the String is the phone number. So it's a bit easier to figure out, if a phone number already exists and easier to remove a contact. With that said, another suggestions: Use a custom type for a phone number. So you can save stuff such as the country code, if it's mobile or office. (But then, the suggestion doesn't work very well anymore). Hope this helps, slowy 

You keep track of class instances and not bare integer values, You can re-use this class in other projects or forms (if designed & implemented correctly), You can extend this class to enrich it's functions etc.. (There are an infinite number of benefits) 

The code is missing the class which I think is also important for the review. The cache items are added with keys and it is important for this method to return the same value for objects having the same credential values, and distinct values for instances with different credential values. Is it? Naming conventions. Class names should be PascalCase and the class violates this rule. Should be To achieve better encapsulation and seperation of concerns, (The creation of an empty credential object should be a concern for the Credentials class, which has control over the internals of itself) instead of having a field in this class, it is better to have a field (or property getter) in Credentials class. 

That's why we should first think about the primary concerns of our application, and try to seperate these concerns into classes, which can then also be re-used if designed modularity in mind. Therefore, Assuming what you are trying to achieve is something like this: 

getType() Why on earth it's the 's job to handle the car type anyway? And why is the car type stored in a . findNewAStarPath() 

What are you clearing the email and the message? Looks important. I think it's only in the doGet. Maybe wrap it in a separate method which describes what you are doing here. And then the 'cookie-to-session-stuff' 

basemoveRate is never used again. Beside that, it should be a constant: private static final BASE_MOVE_RATE = 10.0; 

To figure out, how long the i/o takes, remove everything between within the loop. So you know where you can focus first. Or where it doesn't make any sense. I'm reading 829MB's in around two seconds on my machine(Using your way to load the file, without the magic within the while loop). If I use BufferedInputStream->FileInputStream, it's half a second, using a 8*1024 buffer. Well, that works as long as you don't work with fancy charsets. Here's an interesting article, one guy did a test a lot of ways to load data from a stream: $URL$ Here's an interesting article about buffer sizes: $URL$ If nothing helps: If you're in charge of the part which writes the file: Write different files on different harddisks and have a thread for every file and merge the results together. Regards, slowy 

Try to avoid using underscores and use dashes like to break the class names. You can check the Code Guide written by one of the Twitter Bootstrap core team members. Combinations of underscores and dashes are more suitable in CSS BEM methodology. But in the end what matters is consistency of using the syntax. 

I think it is better to just use . It does not matter now, but when you code for bigger projects CSS performance matters the most. Descendant selectors are considered expensive and you can normally avoid it here by selecting direct element. Both do the same thing. You can use if you want to override some CSS properties only for hosting image containers which are under index pages container. Because CSS specificity will work on it here. Let's say: I have a multiple items with certain class and want to override the items that are within a container. 

Yes, it is fine. Regarding CSS, the difference between ID and class is specificity and uniqueness. You can also link to a div with its ID. Seems more of a personal preference and varies from a developer to another. 

Minimize using and tags, it is clutter to the neat code you are writing. Block level elements by default wrap the next element to a new line. You can also make use of margin and border in CSS for a cleaner approach. Combine repeated styles inside a single CSS rule. For eg: 

Looks good, except: activateObject/passivateObject method: I don't see any usage of the running variable? Beside that, you don't need to do anything in that method anyway, that will be called, before the object will be returned, I don't think that is needed for a Cipher instance, isn't it? But why I'm actually answering: I'm fairly certain you won't gain any benefit by using a pool for Cipher instances. The management of the pool, the synchronizing, the maintaining of the code and the additional library will use way more ressources. A general rule is, "by definition": More code means less performance. Of course, that's not entirely true - what I want to say: If you want to improve performance, you have to measure, before and after your changes. And not only millis, but also cpu, memory, gc, io and so on. You have to be sure, you're changes actually did make an improvement and not the opposite. Hope that helps,... 

Well, when I read it first, it made sense. But when I take a closer look, man there's some fancy stuff going on there! 

We have an app with few entities, which are passed through a workflow. The entities have different workflow states. The main issue is, that the change from one state to another often leads to other executions, such as updating other records or sending emails. The actual code is a bit of a mess right now, very long methods with lots of if elses. I'm trying to implement some sort of an entity state machine with the main goal, to reduce the code mess. The code does not respect assertions, such as null checks, exceptions, etc. I'd like some advice, if I'm heading in the right direction, if there's some simpler methods, if I will have some sort of problems with this solution - or any advice in general. Well, if you see something that annoys you, I'd like to hear that, too =) I like the most about this code, that we can isolate necessary code for switching from a specific state to another specific state, as in . But I'm still not really convinced. The 'assignment' of the posted code would be "If I finish a Task, the task is persisted and a mail has been sent to the user". 

Method name is a common method name used by collection types to add a new element to the collection. An method with source as the first parameter and the items to be added as the second parameter does not make sense. and are bad names for parameters and should be changed at least to and or similar. And in Capitalization Conventions 

To prove that it is properly working, I run a 100 concurrent threads test with random access to the operation with the same credential instance. This test revealed that, 

Then, why restricting the second method parameter to ? Let's get that as an . This way, your method can also operate on or instances 

And here are the results of the test, which shows the method is invoked a total of 5 times for all the 100 threads. The test created 100 threads which access the method randomly within 500 ms. There is another thread for removing the item from the cache in 100 ms continuously (This is because, the cache policy doesn't seem to effectively remove the item at the exact point of time of expiration). The method lasts for a random time between 0 and 500 ms With the following results, it can be seen that the method is invoked a total of 5 times (which is the number of the cache not containing a instance for the given credentials, first one because the cache is empty, and for 4 more times because it is removed from the cache) I can't help myself thinking why the of returns when the item is added to the cache. This would have been implemented differently (as returning the added instance as ConcurrentDictionary does)