Again however, if some class extends it, they won't be able to access the var. Also, stay away from static. 

But without knowing how you want your JSON to be defined, at the moment I can only suggest the following, which fetches all records in the SQL query and shunts them to the JSON encoder. 

"I'm pretty confident it would be a bad thing to have the same code for opening a connection in each function of the class, that's why I've put the connection opening code in a function itself." 

I took the liberty of going through your code - see the comments preceded with MOD (modification), STAT (statement), QUES (question), SOL (solution) and REMOVED (removed) 

I've tried cleaning it up a bit here, removed instances of setting a variable once and using it directly below where it was set (yes, improves readability, but still). 

I just put this together, so I haven't tested it or anything, there might be bugs and someone else PLEASE come along and improve upon it, but I think this might be a good starting point to answering this question: OOP version of OP's code: 

I made a few changes - namely normalizing the styling (PascalCase classname, lower_case properties, camelCase methods) and spacing. I then made the buildOptions() function shorter and renamed it to generateOption() as that is more adept to what it does. I also added an InvalidArgumentException in the construct that is tripped whenever you pass in an empty array. 

Why not go with a template like Twig or Blade which would make the syntax a lot cleaner, while retaining most of all the controls. Also, remember that the view is for showing data, try to maintain as much logic OUT of the view as possible. Here's an untested version of your code with Blade: 

It defaults outside_mode to False, so that we can omit it and only give it a number to check if its within the range Checks if n is within a range elegantly Uses the retval var as a flip switch boolean Handles strings and outputs False if its a string Correctly outputs the expected output 

I think it looks ok - though someone might want to add on if they notice any issues I may have missed. However, a bit of cleanup goes a long way: 

Any ideas on how to improve this to improve performance or reduce calls? Any review, refactoring or just general thoughts would be highly appreciated. What did I do wrong? What would you change? Thanks all! EDIT: adding rudimentary html snipped this acts on 

The code below is good. I only changed the comments a bit to make them a bit clearer and more concise. However, one glaring issue is that it seems you have your setters and getters mixed up. Note the and functions you have in your class. Usually, setter and getter functions do exactly that: they set a value and get a value. What you seem to be doing is using the set* functions to get the value returned by another function. This is +wrong+. 

Notice that your original answer does not catch nor raise an error when encountering a string val. I've reworked your code to this: 

Other than those tips, I will defer to more experienced PHP coders. I hope my ideas help you out a little bit though. Good luck! P.S. As for your original idea of combining the statements: I don't think they can be combined because they are doing different things. One is SELECT, another is UPDATE, and the third is INSERT. If they were all doing the same thing, then you could combine them using various types of JOINS probably. But since they are performing different actions I don't think that is an option. 

I was working on the Project Euler problems today in C#. Here is my code for this one. nhgrif's technique is excellent, but you can shave your code execution time down to an extremely fast 50ms without any advanced techniques. The only thing I did to optimize the code was iterate from instead of . I didn't even implement code to skip even numbers, which could make it even faster. Perhaps your technique of storing every prime, instead of just the current one, is why your code is slow? Your technique is to store every prime in a advanced data type. Instead, you could just store the current prime and current prime count in or primitive data types. 

As you can see, in this class any method called from Main is declared as public, and any method only called from within the class is declared as private. Structuring this program as a class instead of a series of functions makes it easy to re-use the code. It makes Class PrimeFactors like a library that you can easily include into any main that you want. I agree with the others about commenting less. I was reading Clean Code by Robert C. Martin the other day, and he argues that comments should be minimal and pragmatic. Ideally you want to choose very succinct names for your variables and functions/methods, and you want to make as many chunks of code into functions/methods as possible. And what this does is it names everything, which helps to avoid you needing to make as many comments in the first place. I think you're already on the right track with this because you wrote multiple functions and you tried to give them all good names. 

I think it's actually a really good habit to call functions from within functions. This is a very important concept in Object-Oriented Programming. If you wrote this source code using OOP, you might structure it like this... 

Thanks for the comments. I understand what your webpage does now. Suggestion #1 - Descriptions Of What Your Code Does - You might want to create some functions (or add some comments) just to make it more clear what each segment of code does. The OOP people like to make tons of functions that describe chunks of code, and the non-OOP people like comments. You can go either way, in my opinion. In my example here, I will use functions. Suggestion #2 - More Whitespace - I would also add some spaces after your commas and maybe some enters after your commas in your bind_param() functions so that everything wraps nicely and is easy to read. You can do the same thing with your prepare() functions. It isn't a big deal for single line SQL statements like "SELECT * FROM table WHERE field = 'value'", but it starts becoming very helpful when you're doing long, complex INNER JOINS and other complicated SQL statements. 

Removed all semicolons - they are not required in Python Removed all parentheses around the variable as they're unnecessary Renamed the variable in to Renamed the function to Created new and functions to clean up print statements in code 

::EDIT:: In regards to the comment (not same as OPs code), turn the function into an iterator rather than returning a list. This will give you the speed boost of the prior code, and still give you all the places of occurrence: 

Also, instead of perhaps consider using . Perhaps someone with more experience with Nginx confs will follow up with a way to store certain bits and pieces in variables or will offer a better solution than mine (I for one would love to know a better way of doing things) 

Memoizing a generator is a good idea to save having to rerun it. There are a few ways to do it - one is to handle it the way you're handling it, by returning the cached result if it exists, otherwise returning and caching the new result. The first way, is to the the method from . Such as follows: 

Well, the function kind-of sort-of violates SRP...but according to Uncle Bob, I think your class violates the SRP moreso than the function. Your class above, has three functions within it: . One of them scans the directory, one of theme creates an array of theme names, and another loads the theme files. One of those methods should not be in there: should be in its own class called or something. Which means, by extension, that is in violation of SRP. To quote Atwood - SRP is about "choosing a single, clearly defined goal for any particular bit of code: Do One Thing ... But in choosing one thing, you are ruling out an infinite universe of other possible things you could have done. It also means consciously choosing what your code won't do.". So in the end, its up to you whether this violates SRP and whether you would choose to follow SRP so deeply that you violate OOP or DRY. Perhaps someone with more experience can chime in or prove me wrong (heck, always good to learn something from someone else) EDIT: See ($URL$ article as well for clarification. REVISIT 01/26/2015: Revisiting this answer, I would rewrite the code as follows: 

My little attempt basically takes items that are repeated and puts them into their own separate conf files and just include them into the main conf files. On my servers, I structure them as such: 

The only real optimization I see if taking advantage of Pythons english comprehension to unify the return statement: So, would read: 

These are the two final products, one brute force, and one using built ins, and both return the same value when a word is found: 

That way, we end up with 2 function calls to and 2 new variables (which are cheaper than a function call), but is still not as performant as your original one liner. 

I seem to get the feeling you are either not comfortable using maps as others have suggested here...so why not throw in a switch instead?