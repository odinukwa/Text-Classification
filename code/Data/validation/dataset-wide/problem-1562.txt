As I noted in chat, you will want to pay particular attention to code smells. To start, make sure you read this article ($URL$ and his other articles as well. While some of this stuff may be difficult to implement at first, breaking bad habits now goes a long way. That out of the way, lets dig in. Hungarian Notation I used to be a big fan of hungarian notation. My code was riddled with oFoo and sBar. Hungarian notation is harmless, right? It wasnt until Comimterm pointed out to me that I had completely missed a potentially code breaking variable that looked like it had a type, but was never defined with a Type. As a result, I never saw it. Inevitably, I forgot to fix it too, and it came back and bit me in the butt. Why is hungarian notation so bad? I'm glad you asked. Most commonly, it allows us to become lazy as we are declaring variables. Take your classQueryMetaParameters class for example. The name in itself is a mouthful. If you create a new instance, you have to declare it as a classQueryMetaParameters and, to boot, you dont get much help from intellisense until you hit the Q. Second, within the class you have this little nugget: strDatabase. I don't know about you, but I have no way of fitting a database into a string. Of course this isnt actually a Database. It is likely a DatabaseName, or DatabasePath, or DatabaseSomethingOrAnother. Why don't we have to be a little bit better with our name? Because we could have a recordsetDatabase, and a strDatabase and the compiler will compile happily. The key here is this: you, as the programmer, knows what strDatabase means but no one else will. Trust me, when you have to fix the project a year from now, you will be kicking yourself in the butt. Defining Custom Classes This one I stole from @Mat's Mug so full credit goes to him. Frankly, I thought the suggestion was borderline cumbersome at first, but it has made a tremendous difference. Note the code below: 

Again, this is a very simplified version. Usually I am extracting more data than just a few simple scores. The worst I've had was Day-Over-Day tracking of roughly 40 students on an assignment level basis. This is what led to the need for a dictionary over an array. 

To get you started, you have a number of unqualified references within your code. This is particularly puzzling to me since you declare and pass worksheet objects, but you never use this object when determining a reference. For example: 

What this allows me to do (primarily for data) is use an empty value if the input condition is invalid (null) while still returning a numeric (or some other non-string) if the input is valid. Likewise: 

Based on your 'final version' I figured I would offer some advice. While the great advice offered by Mat's Mug and Vityata seem to have helped you, it also seems as though you are still not quite there. First code, then explanations: 

I made some changes to improve your code overall. This wont improve performance, but these changes are worth noting nonetheless: 

Overall Observations There are a number of inefficiencies that are holding you back. First, you are still using , and . While there is a time and a place for each of these, it is preferable, by far, to avoid them. You can do this by fully qualifying your references. 

We get rid of all of those counter variables (opting instead for i and j which are pretty standard). Our other variables are quite clearly named, and everything is what you would expect. As a result if you (however many years from now) come back to the function to add something new, or if it breaks, you can quickly find the source instead of trying to remember what and were and why you set or to and so on so forth. Again, highly recommend picking up a copy of . The idea of levels of abstraction, functions, classes, etc all can be difficult to understand at first but once you get going your code will become much easier to read. 

Which is fine if it is what you meant but it may not be what you meant. The thing is, not only do you not know what the Activesheet is at the time of the code running (unless you Activate it, which is it's own problem) but you also don't have control over the type going into Foo. It could be a String, or an Integer, or a Double. If you use it'll be a . will happily take anything you give it, which is a problem. To solve this, be smart about your code: 

Walk yourself through this, and count how many processes it is responsible for. If I was refactoring your code I wouldnt want to touch this with a ten foot pole. There is just too much there, doing too much at once. There are ten separate clauses, and at least a few cancels in here. This is a prime example of what subroutines are meant for. Consider this (somewhat hasty) example of using a function, and bubbling up the error at the same time. 

This class uses a code pattern I learned from Mat's Mug. Declare the for the class as a , then declare a private that refers to that type. As a result, you have an organized to hold your variables, and you get intellisense. Once you do that, you just need to open up the property accessors. In this case, I made everything public. This isnt good practice, but I am avoiding teaching you too much at once (I would prefer not to use a class as is, but it is the best approach at this point). This Code Goes in Your Module 

This is very common, and I made the same error in naming when I first started off. For a while, it will be unlikely that you have any issues with this. There will come a point though where you are debugging your code, and you have multiple Worksheet variables, and WS just doesnt tell you what you need. Consider useful names that tell you something about what the variable contains such as these: 

The only main difference is that now we are using an object instead of a type, and we must manually copy the object any time we want to create a new one (whereas, with the Type, we just changed the field). 

This will return a 1-Based array that you can then loop through. Now, for example, if Column "C" should equal "B" * "A" you can do this: 

This would then be called by creating a new instance of the class, and then usually by calling the 'Add_TableItem' routine. EDIT: As a side note, I am a super noob when it comes to classes. I know the basic ideas about how they work, but when it comes to terms like immutable, or encapsulation, etc I have no clue what I am doing. I have been working on improving my class knowledge, but putting it into practice is the more difficult part. EDIT: Very simple example of the kind of data that would be loaded in and used (the tables usually are about 100-200 columns with 30k-60k rows): 

Why is this little change better? It is using the active sheet! While not ideal, it at least ensures that points to the same worksheet unless we explicitly change the worksheet it is pointing to. It is stronger than the reference. Even better would be: 

I apologize for the very basic example of how this would work. I usually use this on pre-built Excel tables where I am extracting data from, and I use a class for this process to make it a bit easier on my end. These are the principles though. 

And it is now a range reference (the only difference being the keyword). While it is easy to read the code and determine what is happening for us, you will inevitably lose a bug in there that you will have to search for. Option Explicit to the Rescue! is one of the best things in VBA. It is truly simple, but it makes the simplest of bugs super simple to prevent (and even simpler to find). With at the top of a module, the compiler will throw an error when a variable isnt declared. 

I am certainly not an expert on naming conventions, so find what works for you. Definitely be mindful of what your names tell your 'reader' though. The other point worth noting here is how you have names that are inconsistent: 

The code below is in two parts. I have pasted code with your old code commented out, and then additional comments for clarity. I have also posted a cleaner version with just comments. Note: From reading the code, it likely wont run properly. I was unable to figure out exactly what your loop is doing, and as a result there are still some bugs. Be sure to fully debug this code before using it. Full Version 

Open the Developer Window Press and then . Check the box for . While you're in there, I recommend going to the general tab and selecting under error trapping. 

Aside from the couple of instances of a single ratio being matched to two different aspects, they are fairly consistent. So then I checked each of the original aspects and their results: 

That was the first step I took in making your code make a little bit more sense. By extracting the two loops, and the dimension check, the main routine becomes much cleaner, and gets to rely on a few s to do the work it needs to do. The beauty of this is that your code now explicitly says what it is doing (anyone could read the code, regardless of whether they have been coding for days or years). The next step I took was explicitly checking for the supported types. For example: 

To make easy, do this: Alt + T Alt + O Editor Tab Make sure 'Require Variable Declaration' is checked Indentation Make sure your code is properly indented before posting it. If you did, you would've noticed that you were missing the at the end of your block (which prevents the code from compiling). You would've also noticed the lack of and . Select Case vs. If...Or...Or...Or...Or... Any time you are doing multiple "If it is this, or that, or..." conditionals, you should use a statement. There is a slight performance increase, but it is also cleaner and easier to read. Additionally, it makes it easy to edit the conditions as needed. works by taking an input variable, and checking the condition against 's. If the condition matches, it runs the code inside the block, otherwise it goes to or in the absence of . For example: 

While your code isnt hugging the left-hand side of the window, there are lines that, by their indentation, seem like they are actually procedure declarations (Sub Foo's) and not declarations within a procedure. Dim Blocks This gets its own header because it is something often overlooked. It wasn't long ago when, like you, my Dim blocks were like the glossary at the end of a textboox chapter. At times, I was proud of them. "Look at how much I must be accomplishing with this sub. I have so many variables declared!" "My Dim block looks so nice, and uniform. Surely my code is organized." Hyperbole, of course, but I truly was proud of my code. Then came along Mat's Mug to trample all over it (indirectly). I saw his advice about how they can actually be ineffective, ugly, and work against code cleanliness. I decided to give his way a try, and sure enough my code went from "Okay" to "Much Better". Why are they bad? First, they encourage lazy coding. When you are declaring all your variables at the top, there is no need to question 'Do I really need this here?' and further 'Should this actually be a function?'. These two steps are vital to cleaner code. Even further, they make it more difficult to see when a variable is declared but unused, or when the name doesnt fit the function. In short, declare your variables as close to their first use as possible, and as a result you should see an improvement in your code. Variant - The VBA Programming Menace Variants can be used effectively, and they do have their place within code, so don't think I just write them off completely. I have a few procedures where I use Variants like: