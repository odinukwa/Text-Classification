so you could pass your orderDetails easily from your success handler to the function. No reference to a global object needed - or better: no need for a global object at all. 

Here you are mixing two concerns printing the options and prompting for input. This pollutes your . One function should only do one thing (SRP). 4) Your code lacks an overall structure If you take every point together, this should now be clear. 

That's a simple point to start, but as mentinoed, the resulting array is very dumb, i.e. you have no semantics about what is what. You end up with a simple array. 2) Another way is using named tuples 

So I could use directly a , read a line, and if necessary parse a line to an Integer. What is the advantage of a ? I could not think of one. In this case, I think, the whole idea is overengineered. It seems abstraction for the abstraction's sake. Besides: Reading the Documentation at Oracle, it says »StringTokenizer is a legacy class that is retained for compatibility reasons although its use is discouraged in new code. It is recommended that anyone seeking this functionality use the split method of String or the java.util.regex package instead.« 

is. Okay: A mapping of integer values to a treemap, which maps one string to another. Let's have a look deeper in the code: 

Where X is the result of a function: either div(h,5) or rem(h,5). So the next step is refactoring number,Symbol => output to number,Symbol, fn => output. You get 3 lines instead of 9. The only tricky part is the 5 minutes row You could go the road of abstraction one step further and make one single function for each line: f(emptyline, functionToFillLines)=>output 1) For seconds f('O', fillSeconds)=>output 2) For single minutes, single hours, five hours f('OOOO', fillFunction)=>output 3) For 5 minutes f('OOOOOOOOOOO', fill5minutes)=>output Where the fillX-Functions were closures, taking one argument as input. 

I do not like the fact of killing objects in the constructor. The job of a constructor is: to initialize the object in a sane state - not killing it for user's faults. There are two ways to prevent this: 1) Use a or a method, which refuse to initialize the Library with 2) Gracefully ignore the attempt to initialize with and initialize with an empty Besides: Throwing a in the constructor leads to ugly code, since you have to wrap the construction in an unnecessary --block. Don't do this - please! 2) Naming You could improve your naming a little bit: * should be renamed to just , since the contains all books. is a tautology. 

I think this is a hard one. First I tend towards Barry's point of view: You are really doing "two things" in your class. So, if you take the dictum of "reasons" to change to the letter, you are violating the . But on the other hand: I think breaking this up into a fibonacci-series-producing class and another summing-class is nonsensical. My personal interpretation of the is: "dealing with one topic". And when objects tend to grow too much, I have to decide, which functions are off-topic and need to be refactored in some way. If you want: I am advocating a more pragmatically - perhaps not really orthodox position. In your case that means, if I say "dealing with fibonacci numbers" is our topic and the resulting class results in two "subtopics" generating and summing that is a possible code smell, but more in the future than now. Don't forget: Those principles weren't developed for their own sake, they were developed with some purposes. And one of those purposes is maintainability. And as far as you code goes, I tend to say, it is still maintainable. One last word: If you really want to improve your code - get rid of the class at all. I see no reason, why one should write for such a job a class at all - except, perhaps, you are on the one hand obsessed with classes or on the other hand, for educational purposes. Two simple functions were sufficient. Python is a decent objectoriented language though, but sometimes it is overhead to write a class for everything. Python is not Java, where it is necessary to write explicit classes for everything. Python is not forcing you to do that. First take care of writing clean code. Later take care of your overall design. Start with naming. Barry pointed out, that you should name your functions more pythonic. Another point worth mentioning is your function naming in general. Function names should reveal their intention. So what is the intention of ? Reading this, withouht investigating your code, my answer is: I don't have any clue. I know there are fibonacci numbers involved and somehow there is a . How it is claculated: the heck, I do not know. On the other hand: clearly says, what it does: it sums up the fibonacci evens up to a paramter given. 

I would use some MV* library for this kind of task. Maybe you have a look at Backbone. A small library (about 7k in production) with lots of nice functionality for those kinds of tasks. 1) You have representing you data as a proper javascript object. Each model is instantiated with: 

This is nothing more, than: returning a list of the digits in descending order. A Java8 Solution would be: 

That indeed is a conflict. If the user wants to log in a hundred times: let him do that. Every time he does, he gets a valid token. End of story. If a user doesn't exist, return a and if the login failed return . That's why they were invented: to signal, that a ressource isn't there and you are unauthorized to do that operation, you wanted. And only, when there is something syntactically wrong with a request you should answer with . This is not about semantics. So, if I am asking you: »Do you live on the moon?« this is a syntactically correct question. Your answer »Can you repeat the question? - I did not understand, what you meant.« is misleading. That's why this 

If you read, what I wrote above, you understand, that this is misleading. You are branching on the condition and returning in both cases : That makes no sense at all. Although the request itself is , the answer should be a . The same goes for: 

Sorry, the specification makes me cry. How does this make sense in any way? Imagine someone going to a library, with a wizards hat on and a big staff: »Sort you, I, as your master, command you!«. 

The advantage: 1) your parameter shrunk to just one 2) if you name the properties (better than above) anybody else knows, what options were chosen. 

Besides: Your code looks a little bit messy. It's really hard, to get ones head around what you wrote. If you come again in 3 months i doubt, you understand anything you did above. Your naming of variables is not only poor (,,) but terribly misleading: 

It reads wrong: »Check, whether the book is an empty string!« That doesn't make any sense at all. And honestly: At first, I didn't get it, unless I saw, the . A better way of expressing this would be, adding a method to : 

In a more general case, I would implement a Push Down Automaton using a Stack and open parentheses on the stack and performing a for closing ones - Assuring, that the stack isn't empty. So every occuring closing parentheses has to match the last pushed open one. For simple cases, a counter is sufficient enough. 

Perhaps you could go one step further: Instead of iterating over each block, you could make use of the fact, that between each block is a delimiter ( in your case). So you could get blocks by simply chopping up the string with . This makes it possible to do a on the resulting blocks. You could refactor the inner for-loop out. 

Again: These are very poor specifications! Why on earth do you have to return a to signal, that there was no error, when the previous sentence clearly states, you have to throw an if anything goes wrong? And more: Who cares for a return-value? The only thing, which would make any sense, would be returning some kind of id in a persistence-context or for heavens sake the total number of books, but not a boolean. I am unhappy with that implementation. Of course, your has a -Method and you are checking if the book is literaly a blank book. But doing it this way: