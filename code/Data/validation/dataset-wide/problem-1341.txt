As you may have noticed in the code directly above, I use the DbResult class as a return type to carry the status message and bool back to the main program. I think this does not make sense since DbResult is a class created for returning results from trying to perform operations on the Database, not the SQL Server checkup. I could create a new class called ServiceResult, which does the exact same thing as DbResult, but that would be duplicating code. see example below: 

I have discovered, with thanks to you each, that it is better to call the display method within the DataAccess.ReadMethod() than to pass strings, Here's what I think i should do: 

I am asking this for coding style. I have a program class that calls a function(of a data access class) that reads from a table (using entity framework by the way), and I'm preparing to write the . Is it better to pass the function a 2d string array , reading each field and each row, and put it in the 's out parameter to return to the main program and have the main program display it? or just repeatedly call the and in the main program print each record out individually to the console? I imagine that my will look something like this: 

general impression overall the code looks clean and tidy so it is quite easy to follow some comments/suggestions MISRA and other coding practices recommend to always use compound statements after conditionals to make the code more clear and more foolproof for maintenance 

you also call twice, that seems unnecessary but I guess that is due to your unwillingness to have local variables. 

It seems unnecessary to have the macro when you could have just have written a define with the actual size 

is not a good name for a function, pick a name along the lines of {verb}{noun} to make it more clear what the function does. 

Lot of code but here are some comments. class Card Personally I put private parts of a class at the end of the class, those are implementation details. The public parts OTOH are more important for the user of the class. (IMHO) Use scoped enum for the card suit, as it is now you use char so any char can be accidentally assigned. assignValue assignValue depends on the order of when the member variable m_card was defined, it would be better to make it static and take as argument the card otherwise this can be an error source in the future. A std::map could have been used to hold the values of the cards e.g. map constructor you do not initialize all declared variables, std::string is initialized automatically to empty string but it is good nevertheless to show that you initialize it for clarity. one day you may change the type of the variable and forget to add it to the constructor nameCard you seem to have omitted the King. your switch sets a string for 0-3 but forgetting to call this function will forget to define that variable, you could instead make sure the card has a textual suit by defining it in the constructor same time you assign m_suite. again the mapping from value to some string could be held in a std::map both for suits and for the textual values like "Ace". that would make things like Deck::fillDeck smaller. Deck Use a smart pointer instead of a raw pointer to the cards, that you do not have to worry about memory leaks. 

I agree with @oopexpert that neither implementation looks particularly nice. I can see a few ways to improve this: 

If the ints are fact ordinals, you should maybe consider using an . If not, your current approach is fine. For , you could consider returning an instead of the value, null or throwing some exception. I've been using this pattern in my own enums. 

Several people are recommending to remove the final keyword from the private fields. I would strongly recommend against doing that. The whole point of the final keyword is to prevent accidental re-assignments to these fields from other methods in the class (private and public). So, if a Person is immutable, then all the fields in Person should be marked final. I actually have my IDE configured to automatically mark fields private on save. Immutability is a good thing to have unless you really want mutable state. Your builder does not need getters; remove them. I would not inject the builder into the Person constructor and keep the business of building in the builder. Instead inject the individual fields from the build method. This way, you can make the Person constructor public and use it without the builder as well and you stick to the principle that constructors should not do work (other than assigning arguments). Now regarding the getters on Person; if your fields are final, you might as well make them public and skip adding getter methods. Why type when you can just type ? The only reason to have getters at all is that is if you are depending on frameworks that still expect javabeans style getters with the naming conventions and verbose sillyness that comes with that. If that's not the case, don't add them. Some other things I would tweak are moving the Builder.build() method to . This will simplify the business of creating a Person builder and you won't need to type which looks a bit ugly to me. 

returns the same value regardless of what error occurs in the function, it is better to create an enum with various error codes so that the caller of the function can determine what went wrong and give a suitable error message. In the same manner remove the fprint-out in the function, let the caller worry about showing an error message based on the error code. 

Your pop function just removes the top most int, but normally one would like to get the value as well not only remove it. seems more natural. Your functions do not deliver any error codes to the caller instead you select to display error message with cout. It makes the class less versatile, instead you should let the user of your class handle the error messages and just return error code/throw exception. It is good to be consistent with {} for each if statement not switch between with and without e.g. 

you should check the return value of , it is not always successful. you need to deal with that event as well. e.g. reading many lines and with a memory that is fragmented may cause it to fail to find a large enough continuous memory block. also is an expensive function to call, it is better to allocate larger blocks than try to allocate several small blocks.