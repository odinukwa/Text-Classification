Doing the conversion once up front you can forget all the other int() conversions that clutter up your code. This includes removing the need for your mlistsub global entirely as far as I can tell as it seems to be an integer version of the listsub variable. I suspect the following reference to job[0] should reference job[1 ] as it is column1, not column0 that you talk about in other comments. 

OK, your code is a bit of a mess. I take it you are fairly new to python. Read the python style guide and stick to it. It will make it easier for people to read your code. It is not easy to work out what you are trying to do here. As it stands the code doesn't run. However, here are some thoughts. building on @Changaco's answer you can iterate through the file and process each row into integers like this. 

It's not strictly necessary to have the dice roll in the character class but that's how I've coded it. The method provides a nice way to present your character. e.g. 

Since you are deleting all your globals at the end of each loop, I am assuming you don't need them at all. 

If I understand your intent, you can also create a simple list and return it from the function as a way to remove the listsub global variable. 

A simple improvement is to use instead of multiple s. Taking out common statements in the each of statement. 

This also requires changes in HTML of elements on which event is bound. As can be seen from the code, custom attribute should be added with value as same class. Example, on this element adding custom attribute will be . This is required as there can be multiple classes on element and taking a particular class can be cumbersome or long trail. 

where - boolean can be passed to the function to open or close. There is no need to change the as zero-width elements are not visible. There is no need to iterate over multiple elements and bind the event individually. jQuery does that when working on selectors that selects multiple elements. 

As pointed out by Heslacher, you're repeating the code. The value of can be cached and used in following statements. To get the value of param value, use RegEx. You're using which will fail if there are other params followed by for example, . 

will join the array elements by , thus giving which is valid selector and can be passed to and any method defined on prototype can be called on it. 

Common attributes can also be added and selected using Attribute Equals Selector [name=”value”]. However, this can be slower than class selectors. 

It seems that you are looping through the entire job data set 3 times (once each for salaries, descriptions and titles). You will be able to speed this up three-fold, if you extract all the info in one pass: 

In python, the first thing you need to do with a recursive function, is to figure out a base case. Here, we want to keep going until we have k number of primes (or until k = 0), so that is our base case. Then we test to see if is prime or not. If it is, we add it to our growing list of my_primes. Then, we go to the next value to test (), we can reduce k by one (since we just added a new prime) and we continue to grow our list of my_primes by calling the modified: . Finally, if it happens that is not prime, we don't want to add anything to and all we want to do is test the next value of . This is what the last return statement does. It will only get this far if we still want more primes (i.e. k is not 0) or i wasn't prime. Why do I think this is more readable? The main thing is that I think it is good practice to separate out your logic. does one thing and one thing only, and it does the very thing it says it does - it tests a value. Similarly does exactly what it says it does too, it returns the first k primes. The really nice thing, is that this all boils down to one simple test: 

You have a problem in that your code fails when the strength of your characters is equal. The strength difference is zero and this is applied to each character at each encounter. If its zero then neither character is affected. Also, skill seems to have no effect on anything. I would expect it to modify the damage and/or the 'dice roll'. With that in mind, I would create a class for your character 

A simple csv.reader does the job for me. For each row, I pop off the username and then simply loop over the rest of the data in the row and yield it with the username. 

I would reduce the global variables to the absolute minimum (which is usually none). I cannot work out the detail but the only reason I can see to keep globals here would be if they are continually being appended to and this is not happening as far as I can tell. For example, I think the global variable a = [] can be removed. Your original function. 

This is not necessary if you return data from your functions as above and assign the result of the function calls to variables which are created in the scope of your new() function. As I say, I'm not sure what your doing exactly here so I can't advise on the logic. If you can tidy it up a bit then I'm sure we can help you get to the bottom of it. My feeling is that the code can become much shorter and much clearer than your current version. 

Default Parameters This will allow to use the assigned value to the parameter as default value if no value is passed when invoking the function. Now, ES5's default parameter notation 

Note that and in the diagram refer to respective capturing group. Demo on RegEx101 Although, this answer only explains about one RegEx, other RegExes can be modified in the similar way. 

RegEx vs which is same as (space followed by a star) matches zero or more occurrences of space. This is not flexible as it only allows users to use spaces. If user use tabs, this regex will fail. Use , which matches all the space characters. Quoting from $URL$ 

The code, is in both and block in all three functions. This can be moved outside of them. Also, I'll suggest to use instead of applying CSS explicitly as it is more expressive and easy to understand. 

What if I say you can avoid loop completely. Yes, you can avoid loop by letting jQuery do that for you. jQuery accepts multiple comma-separated selectors and internally iterate over each selector and perform operations. is an array of elements, this array elements can be joined with as glue, to create the selector. Let's say, we have an array and we want to add a class to all these selectors. We can iterate over the array and add the class to each element individually or we can combine the array elements somehow to create a comma-separated string and pass this to as selector. 

EDIT Added loadData(); slight tweak to return a dictionary of dictionaries, instead of a list of dictionaries: 

as you say, it does look like this code is doing exactly what you want. But it also looks like you are repeating yourself in a couple of places. If it was me, I would prefer to loop through the file only once and check for both and at the same time, and then only print out if the sample text is there: 

Other than the few things pointed out above, it might be 'cleaner' to use a helper function to test primality. For example: 

the rest just sets up the boundaries (i.e. the kth limit). So once you have seen a bit of recursion, you intuitively zoom in on the important lines and sort of 'ignore' the rest :) As a side note, there is a slight gotcha with using recursion in Python: Python has a recursion limit of 1,000 calls. So if you need to recurse on large numbers it will often fail. I love recursion, it is quite an elegant way to do things. But it might also be just as easy to do the function as an iterative function, or using a generator. 

There is more than likely a more elegant way to implement this using list comprehension. But conceptually, does this work for your needs? 

Line #1 is the prefix Line #2 will give Line #3 will add suffix to make the selector valid. With this, the code will be 

Adding quantifier also has positive effect on the number of steps taken to match characters when the characters in the character class are consecutive/adjacent to each other. Here's the demo on RegEx101, without quantifierScreenshot and with quantifierscreenshot applied on the same data. Note that in these demos, PHP is selected as the steps taken to match is not shown for JavaScript. Also, the regex is different, it also contains lowercase counterparts of those special characters as flag is not working with PHP and don't want to apply (Unicode) flag as it is not supported in JavaScript. These demos are created only to show difference when is applied on character class. The effect should be similar in JavaScript. Note that the (two underscores) are redundant as is already added in character class and with flag it'll remove all occurrences. Method Chaining As returns a string, any other string method can be called on it. Multiple calls to can be chained. 

Remove some class from some elements Toggle some class on clicked element Hide some element Toggle some element depending on a condition 

The advantage of this method is that you can use any selector. For example, if you want to use class selector for one of the checkboxes, just use as the selector in mappings and it will work.