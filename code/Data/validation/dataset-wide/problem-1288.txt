The word sounds like your taking an iterable of some sort and summing all the values in it. would be a better name. Even then, I would expect to return all possible pairings, which the code doesn't currently do. 

It appears that you are using across multiple threads. I guess you plan to replace it in the future, but still, according to the documentation: 

Small syntactical changes should at least be . Some would probably argue that you should spell out and entirely. I personally like small names, but regardless, the capital should not be there. You wrote this one time: 

Although you should comment your work, some of your comments seem unecessary. Let's look at some lines to see why: 

Or something along those lines. Furthermore, once you have done this, is only called once in your entire code. I would just get rid of all together and just call . 

Also, add some spaces in between your function declarations, it's hard to read when everything is clumped together. But don't over do it (in particular, don't double space everything). 

returns the result of rolling two dice. Be sure to not say that it is the sum of two random numbers. Provide the context for doing that. Explain the rules of craps inside of the function (in the docstring). 

What does mean? You proceed to use it to determine the level (i.e. ) but it is not clear from the name (or even the method you use) that that is what does. Java 8 now supports - statements for strings. You may eventually want to refactor this into some sort of "difficulty" , but for now, I would change the level select to a switch case instead of - chain. See this answer for the syntax. 

Just use . You don't use , ... that often, I would just use to save space. Although there are many reasons not to make code as terse as possible, adding lots of these variable declarations makes your code hard to read. 

These are just some basic nits and optimizations. Other than that, I don't see any major glaring errors. Happy coding! Python Experience: LEVEL UP! 

Comments about the code are appreciated and welcome, but I have a few specific questions about best practices with regards to using Mongoose. 

As mentioned in other answers, list comprehension is the fastest way to solve this. However, I'd just like to point out that you should also consider using a generator function if it suits your needs to prevent the need to load the entire dataset. 

This comment doesn't really add much value. Enclose your main code using an guard. Avoid putting it in the global scope. 

You're asking for elegance and conciseness. Elegance doesn't always mean short/hackish, and neither does conciseness. You should never sacrifice readability for brevity unless you're codegolfing. As per your comment, just because you can read it doesn't mean the next maintainer or developer can. Someone (maybe you) revisiting this in 5 years should know what the code does without having to pick through it. Let's start by breaking apart the code into its components. 

Prefixing with an underscore is generally a developer convention in Python indicating that the method is private. Given the context of your function, I don't think you intend for your code to be a module whose functions are imported and used elsewhere. Having the underscore prefix seems unnecessary to me. Too much abstraction? 

One important thing here is that you should put the game logic inside an guard. This prevents the logic inside from being exposed globally. This method of organization is just one way to do it. Of course, there are other ways to organize your game that make sense, but in general you should group together similar things and prevent circular dependencies. Avoid accessing member variables directly. 

and I am guaranteed that the objects are already sorted chronologically by . I'm sure that this code can be vastly improved. 

Avoid using . Try to have your program exit normally. You can just set a condition in your loop. Comments should not state the obvious. Use comments to document things like complex algorithms. 

Then, you could implement all of your command-driven printers using that same base class, like this: 

The reason that the first example would be considered problematic when multiple threads are involved, is because in that example, a object maintains state (i.e. data) and it has methods that act upon that state. There's nothing wrong with designing classes that way, per se, and it doesn't mean that the class cannot be used by multi-threaded applications safely--it just makes multi-threading more difficult. For instance, consider this example: 

When you think about it, it makes perfect logical sense. In the real world, you'd never even think of designing a car that creates it's own engine--that would be a nightmare. You of course would build a factory which would create both the car and then engine, and then put the engine into the car (inject it). The equivalent in code, would be to create a factory class, like this: 

Simply put, from an idealistic standpoint, fancy-pants code is always better than cowboy code, but from a practical standpoint, fancy-pants code can sometimes be much worse. So, as a general rule-of-thumb, I would say that you should always fancy-pants-code unless you have a good reason not to do so, and you should accept that there are some very good reasons not to do so, sometimes. I have a lot of experience with this, and I can tell you, designing code well up-front, is WELL worth the effort. It's true, as you said, that good design has more up-front cost, and poor design has more back-end cost, but to say that the two are equivalent, because of that, is fallacious. It all depends how much back-end work will need to be done. As you say, a simple statement isn't really that bad, and if adding more statements to the statement is the worst of the back-end cost that you are going to incur, then it's really not worth the time to add a bunch of complication to avoid something as trivial as that. But if the project grows and changes over the years, a little shortcut like that, to save a few hours of development time, could potentially cost months of development time in the long run. It all depends. Another issue which often muddies the water is that not all fancy designs are actually good designs. You could develop the most impressive fancy code in the world, but if it doesn't actually solve any problems, such as making the code more stable, flexible, or maintainable, then you've actually made the problem worse by all your fanciness. As much as I am a believer of good design, I am also a strong believer in the YAGNI principle. If you haven't read the wikipedia page on YAGNI, I'd strongly recommend it. YAGNI simply means "You aint gonna need it". Simply put, don't add features and complication that you don't currently need. YAGNI does not preclude good design, but it does preclude unnecessary fanciness. Again, the issue isn't whether or not the design is fancy, it's whether or not the design is good. A good design will follow the YAGNI principle. It is definitely possible to "over-design" something. All that being said, if there is no good reason to cowboy-code on this one, as it sounds like their might not be, allow me to offer my perspective on what a good fancy design might look like. My way is by no means the only right way, but hopefully it will be helpful to you. I'd like to think that my fancy way of doing it does solve a lot of future problems and would therefore be worth the relatively small up-front cost. My Way to Do It (Dependency-Injection) Your first instinct was to think that the Factory Pattern would be a good solution to this problem. That was a good instinct, but I don't think it quite goes far enough. Dependency-Injection (DI), which relies heavily on factories, is perfectly suited to this type of problem. Personally, I think it is well-suited for almost all problems, but there are certain problems, like this one, which just scream dependency-injection. In general, the principle of DI is that a class never creates it's own dependencies. So, for instance, if you have a class, and it needs an object, you wouldn't have the class create its own object. Instead, you would have the class request that the (it's dependency) be given to it (injected), usually in its constructor. For example, rather than having something like this: 

Refer here for the definition of a balanced binary tree. If you don't like having two return values, you can always refactor and write a separate function to get the height of a tree. This would allow you to implement it without having to return two values and would improve the readability of your code as well. This is the suggested way to do it. I would say avoid raising exceptions unless you're certain you know you want to. You should never raise an exception if you don't have to. 

If you want, you can always refactor functions like so that you type less. Something that I see a lot of people do is: 

Anything involving styles should probably be in an external CSS stylesheet. You can paste your HTML into the question and make a runnable snippet so that we can try out your application. 

Concatenating the address and postcode seems arbitrary to me, if you did the refactoring as mentioned above, you could shorten it to: 

You could probably put that in a helper function somewhere. Have you considered using an XML parser to tokenize this? Or using the native JS DOM to store your generated HTML? 

Consider using a style guideline like PEP8. This is more of a general suggestion and will make your future code much more readable and maintainable. Consider defining all your constants at the top of the file. This makes them easier to find. In other languages, you cannot use a variable before you define it, so this is a good habit to get used to as well. Python is a self-documenting language. Generally, in Python and other languages, comments should not be used to state the obvious. Use comments to explain algorithms or non-trivial aspects of the code. 

This one is a little subjective. For an algorithm like this, it makes sense to only write pure functions as that can make debugging easier. Your code is readable and clear, if a little contrived, but I wouldn't worry too much about this. JavaScript is sort of a weird language to ask this about since most functions won't follow this rule especially when you do DOM manipulation and frontend JavaScript. 

The beauty here is, you are free to implement these printer classes however you want. If some of them all work very similarly internally, you could create a base class for them that those classes derive from. But if you need to make a new printer class, sometime in the future, which doesn't work the same way at all, you're free to implement it anyway you want. As long as it implements the interface, that's all that matters. It doesn't matter what class it derives from, how it works, what namespace it exists in, or even what library it comes from. So, for instance, if you do have a bunch of printers that all work by sending the same kinds of basic commands, you could create a base class, like this: 

By synchronously locking on the object, if a second thread tries to call at the same time, the second thread's execution will be blocked (i.e. hung) until the first thread's call to is complete. The problem with this approach is that, at least to some extent, it defeats the purpose of multi-threading because only one thread can do that part of the work at a time. The second way to fix this would be to have each thread create a new object so that they don't interfere with each other. For instance, instead of having the object declared as a class-level field, you could just create a new object inside the method, like this: 

By doing it that way, you only need the single statement. Another side benefit is that you can now store the list of valid combinations somewhere else, outside of your code, such as in a configuration file or a database. Then you could load the data from that data source into the dictionary at run-time. 

As you can see, that would certainly be undesired behavior. There are three ways to fix this problem. The first way is to use one of the available synchronization techniques to make sure that only one thread uses the object at a time, for instance: