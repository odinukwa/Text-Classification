If you follow suggestion above about injecting dependencies (including content) at point of instantiation, then perhaps this simply looks like: 

I would strongly encourage you to familiarize yourself with PHP's and related classes. They are much more powerful in working with date manipulation than the old procedural functions. This can eliminate large portions of your script where you are doing things like manually building date arrays and finding first days of months and such. 

You can often use in your queries to help you simplify how you read data from multi-table queries into multi-dimensional data structures. 

You are not using at all in determining your offset for the LIMIT clause, so your pagination is not really working. 

I would suggest that, as you are looking to implement your code around session management, you would think about it more globally. Having several lines of procedural code to manage session logout, rather than a method on a class that provides methods to manage sessions, limits re-use of this code. Why should you need to route a user to a specific URL to log them out as opposed to just having ability to do something like from anywhere in your application, with that method basically doing what is in your code now? Perhaps take a look at existing libraries to see if they meet you needs (for example something like $URL$ 

I don't like the mix of in one case, having this method abstract and in the other having a concrete method. I would think you should either provide standard implementation of both or neither. I honestly think you can probably generalize implementation in the abstract class with something like . Your current concrete implementations seem like a lot of code for little value. 

In class B, I don't understand declarations throughout. Using is generally a PHP coding anti-pattern that should be removed from the code. It seems as if the intent here is to access the class properties, which should be done using . 

In method you have a lot of validation that might best be moved into , or similar methods. You may consider regex as part of your validation methodology, to more concisely cover your validation cases. You are also missing some other cases around allowable config key names (i.e. reserved words as noted in documentation) that you may want to include as part of validation so as to avoid unexpected behavior. You could reuse these validations elsewhere (like on get/set key/entry methods). 

Should your method actually be broken up into and methods? I would think that a programmer should be explicit about what they are expecting to happen here. And you should not ever let the class get set up to where id would be empty if the record has been persisted to the database. 

This may or may not be trivial to compile this into your percentage results in your application layer depending on how many unique id values you have. You could potentially make it even easier by using clause in your (see $URL$ for more info). That query might look like this: 

You may consider passing DateTime object to this method instead of just a string. That gives you the ability to enforce the parameter type via typehint. As it stands right now, you have nothing here to validate that a proper string format is passed. There is no reason to twice here. Just explode once and work with the resulting array. If wanting to work with concrete objects this logic should be in the constructor so that you can enforce that the object gets set up in proper state. How does this method handle AM/PM? Is it using 24 hour clock? Your test data only reflect values < 12:00, it seems as if you are missing coverage here. 

You are duplicating work in your function and in making your database inserts. Consider a method like . To both validate the images and read them into an array that can be used directly in code shown above (i.e. removing need to recalculate file location on server), or provide result on validation error. So perhaps a usage pattern like this: 

The primary performance problem you have is that you have fallen into the anti-pattern of querying in loops. It looks like what you are doing is some sort of data migration. The chances are that this whole thing can be done based on a few queries. For example, let's look at using syntax to simplify this operation. To do this, let's assume that the email address / password combination from the source table is the main thing you are concerned about here. And let's also assume that your table is the primary table you are going to be migrating the data into Let's start with this. 

If header and footer are always going to be first and last line as might be indicated from your example, should these even be in the same template structure? You could just as easily have and variables defined for those use cases. You could also address the header and footer case outside the loop to avoid the unnecessary if nesting in loop. i.e. 

I wonder if what you are really getting at is a dependency injection framework. It seems that you want to be able to instantiate authoritative dependencies which can be pass around your application. Rather than implementing an abstract singleton class which all your concrete classes inherit (something that would be VERY limiting to your design flexibility due to PHP only having single inheritiance), perhaps you look at dependency injection frameworks or patterns to do what your want. Or perhaps you have class structures like: 

In class A, why store both an instance of the class and an instance of PDO? If you really wanted to stick with singleton I would simplify this down to something like: 

In your document, you should call the field or similar to be clear about exactly what is stored there. 

You should have already validated this input before ever getting to the point of trying to make inserts in the database. Reference earlier notes on data validation. 

This approach would limit the repeat code you have for each transformation string and would also take care of your concern in that only those transformation types specified in the config would be executed. This also more directly injects the transformation configuration information into the function that generates the strings, meaning you no longer have to rely on variables that may or may not be present in inherited scope. This means you could now have your function declared in a wholly separate include file from the code where the actual transformation(s) values are generated, promoting code re-use. Since you are using ECMA6, I would also consider building this as a class (or classes). Finally, from a stylistic standpoint, I would recommend sticking with camelCase instead of snake_case, as this is pretty much the de facto standard for javascript. At a minimum, don't intermingle the two. Additionally, I would suggest watching your line length. You should strive to keep lines of code under ~80 characters per line to improve code readability. 

Since this is part of a parsing class, should you perhaps set the templates on the class (with appropriate validation in doing so) before going about parsing input? Should you pass template(s) to constructor? (Just thinking out loud here in that I don't know the call pattern you are imagining in your application against this class.) If your call pattern is such that you will be parsing multiple files against multiple templates within any single script execution, then I wonder whether this parser makes sense to be a concrete class at all, since for this use case you would not ever seem to be maintaining state in this class (you are always passing your dependencies to this parse method, meaning it might as well be static). The only "state" this class has is with regards to the error property, which is pretty much used in a stateless manner. You directly return the value from method immediately after setting this state in the only place in the class this property is set. Why do you need and corresponding setter at all if this is the only way it is being used? 

Or maybe, if you find that to be too much code in a single class, split out the ini file read/write functionality into a class or trait that is injected or composed into the ini management class for its use - not as a base class to be extended upon. I thing I like to suggest when making decisions about using composition vs. inheritance is - "what makes most sense in the real world?" In real world terms, is an INI configuration manager an "extension" of file systems operations, or does it really just need to be given the ability to operate against the file system to perform it's job. If the former, inheritance is likely the best answer, if the latter (which I believe to be the case here), then composition is likely your best bet. Now, let me talk about static vs. concrete, as I don't really understand why you have a static class that does exactly the same thing as the concrete class. Sure you may have different application contexts, which may need to operate against INI configuration data in different ways and your application may need to operate against multiple such files. I like that you are thinking about how an application might need to work with data from a number of these files in different contexts. But, let me ask you, why do both the static class AND the concrete class BOTH need to deal with all of these potential use cases? Let's think about what a meaningful concretion truly is. I would suggest that the concrete object really only has meaning as a 1:1 representation of a single ini file (which seems to be the intent of the design). So why would it need a method? Would you not just pass it its file dependency in the constructor? Why would it need a method that takes file information as an argument? Shouldn't it already know the file it is associated with? (If this is to be able to rename/move or copy the file, perhaps there should be separate methods for that.) On the flip side, from a static context, why do you need to do individual file level operations in that context? Your use of should be a strong indicator to you that you are really working with a concrete instance of an ini file object. From a static context, perhaps it really only makes sense to specify files to be loaded via a method like and then return concrete ini objects you can operate against. I suppose you could make individual file-level changes statically, but just be honest about what is really happening, you are providing a static convenience method with really instantiates an ini file object to operate against. As such, I would suggest that you either just provide a static method on the concrete class which can be used to instantiate an ini config object, or if you find yourself truly wanting to expose more static functionality, than have a separate static class that focuses on instantiating or working with concrete ini objects, not on also being an object. Think of the difference between a library and a book in real-world terms. That is analogous to what you are dealing with here. Your library (static class) may provide means for you to find a book (ini config object), check out a book, or even get excerpts from a book (in an electronic sense). But it doesn't need to have all the methods and properties that a book has. Similarly, an individual book doesn't need to know how to find other books in the library. Here you have built two classes that do the same thing and I would challenge you to rethink that approach. 

I question the whole persistence model. Rather than explore ways to write code to work around what looks to be a bad data storage model, I would think about how you can best persist the data in an appropriate manner such that it can be read into your application without an intervening layer of regex-based data mapping. 

I am concerned with the whole approach in comparing $_POST['pass'] against some stored password variable (I am assuming this is defined in the include file). Does this mean you have a single password that, if compromised, gives any user of the system the ability to modify any record? This seems like a poor security strategy, not to mention the apparent plain text nature of this as already noted. You should like have a separate user authentication/authorization mechanism rather having a single password passed at the time of especially since I am seeing nothing in your .htaccess or code (maybe this is in include) that is forcing HTTPS protocol to be used. 

The answer provided by @ThijsRiezebeek gives really good information about moving your class towards using a singleton pattern. Since you mentioned dependency injection (though you are not currently using it), I figured I would provide some commentary more geared towards that approach, which many people would prefer over using something like singleton (especially in complex applications). With dependency injection, you have to really embrace a different approach with regards to how you deal with dependencies. Rather than having calling code or classes need to instantiate or create their dependencies (for example a database connection), you look to instead make the dependency available to the code that needs it as part of the executing that section of code. Take for example a class that needs a database object to interact with the database to do something like interact with a user record. An approach that does not use dependency injection may need to instantiate the database object itself in a constructor. Let's give an example that utilizes a singleton to provide the DB object.