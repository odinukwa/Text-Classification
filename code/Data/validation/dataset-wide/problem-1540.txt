Here where you check to see if form is valid, you do nothing other than return false. How to you perform user messaging as to the validation failure? 

Don't have functions declared arbitrarily in the middle of your code unless their might be some conditional declaration of the function (that doesn't seem to be the case here). 

Putting aside the problems noted above around LEFT JOINS and null. I would suggest that you consider working with each row of your results set as an object. IMO, this can make your code a lot cleaner and, in most cases, actually more truly represents what you are working with (an object representation retrieved from DB). Taking this approach, as well as taking the approach noted on using numerically-indexed arrays for contact groups, contacts, and phone numbers, you might end up with something more like this: 

The class does not seem to consider a GET request. Would there ever be parameters passed in URI on GET? If parametric data will only be passed in URI, then perhaps you need to validaate that the URI does not contain or 

By doing this, you guarantee that all dependencies are met and you can totally eliminate all your setters. This makes code to instantiate this object much cleaner and more foolproof as well, as it is way easier for someone to see all dependencies you need to pass an object while working in an IDE via code completion and method signatures than it is for a coder to have to know that they have to not only instantiate an object, but also call methods a, b, c, d, e, etc. on it to get it set up in a proper state. 

This makes complex queries much easier to read. Don't be afraid to write the query into a variable (rather use directly in ) if this makes your code more readable. And even be consistent in your formatting within query. Your field aliasing seems arbitrary. You sometimes use uppercase for and sometimes don't (I would actually recommend uppercase for everything in query except database objects, columns names, and aliases which you generally seem to be doing). 

Why would you call this variable when it does not contain JSON, but rather a data structure resulting from JSON deserialization? Call the variable something that is meaningful to what it is actually storing. What if fails (i.e. server sent you something that is improperly formatted)? 

So ideally, your application should be able to seamlessly handle both without custom code that changes based on where you deploy the application. Typically, this is done by configuring constants for file paths in a config file, not by relying on values derived from as this has absolutely no connection to where on a server you may have the ability to place your non-public application code. You may be able to count on this behavior for some specific shared host environment, but this gives you no guarantee that this same behavior would exist in another environment. So an approach of defining path constants may look like: 

You can get to the point of making the (relatively) expensive database query even if an empty string is passed to the method. You should get in the habit of failing early and failing loudly if your methods get passed bad data. This makes your application easier to maintain / debug. 

If you should consider incorporating style checks into your static code analysis such that you can automatically flag style issues like lines of code that are too long (typically ~80 characters). 

Consider renaming your file input fields to (note that array notation). That will allow you to access all your values like an array, allowing you to simplify your code. I will also take the addvantage of the fact that binds the a variable to a parameter not a value, meaning you don't need to rewrite these lines of code repeatedly. For example, 

These could all be broken out into classes that handle this responsibility. Consider something like: 

First I think that you need to reconcile your use of session vs. cookie. In your answer you explain technically what is happening in your code, but not what the overall user experience requirement is. You need to match your usage of cookies vs. sessions vs. HTML local storage (though not used here), which are all means to convey application state to what the actual user experience needs of the application are. Does the cookie represent a default user preference? If so, then should you be overriding it when the user passes parameters or otherwise changes mode setting in a session only context? Why use session at all if you are always going to set a new "mode" cookie which overrides whatever is in session and there is not a session-specific override context? Most likely you are propagating session ID by cookie anyway, so if user deletes cookies, you are going to lose state anyway. If for example you remove session from the equation altogether, you may get something like: 

I don't understand why you have method or have it exposed statically. Do you really need a method to build an array? Why is this not just done in . i.e. 

Since you are, in essence, building out a class, I would think you should consider implementing your various properties and methods in more "class-like" manner (not necessarily ES6 type classes, but something ES5 compatible like I have shown below). This would allow for higher level of re-use for your Quiz class (i.e. multiple quizzes on same page) and allow for optimized performance of methods (because they exist on prototype rather than on the instance itself). 

I would consider asynchronously checking for all 5 potential files at once, meaning that checks can be paralellized. Once all are complete, you can evaluate the compiled results and return the most recent file. Depending on your expected call pattern ( for example, are more recent files typically the ones being requested?), you may consider keeping a cached copy of all or part of the file listings in memory to avoid disk read altogether. Another thing you may really want to think about is your API interface. I would find it extremely hard to understand that a request for a file that may not actually exist would return a 200 result. This would be very non-standard from a REST API standpoint. Perhaps the client calling this service should own the logic of checking for 5 daysâ€™ worth of results. Why all the weird formatting steps from Date object? Just output directly to your desired format instead of chaining together a bunch of string manipulation. If file is already JSON format, why parse it and then reserialize when delivering response? Had you consider serving these files statically? You could GREATLY simplify this code (down to literally two or three lines by serving these files statically and letting caller own the logic of looking for days in the past. Not to mention. You can get all the serve static behaviors around cache-control, etags, etc. this way if cacheability matters to your client.