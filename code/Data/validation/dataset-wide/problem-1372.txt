is the C++ equivalent of Java's TreeMap. It's big (it stores about three pointers per node) and slow (lookups require following of those pointers on average, and inserts can require rebalancing of the red-black tree, thus touching even more pointers) and therefore cache-unfriendly (a single tree lookup can dirty up to cache lines, none of which will be helpful for the next tree lookup) and therefore even slower. And you're not just using one — you're using one per node in your trie, i.e., you're making a big pointer-based tree of big pointer-based trees. This is just absolutely awful for performance. So yes, an array would probably be preferable. Or it might be worth the effort to abstract out a data type like 

I would say that you've got a case of "solution in search of a problem" here — and your solutions are mostly faulty! 

I haven't even really dug into the lock-free parts of this code, except to point out that all your spinlocks are broken. I suspect that the lock-free parts have approximately the same density of bugs as the main code, which is to say, they don't work at all. One way you could help people review this code — including help yourself review it! — would be to split the code clearly into "deep magic" and "boilerplate" parts. Right now, you've got deep-magic code like living right next to boilerplate code like , deep-magic living right next to boilerplate , and so on. It's really hard to figure out what exactly is the "core" of primitive deep-magic operations that needs attention, and what is the higher-level boilerplate. Of course another way to make the code more reviewable (and more correct) would be to rip out much of the boilerplate. For example, you have five different overloads of and one of ; I contend that for your purposes you only need . That'd save you about 40 lines of code, and save you at least the one bug I pointed out in already. 

You should always use whenever you're manipulating mutex locks. Your manual mutex-fiddling here will cause a deadlock whenever 's copy-constructor throws. 

Seems short enough to me. It's impossible to know how to refactor any code without first knowing what it is supposed to do. All we know about this no-op function is that you "want [to] exclude several type[s] like void or char". How many types? Which types? Why? 

In , I don't really understand why you're yielding at the bottom of the loop and then reloading the value of at the top of the loop. The only way the CAS operation could have failed is if someone else snuck in and changed the value of very recently, and if that happens, I would think that the last thing you'd want to do would be to yield and allow further threads to sneak in! I'd rather loop around as fast as possible, using the new value that I just got from the CAS, and try modifying again as quickly as possible. IOW, I'd do this instead: 

Yes, there are better ways. They come from functional programming. Try to adhere to the idea of "one concept, one name" as much as possible. For example, on the penultimate line above, you use the name to mean both "the ciphertext character" and "the of the ciphertext character". Don't do that. Instead, use a new name for the new concept " of the ciphertext character"; for example, . 

Next, a style/safety note: For metaprogramming, you don't need to provide full definitions (i.e. class bodies) for your types; a declaration is usually all you need. Furthermore, providing just the declarations will prevent the user from accidentally trying to define variables of those types. So, for example, you should write 

Did you know that you can use the name of the template itself as a class-name inside the definition of the template? That is, you could just use in all the places you're currently using , and the compiler would know that you're talking about . In any event, probably shouldn't be a public member typedef, should it? 

More importantly, what is this function doing? Its name suggests that it should be returning : either you or you , right? What's the point of returning an integer? Reading the code of the function makes it clear that the function is definitely misnamed... but I can't figure out what its name is supposed to be. Also, you return the magic value to signal failure, and then in the caller you test for with . It would be much much simpler and easier to reason about if you returned on failure and tested for . (It might also be just a hair faster.) 

Use source control, such as or ; then your test for "editing accidents" can just be "is the source code up to date". If you're worried about editing accidents in the past, take a look at the history of the source file. 

I was as surprised as @chux that actually popped an element from the queue. I would expect the pop function to be named, well, ! Also, it would be nice to document explicitly in the API whether the "pop" operation (currently misnamed "top") pops the smallest element or the biggest element. You could do this in either of two ways: 

Again I may be exposing my own lack of knowledge, but I'm about 75% sure that cannot possibly throw an exception. What case are you worried about here? 

Noooo. This is a misuse of 's constructor (trying to create a brand-new to manage an object that is already managed), and will lead to double-free bugs or worse. What you meant was to cast the existing smart pointer to your desired smart pointer type: 

However, this assumes that your objects will basically only ever be allocated on the heap, via or the like. You'd pretty much have to commit to the idea that at least in this part of your codebase, you'll be doing a lot of reference-counting and heap-allocating. (In exchange, you'll be 100% free of memory leaks and dangling pointers. It might be worth the tradeoff.) 

I have to keep in mind while reading your code that and are different types (despite being spelled the same). That's a good design choice for the user of your library, but it's a terrible design choice for the reader of your library. Therefore, IMO you should create a new name for your type in this file, e.g. ; and then at the very end of the file you should introduce . That way you get the best of both worlds: the user gets two things with the same name, and the library reader gets distinct names for distinct concepts. 

You should know that in basically all curly-brace languages, can be rewritten as . In C++, operators can be overloaded; including the prefix and postfix operators. The prefix version means "increment my value and return me"; the postfix version means "copy me, increment my value, and return the copy." Therefore, in general prefix will perform fewer operations and be more optimizable than postfix (and the same goes for ). It certainly won't matter for primitive types like , but if you get in the habit of writing in general, then you'll never have to stop and think about this issue ever again. Result: 

(1) Style nit: Prefer to fragile -based include guards. isn't yet part of the standard; but any compiler that supports C++11 will definitely have supported for years already. (2) Obviously, remove the usage from your constructors when using this class for real. :) (3) This is a MAJOR issue, and a common one, which is why I want to make a big deal of it: 

is , which is to say . That's too many futures! So I was trying to work around this by calling right before returning the "inner" future. Turns out that and (in the Concurrency TS) already have a solution for this problem. It's called , and the idea is that if is , then is . In Boost's case, this is currently provided as a constructor instead of as an member function, but there's a bug open to provide directly. In the Concurrency TS, also implicitly calls on the callback's return value if that return value is seen to be of type . So my solution was simply to add a call to (well, the Boost explicit constructor), and then everything was happy. 

In C++11, we need to use the "trailing " trick to get the compiler to accept that code, since C++11 can't deduce return types (except in lambdas). 

Much cleaner! And a tiny bit faster in the case that you call multiple times, because you don't have to check anymore. (And much slower in the case that you construct a object and never call the method — but why on earth would you construct this single-purpose object if you're never going to use it?) 

Another late-breaking comment that I forgot to write down last time: The use of the suffix disturbs me. I'm familiar with and (and I've had occasion to use on MSVC, which supports constexpr inline functions but not constexpr inline variables), but confused me until I saw that you were using it to mean literally "this template takes an additional parameter named ". That's not a good reason to use a single-character suffix like that. glibc also uses to mean "reentrant-safe", as in and . If you collapse the versions into the two-argument versions as I suggest in the previous point, then you won't need to worry about naming the versions, so you solve two problems at once. :) 

A cool thing about delta swaps — besides how efficient they are — is that to get the inverse permutation (a.k.a. "rotate left around x axis"), all you have to do is invert the order of the swaps! (Swaps that don't interact with each other don't have to be inverted. I found it aesthetically pleasing to keep such swaps in decreasing order of shift value.) 

You certainly can reinvent-the-wheel of while you're at it, but you don't need to reinvent it. The standard one will probably be faster than your thing. 

Your indentation here is wonky. Which reminds me, for style tips, you should run the whole thing through a linter such as . The linter will catch all your weird indentation and such, and even sometimes tell you how to fix it. 

Looks reasonable to me. The efficiency of this code really depends on your expected workload. For example, if you're expecting to use this code with a lot of strings of length 50 to 60, and you don't mind wasting a bit of memory in the case that the strings are shorter, then you could probably avoid a in the common case by writing 

A list of 6542 primes is not necessarily "bloat". At 20 primes per line, that's 328 LOC (lines of code) with zero complexity, compared to what you ended up writing, which took only 62 LOC but has relatively high computational complexity and dependencies on the filesystem, heap allocation, and so on. 

and if you really want to get fancy and eliminate even the move-construction, you might use perfect forwarding: 

The next step is to implement one's own priority_queue, implementing not just and but also , since that operation is the bottleneck for this (and many other) algorithms. 

I'm not sure what you're asking here. Obviously the first version is fine; obviously the second version is pretty silly (because it does the same thing as the first version but in a more confusing and verbose way). As for "using indexing", doesn't the first version also use indexing? What do you think is, if not "indexing"? It sure seems like you've got the hang of "indexing" well enough. :) 

Or if you're really worried about holding the mutex for some reason, then check again after taking the lock but before going to sleep: 

If the string in is , this copies 5 characters into : namely, . You never copy the terminating byte! So you've allocated 6 bytes, but initialized only 5 of them; you don't have a null-terminated string, and is going to blow up when you get to it. is NEVER EVER EVER appropriate. Treat it the same way you would treat : it is not in the vocabulary of an educated programmer. (And the same goes for .) Show me any code that uses , and I will show you bug-riddled code. The function you want here is the standard function for copying strings; it's spelled . (If you don't care about 100% ISO-compliance and don't care about any memory allocator but , save yourself another minor hassle by using . But do not use ; it is never appropriate.)