I like your solution as well. The only thing I might consider doing differently is making input a private instance variable which would mean all your input parameter requirements to the methods would no longer be required. Something like: 

In response to your "I still feel there's a better way of handling this than the switch" sometimes when I see switches I think polymorphism and is there a way to handle this via OOP. I typically don't do anything about it but at times it's hinting that I have a problem in my design and I should think a bit more deeper to put the necessary abstractions in place etc In your case, although this might be needless complexity you could change your enum into a class hierachy of Urgencies. Maybe something like. 

What about creating new classes that use the existing static methods rather than extending existing code. That way you will not need to worry about breaking existing code or adding duplicate method calls onto existing? One thing I would say for certain is to stay away from a property name being the same as the class name. Name it something different at least. Even just Helper is better than HelperClass (although probably not much). Something alot along the lines you mentioned but very slight differences: 

} A great thing about writing unit tests is that it can sometimes ensure you think about your requirements before you even code and so help cover everything. In this case I was writing some unit tests for the method and it occured to me that the code might not cover the case of empty strings. I created the test and hello, it had worked. That was great. Now I also have a test! And not only that, doing a couple of other tests showed some flaws in my code which meant I identified problems with tests. Awesome! 

I quite like the concept. The only thing that stands out for me initially is that I would probably leave the wrapping methods the same as their wrapped name. i.e. 

I'm not really any good at algorithms as such so my main suggestion would be to remove duplicate code. That is primarily in the creation of your pPairHigh and oPairHigh blocks of code. I admit they do share a common loop which in my implementation means this will be occurring twice. If this is an issue in performance it could be broken out so the pairs are created like you have done in a single loop. But I would still call a method to do the actual creation. However I'm working on the assumption performance is not really an issue, here is my suggestions. 

I quite like the idea when implementing error handlers to do stuff through an interface to remove any dependencies on modules. Sometimes I've used that in conjunction with a global static Log method. I've typically done this in c# but the theory is the same across to Java I believe. So how about something like this? 

Making use of built in functionality In .NET (and most languages I guess) you do not have to explicity compare a variable to it's boolean representation. So in .NET you could change this line 

One thing I was tossing up was whether to switch the order of the if statements in the Execute method to have the normal flow go though the commitchanges method. Not really sure though. Something like: 

I would personally separate the method as like Mark said it's having side effects as well as doing more than one thing. Based on your code provided maybe something like this. Each method hopefully does one thing and the Execute uses these as required: 

Here's a crack at a bit of code. It's probably worth mentioning though that I don't think your code could even compile or if it does your missing variables i.e. itoy_tmp5... Either way, like Robert said I looked for some patterns that seemed to be repeating and started from there. I extracted the first part to a method and then extracted again etc etc Here's the code anyway if it helps. 

ViewModel.Save() I'm not a huge fan of having the viewmodel responsible for calling the model to persist the data. I'm not sure where you could move this to as I haven't looked at the rest of the code but I would typically put that call in the controller and use a mapping layer to copy the properties from ViewModel to model. My main reason is that it seems to violate the boundary between the viewmodel and model in that now viewmodels know about models. I tend to prefer the level of dependency direction going toward a ViewModel not away from it i.e. View => ViewModel, Controller => ViewModel 

This means that you could create the SMTP client on Emailer creation and then dispose it as necessary. In this case the code might look like 

I would probably point out that these methods would probably be in different classes. For example the Update, Insert and/or Get might be in some sort of repository class. The CreateCustomerLog and UpdateCustomerLog might be at the higher level, maybe your UI level as it interacts directly with the UI elements. Just my thoughts. 

I don't think that splitting the ViewModels up into smaller ones will break this statement . However I also don't necessarily agree with it either. Why should the ViewModel depend on anything? However what I do think splitting your ViewModels up (where possible of course) is allow you to potentially re-use any Viewmodel while also making each view model specific to a particular part of the design/functional requirement. So if I was to continue on with the IFooRepositoriesContext approach I might consider something like this: 

Here's an attempt to use a bit of polymorphism. While doing this some things I did note were: 1) The if statement at the end means that !minValueOk and !maxValueOk are irrelevant and will never be true. The first if should be !minValueOk and !maxValueOk rather than !(minValueOk && maxValueOk. 2) Assuming value is never null for some of the checks you do not need to double check for null. For example should always return a non-null value assuming it will convert. 3) I typically try not to through Exception where I can. Perhaps a custom exception might be worthwhile here. Here's my attempt at a refactor. I'm not 100% sure it will compile but it should at least give an idea: The new Validate method: 

A couple of very minor points. I noticed a bit of an inconsistency with your convention for naming variables. Sometimes you are using _ prefix, sometimes not, sometimes PascalCase sometimes not. For example some of your variables are declared as: 

A further enhancement would be to consider DI of the IErrorHandler into your application so that it is only ever defined in one place. That way will end up having dependencies on IErrorHandler throughout the code which would make it easier to unit test as required. Of course the IErrorHandler interface could include other methods, these were just suggestions based on your original code. 

Any code that runs in Razor syntax will run on the server. The noscript tag is a client control mechanism and is used to help browsers when script is disabled. Hence, by the time the html code reaches the browser there will be no indication that the razor code was even used. Hence, if view the source of the browser you might see something like. 

I want to keep it flexible so that I can decorate Enums with different Attributes as the requirements may vary i.e. using System.Xml.Serialization.XmlEnumAttribute in conjunction with System.ComponentModel.DescriptionAttribute so a UI can use the Description attribute to display a nice name while an XML serialiser can use the XmlEnumAttribute etc I would expect to either provide a wrapper class for this on my various projects so that I wouldn't have to create the delegate method everywhere however unsure of this approach. EDIT: After re-looking I thought the GetProperty() method is pretty generic and doesn't really necessary only belong to an Enum so I moved that out into it's own ObjectInspector class. EDIT: After some further thought into this I decided that actually it's not directly related to Enum's but rather the ability to get descriptions from properties in general. I've made some tweaks to the classes to try and separate this out. Any comments would be most appreciated. 

I would further refactored the getting of user email into it's own method as that seems to be common across both forms. 

You might notice two methods for . I did this as I wanted to do some unit testing on the methods, but to setup that I didn't want to have to enter in a value. My unit tests included: 

If you aren't considering using a mapping solution such as AutoMapper, you could make this code a bit more succient by removing some of the local variables and creating a couple of local methods that are responsible for creating the select lists. The end solution would look something along the lines of: 

We could perhaps do away with the bulk of the children class code by implementing a bit of logic in the base class. A starting point for discussion would be something along the lines of: 

As for how that works, I'll leave you to figure that one out, or I might post it if you go down this route? However what that partial does is ends up printing exactly what you need: 

Summary I like your approach. You are correct in that class explosion might be a problem but I think this potentially is outweighed by the clear separation of concerns in the system. As for TDD, I don't think every class in an application needs testing. For example if you classes are DTO's there's nothing to test, so class explosion might not necessarily be a cause for concern (or a reason to not go down this route). Well just my two cents. I hope you get some answers and reviews that enable you to produce code that you are happy and proud of. After all, isn't that what we are after :) 

I actually think I slightly disagree with the other answers in this situation. As you, others have mentioned I see three possible solutions (although there may be others) 

I would probably have a seperate method that takes no parameters. Mainly because by passing null, null you are assuming knowledge of the inner workings of the method. What happens if later on down the track your suddenly decides to do something with sender. I think it would be fair enough for the method to assume the objects will not be null and work with them directly. So in that case suddenly your program would fail. You might not even notice that until the program makes production (if the test cases, user doesn't test the ThisButton_onClick functionality). I would start by making the method private within the code behind. And later move it to the domain or service later later on if required. 

These written in notepad so no guareentee on exact syntax although hopefully they can give some ideas. 

What about seperating your sorting from your criteria? I'm like you, I'm sure there is another way so am interested to see other opinions. I'm not exactly sure if this would scale for multiple orderBys either but I think it might (NOTE: this code is untested and some types are not defined) Something along the lines of: 

Maybe a switch? Although whether it's shorter or more efficient or even easier to read up for debate. 

I would now only use a service layer directly interacting with the IUnitOfWork. However I would also consider abstracting each service behind an interface itself. 

With these in place we did a bit of serverside code that ensured we hijacked the result and returned a json object instead. I'm fairly happy that code works. What I'm not sure about is the javascript code that I use to perform the result. Some notes: 

I'm typically not a user of the statement but here is one alternative using this method. In this case it may be a simpler implementation and removes the need for any extra local variable. 

Not much there to be ugly to be honest. I guess all I might consider would be the reverse of MrSmith42 and adding functionality to avoid the duplication of .