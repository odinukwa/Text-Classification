I would suggest focusing on the nature of the answer. The requirement is to return the highest possible values, which also means the shortest sequence. So I would suggest you start at and work your way down, checking increasingly long sequences until one sums to greater than , in which case you can restart at , etc. 

You can use the method to provide a default value instead of catching an Exception. This makes your computation a single expression, which is good for further inlining: 

Validate and rename! You have two constraints, one explicit (the Betz limit) and the other implicit (all the parameters are numeric). Validate them! I'll suggest you have a look at Python's module, which provides abstract base classes for numeric types, and applies a "hierarchy" to them. The most appropriate type, since you use "float or int" a lot, seems to be . The type adds "conversion to " which is right up our alley: 

Probably the biggest pitfall I see is the question of ownership. As the code is written, you call on both the key and value when you insert them in the function. (By the way: you leak memory if returns NULL.) That makes the ownership clear, but it forces a copy of both the key and value, and doesn't allow the user to do easy updates. I would suggest not trying to duplicate the value part at all. I would further suggest making that a pointer rather than a - the current implementation is too tied to the model. You might keep your own copy of the key - that makes sense if you are reading keys from a file buffer where the memory is likely to be re-used. Again, though, I would suggest pushing the ownership issue onto the user: let them call for you, or take responsibility for interning the strings, or whatever. You recompute the hash during resize operations. As your hash functions grows more powerful, this gets more expensive. I'd suggest storing the hash value in the key record, and not doing any hashing during resize - just compute the stored hash value modulo the new table size. Your type names are a mix of Pascal case and the C suffix. I'd suggest that you pick one: either use or as your type name. Further, why not include the pointer in the type definition? Instead of declaring it would be easier to declare and let the type be opaque. You are leaking names into the outside. The various table-entry functions should definitely be prefixed with (, , and ). Ideally, they should be declared and completely hidden from outside access. Consider storing your hash/key/value entries in a simple dynamic array. You can then create a separate array of shorts or ints (depending on size) to serve as your hash space. You would hash into the hash space, then use that to find an index into the main table of entries. This lets you store the entries in insertion order (which can be useful), and lets you access the hash space using open addressing with a fairly high degree of locality. (You could even use indexes in your hash space, if you felt there were enough use cases for small tables. Keep in mind that the size of the index is determined by the number of entries, not the size of the hash space: you could have 1024 buckets with < 256 entries and still use indexes - damn few collisions, too, I'd bet.) I really think you need a better hashing function. In order to prepare for this, you should probably treat your key as a memory block, instead of as a string: pass a start-pointer and a size to the hash function. Next, you might consider using a much stronger hash. Even a cryptographic hash. If you are caching your hash values, you'll never have to call it again on a key, and at some point the probability of a collision gets very close to zero (this is how Mercurial identifies changesets, for example). 

Your overall breakdown looks good. There are a few problems in the organization and logic: Create a function In you have this code: 

It seems to me that the type is part of the . So there's no reason for that to be visible outside the SLL. I suggest making it a nested/private/hidden/secret class. (There are many ways to hide it, pick the one you like.) Your method names are confusing. The namespace has any number of collections defined. Pick one of them, and model your naming on that. For example: has a method that returns the size. It also defines and . Alternatively, also defines and . You need to pick a usage model for your SLL, and then choose method names compatible with it. What, no iterators? 

That said, I notice that you initialize to outside of your loop and never reset it to anyplace else. This means that once you've set , it will stay true forever (inside you loop, anyway). That's probably the source of your error, because it should stop being true once you've updated the stack. 

Get used to writing docstrings. When you declare a function and then write a comment describing what it does, you're wrong. Python uses docstrings for this, which have the advantage that they can be accessed and manipulated at runtime (for example, in the REPL command line): 

Your second alternative, on the other hand, has a much more restricted, and thereby much cleaner interface: all operations must be encapsulated as callables. Now, they could be functions, or they could be lambdas. They could be s or dynamically loaded or web api calls to a satellite orbiting planet Nebulon. But from the maintenance point of view, "create a callable, plug it in here with a name" is as good as you're likely to get. You could even do it dynamically, in response to a configuration file or plugin module: 

You return a list of chunks. But wait! Actually, you return a list of chunks ... backwards! You reverse the order of processing for no good reason. It's somewhat more convenient to you, in the sense that you can keep dividing by 1000 in the function. But it's not actually helpful for any other part of your code. All it does is require that somewhere, another piece of code has to reverse the order of whatever data it has. Here's a link to Ned Batchelder's Loop Like a Native presentation. Please watch it, even if you've seen it before, because it totally applies in this case! Instead of creating a list of 3-digit chunks and returning it (backwards!), why not create a generator? Furthermore, since a forward generator will have to know about powers of 1000, why not create a generator that will also deal with your powers-of-1000 labelling? You can kill two birds with one stone: 

Your code looks at every value, and if it's 1, adds 1 to the count, and if it's not 1, adds nothing to the count. Now, think like a programmer! Ask, "how can I get rid of any of that code?" In this case, what happens when is not equal to 1? Why, then, it's equal to 0. And what happens when you add 0 to any number? Nothing - the number doesn't change. So you could change that code to: 

Consider . What does it do? It sets the current Hp. That's nice, but what is your code actually doing? Your code is raising the current HP, subject to a maximum. Why don't you write a method that raises the current HP, subject to a maximum of ? It might be called And then you could write: 

You built it, using a totally artificial ID that you made up. You might just as well say and use a list. Except that function is built-in: If you do that, you can iterate over the artists just using: 

Right off the bat, I want to ask why you're passing a pointer? The "double pointer" in question is the , not . Since the structure is encapsulating the head and tail pointers, and is not a node itself, I'll recommend that you just use a single level of pointer for this. I'd also suggest that you the key type. Make it a or something, not a . 

With that text structure in mind, it seems obvious that each part will have an boolean method, and some mechanism for selecting the tag of the next part. Something like which can return a tag. The tag (string or integer) can be used by the to select the next part. Thus, I can pass in a simple class that has a method that returns some appropriate value (single letter of the alphabet? integer?). Creating a new and calling will cause something like: