PHP already has a function for escaping HTML characters. . In order to completely and absolutely prevent XSS, all you need to do is pass anything that's about to be ed on a page through that function. So for example: 

Note that in the above, the User is unaware of the database, which means it's perfectly reusable across applications with different storage systems. 

This code is 100% XSS proof. And it doesn't matter what has in it. Note that with this method you do not escape for HTML before you insert to the database. Always escape as late as possible. A note: This is about escaping HTML. It will not help you escape things like JavaScript or URLs. The following will not be escaped properly: 

Depends, are the pictures extremely heavy or otherwise take a burden on the server? If you're uploading 100 2MB pictures at a time, that may be the case. If you're only upload 2-3, it wouldn't. Don't generate the thumbnail in advance. Generate it on-demand and based on the requester's needs (i.e. an avatar in a forum is 64x64, but in the profile page it's 128x128). Save the results normally to a file and create a database entry for it, so that next time, you won't have to generate the thumbnail again. It is. It depends on the rest of the application. Personally, I'd go with a more OO solution, but that's because I understand how OO works and how to incorporate it into my needs. Split the code into smaller pieces of work. Either objects or functions, that do small tasks each (get input, do something, return output). This will help code readability tremendously. 

It depends. I would say, if validation failure is a common use case (e.g. validating user input), it would be better to use an validation approach without exceptions. Otherwise, if validation failure is not expected (e.g. re-validating input from the client on the server), throwing an exception would be OK. 

Just register the interface as factory and you can use it for creating the unit of work objects. If the unit of work has additional constructor dependencies (which have to be registered in the DI container of course), Ninject injects these dependencies automatically. That solution looks a) simpler with b) less code and c) without using a service locator ;) 

Great Idea! I really like that way to realize "generic arithmetic operations", even if it may result in run time errors when the type does not support the corresponding operation. However, its great that it works with all types that implement the corresponding operator - even with custom types :). Performance My first thought was: That must be slow compared with the static version - but it isn't. The static version is less then double so fast than the expression version. On my Computer, 10.000.000 add operations can be executed in a few 100 milli seconds. Therefore, the overhead can be ignored for the most use cases. Code Most points are already mentioned by other answers... just yet another: Instead of having one class that provides the 'Create' method, I would prefer to have one class that provides all that methods and returning an IEnumerable: 

You can have more methods like "fetch the N top user with most comments", or "Fetch all the friends of this $user" The point is, the is responsible for getting/saving all necessary data from the database or whatever other permanent storage you might need, and fill the actual Domain Object, which is then used by the application to do processing. 

In the above example the nonBusinessDays of the week are SATURDAY and FRIDAY, and 1st and 2nd of June are holidays. In that case, 3 business days from now is June 5th. This can probably be improved further, let your imagination run wild :P 

What's wrong with your sanitizing Sanitizing is an important job of the server. It makes sure nothing nasty comes in and affects what your users are seeing/experiencing. Sanitizing is done as late as possible, for a simple reason. When the username is entered to the database, you shouldn't make assumptions on who is going to use that username. It could be your application later on, it could be an API you may or may not choose to provide one day, it could be a desktop application or a mobile application which does not care for HTML formatting. When you extract that value from the database and are about to put it in HTML, that's the point where you should escape for HTML using . Maybe at a different point you may want to output it to a JSON response for an API, in which case, is good, but not as much. 

Yes, that is necessary and another indication of the complexity of the code. You actually don't know if an instance variable is reinitialized while a method within the class is running... 

The "LINQ solution" is more readable and a little bit faster than the "manual comparisation". Depending on the actual size of the test set, you can play with the hash function to further improve performance :). 

Actually, I am a fan of small and stupid domain models. Why should the domain model have a dependency to the validator and the calculator? How do you handle e.g. validations that require more than one domain model? All that stuff can IMHO be done in the controller, view model, whatever.... But that is only my personal preference. If you decide using rich domain models, I think that is OK because the actual validation / calculation logic is abstracted as t3chbot already mentioned. 

Each time you call , you create a new files stream and close it afterwards. Therfore, you should not write the result into the file by calling n times. just use instead: 

Some context I've been tasked with supplying an escaping function to arbitrary CSS values that are entered through a form. The goals and caveats are: 

It's perfectly fine to not reject if there's no error. Yes, there was an error loading the image, but it isn't an exceptional situation, it's not something you'd because of. Your function is actually there to check if the image loaded fine or not. 

Business rule validation - "User chose this city and this country, does it make sense?" or "User said he was born in 2012, does it make sense?" Data-integrity validation - "User already exists in the database" or "Username should contain between 3-20 characters". 

Yes, there are several things I can see with your implementation, from most critical to less critical: 

How to improve This code, contrary to popular belief, is not MVC. MVC stems from good OOP practices, and the separation of concerns. The idea is to separate your application into three major layers: 

You want two classes. They . and , you instantiate whichever you need, and inject whichever you need. That way you can even have the same signature in the constructor in both types. If you don't have a preference, you just need a database connection in a function, just ask for , and either will fit. Also 

Logic The object is not a real singelton because the method changes the internal instance. That may lead to strange errors (imagine the case that the settings object was bound to the GUI which is generally possible with singletons). 

If a boolean (without error message) is enough, I would prefer the boolean return value because of its simplicity. Otherwise, I would even prefer something like an object that contains a success flag and an optional error message (or even other information like the exception) as return value. Another option is to throw an exception - may be also valid in your case. For that kind of error handling, the command should be executed before being pushed to the obviously. 

It seems that the instance variables , class variables are set / used from different methods. That increases the comlexity of the program flow. I would try to avoid such 'global writable states'. 

Creating multiple types for implementing different representations of the same type is probably not the best option. A simple solution is, to create one type that uses internally one of the available representations (it's rad in the code below). Further more, the type should provides methods for creating a value from any of the available representations and converting the value back to any of the representations: 

There are a few things I would have done differently, I'll say those before showing my own solution: 

Yes, you are most certainly on the right path, and as a first step, it's very good. Some pointers for the future. 

MVC is a concept that stems from good OOP practices. It's about seperating your application to three different parts: InputControllers, ProcessingModel and OutputView. What you are describing is the bootstrap page, which, at least from my perspective should not be a class. Here's my approach to this: index.php 

And that last snippet the only thing that's specific to your current DOM, so when your DOM changes, you don't need to change all of your code, just the bit that interacts with it. Additional notes for future snippets (just general things I've noticed): 

Note that this way the User has no knowledge of where the data in it came from, could have been files, could have been a session or even a REST api. 

You should first ask yourself this: Why am I sanitizing input in this way? Let's say I have a login form, and the user enters his credentials, an email and a password. The email will be queried against the database, to figure out the user's hashed password (You are hashing your passwords, right?!), and the password would be hashed, to be compared against that hash. Both of those fields will never be outputted to HTML, the password is never kept in plain-text form for very long, and the username is queried against the database and then discarded. So why should you escape them for HTML? 

For me it feels better to use a factory for creating commands compared to registering all commands to the DI container. However, it is more effort to create and maintain the factory interface. [Edit] Alternatively, it is possible to create a generic factory for commands. That doesn't require to extend / maintain the interface: 

Update AdrianoRepetti mentioned in comments, that the solution above may result in rounding errors when adding two angles in degree for example. That is a valid point, so the code below stores the values as well as its unit as internal representation. That allows to avoid that kind of inaccuracy. The API remains the same (except that the precision changed from float to double): 

An alternative solution could be a binary reader (see also: this code project article) Implementation: (I just replaced the 2 try catch blocks with one using): 

It would be better to give the interface an additional "Name" property that returns the value of . Than you can iterate over all implementations and get the first with the corresponding name ;). Example: 

What you should be doing when receiving your input, and as early as possible, is validating the input, i.e. making sure the input matched what you expect in format, and in business logic. Format means "This is a valid email address", and business logic means "This comment that the user is trying to edit, really belongs to him". 

Now for the more juicy stuff. Is your library useful? Why would I, a user, want to use your library instead of just writing HTML? Or generating HTML for that matter? The usage code seems a bit over-engineered, too large and "clumsy" to actually be useful. Truth be told, it's a nice project to improve your knowledge with XSS and the structure of HTML and perhaps even OOP, but it's not actually useful in the real world, because generating HTML is simply easier. 

Business rule validation belongs in the Domain Object itself. (i.e. the object directly). While your data-integrity checks should be done by the RDBM. More often than not, the RDBM (which is usually MySQL when talking about PHP) is not capable of doing all of that (which is why moving away to a better RDBM is encouraged), in which case those things also need to happen at the Domain Object level. TL;DR It's the job of the domain object to validate itself. It's the job of the storage manager (the database) to make sure the data is correct from the constraints point of view. The validator class ends up (usually) as a utility class, which is nice to have, but unneeded for an actual project. 

I would suggest not to recreate the instance of each time, because it creates an assembly in memory that is not reused / unloaded. To avoid that, just create the instance as static field of the class or use something like a XmlSerializerCache. see also: XmlSerializer class may result in a memory leak and poor performance 

Nice pice of code! Did you run performance tests? It would be interesting to know if the cached version is more performant as a non-cached version depending on complexity of the dependend objects. 

d) Maybe a question of philosophy, but I don't like properties of type in view models. A boolean property is more appropriated to represent the logical state of something in the view model. The transformation from the logical state to it's visual state should be part of the view / XAML (using a BoolToVisibility converter). But that is probably just a matter if taste... 

Do not open and close the file stream of the output file each time you write one line. Instead open it once at the beginning and close it at the end (open/close a file stream is an expensive operation).