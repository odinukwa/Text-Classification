will throw the relevant exception for an invalid value. Do not repeat yourself You can try to avoid duplicated values and have a single source of information. In your case, the list of planet is indirectly hardcoded twice : 

Then, because of the small amount of prime check we perform, pre-computing a sieve is not worth the pain. Thus, you don't even need to assume a maximum value. You don't even need to assume there will be 11 numbers found. The new code is way faster than the original code: 

I'm not quite sure if you are aiming only for smaller length or also for better code/readability. Depending on the answer, you can take the following style comments into account (which are somehow pretty personal except for the last one): 

I have found new things to improve from my previous version of the code Trigonometry Adding an offset of before calling the / functions is not really needed as this can be done by swapping the functions (and their signs). You'd get: 

A matter of priorities Make it work, make it right, make it fast : at the moment, your code does not work in that sense that it does not give the solution to the project euler problem. Nevertheless, I'll try to give you hints to rewrite your code in such a way that it returns the same results as it does currently but in a better way. In order to do so, I've written a few assertions to be more confident when I perform changes. 

Multiply once You multiply by 2 each value you add to . You could do it only once at the very end. Sum builtin You could use the builtin to perform the sums efficiently. You'd get something like: 

You should start by rewriting your function so that it returns things instead of printing them. Then, you can write automated tests. For instance, you can write the following tests: 

A constructor taking device_id, device_type and home as an argument. a static method doing the file handling and calling the constructor previously defined. 

Correct data type Instead of using literal strings and , we could use a more relevant data type like booleans. Separation of concern/optimisation In the same function, you compute things, you move the cursor and you draw dots. This seems like a lot for a single function. Also, you end up spending a lot of time performing the same computation. What you could do is define a function to compute coordinates, then call it for all vertices and use the results to draw dots first and draw edges later on. 

(It's probably a good idea to rename arguments and functions but I'll let you deal with this). Useless return Your is useless. Do not use to check booleans It is a bit more idiomatic to write instead of . Avoid string concatenations Instead of using again and again on your string, you can simply define a literal string on multiple lines. Also, if you do it directly in your call to , the parenthesis will help you: 

It's simple and clear. About There is still quite a lot going on here. The logic is duplicated looks like maybe it shoud be part of the function (telling how many dice are left to play). Also, it could be a good idea to have a constant containg 5 to make things less confusing. At this point, the code looks like : 

shows that there is something wrong in your result which is the first problem (Hint: the problem is in the shortcut). Trying to perform tests with starting from 1 shows that there is another issue (Hint: a loop does not finish). Actual optimisation Think about the cases you are trying to handle or how you are trying to reduce the search range. With the following code, you compute less in each iteration while making the search range smaller : 

Actually, as mentionned by Maarten Fabr√©, this does not handle 0s perfectly. The code below is updated to handle it better. The last case is trickier. We can try to use recursion to solve smaller versions of the problem. I didn't manage to make this work properly... 

Reorganisation in the main function At the moment, the code parses two number and an operation, computes the operation, convert the result into a string to be parsed at next iteration. Thus, each temporary result gets converted from integer to string then integer. This leads to issues when the result cannot be converted back and forth - for instance when you perform divisions with non-integer result. Also this could be optimised a lot with the following logic: 

Also, because of the way Python evaluates integers as boolean, you can write the conditions : , and . The list is not used, get rid of it. In a "normal" password checker, I guess it would be possible to factorise the different possible cases on the different criteria to make your code more concise. Here, I have troubles trying to see a logic behind the different cases you are considering. Why would a lower case password be no matter the other criteria while a pure upper case password would be ... 

You may wonder why I used instead of for the second loop. The reason is the fact that if at the beginning, the value would either stay the same or become , thus `cd != "Tuesday". 

Among the nice benefits, because the function is now used for a single test case, I can return directly from the most relevant place and this is no need for a anymore (if you were to keep such a flag, it'd be a good idea to use the Boolean type). Style Python has a Style Guide called PEP 8 which is definitly worth having a look at and following. In your case, the spacing (both vertical and horizontal) is not quite perfect and so is the usage of useless parenthesis. Fixing this, you get: 

Now, the data structure you are using is a bit akward because you don't use the key at all. Instead of mapping string to list of strings, you could have a list of list of strings. Even better, you could use list of tuple of strings : 

Actually, going further, one can easily spot that this loop is nothing but a loop in disguise. What you want is just to go from to . The pythonic way to write this is : 

I had troubles testing your code on your example because an empty string was messing with the conversion to int. I took the liberty to had a simple in the loop to deal with this but you can probably find other solutions depending on the input files you want to accept. 

def add_txt_extension_if_needed(filename): if not filename.endswith(TXT_EXTENSION): return filename + TXT_EXTENSION return filename 

Then it seems a bit more obvious than sell_threshold is not useful. Also, as suggested by jonrsharpe's comment, you can use : 

The difference is that one operates in place and the other one returns a new list. Your code does both which is likely to be confusing. Other various comments You could (and probably should) pass the sorting function as a parameter to your testing function. You'd have something like : 

Also, if you were to do things manually, after notificing that 0 has to be in 10th position so that the number is divisible by 10, you can notice that it leaves only 5 to be in 5th position so that the number is divisible by 5. You have 2, 4, 6, 8 left for 2, 4, 6 and 8th position and 1, 3, 7, 9 for 1, 3, 7 and 9th position. You can do this programmatically for yet another performance optimisation. 

Problem in your code (and in mine) : trying to make the test case a bit more interesting (at the moment, your example does not encounter any problem), I've discovered a problem. Indeed, I was adding Queensland as a neighboor of Victoria (which is still possible in a planar graph if the Sunshine State decided to invade the West Coast of NSW) and I got the following error : 

Don't use the same variable for two different things if you can avoid it as it can make it hard to understand the kind of data the variable is supposed to refer to. For instance, it's easier to get what is like if you rewrite 

A different algorithm I though that by the time I'd write this, I'd have found the name of the algorithm to solve your problem but I haven't yet. :( Real life problem and data example In your description, you say 

This is a bit better but you can go further in the separation of concerns. It is probably a better option to have to return a boolean and have a loop ensuring we call as long as required. This would look like: 

Because of the way you use , there is no need to add in it as it will not make any difference. We can them simplify the code by removing the corresponding branches and inversiong the conditions : 

I think see this the neatest solution. Then if on only want to create the table only once for performance reason, you can put it a variable outside the function but it's probably not needed. 

Duplicated code You should try to follow the Don't Repeat Yourself principle. In your case, most of the logic is repeated in 2 branches. You could write : 

As @tobias_k pointed out, this doesn't do much at the moment as gets overriden. In Python 2.7+ or 3, you can just use the dict comprehension directly. 

Looping over an array using is an anti-pattern in python. To loop on an array while keeping track of the index, the usual solution is to use . In your case, because you are updating the array anyway, it is quite tricky to loop on it. 

Your code does not take into account that when something is moving , it is not also moving (and the same thing for left/right). It might make things easier for you to track if instead of , you had a variable for vertical move taking values , and (or anything else you fancy) for up/none/down and the same kind of thing for horizontal move. This could also be a single variable altogether. 

Disclaimer: I haven't tried the challenge myself so it will be pretty generic advices. A bit of style Python has a style guide called PEP 8. You'll find various tools to check that your code complies to it such as , various tools to fix your code (such as ). I also highly recommand testing other tools to check your code such as , , ... Problems in your code are mostly related to whitespace but you might want to get the habit of doing it right. Also, as far as style is concerned : the variable does not seem to be very useful (its name does not convey much meaning and the value does not change) ; the variable is not used as such, the convention is to name throw-away values . A bit of scaffolding A piece of code like the one you've submitted is quite hard to test as it is. Indeed, the only way to play with it is with input/output. This makes it quite hard to write automatic tests to ensure you do not break the algorithm but also to write performance tests to make your optimisations actually are optimisations. Let's try to separate the concerns to have the actual algorithm on its own and the input/ouput in a different place. Here's what I have done : the function takes a list of tuple (min, max) and returns a list of list so that each list corresponds to the list of primes. Then it is just a matter of pretty printing to solve the challenge. I have converted the test in the example and some more to automatic tests : 

Now, because a single is enough for the final to fail, we can add between conditions in order to stop at first failing conditions. 

You can already handle much bigger values. More tricks to handle bigger inputs A trick to perform things quicker is to precompute values to be able to reuse them quickly. Such an algorithm for prime number is called the Sieve of Erathosthenes. You won't be able to compute it for the maximum values () but it could be worth storing a list of primes up to where max is the maximum max value in the input. If you do so, you'll perform the sieve for values up to maximum 31622 which is realistic. Then instead of checking all divisors, you can check only prime values (as primes gets rarer and rarer, I expect this to make the code faster). Another trick might be to try to handle overlapping test cases by not performing the same actions many times. 

Off-by-one error This may or may not be an error depending on what you had in mind. You've defined a function which is supposed to return 100% initially and 0% at the end. Your function reaches 0 when which is when . Unfortunately, this is not the last value of your loop : the last value of is .