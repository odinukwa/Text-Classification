Here's a slightly different take on this question. Here is an example of the two different swap operations being used in a more-or-less real-world context. This code: 

This is overly confusing, and things are obscurely named. This is a one-off for a programming contest thingy, so it doesn't seem like it's that important. But I find that organizing my code well helps me think. You might find that's true of you. Also, you have several fixed sized tables that are very huge. Quite likely unnecessarily so as the short cycle lengths for large numbers indicate that most sequences converge rather rapidly on a common chain. Lastly, you keep a stack of values when no such stack is necessary because the problem description doesn't require you to print out what the chains are. And even if it did, a very slight tweak to the table contents would allow you to easily print out the chains by just following pointers with no stack necessary. There are other details that seem minor but are actually a big deal. For example, you create an empty vector, then assign it a very large table. This will create two copies of the very large table, and throw away the (rather minimal admittedly) work done to create the empty vector. Since this last is a very specific coding flaw, here's how it would be fixed: 

Lastly, your organization is very confused. You make one class responsible for too many things. There is no need for one class to both handle finding the max value in a range and to compute the cycle lengths. But, while these issues are important, I can't see that fixing them is going to shave more than about 20% off your time. :-/ 

I've created this scheme to preserve function calls until all the arguments are available. The classes will be replaced with classes that implement a -like mechanism that receives notifications when a forward is finished. I wanted to have a way to set up a function call that turned into a forward that was complete as soon as the function's arguments were available. So I came up with this. Could this be done more simply? 

Notice how the two different functions generate identical assembly output? Notice which swap is easier for a human being to understand? Don't use stupid tricks like the xor trick. They're novelties and amusing for all that, but they rarely make a difference in the real world. About the only place where there's even a tiny chance that the xor trick is a good way to swap two integers is on some embedded system with no free registers. And, your formulation of the xor trick is undefined behavior anyway. The fact that it worked is a pure accident, and while perhaps the fact that it didn't cause your computer to explode is less of an accident, that would also be a permitted result of running it. 

This is only slightly faster because some processors have a combined 'find the remainder and quotient' instruction that this leverages. It also avoids testing even numbers. If your number is not divisible by 2, it won't be divisible by any other even number other, since all even numbers can also be divided by 2. Also, make sure you have compiler optimizations turned on. 

If you stay with an procedural style (totally fine for such a task), you could anyway try to split your main method into smaller well names methods. Nevertheless, after this initial objectifaction or extracting of a method like 

Don't use all-capital-letter variable names. And don't use global variables. Both is considered bad practice. 

Of course you can take advantage of all the arithmetic power of BigDecimal and define a specific rounding mode etc. EDIT: Just to prove that the float approach will fail (tested in Java 6): 

Put your code into a method. So you get rid of the temporary variable, its cleaner and you can leave your method with a return as soon as you find the first true. (A break to leave the loop will have the same effect.) In addition to that I'm a big friend of guard conditions. Invert to , so you have one nesting level less. 

I have the feeling that there is something wrong with your database structure. According your query, user will have exactly one item? If one user can have many items and the items belongs only to this user, your schema should look like: 

The default solution for any is inheritance. Add to your and implement it accordingly. Do the same with the other methods. But mtj is mostlikely right. as common type, might make your life easier. 

should be and in new classes you might want to use namespaces instead of underscores in your class names. See PSR-0 As non of your is optional and there are only 5 I would recommend the use real method parameters instead of this array. Otherwise some validation and documentation of this array is missing. Furthermore you could refactor your ifs to real guard conditions and skip the else branch. This makes the code more readable and you get rid of a indentation level. There are also no braces on one-line-ifs. Edit Sample for guard conditions 

I think the main issue you need to focus first, is to split the input from the processing and maybe even from the output. I'm not sure if you meet the requirements of the task, when you start outputting stuff before completing the input. If Java was a conscious choice, you might want to think about a more OOP approach. seems a good candidate for a class. I assume you left away any input validation/user interface by purpose in relation to the task. In Java you usually define variables not at the beginning of a method, but where you use them. In addition to that, loops general start with 0 and end . 

In general it is a good idea to replace ifs that covers the whole function by a guard condition. So you get rid of a level of nesting. 

As Jason stated checking for ".." is a good idea. If there are only a limited number of path where the pdfs are located on the server, I would even prefer matching against this set. Nevertheless, you might also want to invert your ifs to get rid of the nesting and use guard conditions. 

If the statement (e.g. ) is wide, this burns a lot of horizontal space and the comment will probably exceed 80 columns. Consider such a comment to be the "topic sentence" of the paragraph. When it's a sidebar, it's effectively like putting the topic sentence at the end of the paragraph. Most style guides recommend keeping the width to 80 columns or less. I prefer ANSI comments (e.g. ) over K&R (e.g. ) as they're much easier and faster to edit. Try to avoid "if-else" ladders if possible. I replaced one of yours with a and the other, in the loop, using a I prefer to put the return type of a function on a separate line [in column 1] and so the function will appear in column 1 on the next line. This makes it easy to find them with a regex like which can make things easier when editing or analyzing source. Never put multiple statements on a single line. This is very hard to see visually when looking at a lot of code: 

Here is your code cleaned up for style as I've mentioned above. Also, look at some of the changes in vertical and horizontal whitespace: 

Anyway, here's a full program that does comparison benchmarking. Ignore most of it, and compare the and functions against your function. They are largely agnostic. The primary intent here is to back up the 20x performance benchmark above, rather than just stating that without proof. It will also allow, if you so choose, to provide a baseline reference for any recode/tweaks you may wish to do 

Edit: This is probably what I should have said at the outset to make things more clear: Since your interview question is concerned with performance: 

A single simple in-place 2D matrix is much faster than what you have coded (20x faster in fact). Thus, it's all about performance. And, the algorithm matters. IMO, it's appropriate to talk about alternatives because yours is not in the ballpark range as to what is possible/required in performance. It doesn't meet the "most efficient" criterion. In an actual interview situation, this would probably be flagged by the interviewer. Note that, if you were [much] closer, say within 10%, this wouldn't be an issue [and I wouldn't have posted]. I'm not sure that you can meet the objective without a full refactoring of your code. Your solution puts an additional strain on the processor's cache and seems to have more complexity than would be needed. It also seems to use more memory than is required as well. And, a number of the STL primitives you are using, by their nature, appear to access the heap a lot (i.e.) they're slow. I'd say that simply clearing out cells as you traverse would be better than adding the complexity you have [or see below]. Also, for your algorithm, do you have benchmarks on and analysis of how much performance is taken up by each of the STL components you're using. That would probably be required when discussing the time/space tradeoffs. As it is, they are a bit of a black box. Is there a better alternative to for your matrix? I think it adds an extra [internal] pointer dereference [that the optimizer might be able to elide] for each cell access. And, for example, I see a better alternative to using a separate to keep track of visited nodes. When a node has been visited [used], simply OR it with 2. Eliminate your altogether. Then, you can replace: