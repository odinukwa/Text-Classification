The other reviewers cover other bits sufficiently well, so I just want to point out how odd this looks. A null pointer exception typically occurs when you try to access a null using the dot operator. Ie: 

Then the question becomes, how do we call all of this to make it work? I'll start with the first line of your code: 

Normally when there is a lot of math involved, you would include the steps you've performed, either in a comment or in the documentation in some way. So your whole thing showing $$b=num-\frac{500num}{num-a}$$ would be visible to someone working on the code. My point here is that we can make the code look a little easier to read if we make the numerator and denominator variables themselves. Eg: 

I'm going to throw my hat in the ring and say the format of the last example is the easiest for me to read(like your colleague says). It's easy to see that everything is coming from and I can read the conditions in a straight line: it has a sensor, it has an input unit, it is valid, and it is not suspended. And that's exactly how I would read it going through the code the first time. Someone who comes across this code in the future shouldn't have any trouble figuring out what is going on. With the local booleans, I have to verify that each boolean is coming from and that the booleans created are the ones being used in the . In this example it's trivial to see that is the case, but in the case of multiple ifs, elses, or other logic in the function...it may not be so trivial. It also introduces another vector for producing bugs either in the creation of the function, or the function's maintenance in the future. Again, the example is trivial, but it's easy to imagine cases that aren't trivial. Having seen your other related post, I would also pair this with having a separate function for each category(x3ro suggested something like isCat24(), etc), and within that function following the format of the last example you gave(one condition per line, no locals created). Your conditionals then start to look like: 

This is the kind of thing that fills an entire semester at college, but for a simple system like this, the gist of it is to find the individual complexities of the loops involved, and then multiply nested loops' complexities by each other. You only have one loop, which iterates roughly times, so the complexity of that loop is O(a). So we call that linear. Inside of the loop is some math, but since it all uses Java's primitive types, we can consider these operations to be constant-time: O(1). So we have O(a) * O(1) which is just O(a). However, if you were to use Java's for larger values of where , , and could be expected to go higher than , then that's no longer the case. You would have to take the time complexities of multiplication, division, and even addition and subtraction into consideration. It would take a loooong answer to cover this complexity thoroughly, so I'll just say "it's complicated". 

Most importantly, this ensures that s1 and s2 aren't null, so you don't have to worry about s later on. Note, it's OK to define and as here, because we don't intend to change their value. Then, there's . I would make that a , like so: 

David Harkness pointed this out, but I'll reiterate since I'm on the exception anyway. You say "and this set does not support null elements", which either suggests some sets can have a null element, or you're saying that this set class doesn't allow null elements. If some sets are allowed a null element, you need to change your if statement to this: 

The downside to this approach is that you no longer have your numbers after the fact, since the functionality throws your numbers away. There are still ways to get around this, but that's something you have to keep in mind. 

I just gave Euler #9 a shot myself and stumbled on this question. Since it's recent(a couple weeks ago), I'll try to add a few bits of information. For starters, the suggestion by holroy to use modulo arithmetic would look like this: 

And if I want to verify each set of conditions, I can just look up one function per category and see what they're doing. Finally, you might want to consider making a function in called . All of the logic shown uses one , and uses no information from anything outside of that . It seems like it should be encapsulated by the class, and anyone who wants to know the category can call the getter for that information. 

The second thing that pops out is the quintuple nested if statement. The rule of thumb I've heard before is to have 2-3 nested loops/ifs at most. It looks like you're traversing an XML-like structure, in which case I would almost always go with a recursive method to find the child node you're looking for. In my experience, you do this by passing the object to search along with a queue of nodes. The only downside here is that you're looking for a specific piece of data in a specific place, so you have to know all of the steps to get there(which you do in this case). 

As you see, I used his verbatim, and added the like he recommended. Most importantly, I added , which is scoped as private, and put in the as well. Some important notes: 

One thing to note is that you are currently accepting user input without verifying it. could potentially return or throw and . Since you're doing the same thing twice in a row, I would put this sort of thing in a separate function(see below). Also, I've put the keyword into my code below, but I'll explain that later. 

When situations like this come up, it's a good idea to step away from the code and think about how the real-world operates. Objects in programming mimic those in the real-world, so it can be useful to just look at a use case you see elsewhere. For example, let's say you're a US Citizen, and you went to another country for vacation. On your way back into the US, you must prove who you are so that they know you're not on some black list somewhere. You, the user, provide your credentials: primarily your passport, but you might also be asked for your drivers license or any other identifying documents. You hand those documents over, and then it's someone else who determines whether your papers are a forgery or not. It is not your responsibility to tell the officers that you're not a threat. It is their responsibility to determine that. Taking this back to computer authentication: The user provides their username and password, and then someone else(the system) determines if they are authorized to access the system or not. Taking this to the coding level: it doesn't make much sense to have a user authenticate themselves. The code can be written to do that, but it really isn't the user's job to say he's authorized to have access. Someone else in the system needs to determine that - like the authService your colleague mentioned. On the topic of database access...like others have said: that's somewhat up to you. I always like to have one object that provides access to data resources(not necessarily to mean one thread, but one object that determines which operations are allowed concurrently and when to lock the resource for writes/updates). Alternatively, many objects can access a data resource but they're synchronized in some way(mutex, semaphore, etc). This way, the concurrency issues will be located within that object(s) instead of scattered in mysterious locations that make debugging harder. So, if my program is running and I'm noticing wonky things going to/from the database, it's pretty straight forward to drill down to where the problem exists. If I had a bunch of users who were in their own thread and doing whatever they wanted with the database, it might not be immediately obvious that the users are the problem. The symptom is the database looks wrong, and the reason it's wrong is because users are changing the database without respecting the changes the others are making. An example of that case would be source control, which is a tool used to allow multiple developers to work on the same project at the same time without worrying about who is writing in which file. Now, take away the source control. If two developers write to the same file without knowledge of the other, one of the developer's code is going to get erased completely, and when that developer tries to watch his functionality work...it simply won't be there because someone wrote over it. Then the question becomes...who wrote over it, when, and is there a copy of the feature that was implemented, or does it need to be done again? These kinds of things happen on the order of minutes, hours, or even days...but in a program that uses a database...this will be happening hundreds of times a second. It's better to give control of a resource like that to someone who can safely manage it(source control, database handler, etc). 

Finally, the IList seems to get in the way. It's unlike the other function calls you're making, because it's using the node's instead of its . However, if we revisit our function, we might be able to resolve that. AS you can see below, if we pass it a key equal to , we don't look up the key, but instead set the result to the instead. 

Regardless, this bit of documentation would be more fitting in the class' javadoc instead of in this exception's javadoc. Knowing whether a collection takes null values or not is one of the first things people will want to know when they use your code. 

First note that I used the idea to name as . I also didn't use the $$500num$$ I used $$\frac{num^2}{2}$$ I see this as a little bit simpler, and it removes the 500 magic number. It also makes your code work should you change to a different value. Now, x and y aren't really meaningful names, but an actual meaningful name would be something like "bCalculationNumerator" and "bCalculationDenominator". The point of their existence is to make the code easier to read, and those names are too cumbersome to help readability. Since the above calculation would be present, a programmer who comes along to maintain the code would have no trouble understanding what you're doing. At the very least, someone reading the code would understand that these are intermediate calculations, and nothing more. In one job I've had, we had a system for marking math. The code would have a comment giving a document number and page number for the calculation, and the document was maintained just like any other business document. Putting it all together this would look something like: 

But using this kind of system also requires meticulous maintenance of the comments as well, which is possible, but it has to be part of your culture and processes; it doesn't happen magically. In one of your comments you ask: 

I'm compelled to write an answer because no one has really covered the thing yet. Sets, maps, queues, vectors, linked lists, etc are words that have meaning to programmers, and I have a hard time believing a programmer would ask a question like this without intending the elements be unique. Overall, I agree with ChrisW and Carl Winder...it looks like they wanted some underlying data structure, not just a that you append to. And they don't want .Net collections or Linq to be used. Technically, you could use a and be safe. However, adding a new item requires you to create a new array, copy all the old values in, and add in the newest value at the end. That's fairly expensive and will not work well with large sets. Extending ChrisW's code: 

Assuming that the array isn't something you have to use, the natural solution to this kind of problem is to use a . A stack is a data structure that is Last-In, First-Out. The idea is that you read the file, one item(number, in your case) at a time, and 'push' each item on to the stack. Once you've read all of the items, you 'pop' them off the stack to display them. Here's an example of how to do it with a stack: 

And the caveat, of course, is that I can't compile any of this, run it, or verify the sanity of any of it. At the very least, I hope it gives you some ideas or will work for you with a few tweaks. It's my personal preference to always explicitly name the types of things in C#. and are wonderful and have their place, but I only use them for one-liners. Carrying around a for a long time through nested statements can be a pain to debug and maintain when you revisit this code. Unfortunately, I don't know much about linq - well, I know it, but I haven't used it enough to have that intuition on when and how to use it really effectively - so I can't provide a solution that uses linq. 

In your case, however, you're not accessing an object. You're simply checking if it's null or not. Also, the rule of thumb is that exceptions should only be thrown when something exceptionally bad happens. Is receiving a null object in this function exceptionally bad? (That's for you to decide). If you regularly expect attempts to insert null objects, then I would say that throwing an exception is extreme, and you should just return instead. Also, the javadoc: 

Sorry, I don't have access to a C# compiler at the moment so I can't verify this 100%, but it's a starting point at least. Edit: After thinking about it, I don't think C# likes it if you use before an element is in the Dictionary. I edited the above code to include how to get the and included the Console.WriteLine so you know where I would put it.