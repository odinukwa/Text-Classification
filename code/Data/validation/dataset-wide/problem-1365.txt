My introduction of Algorithm I was asked to write a simple recursive algorithm two years ago at the end of important meeting. I like the algorithm, so I reviewed the algorithm today and write a short C# solution today. I am planning to study a few of short C# courses by myself on pluralsight.com called "defensive code in C#", "Code Contracts", "Provable Code", learn to write better C# code in next 2 weeks. I am learning C# right now. I am trying to get some critics on my practice today. 

Introduction of algorithm The algorithm is very good one for me to practice write a depth first search and also start to learn LINQ. I still remembered that I did the practice in June 2016, and the code was written and saved as a gist here. I reviewed the code today, and rewrote the code to make a new base case selection for depth first search. Based on the facts that last 12 months I asked questions over 35 questions on this site and also I have practiced mock interview over 100 times since this March 2017, I have more ideas to review my own code after six months. I also learned from my mock interview experience last month missing a base case. Code improvements I decided to make a few improvements based on my last practice over 18 months ago. Internal class is used instead of external class. I choose to use camel case for public method, and rename the function DuplicateCheckingPathSum to make the function name self-documenting. Specially I took 10 - 20 minutes to go over those stackoverflow links to learn LINQ and also ASP.NET C# class and I found that those links are really helpful for me to warm up LINQ. It is tough for me to see that after 18 months I still do not make big progress on LINQ and the functional programming syntax still looks like foreigners to me. Most of important change is that I learn better recursive function design after 18 months. I was surprised that I ended my last practice with so many issues. The base case should be selected to avoid duplicated count of each path. I like to see the depth first search algorithm specially a recursive function is written in very structured way, base case is very clear and also the recurrence formula afterwards. Please share your advice on my journey to be a good thinker on depth first search on binary tree. I still make mistakes on depth first search and have interest to know how to choose the base case as an art and scientific approach. 

Debug the code, and check how many times the dictionary is looked up. 3 times. key = "0 1", "0 2", "1 2". Draw a recursion tree for this simple test case. Here is the graph: 

My introduction of algorithm The Gridland Metro is the medium level algorithm in the contest of Hackerrank World CodeSprint 7 in Sept. 2016. I did manage to solve the algorithm in the contest but I spend too many hours, problems are related to runtime error and timeout, the test cases I used in the code does not help to figure out the issue. Since , and are with large value and I did not have good techniques to work on simulation of large test cases, I examined the code and remembered the coding guideline phrase "express the intent", and then change a for loop to one statement to get distinct rows with train tracks first, in the function , first statement:. Today I spent near 2 hours to review the C# algorithm, and put together the readable code, I have to relearn the algorithm and also write code with less smells, with some instructional notes. The code passes all test cases on hackerrank. 

My introduction of algorithm This is medium level algorithm on Leetcode.com. I have practiced over ten times from March 2017 to Jan. 2018. I wrote the algorithm in mock interview five times and also watched five peers to work on the algorithm. I experienced the pain to write a for loop inside a while loop four times, I wrote the code with a bug to print one row matrix twice, duplicate the output on last row and first column. And also I watched a few times the peer to struggle with so many bugs. Overall it is an algorithm with a lot of fun to play with. How to write bug free solution in mock interview? First time I had a mock interview on another mock interview platform on Jan. 23, 2018, and it is anonymous one. The interviewer asked me if I can write the solution only using one loop instead of four for loops inside one while loop whereas two for loops to iterate on row, either top or bottom row; two for loops to iterate on last column or first column. I had worked on the algorithm over 10 times on mock interview, but I never come out the completed idea based on limited time concern and buggy for loops. None of my peers came out the idea and wrote the similar ideas, and I only had discussion with one peer before. As an interviewer or interviewee, I did thought about four for loops are problematic as well. One time I complained to the peer in mock interview when I worked on the four for loop of this spiral matrix problem. I told the peer that I like to use extra array to mark visit, so that my four for loop can always go from 0 to rows - 1 or 0 to cols - 1. The code will take extra time to iterate on visited elements but definitely no worry to define the start and end position. The peer's advice is not to be a hacker in mock interview, you should always follow the interviewer's hint or advice. That is only time I made very close to this new idea. It is helpful to review all past practices through the code blogs. Here is one of blogs about the practice on spiral matrix algorithm. Analysis of the algorithm One thing I like to do is to write down some analysis of the algorithm before I write any code in mock interview. And it is also very helpful for me to go over various ideas to find the optimal one. I also like to practice this approach when I ask a question on this site. Here are some keywords for the spiral matrix algorithm. Direction - There are four directions. Change direction if need, in the order of clockwise, starting from top left corner (0,0). Range - Stay inside the array Visit - visit each element in the array only once. Do not visit more than once. Order - follow the order of clockwise, start from (0,0). Quick solution with readable code I wrote a C# solution and use extra space to declare an array to mark the element in the matrix is visited or not. To change direction, if the current row and column is out of boundary of matrix or it is visited before. I wrote the solution after the mock interview, I could not believe that I need so many hints in the mock interview after so many practice, one hint for four directions, one hint using extra array for visited array. Here is C# solution. 

We then print the number of squares she can attack from that position, which is \$9\$. My introduction of algorithm: This algorithm is a medium one in hackerrank world codesprint 9 contest, and I like to code review the solution I wrote after the contest, instead of the one in the contest. Because in the contest, I did not encapsulate the 8 directions very well, I spent time to write code for each direction. And I am studying the open/ close principle, the idea of implementation is the similar, do not write if/ else code to discuss each direction. Enumerate all directions by iterating the directions array once: 

Problem statement You're researching friendships between groups \$n\$ of new college students where each student is distinctly numbered from \$1\$ to \$n\$. At the beginning of the semester, no student knew any other student; instead, they met and formed individual friendships as the semester went on. The friendships between students are: 

Make Java code more readable, ready to review I strongly agree with code review conducted by Janos, code review is not just to share you a workable solution. You also have to learn ways to make code more readable, practice better way using Java language in your case. Use O(N) solution to generate key, avoid \$O(NLogN)\$ Sorting algorithm The idea to avoid timeout issue is to generate a key for each anagram group using \$O(N)\$ time complexity, instead of naive one by sorting the string. To take advantage of alphabetic number only has constant of size \$26\$, go through the string once, one char a time, to record the number of occurrence, like a counting sort. Here is the C# code, pass all test cases on leetcode online judge. Here is the anagram hashed key algorithm in C#, most of important decision is to choose a more efficient sort - counting sort instead of comparison based sorting: 

My introduction of the algorithm The algorithm is the hard level algorithm in hackerrank world codesprint 10 in April 2017. I did write a recursive depth first search tree algorithm in the contest, passed the sample test cases but failed all other test cases with wrong answer errors. So I spent hours to study one of code submissions and put together a C# solution after the contest. The algorithm turned out to me a simple depth first search(DFS) after hours study, debugging and walked through the sample test case. My understanding of DFS solution here is that the base case in the sample test case shown in the graph is the node with one connected edge, for example, starting from left to right, node with weight and node with weight . For any edge in the graph, for example, edge :, node starts a DFS search until it reaches node whereas node starts a DFS search ended at itself. The dynamic programming part is not easy to come out and it takes some time to build the recurrence formula. Base case is easy to figure out, node with one connected edges. For any edge to serve each of two nodes, it has to calculate the maximum/ minimum value include/ exclude itself within all connected edges. The C# code passes all test cases. Depth first search is my favorite algorithm, sometimes I forgot that recursive function is the economical choice for DFS compared to iterative one using stack. 

My practice of algorithms I practiced this algorithm through mock interview starting from this March 4 or 5 times. First time the peer complained to me that I do not know how to write a depth first search algorithm, I did not explicitly write down base case at the beginning of the function; Second time I was interrupted and told to write as simple solution as possible, specially showing that base case is to finish the depth first search and go to row 9 which is out of matrix. Do not write any double loops such as two nested for loops. And the code is much easy to read because the structure of depth first search is very clear. So I practiced a few times to write depth first search like the following, besides I started to read leetcode discussion panel for various solution. Learning through mock interview Sudoku solver algorithm is one of algorithms I have learned from various peers last 6 months. The peer with senior experience gave me feedback from low rate like "Do not know how to write code" since I did not write base case inside the function at the beginning, and then next practice I was coached by a younger peer to write depth first search from (0,0) and avoid any two for loops. After first two practices, I always like to write Sudoku solver using the following structure:   base case   depth first search      recursive function calls      back tracking if need Algorithm analysis I also like to share my algorithm of time complexity analysis. My analysis of the algorithm is that any element of matrix has at most 9 choice to fill from '1' to '9', and there is 81 elements in the matrix, so the time complexity can go up to 981 possibility, since the board already is filled with some elements, the backtrack and also early return, the time complexity can lower down, but the time complexity is unknown. Favorite code review One of my favorite review on Sudoku solver is solving Sudoku using backtracking. I try to use my question to help the review of the most popular algorithm as well. My review for the question is to use clear structure, explicitly write down base case using comment and also put base case in the first line of depth first search function, and start from (0,0) to do depth first search and use recursive function to help iterate the matrix, avoid double for loop. The structure is more simple without double for loop. 

Use meaningful variable names the depth first search function has 5 arguments, I chose to order the arguments using 3 categories, input, DFS helper, output. Use var explicit typing when possible. Add two test cases. 

Problem statement: Find \$kth\$ largest element in the union of two sorted array. My introduction of the algorithm I spent a few hours to review two algorithms, Leetcode 4:Median of Two Sorted Arrays and Leetcode 215:Kth Largest Element in an Array together since median is a special case of kth element problem, and also read the article to talk about the kth largest element in the union of two sorted array, 3 solutions: 1:The trivial way, \$O(m+n)\$; 2: A better way, O(k); 3: The best solution, but non-trivial, O(lg m + lg n). So, I decided to practice the algorithm "Find kth largest element in the union of two sorted array" (similar to Leetcode 4 and 215, but with some difference.), using binary search non-trivial one, C# Source code. Please help me to review the code. 

Introduction of algorithm The implementation of the algorithm is to scan the string once from left to right to filter out non-alphanumeric characters first, and then check the string is valid palindrome ignoring cases. The reason I like the implementation is that the code has some simplicity, avoid mixing checking if it is alphanumeric character with two pointers techniques. The C# code passes leetcode online judge. 

My introduction of the algorithm The algorithm is one of medium level algorithm in hackerrank woman codesprint in Nov., 2016. It can be solved using recursive function and memorization. In the contest, I did not write the recursive function because I overcooked the solution, ended up with a few hours scoring from maximum score . I learned the lesson, write less code, avoid complicated code, think recursively. And I documented the study how to think recursively and tried to learn the simple recursive function. After 3 months of the contest, I reviewed the algorithm again, and spent one hour to rewrite the C# code based on one of submissions I studied 3 months ago. Please help me review the algorithm. The C# code passes all test cases using hackerrank online judge. 

First row of table, left = 20001, right = 21024, since Modify API is called and function arguments: start = 0, count = 1024, value = 1, inside Modify API the variable is calculated as 20001 and is calculated as . The two variables of left and right are iterated from beginning to end 10 times, each iteration two variables's values are recorded in the table. And the highlighted color yellow of column marks that the index of will be incremented by value , column marks that of tree will be incremented by value . 

Introduction of Algorithm: I am learning the segment tree and also binary index tree this weekend, and I studied binary index tree from the article on hackerearth related to binary index tree and segment tree from the blog algorithm: Ahoy, Pirates, so I decided to take some time to practice the algorithm, spent a few hours to work on the algorithm "Kindergarten Adventures" on Hackerrank university codesprint again. Also, I like to present the idea from Hackerrank editorial notes first, and then share my C# practice code to ask for code review. Editorial notes: If a student asks for a minute extra time, then he can never be happy. We can ignore him. If a student with id asks for a minute extra time, then if we start from id \$a-t\$ (if \$a-t\$ is negative, wrap it around), then he will be happy. Not just that, if we start from any id lower than that he will be happy. So we get a range of students ( the range may wrap around ), from which if we select an id, we are sure to make happy. For each student, we get a range. Now, we have to select an id which is covered by maximum number of range. This can be done using Binary Indexed Tree or Segment Tree. We need to deal with ranges that wrap around. The students are sitting in a circular fashion. Imagine they are sitting linearly like an array from to . Now just append \$1\$ to \$N\$ to the array, so that we have two segments that go from \$1\$ to \$N\$. Now any \$N\$ consecutive elements of the array is a valid ordering of the students. Now work with the second segment of the array. For each position \$N+1 \le i \le N+N\$, if student \$i-N\$ request \$t\$ time, then we need to add \$1\$ to range \$i-N+1\$ to \$i-t+1\$. Next, to find the value of \$X\$, we iterate over \$1\$ to \$N\$ using \$i\$ and select the index for which sum of values at position \$i\$ and \$i+N\$ is maximum. My Implementation of segment tree I documented the step by step how a segment tree is built using the array starting from , and added some notation for each node in the segment tree using array index ID, range of the node is represented and also the value of node in the comment, went through the sample test case . Make sure that every step is making sense and then assume that the learning of segment tree can be accomplished by this simple test case. Most important is to implement the API of Modify and Query using time complexity of , whereas Modify function is the second argument which is the range of interval, Query function is input argument value. Otherwise timeout will be an issue in the problem solving. Test case study I did spend time to learn the algorithm about time complexity. For any N smaller than , I certainly can choose as to analyze. Suppose that there are students in the circle, suppose that the first student only need to minute to finish drawing, so that the first student can complete the drawing for any student chosen by the teacher to start. Related to SegmentTree class Modify API, it has to increase those nodes by value . If the time complexity is linear , and if all students has operation, then there are operations of N2 = , almost million operations, but the time limit is only 3 seconds, so I am pretty sure that the function will cause timeout. So that we have to lower down to intervals to cover the range of using segment tree. To make it simple, we assume that the range's width is instead of , and see how many steps we need to mark in SegmentTree class variable tree[]. We will show only increment operation. Let us get our hands dirty on the calculation of tree.Modify(0,1024,1). We read the code pasted here first.