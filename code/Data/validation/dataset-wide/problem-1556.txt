It is always a good idea to seperate your business code and your logic code. The business code is the rules for your code. "Do A,B,C give me D, and Save to E" the logic code is the nitty gritty details of how to do A-E. Everyone calls it something different but the concept is always the same. Keep the two as seperate as possible it makes changing your code easier. Those are my tips. Other than that I don't see any problems with your code other than you don't have a way to escape the loop other than guessing the correct number. 

Next I am going to point out 2 things here. One is that even though you are in school, and you are somewhat new to programming I am a firm believer in using tests (and not user input) to test your program. I don't want to start a debate about how to write tests and when. That isn't the point. The point is that writing automated tests have many benefits. Granted at first it is a little harder and slower to write a program. But once you get the hang of it it is amazing. Some of the benefits are that your code can test itself, and it can test itself very fast. For this game I would imagine that it could be written using about 20 tests total. Those 20 tests would (and should) complete in less than a second. (probably in the 100ms range) You may be fast, but not that fast. What's also nice is that it gives you confidence to change your code willy nilly to try new things and know that you didn't break your code. So I am going to take 2 of your methods. Pull them out, and make them testable. (FYI, I had started a book about how I got from A to B with your code. But instead I decided to just show you what a few of my tests look like, and what your getInt method turned into)... First the tests 

Personally I don't think having one extra line per early return is much clutter. It doesn't seem like it'd take long to understand either. That said, if you really wanted to, you could reduce it to one line. You'll still have to assign a variable though. 

I will explicitly answer regarding your sieve and its performance. Firstly, you should know that you cannot write an implementation of the Sieve of Eratosthenes without an array; that is core to its being. However, your method of selection can be improved. First, let us rewrite the sieve in terms of for-loops, since it is more natural to do so. I will also change your implementation from checking primeness to checking compositeness, which avoids the initialization step. 

This post will focus on your implementation of Union-Find. First and foremost, you're not using the member at all, so you should probably remove that. It turns out you actually are using this, just not in your Union-Find class. This is a bad idea. We typically wish to minimise coupling, and using a public member in this manner does precisely the opposite. Next, all your members are . This usually isn't advisable; you should endeavour to make them and provide getters and setters as appropriate. Next, you are in my opinion overloading (not in the programming sense! :P) the member. It's doing double-duty, holding the nonnegative parent node index for child nodes, and the negated size of the set for root nodes. The name therefore cannot be meaningful, since its two purposes are so distinct. If you are pressed for memory then I understand your use of that solution. Keep in mind, however, that since disjoint-set structures are really forests, the classic implementation uses objects containing a reference and optionally an for / . This has the advantage of being more semantically meaningful (and arguably more readable): 

I feel that sometimes inlining some values makes things a little more readable. But in terms of overall compactness, this isn't that much better. Here is what I would probably write 

Assert This is the important part of it all. This is where you check that your code did what you are hoping. In this case I want to assert/show that those arguments were not valid. 

Testing code like this is very difficult. It is hard to read, difficult to maintain and lastly is a HUGE pain to debug a small problem. First suggestion is to group things together into a class that need to go together. This is the first suggestion on finding out what is slow. So here is a much smaller version of the same code. 

Mind you this probably isn't the best choice in names, (or even naming convention) but this does give you and idea of where to go. Making a class that can compare itself to others. We are only interested in comparing the states by their name. implementing is important for list as it is how you will search for an item pre java 8. With java 8 you can use stream and lambda's. Handy if you understand them. That is my suggestion. 

Here's an example that takes advantage of the built-in functions, and intelligently merges in conflicts. (ideone) 

First of all, please strongly consider @Flambino's advice; it's excellent. That said, I don't imagine valid VAT patterns change often. For this reason, I propose condensing each country's pattern into a single regular expression. Since you're so intent on eliminating the loop: notice that if my VAT number is "GBGD123", then based on the prefix, it can't possibly be a (e.g.) French VAT code. I would try matching the country code first, and then match the rest based on that. Consider something like this. You'll notice though that because the various types are condensed, you lose e.g. the comments on UK VAT codes. You'll need to decide if this is worthwhile to you. 

This could be DRYed out a bit. You can get rid of the first instance, and put the logic in the second instance like this: 

This started out as a comment since I'm only going to discuss , but it grew a bit big, so here we go. First of all, I strongly recommend @nukeforum's suggestion that you use the function. Also, as has been mentioned aplenty already, should return a bool: 

This is a bit of an inefficient way to render. Each time you modify , the DOM is going to change. Instead, it's better to add up your modifications and then only modify once. 

I agree to a small degree with Hugo about seperating all the graphics portions within each if statement. But this is a prime example of how inheritance comes to play. You have a switch statement inside your logic method (some people have different names for this, but it basically just means where you do all the work) You are on the right track with having a state. You are also on the right track with having a enum. Where I feel that you go wrong is by putting all those in the logic method (in this case render) So I would make a abstract class that returns a instance of itself based upon the state. It would have 1 abstract method called render. 

but even more important I can create a test for SquareRootOperation to make sure that it works as desired. 

WHY?!? Why would you catch a index out of bounds exception. There is no one but to blame but the programmer if that is thrown. which leads me to my next tops for discussion. Using unit tests. When you have something this "complex" having unit tests in place is a must. There are scores of papers and blogs and books out there as to why and how so I'm not going to elaborate on that. I will however show a few examples. A tip I've learned about unit tests is that they should be neat, small, and fast. To know what to write a test for take a step back and analyze what you want to write. Can it be pulled out into a class easily so it can be tested in isolation. In this case yes! However because of how this is written pulling out things into a proper class can be tricky. (because it was so tricky I moved on to something a little easier to show what I mean) NumberDisplay (and by extension TimeDisplay) is a good example of a class that does too much and can easily delegate its work to something else. What's more you can take that work and put it in a unit test. NumberDisplay does a lot of math to just display 3 numbers, to what is essentially just a number format. We can use that to our advantage thinking of it like that. Make a NumberDisplayDigitFormatter that extends NumberFormat it will have a matching test in the test folder. NumberDisplayDigitFormatter 

A better way of checking visibility would be to use the function in conjunction with the selector. Here's my revision. I took the liberty of renaming the parameters. I also used the common practice of naming jQuery variables using Hungarian notation. 

I'm sorry this is so short, but I only have time to give it a quick once-over right now. The first thing I noticed was the flickering of the cycling icon as I scroll through the bottom. Compared to the rest of the application, which looks great, this was awful. This is happening because you are assigning the to the on , which doesn't make much sense. If you move this initialisation to a handler instead, the flicker will be gone: 

For conciseness, you can replace the second block with the following, if you think it's still acceptably readable: 

I just want to highlight your - chain. You should stick to one style. I understand that you want to put in a comment, but this should not cause you to uncuddle the . You can put the comment on the line after the instead. Also, this function needs to be documented. I've read it over twice and I can't understand why an item has to be to count as an item. It doesn't help that you didn't actually use the form ever. Anyway, I'd rewrite it a bit still: