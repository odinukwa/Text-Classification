OK I am not going to say its totally wrong. But I think you should set up member variables in the constructor before calling member functions. Currently the state of the object is random (for POD values) and member functions assume (especially public facing ones) assume that the state of the object is well defined. Now using member function to set the state is OK (if you have a couple of constructors and some large piece of common code). But I don't think this falls into the same category. So I would initialize the members then call . 

I have always hated the trick. It is so unreadable and you only really know what it is doing once you have tried it a few times. Also in this case it is totally unnecessary. When a stream is used in a boolean context it is automatically converted to bool (by the same method that the first operator uses). So the code works just as well written like this: 

You seem to have header guards in a source file. Only add these to the header file (I assume this is because of pasting into website). Also they should surround everything in the file (include the #include). 

Be consistent with you style: In yout first two function you use the style of putting the brace on the next line. 

By creating the array like this, the rest of you code does not need to have a special case for NULL buffer. The code just looks the same. Now that looks very similar to your other constructor. You could potentially just combine the two. Prefer to use the initializer liest (even in the copy constructor) 

This is enough to hold the terminating but nothing else. You probably want to hold a longer string try. 

If your primary goal is the shortest program. Then you can use regular expressions for a much shorter program to find primes. So in python it looks like: 

Code Review Please specify parameters. Please provide parameter names even in declarations. It helps understanding what your code does and is part of the "Self Documenting Code" principle. 

I would make the structure a private implementation detail of stack. That way other people can not rely on that detail when they use your code. 

This is better but it sort of defeats the purpose of using algorithms. If we had used the loop it would look like this: 

The first thing to point out is that you are passing the parameter by value . This means you are copying the parameter into the function. This can be expensive (especially with strings and vectors). Also you are not mutating them so much easier to pass by const reference. 

Every time you encounter a path to a destination node you update the destination node with the shortest distance. But this also means you have to re-sort your whole priority queue each time you change the distance. This is not very efficient. This is why the destination node and distance are supposed to be stored together in the priority queue (sorted by distance). Then you will always find the shortest distance to a node first. Then duplicates will be quickly removed by the . Checking the flag here is an optimization that I don't have in my example (that can be added). But putting it here is not enough. You also need to check the flag before you start processing the current node Otherwise each copy on the frontier list will push all its children on the frontier list thus growing it exponentially. 

noexcept You should mark the function as no except (it is noexcept) but it makes using it from other functions useful (like move constructor and move assignment). 

Global variables are bad. Don't do this. They make the code hard to test. Side affects will cause problems. Prefer return over out parameters. 

There is technically nothing wrong with this code. But missing braces can potentially lead to very hard to find bugs (especially when there are C macros around). So just to be on the safe side always use braces around subblocks (its a good habit to get into). 

You don't update current (so it points at the deleted node). You allow the sentinel to be deleted. If you delete the last node the easy insertion/deletion breaks down. 

By putting srand() inside the structure you are opening it up to be called multiple times. Call it once just after main() then don't call it again. When you can use the standard tools: 

That is a relatively trivial hash function that is known to have a bad distribution. If your keys are the same length you are very likely to get clashes. 

Why not have a move const for vectors? The Constructor that takes a string foes a lot of validation. Why does this constructor do zero validation? This constructor requires that you move a string (or provide an r-value reference). But you don't actually move the string you still make a copy!! 

You now have a pointer to an object with the ref-count incremented to +1. If you now put the pointer back into an intrusive pointer the count will increase to +2 and when that goes out of scope it is back to +1 and will not be deleted. Personally I think you should still decrement that reference count, but not delete the object if it reaches zero. You still have to remember to manually delete the object when you are done. This also mimics the behavior of the other types of smart pointer. In addition to the cast to the pointer. 

The standard containers (that support pop()) return a type. This is because there is not a way to implement an exception safe that returns a value. That is also why they have . So you can get the value with . Then do an exception safe . 

The creation of the unique_ptr here already creates an you do not need to call to convert it to a for assignment. 

Issues (for me) I get a couple of errors when I try and compile. This error I have a feeling is caused because you are using a more up to date compiler (I presume this is a C++17 feature). 

If the constructor fails then throw an exception. Error Codes Error codes are great inside your object to indicate error states internally. But error codes should never escape your public interface. Prefer to throw an exception rather than force the user of your object to check an error code to verify correctness. These return error codes. 

But you have not inherent ordering on the array so you can make this a lot less costly to do (but you would need to invert the above loop so it counts up rather than down). 

Your problem (as you stated) that the parallelism is uneven (the lower outer loops is doing more work than the higher values of the outer loop). But why not combine the two loops. 

When the last line does not have a '\n' character the return value will be -1. Which means it will not be printed because the main() function has. 

Here you should do a swap (or close the current socket before overwritting). Because your current object may have an open socket; you want to place the current into the other object so that its destructor will call close on the socket when it goes out of scope. You should prefer the swap to a manual call to to make sure you move constructor stays exception safe. If you do the manual close you should also remove from the move assignment operator. Currently you are leaking an open socket. Init/Destroy on Zero sockets. Do you really want to init and destroy the socket layer every time you reach zero sockets. 

For non pod types this is because the object are constructed before the body of the constructor is entered then the constructor code is applied. If was a non pod object that means you would first be constructing it and then applying the assignment operator (ie initializing it twice). For pod data it makes no difference, BUT does no harm either. So it is a good habit to get into. Because that way of the code is later modified to be a non pod type (i.e. CharUTF) then doing it the prefered way keeps the code optimal. Not a fan 

Looks like these should be static const. They are valid for all members. You don't want to initialize them more than once and you don't look like you are going to modify them. 

Even though you pass around a pointer to a pointer (for re-alloc I assume). You don't actually do any reallocation. So I would simplify the code and just pass a pointer. 

But you will need const versions of all these (and a type) to be a fully compliant container. You are going to have a hard time making this work if the buffer is of type T. Every time you expand the buffer all the elements in the buffer will be initialized with constructor. For this is not a problem. But if has a non trivial constructor then you are going to pay a heavy price initializing elements that may never be used. 

You should either update to take the function by r-value ref or change the take a normal ref (to be consistent). Personally I would pass the r-value ref through to the . 

Interestingly this also allows you to sort any type (not just integers). As long as your type supports the comparison operator. The standard library tends to implement any comparison in terms of so to avoid confusion with potential users you should implement your sort using the less than operator and potentially allow the user to specify the actual comparison operator. 

a) Why not have a constructor that takes the two parameters to do the initialization. b) Who owns the object. The owner is the person responsible for deleting the object. c) If you had stored normal point objects in the vector this would not have been an issue. 7) This is just a tad nit picky: 

The best case version of bubble sort is . You only need to do a single pass over the container if it is already sorted. So you should track if there was a swap on a given pass and exit early if no changes were made. Secondly both loops go from . The inner loop does not need to cover the whole container. Each pass you have moved at least one item all the way to the correct location. So the next pass you don't need to check that item. You do some manual swapping. There is a built in in the standard that allows you to swap to object optimally. 

Like the destructor. I would destroy the members in reverse order (so it behaves like the built in array). Bug 1: Does this loop terminate 

You are using a Sentinel at the beginning of the list, but this is not really needed. Sentinel are very useful for double linked list but don't make things easier for singly linked list. Your code will be simlified by removing it. You can make your code simpler by moving the initialization of the node into its constructor. The destructor can be made simpler just be running accross the nodes and deleting them. There is no point in the extra work in pop() to keep the object in a valid state. 

Singeltons and copying You don't want your singelton copied so disable the copy and assignment operators. 

If you change the code to use (rather than std::cin/std::cout) you can get even better performance. I did some experiments and reading a line and parsing the line separately improves things even more. 

Your naming of variables here makes this code unreadable. Make your variable names obvious. Don't re-use variables. In the above code it looks like diff is being used for two different purposes (or is it not?). Let the compiler optimize out the extra space you should be making the code clear. 

Yes every crappy book on C++ has this line. Once you get past 5 lines programs it becomes a nuisance (technical term ). So get in to the habbit of not using it. There are a couple alternatives (read other C++ posts on this forum) personally I prefix anything in standard with std:: (i.e. std::cout) Global Variables are not a good idea. 

But you don't check the error codes. The object is potentially created with invalid members. Use exceptions to gurantee the state of your object. Destructor does not do anything useful. 

Here has mem-copied the part over from (So no constructor was called). You probably want to move it. Also the assignment operator does not work. Apologies to @Rapptz (now that I have dug into this I understand the complexities more). I still don't believe the code was correct, BUT @Rapptz did spot the depth of the problem long before I did and was working towards a solution.