First of all, your code is working, which is a good thing. However... for any seasoned D3 developer your code is somewhat weird: it's not idiomatic and it has some strange patterns (which will make your life harder in the future). Here I'll deal with your 4 bullet-point questions together, since they are deeply interconnected. So, let's first see the major problems: 

Your code is certainly improvable, and several changes should be done. The main problem, that immediately comes to attention, is the repetition of the code. However, the problem here is not (only) the DRY issue itself... the problem is more fundamental, regarding D3 best practices: since you have two data arrays (which are almost the same), you're binding different data to different selections. Because of that, you're bending over backwards to do some simple tasks, like creating the tooltip (I'm the author of the answer to your previous question at S.O. regarding this). So, let's get rid of those repetitions not just because they are repetitions, but for having a single data set which we can bind to a single enter selection. Here are the steps: 

The enter, update and exit selections The biggest problem with the enter/update/exit pattern in your code is that, when you create the stacked chart, you append elements, but you don't remove them when creating the bar chart. So, you actually don't need the exit selection for them. The same way, since this is D3 v3, you don't need the update selection for the bars. It's a good idea keeping this selection, though: this is an incorrect pattern in v3, which was corrected in v4. This use of elements in the stack chart and just elements in the bar chart is not the best option. You should deal with groups in both of them, or just rects in both of them. That way, you could create more constant transitions, which would have the same behaviour in bot layouts. However, this would be a major refactor, which is out of the scope of this answer. Also, since your bar chart right now has less bars than the stacked chart, the bars naturally expand to the right hand side. So, to give the transition more fluidity, I'd set the exit to the right hand side... 

My answer here will focus on refactoring the function. Right now that's an awkward function, with some unnecessary logic. Let's examine the it: 

... and use it to fill your rectangles, with method. Don't call your scales and . Use more descriptive names, like and . Doing that, you avoid confusion with the and methods which are very common in D3, like in line generators or area generators, for instance. Use in your domain: 

That being said, my proposed solution is: use regular functions. So, in your code, I put all the drawing parts inside a function... 

Before answering your question, here is an important advice: name your selections. So, instead of this: 

That's a pretty good code for a first attempt with D3. There are some considerations, though. First of all, if you have an condition testing the size of the input, it's a good idea writing the . For instance: 

Therefore, you just need to sum all elements, then subtract the smaller one to get and subtract the biggest one to get . So, here is yet another solution, without any : 

Well, I am the answerer that gave you that advice on S.O. The reason, or reasons, are actually quite simple. Right now, every time you change the dropdown menu, you call the function: 

That way, you can easily rebind data, create transitions, filter, translate elements and several other changes by just using the selection's name. Back to your question: The most idiomatic way to substantially reduce the amount of code here is using , which, according to the API: 

Here, is just a boolean to check if the function is running for the first time. Finally, I'd remove the transitions from the x axis, they are quite distracting (because of the ). Here is your code with those changes: 

In the linked Plunker, which uses a real CSV, you get the result of the promise and pass it to the function. So far, so good. However, inside that function, you're calling another function, named , which gets the selected value of a element. Then, based on that option, you're coercing only some values of the data array to numbers, but keeping the whole structure of the data array (you're not filtering or anything like that). The inside is also strange: you don't need to return the object row. Also, the third argument, , is probably a reminiscent of the third parameter in the : in a method the third argument is not the array of headers. Continuing, you're using a variable (which is always after the user changes the select) to choose what functions to call, and finally setting a listener to the select that never listens to the value of the select! It just calls again... This is my proposition to simplify this function: 

The coerces all the values, except for ; You call the drawing functions with the data and the teams; Since you know what values you're using for the first time, I just hardcoded them. If you don't like that just use another selection to get the selected option (again, hardcoded!) You use the listener to get the value of the select with , and call the update functions. 

Back to your question: Indeed, you don't need to reference the array by the indices, which forces you to sort the data array and then to sort the resulting array... that's not only confusing and error-prone, but also very computer-intensive for the browser: sorting big arrays of objects can take quite some time. It's a good idea avoiding sorting, specially because, as we'll see, you don't need it. There is a way to omit that step, making it automatic. Better than that, you can make the whole thing automatic! In my proposed solution, you don't even need to set the keys, as you do right now... 

You'll have to re-select the bars, but that's not too complicated. Also, mind some minor details: there is no attribute for a SVG rectangle. Also, your data contain strings, not numbers. Change that (you can change the data itself or you can use an unary plus, like I used to merge the rates). Here is the refactored code: 

You're binding the data to the SVG in an enter selection, but you never use it. So, just append a single SVG, without binding any data to it. Drop the and the functions. If you want to create a single drawing function, which is a good approach (regarding DRY), pass just the changing data to it, avoiding repetitions (the scales are always the same, for instance). But in a chart like this one such pattern is unnecessary (have a look at the in my last snippet). You're binding a single array of numbers both to the lines and to the circles. Instead of that, just filter the array accordingly (or create two separate data arrays, as I'm doing here), and bind the whole array of objects to the circles and the path (which brings us to the next point). That way, each element has a datum with all properties in the object, that we can access easily. More importantly, that way you don't rely on the index of each element in the array as you're doing right now and which is an inadequate approach. Don't append a bunch of elements to create a line chart. D3 has line generators that you can easily use to create a element: the whole line will be a single SVG path. This is way more convenient, and on top of that you can use curves to smooth the path. You have time in the x axis. However, you're converting the date objects to strings and using a point scale with those strings as the domain, which is probably not the best practice. Treat time as time, using a time scale, unless you really want to treat each individual moment as a categorical variable (for instance, when the time span doesn't matter and you want the space between the ticks to be the same, regardless the actual time). 

It's not necessary, you can do the same using regular functions (see below). The main reason why it is not needed is that, despite the fact that you have two events, and , you just need one, since you already have the necessary enter, update and exit selections, and their proper transitions. It's not idiomatic and adds needless complications to your code. Because it's not idiomatic, it will make harder to other D3 programmers trying to understand/maintain your code in the future. It creates a lot of duplications (in my solution below I saved you 100 lines of code, going from 379 to 279 lines).