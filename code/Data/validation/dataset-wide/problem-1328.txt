it is called many, many times the while loop iterates many many times there's something else you're not showing. 

This changes the value that you are returning though.... but... what was the requirement? Was the requirement to get the number of steps to go from the first to the second, or the number of in-between nodes you have to visit? If it was the number of nodes you have to visit, then you have two places where the result is 0, when , and also ... In a general sense, I have never encountered a reason why there has to be a full loop-count when the Finally, what if you are going the long way around? For example, what if someone does this? 

You have been overly enthusiastic in your type declaration for , I think, and it should just be removed. Also, there's no real reason to make it an . A simple will do fine - and you're probably on a 64-bit platform anyway. 

Note how I create a even though the input is a String constant? This is deliberate so I can use reference equality () on the check, and guarantee no collisions with some other String. Let's put that pill on the class which is the coordinator for the other classes. Now, back to the Reverse thread's loop... The 'industry-standard' way of coding the loop in the reverse thread (using the new poison pill): 

Apart from that, the immutability looks fine. Good, even. The package name you have chosen though... is lacking: . You could not name your package something better? 

Your strategy of counting the spaces and then back-looping to shift the characters right (and replace spaces with ) is good. The basic algorithm is probably as good as it gets as a character array system. Your variable names are decent, and the code flows well. On the other hand, there are some small things I would change. Possible bug Your code, given the input you would output but you should not remove any "extra" padding in the string, you should return In fact, you should only really have the one array. The second one is making you do bad things ;-) Enhanced fors Use enhanced-for loops when possible, and always use blocks for if-statements, even 1-liners: 

My assessment of the code is that, as a Util method, it is poorly named too. The methods are not self-documenting. I read , and with two lists as inputs, where is the Id? What does 'updated' look like? I am at a loss. What I can say is that there is some black-box function that does some update, but, does it manipulate the data in first, or second? Why is 'second' specified first? Why is it not: Also, why does an function return a value, and not update something? it should be called or just . Or, does the function do both? Does it update values and also return values? Yuck!. The function. Does it subtract the first value from the second, or the other way around? I presume this method has the signature: 

Your code has a for-loop with a nested while-loop. Typically this would indicate an \$O(n^2)\$ time complexity for your solution.... but, your code is only actually \$O(n)\$... how does that happen? Because you do for-loop control variable manipulation outside the for-loop control block. This is a bad practice. A for loop has three control statements: . A for loop is designed to have those three mechanisms in one place. In your code, you have split the logic of the stepper in to two places, which makes the for-loop hard to read, and unconventional. Your variable is stepped, and also you have later in your loop. If you cannot implement a clean for-loop structure because your code demands some other mechanism, then you should instead use a while-loop, or find a different way to express your step-process. Bhushan has provided an answer which solves the problem, but does not implement a clean break-processing loop. His code implements the logic check when leaving a clump, rather than when entering the clump. If you do the check when the clump starts, the logic becomes much simpler: 

When converting time values like this I find it much simpler, and more readable to work up from the smallest units. Consider the following: 

You need to identify the complete word, not just the word fragment. You may be dealing with large files, and your mid-point is at risk of overflow errors. The code: 

Suggestions Right, the first major suggestion is to consider the use of protected constructors for initialization, not using an initializing method. Next up, you should be using a as one of the constructor arguments that can be used to populate the pool (instead of having an abstract method) (also, you may want to actually implement the interface yourself - it may be useful for others - consider it later). Instead of having a dedicated system for "monitoring" the pool size with a scheduled thread system, you should rather have hooks on the borrow/return side of things to trigger asynchronous pool modifications/alterations. Finally, you should implement the queue inside the abstract class completely, and not expose that to higher-up implementations of the class. Restructured Having said all those things, here's a "different" way of implementing the pool... First up, the basic interface if you want to separate it out in its use contexts: 

This function has very slightly different boundaries, but you may find it does better than what you have right now: 

That sets up a set of data tags. Now, we create an instance StringBuilder... to cache the characters when they come in: 

The most logical solution to this problem is to do a BFS (Breadth-First-search) and then determine the size of each level as you get to it. Your solution uses a depth-first search and tracks the results in an array. But, to create the array, it has to calculate the depth too. If you have to do it that way, then you should calculate the values in an ArrayList instead, and avoid the height calculation first. The breadth-first algorithm would be simple: 

If you choose a fixed row size that is also a power of 2, then you can accomplish the same with bitwise operations. A row size of 256 elements, is implemented as: 

That's a pretty short list of nit-picky things. In all, this is a good program. There is one suggestion I have for your recursion, and that is that there are multiple 'styles' of recursive methods. If you choose one method, and use it consistently (except for those times the other methods are better), it helps. My suggestion is that you should settle on what I call optimistic recursion.... which is the opposite case of what Wikipedia calls 'short-circuit recursion'. What I am saying, is that 'standard' recursion checks the recursive state, and, if it is valid, it does it's work, and it then calls recursion. The short-circuit system does the state-check of the new state before recursing in to that new state. By way of example, a standard (what I call optimistic) recursion for this problem would be: 

Lock Free is consistently performing faster than the alternatives when more than one thread is accessing either end. 25% faster would be about the right ballpark. Here's the lock-free code. Note, instead of using an array, it uses a linked list (calling it an is a bad name - I agree): 

Conclusion: I figure your code is close to right, It may not be worth breaking it. Adding a CDL would be a pain to do, but the code for the parse would be much easier to manage. My money is on the system-change to store the parsed fields.... ;-) 

If you're interested in better-performing options than that, I suggest writing up some benchmark tests and using those to improve the performance of the method. See benchmarking notes here: $URL$ 

Then, what you need to do is make the actual KarpRobin class more 'stateful', it knows where it is in the search, and it finds the next match each time. The code should be fairly easy to copy/paste from your current code. 

you double-nest the synchronization on in the method . your method sets to , but it was already , so your does nothing, actually..... ;p you don't have enough functions - your existing functions do too much. 

Your question would do better with a more detailed description. The way I understand your situation is: 

Your algorithm is very sub-optimal. Essentially you take a copy of the input array, then you randomly pick an index values, making sure you have not yet picked that index. Once you have randomly selected the indices, you then copy the data back from the temp copy, back to the input array. The bottom line is that you loop through the indices once, and, for each time, you check to see whether you have already selected the index. This is a \$O(n^2)\$ operation, with an unlimited down-side..... you could possibly be sitting there forever guessing index values that have already been selected. This problem has been studied many times, and, by general agreement, the Fisher-Yates shuffle algorithm is about as good as it can get. It is an \$O(n)\$ algorithm (time complexity), and it takes no extra memory space to run (\$O(1)\$). Do some searches for shuffling, and you will soon arrive here: Fisher-Yates Shuffle. That algorithm is proven to be optimal, and as reliable as your random number source. Use it, or understand why your algorithm is better/different before you re-invent this particular wheel. 

Finally, for code reuse, it is often important to extract your functionality to a single reentrant method, other than the main method. Consider a signature like: 

In many cases, the simple solutions are... simpler. In this case, your solution of splitting the data on space , and locating the longest word, is accurate, but a simpler solution was probably intended. As an up-side, the simpler solution is actually better in terms of time-complexity (it is \$O(n)\$, which means the performance takes twice as long if the string is twice as long. Other solutions take more than twice as long if the input data is twice the size). Bug: You have a bug in your string clean-up too, because you strip all punctuation, and replace it with the empty string , you are vulnerable to input like , and you will identify that as one word: . If you set the replacement as a space , you will be OK. Note, this solution scans the data only once. Other solutions require that the data is scanned multiple times (once to split, once to sort). 

MergeSort is a nice sort algorithm because the concepts are relatively simple, even the recursion makes sense, and it all just 'fits'. You have done a good job at describing the algorithm through your code. Putting performance aside, I think you did a good job. Small items to consider: 

the pattern is more obvious. Also, since the algorithm is \$O(1)\$ time complexity, you can do things like: 

The indicates that should become , and so on, but should become . This allows us to then make the "simple" nested loops: 

Now, is a value which may not be easy to translate directly to an integer. For example, because of floating-point inaccuracies, the intended Q factor may be 5, but the computed one is 4.99999999997 or something. 

Again, that makes the logic clear, no need for a comment. I believe that has now eliminated all of your comments..... and replaced them with code that does not need a comment, because the code is self-explanatory. In other news, if you had more functions, with good names, then your code would be simpler to read as well. Bottom line, though, is that the comments in your code should fill in the blanks that your code does not. In addition, your comments should give details on the motivation, and not the application of your code. You should, in general, comment only on why your code does things, not what your code is doing. That leads on to the other comments you are missing... JavaDoc. JavaDoc is documentation that should explain what your code does at an abstract level. You have no JavaDoc, and you likely should. JavaDoc is where you describe what your code does, because, typically, the people reading the javadoc are not reading the code, so they need something else to tell them what the code does. 

Using that mapping, we can look for sums that have cross-references... We can loop through just the sums of the factors, and for each sum, in their set of input values, see if those values exist as sums of other values. If they do, then see if the original sum is one of them.... This makes sense if you see an example: 

Will your input files change in the middle of your application running? If not, a better solution would be to read the file just once, and keep the lines in memory until needed. This will significantly improve your performance. This can be done really easily... but first, there's a much simpler way to read the lines of data from a file: 

As for whether there's a better way/algorithm, well, for a LinkedList, like you have, then no. The scan to locate the insert-point is needed. Finally, you should only create the if you actually locate the insert point. There is no need to create the new node unless you are actually going to insert it.