Can you find the one difference I made between the first GetSpecString and the second? How long did it take you to find it? This was done to prove a point of course, but imagine if you, in all your wisdow, edited the first spec string, but forgot to make the same change to the second. Now you have two possible 'routes' your code can take, and it will take you forever to figure out why. Something like: 

I've done my best to refactor your code in such a way that you can use it to learn to improve your coding, but also in such a way that it all makes sense. I'll post it and then explain the process and some tips. The Code 

The beauty here is that not only will our code raise an error explicitly related to the source of the problem, but we also have a very modular way of adding additional support. For example, if we wanted to support a worksheet (for whatever reason) we would want to update the error message, and add just a bit of additional code: 

Currently your code cuts too many corners. Even with the assumptions that you're willing to make, you can't seriously search through the directory without specifically looking at the first byte of the 32-byte entry (at offset 0) and at the file attribute byte (at offset 11). Looking for the ASSET directory: 

Your comments certainly explain well enough the purpose of the code, albeit this one (; Preserve ESI) is a bit superfluous. What would greatly enhance the readability is you writing tail-comments in stead of whole-line-comments 

Each time you clear a register (any general purpose register!), you can do this more efficiently by ing the register with itself. 

A small error here. On exit with Ignore the register will hold an uppercase J. My main concern here is why you want both the register and the ZeroFlag express essentially the same thing? If you would stick to only return result in the ZeroFlag then you could save extra bytes and at the same time get rid of the , , and registers being modified which is a good thing. 

Admittedly, this is uglier than Mat's Mug's approach, but this is the approach I use because it suits my style and needs a bit more. The benefit here is that you can choose your approach to handling the error. So, for example, handling an error in the routine can be different than handling an error in the routine. I also avoid statements as much as a possibly can. There isn't anything wrong with them when used well, but I try to anticipate errors if I can. On that note, and as others have noted, some of your subroutines need some cleanup. Someone in the RD group recently reminded me of the 'Single Responsibility Principle'. Everything should be responsible for one thing, and in turn, that thing should align with it's own intent. Along these lines, I would argue, that one unique thing should only ever be returned by one owner of sorts. For example: 

In the binary search, when a good value (that is when valid returns true) is found, your code doesn't save it before trying to optimize it further. 

Limit the loops iterations from to . This will make you avoid some unnecessary checks. Only try to get the 4 numbers in the forward direction. There is no need to check in the backward direction as well since it's already checked in the forward direction. 

Optional.map produces a cleaner code. It's similar to flatMap except the function inside doesn't need to know about Optional. Also passing method references makes things a little bit shorter. 

The method name is not really readable, also the variable names and are not expressive. So I would rename it to something like. 

, now if the distance between the stations is and mid is , the result will be 2, while you really only need to add 1 gas station. What you really wanna do is to get the ceiling of which will give you the number of pieces of length , then subtract one to get the number of gas stations in the middle. So . 

Looking at the code I've just written above, I don't think there's anything ugly about it. It's the cleanest way to do it, and overtime it'll prove that it is self-explanatory. 

On FizzBuzzGo the number of divisions was reduced by 49 percent. It is very easy to turn this binary tree into something shorter that doesn't use any conditional jumps. I decided however to not keep it because I feel there's at least some contradiction in branchless binary tree. Moreover it was a bit slower. 

This procedure must process bytes (you raise the addresses by 1), but you read and write words! The test to see if 16 bytes were processed is too complicated. All that is needed is testing with 15. 

Decrementing counters. Given that the output is to be redirection friendly and that the matrix on the screen shows up filled column wise, adjustments to these decrementing counters are necessary. These adjustments account for the missing decrements due to the step when going to the next column. The numbers aren't processed in natural order. Hence. Instead of decrementing I could have used incrementing on the counters. Usually (1) doing so requires an extra instruction that will certainly add to the code size but not necessarily slow things down. (1) It's possible to avoid the additional while still incrementing when we start from negative numbers and move towards zero. 

Great job overall writing organized code with nice test cases. I agree with using exceptions than returning a fixed arbitrary value. Also, good job trying to choose an appropriate exception type and writing meaningful messages. Below are a few comments and slightly modified code. Suggested Variable Naming Changes 

I think your algorithm is fast enough to get accepted. Contest times are sometimes not well calibrated for python speed. One part that could be optimized is splitting the string and converting it to integers, which is now creating a new string for every number, possibly up to \$10^5\$ strings. Since the string is always gonna be 1-digit numbers separated by spaces, you could instead iterate on the string without parsing it or converting it to integers. Something like: 

Input Using magic numbers like 48 and -16 makes your code very cryptic and hard to understand. Consider comparing with the characters instead. Algorithm / Logic I think two things that could really simplify your code are: