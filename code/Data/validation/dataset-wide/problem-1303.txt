Improving performance by using native methods whenever possible Another thing you'll want to consider if you're worried about code performance is whether you can replace any of the jQuery shortcut functions with the analogous native methods. For example, will always outperform , and assuming they're supported by the browser and will always outperform . and can be called on any element (not just ) so you can also replace jQuery's method for similar performance gains. The native methods will also increase the verbosity of your code (and thus the number of bytes that must be downloaded), so take that advice with a grain of salt; personally, I find that the dedicated native methods also make the code more readable and thus maintainable. 

If you need to have the output in an array format for other reasons, such as sorting or mapping, that might outweight the benefits of the hash key object. Here's a snippet demonstrating using an object with hash keys instead of an array of objects: 

Selecting elements by ID When obtaining a reference to an element by its ID, it's more efficient to use than . Instead of: 

The performance benefits vary depending on the browser's implementation of ECMAScript, but you can usually get a modest performance improvement by selecting the parent element first, then selecting only child elements of that parent element. This jsPerf test somewhat demonstrates the difference. In native JavaScript, this is done by selecting the parent element with , , or . You can then call a similar selector method on that element instead of on to limit your search to only child elements. Native 

Note that in the above example, each time the bot talks is represented by an object with a string property and array property, and each object in the array is formatted as with representing a new question from the bot. This is recursively traversable so that you'd only need one common function to read a question, write it to the chat history, and display the possible responses. One benefit of this is that the data (your questions/responses) is separated logically from the view (directly updating the DOM with HTML and text). You can change or improve the way the questions are displayed without having to reformat your data. Here's a barebones proof of concept: 

This brings me to my next point... Date objects can be compared directly Instead of comparing hours to hours, years to years, months to months, and so on, you can compare two date objects directly to see which one comes earlier or later. You can even subtract one date object from the other to find the time (in milliseconds) between the two dates. The code below will populate the variable with a number representing the number of days since the sale started (assuming is the sale's start date and is the current date). 

This gives us a few nice advantages. Remember how earlier I said you could store the current day of the sale in a variable? Well, you could use that to access the corresponding day and list elements without having to create a bunch of statements. Your final method might end up looking like this: 

More reading on Object and Collection Initializers. Get SharePoint list: Don't blindly use , it depends on the number of lists you have in your environment what call you should use. Using , SharePoint will look for all lists in the current web-object and fetch all metadata from them. Then it compares the name you provided and return the correct list. And will make a call to the DB for each list for which info is needed. If you have a lot of lists (thousands), use the second method, otherwise the first will normally score better. Also, this depends on the performance of your hardware. But in general, I tend to avoid the indexer (using the second method or even ). The foreach loop: You have this piece of code: 

Your implementation is not bad for a no-LinQ solution. But there's always room for improvement. First I'll provide a LinQ solution that provides a clean way to return a chunked list: 

Person Split user-input from your class definition. It's not a good practice to mix the input in the definition. Try to decouple as much as possible. I also redefined the properties in the class: 

According to the above method, the rover is dead from the moment the variable is greater than 0. But when you're moving the rover, you're subtracting the change from the lifetime, making him more and more alive. But you can't make him more alive since he will be dead from the beginning when you give the rover a lifetime of any positive number. This doesn't make sense to me. Rename the variable to and use the property suggested by mjolka: 

You could create a new class in which you define all sorts of methods like these to process a result and return it to the view-file where you will show it on the screen. Hope this clarifies it. :) 

and can even be shortened to simply this, because you're simply returning a boolean corresponding to the value: 

Using variable names like and are very bad practice. Not only will other people not understand your code, if you haven't looked at your code for a while, you might have forgotten what each variable does/stands for. Give your variables a meaningful name. So after applying this, your code looks like this: 

I would not over-complicate the matter by splitting it up in several models. But if you want to stick to the choice of splitting it up, I would define an base class and create a and model. Because in the current situation I find the naming not 100% clear. Certainly because (which sounds generic/basic) derives from (which is specific). It should be the other way around, a specific class should inherit from a generic/basic class. Here's a rough implementation: 

See how the other names make more sense? Try to avoid verbs as a classname. Methods can and most likely will be or contain verbs, but not classnames. Also, leaving the query out of the class leaves you the option to use the same code for other queries. Note that this is no perfect code, I was only suggesting what might be changed. Hope this helps! :) Edit: You call the function selectData() and pass the query-string as a parameter. This changes nothing, it gives the same result as your code. Only in my case you can pass other queries to the function whereas your function is limited to the embedded query. Now for the result. This has also to do with the decoupling of your connection-class and what will be shown to the user. I showed u the usage of the class, the code below is how you can process the result. Create a function (but not in the connection class!) that returns the result in a table: 

Here's a working example of the function, along with the function that I use to attach it to the mouseup event on row elements. 

getUserInput() You're missing the keyword before defining the variable . There's no reason to define variables for , , , , and , since you never reference those values by name. You can just populate your array directly. 

Here's a working snippet that demonstrates another method of using closures to maintain live references to HTML elements. 

For some browsers, the performance impact is significant. For reference, here's a relevant JS perf test: $URL$ Avoiding Unnecessary DOM Queries You did a good job by caching (that is, saving to variables) most your query selections up front. This is much better than querying the DOM on the fly every time you want to access those elements. There's only one spot where it looks like you're querying the DOM unnecessarily, inside your function: 

Note that there are also native JavaScript equivalents for manipulating HTML within HTML elements (such as and ). Table elements in particular have their own special properties and methods for manipulating their layout and presentation, as documented here. Cache reused HTML elements and collections to limit DOM queries If you have code that queries the DOM using any of the selector methods I mentioned in the above section, you can save the results to a variable that you can access at will. That way you don't need to re-query the DOM for those elements if you need them later in the code. The exception to this is when the DOM may have changed and you want to get the latest version, in which case you generally need to re-query the DOM. Avoid polluting the global namespace You can avoid creating global variables by simply wrapping all your code in an immediately-invoked function expression (IIFE). 

The pattern for dealing with asynchronous dependencies is to move your dependent logic forward into the execution chain. This usually means passing callback functions to your asynchronous functions. You're handing off the responsibility of executing the callback function to the new function ("Hey, you're in charge now; do this other thing once you're done.") 

How and Why to Avoid setInterval In general, it's best to avoid if you can help it. The primary reason is that has the potential to keep issuing more calls to the specified function while the function code itself is being executed during a preceding execution. An extreme example would be a case where the specified function takes a full second to run, but the interval is set to execute every 100 milliseconds; in such a case, by the time the first execution is complete, ten further calls would waiting execution. This isn't an obvious problem when you're working with large enough intervals and synchronous code, but long-running functions (especially asynchronous or looping functions) could lead to unexpected behavior, so it's best to break out of the habit before it bites you. A decent alternative to is to use . Within the function passed to , you can decide whether or not to repeat; if you want to repeat, just call again. Here's an amended version of your function, with an additional function to be used in the call.