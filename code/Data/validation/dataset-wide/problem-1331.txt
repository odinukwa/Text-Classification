And now, a line is gone and your code flows naturally and doesn't abruptly exit the function. Finally, this thing where you put your 

You don't need to explicitly call or any such non-sense. When it exists the event handler function(s) it will save for you You would stay the same but your would become a spring CrudRespository - the implementation is trivial. You can actually look here for an example. With this, you can: 

by shifting the digits left, performing your digit selection and bucket sorting, then outputting them back in decimal form? Like, take your random set and first convert all of them. I would expect better overall execution time. 

I would also suggest that you might be able to make use of Java 8 streams to improve your performance on large numbers. 

Here is how I would simply this: First, I would create a reduced method for getting "body" in fixture as such: 

Craziness? You only need to do this if you want to assure yourself (or the compiler) that it won't be reassigned. This is hyper defensive and, in 15 years of writing code I have never found it to be a necessity. Frankly, 'final' in this case is repetitive and distracting. Unless you have a need for it (which, from this code, you don't) then ditch it. this: 

Use Statements.... Or not, if not... this is probably as optimized the code is going to get. Here is my rendition of what your code will look like if using switches instead. I just switched the regular flag enums, although you'll probably want to bitwise OR them with the rest of the values as you were doing in your OP 

I was able to compile and run using , perhaps I wasn't using c99. So perhaps just don't use c99 :). If you have to use it, then declare those ints as symbols or consts above , then you can say 

Make sure you are disposing(closing) your database object. I presume by the way you have your class setup that when your database object is disposed it will close, in which case I would recommend using the keyword. Which would make your above code look more like this in practice. 

However, now that you have actual code to review, I will also point out that there is no reason to be using a loop vs a loop. I would write that as follows. 

Get rid of the REST/persistence/dao layers you have Refactor your services to use the Spring Data events So you're would become an handler for the looking like this: 

Your variable names mean zilch to me. You HAVE to give them a better name. Also, create them up in groups of 2. This code here is also problematic. 

Ok, yes that is 80686 assembly but you get the point. It's a branch and function return. All, of course, my .02 USD 

And literally the only thing you need to do is implement business specific event code. The caveat here is that, by default, spring is going to produce a data format called - if you have a requirement to certain output formats you can create and register a and register it for and remove the one defined for 

You're using ramda for currying and nothing else? Ditch it and implement your own currying; it's not hard. Since usability is of a concern to you then making this an actual nodejs stream would be hot and also not difficult. Integrating it with iterators/generators would be handy A more natural usage would be 

Edit: This is of-course personal taste, but I dislike (what I consider to be unnessary brackets taking up newlines). 

Contact and ContactItem should in some way be child and parent, or at-least share a common ancestor so that you don't have to manually copy over all that identical contact information. I'm not certain, but I think you might have wanted all this to be done with the and not the of this contact. You should be using in-case these strings haven't been trimmed or something. As for simplifying your nest of ifs there are two solutions that fit the program as is. 

Because the TryParse method returns a bool you can just use this in an if statement which is conditional on the TryParse returning true. 

use iterator instead of , I also took the liberty to use ternary operators instead of giant if-else bocks. 

If you were looking reduce the amount of code further, you could probably skip the whole dictionary part of this, and just compare the lists returned from the , by intersecting them and subtracting one list from the other. I just had to try :) 

I don't know enough about android but in Swing, for example, a combo box took, in it's constructor an 

It's a lot to explain here, but in a nutshell, I would simplify all of this using spring-data-rest and do the following 

First, I applaud your effort - I must confess: this is definitely lacking in the js world. A few things come to mind: 

Delete all of your controllers. The endpoints are created and the content-types managed by spring data rest for you. Read more about for details on that Delete all your DAL code 

Shorten the code Create a type of factory method for these "fixtures". This may not be appropriate for your case but with no other context that is what I would do 

In general, any math on doubles is slower than on integers. In addition, you have repeated downcasting from double to int which also incurs a hit. You know your decimal value is up to 10 digits -- just a smidge too many digits to guarantee you can move the decimal and represent it as an int, but you can represent it as a long which is just as good because java and modern hardware architectures are 64 bits. So, any math on them will be really fast. Why not convert the decimal to a long 

Some people prefer that, I just am not, and that is up to every coder to decide. If I was to put brackets arround that, I would probably do it this way 

will replace the condition for checking null-ness and emptyness, I would recommend you look at as well, this is good if you may be getting some blank spaces newlines or tabs with your data. (Optional) Instead of comparing your Enumeration to 0, implement a value, this way in-case someone ever changes the default values of enum this code will still work. Or if you don't want to change the enum, you could just check to see if the value given is a valid value in your enumeration. 

Edited additional points In this line you'll notice that you are printing the address of not the value of as denoted by the , remove this if you want your program to run properly. 

Review I don't know if this is something you should implement, because I don't know how you intend to use this class. In C# you can place access modifiers on the individual parts of the getters and setters. A way you can use this (again, not sure if you need to, but this is isncase you do): 

generateValue The conversion to and from strings slows your method down, bitshifts are more appropiate ( returns the same result). As @Piers Williams already stated, an iterative approach is preferable. A possible implementation: 

Current approach You can determine the exact count of days in the mask beforehand -> you can use a better initial size than for the array list (or directly an array as the size is fixed). You don't have to sort the list (and thus don't need the comparator), rotating based on the is sufficient as the order of the days does not change. While this is very ugly: You could replace the with . Regarding your edit: This seems like a very bad idea if you ever want to make your app multithreaded. Alternative implementation You can avoid rotating the resulting list if you start interpreting the at the provided instead of . 

In the context of the quoted task I would stick with , documenting the possible return values should be sufficient (besides maybe renaming the method to something more meaningful like ). getCoinToss Using or would avoid quite a few calculations and thus would be significantly faster. Additionally the current approach will perform poorly if the method is accessed by many threads. 

IO is always infinite (or should assumed to be so) and thus is natural for this case. The default node libraries for streams are really unimaginative on this. I was just asking around on JS chat yesterday about something like this. 

People generally took this to mean a String[] as that is what they saw in the dropdown. But ask yourself: Why Object[] then? Assume we transpos your case to Swing for a moment. You could pass in your Object[] into the constructor and override the toString() in your enums to display something useful as that is what would show up. Then when the selection is made you receive the callback telling you what it was (as an Object). But you know it's your enum. So, you downcast it and blindly call the 'attempt' method on it. If you have something similar in your arsenal, consider it. What you have here, actually, is an example of the Command Pattern 

The idea is to decompose it, apply the filtering and then reconstruct it. part of the problem is this code mixes development paradigms: it uses and and 

Separate your main-loop logic from your main menu rendering logic. You should have a main-loop, which calls recalculate, and draw, then in your draw you should draw the appropriate menu, based on the games current state, the logic should stay in its own class away from the main-loop. 

Lets kill that giant nest of code. When an Exception is thrown, it interrupts the flow of the program. The code does not continue to execute beyond that point, it is like an early return in that regard. This means we do not need to nest our next statement in the Else block, because if an exception was thrown the program has returned. You should not be throwing Exception, not to say you should throw exceptions, but just not throw the base Exception class. Instead make your own exception class that inherits from Exception. An incredibly simple way of doing this is just... 

I just wrote this short little program to increment up the build number for my projects every time I build them. After compiling this exe, I just call it in the pre-build command line. I did take out the filename string because I used it thrice, and I figured I'd get some flack if I didn't. 

You can use the method to require only one lookup for most map implementations (esp. important for concurrent maps that may contain values to ensure reliable results). 

MyWord Your / implementation is not conform with the specification of - equal objects can currently return different hash codes. The implementation of should return the hash code of instead of . The constructor performs no argument checks -> it is possible to create i.e. an instance with , which will lead to s thrown by the method. The method could return . Alternative implementation A priority queue is not a good data structure to determine the frequencies as you have to iterate the queue for each input element. You can use a to convert the input array to the frequencies with complexity (plus additional to sort the resulting frequencies, or to create a heap). Using the stream api this could be written as: 

The implementation 'does not count' as it overloads the method and does not override it. You can use generics to specify the expected parameter type. If you can change the interface: 

Now the succeeded value is available after the method returns, and will only be true if all values past the test, and now there is no nasty exception throwing, which hurts your application's performance and is just bad practice. You can call the method like this now. WITHOUT a try..catch surrounding it 

You could just combine the logic into one statement, assuming there is not other things occurring during your if-else blocks and stuff. If there is, then this won't necessarily work for you, and you should post the real code, because a lot of times these problems are subjective to the code. I guess one lesson to possibly learn from this is just to realize the end result, and build a condition that matches the necessary conditions to do something. 

A good alternative to your current implementaiton would have been to create a recursive function which takes in , and the method would simply loop over the remainingNumbers and making new composites to check on, each time you would want to check just the currentComposite to see if that is a valid set. The way I would do it, would be to create a list of number arrays which hold every combination of the given numbers, then I would simply loop over that collection to determine which sets fit my conditions. Here is some code I found online (specifically here), because I did not want to make my own Combination generator. I'm going to post this code on CR, because I'd like to see someone take a stab at making it better.