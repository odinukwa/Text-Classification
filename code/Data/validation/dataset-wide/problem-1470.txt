You will see that implementing is very simple and beautiful in comparison to a direct . Edit: What I call here "upper_bound"-like search is implemented in the STL as not to confuse with . 

Makes a copy of while returning . Imagine val_ is a very big . This could be very expensive in code which calls multiple times. If you want read-only access, prefer to use 

If I read I do expect to search for a node. But take this as a weak complain only. Naming is hard. 4.2) Nodes should be passed by const-reference or (if you really need to modify s when accessing its children) The way you declare your search method makes it impossible to search in read-only graphs. I suggest something like 

Finally you can eliminate some single use intermediate variables. This may not appreciably speed up the function, but it does make for cleaner code. 

If you really want to eliminate more duplicate calculations, you can assign outside both loops and outside the outer loop. 

I am assuming that the call to is not what is taking most of the time, so I'm not including that in my analysis. One thing that is slowing down your code is that you are assigning to every iteration of the loop (well, every iteration that is 0). That could be pulled out of the loop since it only needs to be done once. 

If you want to initialise your data from any range use templates and constrain its type to guard for errors at compile time. Prefer regular functions for computations This means, that an implemented function is also a function in the mathematical sense. Same input data produces same output data. I found that this almost always leads to evaluations which do not change an inner state. Thus it smells to me that 

Since stylistic comments are also welcome I will start very simple. I prefer to reserve upper-case names for macros. Instead of 

Why is that? Whenever you move a pointer from to you move its ownership to close, but you never free any pointers form , only from . This 

The vector has a added to the beginning and the end which is equivalent to adding a to the beginning and end of the baskets. This makes the first streak start at the beginning and the last streak stop at the end. is a vector of indexes of where the misses ("M" in , 0 in ) occur. The lengths of the streaks preceding them, then, is just the difference in successive indexes (minus 1, since you want to count the number of spaces between, which is one less than the difference of the positions). Now, since the intermediate results are just used once on the next statement, they can be rolled up. Here are successive versions of doing that: 

LINQ has extension methods for any which will help with this. There's , which will return the first elements, and which will skip elements, then return the rest. Of course, these don't actually change the they're operating on - they just return a new one. But that's a safer pattern to use - it means you have the option of keeping the untrimmed version around if you need to. 

I can't say that it's going to be more efficient, or better designed, but one option is to take advantage of polymorphism by creating a set of classes for this. 

Everything in your code should either require the interface or the interface. If the former, it can accept any of the four classes. If the latter, it requires the plus four bit. Since a plus four can always be downgraded to a pure zipcode, this set of inheritance will let you pass a +4 wherever you are looking for a . Also, by always requiring the interface, rather than the concrete type, you can trivially implement the null object pattern you asked about. 

Here is an example of how to use to use uninitialised memory. I think this could help you as well. Do not return by value if you can The line 

2.) Don't use abstract base classes for function objects 2.1) Use instead of abstract base class 2.2) Use instead of abstract base class [ Note: Or just take these as template parameters only. ] The rationale is that the way you do it is intrusive and a client has to define adapter classes to use your library. Since your abstract base classes only require virtual you are better of with which is just such a wrapper around any function-like type. Defining abstract base classes here might also introduce a lot of subtle misuses and errors. For example: you do not define a virtual destructor! Since you do not store your function objects polymorphically it seems to be okay in this case (and might leak otherwise), but on the other hand you take pointers to such objects without -checks... and your classes invite users to misuse them by letting the pointers dangle. I have no experience with fluent interfaces but I do not like this particular example. You gain pretty much nothing but a code bloat -- one selector-class for each parameter plus it seems to be easy to misuse. Maybe one can generate selector classes and avoid code repetition with Herb Sutter's announced metaclasses. IDK. 3.) Don't use an abstract base class to require a ForwardIterator Just rely on substitution errors or constrain your Node type with Concepts / + . This adds again unnecessary coupling for the client to your library. 4.) Issues in A*- 4.1) is not a good name. I suggest something that indicate what you search for (an element? a path!) Suggestions: 

You can avoid appending to vectors (which can cause re-allocation of space and can considerably slow things down in principle; though in your case of only a length 10 vector that shouldn't be noticeable) if you allocate them to the needed size initially and then assign within them. 

In your code, is not defined. Presumably it is some threshold value, since it is used in a comparison of absolute differences. First, reformat your code so that I can better determine what it is supposed to do: 

Your approach seems reasonable, but there are some simplifications you can make. First, your construction of is needlessly complex. This works just as well: 

instead. Make use of move assignments Currently you have to copy values into your optional. But what, if you just want to move something big that you want to return from a function? You need to add constructors for rvalue-s. 

This data structure maps values from intervals of some type which satisfies to values of some type . I remembered this kind of data structure from an interview question. My current use case is a distributed vector where I want to keep track which MPI rank owns which parts of some global index space. I am not sure about the . Explanation I use a where empty optionals are my sentinel for intervals, i.e. marking their end. So when mapping some interval to some value I do this by inserting 

The comments are good; I copy them here so this question has a "proper" answer, and add some my own: 

Second, you can call on each element of at the outset which eliminates the need to specify an value to (and thus reducing all the calculations by one call to ). It also shortens the arguments to since duplicates have already been eliminated. 

If a streak must have at least one , how can you have a streak of 0? The example here (and the following example) are consistent with a definiton of streak of "the number of consecutive 's preceding each ." I'll continue with this interpretation so that it matches the existing code. Now to improvements to the code. The initialization of can be simplified because is the default numeric value, so the first line can be re-written as 

By doing it this way, you separate the formula (which is basically just Ingredient/Percentage pairs) from each application of it. You can use the same object to calculate the weights for 10000g of dough or 50000g of dough - simply call with a different value. Notice how many fewer properties you need on each class, and the question of "late setting" of some of them is entirely irrelevant. Effectively, weight is not an intrinsic property of an ingredient, because it varies based on the total weight, so shouldn't be a property of . 

Edit: Stole the idea from Jesse C. Slicer's answer, but didn't modify the function signature. You can also return if that is more useful to you, or you can go with his idea of returning , in which case you don't need that at all. 

That is, generate all the answers and guesses, check for each one (vectorized) which (staying or switching) would be a win, and then accumulate those results. The rest is just to put the data in the same format that your function already had. 

I'm not clear what you are asking about combing function; you can add an additional argument which is a character vector which then the code just has a series of if/elseif's checking that parameter to see which algorithm to use, if that is what you mean. 

The first two lines together create a 0/1 vector corresponding to whether the value in was (1) or (0) (and uses the fact that it must be one or the other of those values). This can be done as one statement, using the fact that and become and when converted to numbers.