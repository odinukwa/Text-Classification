It's time for a fun edge case! Question: what happens when you have a reaaaaaaaaally big number? I'm talking reaaaaaaallllllyyyyy big. I'm talking 308 characters big. That's right, it will be a correct value but your code will throw an when it cannot parse it as a double. Likewise: if you have characters in your string, you're going to end up with trouble as well. Though at that point, your memory will have already been depleted so it's "okay". Unless you're building something aimed at these usecases: don't fix it. I just thought it worth mentioning. 

Additionally, I would suggest turning your into a or an array so you don't have to deal with an O(n) lookup. Or you omit it altogether and just combine the usage with your dictionary: only add the days you're open in and try to retrieve the day from there. 

If something went wrong so badly it throws an exception, we'll just pretend they're the same? This is logically incorrect and will cause very hard to track down bugs. 

I prefer a style that takes away some of this nesting (and thus allows more characters on your line): 

Here too: I prefer over . Takes away some of the black color in your IDE and it feels slimmer. All the cool kids use it. 

First of all a remark: I am not entirely sure about the requirements but in order to make your app Windows Store qualified you have to adhere to certain rules. One of them being you're not fiddling with .NET stuff in a WinRT component. I would look up whether or not reflection is ported from .NET to WinRT. Just because it works on your machine locally doesn't mean Microsoft will allow it. 

99% of the time you think you need a Tuple, you don't. First look into whether this can be turned into 3 methods. If that isn't possible, return a simple object that holds these 3 collections as properties. 

So you get a directory, take the length, substract one and compare it to the ASCII value of ? What? Unless I am reading it incorrectly, this doesn't do what you think it does. Can you give an example of a value so I can propose something better? 

I don't like using and then implementing on activity level. You end up, as you do, with one big click handler while you might as well just create a method dedicated to that button. It will be clearer and easier to find as well (when you have 20 buttons, you would have them all laid out in your IDE's class view window). 

I feel like there's room for an optimization here: what if you have 100.000 pages? Or even just 100? You will load all your items each time someone visits the frontpage and you're only doing this to show the user how many pages of items there are. In fact you're not even doing that: you won't show them past 10 pages anyway! I would argue that maybe you should just use two queries: 

I would suggest an : they're made to encapsulate a set of distinct values known at compile time. For example, this might be the code you have as a result: 

You're doing validation inside the constructor instead of the corresponding setters. If I want to, I can create an object that has a startrow less than the endrow but then manually use the setters afterwards to change it anyway. 

Note that you can also use a direct cast instead of since it is guaranteed to be a possible cast, but I like to read myself (the performance impact is minimal and not relevant in our scenario). Note that I also use instead of because from your description I can assume it is either a or a . If it isn't, I'm throwing an exception anyway at the end so I don't feel compelled to use . 

You're using a and executing on it. In a list, this will iterate over all the values which ends you up with O(n) time each time the inner loop runs: obviously very slow. Instead use a which has O(1) lookup. 

is not an appropriate boolean naming. It should , or something similar which indicates what exactly that solution means. 

There will be no difference in performance whatsoever between the two approaches. I would suggest you don't break the responsibility principle and leave the handling of the tablemodel to the class. One remark though: if there are additional computations done in aside from a plain setter, you will bypass these if your create the local variable. This may or may not be something you desire. 

While we're on the topic: FluentAssertions. It turns that into something like : it's easy to read and perhaps more importantly it also gives really useful information when the test fails, unlike "false". 

Do these all have to use a fully qualified name? It would read a lot easier if you'd drop all the unnecessary namespaces and used a directive instead. 

Feels a little pointless to inject a JS function and then only call it once. Can't you directly call from ? I would use an intermediate variable to store the string for readability purposes. 

Not that I'm aware of but it's okay -- IDs are supposed to be unique anyway. You might want to add a prefix of your own though to indicate it's a diagnostic part of your own library (and thus avoid collisions with other libraries). An example is the "CS" prefix used by Microsoft themselves. 

since the evaluation of that is a boolean by itself and thus there is no need for the additional ternary operation. I would suspect that this is the same in PHP. 

Do you really want to insert the item when there might be argument exceptions possible? If you catch the exception, you will have a partially executed method; if you don't catch the exception your program will have crashed anyway. 

I took a shot at this as well. I think @Hangy had a few good ideas but ended up with a rather complex solution. I haven't added any caching so you might want to add that yourself afterwards. What I changed: 

This will also fix the problem you'll get when the option passed contains uppercase letters (or misspelled alltogether). Likewise you can now add another method that calculates the range for your random call: . Naming What is a "SudokuUtility"? This looks like the actual game to me (somewhat). Are you absolutely sure this isn't a part of your game class? There's no need to abbreviate , is just fine. The method isn't very pleasant because it starts from a negative point of view. Consider instead (remember: method names start with a verb because they represent an action). Magic values In your nested loops you're iteration to an upper value of . What is this value? Where does it come from? What does it mean? If you put it in a variable like (I don't know its actual purpose), it's a lot clearer. 

You'll find that you can configure this a lot and add restrictions to the table that gets generated but I'm too lazy to look them up myself; mapping isn't my best side. This should give you an idea though about how you can get rid of those not-so-pretty intermediate tables. 

I would consider using the extension method: it's just more expressive than and should be no difference in performance. 

Last but not least: USE AN ORM Getting a proper ORM up and running is very hard to get right and by creating your own you are 

Note that I am using variables so you don't have needless clutter of getters/setters. This class is just a wrapper to send values, nothing else. Some notes, perhaps? Naming In that same method you have the following parameter names: 

As you see I also prefer to keep the first statement on the same line and indent the next statements to align with the linq statement. One remark though: first you're ordering your records and then grouping them. Is this done deliberately? I would assume that you'd want to group first and then order, not in the least because you would have to order less elements. But then again: grouping might be more performant if you order it first so I'm not entirely sure. 

There, I clarified what this section was about. Well, actually I didn't because the title already conveyed that entire meaning. Which is exactly what you're doing with 

This incorporates a few changes. First of all: I've made the event handler . This is the only situation where it is advised to do this, simply because there's no alternative: event handlers have the requirement to have a return type whereas asynchronous methods work with . In essence this means that you won't be able to the event handler so if the caller finishes while the event's effects are still running, your program will exit without a regard of this still running code. Another change is that I used . You can choose between this and but both are more fluent than creating a new object and then starting it. You should always avoid calling since it synchronously blocks the thread to wait for the result (which is the opposite of what you typically want in an asynchronous environment). As shown in the docs: 

Very short and sexy! This doesn't take the in account but you can easily add that yourself: just split up the oneliner and add the appropriate check. 

Initializing should be done automatically from your constructor. Right now you're exposing it as a public method that may or may not get called: this will guaranteed cause problems when someone forgets to initialize. Considering it doesn't add value in the first place I would just call it automatically in your constructor. 

Restrict visibility unless you actually want an outside class to access it. Both and are not things the outside world should access so make them . 

does not need to contain 'PHP' since that's a given for any class you create. Unless that is the actual name of the service, name it . 

Return instead of . It tells whoever reads your code that you really did intend to return an empty string and it wasn't just a typo. 

The main reason for doing this is because I don't like the 0-based array index with the 1-based cameras: refers to camera 4 instead of 3, thus losing some expressiveness even for people familiar with this. Using an enum also takes care of you having to choose a place to create those boundary values and passing them around: the enum is created once, stores its values in a central place and can be used anywhere you want. Usage is easy: 

Notice you don't use in your first method (although this is caught by doing that cast in every method). Still, nasty. 

You're throwing a . Big no-no. What you want to throw is an , much more intuitive. When we catch that exception, we want to catch all invalid arguments; not just those that happen to be . And it would cause confusion if we receive NPE's from somewhere else.