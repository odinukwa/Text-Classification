This is a time/space tradeoff that allows you to reduce the number of computations from 2168 down to 2112 with a space cost of 256 64-bit blocks (512 petabytes). Now, for some bizarre reason, all security tools seem to report 3DES-EDE as 112-bit without actually qualifying why. 3DES-EDE does not have a 112-bit key length, nor does it really even have a 112-bit effective key length unless you specify that your attacker has 512PiB of lightning-fast storage available alongside their massive array of DES-cracking ASICs. The practice of reporting it as 112-bit appears to have started with the "sslscan" tool, and has been copied by various other tools since then, leading to all sorts of confusion and misconceptions (I even saw this incorrectly marked in a security exam!) This isn't to say you shouldn't disable 3DES - it's an old algorithm now and there are problems with it, so it's probably worth moving away from it. It's just worth knowing why. If you want to do so, add and to your list of disabled algorithms. These names are defined in the cryptographic providers documentation, in case you want to disable any others. 

I'm in the middle of doing some testing on a mobile device, and want to test it from the network. The mobile device will only connect to networks via WiFi, and doesn't support ad-hoc mode, so I've set up an old WiFi router as an AP, which is connected via ethernet to a port on my laptop. The router operates under 192.168.0.0/24. My laptop is also connected to our normal network via another ethernet port. This network operates under 10.0.2.0/24, and provides internet connectivity. My laptop is running a VM which has two NICs, each bridged onto the two respective physical NICs. The 10.0.2.0 network is reachable via eth0, and the 192.168.0.0 network is reachable via eth1. The problem I'm having is that all connectivity drops as soon as I run . I've tried changing routing tables and adapter metrics, but have had no luck. Here's the output from : 

Find a known plaintext and ciphertext block pair for a given key you want to crack. Compute the first encryption step (i.e. one DES encrypt operation) on the plaintext block for all possible 56-bit keys. Store all of the resulting 64-bit blocks in a big lookup table. For each possible remaining 112-bit part of the key, perform the other two operations (decrypt, encrypt) on the ciphertext. If the result of the two operations matches any block in your lookup table, you've found the key. Otherwise try the next 112-bit key. 

What you're looking for is a combination of penetration testing and code security review. There are a lot of companies and freelance individuals who will do a pentest for you, for a price. Depending on what you're trying to secure (webapp, payment gateway, physical box, hosted VM, entire network, etc) there may be certain regulations which need to be followed. You'll also have to liase with your hosting provider, since they don't like random people sniffing around in their network. A code security review, on the other hand, requires in-depth knowledge of your codebase and security concepts, so most companies hire a security developer (or contract one in) for this kind of role. They'll need to get comfortable with your entire application and network, then do a detailed analysis of any potential security issues within the code or infrastructure. 

In all honesty it's easiest to schedule a proper restore from your last backup at this point. Fortunately you can still do another, final, backup to preserve your current user data; then restore your old backup, and finally restore your user/customer data from your final backup, making sure you preserve the permissions of each group of files as you do so. 

I've installed MIT Kerberos 1.10 on a Debian server and happily have my Debian clients authenticating with it. I'm having some trouble getting my Windows 7 machine to do the same, however. I've used to configure the machine as follows: 

has an A record that points at the server's IP address. After configuring the Windows system I rebooted it and tried to log in, noting that the login screen offered to log me into the domain. However, when I attempt to log in as the local user , which should be mapped to , after a brief pause I am told that there are no logon servers available to service the logon request. I can't see anything relevant in the Windows event log, and having examined the network traffic between the client and the server, I can't even see that the Windows machine is trying to contact the KDC. It's not all bad news, however. What gives me hope is that I can use to get a : 

If I then launch PuTTY from that command prompt, I can ssh into the other servers using SSPI to authenticate just fine! 

I discovered that if I enter the full username at the Windows screen then logging on works fine; or don't cut the mustard. I can't find anything that confirms that this is the expected behaviour, but it is consistent with a careful reading of the output of : 

Some general advice that will apply no matter which network filesystem you adopt: many programs cache data in the user's home directory, which usually does more harm than good when the home directory is accessed over a network. These days, you can tell many programs to store their caches elsewhere (e.g., on a local disk) by setting the environment variable in a login script. Lots of programs (e.g., Firefox) still require manual configuration, however, so you will probably have to do some extra work to identify and configure them in a uniform manner for all your users. 

Have you configured NSS to talk directly to the LDAP server, or are you going through a proxy such as ? If so, look into configuring the proxy to rewrite the user's home directory attribute. For instance, in you can state: 

i.e., if you log in as then the local account will be logged in; this does not imply that you can log in as and have the system authenticate you with the KDC as . 

Before you go changing your SSL config, it might be worth understanding exactly what the vulnerability is here. When 3DES was introduced, there was a requirement that it was interoperable with legacy single-DES systems. The idea behind 3DES is that you can multiply the security by performing multiple DES operations with different keys. In order to provide compatibility, they used an EDE construction: 3 DES operations in sequence - Encrypt, Decrypt, Encrypt - or EDE for short. It turns out that a DES decrypt operation is basically interchangeable with an encrypt operation in terms of security, so this works quite well. When you use three independent keys for each operation (known as keying option 1) you essentially have a 168-bit key. If you want to go back to old single-DES mode, you use a different keying option (3) which has all three subkeys set to the same value, i.e. k1 = k2 = k3, so that two of the operations cancel out and only a single DES operation actually matters. There's also another keying option which has two of the keys with the same value but one different, producing a 112-bit key, but this isn't really used in reality and (somewhat confusingly) is completely unrelated to why you're seeing 3DES reported as 112-bit. To make things even more confusing, you'll sometimes hear people talk about 64-bit DES or 192-bit 3DES. These are, from a cryptographic perspective, identical to 56-bit DES or 168-bit 3DES. DES specifies a key padding system whereby 8 padding bits can be added to a 56-bit key to produce a 64-bit padded key. This was for use in some old systems and it's not really important, but the 8 bits can be ignored and only 56 bits are actually key material. In 192-bit 3DES the same thing happens, where each 56-bit subkey is padded with 8 padding bits, but again the real cryptographic key is only 168 bits long. Now, what's the 112-bit thing all about? 3DES suffers from a problem called a meet-in-the-middle attack. The approach is as follows: 

I'm getting really slow queries in MS SQL Server 2008 R2 on my dev machine. This problem has been plaguing me for about a month. Other developers don't have the same problem, but we all run the same code. It seems to be that any query that includes a takes >20s, some taking up to a minute. Inserts and updates are fast. The total database size is about 30MB, so it's hardly huge. During the laggy queries, the CPU usage stays flat, the IO rates stay low, and the pagefault delta stays low too. I've not tweaked any performance settings in the db config - it's all stock from the setup. The software that connects to the SQL server is running on the same machine as it. I've tried multiple dev database copies, and customer databases that are known to be fine, all to no avail. Any ideas what might be causing this?