Apart from using upper case for method names (as pointed out by @paritosh), I think it's a reasonable convention to use prefix for methods returning a boolean representing some state that may or may not be. Case in point: $URL$ Note this is a property, meaning you could indeed replace with a read-only property. Not that there's anything bad with leaving it like it is - properties are just more idiomatic in C#. Using a property kind of puts more emphasis on the fact that we're only checking on some state, and there's no side effects to that. (You can still implement a property in such a way that it causes side effects, it's just blatantly against the semantics of it). Last but not least, variables should be named with lower case in C#: 

The problem with your design is that you have different fields that, to a certain extent, represent the same property, leading to interdependent state, which makes the code fragile and confusing. I am talking about the class and . For example, the class contains a field , but it also contains a field , both of which represent information about the size of the fine. So it is possible to construct an invalid object by assigning the fields and contradictory values, e.g. and . The same applies to the number of points gained. Since the fields and already contain all the necessary information regarding the the fine size and the number of points, the question is why you actually need an enum. 3 of the 5 enum values, namely , and , only represent information that is already stored in and , which means that these enum values are practically useless. So the question arises what the enum is actually supposed to represent. Let's look at the other two values, and . Disqualification is an additional action that is taken on top of the fine, and a warning is issued in place of a fine, so both are not really "types" of a fine, but actually have nothing to do with a fine directly. So how to represent a warning? That probably depends on what you want to do with a warning. Does it have any state associated with it, like a object that contains the size of the fine and the number of points gained? If so, it could be a class of its own (and and could be subclasses of a common superclass). But judging by your code sample, it doesn't look like it, so maybe it would suffice if the file that contains the driver's registration details has a way of storing the warning without the warning itself being represented as an object, for instance a of dates on which a warning has been issued to the driver. Similarly, the disqualification is not directly related to the fine, so like the warnings, it could simply be stored in the file with the driver's registration details separately from the fines. Finally, about the field in the class . This should not be a field at all, because its content only depends on the other fields. Instead, I would write a method that generates the based on the values and , for example like this: 

We're kind of emulating Java's enums here (one of few features where Java actually happens to be superior to C#). And a little bit of help (so that we don't use reflection etc.): 

Error handling or the lack thereof. Sending an email can fail for a variety of reasons, and you don't handle exceptions or failures. In you're sending emails in a loop - what if there's 10 managers, and sending it to the second one fails badly, shouldn't we try to ensure that the remaining eight would still receive their notifications? You don't handle edge cases either (such as an inexistent recipient: it would result in a once you tried to retrieve from a null , if didn't contain any entity under a given id). 

I like your approach with the two-pointer-array. As for the performance: The other answers here use the Big O notation as a basis for comparing the speed of different algorithms, hinting that using a or a might be faster than your approach. But this is misleading, since the Big O notation says nothing about the speed of different algorithms compared to each other, but only about how much slower an algorithm will be when \$n\$ increases. For example, you might have an \$O(n)\$ algorithm that takes \$n\$ hours to complete, and an \$O(n^{2})\$ algorithm that takes \$n^{2}\$ milliseconds to complete, and the second algorithm will be faster for all \$n < 3600000\$. Of course, this is an extreme example, I just wanted to make a principle clear. As for this case, I tried to compare your algorithm with the algorithm suggested by zenwraight. Here is my implementation of that algorithm: 

Do you plan to extend this class? If not, I would mark it as . Given its nature, inheritance can open a Pandora box. 

Who would have thunk! Not too informative... In contrast, this code doesn't comment the non-obvious stuff. For instance, now your class has a certain policy regarding nullability - which, as I said, is by itself an improvement over the previous code, where this policy was sort of accidental. But is it obvious that throws an exception whereas is ignored? I wouldn't have guessed that correctly, and yet the documentation doesn't say a word about it. It's too busy telling me that element is element. By the way, it's not just a question of documentation - I'm not sure I like this asymmetry in principle. And it isn't the only inconsistency lurking in the implementation, either. For example won't crash when the list is empty - but will if there are already elements in it. What's the rationale for that? :) That's not predictable behaviour in my book. Speaking of , this comment is just plain wrong: 

I assume "next" in means "after one unit of whatever temporal unit you use in the unit of the velocity", since the change of a position based on a velocity only makes sense in the context of a time span. As for your code, you could simply model the path of the object by breaking it up into subpaths where the direction does not change, like this: 

I've renamed to because I found just too confusing with always coming up somewhere. I've also replaced some of your s with s, since an is only meant for arrays, and not for any index-based data structure. Unfortunately, the method is an eyesore. Maybe this can be mitigated by introducing more local variables, but the problem is the constant threat of overflows, which often requires the comparison statements in a way that they don't lend themselves to use local variables (e.g. instead of ), so I'm not sure how much can be done about this. In addition, I've implemented so that it produces a hash equivalent to the hash code of an analogous , which can be used both for testing purposes and to prevent clever compiler optimizations (hopefully). 

And that's it, job done. As I said, this solution may not be applicable in your case - I have no way of knowing. 

Naming Unlike in Java, constants in C# aren't normally named with all caps and underscores (). Methods names shouldn't be lower-case (). Names such as are way too long, and they don't describe the method well. A method should be named for what it does, not when or why it does that. A method doesn't know who calls it and in what scenario or context it happens. That's not its responsibility. A method knows what it does itself. The calling code knows when and why to use it. That's how responsibility is dealt. A pickaxe doesn't need to know it's in a coal mine. When a method's name starts with "if", it's already very suspicious. Structure is a class field, and yet methods are passing it to eachother as a parameter. This is confusing: every method has access to all class members by itself, they don't need to piggyback on other methods for that purpose. Redundant clauses 

You could speed up the first version by switching the loops, so that the loop over becomes the inner loop, and short-circuiting the loop over , because once you have found a character in that matches the current character in , you don't have to loop over the remaining characters of (mtj's suggestion to use would amount to this). As for the second approach: Why do you first convert the strings to a before iterating over their characters? You did not do this in the first version, so what do you gain from it by doing it in the second version? About your question which approach is better: Depends on what you mean by better. I think both versions are quite straighforward and to the point. For large strings, the second version might be preferable because it has a lower time complexity. However, you write that the strings will contain at most 50 characters, so the benefit of constant-time lookup might not outweigh the cost of creating a and implicitly converting each primitive to a object. But this is just a guess, I did not measure it. 

I'm not sure about this condition. There are other states where connection state isn't Open, and yet it should still be closed - see $URL$ I would err on the safe side and try to close it anyway. You could test it, but I don't think anything bad's going to happen if it's closed already. Or you could make it instead. Since there are other possibilities (, , , ), this is not the same thing. 

Indeed, did you test how it behaves for very large (or very small) values, nevermind the performance? What will happen if I multiply by another one? What is supposed to happen? 

Code style Magic numbers In "DatabaseManager", I would convert "magic numbers" (connection life time being 5 minutes, command timeout set to 120 etc.) into constants. Fluff / noise