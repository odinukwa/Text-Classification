Since you are doing the same operation over and over, you can put your strings in an array or list and use a mapping function. For example: 

Shorthand if/elseif syntax You can use the keyword in conjunction with and to cut down on the whitespace of your if-eslif chain. The syntax would look like: 

I think you can add functionality to to make the common ancestor search more ruby like. (I can add a search by value later, if you want.) I've added a parent member that is set automatically, and I've added and enumerators to enable easy traversal up or down the tree. Note: Thinking about it, the search function needs a little more work in case node 2 is higher in the tree than node 1, but I am out of time right now. Let me know what you think. Testing indicates that this is not an issue. 

They are syntactically equivalent, so choose whichever you prefer, however the second one is more idiomatic than the first. As Paparazzi mentioned, you should use lower case for the first letter on your variable; in idiomatic C#, only classes, property names, names of structs, and enums should start with an upper case letter. Updated: added additional notes on what should be capitalized 

Then, you could implement all of your command-driven printers using that same base class, like this: 

By synchronously locking on the object, if a second thread tries to call at the same time, the second thread's execution will be blocked (i.e. hung) until the first thread's call to is complete. The problem with this approach is that, at least to some extent, it defeats the purpose of multi-threading because only one thread can do that part of the work at a time. The second way to fix this would be to have each thread create a new object so that they don't interfere with each other. For instance, instead of having the object declared as a class-level field, you could just create a new object inside the method, like this: 

To quote an ancient truth, "To every thing there is a season, and a time to every purpose." There is a time to fancy-pants-code, and there is a time to cowboy-code. Experience is what has to guide you in determining which method is better suited for a given task. There are many things that can impact that decision, for instance: 

Ruby also has C-style format strings. Use '%d', %f', '%s', etc in the string and then supply an array at the end of the string with all of the arguments. 

If you can't do that, when you start the new thread, try setting the thread priority to low or tweaking other related settings. 

Note while the regex works perfectly in RegexBuddy (set to python), I had issues getting this to run at the command line. The regex looks for a non-zero digit (1-9), followed by an optional grouping of [any digits (0-9) AND a final non-zero digit (1-9)]. Any match will be the significant digits. Getting the length of the match returns the number of significant digits. Also note that in your example, the last entry appears to have two significant digits, but you have it listed as three in the comment: 

The BackgroundWorker.RunWorkerAsync() and RunWorkerCompletedEventArgs only accept/return a single object and you need to pass two (the block index and the block itself). You will need to either use a tuple/struct/class or something else to hold both objects when passing back and forth. Finally, You may need special handling for the last block of the file. Some encryption algorithms (zero) pad a short block to the expected length (1K in this case). This means that your encrypted file may be slightly longer than your unencrypted file. If this is the case for your chosen algorithm, your allocated output file size may be slightly longer than the original input. Depending on the file contents, this may or may not be an problem, however you should be aware of it as a potential issue. 

Let's say that in the above example, the method is called from two different threads simultaneously, and the order that the lines are processed is like this: 

Simply put, from an idealistic standpoint, fancy-pants code is always better than cowboy code, but from a practical standpoint, fancy-pants code can sometimes be much worse. So, as a general rule-of-thumb, I would say that you should always fancy-pants-code unless you have a good reason not to do so, and you should accept that there are some very good reasons not to do so, sometimes. I have a lot of experience with this, and I can tell you, designing code well up-front, is WELL worth the effort. It's true, as you said, that good design has more up-front cost, and poor design has more back-end cost, but to say that the two are equivalent, because of that, is fallacious. It all depends how much back-end work will need to be done. As you say, a simple statement isn't really that bad, and if adding more statements to the statement is the worst of the back-end cost that you are going to incur, then it's really not worth the time to add a bunch of complication to avoid something as trivial as that. But if the project grows and changes over the years, a little shortcut like that, to save a few hours of development time, could potentially cost months of development time in the long run. It all depends. Another issue which often muddies the water is that not all fancy designs are actually good designs. You could develop the most impressive fancy code in the world, but if it doesn't actually solve any problems, such as making the code more stable, flexible, or maintainable, then you've actually made the problem worse by all your fanciness. As much as I am a believer of good design, I am also a strong believer in the YAGNI principle. If you haven't read the wikipedia page on YAGNI, I'd strongly recommend it. YAGNI simply means "You aint gonna need it". Simply put, don't add features and complication that you don't currently need. YAGNI does not preclude good design, but it does preclude unnecessary fanciness. Again, the issue isn't whether or not the design is fancy, it's whether or not the design is good. A good design will follow the YAGNI principle. It is definitely possible to "over-design" something. All that being said, if there is no good reason to cowboy-code on this one, as it sounds like their might not be, allow me to offer my perspective on what a good fancy design might look like. My way is by no means the only right way, but hopefully it will be helpful to you. I'd like to think that my fancy way of doing it does solve a lot of future problems and would therefore be worth the relatively small up-front cost. My Way to Do It (Dependency-Injection) Your first instinct was to think that the Factory Pattern would be a good solution to this problem. That was a good instinct, but I don't think it quite goes far enough. Dependency-Injection (DI), which relies heavily on factories, is perfectly suited to this type of problem. Personally, I think it is well-suited for almost all problems, but there are certain problems, like this one, which just scream dependency-injection. In general, the principle of DI is that a class never creates it's own dependencies. So, for instance, if you have a class, and it needs an object, you wouldn't have the class create its own object. Instead, you would have the class request that the (it's dependency) be given to it (injected), usually in its constructor. For example, rather than having something like this: 

If Yes, read the next block from the file, pass it and the block index to the worker and start it. Remove the worker from the list If No, then sleep. 

Break out of loops sooner This applies specifically to your spaceship and to a lesser extent to asteroids and torpedoes. Once the spaceship is destroyed, return. Any other collision checks are wasted processing time. For torpedoes and asteroids, once a torpedo has destroyed an asteroid, break out and move on to the next torpedo. This leaves a small edge case where a torpedo might perfectly hit two asteroids at once, so this decision is up to you. 

The reason is that transform is a instance method of , which is why you need to convert back into an image before calling it. There are a couple of way this can be handled. I've chosen to make a static method that only works on arrays. The instance methods and call the static method as needed 

(Note that I wrote and tested this code in ruby and then ported it to C# by hand, so there may be a minor issue when multiplying decimals and floats or other trivial compilation errors) 

The third way to fix this would be to use your second example. By fixing the class so that it is a stateless class, multiple threads can call the same object as often at the same time as necessary because the data is stored outside of the class. So, as long as each thread is instantiating a separate object to store the data before passing it into the object, all the threads can share the same object without needing to worry about collisions. 

Then, you would need to create a separate factory class which creates all of these objects and wires them together properly: 

But again, the point is, you don't have to use that base class at all. At that point it's totally up to you how you implement each printer class. They may all share the same base class, there may be three different base classes, or you could implement them all separately with no shared inheritance at all. In fact, rather than using inheritance, you may want to create a separate helper class which includes all the common business logic, and then just inject it into each of the printer classes that need it, for instance: 

Aside from Pimgd's comments, I'd like to add that from an architecture point of view, you might want to reconsider your abilities. To make them easier to maintain, you should design all (or nearly all) abilities as just a dictionary of pure data. Figure out all the possible interactions and make key-value pairs for them. For example: 

We now run over 1000 times faster, yay! Cleaning up the Code One of the reasons this question took so long to answer is that your original code is very hard to read. I'm going to keep your logic intact but clean it up some, just to make it look a little more rubyish. 

Power Issue The increase in current when you increase the baud rate is expected behavior. See this question on the electrical engineering stack exchange for more details. Also see these guidelines on wireless considerations Arduino Code Some considerations: 

So when you do 2520 + (252 * 253 / 2) = 34,398 operations. When you do 360360 + (27720 * 27721 / 2) = 384,573,420 operations. This is not good. Practical Code Evaluation Now that we think we know what the code is doing, we can profile it to see what it is actually doing. I generated these numbers on your code using the ruby-prof gem after setting . (This is just a portion of the output) 

By doing it that way, you only need the single statement. Another side benefit is that you can now store the list of valid combinations somewhere else, outside of your code, such as in a configuration file or a database. Then you could load the data from that data source into the dictionary at run-time. 

The reason that the first example would be considered problematic when multiple threads are involved, is because in that example, a object maintains state (i.e. data) and it has methods that act upon that state. There's nothing wrong with designing classes that way, per se, and it doesn't mean that the class cannot be used by multi-threaded applications safely--it just makes multi-threading more difficult. For instance, consider this example: 

If each ID1 can only have one valid corresponding ID2, then I would recommend using a dictionary object to store the valid combinations, like this: 

When you think about it, it makes perfect logical sense. In the real world, you'd never even think of designing a car that creates it's own engine--that would be a nightmare. You of course would build a factory which would create both the car and then engine, and then put the engine into the car (inject it). The equivalent in code, would be to create a factory class, like this: