If there is no formula to calculate shoe size from one unit to another i suggest you to put sizes in some data structure and map them together. For example in Map. Then you just query the map instead this if-else hell. Same applies to the mapping. Also i see you use Strings a lot as a constants. Consider creating enumeration of some of them. 

I also think that methods like Should take a File instance as an argument - it should be responsible for writing to the file not opening it or creating some directories. Same for readFile method. 

First of all name your variables properly. Name of the variable should describe what it is, but is just a random letter not a name for variable. Consider using logger instead of printing to sout. Stream closing should go to the finally block not in try. You are nesting a lot of loops and ifs. Try to separate it into methods soo you and up with 

And don't mix classes from primefeaces and dao as suggested in axels comment. When creating this wrapper convert this view classes to some custom backend classes. in some object. I have class. It is much readible and convenient to use. Instead of use CollectionUtils.isEmpty I recommend you to extract nested ifs and loops to methods. Maybe when you extract them you will find some place where you can remove duplication. 

In Option #2 you cannot be sure that user of your class will pass new Object as a parameter. If you really want to create a clone of parameter you should create on yourself or implement some method on MyReferenceType 

Do not throw NullPointerException when arguments are null. NPE is thrown when you are trying to access properties and methods of null reference. Not when you are checking on some preconditions. Throw IllegalArgumentException as you do in length validation. In other method you use assertions. Chose one method and stick with it, dont mix them. You don have to define empty constructor. It is created implicitly. 

Classic DFS doesn't use any pruning. That means you should not have a list of nodes; Hence, my question in the comments. This means that for cyclic graphs DFS does not terminate by default which is why people commonly do pruning on visited nodes; however, revisiting nodes may be wanted, e.g. "list all paths from edge 1 to edge 5". Making the choice of using not only makes your graph acyclic, but rather "tree-ifys" (technical term ;-) ) it. 

Now my biology is lacking at best. I assume you are not respecting that because you can make the assumption to only ever deal with nucleic acids in DNA? Hence you ignore checking for that? You seem to further seem to be able to reduce this to only which I guess also has some very sound biological reason that I don't know. This will probably blow up if you aren't careful what files you put in. 

Again a debug statement. There is not much use of informing the user that a query has been executed. He cares for the side effect of this, i.e. if there have been the correct rows returned 

Output I've ran the and it tried to create a image. That's (Gigapixel)! as an uncompressed image is no fun. At least on my machine it doesn't fit into memory uncompressed. Similarly, if I look at your it doesn't seem to open correctly; I only get a reddish shadow. On your machine (assuming you have a bigger one, since you can apparently fit 30+GB into memory without issues) you might get more out of this. Fortunately most of these pixels are empty / transparent. In fact for only 2.2% of the pixels are not transparent. Potentially even less, because I've noticed that they sometimes overlap, e.g. a "GC" sequence would only be visible as "C" sticking out to the side. My attempt would be to use matplotlib, however that is still fairly slow and known to not cope too well with big data. It runs slightly faster then your initial version and the memory requirements are better; still its not enough for on my machine. Yet, you get an interactive figure that you can zoom around in and "take screenshots". I like this way to explore the sequence better. Another advantage is that you can specify file format and viewport, legends, axis and so forth. Here is the code for that: 

When second dao fails to delete and you have transactional daos not service, the first entity is lost. And you method should not return boolean, but let bubble the exception up into the service layer and let service handle the exception. 

EDIT Also do not put on your DAO classes but on Services. Service method describes unit of work which should be done whole or rollbacked. Consider this simple code 

Classes in model layers should be aware only of interface of underlying layers (DAOs or something similar). If it contains than you are telling your business model what view you are using. Send text from textfield directly in you service (model) methods. Or better send them some DTO wrapper object. You misused and . belongs to the controller or view layer and belongs to the model layer and check the business requirements. Also you duplicate the name of the cities. When you want to add new city you have to change the model and the view. Put them in one place (maybe something like CityRepository accessed by the Model layer classes) and get the cities from there. So to recap Model is businees view. It should contain validation and perform your business task (in your case some traint icket processing) and should be aware only about data model. View should be aware only of controller and provide interface to interact with and methods how to get the data from the user Controller Drives the flow - it gets the data from view, wrap it in some business objects (like TrainTicket, User, etc...) and pass it to the model, takes output from the model and present it through the view. 

Your method is very long. This is code smell - if method is long it maybe do a lot of thinks, but method should do one thing. I suggest you to split method into smaller peaces which defines smaller units of work and are reusable and easy to read. If you put piece of code into method you give name to the code which work as a hint to he programmer what code enclosed in method does. Also use full name of variables, not some abbreviation like . You write them once (if you are using ide) but read it multiple times so you invest the effor into the writing the proper name. I did not checked your logic. Your logic should be captured in unit test - if there is no unit test i would hesitate to refactor some code. If there is no unit test dont write them now if you dont have business requirements, but you ca try Characterization testing to capture current behavior of the method. Because without any test you cannot be sure if you did not broke something when rewriting the method. 

The latter half of that description is easy, we know that is really , and we can easily flatten doubly-nested lists with . The former portion we could implement on our own, or search Hoogle for to see if anything already exists in the or other modules that could help us out. In this case, we're looking for a function with the type , that is, we want to pass it a value and a list and have it return a list with that value inserted between each pair of elements. As luck would have it, there's a function in that does exactly what we're looking for called that comes up as the first result if we perform that search. Using these two functions, we can write a very short version of that reads almost like prose. 

This isn't that much of a mess at all. Let's clean it up, then get a little fancy. Right off the bat it seems a little funky to have a , as it appears you're not actually trying to account for agender individuals but instead providing for the failure to produce a for a particular . Operations that might fail in Haskell usually signal so by returning a value, so let's drop from the definition and see what needs changing. 

To break that down, since the list is supposed to be "circular" we safely pop the first element off the front of with (we either get the first element, or an empty list) and append that to the back of to get the wrapping property. (As an aside, this is complicated a small amount by being efficient, an equally correct solution to having a circular list would be , but that would end up checking the entire list for equality twice if isn't present.) Next we drop all elements from the front of the list that are not equal to , which either produces the empty list if the element isn't found, or the first tail of the list fronted by , i.e., , so we use as a safe version of (to again handle the case of an empty list) and end up with a list where the head element is our answer. Then produces the first element of the list, or if the list is empty. In principle this isn't much different from your original solution, I've just shrink-wrapped it down to the constituent pieces and arranged control through function composition. 

There are a lot of debug prints in your code snippet. I will mark them with a if I can't see any use for the end user. I would opt for removing them. 

There is a lot more you could do to the rest of the code, but that is out of scope for this question. 

There is a steep gap after buildins.sum, i.e. you spend most time there. We can use instead (pushing it down to 3.457 seconds): 

Here is my list of thoughts (in random order). Since you don't specify any particular goal I am reviewing mainly for "relative beauty" of the code: 

A) This is not very useful output. I would rather return how many lines have been inserted into the database or nothing at all. The fact that something happened somewhere while this code executed is implied by the user calling the script. B) If the script fails, you should inform the user; however, it is probably better to not catch any exception and then continue. The block will be executed regardless of what happens in . You can omit the entire block. A setup is thought of as a "cleanup block" which will make sure that the finally is executed before any exception is escalated. 

will concatenate all sequences, despite them potentially belonging to different DNA Sequences. Here is Wikipedia (the best source to cite xD): 

At this point we could start to tackle the loop, but it would start to get very micro optimized. One might consider aggregating the results in prob and then using and outside the loop, but that only nets like so it's more of a personal preference thing. 

I can also limit the amount of elements processed. That way I can visualize the first 10 million elements of . I find this visualization to be of limited use, but I guess it makes more sense to you? 

Here is a faster version (around per batch). Its essentially refactored for readability and often in vectorized code, more readability / code beauty makes code run faster: