(Note that in your code, it's actually impossible for a draw to occur, since you check both of the winning conditions with and , meaning that the condition will be caught in one of those. This may be a bug in your program. :) ) I might even make a function to avoid some copy-and-pasting: 

I'll leave an in-depth analysis to the true Python experts, but here are just some quick notes: Variable and function names: As far as I'm aware, variable and function names should have words/elements separated by underscores (e.g., , ) main() function: Instead of having your functionality on the first/default level of indentation, it's good form to wrap it in a and call it via: 

I'm being forced to use the common anti-pattern of a which many classes in this project implement. Long story short, I need to have a constant which is pre-populated with values. Normally I would do this like so: 

Also, if possible, could you give the variables better names? The first three are fairly self-explanatory, but once you get into all your random letters, it gets pretty hard to follow what you're trying to do in your code. For example: 

That's just my particular style, but even if you don't like mine, there should be a consistent structure you use throughout your code. 

Variable names: Try to have variable names which describe what the variable actually represents or holds. For example, I have no idea why you named your "kb". Method names: Method names should always be verb phrases (actions) which describe what the method does. So for example, your method might be better named or some such. Even just might work, though that might be a bit misleading and lead someone reading your code to believe that all the method does is add two numbers, when really the core functionality is user interface. Redundancy: Any time you are copy-pasting code, alarm bells should go off in your head. You do this in multiple places. Most notable is: 

You should always check if the parameters are passed in as null. Your code would fail with a null refererence exception at if is passed as null. 

Reading through the code, I can say that it is well written, concurrent access in mind, and at the first sight, it can be said that it has no flaws. I especially liked these lines: 

Method name is a common method name used by collection types to add a new element to the collection. An method with source as the first parameter and the items to be added as the second parameter does not make sense. and are bad names for parameters and should be changed at least to and or similar. And in Capitalization Conventions 

You keep track of class instances and not bare integer values, You can re-use this class in other projects or forms (if designed & implemented correctly), You can extend this class to enrich it's functions etc.. (There are an infinite number of benefits) 

Therefore, You can simplify the exact same behaviour at least in terms of the final state as follows: 

That's why we should first think about the primary concerns of our application, and try to seperate these concerns into classes, which can then also be re-used if designed modularity in mind. Therefore, Assuming what you are trying to achieve is something like this: 

Finally, the implementation, with all the naming convention violations and functional confusions fixed, might look like the following: 

The access is synchronized to the method. OK. For the threads that call at the same time passing the same instance, after the call to , is for only the first invoking thread. OK. All other threads get the existing instance after calling and is . OK is called on one of the first threads that call , most of the time the adding thread, but sometimes on another. OK After the call to , all requesting threads get the same instance out of one by one, as returned by . OK The first thread that gets the instance calls and succeeds. OK. After the instance is removed, other threads continue to get the old instance because they have the removed instance. OK 

[ln 60] Single responsibility: if 's purpose is to get news, it shouldn't also be dealing with notifying the user if there is none. Make this method return if there is no news to be had because of the , and do the check in the UI code [ln 55]: 

ServerManager.cs This class is generally good, apart from naming. Rename your variables here and you're OK on this class. 

More in general, this class is doing too much. This is the code-behind for , it seems, which should be an effector class (handling what the user sees). Make another class containing the helper methods like , , etc., for the business layer, and refer to it from . 

At the moment, I'm updating the record if there's already a vote by this user on this post, but I wonder if that's the most efficient strategy. Would destroying the old row and creating a new record be faster? I'd particularly appreciate efficiency comments - at the moment, this is a very server heavy action, which I'd like to minimise. 

Did you just... catch a generic exception? And ignore it? You need to work out what exceptions to catch and what to do with them. In this case, you're most likely to get a or , assuming your arguments are constructed properly so you don't get an or . So instead of catching a generic exception, catch both of those and tell someone about them. Something's gone wrong and this program doesn't work, I want to know why. 

Why is this here? If it's because you're waiting for the client to connect, this is a bad idea because you don't know if the client might actually take longer than 1 second to connect. Instead, you should execute the next line inside the event handler: 

You should try to use consistent style in your code. If you're going to put these checks and return statements at the beginning, either put them on the same line as the statement or don't. It doesn't matter which you do, as long as you do the same thing throughout. Makes your code much more readable and easier to maintain. 

This will let us set the references for each missile type upon initialization. With these references, each missile will be able to calculate its values on its own. 

This code will return if I pass in for both and . Is that intentional? It's unclear from the way you've written your code that that would be the desired result. When I think about it, it makes sense that the method would return in this scenario, but I'm not sure if you understood that consequence when you coded it, just based on the style. 

One last note: I could have just had them all be statements as well, since each only returns and removes the method call from the stack anyway, but I find that it makes the code more readable to have s, since it means the conditionals are logically joined to the reader. EDIT: I actually had to expand the initial checks slightly. Technically speaking, given your rules, if the is passed in as , it should return , not the empty string. 

I think the biggest problem here is that you're trying to do too much in a single line. It seems obscure because it is obscure. If I were looking at this outside of a Code Review setting, I would think that someone had purposefully obfuscated it or condensed it for some character count restriction. Consider breaking apart your lines in order to make your code more legible. Whoever looks over or has to maintain your code in the future (even if it's just you) will be incredibly grateful for it. I was going to try and break this down into a legitimate block of code, but I have absolutely no idea what your various variables are supposed to represent. What does the list hold (e.g., what is ? what is ?). But let's take your last line of code, which is at least somewhat comprehensible: 

What sorcery is this? You've conjured a string from thin air! Where did that come from? You should avoid magic strings where possible, instead assigning them to a or of commonly used phrases within your application. The same can be said for in the call: what is 1987 and where did it come from? Assign it to a resource list. Client.cs Code Analysis Says: Implement correctly. Your class nominally implements , but you've only written half the implementation. You also need a method, called by . If called as , it should also clean up managed resources; if it's you should only clean up your class' resources. You also need to tell the garbage collector not to run the finalizer on your class because you've already implemented . In this case there's no difference that I can see, so a few simple modifications: 

Where is declared? I can't find a field or property called in this class. If is a type, it needs a variable identifier after it; if it's a declaration and identifier, it needs a type before it. Were you trying to assign to ? I stand corrected: the property concerned does exist. Naming - the same points apply here as to Client. 

(A quick note on vote types: the column has type , and the possible values are 0 (upvote) or 1 (downvote)). 

String replacement If you've got a lot of replacements, or you plan on adding more, try an extensible solution instead of all the calls: 

What is this verb "Enqueue"? Method names of this format should be verb-object, as in "do this to this thing". If simply adds the passed object to a queue, the correct name is . 

Running Code Analysis in Visual Studio on this code throws up a few issues, with which I shall combine some of my own remarks. Program.cs 

And here are the results of the test, which shows the method is invoked a total of 5 times for all the 100 threads. The test created 100 threads which access the method randomly within 500 ms. There is another thread for removing the item from the cache in 100 ms continuously (This is because, the cache policy doesn't seem to effectively remove the item at the exact point of time of expiration). The method lasts for a random time between 0 and 500 ms With the following results, it can be seen that the method is invoked a total of 5 times (which is the number of the cache not containing a instance for the given credentials, first one because the cache is empty, and for 4 more times because it is removed from the cache) I can't help myself thinking why the of returns when the item is added to the cache. This would have been implemented differently (as returning the added instance as ConcurrentDictionary does) 

In that sense, the creatively defined method name and the parameter names and will not do. The General Naming Conventions states: 

EDIT 1: You also don't have to check and assign moannie if it is passed in as euro because it already has the value euro: 

I'm not suggesting to change to and to of course. The parameters should have descriptive names in the first place. You can consider and or similar. Possible Improvements Being consistent with code formatting is important. Consider using curly brackets, always: 

You should also check the items of the passed in collection for null references. If any of the items of the would be null, your code would fail with a null refererence exception at 

You can wrap your timers in ExecutionPlan class. Using a class for wrapping the timers have many benefits. 

This entire block is very difficult to scan. What it does isn't readily apparent by the way you've named all your variables. For example sounds like the rightmost node in the tree, but in fact it's the left node of the right node in the tree. Then with all the subsequent processing, it's very confusing without stepping through line-by-line to get a better understanding. Consider renaming your variables to be more meaningful. In my opinion, the most beautiful and elegant code is self-documenting. Also, if you were looking for ways to further improve the code's functionality (besides adding recursion), you might look into generic types so that your nodes can hold any data, rather than just an . 

You can shorten this long block of variable declarations as the following. Makes the code look a bit cleaner. 

This is a curious method. All method names should be verb phrases, firstly, and if this is taken as a verb phrase then it means you are executing the code to play again. But the really curious thing about it is this: you return if the user does not want to play again, and if they do want to play again. That's bizarre and completely counterintuitive. 

Break up the big multi-line message at the beginning rather than having it stretch on for 200 characters. (Purists will still say that the implemenation below has the second line too long, as the Python standard is to have no line exceeding 80 characters, but you get the idea.) 

What that means is that this is a prime candidate for encapsulation into its own method. Something like this: 

This was just an experiment to see if I could replicate something like C++ function pointers in Java. Basically, the idea was to have an object which represented a method call, and when you call on that object, the method would run. It feels a little sloppy to me, and I feel like there may be some tricks of Reflection and Generics that would make the code more elegant/usable which I haven't thought of or am not aware of. Any tips or tricks? 

is technically safe, and is fine for your current script, but if you want to adapt it for another script, it'll break. A more general, equivalent one-liner is: 

and its equivalent on the next line, is redundant: you should only use when you're passing in a delegate, and even then not always. Rewrite those two lines: 

can just be , because range starts at 0 by default. The syntax is essentially - the only mandatory param is . Filename parsing If you want to parse filenames by yourself rather than using a library, then while your current solution: 

Don't prefix your names like that. If you're adding a prefix, it should still follow all the rules of variable naming for C#. For private fields, variables are named in , with the underscore before it. Public properties are named in . So, you can rename a number of variables, for example should be . Server.cs I do believe I've found an error here. 

[ln 215] ? Seems like one list to me. Rename it; again, consider the point above that it should be . 

[ln 179] Folder !== Directory. Be consistent throughout: if this is a setting that a user needs to understand (hence why you used Folder instead of Directory), convert it to Directory code-side. 

[ln 30-31] Style choice: I recommend using around conditionals, even if they're only one line - because if you update them and make them more than one line and forget to add the brackets... exceptions. Also, your indents are off here. Indent the first line of the snippet above by one more space. 

I've written a userscript that pops up a dialog before you take a moderation action (closing, deleting) with some pro-forma comments, so that you can add one of those before you cast your vote. I'm pretty happy with how I wrote it, but what's clear to me is unlikely to be so to others. Is there anything in this that I could have "phrased" better, or that could be optimized more? Comments on style (or, for that matter, anything else) are also welcome. It also occurs to me that this isn't as extensible as it could be: it's not easy to add new comments. Is there anything I could do to facilitate this? I've also put this code in a gist, if you want to see it there.