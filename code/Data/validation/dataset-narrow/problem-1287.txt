and then plug your back in to the line equation to get the crossing point. From this we can intuitively read a couple of simple properties: If the line's direction and the plane's normal are perpendicular there is no crossing. is zero, which would be a divide by zero. describes how 'far' is from the plane in the direction of the plane's normal. N.Q then describes the ratio between the direction of the plane and the direction of the line - the more parallel the direction and normal, the faster it will intersect. 

This will fix a timestep to a multiple of 1/60. If you wanted an integer dt, just truncate again using . I'd advise against this, though. I would either find a more accurate timing method than what you're using or fix your timestep rather than a halfway house. 

Do you ever move the bounds? If not, then all the rectangles are always at 0, 0, 60, 60 and always intersecting. You need to move the bounds to the location of your ship/asteroid: 

To rotate a polygon around its centre like this, you need to draw it around the origin. Currently you're drawing it off-centre: 

This will give you a unit vector in the direction of from your left example, going counter-clockwise. If this sounds complicated, think of it as a clock hand that starts at 3 and goes counter-clockwise as the angle increases, and reaches back to 3 at 2*PI radians, or 360 degrees. To get extra-fancy, multiply these by a 'speed' value to get a velocity vector: 

Are you accidentally firing more than one missile at a time? Is it possible that your code creates two missiles at the same point in time and it's the second one that's hitting the asteroids? Edit: To solve the problem of removing asteroids and missiles, you create 'to remove' lists. Using your code: 

Your TextureOptions settings are likely to be the cause, see the call that you use for creating your TextureAtlas. Try the different TextureOptions and see which one you like the most. For more information, see the related thread on the AndEngine forum. 

There is no reason to do that unless you plan to reuse it. JointDef doesn't really do anything, as the name suggests, it is only a definition and even though you can change the fields, the Joint that was created using the JointDef will not change, as you probably discovered. What you want to do is store a reference to the Joint that is created using the JointDef and then manipulate the Joint itself. What exactly are you trying to accomplish? Specifying the problem better will help us provide you with a better answer. 

I think it is caused by a spike in CPU usage when you resume the game. Box2D works on a best-effort basis so when the CPU is being overloaded momentarily, the Box2D execution drops to too small a number of steps per second. This causes problems. There are two things you can do to improve the situation. a) Let the engine sleep for a while after the resume button is pressed. b) Implement MaxStepPhysicsWorld, you will find it on the AndEngine forums. It allows you to set a minimum steps the engine has to calculate each second and if it cannot keep up, the execution will slow down but it will not break down like this. 

You are only rotating the Shape, not the physics body. The Shapes follow the movement of the physics bodies of Box2D, not the other way round. 

This is not a callback, you have to call the method yourself to find out whether the Sprites collide. By overriding it you broke its functionality. What you want to do (I think) is override the onUpdate method of the Sprite and put there an if statement calling the method. 

If you want to protect your source, don't write it in HTML/Javascript? Part of the really nice things about the web as it's all human-readable. This makes it an excellent learning resource. If you're telling me that you've never looked at the source of a website to learn how it does something, then feel free to tell me I'm wrong. I'm all bout sharing the love with code, otherwise I wouldn't answer questions on a website about offering help, all for free, would I? Edit: I've said what I think of it, is there a way to make it non-readable? No, not in pure JS/HTML. The reason for this is simple: Somewhere down the line, it becomes readable. If you obfuscate it then a deobfuscator gets you. If you use a cipher or translate it somehow, at some point you have to translate it back into javascript (and the code to translate it back needs to be in your source too!). The best you can do is to protect against bandwidth theft and obfuscate if you really feel the need, but it's not going to stop people if they're really determined. 

which, when you put these into ctx.setTransform (along with the translation X and Y in the last two parameters) yields the correct result: jsfiddle.net/3ugzy/1/ But only works if the tile is centred at the origin. This is because if not, the offset from the origin also gets factored in to the transform and it goes slightly wonky. Hope that massive example helps! Sorry about the lack of hyperlinks, but I've kept the important ones in and de-linked the others to keep the spam police happy. 

The issue you have is that you're not taking into account the effect of the translation of the square away from the origin. ctx.rotate and ctx.scale both work relative to the top left of the canvas, at co-ordinates (0, 0). What this means is when you rotate your top left corner at (500, 100), it will move 45 degrees in an arc around from there. when it is scaled, it will just scale these corner positions, not the size of the rectangle around the corners. When you want to scale and rotate the square, you need to choose the anchor point on the square around which you rotate and undo the translation first. For example, here's an example using the top-left corner: jsfiddle.net/9atht/1/