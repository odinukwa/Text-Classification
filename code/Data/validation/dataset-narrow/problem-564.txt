I wouldn't rely on $.noConflict - Chaining: As pointed out in your question, you should be using something like that. jQuery is particularly good at this and you should make the most of it. Ex.: 

So lets break this down. The in the front is a safety net against unclosed scripts, which can be common if you use plugins in Wordpress, or if you concat and minify your files it will protect you from your function becoming an argument. Then we pass in , , and . We pass in and at the bottom assign it to jQuery. So now in this function, no matter what value the carried outside, in here it's jQuery. Then we pass in and . These are optional in your case, but a good idea since you do use references to in your code. It saves as a local variable, and also will be good when you minify your code as the reference can be changed to something like or automatically. Now keep in mind there might be times where you have to put your script in the header. Modernizr is an example of this. Then you'll probably end up using the . Don't sweat because all you have to do is this: 

Indeed, did you test how it behaves for very large (or very small) values, nevermind the performance? What will happen if I multiply by another one? What is supposed to happen? 

As explained in comments (in which I pointed out a few possible edge cases), even though it's not optimized in terms of performance, this is about as clear as it gets. A more clever algorithm - calculating the number of weekdays without iterating through all of them - is probably possible, but I bet it would be much less readable. If performance isn't a concern at this point, I'd leave it. You could maybe replace the loop with a LINQ-based solution. 

I think your code is good and more importantly it works. The main thing I would change is that huge if else statement. You repeat yourself a lot there. Here's another way you could do it: Also here's your edited fiddle. Acho que o seu trabalho está bom e mais importante ele funciona. A parte que chama minha atenção é o if/else enorme. Você se repete muito ali. Outra forma que você pode fazer é assim: 

That just makes the syntax so easy to rememeber as well. If you're going to use jQuery on a regular basis, I recommend that you take some time and read through the source code of the methods you're using. To find them quickly just use and type . That should jump you straight to what you want to know. This way you can understand what and how you are doing things, and even find better ways to do them on your own. Also if you see something you think should be done better or differently, you know how it works and you can contribute to jQuery. In your click functions you also might want to prevent the default browser action on a link, which is to direct the page to that link. Since you just want to perform something on your page and don't actually want the browser to leave the page you should prevent that action. You can do it by passing in for and running . I see you've used which does that, but if you want to read more on the difference between the two I would suggest [this article by Chris Coyier][1]. -Playing with visible elements: You're if statements from what I can tell are trying to detect scroll position and etc. I highly recommend you check out [this tiny plugin][2]. It basically detects if an element is visible or not at any given time. This may or may not help you out but I just thought I'd throw that out there. -Performance Wise: Focus on the event for now. The way you have it now, the code runs hundreds of times since it is called each time the window scrolls, even if the user isn't done scrolling. That's an increadible ammount of times your code will run for no reason. Not only that but then you run code on each element with the class of - more code that gets run. Now we don't want to do that since it can really slow down the browser, if not crash it all together. What you'll want to do is wait for when the user stops or is done scrolling, then run the code. 

But why would you assume that whatever time passed between opening the connection and disposing of the entire object, was consumed by query execution? Especially since you do this at the very end, after disposing of the connection, params object, transaction and command objects :) and the object is apparently supposed to be reusable (). Disposing 

We've cut on verbosity, but it's debatable to me whether it improves readability. It's harder to achieve the same thing for , although you could pull it through if you added a helper extension: 

from (minus the case sensitivity discrepancy). Unless there are some good reasons not to do so, I'd stick to only one implementation and reuse it in both methods. 

If you didn't know already, this type of plugin is referred to as an accordion. I would suggest reading the code for the jQuery plugin (since you are using jQuery) to find out how they do it. With this you can get ideas, see their organization, and if you find something that can be fixed/improved you'll have the power to contribute! To add to redexp's answer about the method. In your click functions you might want to prevent the default browser action on a link, which is to direct the page to that link. Since you just want to perform something on your page and don't actually want the browser to leave the page you should prevent that action. The difference between the two is that does that and at the same time stops event propagation. Propagation being when you click on an element, it triggers an event on the element, and any events on its parent elements (because technically they were also clicked). Whether or not you need to stop propagation is up to you, so pick accordingly. So basically: 

without the constants and the converting them to their respective classes? What value do you feel this additional abstraction layer adds to the code? (If you got rid of it, you'd only need implemented as follows: 

A red flag goes off for me every time I get to hear "this class does this, and that etc." - this is at odds with Single Responsibility Principle, stating that class should only have one. Do one thing, do it well. The infamous suffix is a code smell, too. How vague is that? All too often it actually means "I had no idea how to call it". In this case it's more of a naming issue, really - your doesn't really manage anything, it just builds database connections. Not connection strings, but connections themselves. Correspondingly, I would rename it to or perhaps - since it's not parameterized - . It describes what it does way more accurately. I would also try to be consistent - if you have: 

You'll see several variations of this all over the internet as you read to find out more. The one I recommend you use in this case is like this: 

Here they don't return the jQuery object, since this utility is for arrays. My point here is that there's no one shoe fits all. It depends on what you're trying to get from your plugin. Also chaining is expected but not on something like $.map(). Also keep in mind, in your callbacks should refer to the element in question (ie. in a click callback refers to the clicked element). If you're not playing with an element, should refer to the global(window) object. 

Thanks to this pattern any new formats can be added as separate classes (supporting the interface), so the system is open for extension, and they can be registered within the factory. The base routine () is closed, which is what we want. The factory only carries one responsibility, which is to match any given file type to respective behavior, or file processing strategy. This means there is only one ever one reason to modify the factory: when this logic needs to be enhanced, or modified. 

Now you can't call eg. . Other than removing the "m" prefix from the parameter name, I wouldn't also keep it named "activity". It's an class, not an (instance object) itself. I'd rename it to . 

This works just fine and fulfills all the requirements from the assignment. What I want to know is how can I improve this code while still remaining within the requirements. Also any reading materials/videos that you think would be useful for my learning please feel free to share them. Main Race file: 

UPDATE I've looked at your .js file and there's quite a bit I would change. But focus on the resize event for now. The way you have it now, the code runs hundreds of times since it is called each time the window size changes, even if the user isn't done resizing. Now we don't want to do that since it can really slow down the browser, if not crash it all together. So what you want to do is only run when the user stops or is done resizing, then run the code. Here's an example of how I'd probably do it: 

It's not bad already (save for the weird formatting of parameters, what's with commas at the beginning of the line? : ) But that's a matter of taste, and beyond the point). You could return to the trick you used in your previous implementation to avoid breaking the chain and get rid of value reassignments by pushing into the predicate, like so: 

There, I'll say it: it can't be done. C# doesn't allow identifiers to start with digits. All workarounds either won't meet all your requirements (eg. @radarbob's answer, while clever, doesn't let you narrow down numeric values to a predefined set of legal ones, which I understand to be your main goal) - or will get you on a ride that ends up back on square one (if you use a dictionary as @Malachi suggests, then the name of this dictionary will go upfront, and it still doesn't start with a digit). Underscore prefixes are as close as you can get. Abusing Unicode a bit might work to a degree: 

Here are some general things you should be doing differently. These suggestions don't change the functionality of your slider, and are suggestions you can apply to your future projects. First and most important 

If you wanted to change your code a bit here's an example with using child selectors. If you have question about any of these methods just let me know and I can explain them. You can also read up the jQuery documentation for each one to get a better idea of what's going on. Also here's a Fiddle: $URL$ 

As a rule of thumb, when you use a jQuery selection more than once, you should cache its value. When you do , jQuery now has to go find that element in the DOM, wrap it in the jQuery object and return it. If you save what it returns, then you only do the search once - not every time you use it. The hard part is caching . This is relative to where you are in the code, function, callback, etc. and changes to provide context. For example: