If the problem is #2, which is the least likely IMO, there is nothing you can do. If the problem is #1, which is the next least likely, you will have to return the pi and try a new one. If the problem is #3, which is the most likely, you need to try another power supply. Personally, I have not found a supply stamped 1+ amps that would not power up any kind of pi. However, it could be that all of mine are decent quality, since there have been people with problems similar to yours and certainly the #1 most successful fix for them reported around here is "I tried another power supply and it worked!". 

The Pi isn't really a "linux" anything, it just so happens that GNU/Linux, more specifically Raspbian, which is more-or-less Debian with some tweaks (and also a few pieces of pi specific software -- the Foundation seems to have a dev that puts some work into adding stuff to the GUI, etc, as demonstrated by some recent additions -- but there are some independent things as well, such as ) has come to predominate amongst the userbase, with the encouragement of the designers/manufacturers. There are a number of reasons this worked out that way: 

IMO it sounds more awkward than elegant; since the pi's wifi is on USB and it's the USB bus that's the bottleneck there, this won't be any faster. It is possible; Android has an API for USB, obviously, as does linux, but here's the catch: the linux API is not a userspace one. I.e., you might need to be writing a kernel driver for communicating with the phone. There is also libusb. You could look into the source code for adb, not sure if that is C or java. It does not involve a special kernel driver, implying there is some option via a generic userspace interface. At a glance, having flirted with the kernel USB interface before, I'd say you are looking at way, way more work this way, to accomplish something that is going to be no faster, and much more awkward, than a wifi one. Using network sockets, OTOH, is relatively simple. If you haven't learned network programming yet, you might as well now. It's certainly going to be a lot more generally useful than knowing how to write a USB driver. Not quite as cool of course. 

Turning an led on and off. Using a button to to indicate state in a program (e.g., one that turns an led on and off). 

A SIM900 has autobaud set by default; it will detect the rate (to a maximum of 115200?). So until you set it differently, it should not be a problem. That board was made for an Arduino, however, and is very unlikely to provide a 3.3V logic. I had a Kuman board exactly like that; it does not actually do anything with the voltage, meaning the logic is at the level of the GSM, 2.8V: $URL$ This is confusing because some boards sold with a SIM900, e.g., I believe that red one from the picture, come with selectable logic (3.3V and 5V). However, no one makes that claim for this one (and this Amazon UK ad makes it explicit the breakout connections are all 2.8V). If you look at the traces on the board, tx and rx go straight to the module with no intervening circuitry. I used it with a level shifter (beware this is the inverse from that example; you are shifting down to 2.8V instead of up to 5). For that you need a 2.8V reference in addition to the tx/rx lines; if you look in the corner by the pink jack you will find a connection labelled "2V8" for this purpose. There is the outside chance that you may have damaged it using 3.3V but I think that is unlikely. As other people have recommended, I suggest you use a serial terminal app to communicate before you use your own code. The thing I've found most useful for this is which is installed along with the python serial libs. Minicom is fancier but also more tempermental. 

1. Actually, there's another system logger integrated into systemd, the init system, called . However, since it's files are not human readable text it is not of much use particularly if you are, e.g., examining a card from a failed system in another computer. 

A single screenful, which is easy to glance over. But there is no mention of "gnueabi". "arm-linux-gnueabi" is actually a tuple used to identify the target of a compiler. In this case, the target is the same as the base system, so we can assume that the normal compiler will work in this case (it would have been good if you had included a link to the instructions you are following). We just need to make sure we get at least version 4.6; the list returned from the last search (which I omitted here) contains reference to 4.4 through 4.7. As it so happens, the current default on raspbian is 4.6, so just plain: 

However, while I am sure the Pi designers were aware of linux, I think it would be pushing things a bit to say it was actually designed for it. Embedded... Simply refers to a computer system dedicated to a special purpose, where the computer is not really a defining focal point of the "thing" as a whole (although it is probably essential to it functioning). This covers everything from your set-top cable box to the electronic brains in cars, military weapons systems, etc. They may be small and simple or large and complex. The linux kernel (as distinct from the aforementioned userland paired with it in general purpose systems) had a well established place in parts of this realm already (including those set-top boxes, and home routers, and no doubt all kinds of other things like POS systems, etc.). The Pi all by itself isn't really an "embedded" device in this sense, as it has a general purpose set of peripheral interfaces and was not designed with any specific purpose in mind. But its small form factor and low power and cost make it a good candidate for all sorts of embedded scenarios. This is why a more appropriate categorization is "dev(elopment) board". It is an ideal platform for prototyping small scale embedded systems. 

There are a few ways of reacting to both the rising and falling edge. The obvious and easy one is to write to the file. An apparently common pitfall with buttons is "bounce", whereby the signal may oscillate when the button is depressed or released. A programmatic solution is to "debounce" by discarding multiple changes within a brief window. This doesn't require a sleep, it just requires you timestamp events.1 So, once the GPIOs are configured (as inputs, set active low with a trigger on both edges) the file handles are set up with a mask and handed to . Since returns with a list of handles that actually fired, I created a hash table () corresponding handles to objects. Thus the main loop begins: 

Right now, if I go into "Device Drivers" I will not see this option. First I have to enable "SPI support", which activates the first two above. Then, since is enabled (this is actually ARMv7 for the pi 2; for earlier pi's it would have been ), I can go into the submenu and find both 

"linux-source" is the basename of the source packages. If anything turns up, use on it. If that doesn't clear out , you can just mass delete whatever is left. 

You won't necessarily notice the ACT light blinking; on a successful boot, once the kernel loads the ACT light only indicates SD card activity, whereas with a boot which fails before the kernel loads it will produce a regular pattern of blinks, possibly repeated in a loop, or (on the 2/+ models) if there is no SD card (or the reader does not like the card), a solid green ACT1. Note on the A/B models, no SD card will not light ACT, which could be confused with a successful boot. However, since there is generally more SD card action than just loading the kernel at boot, usually there will be irregular flickering for few seconds. Not noticing any, i.e., just getting a steady PWR, does not necessarily mean the boot failed, but it could, as a result of a kernel/init hang or hardware damage -- you would have to plug in a screen to tell the difference between these three things (successful boot, broken hardware, kernel or init hang). Put another way, no ACT light could indicate: 

This is because the UID number for on the Pi is evidently the same as the number for on Ubuntu. A variant on this is when the number isn't attached to any user account (they are all listed in , which IMO is sort of an unfortunate name since most of the information in it has nothing to do with passwords). In this case, the file will just have that number associated with it. I.e., when you see this, it isn't because there's a user named , it's because the file came from some other system with a user number that's not listed locally. [Technically there can be a user named but never mind that.] 

This is just meant to be illustrative. The default of an output pin is 0, so setting it as such will turn the power off. Note that I did not use here simply because 2 and 3 are the I2C bus and you should leave it as is and not connect things to it that aren't meant to be. The interface uses the commonplace Broadcom numbering; GPIOs 17, 27, and 22 are adjacent on the inside row (physically 11, 13, 15). This will not persist across reboots, or after the settings are changed by some other program. Short of creating your own bootloader, kernel, etc., there is no simple way to make this the default. The pins start up as floating inputs to prevent accidental shorts. I'm sure there are plenty of ways to leave the pins this way using python, C, etc. as well. 

This will start a subshell in the background which sleeps for 150 seconds (2.5 minutes) before starting the the process. You could also drop that code straight into (omitting the shebang line, ). 

This will print a "backtrace". If it asks you to install "debug-infos" (it probably will), do that and repeat the process until it doesn't ask again (to quit gdb each time, use and say ). At that point, copy paste the backtrace and include it in your bug report. You can copy paste with the mouse in console mode if you install and run (the "general purpose mouse" daemon) but probably this will be easiest in a GUI terminal. 

Right, so look them up one at a time. If you are confused or uncertain, then ask a concrete, specific, singular, focussed question about that term. WRT "this causes me to go into deep detail causing me to learn things that I sometimes don't need to know at all": That is a pitfall of learning. Learning is a skill. With practice, you will hone your ability to judge when to let go and when to continue. But if you throw up your hands because learning how to learn is too hard, well -- good luck... 

1. Ignore the "Exporting from Kernel code" section there. That's not what you are doing, you're writing userland code and there are no special C functions involved. 

You don't explain what you mean by "similar". If you mean more or less the same, then obviously the result here is predictable. If that's all it is, I would not worry too much for now, but also don't do the same thing over and over again expecting a different result. If you want a GUI-less install, start with the jessie-lite image (presuming you are using Raspbian). My preference is to actually start with the jessie-lite image (about 1.5 GB) and then install the GUI the way I want it; including a WM and various applications this adds another 1/2 GB, which is why I am pretty sure "x11-*" doesn't add up to much, depending on what also gets removed. I'm guessing might do quite a bit and saved you somewhere around that, but before you take a wall down with a sledgehammer, make sure you understand what's in the wall. If you aren't sure, don't use a sledgehammer. 

Once an SD card starts producing errors I believe it is defunct. They generally use a methodology called wear levelling (apparently often via a 32-bit ARM microcontroller) to maximize their lifespan.1 This means the addresses the card exposes are virtual, they do not literally correspond to specific physical blocks; a consequence of wear levelling is that any correspondence is prone to re-arrangement. In other words, block 106 may physically be the right after block 105, but at any point the microcontroller may change that, and this mechanism is independent of whatever computer it is plugged into and the OS accessing it. The addressing is opaque, and dynamic under the hood. I would think the wear levelling also throws away bad physical addresses internally, but perhaps not (it may not recognize they are bad). If it exposes them: 

You cannot usefully do anything network related before the Pi boots up properly. I think you have just misconstrued the concept of "booting", and what you really mean is you want the Pi to boot up the first time in a state where the goal is to get a wifi configuration somehow. 

No, because the pi does not have an RTC (real time clock), although you could connect one. However, that won't do you much good because something else the pi does not have is a sleep state. It is either on, because the power is attached, or off, because the power is not attached. It cannot be made to sleep. 

I'd presume these correspond to the CEA modes from here: $URL$ Although the state ID is not specified, your output matches "HDMI CEA (16)" as 1080p @ 60 Hz. Note there are two lists there, the first one is for when using CEA (predominantly TV) modes and the other for DMT (more appropriate to computer monitors). 

This should avoid invoking the userspace driver because of ("-i, --internal-only: Don't call the [userspace] helper even if it exists <- ). If you don't get any errors, check . There should not be any such process running; it will exit right away having invoked the kernel driver if present. If there is such a process, it's probably the same thing as . If not, the partition should be mounted and available.