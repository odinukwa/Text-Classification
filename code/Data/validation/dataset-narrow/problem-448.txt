To improve you code, I recommend create a class/struct that stores the attribute name and value, like this: 

instead. I think it would still work either way (I did not test it), which is one of those gray areas between arrays and pointers. 

Personally, I'd go with the second option. This "aligns" your objects more, so one object isn't doing the work or holding the information of another. And, it makes more sense in real life: at a real race, you could place a single bet that applied to multiple teams; you place multiple bets, one for each team. 

Simplification with variables There are quite a few places where you could both simplify and speed up your code if you used variables to access repeated data. For example, in: 

ASCII numbers This is also against the challenge output. Most compression services don't leave an intentionally readable output file in the end. In that case, there is not much need to have the numbers accompanying the letters be ASCII. That way, when it comes to large repetitions of characters (at least > 10), you will not be spending an extra byte or two. Now, you may think: if the number got high enough, it might interfere with the file content. That is true; but your code will do this now too. However, when decompressing, it can be kept in mind that the compression will result in two byte pairs: one byte for the character, one byte the character occurrences. 

You are re-inventing the wheel here. Form fields already have a property called . As the name suggests, it forces a field to be properly filled out before the form can be submitted. You can use it simply like this: 

Notice how there is no at the end of the conditional? JavaScript already checks to see if the conditional reduces to automatically. Now we have to find a way to set the other two values in the object to in a DRY way. I think it would be best to create a function that takes in one argument that is the name of the property that should not be set to false, and then the function sets the other properties to false That would look like this: 

Now, for the converting. This process will be very easy since we already have a handy dandy dictionary that holds all the information we need for converting. All we need to do is divide the amount of basic units of the first type by the amount of basic units for the second type, and then multiply the input number by that result. Here is what that would look like: 

My guess on why this gets sluggish is because you have an infinite loop in that creates a new thread every loop. 

I don't know why you have the two trailing 0's on the interval - JavaScript reads a trailing 0 as an octal number. in octal is equal to decimal. Global variable In your function , in the first for loop, you declare the variable , but you make it global - as in, you didn't append to the beginning. This is not good practice, and can cause errors if other functions or scripts on a page are using the same variable name. What you wrote: 

Unnecessary instruction This MIGHT work; I didn't have the time to test it out Instructions like , , and don't have to be used after a instruction; they can also be used after arithmetic is performed. Instead of doing: 

Then, instead of accessing the element by passing it's ID to , you use the ID - 1 as an indexer in this array to access an element. This will significantly boost the efficiency of your code. Note: I am not very good with HTML, but it may not be good practice to use the in this case, but rather a custom property. 

It would be simpler to just create the class and put this as a property of the class. Same thing goes for . Those variables are states of the stadium and should therefore be apart of the class. 

Instead of having a field called and a field called , I recommend just keeping but having it default to . This will tell you three things now: 

You generated a number between 0 and 1000 in the first place, so this conditional is always going to pass. 

This is somewhat confusing. You should move the declaration right above the loop, and move the incrementing into the signature. 

User-supplied output buffer Right now, the reverse string is just printed straight to STDOUT. To make this more flexible and so that it follows the single responsibility principle, you could have the function accept an output buffer to stick the reversed string into: 

The special cases are the first and last element: you've written two conditionals and are storing extra data just so you can handle these two separately from the rest. Rather than that, it would be a lot simpler and a lot cleaner in the loop if you instead modified the elements after the loop: 

This code will be much faster now because rather than constantly accessing local storage, you can access this local object instead. Of course, this data will not be stored when the browser closes, so another method is needed to save this data back to local storage. You can call this : 

This element's children is the child that is being repeated; the child that we are trying to grab and stick into it's own directive. So now, the next step is really simple: 

concerns me. What if this conditional returns ? Calling on it would result in a . Are you handling this somewhere else in your code? 

I don't really know if this has to do with practice, but it sure is weird: this object is the exact same thing every time. It would make a lot more sense to put this outside of the function so it is loaded once and only once, rather than it being created and destroyed every time the function starts and stops. 

You do this in a few other spots, along with the above recommendation. You should fix those spots too. 

Isn't this a little redundant and inefficient? Wouldn't it be easier to just store in a variable, and then to re- it back into the array when you are done? 

Why are you creating a variable with an extremely simplistic value, and then having it returned from the function in the very next line? Wouldn't it make a lot more sense to just do: 

You should move outside of the statement because you don't need to redefine the timeout time every loop. There are two kinds of errors that could happen here: a timeout error, and an from .