This keeps my code DRYer and I don't need to worry misprinting or forgetting to return it (your does need a !) You don't handle errors (but you knew this already ;-) Your has way too many dependencies and responsibilities. The best practice is to keep your controllers "thin" with the sole responsibility to glue your data with its scope. Changing routes (states) looks like one job too much. Say you want to keep another sing-up form elsewhere with its own controller - will you really want to copy over all the logic? This is good for prototyping but is generally to be avoided in production: 

Your code is manually recreating HTML, which is an anti-pattern. The Angular way is to supply separately HTML template and its data scope object. 

First thing that strikes me is the inconsistency of naming. Why using different styles for constants? Your does not need to , see here. I would use something like instead of as Form has another meaning. As a personal preference I like to write my as 

Warning. Keep in mind using inside HTML, that your code becomes invalid as soon as those s are not unique. This can easily happen by copy-paste and forgetting to change the . Unless you use reliable validators, and consider this a feature to help your validators, I would avoid using s whatsoever. Styling can be done merely with classes and is a recommended way. 

Then it is the job of the directive to pick the right model and make it available under this name. This way I can change to inside without breaking things, so the directive is more encapsulated and re-usable. 

I would also suggest that you always use brackets for your statements. It's generally accepted common practice and with good reason - the few lines that you save by not doing so lead to some very insidious bugs. On an algorithmic note: why reverse the at all? Use one loop and read the both forwards and backwards simultaneously. For further improvement, walk through a comparison manually: 

Others have covered bad practices here, I am just going to demonstrate a Java 8 solution to the problem - as Java 8 is the current version of Java; I believe this is what should be written in modern Java: 

So I am using a for-comprehension over the tweetsfile to each line in the file to its corresponding number. So my question is, how would you rewrite the above the maximise speed and minimise memory usage. Any other comments on the Python would be welcome too. I realise that I can use a single-producer -> multiple-consumer pattern to speed up the processing of the file, but I would for now like to stick with a single thread. 

You're close to a sieve, but you're missing some points. First and foremost your is incorrect - this should step though the range in steps of ; this very fact precludes the use of a . The usual approach uses a , on which you carry out the following steps: 

I don't like this. I think if you are going to down the route of using then use it for all references that won't change, that includes: 

then you should have two different classes to represent them. The first type should not have a car field at all. The second should not be creatable without being passed a non-null car object. Depending on the rest of your code, the second class could be a subclass of the first (with the addition of a car field amongst other things) or share an interface with the first (preferred option of those two) or the request could be an entirely separate class, replaced with a car-containing rectification by a factory. Either way, only need specify the second type as input. And immediately a whole category of errors is eliminated. There is no need to check for the existence of a car when it is guaranteed to be present. If you do it this way, you never have to check for the presence of a real car. Any method that depends on the existence of a car simply has to specify the car-owning type. I would not be surprised if other stages in the lifecycle of rectifications can be treated this way. If you create a common rectification interface but 

It is clear that I have comprehensively covered the possible range of states (OK, I haven't dealt with Null but this is Scala - don't use Null). The corresponding actions are simple and the small differences between each one easy to see. 

Oh, what happened to ? Why does that work without it? The answer is that Scala's does an implicit conversion of the array to a list. Google if you want to learn something about Scala collection internals. Over-specific types Once those three functions are rewritten to use combinators rather than pattern matching, they don't need to take or return . They could take and return . This gives you more freedom abut what you pass in (could be , could be some other -based collection). No performance penalty (the appropriate filter/map/flatmap of the actual type will be called) and much more flexibility. OK, at the end you would have to convert the sequence back into a list (or whatever you want the final form to be), but this allows you delay that decision till it is important. This is that extra bonus I mentioned before. And I'm about to explain why using - or possibly could give a big performance boost. Multiple traversals and intermediate collections returns an iterator (a lazy, one-pass collection which only processes each element on demand). But you immediately convert it to a list, reading the whole (potentially large) file into memory. Then each transformation in turn creates an entirely new collection. So you actually create 4 collections in a row, traversing the entire contents of the file 3 times (possibly 4 if there are no empty or comment-only lines). But I'm pretty sure you only care about the final one. Even if you always want to process the entire file, that's expensive (the bigger the file, the worse it gets). And what if you only want to process the first lines or process the file in chunks, not wasting memory on processed and not-yet-processed chunks? There's a pretty simple solution which will give you all those options (but which doesn't force you to overcomplicate things just because you might want those options later). 

You don't use any of the properties of . You do not need to know that it is a . I would specify the argument as and leave the invoking class to decide on an implementation. Brackets There are two styles of using curly brackets in Java, and either are valid: 

Are horrible! If you need to label a variable declaration with what that variable is, you have picked the wrong name. Further, if you are going to use inline comments, avoid the case where the comment makes the line so long that it's illegible. 

Firstly because of the scope of and also because loop indicies should be incremented inside a declaration unless you have a good reason not to. I would prefer the following construct as it show that I have two variables used in the loop, that the termination condition is and that I increment every iteration. 

But (and this is a big one for style) you should only use one type. You have got one type in some places and the other type in other places. Set a preferred style in your IDE and stick to it. Also, if using Egyptian brackets (the first style) please leave a space between the statement and the opening bracket. Comments Comments like this: 

it's recursive - Java doesn't handle tail optimisation and recursion is slow It makes a rather large number of copies - copies the underlying it's very long 

So we check whether the game is over after reading a new value from the user. In the winning condition we call which interrupts the clock thread and causes it to exit. 

Having looked at your code I can see one major problem - your directive hides but does not isolate its scope. That makes it vulnerable to both external and internal changes. Internally you may change a variable and forget to adjust it and suddenly your directive is using the same named variable from outside! Imagine all the bad things can happen to your directive! That makes the maintenance a nightmare - you can't even use reliable tests to catch the "leaky" variables that you forgot to declare. They will keep "sleeping" quietly deep inside your code until the wake-up explosion :) Your directive seems to be intended as encapsulated drop-in component. For which Angular's isolate scope is the best solution. The isolated declaration inside your directive tells you exactly which attributes are "allowed" inside and how are they named. You see it clearly right at the top of your directive, which makes your code more readable and maintainable. Now you can change the outside-inside coupling nicely inside that declaration. That also would make your code cleaner, shorter and DRYer. As side remark, I would generally try to avoid, if possible, the low-level "system functions" such as , etc. They are used by Angular internally to expose more user-friendly (and reader-friendly) API to you. Such as the isolated scope binding and using filters rather inside your templates (i.e. what it is meant to). 

I would try to split into simple pure functions doing one thing each. Search for Robert Martin aka Uncle Bob advices on clean code. Is this just a helper to display an array: 

Do not break down non-matching sequences but preserve them Do discard an initial (as in your code) Wrap failing iterables in and passing iterables in 

Point 2 is actually the more important one. To choose an apt analogy, you know the story of the peasant who asked the emperor to place one grain of rice on the first square of a chessboard, two on the next, four on the next and so on through powers of two? And the whole empire is bankrupt before square 64? That's what you're doing. You are forcing Haskell to consider every possible variation, which would be costly even in an imperative language but is more so here. In an imperative language, you would use lots of tricks to detect when you can abandon one branch of the permutations and track back. The advantage of lazy Haskell is that you can greatly simplify such code by "creating" large or even infinite structures, but only every evaluating small sections of them. The trick is to only ask for what you need. Here's part of a much more idiomatic and also much more performant n-queens solution: 

Option's fold evaluates and returns the first parameter only if the Option contains Nothing. Otherwise it unwraps the value and applies the function. There is much disagreement about which is better. 

I used the same variable name in both groupBy and map. Those are two separate closures so can reuse the same single-item name. I placed spaces around the operators. Scala can be dense enough (and also permits non-alphanumeric characters in variable and function names) without more density. 

There is no way I see here that this directive listens to an event and no clue what the event is. A better design would be: 

Again, pure functions without side-effects are easier to test in isolation. Use the and methods on arrays for shorter and simpler code and libraries such as Ramda (my favourite) or Lodash. 

looks hardcoded and non-reusable to me, but then again, I don't know its purpose and the level of abstraction. 

You are re-defining , which is a bad practice. It will break the chain, forget all your previous properties and can lead to unintended effects if using (which isn't good idea too unless you know what you are doing). It is better to specify individual properties of it. 

In that case, is a function argument, so using it won't throw any error (in contrast to a variable) and hence there is no need for . Also note that evaluates to , so the two expressions are different, strictly speaking. 

The last argument inside is too far away down, making the code hard to read. It is better to define your function separately, and use it a short line inside . Also executing your function inside is a recipe for errors and hard reading. 

I am puzzled by how you use both inside and outside . Each iteration of has its own scope, so its own . For instance, if , which item do you mean to use inside ? The way it is used now, the seen by that function will be another on the outside scope. If this is the intention, this variable should be named differently: 

Set everything to as you don't know if anything is a composite. This isn't really required as in Java is by default. Starting with to , if , loop over for while in increments of and set . You now have an where anything that is () is a prime. 

So we create a to communicate between the clock and the main . We place a sleep in the clock thread that sleeps for seconds, if the thread is interrupted before waking, it simply exits. This is much more efficient than your busy wait as it doesn't tie up an entire CPU core for absolutely no reason. Never busy wait! We can now modify the game loop to: 

Iterators Kudos for correctly using an to from a while iterating. But, as described above, this is not the correct approach to implementing a Sieve. Programming to the I don't link this method declaration: 

So whilst I have a lot of tweet data, I only need a list of integers. This is obviously much smaller. I want to be able to stream the data from the file and convert each line to its sentiment value in the most efficient way possible. Here's what I came up with: 

read a tweet file, with a JSON tweet on each line parse each tweet to a using extract the field from the tweet - giving the content of the tweet for each word in the content, check it if has a sentiment for each sentiment word in the tweet, calculate it's value (from the AFINN ) and sum across the tweet store that number