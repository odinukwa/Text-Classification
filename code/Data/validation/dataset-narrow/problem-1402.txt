You seem to be stacking matrix calculations. The "node original transform sources" should be kept pristine while calculating "node in the graph stuff". Assuming your original code looks a bit like this: 

Now with this your get a whole lot of flexibility in the tweaking of your cards :) And you can add some without having to recompile, provided that all the effects are already programmed in the game. 

No. And there is rarely a need for exact physics replication. You mention multiplayer in your tags. Generally, in a multiplayer game, the physics and game logic is performed by one instance, which can be the server hosting the game, or one of the client that hosts the game. Each simulation step, that authority, the server, performs logic update and physics update then send the resulting game state to all of the clients. The clients draw the scene upon reception of these events. This way, all of the clients do not need to compute physics, they only draw. This removes a load from the clients, and it allows every one to have the same simulation. Plus it helps against cheating! Game clients still can simulate physics for: 

You have rectangles A, B and C A directly above and is overlapping B, which is above and overlapping C. The update for A is done, pushes it a bit up. The update for B is done, pushes it a bit up because of C, and a bit down because of A. B because it did not move because your [x|y]Shift is cumulative for all of the neighbours. Deadlock because this is the situation of a chain in your rectangles. 

Keep in mind that your players will want to play the game, not be bothered by the story: make sure they know there is one and give them access to it if they want to live it, but don't force them to have to go through it in order to play. 

you use the position that are set in the nodes to infer the location and the orientation. this will depend on the implementation of your node graph. use a path-finding algorithm like A* to find the best route between your current location and the destination. Your graph, again, will be used for that. 

Obviously, this will depend on your implementation, but this could give you an idea on how it could be done. 

The basic idea is that you extend your car's collision box, based on the current velocity of the car. If this extension collides with a car or with car's extension box, you can assume that there will be a collision, so you must have the car that is the most 'behind' to avoid the collision. There seem to be a nice article here. They use vectors, but you'd want to use boxes in your case. 

An option would be to remain quite vague in the description, but to add another section which simply states facts: 

The gun position is not the same when viewed from the FPS player perspective than from the 3rd other players perspective. This is due to the fact that both of these views need to look "realistic". And there is no magic potion to make the look and feel applicable for both of them. In the first-person-view, you rarely see the character's body, so what the player sees is only the hands and the gun, tuned so that it has a look and feel realistic. And the 3d artists can work with the models that you see in 3rd person so that they too look realistic. 

If I understand correctly your question, one way to achieve it would be to clear the list each frame to make sure you list is always up to date. Please note that I do not know exactly the syntax to clear a list, but your function would look like this: 

The 'explosion' you see when two units spawn at the same location is a normal behaviour with collision engines. To try to avoid this situation, you can try and limit the maximum distance each unit can travel each frame. 

This way of doing things allows you to combine small effects/actions into a card, which can offer a bit more flexibility in the design: you can create new cards by simply adding a chunk of xml. 

One way to do it would be to wait until all your collision detection is done before 'reacting' to it. You could then check if it touches only the water and not the log before 'reacting' to the event. Example game loop: 

You don't seem to need the angle, only the delta vector between the two positions. vA = vector representing position of A vB = vector representing position of B vD = vA - vB // distance and direction to travel vD / len(vD) = vDu // direction of travel And you multiply vDu with your speed per frame, this will give you the distance per frame. 

To get to what you need, I suggest to do one step at a time. ("Ok, is my sword properly centered from the origin? No, ok let's do that... Ok, done, now let's try to rotate it about it's new origin... ok now it works as I'd like it to... ok, finally, let's put it in its final position... and... done!") That's usually what I do, otherwise I get lost and do not fully understand the process. 

You could try and compose a sprite based on the vertices of the GameObjects that you bend. This would help hide the 'chain' that is behind.In the image bellow, in black is your original "chain". You take some precise location on it and you make out of it a new "continuous chain", drawn in red. 

Detect the collision between Dude0 and Dude1. Is Dude0 or Dude1 having his flag set? Yes? Go on detecting collisions. 

It's unclear where your issue lies. To rotate a vector about the origin, you create a rotation matrix, and then you multiply the vertex by the matrix. In order to create the rotation matrix, you need a rotation axis and an angle. With glm, you can do it this way: 

The goal is to rise awareness and get as much potential players to follow you before the release of your game. As you might have noticed, most of this must be started long before the game is released to hook as much as people as possible. This has the advantage of getting feedback during the development of the game because people will comment on what you post. 

Nothing beats practice. Reading the manuals will give you a good start at knowing what features exist and how to use each one individually. But generally, what you want to do is not available in text books so you have to figure out how to assemble parts of what you know to achieve the result you're looking for. That's where practice comes in. And forums. And stack exchange. Or a teacher. Or a colleague. And youtube. And practice. So, to answer: It is good to read manuals, but it is not enough to get good at it. 

You delegate the computation of the to a third method, which will be called by both and methods. It's unfortunate you have to call the same method twice, I don't really see any other options with your current architecture. 

What most likely happens from the (very basic and incomplete) description of your issue is that each frame you detect a collision, you reduce the size of the shape. Thus, frame after frame the shape gets smaller and smaller, so much that it's no longer visible. When you get the collision and you change the size of the shape, you also have to set a flag to tell it to not do it again the following frames. You reset the flag once there is no longer any collision detected. 

This offers the possibility to set the maximum and the minimum, and allows for generating random numbers in between. In addition, you could also devise a 3rd and a 4th formula to replace the use of the value used above: one for the variation of the maximum, and one for the variation of the minimum (you could also use only one for the two purposes, if it suits your needs). This furthers the control you can have on the data produced. (You could also transform this to a "minimal higher value" and a "maximal lower value".) The graph has been made with this tool and this Load & Save string: 

One way to avoid using a load of // statements that always checks the same set of things is to use the state machine design pattern. You start by defining the different states that influence the behaviour, based on the player preferences. Then you extract the behaviour from where it is now, and add it to a method of a class that derives from a base class. Depending on the user's preferences, you instantiate the appropriate derived class, and delegate the function calls to that object. If you have these states: 

Note that another option would be just to remove the 'losing Dude' from the collision detection set. 

Simulating the whole world in real time on a single PC is unlikely to be possible. What you could do, however, is split your world in several chunks (I mean chunks, not shards). You'd have to adapt your world for an agent (AI) to be able to exist in a single chunk at any given time. For instance, you could have one big island per chunk. And then you could have one computer per chunk that manage the simulation. For that much stuff to simulate, I would suggest you use a very low frame rate, i.e. 1-2 Hz. Your game servers would be somehow all connected together, with a master server that stores data. And you'd need a way for your simulated agents to transfer from one chunk to another (like a mega teleporter bridge or something). A thing you could do: if a player is in a chunk, set your simulation speed to a higher frame rate (4 Hz, for instance), while if no one is there reduce it to a lower frame rate (i.e. 0.5 Hz). Of course, you'd have carefully decouple your graphics from your logic, and make it so that your graphics look smooth and not show that the logic is really slow. 

Some implementations of state machines do not know the states they contain. This makes hard for them to know to which state transition. So the 'decision' to change state, and to which state, is made by the state itself. This makes the code more localized: State A only knows about State B and C, while State C only knows about State D. It's easier to look at the code and see right away what's going on from that state. And the "Tteleporter" class should not know about the concept of "state machine". Your play state should know about the Teleporter, and detect a 'collision' between the Teleporter and the Player, and then do what's appropriate.