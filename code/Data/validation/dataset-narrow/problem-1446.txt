You can invent your own algorithm, as simple or fancy as you like. It'll be horribly broken, but it will have to suffice. You're asking for good ways to secure save-state passwords. There are none. At best, you can try to frustrate the player until he gives up. The reason these methods don't work is that they fundamentally try to do something out of their control. Assume I'm a dishonest player. If you tell the game not to do something (e.g. start in a different state) and I say otherwise, I win. My pc does what I tell it to do. To put it a different way, you can't trust the client. Perhaps more importantly, as long as my cheats don't harm the experience for other players, any effort you put into securing your password system goes straight to making the game less enjoyable. After all, if I didn't want to manipulate my saves, I wouldn't do it. In conclusion, unless you have a multiplayer mode to protect, this is a lost battle for a bad cause; I advise you not to fight it. 

Personally, I would prefer to keep variables like 'normal' and 'center' intact for later use, but I hope this example code gets the point across. 

Here, F is the magnitude of the force generated by the thrusters, rx and ry are x- and y-components of the vector from pivot point to thruster. Positive torques tend to rotate the ship counter-clockwise. Using the four formulae above, it is trivial to deduce the sign of the torque each thruster produces. For a modestly accurate representation of physics, you need not only know the sign of the thrust, but also its total magnitude and the rotational inertia. Moreover, you might not simply want to activate all properly aligned thrusters to do a rotation. 

The equation works reasonably well for bullets of different sizes, shapes and masses, but not for different materials. Wood, kevlar and flesh are not fluids and the drag equation does not apply. Newton's approximation of impact depth may be of some use, but its accuracy is limited, especially for materials like kevlar, which are designed to outperform this approximation. 

If you're looking for soft shadows, then you have to go back to the reason why shadows aren't hard in the real world. Soft shadows are a by-product of lights that have a finite area. In order to handle this properly, you have to actually check how much of a light source is visible; it's not just a binary on/off. Your 4x4 kernel is a good approximation for soft shadows, but only for directional lights. Each sample is effectively approximating a light of a particular apparent size. And since directional lights are infinitely far away, all objects will see the same apparent size of the light. So a fixed, 4x4 kernel can approximate soft shadows for a particular area of the light. For a point light, that approximation no longer makes sense. You can't use a fixed kernel to get soft shadows, because the apparent size of the point light changes depending on where you are. For this, you need to compute the apparent area of the light (based on the light's size), then compute a number of directions within this area which you feel is representative of the area. Or just whatever you feel you can get away with without killing your performance. You use these directions as the normals in your shadow tests. Done. Now all of this is an approximation (or really just a hack), because they don't really provide soft shadows at all. The problem with these approximations is that they're basically changing the place in the world that they're looking for shadows from, rather than changing the place on the light where they're looking for shadows from. For a directional light, it's really one and the same, but not so for a point light. To get soft shadowing more accurately for point lights, you would need to render multiple shadow maps from multiple different positions. Or just go with the approximation; it's probably loads cheaper. 

But that would just be drawing a circle. A sphere is not a circle. A sphere is never a circle. Lighting affects how the interior of a sphere is rendered. Even if you're just talking about the 2D silhouette of a sphere, that's not guaranteed to be a circle either, due to perspective projection effects. I think what you're talking about are math-based impostors (as opposed to impostors based on other things, like images in a texture). Impostors are generally a performance optimization. The reason to use a sphere impostor over a sphere mesh is if rendering the sphere mesh will take longer. The same goes for most impostors; they replace more complicated graphical effects. 

Only in exceptional circumstances will players notice or care about the accuracy of your physics simulation. Most games fake calculations like these, which has several advantages; fake calculations are easier to code, computationally less expensive and most importantly, they allow the behaviour of the game to be tweaked in favour of fun rather than realism. If playtesting reveals physically accurate bullet drag is less appealing than some other model, faking it becomes a deliberate design choice. If you still believe realistic drag is an important feature for your game, here's a bit of physics. The drag equation can be solved analytically, though if you should want to involve other forces on the bullet, you require numerical integration. Combining the drag equation with Newton's second law of motion, we get: m v'(t) = -½ v(t)² ρ A Cd, the solution of which is: v(t)=2 m / (ρ A Cd t + 2 m v(0)-1). This gives us the bullet's speed as a function of time, not of distance, but we can integrate v(t) over time to get the distance travelled x(t), then invert that to get the travel time as a function of distance: t(x) = 2 m(eρ A Cd x / (2 m)-1) / ( ρ A Cd v(0) ). The many symbols in this formula obscures its relatively simple exponential nature, which becomes apparent if we simplify v(t(x)), the speed the bullet has when it reaches x: v(x) = v(0) e-(ρ A Cd/ (2 m)) x. The plot below shows the bullet velocity against distance with the parameters you supplied (air density: 1.225 kg/m3; bullet radius: 11.43 mm; initial speed: 251 m/s; drag coefficient: 0.45; mass: 10 g). 

As drawn, full power to thrusters B, D and E will maximize the rotation, but will also accelerate the ship to the right. Shutting down D will prevent this. If instead, accelerating right is intended, but a clockwise rotation is not, the most efficient way to go is enabling both C and F at two thirds of full power along with D. If this isn't beyond the scope of what you're trying to do, you would have to write some sort of solver for the equations of motion, clearly not a simple task. 

Since your render target is exactly 8 times the size of the screen, I'd just use , after setting . Then, just blit or whatever from mipmap level 3, and you're done. But really, you're wasting a lot of performance by not using multisampling+aniso. Supersampling won't give you much that you won't get with multisampling and anisotropic filtering, and your rendering will be that much faster for it. 

Allow me to state this more clearly: The only way to know if your OpenGL implementation supports a particular version is to attempt to create a context with that version and see if you get a valid context as a result. will either return the version you requested (or a backwards-compatible higher version), or it will fail. And failure is the only way to know what is and is not supported. 

Everytime someone uses the word "engine" in relation to a component of a game, the word loses a little meaning. The term was invented in the Doom days; imagine how much meaning it has left. Right. Not much. "Game engine" used to have a well-defined meaning. Nowadays, "engine" is just an overblown synonym for "library" or "module". The "Rendering engine" is nothing more than that part of a codebase which is told where to draw stuff, and that stuff gets drawn there. The "Rendering engine," in a well-architected game (hard to come by, I know) has no knowledge of who tells it what to render or where to render it. All it cares about is doing the rendering. The "Physics engine" is again simply the part of the codebase that decides how things move around and whether they collide. It should not know or care how this information is conveyed to the user. A well-architected physics engine should not have any particular dependencies on the rendering engine, or even know that it's feeding a rendering engine. It just moves stuff around. The "Game engine" is a concept so nebulous as to be non-existent. A "Scripted game" (one of these things is not like the other) is a game that has scripts that control some aspect of it. Which aspects is up to the game developer. Some games expose the renderer directly to the script, thus coding most of the game in the script. Others only expose basic things like the ability to spawn entities at fixed, predefined locations to scripts. Most are inbetween. Obviously, some don't even have scripting to begin with. Ultimately, none of these modules needs to have any relationship to one another. They can be said to be hierarchically composited, but none of them needs to know that the other exists in order to do their jobs. 

As far as legal issues go, the usual remarks apply. Laws are not universal, your mileage may vary etcetera, etcetera. If you are required to obtain the user's permission to publish his score, it doesn't follow you need to ask. Permission can be implied by simply playing the game, as long as the player is informed of this, for instance through your terms of service. Once again, one paragraph of legal advice is bound to cut corners all over the place. Most answers so far have been focussing on these legal issues, but from a gaming perspective, there are very few reasons to pose the question whether scores should be submitted. Obviously, the less you bug the player, the better. Interrupting gameplay to register the user's preference adds no enjoyment to your game, regardless of which option the player would click. Assuming the score should or should not be submitted is intrinsicly better than prompting, but you risk getting it wrong. By automatically submitting the high score, getting it wrong is not such a bad thing though. Players simply uninterested in competing on the leaderboard, will not be harmed by their own achievement being on there. After all, it might just as well have been someone elses. Other players may however still benefit from the score being on there, as it allows them to compete with it. The leaderboard will be more competitive and fairer; it is not limited to a non-representative selection. Moreover, showing the leaderboard with the player's name on it, might awaken his interest to compete, even if he would not have posted his score, had he been given the option. Perhaps he realises his score was far better than expected, giving a sense of reward, or quite the opposite, letting the player know there is a lot of room for improvement. Perhaps he sees he has beaten a friend, or that he has been beaten by one, inspring him to play again. All experiences he would have otherwise missed out on. Worst case scenario: the player looks at the list and doesn't care at all. A leaderboard can definitely make your game more interesting. If it does, you should probably just go ahead and get the player to participate. If it doesn't, you probably shouldn't even have one. 

This is pretty easy; just the program introspection API to fetch the indices. First, ask how many uniform blocks there are: 

This is an old question, but the current answer doesn't really explain what you would use them for. It's all about saving space. And with vertex attributes, less space can mean higher performance (if you're vertex transfer bound). Colors typically don't need much more than 8-bits per component. Sometimes you need 16-bits, if it's a HDR light value or something. But for surface characteristics (which is what most vertex attributes are), 8 bits is fine. So unsigned normalized bytes are a good vertex format. Texture coordinates do not need 32-bits of floating-point precision. A 16-bit value from [0, 1] is sufficient. So normalized unsigned shorts are a reasonable vertex format. Normals never need 32-bits of precision. They're directions. 8-bit signed normalized bytes tend to be a bit small, but 10-bit normalized values are good enough most of the time. OpenGL (3.3+) even allows you to use 10-bit normals via a 10/10/10/2 bit packed format, stored in a single 32-bit unsigned integer. You can even play games with vertex positions, if you find yourself in grave need of more memory. Without normalization, you would have to waste precious cycles in your shader dividing byte attributes by 255.0. Why do this, when the hardware can do it for free? 

In general, you should not be using glDrawArrays at all. If your model has repeated vertices, you'll get a lot more bang for your buck performance-wise from an index list. There, optimized strips or even triangles will be able to use the pre and post-T&L vertex caches. This means less memory fetching and less vertex shader execution. 

You never need the FORWARD_COMPATIBLE bit set. I know that a lot of code does it, and if I could, I would scour the Internet and blacklist every webpage that says to use this flag. The FORWARD_COMPATIBLE flag should never mean anything to a compatibility context. FOWARD_COMPATIBLE means that features marked deprecated aren't available; nothing is marked deprecated in a compatibility context, so therefore it should have no effect. When used with a core context, it will remove the few features that have been marked deprecated but were never actually removed (wide lines and a couple of other things). But there's no point in doing that; if the ARB were going to remove them, they'd have done so already. Therefore, the flag no longer serves a purpose. It meant something in 3.0, before core contexts. But it means nothing now. In any event, the lack of the VAO is the problem. Once you have a core context (which I think you get by default when asking for a specific version number), you must use a VAO to store your vertex array bindings. 

The yellow line indicates the intended behaviour. You can see the blue line (timesteps of 0.1) starts with the right slope, but isn't updated for a while. It's a little high, but doesn't cause any major issues. The red line has more time in between steps (0.2). By the time the slope is updated, the rotation has overshot its target. There are more elaborate ways of tackling this problem, but you are somewhat handicapped by the fact that the target rotation might be changing too. The simplest way would be to specify a range around the target where the rotation is 'close enough' and should stop moving. How large this range should be depends on your timestep and maximum angular velocity, but I suggest some experimentation. 

There is a similar expression for drag as well, and it is obtained in the same way: by solving the differential equation . It yields . Note that coefficient needs to be a negative number, because drag accelerates against the direction of the velocity. Assuming the coefficient does not change over time, the resulting velocity is independent of the timestep. Though the calculated velocity might be accurate at every step, by numerical integration, the position is not, but since is a known function, we can integrate analytically too: . 

Let's first discuss the dot product. A·B is a measure of A's component in the direction of B or vice versa; of the magnitudes of both vectors as well as their similarity in direction. Vectors pointing in the same direction have a dot product equal to the product of their lengths, perpendicular vectors have a dot product of zero. Turn the vectors even further apart, and the dot product becomes negative. Though normally defined as (x,y)·(u,v) = xu + yv, it has the property: A·B = A B cos θ, where θ is the angle between the two vectors. The sign of this product can be used to determine whether a vector B partly points in the same or opposing direction of a reference vector A, i.e. if A·B is positive, the angle is less than 90° (or greater than -90°). It doesn't tell us if the vector points left or right with respect to the reference. Below is a graphical description. Blue vectors B would yield a positive A·B, red vectors a negative.