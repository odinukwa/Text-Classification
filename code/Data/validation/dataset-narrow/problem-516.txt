The vector lib has forced you into creating a new object for almost every operation. If you were animating 5 balls interacting with 10 lines you would be generating 3000 un referenced vector objects a second. And that is a very modest scene complexity. Simpler line-seg circle intercept test If you get the line as a vector and a vector from the line start to the circle center you can get the closest point on the line as a unit distance along the line by dividing the dot product of (AC dot AB) by ) / (AB dot AB)(the unit being the length of the line). When you have the unit dist you use it to work out what part of the line segment to measure the circle center distance from. if u < 0 then get the length of AC if u > 1 the get length BC else get the distance from (A + AB * u) to C. If the calculated dist is less than the radius the circle is touching. Rewrite Almost zero CG overhead, and much smaller yet does the same thing. 

As a function Always use a function to wrap any code. Code running in global scope is inherently slower due to how JS manages variables. The whole code should look more like 

Mostly just style Why add the variable inside the for loop. It is a constant so put it outside the loop as one. The variable is in function scope. Use rather than . The variable does not change inside the loop so it should be a . The expression to get the random number does not need the (...) as operator precedence ensures that the is applied correctly. Add some spaces between operators for readability. eg is better as One issue The only problem is that you have one to many iterations. The last random value will always be to select from a 1 character string, so it is not needed. You need only iterate the string length minus one. The rewrite How I would rewrite your code. I personally don't like putting the inside the for loop, so I put the declaration in the scope above. This is because for loops can have a lot of noise (clutter) and that reduces it a bit. Also the function is so short and simple variable names can be shortened without problem, I would make just the . 

The variable holds each pixel as a 32bit integer. The channel order is from high byte Alpha to low byte Red. Eg to write a yellow you would assign an array item To write a pixel at a coord x,y 

Use a queue or stack. Place the elements on the queue you want to show and start a timer and keep it running until the queue is empty. 

Avoid placing javascrpt inside the HTML content. It makes it much harder to manage your code. Use an unquie Id to identify elements for direct or queried access from within your javascript. 

You share the page with a variety of 3rd party scripts, adverts and what not. The page is yours alone and no other code, but yours, will ever see that page. 

More points It is nice to have descriptive names, it is not nice when descriptive names get in the way of code readability. It is even worse when names are in conflict. 

As the cards are now encoded in a 6bit int we can use a regExp to evaluate sets of cards by converting an encoded card to a hex value. For example the card Ac (Ace = = 12 of clubs = 3) is encoded as is the hex value King of clubs queen of hearts as . A royal flush would have the hex representation of , , , But if we create two string. One that is the suits and the other the ranks we get . That means a straigh is one of 9 squences and a flush is one of suits . We can create very simple reg expressions to test for a particular type of hand. 

Plus a ? Why add the plus? your code can more easily add the plus in A better A better way to parse a float is because tries to fix values while creating a will not. 

Too many steps Assuming the has been "Parsed" (white spaces removed) It is only when you have two matching characters that you require any additional processing, parsing each char to a number before you know it to be part of a pair is redundant, also parsing both characters when you only need one is also redundant processing. All you need is the reduction. 

The next snippet shows it all put together, copied from your fiddle (a page needing well over 1Mbyte of javascript to run) to a total of less than 1000bytes for all the code, css, and markup 

This controls how fast the numbers will increase per second. The animation will play at the same speed on all devices. 

Should the variable not be And is meaningless out of context. And speaking of context you prefixe some variable names with and others not. 

Object oriented programming Sorry this is not a good review, your code is a classic example of a quote often cited in the argument against OOP. 

This only gained a slight advantage, ahead of 82%. I then looked to see what code gave the best result, it was almost identical???? Code from leetCode best answer in terms of performance. 

I would do it as a singleton, so that the core functionality can be protected and private. All that is exposed is the Interface, ,,,and the semaphore Using prototype is only an advantage if the object that it belongs to is instanced many times. If you only create the object a few times, or once then adding to the prototype is actually more work for the javascript engine. I also added a start method so that the queue could be created and started when needed. Once started you can add to the queue as long as 

Type and vetting There are a few issues with the code, though minor they would make the function more usable. 

Exposed states are bugs. Your code is not at all good. This is an example of a banana in an OOP jungle, gaining none of OOP benefits and amplifying only the bad parts. You have exposed almost all of the object's state which is total against OOP principles. Some notes. 

Rewrite This is how I would write the function. I would never use degrees, that is only ever needed for display only. That makes the function much simplier. 

Personally I would say, forget the DOM and use a canvas, but that will upset the the believers in semantic page design. I all I can say is maybe rather than use relative positioning do all elements via absolute positioning, that way you don't have to fight the pages layout engine. If you have correctly separated rendering from the apps function then you are free to experiment with rendering methods. 

Some functions such as are not worth the extra code. It is simplier to write an expression. If you did something apart from assignment then the function is worth it. But for simple assignment not worth it. 

Design You have created a whole pile of functions, it's a real mess. Put the related functions together inside the main function. Use closure to reduce the number of arguments you are moving about. Don't create variable you use on once in the next line. Deep in the sort you test for empty array, that should be the first test in the radix sort not deep inside. A rewrite This is an example of the same functionality as your code, and by far not the definitive solution. It matches the native sort in speed by eliminating a lot of the overhead you had. It uses 20 bucket so that the positive and negative values don't need to be split 

Some points Event listeners When adding event listeners it is considered bad practice to add them in the page content. You had 

But also do the very same calculation but don't call the function you defined to do it. Good code is compact and non repeating. 

You could not have found a worse way to do this. remember you are writing 1 32Bit pixel, but you create x,y coordinates, then copy x to an object, which you pass to a function in which creates another copy, you return the computed value and store it in yet another copy. Then do it again for y. And once y is done you make yet another copy to be pushed to an array as a reference (even more memory used) (remember that memorize will also be making a copys). X and y should be immediate, on the heap and then forgotten, no variables need be created, no object constructed, no allocation requests made. The performance rewrite. Move one 32Bit word to an array of pixels for each item in . 

but the following is quicker (note it should be defined outside the function but in this case you may only have the function's scope) 

Design The logic is not fully thought out. It is always important to test your code for behaviour that are not expected. I can not tell if you expect to be called again after construction. The fact that it is outside the constructor suggests so. If this is the case, why are you not providing a way to remove listeners. Calling init will just keep adding listeners and because the added listeners are anonymous there is no way to remove them. I do not know how many events you are expecting to intercept or delay, but any more than a few and you would be much better of running a continuous rAF loop and handling all the needed events in that one function. Review by comments. All comments within are added as I went over the code, and other comments are me modifying your code by removal. The comments are generally unrelated suggestion and were created before I wrote the review above. 

Consider the image above, The x axis and y axis are defined as a 2D vector each with an X and y magnitude that usually defines the size of a pixel. The origin defines where in screen space the coordinate 0,0 will appear. You can define the axis as a matrix 

The reason I don't like this syntax is somewhat complicated, but there are performance and memory issues to do with function closure that using introduces. I would recommend that you learn all about closure befor you start using block scope variables within loops. 

You can nest these objects creating additional levels of state security. You can also create several public objects that share a single private state, A rewrite As your code does nothing with its private states there was not much to go by. The Design section above would be more appropriate for what you may be after. The following does the same as your code with considerably less noise. 

I am the wrong reviewer Coders can be grouped into two types, those that will use libraries for anything and everything, giving automatic trust too 3rd party code, and those that see libraries as inherently slow, a potential source of unknown bugs, and will only use a library after thorough evaluation of its source, documentation, performance, and cost (kicking and screaming the whole way, "No No... dont corrupt my perfect precious code... " ;) ). I am of the latter and thus maybe not who you want evaluating your code. However as nobody has yet provided a review I will give mine. Why the most popular libraries are inherently slow. A library is designed to work in unknown environments and be usable by both professional, amateur programmers, and many monkeys. A library can not trust any data or adherence to methodologies. To protect the libraries stability it must vet anything that is exposed to the user (code that uses the library). Library code must constantly be on guard that internal state is not mutated. Your code is lacking some basic protection and there are many ways to have it fail, not because your code logic is bad, but rather that the monkey using your code is feeding it bananas skins rather than the banana. You need to add more vetting of arguments, and properties that come from external (un-trusted) sources. Evaluation. This evaluation is in terms of my expectations of a library, is subjective and is certainly not how everyone would see it. The other camp will say, does it run? Yes, does it like my data? Yes great stuff add it to the pile. Documentation. There is no documentation apart from that in the source. You should have a separate document that contains, at minimum, a Library overview, how too guide, abstraction explanation and complete API reference. You should not have documentation spread randomly in your code. Even if this is just a hobby project at least move the documentation to the top of the source file in one comment. That said the documentation you have given for each function is good, though the top comment, listing API methods, is so sparse it provides little useful information. You are also missing details about errors that can be thrown explicitly by your code or can be expected by the JS context. Performance. Without running the code and based on just viewing the source I would say your code has good performance. You are not using any of the common anti performance patterns. Memory use is also good with not too much wastage and GC overhead. Good is not great, there is thus room for improvement, anyone that has used GA's will know that they can be time costly functions with run times being very long. I don't see any performance oriented patterns like object pools, pre-allocation, object reuse, and in-lining (Yes JS optimizers will inline for you, if anyone knows how to ensure that do tell) Cost This is a hobby project (I assume) and dollars and cents don't come to play, well kind of. Cost is time, does you code save the users time. The time is not just adding the library to the project, it is in learning the API and reliability, you dont want bug hunting to enter the library costing users time. Time savings. I ask, can I write the same (and tailored to my needs) in the same or lower time cost. Based on the fact anyone using the library will already be familiar with GA's, and an effective line count at ~250 you are at the time saving border, experienced codes would see using your lib as a time cost (I can write it in less time than it takes to evaluate it), less experienced coders will see a time saving. As the primary designer you should ask your self, "Can I add more value (time benefit) to the library?" Source code. Sorry to say the source code is of poor quality. The primary reason is that you are using old school JS. The current JS version is ES8, and if it was not for the use of (which you only use in loops) and one function using a default parameter, your code is plain old ES5. You need to move the source up to the current version of ECMAScript if you want people to evaluate it positively. Code style points There would be more but I am limiting this mostly to ES5 style points.