Since you are already willing to, in effect, make a question moot on an exam when there are objections you are partway to a solution. As ctrl-alt-delor notes here you need to assure the validity of the exam itself. It is possible that your interpretation of "subtlety" is actually misleading to students, especially the ones you think are "best" for reasons other than the exam. But a better solution is to run a statistical analysis of the exam itself after the students take it. There are measures of consistency that will tell you whether the individual question marks are consistent with the overall marks. See Reliability measures here for example. However, there is a simpler way that you can proceed, provided that you explain it to the students in advance. There is no absolute law or reason that every question on an exam has to count toward the overall grade. You can have a few ultra subtle questions on an exam that are not intended to "count" but which give you additional information you can use for, say, advising and shepherding. You don't need to tell the students which questions are the non-counters, but should let them know that such questions might occur on any exam. If you don't use multiple choice exams then this is easier than trying to find proper statistical measures. A variation on the above is to have the subtle questions count for less than the "mainline" questions. That way the bulk of the grade is determined by overall understanding and the subtle questions matter only at the margins, which I'd guess is your intent in any case. 

Some conferences actually have "nap time" right after lunch. Let people nap if they like or catch up on outside tasks. Such conferences are usually residential, of course, so a nap is a real option. A lecture immediately after lunch is going to lose a lot of people, as you say. Your teaching should account for human nature of course. But an active learning session - say role playing an algorithm - might work. If you have to hit them hard for the complete two days (no naps, no games), make sure that it isn't all just lecture and powerpoint. They will be too passive and will zone out too often. Break it up: lecture, discussion, exercises, role-play, feedback, pairing, group work. Even a discussion session after lunch would be better than a lecture. You can pose a question to the class about some related topic, preferably one that might generate some differences of view. It could even be somewhat orthogonal to the topic of the course. If the course is about programming, make the question about software process. A simple strategy to start might be to elicit their experiences in development. You don't win, nor do they, if you lecture beyond their point of caring. 

The suggestion is that if the simulation is built with something like Model-View-Controller that the students only modify parts of the model. 

To translate these into code you need some imagined functions for the actual activities (). For some of them it is useful to discuss the empty case: you are already at the ice-cream shop, etc. For others, a discussion of "at least one iteration" might be useful to have. If you want to include in the game: 

You can use face to face contact (office hours) or email, etc., to develop the lecture. You can give the student an outline, or ask for one instead. Lots of variation is possible, but you want some sense that the student is well prepared both technically and personally. 

The focus is on design and on building things, not mathematical puzzles. This needs a graphical system in which to work. Greenfoot is a good UI for this. Also. Classes should be simple and methods (very) short and very simple. At statement number 5 in a method I start to itch. Put the complexity into the interactions between objects, not in the methods of the class. This may be the most transformational message of all, here. Another way to think of it is to capture "state" in the program counter, not in fields and variables - the "state of the computation", not in explicitly "remembered" values. Note that this "mind set" is radically different from that of a C or even (the typical) C++ programmer. It is as radical as the mindset of a functional programmer. 

One lesson that hasn't been mentioned yet is that the basic (manual) algorithms that students use for addition, subtraction, etc. are independent of base. In Octal, you just "carry" when you get to "eight" rather than the "ten" they use with decimal numbers. This is a unifying concept that is useful to know. Not that it is especially relevant, but it is said that if you have horse that can write and ask it to write out "ten" it will write "22". Similarly, if you ask it to stamp its foot 10 times, you hear "stamp, stamp, stamp, stamp". While the above paragraph is intended as a joke, it provides a certain insight into number bases that might actually be helpful to students. I also find it interesting that different European languages have names for the smaller numbers up to some limit, but the limit differs by language. German, like English, has number names for 1 - 12, with 13 being a compound(-ish) name thir-teen (three and ten), or dreizehn. French, on the other hand has names for 1 - 16, with dix-sept (ten and seven) being 17. But the Latin-derived languages (Romance Languages) aren't consistent in this. Italian, for example, only has individual names for 1-10, with eleven being undici (one and ten) and Spanish has names for 1-15 with 16 being dieciséis (ten and six). German uses null for 0, and the Romance languages seem to use some form of zero, perhaps accented, zéro in French. I haven't done a comprehensive search, however. It may be that the names of these numbers derive from commercial considerations, early marketplaces/marketdays, for example, and so depend more on local culture. This is a bit distinct from their use in mathematics, which tends to be more uniform. And note that English is a compound language with both Germanic and French roots and we take 1-12 from German, but 0 from French. 

Now run the simulation with each version of sum and product. Note how with the printing version of sum, the paper goes back to the operator and the main (function/person) doesn't have any value to continue with so it gets stuck. With the return version, the sum goes back to main and so it/he/she can continue. Only one paper is ever handed to the operator and there is no getting stuck. Write out the program fragments on index cards and give them to the players. The "sum" player has only one version of the function in each simulation. The "main" player has the code for main above. 

I suspect that you handle such situations by informally building the parse tree of the expression in your mind. Maybe not all at once, but a bit at a time, perhaps. I'm not a cognition expert, of course, but it might help him if you teach him to do it explicitly on paper. He needs a table of operator precedence, of course and needs to be able to deal with parentheses, but otherwise it is just a mechanical process. Put the lowest precedence operator at the root of a tree and then work on the operands. The interior nodes are operators and the leaves are operands. Can't promise it will work, but it would be my next step. With time, he may learn to rely less on the paper. Or, he might learn how to build a tool to do it automatically. That might be nice to have. 

You need to ask your students to create things and you need to give them individual feedback on how they did. The fraction of students who learn by listening to lecture is actually quite small. Taking notes (by hand) makes them more active, but using the face-to-face time to work with them in artifact creation is much-much better. But students are unlikely to get everything right the first time and each student will need individual direction, whether they are struggling or excelling. Note that teamwork is an attempt to combine these two things. The team creates something and give each other feedback as they go along. My constant mantra while teaching was "It isn't important what I (the teacher) do. It is only important what you (the student) do." Focus on their activities, not yours. Perfect their exercises, not your lectures. 

Remembering that your job is teaching, not grading, yes, you should allow resubmissions - you can even encourage them if you take the right approach. Some of your problems can be easily solved. Assuming your students are submitting electronically, you can (fairly) easily write a script that watches the submission folder for incorrect things. You can have the script respond to the student about the issue so that they can resubmit before the deadline. Another tactic is to have them simultaneously submit a printed version of the project. They are much less likely to submit the wrong thing this way and it gives you a way to guard against some kinds of cheating as well as many kinds of errors. I'm assuming that projects are at most tens of pages, not hundreds, of course. Having a printed copy permits something even more creative. After you have marked and commented on their first submission, you can encourage them to improve it based on your feedback. You have a base line and a base grade. When a resubmission occurs, the student submits the original marked up (paper) version with your comments along with the new work. Any changes in the project can be required to be highlighted with a marker pen so that you can see what is new at a glance. You can give them additional points for the resubmission, though probably not "full marks" based on the second (or later) submission. My standard used to be that you could earn up to 90% of the marks lost for the first submission on rework. With the printed copy, your first two problems go away. You can permit resubmissions of the electronic copies freely if you have the paper to prove the work. It provides an audit trail, even if you prefer to actually look at and/or execute the electronic copy. This recognizes that students don't need to be "perfect" to do well. It encourages them to be reflective about their own work. It avoids endless arguments with some students over why you marked them down the first time, as they can correct with little penalty. For me, it was always win-win to do this. The highlighting of the rework also made it nearly painless for me, though I never tried it with more than about 50 students. Students would turn in their work in a folder that contained both the old and new work with changes marked and old comments included on the originals. 

The first OOP was actually Simula (1967), developed in Scandinavia to do simulation programming. Simula was the main inspiration for C++. The first (and maybe only) pure OOP was/is Smalltalk. It became the inspiration for most other modern OOPs; Apple Object Pascal, Java, Python, .... However, most other OOP languages than Smalltalk compromise in a number of ways. To discuss pure OOP more deeply requires an excursion. There are two ways to think about an object in an OOP; it's creation and its use.