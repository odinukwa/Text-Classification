Generics Java by convention uses a single upper-case letter to indicate the Generic type. In this case, should be ....: 

Then, your code would be simplified logically to something you can stream, even.... ... but, before you get there, have a look at the new Java8 comparator constructors: 

There are two things here. Firstly, in any code that is not directly related to the system itself, is almost always a bug. There should never be a need for this. Let the system look after itself. It really does not need your help. The second item is that it may be taking a long time to load the Images. If you are scrolling to unseen areas of the system then the code may need to be calling the method a lot. You need this method to be fast. Convert the line to be an AsyncTask, and let it populate the imageView in the background. That will make populating the views a lot faster 

I am going to critique your class. Firstly, I think that code should handle the common cases really well, and, hopefully, success happens often. I would create a constant instance to indicate the success, and all other instances are fails. As a consequence, I would not have the method. How about: 

Return statement in the finally block is almost always a very bad idea..... The sematics of the finally block are complicated, but, if there is a return statement the block, or in a block, then those will be called, and then the finally block will run, and it will change the return value. IDE's, and the compiler, will complain about this: 

Create a filter type, which is a function that takes a string slice input, and returns a bool. "Do we filter this string-slice?" Let's take our arguments, and create a system that returns a Filter for each type of supplied argument... 

As you can see, I have marked 3 squares - red, blue, and purple. Each of them is 2x2. The position at the bottom right, is the end of the 3x3 square. it is 1 + the minimum size of the blue, red, and purple squares. 

Without knowing more about the code and it's context, I can think of only one thing that may help, and this is an extension of Simon's answer: 

Your code is interesting, in the sense that it appears to have been pulled from about 4 different text books all related to Java about 4 versions ago.... actually, make it Java 1.3. It is consistent code, but everything is just.... old. In some sense of order, the following strike me most: 

The above code will be far more efficient than the substring option as well. It is also 'fail-fast', and exits on the first non-palindrome characters. 

non-optimized code is going to be slower.... you pay money for the compiler for a reason, lots of smart people make it 'go fast'. you need to inspect the instruction-level code (asm) generated by the compiler in order to understand the main differences between the two versions ... anything else is just educated guessing. 

Your problem is not really a fizz-buzz problem at all, it is a sum-of-sequence problems, and is commonly based/equivalent to the first "Project Euler" challenge Note: your code has a bug, you are supposed to sum values that are a multiple of either 3, or 5, but you are summing only the multiples of both 3 and 5 (i.e. 15) that are less than the number... There is an algorithmic/mathematical solution to this which completely removes the need for the iteration at all. Consider the sum of all the multiples of 3 less than ....: 

Loop 1 is at index 0. When we apply as the source index to our relocation function, the result is the value 0. It is a single-item loop. Loop 2 is at index 1. Look at the index 1 sequence: 

Note that there's no longer any magic numbers. You get the number of quotes from the actual number of quotes, not from a hard-coded value. if you have 10 quotes it will work fine, if you have 1000 it will work equally well... Now, if you take in to consideration the comments from @tim, you will also be able to extend the actual String quotes in to Quote and Attribution Objects, and make the program more object-oriented. 

When you have named return values in Go you should have a value-less return statement. Your and methods declare output parameters of and .... but you return specific values and . You should instead have code like: 

Go does have a strong opinion on the use of mutexes vs. channels. In fact, the package states: "Other than the Once and WaitGroup types, most are intended for use by low-level library routines. Higher-level synchronization is better done via channels and communication." (See $URL$ ) This opinion clearly implies your first implementation is suboptimal. I agree, so I'm not going to even review that implementation. The second implementation is more intriguing, it uses channels, but it's got issues.... and it's not a "canonical" example of what I would expect with a "communication" implementation for concurrency in Go. The "Stateful" go-routine is one which only that single go-routine accesses, or modifies the state. All interaction with the state is done by communicating with that routine, and communication happens through channels. You have one channel to communicate the request for accessing the state, and another for returning the response. This is a problem... The request channel is OK, but the channel is broken. If you have multiple concurrent commands issued, you won't be able to send the right response to the right command, and things will get mixed up. The solution to this is to dedicate a channel for each command to get the responses on. Add the channel to the struct, so that your code looks something like: 

Note that the 6-char password generated 2GB of data in 10 seconds, or 200MB/second. You will be limited by your storage system probably, not the CPU. 

The above code ends up with a simpler data set to navigate. Unfortunatley, it makes the case where diff==0 a little more complicated... you need to use factorials for that, and not simple products. (Edit, I extracted that logic completely).... Still, I put the whole method together as: 

That neatens up your code, and does what is called "Functional Extraction". Additionally, if you look at that function it does a lot of work... it does 2 string concatenations, creating three Strings, a StringBuilder, and a bunch more. It would be more efficient to keep everything as numbers, and have a function like: 

From this you can get the idea of what you should do.... I realize I kept the as an array, and you have it as a List. I kept it as an array because it is the input mechanism for the bulk methods of the API... but, in fairness, I think you should keep using the List format (the is useful). Then, convert the List to an array when you need it. Also, look in to the FetchProfile object/method, you can add any header fields you want to it... Also, you can filter out messages that do not meet certain criteria, and then fetch additional data for the next set of tests, and do it that way. Bottom line is that you want to access the server as few times as possible, and when you access it, you should get as little data as you need, but, group all similar requests in to a sigle operation..... 

Looking in general, the code looks nice enough. I realize that you are using as values because that's convenient, but I would prefer that you used generics, and a Comparator instance to work with, rather than relying on the autoboxing of Integer to int values. So, taking your core method: 

The answer is: yes, it is large, and the code is ugly.... and he's right. But, not everything can be small, and pretty. This is the lesser of the evils. I would not change it. Your class has a lot of related data, it has to get in there somehow. Other Issues Your constructor has the input but does not store that as a property. You should consider using a generator in your : you should each File, instead of returning the completed list. 

Java is a just-in-time compiled language. As a side-effect of this, it is common for performance problems to happen when you have all the code in the main method. The reason is that Java often only compiles methods that are called very often, but the main method is only called once, so it is not compiled optimally. This is one reason why 'function extraction' is often suggested (as well as the other benefits like readability). So, consider a method that's called 'countDivisors': 

I am aware that heuristic approaches to the N-Queen problem are faster, but answers that rely on heuristics to solve it are not as interesting to me as solutions which improve the brute-force approach. 

As for negative difference input values, I would just handle that as an up-front special condition. The count of pairs with a negative difference will be the same as the count with a positive difference and the same magnitude. Just convert negative difference to positive, and handle the Long.MIN_VALUE special case. Algorithm I would alter the algorithm a little. I would have a simple scan of the data to count value duplicates, and store that count in a separate array. With that data structure, the search for duplicates later is much easier. Consider this: 

I have taken this problem on as a little study in to lock efficiency, performance, and contention. As a result, I am posting a second answer with some additional information, and a different sort of review. Note: The full console output from my harness is here in pastebin.com First, my conclusion is that lock-free fib generator is a mistake. Reentrant locks are also a problem, and that the best performance comes from plain old synchronization. So, to test this all, I created a basic interface: 

Now, I am not suggesting this is easy, but, it works, and it will work fast. When splitting the original sentence, it is possible for there to be some leading space, punctuation, or other junk. This may lead to having an initial empty string in the word-split, so we need to ignore empty words. Putting this together, you get: 

No-return value problems This code has a redundant if-condition in the last check, and in has a 'logic path' which does not have a return statement: 

While your code is neat, and organized, the issue is with your algorithm. The simple fact is that you only need to loop through the array once, when you create the instance. The trick is to "memoize" the sum of all members to one side of the array, and then compute the difference when looking for the sum later. Consider the code: 

I think what you're missing here is an algorithmic change to improve the way you load data, ranter than the way you compute the results. One way to do this would be to build a tree to store your Records. A tree is really not that complicated to do, but, there's an in-between thing you can do which will really help. Create a as part of the constructor of your class. Call it for want of a better name. Then, each time you add a record, ensure that the tree is modified as well. Here's your current method: 

'Finally', the and parameters to your method are constants, and are not changed. You should show this by adding 'final' to the declaration: 

This code loops all the way around the loop, and it returns the distance between the nodes, where 'between' is defined as 'how many times do you have to move to get from the first to the second. It returns a negative number if the shortest distance is to go backward through the loop... or, put another way, the number of steps forward from the second node to the first. If that information is not relevant to you, you can stick with the simpler: 

In other words, you will have int values filled with either 0's or 1's... and no variations. Also, if the "step" for the nano-second clock happens to be an even number, it is possible that the low-order bit for your computer will always be the same value.... and all your seeds will be identical. While the class in Java may be slower than you want, you can at least use it to seed the faster ISAAC algorithm. I would simply use the following to seed your class: