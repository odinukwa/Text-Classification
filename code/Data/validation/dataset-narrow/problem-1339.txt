There are numerous ways of smoothening a rotation. If there is any physical meaning to it, we'll need to know what that is, but if you are merely doing it to make it appear less jerky, it is pretty arbitrary. Note that unless you know what the velocity is going to do in advance, any attempt to smoothen the corresponding rotation will cause it to lag behind to some degree, which may lead to weird oscillatory behaviour. It also prevents you from smoothly setting the rotation to zero simultaneously with the velocity hitting zero. A simple way would be to make the rotation respond exponentially, i.e. use an angular velocity proportional to the difference between the sprite's current and target rotation. 

In addition to the practical advice offered by MickLH on how to do the conversion, I would like to explain the trigonometry and address some of the misunderstandings apparent in your question, so that you can decide whether converting to 'normal degrees' is actually preferable. It probably isn't; both [-π,π] and [0,2π] describe 'an actual circle'. There are many ways to describe a point on the unit circle with an angle. Since a circle is obviously symmetric, you have to arbitrarily define a reference point as zero radians. To differentiate between angles clockwise and counter-clockwise from your reference point, you have to define one of them as positive, the other as negative. Finally, since 1π and 3π describe the same point, you may want to select a point where the angle wraps around, which also determines the range of possible values for the angle. In your example, the zero point is on the right, the positive direction is counter-clockwise, and the angle wraps around at &pm;1π. These decisions are not unique to 'analog stick radians', they are by far the most common convention, similar (and related, see image below) to how we usually draw two-dimensional plots with the x-axis to the right and the y-axis upwards. 

Before diving into formulae, if you want to create a ranking system, you'll have to come up with a list of specifications and requirements. Decide what the ranking system should accomplish and work from there. Be specific. Requirements that are rock solid can be a great guide, where general guidelines, such as the ones you drew up, may lead to confusion instead. An example. Alice and Bob both have a few good virtual players, but Alice's are slightly better. Alice then continues to add mediocre players to her set. Eventually, she'll have quite a lot of them. According to rule #1, Alice's score may no longer be higher than Bob's and therefore must go down. Rule #2 forbids this. Carol joins the party. She has one virtual player and it's terrible, no match for anyone of Bob's players. However, on account of her enthousiastic daily participation and rule #3, she still scores higher than Bob, who only plays once a week. If you stick to basic limitations instead, even seemingly trivial ones like 'winning increases your score', 'playing often adds to your score'... as long as the set is consistent, it will make the mathematics a lot easier. 

'Speed dependent arc' is not a common term and has no specific meaning in game design. The textbook refers to cases where the character is already moving, but not necessarily directly towards the target. If the target is behind you, you would stop, turn around, and start moving again, but if you were moving in roughly the right direction before, you would not stop to do a small rotation. You would instead make the turn on the move. To decide whether to go for option B1 or B2, you need to define the region in which the target is allowed to be for your current movement direction to be considered 'good enough'. The size and shape of this region (or 'arc', as the textbook incorrectly calls this) may or may not vary with your speed, hence 'speed dependent arc'. 

Note that in a coordinate system with the x-axis pointing right and the y-axis pointing down, we can rotate a vector 90° clockwise as (x,y)' = (-y,x), ergo: A'·B = (x,y)'·(u,v) = (-y,x)·(u,v) = -yu + xv. This number is positive (B is clockwise of A) if x v > y u. Those are exactly the two values your code is comparing. 

Where (x(t), y(t)) is the object's position as a function of time, b is the angular acceleration, v is the velocity (in x- and y-components), a is the acceleration, also in components, ω is the angular velocity, φ is the angle of rotation and C(x) and S(x) are the Fresnel integrals. As the result is probably equally disturbing as unhelpful all by itself, I have omitted calculations that lead to it. Unfortunately, no simple approximations are available either. I fear discrete simulation is the only reasonable way of tackling this problem. 

With a few tweaks, assumptions and some rewriting here and there, the result still looks dreadful, but is computationally not all that expensive. 

Balls are actually rather simple objects for collision detection. They collide with terrain when the distance between the ball's center and the edge of the terrain becomes less than the ball's radius. The position of the center of the ball should be trivial to obtain. Finding the nearest point of terrain is generally more complicated and the best way to do it depends on how the terrain is represented. Your algorithm to calculate the new velocity after bouncing off a diagonal slope is incorrect. Inverting both the x- and y-coordinates will make the ball go back in the same direction it approached the slope from. This is fine if the ball comes at the terrain from a right angle, but fails for other angles. You'll want to negate only the component normal to the surface, e.g. when bouncing off the ceiling, you negate y, not x. 

If I understood your question correctly, you're trying to see whether two known angles match within a tolerance 'range', but subtracting them gives unwanted results when the 360° branch cut is traversed, e.g. the difference between 350° and 10° should show up as 20° instead of 340°. One possible solution is to replace the abs-function with a function that adds 360° when the angle is below -180° and subtracts 360° when the angle is over 180°. The result is always in the range of -180° to 180°, the sign indicating left and right. Pseudocode 

You seem to have paraphrased the formula incorrectly. In vector algebra, there are several types of multiplication and they use different symbols. The original article uses the dot product (·) which is not equivalent to the generic multiplication symbol *. It also uses bold face to signify vectors as opposed to scalar quantities, i.e. r² is not the same as r². In fact, as you rightfully noted, you cannot really 'square' a vector. The formula as it was originally written is: p · p = r² If two vectors point in the same direction, as p and p obviously do, their dot product equals the square of their absolute values or 'lengths'. By definition, any point at a distance r from the origin lies on the sphere with radius r centered at the origin. Ergo, if the square of a vector's length equals the square of this sphere's radius (p · p = r²), then the point lies on a sphere with radius r. The article mentions the sphere's radius is r²; this is incorrect. 

There is such an equation, but it's not easy to obtain. Because the magnus effect depends on the ball's current velocity, it changes when external forces are applied. You cannot calculate the position of the ball by linearly summing the contributions of different forces. If you were hoping you could simply add a few terms to x(t) = ½ a t² + v t, you're out of luck. Numerical integration is a valid way of predicting the balls trajectory and doesn't require you to actually move the ball if you use a different set of variables. If you want to use a direct approach, you might want to use a tool that can solve a system of differential equations. I used Mathematica to obtain the following equations for a ball starting off with a set velocity and being subject to a gravitational acceleration -g in the z-direction and a magnus force Fmag = c ω × v, for brevity condensed into: amag = r × v. 

There is no 'flip' here; both coordinate systems are exactly the same. Instead, the two images have been created using two differently oriented cameras. Which direction is 'up' is not defined by the coordinate system, but by an arbitrary mental note you make. 

The multiplicative nature of these stats are not the cause the imbalance you refer to. In fact, they tend to prevent one single stat from being dominant. For example, higher attack speeds increase the usefulness of boosting attack damage. Doubling either value will have the same effect on the DPS, but most systems automatically enforce doubling numbers that are already high is quite difficult. As the player progresses, their increase in attack damage is often opposed by an increase in the enemy's defensive capabilities, which can scale almost indefinitely, unlike attack speed, which has a narrow 'logical' range. I suspect this is the main reason developers turn to caps or diminishing returns. There are other options, however. By defining the on-hit critical strike chance as the ratio of crit statistic and attack speed, you effectively end up with a fixed estimate for the number of critical hits per unit time, removing a multiplicative relation from attack speed. A very common alternative is to use a stamina pool that haste quickly depletes. In other games, attack speed may have limited merit due to it being uncommon for an enemy to stay in attack range long enough for you to land more than one hit anyway. As for critical strikes, a lot of games don't bother with probabilities, but use different criteria, such as attacking from behind. Most importantly, if you can't find a way to make it fun, eliminate the system altogether. Numerous RPGs don't even have variable attack speeds or critical strikes. Arbitrarily making equations more complicated doesn't add any interesting depth. 

The equations you've quoted are translations. A single to move the entire viewport is may appear as a more efficient one-step solution, but it performs the same calculations for every object to be drawn. The algorithm required for moving a 2D camera is so straightforward, there are no real shortcuts or detours at play. Every sensible method will function and perform similarly. 

Your suggested encryption scheme does not change the premise that games generally run client-side and for a good reason, yet anything client-side is 'in the hands of the enemy'. If the game client needs to know where opponents are, even if they are obscured to the player, then a wallhacker will also have access to this information, as from a technical point of view, both are the same recipient, namely 'the client'. A game developer cannot guarantee to keep this distinction between legitimate software and hacking tools intact and safely communicate with the game client, but not the attacker, because this distinction does not yet exist before the data passes the trust boundary between server and the player's machine and the bad guy gets in control. If this distinction cannot be relied upon, we must assume the game client and the hacker are the same party. Encryption can be used to communicate safely over an untrusted channel. Superficially, it seems to do exactly what is required here, getting a message from A to B without an attacker being able to read or alter its contents. But there's a catch. The system is useless if the attacker can decrypt the message. The system is equally useless if the intended recipient cannot. In this scenario, the attacker and the recipient are the same person. Your question concludes in saying: "if games are apparently so easy to hack, shouldn't most apps be hacked as well (e.g. Skype, all DRM running on Windows etc.)?". They should indeed and in fact they are. 

Publication of copyrighted works of art requires the author's consent with due exceptions and limitations that normally apply. Whether the game the art is used in is open-source, is irrelevant. However, in the spirit of this openness, it is not uncommon (but also not necessary) for the author of the game to automatically grant a liberal license to his work. The author's permission is still required, but implied, often conditionally. If such a license is not provided or you do not wish to adhere to its conditions, and the art you wish to copy is protected by copyright, legally, you can either: 

With the engines' propulsion as the only force acting on the spaceship, physics are hardly at play here. Your currently planned implementation are in accordance with 'realistic physics'. You could definitely design a spaceship that flies that way. To answer your second question, that too would be realistic. You could definitely design a spaceship that uses a non-constant force to reach its target velocity. If you spaceship design is very specific, i.e. you know its mass, where the engines are, how much thrust they can produce and how much fuel they burn, how the controls work..., then you can run a physics simulation to determine exactly how that design is supposed to behave. Without these specifications, who is to say your ship handles incorrectly? Your constant force-approach is simple to implement. Build it and play the game to see whether it needs tweaking. 

There are other intellectual property rights that may protect parts of such a game. Patents and trademark, for example. Concepts or mechanics are not subject to copyright in any jurisdiction I am familiar with and no international treaties governing copyright extend the protection to game mechanics. As far as copyright is concerned, you can mimic those freely and it's done en masse. Make sure the game is not patented and stay clear of its name and art. This will leave the creators of the original board game with very little ammunition. Of course, the usual side note applies; you don't have to do something wrong or illegal to get into legal trouble. That aside, the answer is no. You're not infringing copyrights by publishing such a game and you are as safe as you can reasonably expect to be. 

The general 3D expression for torque is the cross product of displacement and force: T = r ⨯ F. In two dimensions, a scalar value for the torque will suffice, and given only four orthogonal orientations for the thrusters, we can write in piecewise form: 

The plots below indicate an example rotation against time using various values for using this exponential smoothening method. 

If the acceleration is constant, e.g. the only force acting on the body is gravitational, we can use a trivial expression for the displacement at any time. It is a integrated twice with respect to t. In vector form: x(t) = x(0) + v(0) t + ½ a t². The starting velocity can be derived from θ using: v = v (cos θ, sin θ) or a variant, depending on how the angle is defined. With the example values of: 

We do have this information we want if we carry out the dot product of B and a different reference vector: A rotated ninety degrees clockwise (we'll call it A'). Once again, in blue vectors B that would yield a positive A'·B, negative values in red. 

The function returns a scalar, but the variable w is indeed a vector. More traditionally, the one-dimensional wave function is written as: Ψ(x,t) = A cos( k x - ω t ) In more than one dimension, for example waves in water instead of on a rope, the spatial part is written as the dot product of two vectors: Ψ(x,t) = A cos( k&centerdot;x - ω t ) In the formula you referred to, x is written in full as the two-dimensional vector (x,y), the vector k is called w and the symbol * is used to denote a dot product. The wavenumber (or angular spatial frequency) k indicates the direction in which the wave propagates and its magnitude is inversely proportional to the wavelength. The effect of different wavenumbers on the propagation of the wave is illustrated below. 

The movement vector will now point along the surface, but leaves the x- and z-components alone. You may want to resize the vector to maintain absolute speed or compensate for gravity etc. This method is anisotropic. It uses some shortcuts based on what is horizontal and what is vertical. As a result, it requires your terrain does not have vertical or overhanging surfaces and is quite limited in true 3D situations, such as bouncing from or rolling off surfaces.