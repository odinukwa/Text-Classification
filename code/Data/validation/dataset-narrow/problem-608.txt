The big idea The idea behind these patterns and similarity measures is that given historical data we compute a pattern and a future price change with the idea that the pattern implies the future price change. Then given current data we compute the current pattern and search for a similar pattern in our database from which we can deduce the corresponding price change. The main problem is that the function is not symmetrical in its arguments, i.e. and may have wildly different values. Consider these examples: 

Note how the while loop avoids the duplication of code that you have in your program. Here is another idea for a subroutine - one that updates a player's score and returns how to report it. Either the computer's or player's score can be updated with this: 

array reshaping array row, column and diagonal slices to compute the product of all elements in an array flipping the array to get anti-diagonals 

Note that row and column indices start from 0. In the case of diagonals, 0 is the main diagonal, with positive diagonals to the right and negative diagonals to the left of the main. Products And here is how to use : 

Note since we are multiplying everything by 100 that the value in is just the value 1, not the conventional 0.01. Given two patterns, and , we say they are close if 

Nothing really wrong here, but I have a suggestion... it is customary to repeat the key if it isn't long enough for the entire message. I.e., if the key was and the message was , you would repeat the key as many times as was needed to cover every letter of the message. The key used to encode the message in this case would be . You can use the function to repeat a list forever: 

Note - my JS is a little rusty, but this should illustrate the idea. Update: Per our discussion in the notes, I am suggesting changing this code: 

The Performance Tips section at python.org has comments about doing repeated string concatenation which you may find here: $URL$ Specifically, it suggests using instead of repeatedly appending to an accumulator with . So I would try something like this, using to find all of the comments, and place the non-comment parts into a list: 

Then you have a list of primes and their exponents: (p1, e1), (p2, e2), etc. and the number of divisors is: 

Due to laziness it may not make any difference. This is something that perhaps should be benchmarked. To form the groups the first way use the function from like this: 

Note that the list concatenation is O(n) where n is the size of . That is, basically gets copied, so this method of rotating a list is not efficient. In practice this probably won't matter since the list will be small, but it is something to keep in mind. A data structure which amortizes the copying might work better in this case is a difference list such as is implemented by the dlist package. Alternatively just use a where the key is a player number, and keep track of whose turn it is with an Int modulo the number of players - much like you would do in a conventional language. --- playerIsInValidState You should have a bounds check here. If (x,y) is out of bounds then will throw an exception. --- general organization Games typically have the following types and organization: 

Again, note how is defined as the memoized version of and calls for recursive cases. Using Array memoization Faster results can be obtained by using arrays to memoize the functions , and : 

This means that your code doesn't cover all of the possible cases. Append to your question an updated version of which doesn't produce any warnings, and then I might have some further comments about it. (Please append to your question instead of modifying it so it doesn't invalidate any existing comments.) Let me know if you are not seeing this warning from ghc / ghci so we can figure out what's going on with your environment. filterEmpty I don't think the logic is right here. What if you have this message: 

naked calls Note that simply allocates memory - you have no guarantees about what the newly allocated memory contains. For that reason it is better to write a function which both allocates and initializes an new object, i.e.: 

is a standard way to copy blocks of memory, and most C libraries implement it with special processor instructions to speed it up. Another coding style issue... instead of: 

The other thing which will help is to keep in mind that the type represents a a combinator which is able to memoize a function whose argument type is . So: 

Note here is represents the upper left corner of either the row, column or diagonal we are taking the product of. That's why both range from 0 to 16 We just run both and from 0 through 19. We examine a few extra products (some with less than 4 terms), but since we are looking for the maximum it doesn't matter. 

An advantage of this approach over splitting each line is that if there are large chunks of your program which do not have any comments they will transferred to the list in one piece instead of as separate lines. Update I would also try using a regexp replace approach - it could be even faster: 

The main difference is that and now take an argument instead of referencing global variables. Also, do the same with ... 

which helps to describe better what it is doing. Anywhere you can use the alias instead of will help the reader. In fact, I would even write the signature this way: 

So, two characters are in the same group if they are equal or if they are not both the character to be squished. Of course, if you do this you'll have to switch the groups back together differently with something like: 

I think you really should look at this guy's solution which employs numpy: $URL$ The advantages are: 

Even though they are not needed, they aid in reading the code. Also, aligning the in the case patterns helps with readability. The type signatures on your calls are not needed due to Haskell's type inference. insert You should be getting this warning from ghc and ghci: 

If is zero for some , then is it possible that will be 0? If so, the result of the division will be a NaN. However, as I mentioned above, this code is unnecessary, so you can just remove it. 

has the same shape as and the diagonals of are the anti-diagonals of . Solution Putting it all together: 

First of all, there are so many pitfalls associated with programming that I prefer to write all except the most trivial scripts in a language like perl, python or even awk. I realize that availability is a concern, but all of those languages are pretty standard now. If you write the script in a better scripting language you can get rid of the duplicate call to which is one thing that I presume bothers you about the code. If you must write in /bin/sh, then run your code through one of the following static analyzers to help you find potential coding problems: 

Overall: aside from the "first item in array is 0" which is either a mistake or a misunderstanding on my part, your code is clean and well-organized. I urge you to 1.) try to use less often, and rely instead on iterator-based loops and -based loops as much as possible, and 2.) read up on ArrayList - it's a very common and useful data structure, and I think it's what you're going for by trying to implement a self-adjusting array. 

See the above note - we probably don't want to force the user to deposit money before every withdrawal. 

I'm sorry to hear you got rejected - that's never any fun. I'll go through line by line, with some general comments at the end. Some of my notes are labeled as style suggestions; these usually mean generally accepted Java principles (naming conventions, etc.), so I'll try to point out where I'm trying to argue for a given style I personally recommend instead of giving a general rule. 

I don't understand this comment - is it justification for calling ? If so, it's not quite right. You could add a counter variable that gets incremented in your clause above. That doesn't mean that you necessarily should, though - see below 

The code looks a little rushed. Just like in a face-to-face interview, appearances matter for code that will be read and reviewed. Big chunks of commented code with no explanation, as well as misspelling / inconsistent naming schemes, won't make a good impression. It seems like you're a little unsure of the problem specification. It can help a lot to think carefully about the input / output to each function, and what data will need to be stored in object variables, as you're writing your code - these things can change as you go along and understand the problem more. It's very helpful to document (write in comments!) the assumptions you're making about how the program should run. There are some spots where you deviate a lot from established Java rules. No company has the exact same code style (here are Google's for Java), but there are some things (camel case, for example) that are very central to a given language. Not using camel case correctly when writing Java is a signal that you don't know Java very well - depending on the position you're applying for, this may or may not be a problem. 

Style: classes should usually be nouns - e.g. Account or maybe AccountCreator, because you use them as Objects - so it makes more sense to have "an Account" than "a CreateAccount" 

This is a configuration constant - it should go at the top of the class, before methods. If all users should have the same withdrawal limit, it should be declared , too. 

What is this comment supposed to tell me? The function is called , so I expect that it will deposit money - you don't need to tell me that. Instead, it might be helpful to explain that the deposit amount comes from the user's input, or what the return value means 

You definitely don't want to loop from 0 to , when is changing. This loop doesn't really capture your stopping condition, which is . How about: and in the loop you add the number to your Array(List), without needing to use the break condition. 

BUT, I think what they meant is, no data persistence is necessary between program executions (you don't need to save account data to a file when the program shuts off, and read it back in when it starts up again). It would make a lot more sense to keep track of a user's balance while the program is running, and check, for example, that the user doesn't withdraw more money than they have in their account. 

Rather than this, consider - it'll save you the indexing. Check out this question: Converting 'ArrayList to 'String[]' in Java 

Consider having an explicit case, and making your case throw an error. It's a simple way to make sure your input is only ever A, B, or C. Unless we want to assume that anything not given a letter grade (e.g. something never assigned a grade) defaults to a 2. 

I encourage you to consider writing unit tests (I recommend ). It'll make your tests easier to write and read. The above tests are ok, but I would definitely add tests to check that you get when you expect to. Overall: Your code is overall quite clean and easy to follow. It's not quite production-level, but it is good for a Java course. Nice job! Regarding returning : There is a large discussion around this issue. I think most people believe something along these lines: 1.) should not be used in place of an error. This is because in general, methods should enforce their contracts loudly, i.e. if a method's job is to take a number greater than zero and return it times two, and it gets a number less than zero, it should complain. By returning , you force programmers who use your code (if they're responsible) to write in code to handle the possible null case, because otherwise there's no guarantee that they will be aware of the error that made your method return . And 2.) can be used as "no results", but it might be better to return an or an empty data structure instead. For more, check out this question Is it better to return NULL or empty values from functions/methods where the return value is not present? For a class assignment, though, it may well be the case that using is "ok" because its fast - and it doesn't require you to shift focus from whatever the point of this assignment is to spend time writing exception throwing code. Avoiding using as an error, and instead throwing an exception, is a best practice, though, and as you grow as a programmer you may want to do so even if it's not required. Be careful though - if your code is auto-graded and it is expected that it will return for a given input, an exception will probably cause it to be marked wrong. In this case I suggest writing code to your assignment's specification, and being content with knowing that were you writing code in the "real world", you'd do it differently 

Double loop, great, and without incrementing variables, even better. The names "grade" and "studentGrade" leave me a bit confused though. "studentGrade" contains more than one grade? I would replace "studentGrade" with something like "singleStudentGrades". 

Style: method names should start with a lower case letter EDIT: this is a constructor (my bad) and is therefore correctly named. Non-constructor methods should start with a lowercase letter. 

Try to avoid naming things as misspelled words. "Module" would probably not be a good choice for a package name because "Module" has a meaning in programming in general, and since version 1.9 it even has a specific meaning in Java. This doesn't mean, however, that "Modul" is better. 

I can't see why this is so, since you don't add 0 to the array, and the user can't input it. Did you test this code? It seems like there is a bug here.