Purely personal but I'd rather avoid whenever it can be easily avoided. If your case, it's quite easy to put the whole block behind a (or even better : ). However, things could be even more straightforward : and could start at because first iteration won't do anything anyway because condition will be true. Then, as far as I can tell, the guard is not needed anymore. 

Do things less often (again) I missed it in the first place but you could do the join-and-strip part out of the loop: 

Correct data type Instead of using literal strings and , we could use a more relevant data type like booleans. Separation of concern/optimisation In the same function, you compute things, you move the cursor and you draw dots. This seems like a lot for a single function. Also, you end up spending a lot of time performing the same computation. What you could do is define a function to compute coordinates, then call it for all vertices and use the results to draw dots first and draw edges later on. 

If we want to play it cool, we can use the fact that in a boolean context, an empty list is considered while a non-empty list is considered . Also, we can use the ternary operator. Finally, because I am now using the string and not the integer, we don't need the conversion to string at the end. We get : 

Not a Queue! First and foremost, your isn't a queue. You can only store one element in it at a time. That doesn't make it super useful - what if the producer wants to write two images? 

Once you reorient looping over additive indices to looping over actual indices, the inner body becomes more straightforward too: 

Once we have those simple building blocks, putting them together to write breadth-first search is downright pleasant: 

Variable Names You use , , , , , , and to refer to important things. I started trying to keep track of what each one meant and then gave up. I have no idea. Give things meaningful names. Apparently is the number with the longest sequence, whose length is - which is certainly not obvious from the names! Chaining To find the length of the collatz chain for some number, , involves also finding the length of the collatz chain for every other number in that chain. However, you don't store that information anywhere, so it's lost. Furthermore, you calculate it TWICE: 

That will automatically handle file closing correctly in case of exceptions and the like. I also find it clearer. Also, why ? Prefer Generators reads the entire file into memory. Prefer to just go a line at a time by iterating through it. gives you a full list of all the items. But you don't need them all at once, you just need to iterate through them. For that there's . Use the tools at your disposal You have: 

The dictionnary could be moved out of the function (and given a better name but I'll leave this for you). A probably better way to write this I think the best way to convert binary to hexa and hexa to binary is to write a more generic function converting binary/hexa/decimal representations to the actual number and actual number to their binary/hexa/decimal representations. The signatures would be something like : 

Also, your dict initialisation could be done with a dictionnary comprehension. Then, your whole function would become: 

Replacing / Conversions between and happen everywhere in multiple directions. You could get rid of one by using the name with in keys: 

Counter is even better than you thought is a pretty cool tool, it even has a method doing exactly what you want. Your code becomes : 

Simple mistake The function takes a filename as an argument but doesn't use it. Instead, it retrieves it from . Also, would be a better name for a filename than . 

Parameters It could make sense for not to be responsible for chosing the file path. This could be provided as a parameter. Disclaimer: I have run (pun intended) none of the code above. 

Str You probably should add a get_description method on players to handle the part. Then, your method could/should use join : . go_to_next_player The pythonic way to loop is to avoid using the length of the list. 

Checking things Prefer just to . Prefer to comparing against 0. Recursive and Iterative is both recursive and iterative. Pick one - iterative is good enough. Just have it loop until done: 

I think there's an issue with wording here. What you're testing is if a given instantiation of a class template is default constructible. You're not testing if it's "specialized". You cannot check for that. How would you differentiate between: 

And then this can be further reduced! Since we never care about each individually, let's make a vector of them: 

It's like you never want anybody to read your code. So you're basically trying to do a sort of quicksort based on partitioning the head. Let's just write that in more than one line of code (and rename it to to mimic python and make it sound less like you're sorting in place): 

given that it sure looks like we're going from to by s... which intuitively should produce . You already do correctly provide two type aliases, where is an alias for ... so if somebody wants a negative range, they should have to do: 

Separate Your Concerns The function at the moment does two things: finds matching customers and checks that it's nonempty. Let's instead add a default checker: 

Rather than using at every opportunity, it would help to just define the current and previous index up front and use that throughout. Also comes in handy: 

Assuming you count rectangle by exhaustion (case by cases), you'll never be able to have a complexity smaller than the number of rectangles. My feeling is that the highest number of "rectangles per point" is obtained when working on a grid of width n (n*n points). Indeed, in that case, we have : 

About As far as I can tell, is interesting only in the method. You can propagage the relevant information (name and/or score) to the other method needing it. By doing this, you can again make things a lot simpler by just having a variable in . Extracting user interaction in separated functions It might be a good idea to extract the user interactions in separated functions. It makes input checking easier and make the game logic clearer. Here's what I have written : 

Also, it seems to hilight a bigger issue about the fact that the connection might not be closed. find_longest_tandem_repeat In : 

It is relevant in your case because you have an array of elements so the last index you should access is . The usual way to write the corresponding loop is with (instead of the equivalent ). The stays the same, I'll let you understand why on your own. The code is now : 

Regarding You don't need to use a new variable. You could use directly. You may use the fact that non-0 integers are considered as True in a boolean context and 0 is considered as False to write . Anytime you use and on the same values, you could use . Here you could write: 

Really adding predicates is the way to handle calling after the was called. The wrapper is not a good solution to this in my opinion. 

As-is, if fails, you're returning 0, which seems pretty misleading! Also, people know what is, so you can just do . main() I'd move the whole body into a separate function just so you can remove one layer of indentation: 

and has several examples in the standard library (, , , , , and ). A lock is something which, for lack of a better description, locks a lockable object. The simplest lock in the standard library is , which is just an RAII scoped lock templated on a and can be implemented via: 

But this is unsatisfactory, as then you have to recalculate how many odd divisors it has. So instead, we can use: 

But then for the other special member functions, you should either default all of them or omit all of them: 

String Concatentation String concatenation is slow. Also it reads terribly. What we want to do is call for every letter in and then join them all together. That's what is for: 

Otherwise you'll get the wrong thing from . This constructor seems wrong - what types are constructible from both an and something else (I'm omitting the SFINAE for brevity)? Perhaps just the ? 

Cents make Sense A much easier way to think about money is to just store everything in cents. That makes all your mathematical operations trivial (just translate to the appropriate operator). This is especially a big deal for things like comparison, where comparing one thing is easy, but comparing multiple things is much harder... Unnecessary work only has integer types. It doesn't manage any memory. So the default copy/move constructor/assignment and destructor all do the right thing. Let the compiler do its job for you, and do not write these functions! If you insist, you should just them: 

Then it seems a bit more obvious than sell_threshold is not useful. Also, as suggested by jonrsharpe's comment, you can use : 

Now, something I am not quite sure about is how you want to handle the "middle" element (if any) of your input. At the moment, you ignore it which is fair enough depending on your requirements. It would also make sense to add it to itself or to keep it on its own so that the sum of the original list is also the sum of the new list. A slightly different solution for this would be to handle two different indices (or two different iterators) and to stop when they cross. 

The name probably needs to be improved for something more meaningful. The right tool for the job To add all the content from to , you shouldn't use but . 

Document your function and use the correct type Your function returns both lists and boolean. Maybe it's be clearer to make it return a list (when a list is found) and otherwise. This can be documented accordingly in a docstring. 

Then, I am wondering if you should be checking or . This corresponds to choose whether you can have a sentiment of value 0 (for instance if you have both positive and negative words) or if it corresponds to None. This is an open question and I do not have the answer. Finally, a slightly different way to write this function would be to abuse list comprehension in order to be able to reuse builtin functions and . For instance, we'd have something like : 

Pointer to pair? Similarly, for , take a vector of pairs - not a vector of pointers to pairs - and by reference to const: 

On the producer front, did you really mean and not ? Let all the consumers fight for the lock! Lastly, this: 

So from the Euler example, we start with and . That doesn't divide, neither does 3 or 4. We get to 5, set to , and reduce to 2639. That is no longer divisible by 5. Then we get to 7, is now and is reduced to 377. Then we get to 13, and is reduced to 29. At this point we're done, since . We know that the remainder must be prime (otherwise we would've found a smaller factor already), so we return 29. Note that the square root of 13195 is 114, but we didn't even go as high as 14. Your original solution would've have gone up to 114, then gone up to 6597. I just saved you something like 6700 mod operations. And mod operations are not cheap! Optimization Potential Once we check for 2, we don't have to check any more even numbers. Once we check for 3, we don't have to check any more multiples of 3. So a simple optimization would be to loop over the factors 5, 7, 11, 13, 17, 19, ... by alternating adding 2 and 4. This is going to be a relatively minor improvement compared to the algorithm improvement I just suggested. 

Enumerate As pointed out in comments, you could (and should) use enumerate to keep track of the current index during an iteration. In your case, because it makes sense to start from index 1, you can use the parameter. 

You could also use some recipes to iterate over consecutive pairs. Then, you'd get rid of the boundary check altogether: 

It may be a better option when considering a new permutation to handle all the rotations in one go. For instance, you could decide that a given permutation is interesting only if it corresponds to the smallest of its roations. Then you'd have something like (a set is used to get rid of duplicated rotations): 

Making debugging easier Now that you know that your code is wrong, you might as well try to make it easier to debug. My suggestion is to work with strings until the very last moment so that you can print it whenever you need. At the end, you just need to get the length of the string and you are done. 

As I am talking about tools, it is probably worth mentionning that you'll find various other tools to check your code. pylint finds : 

(I could move the definition of link out of the loop but I guess in your real situation, the content depends on ). 3) You can try to store your content in an array instead of using different variables. It removes a bit of logic and makes things easier to update if you want 2 or 4 columns in the future. It also removes some code duplication : 

Presumably, these are all attributes of a player. That suggests that you want to stick them all in a type: 

is a . Lookup in a list is linear time, and comparison is more expensive than int comparison to boot. Instead, use a different structure: 

That way you only implement the average logic once. If a member function doesn't change the object, make it Good practice. A lot of your member functions (e.g. , , etc.) don't make any modifications to split. So they should be . Just expose the splits Rather than having , , , , just expose everything to the user: 

That's it. Sure, I have to show you what is. But this is the power of C++11. We use RAII for locking (no or ), keep the mutex in a map, and don't need macros. That is super cool. We just need some other utilities: 

As a truly recursive solution, divided neatly into base and recursive cases, I find it much easier to follow the logic. Debugging Rather than write a level-by-level comparison, you should simply write an method on (or, alternatively, a much more correct or ), and then use that to compare: 

The latter on the one hand adds a better invoke mechanism, in that it's actually callable. But then it limits you to non- member functions. But both can really be replaced by writing a reduced form of :