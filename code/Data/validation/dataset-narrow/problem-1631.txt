And what problem does the useless junk really entail? Configuration files are tiny, little things. Many are measured in bytes, and few are more than a couple KB. It might be annoying from a general principle kind of thing, but unless you're installing and uninstalling a huge amount of applications (that presents other issues) it's just not going to cause any kind of system issues. 

Can Embox be hacked/configured to run on the RPi: The answer to this question is: "maybe". Embox is written for embeddable platforms, and is open source. Embox can certainly be tweaked and compiled for the RPi. In fact, there's an open issue on the github repo to do such a thing. If this is what you want to do, prepare yourself. This won't be a simple endeavor. 

You're getting an error because your code doesn't make sense. Unlike C, C++, or Java, Python has no parentheses. Rather, it uses indentation to determine logical blocks. Since you never "deindent" at the end of your class, Python is interpreting everything after as a part of the class. Additionally, your code is inconsistently formatted. The first time you indent, you use 4 spaces. Everywhere else, you use 8. This will make Python unhappy. You can use whatever indentation value you want (I suggest tabs instead of spaces), but you need to be consistent. You need to deindent lines 36-45 and then delete the empty lines 9 and 35. That gives you the code: 

EDIT: Note that the question was changed from "how to detect 12V turning on a light bulb" to the current question about doing so for a backup bulb in a car. Other solutions are better for an automotive environment. 

Sounds like you may have some floating inputs, i.e. logic inputs that are not pulled or driven high or low. Some times when you touch floating inputs, it sets them at a particular logic level. You can try probing the pins individually with a 10K resistor on a wire tied to 3.3V or GND and see which exact pins are causing the problem. 

Your best option is to use a USB Wifi dongle that has an external antenna and disable the on board WiFi. For really long range, they make dongles with two antennas. Just Google "usb wifi external antenna" for many options. To find one with two antennas, just click the "images" button on the google search results page. The description of the dongle usually lists the WiFi chip used. Make sure to get one that has a chip that is supported by Raspbian . If you need REALLY long range, you can use an external antenna dongle with a long range 2.4 ghz antenna . 

Presumably you looked at $URL$ from Adafruit. Once you get your data with the microphone, what you want is an "audio spectrum analyzer" . You will need to do Fourier Transforms to convert the time series data from the microphone into frequency data. You can look for the standard musical note frequencies in the Fourier Transforms. There is a computationally fast way of doing Fourier Transforms aptly named FFT, i.e. Fast Fourier Transform. See $URL$ for info on how to do that on a Raspberry PI. There is a LOT to understand about FFTs and spectrum analysis. For example, the frequency resolution of the FFT depends on the number of samples that are processed. You also need to understand windowing. See $URL$ . For this specific example, if there are multiple notes playing at the same time and the same note is played in different octaves, you will have to distinguish between overtones from lower frequency notes and the fundamental frequency of higher notes. For actual music versus isolated instruments, this is non-trivial. 

It really depends on what you want to do. A real-time system usually means that a system's response to stimulus is guaranteed within a specific timeframe. A simplified example is an immediate response, rather than a queueing. Most operating systems aren't designed to work in real time; there's very little reason for them to be. If you don't have a real time OS, it's very difficult (if not impossible) to run real time software. The primary way to deal with this is to use hardware that's dedicated to the task, and then have your operating system interface with it. For the purposes of learning general programming, you shouldn't need to worry about this unless you have particular real time problems in mind. 

There's no way to do this with the Raspberry Pi as it's currently designed. If the device is plugged in, it's on. If you shut the device off through software, you need to physically power cycle the device, or hit the reset pin. I would recommend that you just not worry about it and let the RPi run continuously. It uses about the same amount of power as a cell phone, which is estimated to run at a cost of about $0.25 per year. 

Using direct Ethernet? Why? To even make direct talk possible you would need a crosstalk cable, which is an ethernet cable where the wires are crossed so that what is output by one computer is received on the input pins of the other. This will take some specific knowledge of socket protocols, but could be done. My suggestion would be to use a router as an intermediate or transfer with a flashdrive. 

Assuming that your pH meter does not have a common ground with your RPI, you can connect the "GND" input to the pH meter to a 3.3V/2 resistor divider from the PI 3.3V supply and use a PI PWM output with an RC low pass filter to generate a programmable voltage without any DAC. Tie the RC low passed PWM output to the non-GND pH input and as the PWM value is set above and below 50%, the voltage into the pH meter will vary above and below zero, relative to 3.3V/2. If you want finer voltage control, you can use pull up/down resistors on the capacitor of the RC filter so that the resistor from the PI PWM output can only drive the output to some fraction of the 0-3.3V range as the PWM varies from 0% to 100%. The ratio of the RC resistor to the pull up/down resistors determines the range reduction. As for generating the PWM outputs, you can use the pigpio library to easily generate PWM signals on any PI output. All of this assumes that the rate of change on the pH voltages is relatively small, since it will be limited by the RC low pass filter time constant. In general, after a large change, the voltage through an RC settles to the final value within about 10*RC seconds. The PWM period should also be much shorter than the RC time constant, say ~1000 times, in order to filter out the PWM frequency. See $URL$ for a detailed PWM DAC application note from Texas Instruments. LTSpice Schematic: 

Put owncloud in a subfolder at the root of the drive and set its permissions accordingly. Owncloud doesn't care about the rest of the drive. Partition the HDD and use a dedicated partition for Owncloud. 

In my opinion, Raspbian covers the first bullet really well. Looking at it from the command line, it's very similar to Ubuntu Server. Both are Debian based after all. From the second point... To put it nicely, the default Raspbian distribution is rather bloated. @Ghanima mentioned Arch, but for most people, that meets the second point, but widely misses the mark for point one. Some people love it, but a large percentage of people find it rather challenging. My recommendation is to use Raspbian Lite. Just looking at the image shows a much smaller size, and everything you want to install is just an call away. 

Run . Select Expand Filesystem (the first option at the time of this writing), and follow the instructions. 

Based on everything you've described in the comments, it sounds like your issue is directly related to your power supply. The Raspberry Pi Foundation recommends a minimum of a . According to your comment, you have a . 

Have you checked your translation/keyboard settings? At one point I was using a really odd computer to login to my home server over ssh and had to play with the Terminal > Keyboard settings in putty. Also, make sure that under Window > Translation the computer you're using has UTF-8 set. 

Here is a paper that discusses the frequency response of silicon image sensors in general. The graph below from the paper, shows that the image sensor response is about 20% of the peak sensitivity at the short wavelength end of the range. However, it doesn't drop to zero until around 300nm, so with very bright 390nm illumination, you should be able to see something, assuming that the RPi camera has typical silicon sensor response and that there is not significant UV attenuation from the lens. With really bright illumination, you could use a pinhole lens to eliminate glass attenuation. 

Take a look at this link at github. It has a patch for WebioPi that makes it work on the PI2 and PI3. I have used it successfully on the PI2, but have not tried it on the PI3. There is a discussion of the patch at raspberrypi.org 

Use a voltage divider to monitor the 12V at the light bulb. Make the resistors large enough that they do not significantly affect the bulb. A 3K resistor for R1 and a 1K resistor for R2 divide the voltage by 4, giving you 3V at Vout when powered, and a 1K pulldown to GND when the switch to the light is open. 

As you can see below, I somehow have duplicate file names. I'm not sure if the files themselves are duplicate. Any idea how this can happen? The PI is running Raspbian Jessie. 

Secondly, we should look at Raspbian. According to its about page, Raspbian is licensed with a standard GPL License. In a similar, vein, looking at Debian would be helpful. It is afterall, what Raspbian is based off of. They have a helpful redistribution guide, and state that it can be used commercially, and even burned to a CD and sold as is. They do however, issue a warning: 

Raspbian has a package manager built into the OS. It's called "apt-get". You can install software by typing . Likewise, you can delete the software by typing . If you really want to be sure to remove everything the package came with, including configuration files the option will do that as well. Once your operating system is installed, and you're happy with how it's configured, you can image it. Remove the SD card from your RPi (turn it off first!) and image it. Later, if you break something, you can simply rewrite that image to the card and it's just like it was the day you imaged it. 

It looks like you've created an infinite loop. Your while statement needs braces. If you don't include braces in loops or if statements, they will only affect the line directly beneath them. In effect, you're constantly setting the channel, but never update the controller. Change your code to