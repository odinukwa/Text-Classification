zsh comes with its own completion library which includes completions for Git commands. Once you enable zsh’s completion, these bundle completions will be available. You usually enable and configure zsh completion by running (i.e. ). It will modify your to include and so that completion is initialized for each instance of zsh. automatically loads completions from zsh’s directories (see the “Autoloaded files” section of the manpage). For example, my system has two versions of zsh installed: 

The bit specifies a server socket that you are probably not already using (if you happen to have a server using that socket name, then just pick some other, unused name). The makes sure that the server does not use your normal configuration file (though, short of a custom build, there is no way to skip the system configuration file). The command is necessary because only certain commands will automatically start a server. 

This is a window option, so it will apply to all the panes in that window. After a pane’s command has exited, you can use to start its command anew. 

It sounds like you might have been using a non-standard(?) function, mabye it was recenter-top-bottom. 

Incidentally, you should almost always put your parameter expansions in double quotes (to avoid word splitting and glob expansion). You only have the one parameter and its value (copied from ) is (usually) probably safe not to quote, but it is a good habit to always quote your expansions in almost all contexts. 

The “target specifier” syntax is described in the “Commands” section of the tmux manpage (search for the first occurrence of , , , or to find the relevant descriptions). I have never used screen’s command, but it also looks like it has iteration features. There is currently no direct match for that in tmux, but it should be fairly easy to “script” by parsing the output of , , , and (newer versions of tmux have the option for these commands that can help generate output that it is easier to parse). 

Apparently your errors are coming from . It does not properly handle spaces in the filenames it is given. Internally, it is using the given filenames as glob patterns instead of actual filenames. Unix shells normally handle globbing for the user so programs do not often include this functionality themselves. Maybe this bit of functionality was for Windows users (where the shell does not expand file patterns). Anyway, you might be able to work around the problem by wrapping quotes around your filename: 

With tmux 1.2 (and later), you can use the option of to output a message to stdout (instead of displaying it to an attached client): 

The underlying comparison code () looks like it handles UTF-8 mode, so you might be able to get some basic functionality by simply allowing bytes greater than 127 to be added to the buffer. There are (at least!†) some small problems if you do this though: 

You could bind any or all of these to different keys, or you could use to bind a key that lets you enter a custom separator string before pasting: 

Shutdown the temporary machine. Restart your MacBook Pro, holding down Option choose the Leopard partition from the boot menu. Use System Preferences's Startup Disk preference pane to choose the Leopard partition for subsequent boots. 

The usual answer to this type of question (why use only the lowest-order N bits?) is that it prevents leaking too much information about the internal state of the PRNG. If you give your attacker your full X_n state at two consecutive states, they could easily(?) determine the modulus and thus calculate all future states of the PRNG. That is, given the values a = X_n and b = X_(n+1), the attacker need only find the M such that b = a^2 mod M. As long as a^2 is larger than M, I think this should be easy to do. If M is larger than a^2, then b = a^2 and the attacker needs keep asking for numbers until the modulus comes into play. 

setting the core.sparseCheckout configuration option to “true”*, and filling in the per-repository file with the patterns for the pathnames to keep**. One might use the the low level “skip-worktree bit” in the index*** to manage the sparseness of individual files, but it is probably easier to use the higher level mechanism instead. 

This answers the more specific question in your comment to your original question. It could probably have been a new question since it is much more specific. 

Unfortunately, the mode-specific bindings (done with ) currently only support one command at a time. Additionally, the command must be one of the mode-specific commands, not any general tmux command. In the source, the function limits the non-option arguments to exactly two when using : one key and one command; this is why you get the usage message (though the message it not very illuminating). You can use invoke the command to save a couple of keystrokes though. In mode: use instead of . In mode: instead of . 

Whether TRIM is useful or not depends on the controller and firmware used in the SSD. In a good SSD implementation (Intel's, and probably a few others), the drive can use “unused” blocks as scratch areas to help even out the performance and ‘wear’ of the device. When a drive is fresh from the factory, it starts out with every block in an “unused” state. As the OS writes data to it though, the drive has to mark blocks as “used”, even if the OS went back and ‘deleted’ the files that use those blocks. What is TRIM The SSD itself (usually) has no idea what kind filesystem the OS is using on top of it, so it has no way of tracking which blocks are actually used by files versus which block were previously used by files that have been deleted. This is because as far as the drive is concerned, a file deletion is nothing more than a write to certain blocks hold the information about the directory in which the deleted files resides (a normal file delete operation does not touch the file data itself, which is why undelete utilities have a chance to restore deleted files). The TRIM command (when it is supported by both the SSD and the OS) will allow the OS to tell the device which previously used blocks are now available for the SSD to use. It allows the OS to ‘trim’ the SSD's concept of what is used down to what is actually used by the filesystem instead of the SSD's conservative concept of “anything that has ever been touched is still (potentially) in use”. OK for an OS? While TRIM support could help an SSD maintain optimal performance, it would not seem to me to be a critical factor in deciding whether to use it as an OS disk. Few drives and only the most recent OSes actually support TRIM, yet that does not stop some people from whole-heartedly recommending SSDs for the OS and applications (at least the top-of-the-line ones, not so sure about your Kingston one). TRIM support via Firmware Update Whether your device gets TRIM support is really up to your vendor. You will have to take it up with them. I suspect that the better devices will be upgradable with TRIM support, but certainly not all existing devices will end up with TRIM support. Background Go read AnandTech's SSD reviews for lots of good information: 

Write the current buffer to its file. Run the tmux command to send the Control-R to the bottom‡ pane. We use here so that the next Vim command () is not taken as part of the shell command. We use the prefix command to avoid the “Press ENTER to continue” prompt. You can omit if you want the prompt or want to see the output of the command (e.g. the tmux command is not working, and you want to see if it is giving an error message). Redraw the screen. This would normally happen after the “Press ENTER” prompt, but we are suppressing it with .