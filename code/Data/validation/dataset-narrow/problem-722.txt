Hard level algorithm It is hard level algorithm, and Leetcode shows that there are 231.9K submissions. I like to post the algorithm for code review, I did study discussion panel on Leetcode 212 to get one idea to solve the problem, and then I carefully prepare my own learning notes as well. It is also a good idea to discuss why Trie is needed for better time complexity. Brute force solution is to go over each word in the dictionary, and then try to find it in the matrix. The total number of search using DFS is m (words) * rows (matrix) * columns (matrix). The brute force solution has timeout issue through Leetcode online judge. We like to review why the time complexity should be better. Let us go over dictionary with 4 words, "aaa", "aaaa","aaab", "aaac". If we pre-process the dictionary and store all words in a Trie, and then we do not have to go over each words to search matrix. We only need to go over each element in matrix as start char in a word, search the trie to find match words using recursive function. The number of search using DFS is rows (matrix) * columns (matrix). Second advantage related to the above 4 words ( "aaa", "aaaa","aaab", "aaac") is taking advantage of Trie data structure. The space complexity of Trie is better compared to hashset or hashtable. The same prefix "aaa" is only repeated once in the Trie. Trie against Hashset Related to the test with a dictionary "aaa","aaaa","aaab","aaac","aaad", let us work together to talk about the difference. For example, if the dictionary is saved in hashset, then go over each word in the dictionary, try to find word in matrix. For example, "aaab", the first three letters has to be compared and they are the same first, then the last letter will be checked. Same will be applied to another 4 words. In total, the prefix "aaa" will be compared exactly 5 times in order to find those 5 words. Can we do better? Just compare the prefix "aaa" once? Cetainly we can. We can save the words in a trie instead of hashset. a | a | a |\ \ \ | \ \ \ |   \ \ \ a   b c d Trie efficiency talk It takes some time to get comfortable to design a Trie. So far, I have written a Trie implementation more than 4 times in C# last 3 years. Given the fact that I have worked on computer science study and full time work more than 20 years, if I practice one algorithm a day, then it is around 60,000. Definitely I should practice more how to write a trie, use the trie to get better space complexity. How to design a Trie so that the space complexity is minimum? For example, the dictionary has the following words, "aaa","aaaa","aaaaa","aaaaaa". How to store them in Trie efficiently? a | a | a word: "aaa" | a word: "aaaa" | a word: "aaaaa" | a word: "aaaaaa" The above diagram shows that those four words are saved in a Trie. How many char 'a' are saved in Trie, only 6, not 3 + 4 + 5 + 6 = 18 chars. Four words are saved along the trie nodes. Every node can represent a word, it does not have to be a leaf node. The C# code is written based on the study of one of Leetcode discussion. 

If number of lines is your primary concern, then really all we can do with this is merge your array creation lines, and use to create temporary arrays which you can loop around, like so: 

The first thing I spotted was this: . I'm not sure if that's an error with your page name or code, but whichever it is needs to be fixed. 

I put as a method as it isn't clear whether you're using this design pattern elsewhere, but I assume so as you're connecting to something and there's usually other exceptions that can happen later. If you aren't, you can just stick it back into the catch block of . Additionally, if it isn't clear, the ternary is so you don't have to manually type in the message to attach a cause to an unknown exception being wrapped. And I took the liberty of replacing the generic message "connection" with the stack trace of the exception that caused it being passed to your logger, as this more detailed information will be useful should you wish to debug the cause of it. 

You do a lot of mapping from parameters to arrays and vice versa, which you could simplify by storing an array of the parameter names and whether or not you want them trimmed, for example: 

This way, you don't have to override every time, and you also don't have to put "ERROR" into the actual text of the exception. 

And manually implode some queries with it. To make it generic, have a method which removes vowels in this way, such as: 

The first thing that jumps out is all the Strings you have which are reused throughout, those need to be removed and ideally put into constants so you only have to change them in one place if you ever need to rename them: 

If the code will be distributed, read or maintained by others, you might want to look at your naming conventions as they're a bit inconsistent, for example sometimes you use underscore separated names such as , but other times you use sulkingCamelCase such as and in class case. Either one is fine, as long as you use the same throughout. Aside from your single line getters and setters, the function names you've chosen are not always indicative of what the function does. Ideally you shouldn't have to read the actual code to know what a function does, consider these changes: 

Given the queen's position and the locations of all the obstacles, find and print the number of squares the queen can attack from her position at \$(r_q,c_q)\$. Input Format The first line contains two space-separated integers describing the respective values of \$n\$ (the side length of the board) and \$k\$ (the number of obstacles). The next line contains two space-separated integers describing the respective values of \$r_q\$ and \$c_q\$, denoting the position of the queen. Each line \$i\$ of the \$k\$ subsequent lines contains two space-separated integers describing the respective values \$r_i\$ of \$c_i\$ and , denoting the position of obstacle \$i\$. Constraints \$ 0 \leq n \leq 100000\$ \$ 0 \leq k \leq 100000\$ A single cell may contain more than one obstacle; however, it is guaranteed that there will never be an obstacle at position \$(r_q,c_q)\$ where the queen is located. Output Format Print the number of squares that the queen can attack from position . Sample Input 0 \$4\$ \$0\$ \$4\$ \$4\$ Sample Output 0 \$9\$ Explanation 0 The queen is standing at position \$(4,4)\$ on a \$4\$x\$4\$ chessboard with no obstacles: 

Introduction of Algorithm: I am learning the segment tree and also binary index tree this weekend, and I studied binary index tree from the article on hackerearth related to binary index tree and segment tree from the blog algorithm: Ahoy, Pirates, so I decided to take some time to practice the algorithm, spent a few hours to work on the algorithm "Kindergarten Adventures" on Hackerrank university codesprint again. Also, I like to present the idea from Hackerrank editorial notes first, and then share my C# practice code to ask for code review. Editorial notes: If a student asks for a minute extra time, then he can never be happy. We can ignore him. If a student with id asks for a minute extra time, then if we start from id \$a-t\$ (if \$a-t\$ is negative, wrap it around), then he will be happy. Not just that, if we start from any id lower than that he will be happy. So we get a range of students ( the range may wrap around ), from which if we select an id, we are sure to make happy. For each student, we get a range. Now, we have to select an id which is covered by maximum number of range. This can be done using Binary Indexed Tree or Segment Tree. We need to deal with ranges that wrap around. The students are sitting in a circular fashion. Imagine they are sitting linearly like an array from to . Now just append \$1\$ to \$N\$ to the array, so that we have two segments that go from \$1\$ to \$N\$. Now any \$N\$ consecutive elements of the array is a valid ordering of the students. Now work with the second segment of the array. For each position \$N+1 \le i \le N+N\$, if student \$i-N\$ request \$t\$ time, then we need to add \$1\$ to range \$i-N+1\$ to \$i-t+1\$. Next, to find the value of \$X\$, we iterate over \$1\$ to \$N\$ using \$i\$ and select the index for which sum of values at position \$i\$ and \$i+N\$ is maximum. My Implementation of segment tree I documented the step by step how a segment tree is built using the array starting from , and added some notation for each node in the segment tree using array index ID, range of the node is represented and also the value of node in the comment, went through the sample test case . Make sure that every step is making sense and then assume that the learning of segment tree can be accomplished by this simple test case. Most important is to implement the API of Modify and Query using time complexity of , whereas Modify function is the second argument which is the range of interval, Query function is input argument value. Otherwise timeout will be an issue in the problem solving. Test case study I did spend time to learn the algorithm about time complexity. For any N smaller than , I certainly can choose as to analyze. Suppose that there are students in the circle, suppose that the first student only need to minute to finish drawing, so that the first student can complete the drawing for any student chosen by the teacher to start. Related to SegmentTree class Modify API, it has to increase those nodes by value . If the time complexity is linear , and if all students has operation, then there are operations of N2 = , almost million operations, but the time limit is only 3 seconds, so I am pretty sure that the function will cause timeout. So that we have to lower down to intervals to cover the range of using segment tree. To make it simple, we assume that the range's width is instead of , and see how many steps we need to mark in SegmentTree class variable tree[]. We will show only increment operation. Let us get our hands dirty on the calculation of tree.Modify(0,1024,1). We read the code pasted here first. 

I don't really like the method of exception pseudo-typing you're doing, I'd use different objects to represent the type of exception rather than the content, like so: 

Which will save you a lot of rewriting if you decide to change the names of any of the properties down the line 

And you can delete the rest of your class. Edit: Using the new method would then allow you to add pieces of text at the specified points in your message, so your validation method that returns a State would use it as follows: 

If you want all your exceptions to follow this style, then you could have one parent Exception class, then make your application exceptions extend it, like so: 

I have a array and a of a custom object and I'm needing to loop around and perform an operation on both but only as long as one of both is available, the original method is as follows: 

Obviously the on every iteration is inefficient, however as I need to maintain a counter, an enhanced loop means keeping a separate counter and performing a check on it every time like so (list declaration skipped for space): 

I've been implementing a custom internal server error page in ASP.Net MVC which will check if the current user is either an administrator or accessing the page from localhost, and if so, show them a whole bunch of details about the error to debug it with, otherwise just send them to a basic HTML error page. So far, it works great, but one problem I had was that if there is an error in a partial view on the page, the system gets stuck in a loop trying to report the error. To avoid this, I'm storing a temporary counter of how many times the current action has requested the error page in , but I find the amount of lines and style of the code to get, set and check this variable a bit verbose: 

Additionally, you have made and into optional parameters by making them auto-initialise to empty arrays, however you cannot have an statement without specifying at least one field and value, therefore instead of making them optional array parameters, you should use type hinting to ensure they are arrays, and then check to make sure that the arguments are correct before you send the query off to the server, something like this: 

Problem statement You're researching friendships between groups \$n\$ of new college students where each student is distinctly numbered from \$1\$ to \$n\$. At the beginning of the semester, no student knew any other student; instead, they met and formed individual friendships as the semester went on. The friendships between students are: 

Base Case Function FindKthSmallestElement_BinarySearch's two arguments start1 and start2 should apply to multiple statements. Here are details: 

My introduction of the algorithm The algorithm is a medium level one in the hackerrank contest of week of code 28 from January 9 to 15, 2017. I wrote an algorithm in the contest, and the code has over 300 lines of code, with timeout issue, not efficient. So I learned to use dynamic programming method to solve the algorithm today. I read the editorial notes on hackerrank first, and studied one of submissions, and then built a frequency table for the sample test case to clear my questions from code reading. And then I wrote the algorithm following the ideas showing in the frequency table, using dynamic programming bottom-up method. Hackerrank Editorial Notes In this problem, you are given a sequence of digits of length . You have to find the number of non-contiguous subsequences, such that the number formed by their concatenation is divisible by 8. Observe a bit, The number is formed by concatenating the non-contiguous subsequences, which implies that the number itself is a subsequence and vice-versa. So the problem boils down to counting the ways you can make a subsequence divisible by . This can be done by Dynamic Programming. At any position of the sequence, you need to consider two cases: 

Introduction of algorithm The implementation of the algorithm is to scan the string once from left to right to filter out non-alphanumeric characters first, and then check the string is valid palindrome ignoring cases. The reason I like the implementation is that the code has some simplicity, avoid mixing checking if it is alphanumeric character with two pointers techniques. The C# code passes leetcode online judge. 

My introduction of the algorithm The algorithm is the hard level algorithm in hackerrank world codesprint 10 in April 2017. I did write a recursive depth first search tree algorithm in the contest, passed the sample test cases but failed all other test cases with wrong answer errors. So I spent hours to study one of code submissions and put together a C# solution after the contest. The algorithm turned out to me a simple depth first search(DFS) after hours study, debugging and walked through the sample test case. My understanding of DFS solution here is that the base case in the sample test case shown in the graph is the node with one connected edge, for example, starting from left to right, node with weight and node with weight . For any edge in the graph, for example, edge :, node starts a DFS search until it reaches node whereas node starts a DFS search ended at itself. The dynamic programming part is not easy to come out and it takes some time to build the recurrence formula. Base case is easy to figure out, node with one connected edges. For any edge to serve each of two nodes, it has to calculate the maximum/ minimum value include/ exclude itself within all connected edges. The C# code passes all test cases. Depth first search is my favorite algorithm, sometimes I forgot that recursive function is the economical choice for DFS compared to iterative one using stack. 

The ideal package structure is one which indicates usage. Classes such as these which exclusively contain static methods are definitely utility classes, which I usually put in a subpackage of your main application. From what it sounds like, you don't have a main package at the moment which ideally would be your website (in reverse domain order), e.g. so that the more specific elements are later, then on top of that you'd have the name of your application which may make it something like . This would be the core of your program, and from here you could then add on your extras. The package in particular doesn't sound helpful: your entire program seems to relate to Twitter so it doesn't really convey what that part of the program does. Frankly, I'd just put all those classes under and add in more sub-packages if you add more classes. And generally speaking, in Java packages should be exclusively lowercase. 

It's secure, but it's really chunky and tedious to write. I'd do this by overriding the magic method to trick GSON into thinking the methods exist, like so: 

The best optimisation is only doing what's necessary. When checking the login, you don't check whether they've even been specified until after you hash it, consider reordering it like so: 

What I have so far seems to work fine, apart from the aforementioned issue, though the amount of code for what sounds like such a simple function is far above what I'd hoped, so I'd really appreciate any ideas on how to reduce it. 

I would also avoid using regexes or any kind of manual string parsing, you can do it all with and , thusly: 

However, when you increase the number of possibilities to 10, and reduce the guesses to 5, you can no longer do this, and the chances of never guessing a correct number increase dramatically, e.g.: 

The only other comment I have is that the and methods are , so you should be calling them as and rather than which is for instance methods. 

So it sounds like they want it so you can add a mouse to the choir and it will only squeak, and a cat will only meow. Instead you have a single choir which randomly picks a sound to make and no distinct objects for the animals. I suspect they were wanting an Animal to make a single noise which is specified upfront in a more object-orientated way. Something like this at a minimum: