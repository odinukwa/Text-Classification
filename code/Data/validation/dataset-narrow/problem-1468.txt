One of the early examples I usually use is a quadratic equation solver using the quadratic formula. Since many languages don't like that old square root of a negative number thing it's a nice place for a conditional. 

With respect to APCS-A there won't be a difference. Personally, I'm not overly fond of IDEs or one trick pony environments so I've encouraged our students to use an editor. I'm an Emacs wonk but the kids also use Vim, Sublime, DrJava (which is a lightweight IDE) and more. In APCS-A they won't be getting to HUGE programs and to be honest, in my experience, an IDE like Eclipse provides too much and is too cumbersome for APCS_A. I obviously don't know much about your specific situation (you, your kids, etc) but my general recommendation for APCS-A would be: 

I've been in rooms with smartboards that aren't dry erase marker safe which means if the smartboard goes down the board space is lost. I've never used a smartboard but think I get the most bang for the buck with a projector onto a whiteboard. We can project sites, code, etc and also annotate by writing on the board directly (although the annotations can't easily be saved other than by taking a picture). 

I like the pez dispenser. Also the stack of papers (where the actual human interaction is never to take the top item but rather to take the second from the top. At some point you have to talk about pancakes and the fact that people don't actually eat them as a stack -- they frequently destroy stack integrity by cutting top to bottom. I personally use a stack of pancakes as a queue, extracting one at a time from the btotom as it soaks up syrup but I've been told I'm an odd one :-) 

In a live webcast or classroom, you simply display the presentation view and press the right arrow on every transition cue in the presentation. if the webcast is prerecorded, you record the audio separately and use premiere pro (or any half decent editing software) to match the transitions to the audio. cut edits on screen shots are invisible. 

Unlike java, the paragraph defined between the tags 0990-do-input and 0990-do-input-end has no scope. The behavior of the perform is to execute a jmp to the paragraph, then a jmp back to the point after which it was called. Since the "perform" statement is essentially a "goto", "structured programming" is still a very big deal for COBOL programmers, even though the rest of the world is working in languages that won't compile unless the code is "structured" far beyond the way that a COBOL programmer means it. 

This started as a comment, but got too long, and I realized I was moving well into answer land. Understand I'm not a teacher with a class full of kids, so this may be too esoteric of a way to look at the question. However I have worked with students at different times from different types of backgrounds. Those who were in classes where OO programming is taught first took longer to produce their first working application, but when there was a working application it was far in advance of what their peers in a functional programming first class are doing. I admit I learned functional programming first, then progressed to OO programming later, but that was because in 1975 there were not many OO languages available to a high school student using the school's teletype. Xerox had decided that Smalltalk was cute but had no commercial value, so the paradigm appeared dead. Start with the understanding that Object Oriented Programming is a way of analyzing and structuring problems, and is not tied to any language. You don't need an OO language to write OO programs. I have seen OO programs written in COBOL (not OO COBOL, which is neither OO nor COBOL). I built OO frameworks in K&R C, back when C++ was mostly an academic novelty. I have seen and built OO programs in BASIC (as in "10 let x=1", not the modern Visual BASIC which is a blending of BASIC and PASCAL). Teach the concepts of dealing with an entity. There is the entity, its attributes, and methods for it to interact with the outside world. In COBOL, you might embed the entity and attributes in a copybook, then the methods in nested programs (the lack of scope in COBOL sucks). In C, it might be a struct in a .h file and a function library. In OO languages, use the languages natural paradigm. Personify your objects. Use pronouns like "he" and "she". Teach to build the logic in the entity's method, and keep the methods very simple. Show that a complex method means that the solution is either housed at the wrong level or not clearly borken out. If they are taught this from the beginning, a lot of issues that require retraining can be avoided. 

I use peer evaluation forms as a part of group projects as discussed by @Buffy above, and I also split the marks between group and individual elements. Taking the question in a wider context, I'll just speak from my own experience of peer evaluation, and the opportunities and difficulties I have found with it. My first experience of peer evaluation was on the Rice University MOOC, An Introduction to Interactive Programming with Python. I liked it from the start, and thought it was a great way to grade work, provide feedback and reduce teacher marking time for formative assessments. We do not use it for summative assessment. 1) Sample exam questions: theory An exam paper based on the theoretical elements of the course was designed, and a grading rubric with sample answers prepared. I assigned each learner an ID number known only by myself. Each learner received a copy of the exam paper with their own number on it The exam paper had space for answers- no separate sheets. At least one question has some ambiguity- this is not told to the class, and they cannot ask questions during the exam. This is to allow discussion of question design afterwards. At the end of the exam, all papers were collected and each photocopied 3 times. Each learner is given a copy of a grading rubric and three random answer papers (not including their own) They are given time to grade each paper and make a note where marks not were achieved or partially deducted- this provides each learner with feedback. All feedback must be positive- indicate what would have improved the answer, and why marks were deducted. Collecting all the papers and re-ordering to give each learner back a copy is tedious work. After the exercise, we had an open discussion on each of the questions, if they could have been phrased more effectively. Expansion option: Given a specific Learning outcome, how might they create an appropriate question for an assessment. At the end of class, I provided them with sample answers to the exam so they could compare with what they had themselves. Outcomes: It was interesting that many found it difficult to award a grade, and did not realise how much time it can take to correct a paper. There was some variation in the scoring of identical questions- this proved a useful talking point. Each learner got useful feedback on their own work. Learners have a greater appreciation of the creation and marking of assessments. It was quite time consuming, but a useful exercise. 2) Coding mini-assignment- peer grading on Moodle Given that photocopying code is a non-runner, I set up a peer-graded Assignment on Moodle. Each learner had to work on a mini-programming assignment and had two days to complete it and submit online. Firstly, getting this to work the first time on Moodle was very time consuming. Even on the day, there were several delays in getting started. The grading rubric identified many elements such as use of "appropriate" names for variables and functions, header info, docstrings (Python), clear user prompts/instructions, working code, use of comments and so on. When peer-grading, it is possible to place a comment in each section to explain why mark(s) were lost, and each marker can place a final comment/general observations. Benefits of Moodle Peer assessment Learners are assigned the work of others to mark randomly Anonymity is an option in the setup Each learner was forced to really look at the grading scheme, which was provided from the outset. Many lost marks for simple things that they should have included (e.g. header information). This is important- that they realise they can get some marks even if the code doesn't work completely or partially. All got to see examples of other learners approaches, structure, working and non-working code. Seeing mistakes others make should help them identify those that they make themselves. Teacher can review all more easily without looking through a lot of paper, i.e. the grades given and received by each learner, and the comments given and received. Difficulties I have to say, from a practical perspective, it ran about as smooth as a dragons tail (i.e. not at all smoothly) but this was likely due to my inexperience with using this in Moodle. That said, it was better than paper. Some students failed to provide any feedback even when it was a requirement of the exercise. There are some relevant/complimentary points also raised here. 

I can't speak to cloud9 but I've always taught on Linux and am a CLI wonk. One thing I do is differentiate between user friendly and learner friendly. GUI interfaces are learner friendly - they're easy to learn but they're not user friendly because they're not that powerful. They're basically program loaders. You load your program, work in it, exit, next. The Shell is a little less learner friendly (although the fish shell is amazing from the learning point of view) but it is amazingly user friendly because it allows the user to do all sorts of things. I try to model this over the course of my classes and I try to provide examples. For instance, if I wanted to resize a bunch of gifs in a directory, I might show the class something like: 

We used processing in our summer program. It's a 4 week full day Mon-Fri program for rising 9 - 12 graders with no experience. In that time frame, they're able to learn some good CS fundamentals and write a nice project and games are the most common projects. Processing isn't a game development platform per se so that is both an advantage (teaching core cs using essentially Java) and a disadvantage (no built in game support although Processing is made for graphical applications that are dynamic with respect to time). 

It depends on what you mean by "used." The student projects might not lend themselves to TDD in that the early assignments will probably be very small and if the end up writing 90% of the project as tests and 10% as their stuff it could be deflating. That said, they should at least be familiar with TDD but that doesn't mean it has to or should be in CS1. The most important thing to get across early w/r to testing is not TDD in particular but the importance of thorough testing. I've never been a big TDD person but that doesn't mean I Don't test my code constantly throughout development - that's the important concept. What might be a good idea is to expose them to TDD in that when you give an assigment, give it with the tests / test framework. I played with this a little last year and plan to do it more next year. When giving a lab or homework, give it with the tests - kindof like having them use an online grader but they get and see the grader. Later on, if time and projects permit, they can add some of their own tests or perhaps even do the TDD thing whole hog. 

Set a formative peer-reviewed assignment using an LMS. This is based mainly on part of an answer I suggested to a different but related question here. Coding mini-assignment- peer grading on Moodle Given that photocopying code is a non-runner, and distributing files can be difficult, I set up a peer-graded Assignment on Moodle. Each learner had to work on a mini-programming assignment and had two days to complete it and submit online. This assignment was of a very similar structure and marking scheme as an upcoming summative assignment. Firstly, getting this to work the first time on Moodle was very time consuming. Even on the day, there were several delays in getting started. The grading rubric identified many elements such as use of "appropriate" names for variables and functions, header info, docstrings (Python), clear user prompts/instructions, working code, use of comments and so on. When peer-grading, it is possible to place a comment in each section to explain why mark(s) were lost, and each marker can place a final comment/general observations. Benefits of Moodle Peer assessment Learners are assigned the work of others to mark randomly Anonymity is an option in the setup Each learner was forced to really look at the grading scheme, which was provided from the outset. Many lost marks for simple things that they should have included (e.g. header information). This is important- that they realise they can get some marks even if the code doesn't work completely or partially. All got to see examples of other learners approaches, structure, working and non-working code. Seeing mistakes others make should help them identify those that they make themselves. Teacher can review all more easily without looking through a lot of paper, i.e. the grades given and received by each learner, and the comments given and received. Difficulties I have to say, from a practical perspective, it ran about as smooth as a dragons tail (i.e. not at all smoothly) but this was likely due to my inexperience with using this in Moodle. That said, it was better than paper. Some students failed to provide any feedback even when it was a requirement of the exercise. 

The LET notation was cumbersome, so most dialects of BASIC introduced the "implied let". If you started the statement with a variable, it was implicitly a "LET" statement. Algol, Pascal, and some other language of the day introduced the ":=" operator (read as "becomes equal to") to keep a distinction between assignment and comparison. 

In industry, the DEV environment is where developers are free to play and break anything (provided they fix it for those who follow). A typical enterprise shop will have a DEV, TEST/QA, and PROD environments, with developer access to DEV being nearly unlimited, but PROD being limited to end user support without significant from 5 layers of management and a pope. DEV will typically mirror prod closely enough for practical purposes, but be underpowered to reflect its lesser usage. 

Spaghetti code is often the result of not understanding the problem, although an attempt to treat variables as immutables when it is not appropriate would certainly contribute. Even experienced programmers will create spaghetti code if they don't understand the problem, or if the problem changes sufficiently over time. If you don't believe me, walk into any enterprise shop with custom processes and start reading code. 

which is nonsense, and they realize that, and get confused. When programming most languages use "=" as an assignment, where it should be read as "becomes equal to". Back when I started (in the 8 bit days before PC's), BASIC handled this by requiring the "LET" statement, so it read more like algebra, but the LET keyword was a cue that we were making an assignment. 

Learning Management Systems I agree that Moodle (and specifically the forum feature) may be the optimum solution, but not all institutions have this facility available. Another similar option that is free and easy to set up is Edmodo or Easyclass. Both are easy to set up and to share materials, as well as accept student uploads. They are also FREE :) and you are up and running in literally minutes. All three of these options are "teacher-centric". Something that is quite popular with MOOCS is a facebook page. I once got a reply to a question that was holding me up, from two people on the other side of the world- it was 0300 in Ireland, and I got to go to bed by 0330. Students helping others Suggest or ask for student-leaders in the class. Maybe they can add it to their resume- those with a lot of answers are effectively acting as teaching assistants? The best way to learn is to teach. In any case, it would be very much "student-centric" and self-managed allowing you to spend less time answering questions outside of class. Student Initiative The students may elect to set one up themselves, and offer peer-support to members- maybe you could be a member but it takes the onus off you to answer all questions. In many ways, it is better if they help each other, as they would all benefit in my opinion. Teacher Guidance From my experience of student questions, either in-class or online, the question one person asks is often in the minds of others as well, but for various reasons they are reluctant to ask. Perhaps offer a reward for "Question of the month" (SO guidelines being applied) or something to encourage question asking? Hey, why not an "answer of the month as well? It could simply be a printout, or something simple. Any of the options above would provide the facility that you need. Good luck!