Unfortunately they product description is all but clear and there is no datasheet available. From the product description however we learn: 

The simple way to go here, is to change the GPIO pin used for the PIR sensor. As long as the display does not need ALL the GPIO pins that seems quite easy (note that I am not sure yet, how the display is connected, other than what the product page reads (Transmits data through SPI (clock maximum speed: 128 Mhz)). Changing the input pin for the PIR sensor requires nothing else than fixing the script to the according pin number, the variable they call : 

You do not need additional resistors/capacitors on the bread board. All the components shown in the linked schematics are already included on the printed circuit board you've got from Adafruit. VDD/GND is connected to the supply voltage. Connect only voltages within the given limits and of correct polarity! 

The FAQ at raspberrypi.org states a "Maximum total USB peripheral current draw" of 1.2A for the Pi B+. I take it that "maximum total" should be the sum of all downstream ports. In this case it's outside specifications to drive both cameras directly from the Pi's USB ports - if they really draw that much current each. 

The MagPi, Issue 56 got these numbers for the power usage of the B+, 2B, 3B, and Zero (note the test conditions include additional peripherals): 

I think that in this particular case it is just a minor typo. Instead of it should read as Python is case sensitive. Another common problem could be installing the Python 2.7 or 3.x version of RPi.GPIO using either or and then later not running the script with the appropriate version of Python. 

More often than not displays provide more than one input which would allow to connect both the Pi and the PC directly to the monitor (as an alternative). 

As with all electronic appliances there is a small chance of overheating components and thus the risk of fire. My feeling would be that the likelyhood of the Pi starting a fire is similar to that of a Wifi router or something like that. Of course such feelings could be way off when it comes to small probabilities. Precautions should therefore include at least a flame resistant housing, the absence of easily inflammable materials in the vicinity of the Pi, and of course an unblocked natural ventilation. Personally I have not heard of a Pi being the source of a fire. But I guess anybodys google-fu is as good as mine, so I will not look into this matter right now. I doubt that the Raspberry Pi Foundation would accept any liability in case a 24/7 running Pi catches fire as this would not be a specified use case. 

Started as Community Wiki answer based on Shan-Desai's comment from Mar 6 '16. Feel free to edit or add your own answer. 

There is a nodeMCU based related project listed on Wikipedia that features exactly what you ask for: 

Ripping off SteveRobillards excellent comment: Use the HAT's I2C EEPROM The Raspberry Pi Blog points for HAT specification to GitHub where both documentation and software tools () for manipulation are available. README.md: 

Not a full answer but just some thoughts: Low power WiFi solutions such as nodeMCU or ParticleIO could be used to handle a few sensors (e.g. per room or so) and send the data to a central control unit (e.g. a Pi). 

$URL$ and the current spec of SMBUS (Version 3) makes no mention that it comprises more than two signals - SMBCLK and SMBDAT on layer 1. These are the data (SDA) and clock (SCL) lines of the underlying I2C bus (just as joan's answer puts it). Based on this I do not see why the software package on top of this should include anything else. I take it that you would need to do the communication with this particular device by yourself using one of the Pi's GPIO libraries, e.g. pigpiod. This way you can control the /LDAC input of the MCP4728 using any of the Pi's GPIO pins (check the voltage levels though). 

On a side note: the question could certainly be improved by both linking to datasheet of the respective sensors and listing their requirements in the question itself. Think of it that way: would it not be easier for people to give an appropriate answer if you provide those information in the first place? Would it not show your own effort to solve the issue? This is even more important as there are different devices out there with the same name, i.e. in the case of the BME280 it is possible to purchase the bare sensor or a sensor module (such as the one offered by Adafruit). 

I recommend installing numpy via apt-get not via pip as the latter needs to compile the lib on the Pi and that is no fun. Not sure about pandas but I would expect something similar. So use: 

You cannot (re-)assign any of the special functions, so they are given as outlined in the official schematics. As for the "general purpose" functionality of the GPIO-pins, well, that's for you to decide in software. Simply pick those that fit your needs, i.e. with respect to their location on the header (not the header file but the connector this time), and then stick with it. Whether this configuration is done in header or config files is simply a matter of taste. If your coding a language with header files those configurations could be put there; if you need them user changeable (from your description it would seem that you'd rather not) you could also put them in separate config files. I'll take the Foundations schematics as the authoritative source with respect to the function of the GPIO pins available at J8. These are 28 general purpose pins. Of those only two are reserved (ID_SD and ID_SC) which are used for the ID EEPROM scheme of HATs. So that leaves you with 26 GPIO pins, some carry a secondary function (alternate functions such as I2C) but if that is not used, one is free to use the pin. 

What's the root cause of the USB disconnect and how to circumvent or prevent it? Why is eth0 not coming up again and what to do about it? 

You are right that the RaspberryPi does provide only two chip selects at its SPI bus (see here). And I assume that the SPI drivers and software solutions rely on that fact (although @joan's answer suggests that different libraries handle it differently and the official driver will allow arbitrary GPIO pins to be used as chip selects in the future). You have however to keep in mind that a chip select is nothing more than a dedicated digital output of the Pi. Therefore you can always have a larger amount of chip selects if you use the GPIO pins. In which case however your software will be responsible to set the appropriate pins to address the right SPI slave. Since the whole idea of chip selects is to mutually exclusively select just one single slave you can furthermore use some simple digital circuitry to decrease the amount of "wasted" GPIO pins (if you need them for other purposes too). Something like the 74HC/HCT138 a 3-to-8 line decoder/demultiplexer could be used to address 8 slaves via 8 chip selects with just 3 GPIO pins. It's noteworthy to keep in mind that the bus lines SCLK and MOSI are shared amongst all slaves. So when plugging multiple slaves to the Pi make sure that the fan-out of the Pi is not exceeded by the load (resistance and capacitance of the input pins of the slaves) - although this is less of a problem today with the low capacitance and high resistance of digital inputs. 

Buffering of digital inputs/outputs by buffer ICs (e.g. the SN74HC244N) could offer a certain level of protection at reasonable cost. It however might limit your future design choices as the direction of the pin (input or output) will be fixed according to the wiring. Bidirectional voltage level translator (e.g. the TXS0108E) will overcome this limitation and needs no Direction-Control signal. Since all those solution do not offer galvanic isolation they can offer only limited protection. Things as mains level voltages or even relays driven without appropriate drivers and fly-back diodes might kill the buffer and the Pi too. However, "always" protection and being flexible in the use of the GPIO pins is most likely more expensive than the Pi itself (just as joan's comment suggested). The buffers will protect from thing that are somewhat likely to happen though: "minor" over-voltage (e.g. connecting to 5V) and ESD issues to a certain degree. Here are some projects/products that employ buffering: 

You can use your Raspberry Pi with different SD cards and thus different Operating Systems in turns. Obviously you will have to power down the Pi and physically change the SD card first but other than that there is no problem with this approach. The only possible issue is the wear of the contacts of the SD card and the card slot on the Pi, i.e. the number of mating cycles. Unfortunately it is hard to tell without knowing the model of the card slot on the Pi. Some vendors of such microSD Memory Card Connectors report guaranteed mating cycles of 5,000 to 10,000 (to give a ball-park number here). For the old models of the Pi that used a standard SD card (not microSD, like the Pi3 and the PiZero) issues with the card connector have been reported - but the microSD connectors seem to be more reliable. Bottom line: you're most likely fine to repeatedly change the microSD card to switch your OS. 

Yes. Forced convection will improve cooling over natural convection. Especially if the latter is inhibited to a certain degree by the case. It is definitely worth a try even though it would of course work "better" with a heat sink due to the significantly increase surface area (after all that is the idea of a heat sink). 

Mopidy with extensions allows you to stream from cloud services such as Spotify (and others as well as local files obviously). Packages should be available for Raspian including dependencies, but other than that it can be installed from source and is running on python2.7 (see here). I take it that the developers are aware that libspotify is officially deprecated but worry not too much as it still works for now (see here). They seem to expect spotify to come up with a solution due to its use in numerous hardware platforms. 

Well I'll go with an open mind, the joy of learning new things, and a certain amount of stubbornness to overcome obstacles that will arise. Luckily there are plenty of resources to get you started: 

Disclaimer: I am not using any HiFiBerry boards as of now, so this answer is based on the available documentation only. 

(call or for continous monitoring) is the utility to handle HDMI status signals, such as HDMI cable unplugged. With my setup - Pi2B and Samsung TV - there is a change of status for unplugging the HDMI cable and turning on the TV from stand-by. However there's no change detected during switching channels (e.g. from the HDMI channel the Pi is connected to something else) or turning off the TV set. Thus kodi cannot know to stop playback. Rumor on the internet however has it that different brands/models of TV set might use HDMI-CEC differently. Check the behaviour using . 

Credits for the Howto go to Antonio Borneo (see link above). Note that this question could also be asked at Unix.SE as it is not entirely RaspberryPi specific. 

open remote control find push buttons and figure out how they are connected (most likely via a pull up/down resistor to GND or VCC) connect your own switch (transistor) in parallel to the push buttons wire those parallel switches to the RPi