Another benefit of working with iterators rather than array indexes is that this solution also works with other collection types, not just strings or similar array backed structures. In this case, I e.g. only used the properties of an which makes the very same algorithm applicable to a wide range of data structures, including not only , or , but if required even input streams and alike. If you like to, you can try to rewrite the solution so that instead of expecting for to be passed as a string, it just accepts an arbitrary pair of iterators replacing and . These may e.g. be obtained from or an open file handle. Have a look at the documentation of for that. 

In terms of code style only one remark, and that is on the location of the when working with pointer types. I know, placing it next to the type feels more natural, but it's semantically inaccurate, and it will trip you the first time you attempt to declare multiple variables at once. Placing it where there compiler would sort it helps preventing these mistakes. 

More curly braces and indentation please. The syntax with multiple directives on the same indentation level should IMHO only be used when the declared disposables are independent. If they are dependent, they can no longer have the same life time, and that should be reflected by the code structure: 

3. Sample usage Here's some sample usage to show how a user can get the return values. Basically, the user would send in their function/functor to the dispatcher and would take care of the rest; the dispatcher would return the from its submit-a-function function. 3.1. Example 1 This example is pretty much just a test of the template deduction rules and shows how you can use a collection to erase types. The main feature is that you can have a collection of functions that all have different signatures and return types. 

What this means is that when the comparison fails, E is updated to the current value of X. If the comparison succeeds, X is updated with the value of N. Therefore, you don't need to update X again! That is the whole point of a compare/exchange operation; you're basically saying: "I was the last to modify X." Issue #1: Unsynchronized access to writer In your code, you perform a store to the atomic variable with a copy of a value you last obtained from the update performed in the compare/exchange operation, but this is not atomic. 

Consider what happens if returns value A, but before the expression is evaluated, is changed to some other value B. This could cause to say that the queue is empty when it isn't or that it isn't when it actually is. Conclusion These are two of many issues that are currently in your code. I've decided to stop here since that's a pretty bad problem. This current implementation if not safe at all. I recommend you do some more reading and learning about thread interaction. Good luck. 

I also couldn't help but notice that you defined X/Y pairs multiple times, which always resulted in copying the X and Y components individually between different structs. Define something such as a "position" once, and then just reuse / nest the struct definition. E.g. 

Eh, nope. Looks like you actually managed to bake the game state and logic into the class which was only supposed to be responsible for presentation. Well, at least that means the setup of the game state is still in a single location? 

Fetching X and Y coordinates from different vectors is somewhat weird. You should try to group data which is accessed in the same context, rather than attempting to sort it by type. E.g. 

This function is simply wrong, for multiple reasons. Let's step through them one by one: The return statement is sometimes unreachable Check your indentation. Currently the return statement is only reachable if . Numbers >=1,000 and <100,000 do exist Your forgot to handle the case when the number doesn't contain the term "hundred". The same issue exists with numbers >= 1,000,000 and <100,000,000. Writing the same code 3x in a row, with the same mistakes You are using different constants, but the logic is mostly identical. The copy & paste is pretty obvious. And it had exactly the effect you would expect: You copied the mistakes as well. This would have been easily solved by extracting the common parts of the logic properly. 0 is a number While you don't say "zero hundred" or "zero thousand", "zero" alone is a valid number and should be supported properly. 

Why have you decided that the default size should be 100? Different people have different needs; having default values like this isn't a good idea because there is no true advantage to having a default size of 100. While this is subjective, I suggest you remove that default size and just have users be required to specify the size that they want. Compare/exchange confusion There seems to be a misunderstanding in regards to the use of compare/exchange. The compare/exchange operations work as follows: 

Basic algorithm Since you have very large files, you should consider streaming the file one line at a time instead of loading them all once; your program would use a lot less memory. You would also not have to copy your , which is very large! In order to know which files you've already processed, you could create a new file that holds a list of all the files you've processed and write to it as you stream from the original file. This is of course, assuming you want to keep the original file intact. I will continue under this assumption as the other case (simply delete from the list as items are processed) is simpler. Check the Notes section for a better idea that you can implement with inspiration from the following section. Implementation The following is a sample implementation for the algorithm I described in the previous section. For brevity's sake, I did not include the items mentioned under the Form section, nor did I include exception checking; I will leave those things for you to figure out. It is also most likely not as optimal as it should be, but it's merely meant to show you streaming. Sample 

I'll let it to your exercise to decide on the visibility of these attributes, and to add a constructor. And the class then correspondingly holds a collection of products instead: 

This also goes for return types and method parameters. You should never require a specific type, if other implementations of the used interface work perfectly well either. 

Note: Appears to work only with CLANG and gcc. Visual Studio e.g. fails to handle correctly. Obviously the preprocessor output isn't even remotely that nicely formatted, so good luck debugging that! 

Even generating the last few names (before there are absolutely none left) will lead to a major performance problem. But not just that, worst case, even a faulty random number generator can break this miserably, if it doesn't guarantee that every number in the range is even possible to be generated as part of the current sequence. Which, as far as I'm ware of, isn't necessarily the case. That means, even if you did reset the name pool after exceeding a certain number of unique names, there is no guarantee that the RNG even allows you to hit the upper border, so you might get caught in an endless retry loop much earlier than expect. Plus, with over half a million elements top, that is easily going in the range of a few hundred MB of RAM. 

You can expand on this by providing functions that use the "Error hiding pattern". That is that they return a to indicate whether the input operation succeeded or not, while the result is stored in a reference parameter. Other isn't the only object that can be streamed from. For example, you can also stream from files. You should provide a way for users of your function to specify what they want to stream from (this can be as simple as having a parameter. 

1. Description 1.1. Functionality The objective of these types is to provide type erasure for any function while maintaining the ability to provide a return value through a combination of and its associated . 1.2. Motivation This is useful for any sort of dispatch manager, a thread pool that you can submit tasks to being the actual target; where a task is any function with any parameters and return type. 2. Implementation 2.1. deferred_invoker.h This is the main functionality. Type erasure is provided through the base class, which simply has a virtual member function that is called when the function has to be invoked. The specializations will then know how to deal with the invocation and whether they have to save a result. They also take care of ensuring the correct initialization arguments required for the call are initialized and saved in a tuple. This applies for template parameter which is any function. A simple tag dispatch system takes care of return types. I've omitted a third implementation of for lambda and functor types to focus the review. It's basically the same style as the other two (possible design issue?), but it takes a copy of the lambda/functor and the arguments, instead of a pointer to the function. 

Not quite. You should probably be familiar by now with the concept of splitting your source code into header and source files. With headers containing structural information, and source files containing implementations. In this case, they class definition should have gone into a file called and the implementation of the class would have belonged into . If take a look back at the section about the global variable , it should strike why that was a mistake. 

Speaking of disabling fields. Why did you use the attribute? The requirement only speaks of making the result field read only, and the attribute which does that is named . Disabling the input fields prevents, according to specification and in most browsers, all interaction with the input fields, including the ability to select or copy text. 

The only exception to that is the part below 1,000 which has no suffix. However, a missing suffix can simply be approximated by an empty suffix instead. So the logic approach is to write yourself a helper function which correctly formats every number from 0 to 999, because that is the range you need commonly. Your next realization should be that it is easier to start constructing a number from the LSB, than from the MSB, since you then only ever need one set of constant numbers to extract the relevant part of the number. Once you have that function, can be written much clearer: 

3.2. Example 2 This example displays a more "real-world" use. Instead of having the function call , that would be done by threads consuming from the data member. Since this is an example, I've provided a simple function that works only for free functions; overloads can easily be added to deal with functors and member functions. 

Imagine a first call to in thread A makes it inside the statement and gets stalled just before executing . Now another thread B calls and successfully gets past ; the writer now has a value different than reader because of the compare/exchange operation. However, the store of an element has not happened yet since thread A is still stalled. What is thread B going to pop? It's going to access whatever garbage memory is at that location. Issue #2: Malfunctioning empty function The load from and the load from followed by a comparison is not thread safe. 

To indicate that the first three files have been processed. You would then only have to check the first character of every line you read, instead of the whole file name, to know which files have been processed. This is the technique I would personally use, as it doesn't require an extra file and it keeps the original file mostly intact while providing a much faster comparison. 

Your handling of invalid inputs is plain wrong. While you did right to disable the calculation as soon as an input becomes invalid, you totally messed up the logic to re-enable the calculations. Test it yourself, enter something invalid into both input fields, fix up only one, and the buttons become re-enabled despite the other field still containing garbage. The problem is wrong use of the . Whether the buttons are disabled or not, is actually a function of whether input a and input b are valid. Whether they are valid or not individually belongs into the state - however the computed result of that combination does not! If you had computed the state of the buttons from the state of the inputs in the method, this problem wouldn't have occurred. 

Disabling the inputs without any good reason is providing a bad user experience. The point about using the react framework is, that you can recompute all results (in this case the result field) from the state gathered. So why force the user to discard that state? Just continue updating the state as the user continues providing input. What you should have added, but didn't, is a visual feedback which operation is currently active. Trivial, if you had recorded the chosen operation in the state. 

Even worse - what you just implemented yourself can have unitended side effects if the row object has additional properties with special meaning, which coincidentally collide with (not actually ignored) keys in the passed data. So your logic can be written more compact and less error prone once again: 

I've actually implemented the same functionality in the past, so here are my comments. Wrong behaviour? It depends on what you can consider wrong. Consider running your own example and inputting . The 2nd will be left in the stream buffer and will be automatically assigned to your 2nd variable. This clearly causes weird behaviour, but it is the same behaviour that occurs when normally using . Suggestions The following are what I consider to be useful features for such an utility function. Better interface In order to provide a nicer interface, you could instead read a single value from your stream and then discard anything else that's been left in the stream buffer; calls to will always return one single value and successive calls won't be forced to take what's left in the stream buffer. Example 

2.2. function_traits.h These are simple template class specializations that provide the required function traits for the implementation of . I realize that specializations for and functions are required. 

Notes A faster way to check if a file has been processed would be to add a character indicating that it has been processed, for example: 

Welcome to Code Review. This queue implementation is not truly concurrent-ready. Arbitrary initial capacity 

Specialization for special types You can also provide a way to read whole lines through template specialization or through a different function, since it would be useful for strings (reading a phrase, for example). More functionality You can provide a way to obtain values based on a predicate. So that it can be a lot easier for people to get valid values. For example, I want to get easy input of an integer that is between 0 and 10 from an user. Example