Raknet has an abstraction for a Lobby system (friends, rooms, emails, ranking) with different backends. You can choose between your own PC Lobby server backend (the "simple poor man's version" as you called it), or use their implementations for services like XBox Live, Steam, Games for Windows Live, in case you find out later you are allowed to publish on those services. For more details search for "Lobby" in the manual Even though Raknet is written in C++, there is a C# integration using Swig coming with Raknet 4 RakNet 4 is free for the PC, Mac, iPhone, gPhone or Linux for qualified Indy developers. 

Mutliply the translation matrix with the rotation matrix, not the other way around. You dont need to multiply with the identity matrix at all, that has no effect, it is like multiplying any number with 1, it wont change the number and the matrix. 

Above you see both, the identity quaternion and its negated quaternion. The first 3 numbers (axis, x, y, z -> the imaginary part) can be interpreted as the rotation axis. The acos of the 4th number (w) multiplied by 2 is the angle of rotation. Since the rotation axis is basically zero, there is no rotation at all, no matter how big the actual angle is. So both are the same, no rotation change at all. Another example of a unit-quaternion and its negated quaternion: 

Edit new answer: Ok this shows you how to calculate the rotation-matrix that rotates the triangle from its local space into world-space. Given (the normal of the triangle in object-space) and (the normal of the triangle in world-space) 

Thats one way, very expensive though, since you have to transform all the vertices of all the objects in question. Doing it the other way around is much cheaper. Transform the ray with the inverse object's matrix into the local object space and make the ray test in that space. Usually transforming the ray is way easier than transforming all your vertices. Its even cheaper, if you use Bounding Objects (Aabb Axis-Aligned-Bounding-Boxes, Obb - Oriented Bounding Boxes, Bounding Sphere etc) for a first Hit Test. If that succeeds, do the actual Object Hit Test. 

Yes, your code has a Gimbal Lock problem, since you use Euler Angles. There is a lot of myth out there about Gimbal Locks and how to prevent them. You can also have Gimbal Locks using quaternions, if you use them the way you do. The key is not to store the rotation around each axis separately and not to apply one after another, your code does it here: 

The solution is not to use Euler Angles. and are Euler Angles. Rather store them as matrices or quaternions, basically any representation of orientation/rotation will do, except Euler Angles. Also this code does not do what you want, you can't just add Euler-Angles to combine 2 rotations: 

Now if you want to shoot a bullet in the direction the character is facing, just use the 3rd row (the Forward Vector), scale it by the start-distance from the character and add that to the character's position: 

Debugging - analyzing crash dumps and learn the language of your CPU and how it communicates with other components of the system Profiling - not much to say here, here you really learn about your code and that there are so many wrong assumtions about code that can become critical Shipping Mentality - think in "Shipping Solutions" rather than "Great and perfect Designs" 

The multidimensional generalization of a triangle is an N-Simplex, here is a video of a projection of such an object. Here is another interesting video of a 4D hypercube. This wiki page is a good starting point if you want to learn more about the fourth dimension and how to visualize such objects. It also links a wiki page with a list of 4D games. Regarding your question about the projection: This paper explains the math of orthographic and perspective projection matrices for higher dimensions. Another great paper is Four-Space Visualization of 4D Objects by Steven Richard Hollasch. Particularly the paragraph "4.1: High-Level Overview of 4D to 2D Projection" answers your projection question in detail and comes with source code. Finally here is an N-dimensional renderer using OpenGL coming with full source code. 

Calculate the rotation axis by taking the cross product of your avatar's unit forward vector and the unit vector from avatar to target, the new forward vector: 

I strongly recommend not to put a layer of abstraction between your application and the math-lib, neither high level factories nor inheritance for different platforms, nor delegation nor similar patterns. You want your vector math code as optimized as possible. Unfortunetely layers of abstraction that make your design more user-friendly, have massive performance impacts, especially in low level code such as math libraries. So what can you do? Either use those libraries that do all the dirty work for you like: multi platform implementation, passing vectors via registers rather than the stack if possible, etc: 

So far VC8 and STLPort 5.2 tested, here is the comparison (included in test: string, vector, deque, list, map) 

Create a rotation matrix from Yaw/Pitch and Roll Multiply your local direction vector (z-axis) by that matrix and multiply the resulting vector by speed, that is the translation Add that translation vector to your current position 

LOOK_UP and LOOK_DOWN must rotate around the x-axis, not around the y-axis. ROTATE_RIGHT and ROTATE_LEFT must rotate around the y-axis, not around the x-axis. Immediately rotating around 90 degrees or initializing your angles with 90 degrees will bring your system into a Gimbal Lock state, resulting in weird rotations. You might want to use smaller angles and step-sizes for starters, particulary not 90 degrees or multiples of it. Initialize all angles with 0 and start from there: 

Look at the benchmark demo in the bullet installation folder: . I just checked benchmark 4, it creates 960 bodies and collides them, you can adjust the numbers in the demo of course. All timings and statistics are rendered on the screen in the demo, answering all your questions. Just run a quick test using that demo on my machine: 400 bodies colliding with less than 6ms per simulation call, change this function in BenchmarkDemo.cpp to get 400 bodies: 

Now whenever the mouse is changed, multiply m_orientation with the orientation change coming from the mouse movement each frame. 

If you just want to reuse your code without recompiling, there is another option, static libraries (.lib). It is precompiled code (as in the DLL) but it is linked into your application and has no such limitations as the ones mentioned above, plus Link Time Code Generation still works with the library code. 

Hey Olhovsky, nice challenging question. I know your pain, I implemented Deferred Shading, Inferred Lighting and shadows in my last job. It was really great fun, but lots of pain too when it didn't work as expected. I think the advice with PIX is actually a good one. You don't have to mess with the assembler instructions of the shader, but you can look at the shadow maps and other render targets, select a pixel and call its pixel shader and step through it and also its vertex-shader. General debug tricks for this kind of situations include simplification of the scene. One that comes to my mind is: put the camera at the same position as the light source with the same fovy and other attributes as in the lighting pass. Now you can easily compare the values in the pixel-shader. The pixel-xy in the normal render-pass for your current object should be the same as the calculated pixel-xy for the lookup in the shadowmap, as long as it has the same resolution. Another one is switch to orthographic projection, render something easy, predictable and checkable. The simpler the better you can check each calculation step. Other than that, can you show how you create the matrix that calculates the position in the shadow-map for the current pixel, that is the transformation from screen-space to light-space? 

There is a wrong assumption behind this question which leads to a solution that is not well prepared for real world requirements. Don't ever count on a consistently stable frame time X, unless you are on a Real Time Operating System. The usual gaming platforms don't fall under this category. On all other systems the frame time is not deterministic (even if your update loop were deterministic, which it isn't either), it depends on variables that the game cannot control, the OS scheduler for one thing, other processes can kick in, energy saving settings and lots of other things. Having that out of our way, the first and most important conclusion is: The game has to deal with a varying frame time. It might be 16 ms in one frame, and 27 ms in the next. The update loop simply has to deal with it. That rules out the fixed value in your code example. So what is the solution? Basically there is only one relyable and reasonable source of game time, the refresh rate of the graphics device. It does not make sense to update the game state with a higher frequency than the graphics card can render it. In fact that would introduce new problems without any reasonable gain. However, it makes sense to update some subsystems with a higher frequency, as a physics engine for instance needs a stable simulation time. Most physics engines handle this theirselves by adding sub-steps/sub-loops, for instances bullets btDynamicsWorld::stepSimulation(btScalar timeStep,int maxSubSteps, btScalar fixedTimeStep) needs only be called once in your game loop and handles the necessary substeps itsself. The first parameter is the real dt since the last frame. The third parameter is the fixed simulation time, so it will step the simulation by adding substeps of until it hits the real frame time () and even interpolates the physics state to the exact frame time. So that dirty work is off your shoulder unless you implement your own physics system. So at the end it is much simpler and does not need any timers at all, except vsync to wait for the graphics cards swapping. Other than that, just measure the time since the last swap, that is the frame time to be passed to the game's subsystems. 

The normal for this triangle is or depending on your definition of a front face, clockwise or counterclockwise. 

Here is the implementation in C++ that takes care of those edge cases. Converting it to C# should be easy. 

A simpler solution might be to use an easing function to make the object follow the jittering target-position smoother. 

Ignore the Database and even the GUI at the beginning. Make the basic game-play work first. Just one session without saving/loading. That is hard enough at the beginning. You will find yourself changing the actual data during development a lot. So if you maintain the loading/saving code for such frequently changing data, then you will find yourself 90% of your time maintaining that code, instead of making a fun game. Take shortcuts on your way (use keyboard input instead of a GUI, create sample data on startup instead of saving/loading), don't go for the full blown game right from the beginning. This will keep you motivated because you actually have a game there and not only a database front-end. 

If you need a calculation in object space for any reason, just multiply by the object's inverse transformation to find positions and orientations relative to that object. This makes the position and orientation of that reference object zero and identity. All object's positions and orientations will be relative to this reference object. To calculate the relative velocities, just subtract the velocity of the reference object from the velocities of the other objects, to get their relative velocities, which again makes the velocity of your reference object zero, regardless of its world velocity. 

There are more than one ways to do it. You can calculate the absolute orientation or the rotation relative to your avatar, that means your new orientation = avatarOrientation * q. Here is the latter one: 

That is why you see a makro infront of class declarations in DLL headers. Resources like FILE* pointers can not be shared under all circumstances (different CRTs) between DLLs. That means if you open the file in one DLL, you cannot write to it from the client app or another DLL, nor close it. $URL$ Memory management: You cannot allocate memory in the DLL and free it in another DLL or in client application under all circumstances (different CRTs). Exporting template classes can be a real pain, especially if they use static member variables.