I don't know if you have noticed the inconsistency. All units and tens are in title case, while the names of large number are in lower case. Consider making them all lower case. 

The switch part can be moved out of the loop, as the doesn't change during the loop. This can save us from some string comparisons. 

Loop The condition will be evaluated every cycle. You do not need to on each of the loop. The result can be cached : 

As you already noticed, all the methods have the same repeating pattern. We can extract this pattern and encapsulate it in a method for reuse : 

As you have already noticed, all 4 spawners' implementation are quite repetitive, namely the waiting part. However, each obstacle has its own spawn rotation and position. So, we will have to extract the former while isolating the latter : 

Consider switch the order of your parameter. is the key generic parameter in both method, yet its definition is unclear until the 2nd parameter is passed or unless you specify in or . By keep it on the 2nd place, you penalize yourself by not taking advantage of intellisense : 

Same goes with quotes. You have single-quoted and double-quotes strings everywhere! Just pick 1 style and use it! (My recommendation goes to single-quotes.) 

You aren't validating your images properly! This allows me to send you an image file with a webshell. Something like this: 

Notice that you have to use instead if you are using this in JSON! As I refered earlier, I would review it as an object. 

I'll end the Javascript review here, since it is already too lengthy. Notice that I didn't made any attempt on making the changes incremental. I took right from the original code and showed you with the changes. All these changes are left as an exercise to the O.P.. 

The method name should be . Boolean methods begin with , like if you were asking a question. Since you are 'asking' if a directory has some defined attributes, you should reflect this in your method name. Based on your current name, I wouldn't expect it to return if it had a file there. One example of this is the method . You have another example on the following line: 

Some symbolic constants are included in header files such as in . BUFSIZ might be a good constant to use in the calls to since it is a system defined buffer size. Symbolic constants are good because it allows the code to be changed in only one place when array sizes need to be changed. Quite often array sizes are also loop constants so it really helps to have only one place to edit the code. It is also good because it tells anyone reading the code what the number should be used for. In some cases it might be possible to use enum types as sumbolic constants as well: 

First, Welcome to code review, and a very nice question for a beginning self learner in C++. user1118321 is correct about a everything he says, I'm going to emphasis one or two items and provide some references before I mention a few other things. Use Functions: Functions allow one to break up their code into smaller, easier to understand logical blocks. When designing software it is often easier to break a complex problem into smaller problems that are easier to program. Some people use flow charts to map out their program, and high level flow charts will only contain the functions. These will be followed by lower level flow charts that map out the logic of each function. Using functions allows one to decrease the amount of code written in some cases. The function should be primarily used to set up the environment for the rest of the program, call a function to execute the rest of the program and catch any errors. If you find yourself repeating code move that code to a function so it only needs to be written and debugged once. This is actually a programming principle generally referred to as Don't Repeat Yourself and you may see it referred to here on code review as DRY. Both functions and classes should follow the Single Responsibility Principle (SRP). The Single Responsibility Principle is that a function should do one thing, and one thing only. This makes code easier to write, debug and maintain. It also makes the function easier to reuse. The Single Responsibility Principle may also be a reference to Demeter's Law (I may be wrong about them being the same principle). Another programming principle sometimes mentioned is Keep It Simple (KISS), although this isn't just for programming. You may want to look into SOLID programming as well. A more comprehensive list of programming principles can be found here. Use Existing Classes A long time ago when I started using C++ the Standard Template Library (STL), sometimes called the Standard Library, had not yet been defined or implemented. We had to create our own strings, queues, vectors, stacks and other container classes. Using the C++ container classes and the standard library requires A Lot Less Code and makes it much simpler to write correct software. Two great website to become familar with if you are going to write C++ code are CPlusPlus and the C++ reference. These websites are better than using a book as a reference because it remains up to date, and documents the C++11, C++14 and C++17 standards all in one place. The string container class provides one with much more functionality then cstrings. The follow is new content not previously mentioned. Magic Numbers The term is sometimes used for numeric constants in code that are not obvious. By I mean that it's not obvious what the number represents. Non-symbolic references to numbers should be replaced either by named constants, or enums (enumerator types). An example of a named constant is: 

While you're doing right in using (the equivalent of) , you are forgetting that can be called, breaking your code. My suggestion is to use something like this: 

This code was written purely for fun, but that's not an excuse to write it poorly. Still, I feel that there's something to improve on it. Besides of any performance issue that there might be, and some readability crimes, what else can I improve in this code? 

Why the double ? You only need 1 and it is outside that , since both return the same and there's no more code. Library misuse: You repeat 4 times! You can chain everything and it will work. That's what jQuery is for! Please, chain them. Duplicated event handling. You have this: 

Why do you have a at the end? As soon as the script finishes, it will just exit. No need to have the there. 

What's wrong? The names! implies some actual text, but you have a . is alright, but it is actually . And that is a . I propose the following rewrite: 

Personally I prefer the C# 6 collection initializer the most, second by the method shown in first snippet, and lastly the older initializer. 

Throw an exception on negative numbers. This is covered in last section. Change the parameter to . Do a custom routine for negative numbers : 

Do not use Hungarian notation for constants, keep it in PascalCase. If you like to differentiate the names from the properties you can name in form of , like . Do prefer .net aliases over the full type name, like -> , -> . Avoid repetition of word, like and . Unless you are worried about mixed up with the foreign key in your DTO, but it is not the case here. (if it is , that is fine)(you weren't really consistent with the code) should be renamed to : 

Your solution is very limited. As it only take a string in in the following format , and apply to the function . To build an expressional calculator, you need to go through these steps : 

Whenever code is written future expansion of the program/function must be considered. In the function above there is the code : 

Welcome to Code Review, a very nice first question. I commend you for the ability to be able to debug rather complex code. Just a few observations to help out: Bug in the Code Since the while(1) never exits, the call to close is never executed, since it is outside the while(1) loop. There doesn't seem to be a signal handler that catches the kill signal and closes the socket. Use Space to Enhance Readability The readability of the code might be improved if there were spaces between the operators and the operands in all mathematical expressions. Vertical space can also make the code more readable and easier to maintain. Existing Code: 

Good naming of variables and constants. DRY Code Applying the DRY coding principle or Don't Repeat Yourself principle would greatly reduce the amount of code that this program has. There are two very obvious candidates for functions in this program that would decrease the length of this program by at least 20 lines. Reducing the amount of code will make it easier to maintain and reduce the amount of debugging that might be necessary. There is a candidate for a loop as well. The first candidate for a function is this code: 

This will have the exact structure you wish. Simply use to access all values. And done! An alternative with 0 lines of code! 

This won't be a very in-depth review since I don't know angular.js, and I will focus only on some superficial issues. 

Have you considered an array? You can then create multiple objects, having each object the values per point. Like this: 

This part can also be used for the block. But a major concerning area is that regular expression. It is made to match newlines, the first and a space and . Here's my proposal: 

And to improve performance, you don't need the . It's a waste of time and CPU power. Also, why instead of ? And why not an array with these objects? I would rewrite the whole thing as this: 

Also, notice that when you use on an event handler, jQuery runs and . Depending on what you are trying to do, you should be careful when returning anything in an event handler. 

The method has been renamed to reflect more what it actually performs, and the return type has been changed to , since we only need to know if the file contains the search text. 

RLE Formatting If we were to explain it in english, the sequence is joined by a space() where repeated elements a denoted in the format of . If we were to code it in C#, it is not much different: 

There is various overloads of to accommodate different needs, like the one suggested by @t3chb0t. Feels free to add more, if it help you to keep the declarations as clean as possible. And, the rest of the code: 

I don't understand, why you have 4 different classes with the same properties and copy-pasta comments, and, most importantly, shareing the same role of obstacle. Combine them into a single class, subclass if you had to keep the class name for distinction : 

I'm going to assume the document is composed of hierarchical elements. If that is case, copying and merging the bytes array could get very costly, more as we get closer to the root element. Since you mentionned that you're working with a "very specific binary representation" and writing to a "stream", it would be best to write directly on the stream, rather than copying and merging the bytes, and holding them around. 

What, in the name of the Lord, is going on here? Why are you fetching an object instead of an associative array? What does do? Why is it called ? What is for? What's in it? 

Created a few variables at the top, with needed information. Created a loop to go through all the elements Reduced the number of local variable to the bare minimum Removed global variables being declared inside the function 

As pointed out before, in a comment, non-magic methods in a class shouldn't be prefixed with . Since they are private, they are prefixed with . 

Since the length is 1-based and the indexes are 0-based and returns numbers between 0 and 1 (excluding the 1), you don't need more than this. And now, the You have the following code: 

And with this, I conclude my review. As I said before: the code is hard to read, follow and is very brittle. Object handling is it's weakness. 

Notice something? The use of jQuery just to retrieve the value of an . Just remove the jQuery from there! has the same effect at a WAY HIGHER speed, without ANY bloat. You have it right a few lines below, and I give you credit for that. 

While this is primarily targeted at classes in object oriented languages it applies to functions and subroutines in procedural languages like C as well. The my_malloc function could be broken up into at least 3 functions to simplify development and maintenance. This is also true of my_free(). 

Please note in the previous I cast the result of pow function to int, my compiler gave me a warning message on that line. Possible Optimizations Rather than reading the input file character by character input large chunks of data (file block size perferably) into a large buffer internal to the program and process the buffer instead. Each time fgetc is called it is making a system call which is expensive(time consuming). Having an input buffer and processing it may help reduce the complexity of the code as well. For the same reason, create a string output buffer and write it to the file all at once rather than repeatedly calling fprintf(). Using pointers rather than array indexes may also improve performance. 

Knowing it is a rather large script, I've tried to split it into multiple functions, to make it easier to understand, read and maintain in the future. You can see the complete instruction list on $URL$ As far as I know and tested, this is working as it should. All it's functionalities function as intended and there seem to be no obvious errors. Regarding readability, error handling and readability, is there anything else I can improve? 

Remove . It's useless there. Change the id to Give the class to the . The is the one that will control the width of your . It makes sense to set it this way. Closing in the same line Since you are using jQuery, later on you may want to use the pseudo-selector , which won't work if you have newlines in it. 

This function should do 1 thing and do it well, not a bunch of them and doing it ok-ish. The already-mentioned readability Variable names should be descriptive. Example of variables you have: