As mentioned in a comment of mine, it's possible that there's a bug in the code. The call should always sort on a single value, . The call should be equal to because the method does not filter values. That being said, I'll consider it as from here on out. If this is not the case let me know and I'll delete this answer. I see that you count likes and dislikes a couple of times in your queries, in the method and in the and properties in the final . Keeping in mind this consideration I'd change the query in the following: 

Get the type of info the input string represents. Already taken care of. Keep track of the different punctuation characters in the different input types. For example: and for dates, for acronyms, and so on. Write a method that splits and merges again a string on a certain . Something on the lines of . Once you split the original string by the splitting char you just trim its components (remove the starting and ending spaces). Call the method in the various cases. In the acronym's case (picked this one because it has only one splitting character) the call will be something like the following: . In the case of dates you have to call it twice, once per punctuation character. In the case of phrases you have to call it more times (you have multiple splitting punctuation characters: , , , , and so on). Final step. Remove possible double spaces (just replace with and you should be good to go). 

As a side note: I'd use anyway, even if performance does not improve much on small numbers, but this can be seen as a personal preference. 

Without even looking at how the code works, I see some serious readability issues here, among which: To or not to Be consistent on your coding choices. For example, sometimes you choose to put brackets even for single-instruction-body s and sometimes you don't. Make a choice on which style you're adopting (personally I'd suggest to put even for single-instruction-body s) and stick to it. Naming Avoid single letter variables/fields. Give them a meaningful name. Methods should have meaningful names also. What does do? Indentation The same as the first point. Be consistent in it. 

Otherwise, nX and next should be private data, with getters to read the values and setters to validate and set the values. Line (3) is a bad implementation for a constructor, because it leaves a new instance in a partially-initialized state (it should initialize nX, next and head, explicitly and in this specific order). Better implementation: 

Normally, you should use the most specialized type for a job. In , and should be declared as . uses a big, monolythic switch. Consider replacing it with a dispatch map (extract cases into separate functions, then create a to map these functions to separate inputs). You should not have the entire code in a single file. Instead, you should have each class in a pair of files (.h for the declaration and .cpp for the definition). This would allow you to remove the huge separation blocks. Old code: 

This will allow you to test the code with predefined inputs (see std::istringstream). If you can avoid having global variables, you probably should. That means, declare , , and globals in the functions that use them. You should also have comprehensible names for your variables. You should not use C-style casts in C++. Criteria: 

All these can be avoided by not returning a raw pointer from your class. Consider returning a instead, and using other means to edit or set the buffer, than this API. You say: 

Regarding the second way of optimizing (what your question seems to be actually about) you have the following steps yet do to: 

That said, you should only need one retrieval of the size in this function, and that is for preallocating the result (so you need no len variable at all): 

Note: The algorithm is not equivalent to yours, but it's the interface/client code that looks interesting, not necessarily the implementation of the functions. 

Other than these things, everything else looks fine. P.S: The code I wrote is not tested, it's there just to better explain the idea. 

Cycle conditions The main cycle has two internal paths that cause it to interrupt through the instruction. It could be better to refactor the code in order to include these conditions in the cycle's one. I mean, changing this: 

Let's take an example. If we have that and we'd need the numbers from to . We just parse to , multiply it by 10 for 3 times (length of is 2 and is 5) and return the numbers from 15000 to 15999 ( is set to 16000 which is the first value that is not allowed). In addition, if you just need an the previous method would be something like the following: 

In addition to what has been said already (and if I understood the problem correctly), I'd say that you are complicating things too much. Let's think about it (on a single prefix for now): 

Pick the element on top of . If this element is greater than or equal to the element on top of , or if is empty, push this element in . If this element is smaller than the element on top of then pop the element on top of and push it in , then go to step 2. If contains any element go to step 1. 

and then proceed as you are already doing (randomize the list and write it in a file, or whatever the case may be). Let me know if something is unclear. 

I'd go with the built-in control. Here you can find the documentation and some examples. Also, I'd suggest to use the and for the other operations. Usually, if you have to manually insert some HTML code in the page some bug is pretty sure to show up. 

It is done correctly (i.e. it does what the contract of it's API should), but not efficiently. The operator iterates twice (once in has_key and once in the operator). You can replace both calls with a call to std::find_if, and remove the has_key function completely. 

Yes (but please refer to it as "template method" - "template function" makes most c++ developers think of ). 

For size and emptyness checks, you should consider caching the list size. For iteration you should implement either iterators, or the visitor pattern, or both. Code Style 

The function as it is, depends on the client to check for errors on the stream (either by calling or by checking the stream state, after the call to ). Ideally, I would want to write: 

As a general rule, never use macrodefinitions to write code. In this code, you are better off writing the output code directly. Also, you never use err macro (so you might as well remove it). You should also refactor this code: 

That's a bad call. Ideally, you should only use the preprocessor when no other alternative exists. In this case, many many alternatives exist. 

For learning RAII/resource management, it's a good idea to write your own smart pointer class. For production code, use std::shared_ptr, std::unique_ptr, or boost smart pointers (if you have to). Here are some notes on the code itself: 

The algorithm is a shallow comparison between the documents: it is possible that one of the children of site_entries has a corresponding child in the other document (by name), but other changes are present between the two (like subnodes). Was your intention a shallow comparison algorithm, or is your implementation incomplete? That said: 

While the idea is OK, this seems to add very little over a (unordered_)map of strings to functions (created directly). The client code is almost the same as your client code anyway: 

As an alternative, you can make it an extension method of the class, and I'd suggest a rename of the method in this case: 

The first thing that pops in my mind is the naming you used. For example, from a method called I'd expect to receive a and not a string. The same from . In the method the variable should be renamed IMO as the name is not so meaningful. The same regarding . Also, commented code is only confusing. I'd remove it. In addition: 

is repeated code (the two cycles are almost the same) and could be transformed in a method. Other things seem ok. 

Regarding the complexity, like in Insertion Sort, the worst case scenario is when is sorted. Keep in mind that if you swap the items from stack to stack using the order of the items in will be the exact opposite of the order in which the same items had in . This scenario has a complexity of \$O(n^2)\$. Let me know if anything is unclear. 

There's one thing that is particularly disturbing me: the last block. That's an example of Busy waiting and that's something that should be avoided IMO. A possible solution to this problem could be to store the objects to a and once you have created all the threads you run a for each thread on such list. That being said, I'd suggest to take a look at PLINQ and TPL. One last thing: I'd remove the in the block also. I'd say that the instruction should be used only in a method. See here and here for ways to handle exception when working in an async way. 

We have a prefix indicated by a string (that has a numeric format alright, but it is a string) We have a max length, let's call it , of the numbers you can consider. The allowed length of the prefix, let's call it , should be We need all the numbers that start with the given prefix and have the given 

This separates the act of checking for vowels from defining what vowels are (which is good for maintenance; for example, you could decide you also need as a vowel, later). The function alters the value of the argument, but you do not use the resulting value, in the calling code. The function could be written like this: 

I disagree: I think the erase API of the standard containers is incomplete with regards to removing elements, and extracting such basic functionality behind an external API is the way to go. You can generalize the functionality of your APIs by: 

Create a new base, for objects connected to more than one object, that offers the same interface to client code: 

Your constructor calls swap, which receives a reference (meaning you are actually creating a copy here). Either way, you don't need to write your own swap for this class. For this constructor, consider this implementation: 

Note regarding class API design: You are implementing both a node (for an element of the list) and a list of nodes. You should have two classes instead of one, and the pointer should be a member of the list, not a node: 

I renamed the APIs you used from callback1/2 to on_data (same name) and unified the implementations of fireCallback1 and fireCallback2. 

Since the function takes a unique_ptr now, you now know you need to pass a pointer and you also know you are passing ownership as well. 

The interface doesn't indicate ownership and makes you interrupt your coding, to look at the implementation, just so you know how to write client code that doesn't leak or crash. Solutions: You could change your interface to take a instead. (Similar to passing by pointer), the only drawback is that you need to make sure the tasks you pass to ScheduleTask must still be in scope until the ThreadPool stops running (in other words, you can still write the nice function). This is better, as at least you don't need to wonder if it will delete the task (which passing by pointer may, or may not suggest). Better yet, change your interface to take a std::unique_ptr instead: 

I'd suggest doing the implementation of the various methods in the class. In this way, from the you just have to call . It's fine as long as you call the method very few times and space is critical. Otherwise I'd suggest to keep in each node a balance factor (like in AVL trees for example). 

As @Heslacher mentioned in his answer, naming should be changed into something better. I'd suggest to change: 

This seems like a method suitable for the dynamic programming method. As 200_success said in his answer, the use of memoization can greatly improve performance. What I want to add to the answer are two ways to go with solving the problem. In-time processing This is the way suggested in 200_success' answer (if I understood it correctly). Let's go at it one step at a time. We have that \$G(0) = 0\$, \$G(1) = 1\$, and \$G(n) = [G(n-1) + G(n-2)]^2\$. By caching the result of \$G(n-2)\$ and \$G(n-1)\$ we can easily calculate \$G(n)\$, so, for \$n >= 2\$ we can use the following algorithm (in pseudo-code): 

For the testing part (for which I'd appreciate some feedback also) I used the following: LogicOperationTests.cs 

One more thing that comes to mind is to switch the comparison clauses in the and properties. Note that the two versions could be the same in terms of performance, depending on the execution plan that the query optimizer generates, but personally I prefer to put the most selective comparison clause first. So, the final version would be the following: 

Looking at your code, you get the type of the generic param into the method body (which can be seen also as a violation of the Separation of Concerns principle). In order to solve the issue, you can pass the type as a parameter. The resulting code should be something like the following: 

The code is not only long, but also repetitive in some cases. These repetitions should be grouped by type and purpose (i.e. add some structures/classes to it, encapsulating data with the same purpose). That means, instead of having: 

and this will crash your program when your ThreadPool deletes the task. Another client code alternative, this one much much worse: 

Edit: here's some client code, that is possible due to the separation of the parsing and the construction: 

Now, generate reads like prose. You don't really care when you look at it that print_body is a template method (at least, you shouldn't). You can follow the steps of implementing just by one look at the code. Just think of as client code of your private APIs, and then the functions are APIs that need to "tell you what they do", in their names. Basically, I focus on what the function looks like in client code, instead of what kind of place it has in your class hierarchy (or most other technical/implementation details). Note: I didn't know what name to choose for the generate function (the "PrintReport" in your code) until I wrote an example of client code (and I thought "of course, you generate a report!" - it comes naturally off the tongue :) ). Maybe for you, "generate" will not sound natural at all. Edit (addressing question update): 

If you want two versions of the code, consider using templates (instead of conditioning the code to the macro): you will only compile once, and without imposing flags on the compiler/build system/ide. 

Actually, it is very efficient, because it uses move construction and/or ellision (returning by value shouldn't cost much - if anything, since c++11). 

You should probably also add a using directive with a local alias for and . I only focused on the safety and ease of (mis)use of the public API. Will probably post some more on the code, later.