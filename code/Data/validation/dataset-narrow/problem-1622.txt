The right hand side units are volts and amps, so for example, to light your red LED to full brightness: 

I'm sure there's a very similar question here somewhere but I'll give you a quick answer rather than digging around for it. First, beware when reading Pi related blogs, tutorials, etc. online (including questions here) to check the date, because things can change over time, as they have in this case. Unfortunately, not everyone who posts information online seems to consider this relevant, as in this case -- being mediawiki based, elinux articles require you to look through the View History tab to get the date. So this time you are mostly blameless, but that page has not been updated in almost 3 1/2 years. Anyway, is a relic of SysV init, which was used by Debian (and therefore Raspbian) up until version 8 (the current one as of about a year ago -- and note there was no Raspbian 1-6, it started at 7, the numbers follow Debian, which has been around for a few decades). The replacement for SysV init is systemd; as per bluepinto's answer the easiest way to set up autologin in any case is via (which has been kept up to date with changes to the init system). 

There are two categories you can consider here. The first is TUI applications, which on a GNU/Linux system are usually implemented with a library called ncurses. There will be a python interface to that. The wikipedia article contains enough screenshots to give you some idea of what is possible with that. The other category are full blown GUI apps. These do not have to be much more complicated to create than TUI apps,1 so unless you are certain ncurses is sufficient, you probably want to go this route. There are a number of different GUI libraries in common use on linux, the primary two being GTK+ and Qt. Both of these also have python bindings and can be used to create a typical modern GUI app. The former is probably more memory efficient in a Raspbian context. There is also Tk, which has a bit more of an "old school" look -- if you google for "Tk widgets" and check out the images you'll get the idea. It can be made to look pretty funky; the main drawback visually is that Tk apps will look different than most of the desktop. However, since you only want to run one, stand-alone, that's not an issue. Tk is probably easier to learn than Gtk+ or Qt. Fortunately, python is very cross-platform, so you do not have to start out by learning this on the pi. I do recommend you use a linux system, but I am sure you can learn the fundamentals on OSX or Windows as well. You should find yourself a tutorial on using python with the toolkit/library you like (ncurses, Gtk+, Qt, or Tk) and go from there; getting a book, once you are sure about the topic, is also a good idea. 

If those are callbacks, it obviously does in the sense that your example code presumably waits and reports on both pins. If you want to coordinate the meaning of these events, that's a higher level conceptually and you need to do it yourself. I doubt any GPIO library will provide such arbitrary functionality (because that is not their purpose). 

Here I've used instead of the how-to's line. This will use , and $HOME would be . Pretty sure startx is also a blocking call, so until X exits, won't run. If instead you did this: 

simulate this circuit â€“ Schematic created using CircuitLab Whatever the GPIO would be attached to would go bottom left. Notice that means the resistor is not in between it and whatever; it is between it and an internal 3.3V source. This is used to "pull-up" (i.e. to digital "high") when whatever it is attached to is in high impedance (i.e., connected neither to ground nor a voltage source). The purpose here is to keep the pin high until the whatever (say a button) pulls it to ground (i.e., digital "low") -- in which case you'd want a smaller resistor in line to prevent a short. You are using the GPIO as an output, and need to protect against too much current draw. For 20 mA: 

And if that doesn't work, you can look in to confirm that it isn't there. In this case, you can build a 3.2.27+ module on the pi without rebuilding the whole kernel (presuming the source for it is in the 3.2.27+ tree). 

Except for total available amperage, there is no limit to the number of things you can attach to one 3.3V pin. They are both connected together in parallel anyway; having 2 is just a convenience. If you have this inside a case of some sort, an easy solution is to get a small breadboard, cut it in half, and attach a 3.3V pin to the + rail. You now have 30 parallel 3.3V slots. Alternately you could solder multiple wires together on one lead, etc. 

Setting the keyboard from probably isn't ideal, and you would be better off using , particularly if you use a GUI, because I believe the keyboard used there maybe configured independently of the text console, and you probably want them both the same. That said, the parameters in are passed to kernel, and anything that's not recognized by the kernel is passed to the init system (init being the only userspace program actually started by the kernel). On current versions of Raspbian, "init" == "systemd". There is a bit of grey when looking at the options because some things may follow a generic interface to init; the vconsole keyboard I think falls into this category and (again) there are better ways to configure that. But forging ahead anyway, see .1 If you go from there to and then , you'll find settings from that can be applied via kernel params (although again, it's all actually done by systemd). The parameter is: 

Using ext will eliminate that, although that doesn't mean it is the problem WRT the overall speed. But again, if you know the write speed to your SD card and it's better than 5 MB/s, you should be able to test this by writing a torrent to there. 

I'm perplexed as to why this would have happened in the first place, but it could be that it did start with my last build of 3.6.11; the only difference between that and the previous one was making a built-in. 

Now there's an empty ext4 filesystem mounted on fsmnt (there will be one "lost+found" directory, which is basic to ext filesystems; notice there is one on the pi). You can now copy everything from the SD card partition in. This means there is zero wear on and zero risk for the card. Then just umount the image: 

I believe the pi user has permission to do this by default now on Raspbian but I'm not sure; if not you'll have to run this root. 

Removing packages that you are not using will not improve performance. The only thing it will do for you is free up some space. The base Raspbian install is less than 2 GB, but if you remove all the GUI stuff, you might free up 4-500 MB. Beyond that, there's not really much fat. If you try the minimal build with Arch, you will likely end up with 1 - 1.5 GB anyway. Keep in mind that just because you do not understand what the purpose of something is does not mean it does not have one. Your concern is not unusual (I use to think this way, a long time ago), but it is not particularly rational, either. There are a lot of things you can do to tailor your system to your needs, but obsessive compulsive fixation on the of number of installed packages is not one of them. 

The simplest method I've found for starting a persistent background service via systemd, which may be handy since you can then get it to report on subprocesses currently running as children via , etc., is via a service file like this: 

Powerbanks are not made for powering electronics. They are made for re-charging batteries. This is important because these two tasks have some requirements that are at odds. Most significantly, in powering electronics it necessary for the supply to be responsive to rapid fluctuations in current draw, but the exact opposite is true with regard to recharging batteries; sudden fluctuations in current shouldn't occur and the circuitry of the power bank will, at the least, not be designed to be responsive (such that the voltage will drop in response to a sudden demand for current). It might even be designed to prevent surges in current. The primary target of powerbanks is of course mobile devices that use batteries rated somewhere between 3 and 4 volts (I think 3.2 and 3.7 are common). If you take a powerbank apart, you will find that they use the exact same types of batteries albeit bigger (i.e., capable of storing more energy). This means the voltage is being stepped up to 5V to fulfil a generic standard -- that of the USB connectors they use. However, they don't really need to maintain a steady 5V and as they discharge this will probably drop. It may also wax and wane, as per the Q&A linked above. Point being, don't expect them to work well for your application. If you want a stable portable power supply for a Pi, you should use something that is explicitly intended to power 5V electronics from lower voltage batteries. These are much less common than power banks but you should be able to find them at hobbyist electronics retailers. They are usually called boost or step-up converters (powerbanks use them too, but again, these are not all created equal). You might have better luck with newer USB C powerbanks, which must deliver more current to provide faster charge times -- but maybe not, since again, the higher quality the item the more likely it is to smooth away rapid fluctuations in current draw. I've used powerbanks a bit with various pis and my experience is that they are okay with most models depending what else is connected -- although they do not not live up to their mAh ratings, which are usually derived from the batteries inside them and indicative of how much charge they can provide simililar lower voltage batteries. I.e., they do not indicate how long the bank will last at 5V. However, I noticed they are not so good with a Pi 3. With no peripherals, a 3's power led will almost certainly flicker when booting on a powerbank, indicating the supply cannot deliver in the context of the rapid fluctuations in draw which occur when the device is booting. 

Note the PID is logged when the script starts, which makes it easy to check for and kill. You can also start this from : 

An easy way to test this would be to try putting a torrent on the SD card, or just time some local transfers from it. All the filesystems involved below are ext4. Creating a dummy file on the SD card: 

And see if anything happens. If there's nothing obvious, check ; if there are two devices, 0, and 1, the driver may be working. 

No, not in a secure way. You might be able to conditionally trigger an autologin based on something written to the root filesystem, but that is not secure -- all someone needs to do is figure out how to add the trigger manually to the SD card. This could be mitigated against from a network perspective if you used the init system such that the trigger were only accessible to the root user and you modified the pi user's superprivileges from the Raspbian default, however, that seems pointless since from a network perspective after a restart, you would have to connect to the system again and that presumably means using some kind of credentials. From a "physically there" perspective, the Pi, like most computers, is totally insecure anyway. It would be very easy for anyone with physical access to the pi to circumvent any security you add including passwords. An exception could apply to when the device is found off, if you encrypt the filesystem. On normal computers you can mitgate against this by locking the case and removing any exposed bootable peripherals (or make them non-bootable), and/or use a BIOS password. The equivalent on the Pi would be to glue the SD card in, or use a lockable case which leaves it inaccessible. 

You're going to need to look at stuff in the pi's root filesystem, which means either plugging in a keyboard and display or taking the SD card out. Do the thing, then check to see if there is a more informative message than "Access denied". Note this file is readable only by root (try ). Also have a look at: 

They do not claim to maintain any image independent of this. I presume there is no such thing, or else there would be some link somewhere on their web site. Keep in mind that an operating system distribution is not a device image. Raspbian is an OS distribution. Various people, including the Foundation, have taken this and created SD card images for ease of use. Most GNU/Linux distros do not provide complete device images of this sort either; what they do provide are DVD images which can be used as "live systems" and installers. 

If you are using some other Debian variant, the same methodology should work. If not, or you are using a kernel from , or you would just rather browse around for what you want, you can always start with the commits link from the web view of the repo. Actual version commits are easy to find because they feature a head shot of Greg K.H. They seem to be at least a few pages or so apart.