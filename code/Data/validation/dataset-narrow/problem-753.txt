This way it is easy to read as " is between and OR is between and ". Even better would be to write : 

with an extra on the end? If this is meant to happen, the dashes seem useless for getting the count; you should just do . Further, dashes complicate the code. A sensible way to deal with the code is to split the fake lists into real lists. I suggest removing the dashes first: 

Your doctest is misformatted; fix that. Also, don't add a space before the docstring and don't give it a useless header like "Doctest": give it real documentation. Beware of PEP-8 spacing, too. Your parameter is misnamed; you don't take an but a . Best call it just , which is good for duck-typing. You default and to ... but ! This means that if the user passes in as or it would be ignored. You should default unknown values to, say, . I would also rename these to and . You do 

Then you have at most two partial minutes left over, which means there are at most a further 118 specific timestamps. You can do a full check on these fairly quickly, but it is easy enough to skip it if the minute cache says the full minute never beats the current maximum. 

is better named ; don't describe the type, describe the value. 's output is unhelpful; the result should be much more obvious, especially when it fails. Keeping along the given lines, I might do something like 

Your covers a lot more than wanted, which is dangerous. Restrict its coverage. Personally I'd also do rather than , since whitelists are generally simpler and safer than blacklists. YMMV. 

There are some quick fixes. Firstly, we can try binary search. Python has a fast implementation in the library. But even better is to "move" the paint can as we go along: 

is easily understood in that is producing those objects that are red. The actual storage is unimportant. Something like 

or do Lisp-style expression embebedding, the aim is to make the structure and logic coincide. Exactly the same arguments apply to . is really misnamed; it should be something like . This might suggest again that you split it up into and . I have doing: 

Personally, though, I would do before calling the function: internal functions shouldn't be exposed to user-facing details like 1-based indexing. No need for if you've already returned. The name could be more descriptive; perhaps This gives: 

(note , not ). I removed the term because many sequence types can be palindromic, like . should , not , its values. I would change the documentation to specify the rules the output satisfy. 

\$ \newcommand{\pt}[2]{(#1 \!\times\! #2)} \$Here's some commentary about potential algorithms particularly suited to Python. Note that a general optimal algorithm might not be suitable for Python because Numpy almost requires you to be able to vectorize your calculations. The aim, basically, would be to make maximal usage of . This will require moving the data into homogeneous pure-Numpy arrays. I suggest 

You could do with learning some of the more powerful tools in Python, such as . Tracing control flow, instead of 

let me choose First things first; your code is ing to and opening . This is woefully inflexible. The simplest fix is to accept an argument on the command line, as . (Don't use .) numpy What you're doing looks a lil' bit crazy. To deal with highly-dimensional data, Numpy is often a good candidate. A first-pass would look something like 

Thus no allocations are needed, and the user has no difficulty allocating their new merged result or just looping over it if no intermediate is needed. To back this idea up in prior art, we already have APIs for sorted slices. This would just be another, so to speak. We'd really like to write this in terms of a generator. Eg. the Python 

Again, we'll see the run-on effects later. We do, however, find issue colliding with the next value; 

You don't use - remove it. Rather than rename to , I would directly import and . Use new-style formatting, please! Also, use instead of - using neither would be best, although its use is mildly understandable in this case (even if still saddening). Don't call - this is a function only for interpreter usage. I actually suggest just ing in this case. Your subprocess call only wants output, so drop . Further, you can just call : 

This initial generation might take a long time, though, as you need to generate a list for every possible letter - and there are a lot of those. If you only generate a list for which there is a letter in the string, you've improved your worst case but you're still generating a large square. This could be expensive. One other option is to store indexes: 

But this just makes it obvious that is never used by the function, so shouldn't be passed in in the first place. This means that the comment for the function is also a lie! So what is doing? Idunno, let's work it out. tells me nothing about its purpose, but I can see that it's a mapping from numbers inside the triplets to counts of some kind. This suggests a , though that doesn't clarify a lot. The comment doesn't really help either. I'll call it for now. Note that is just , but the first loop can just be 

plus a bit of concatenation. This gives the opportunity to implement the N-dimensional variant by using the algorithm as given since the prior is so simple and supports it trivially. This requires addition of: 

We are going to place onto next, for all values that will fit. Fill in the unknowns on the base with the minimal values that fit, pushing larger numbers to the edges. In this case, we cannot add , , or , so we fill in a . Treat the as a for now: 

Use instead of as a "missing value" sentinel; that's what it's for, after all. Looking further, I got confused as to why you delayed it anyway; never seems to be big so it makes sense just to do it eagerly. This pointed out what seems to be a bug: is too few bytes when represents a value of > 1 bytes. This kind of error and repetition suggests that you should really have a class to encapsulate reading data from the file. would work great for that. You also don't check for insufficient read sizes, but I'll let that be for now. Being non-lazy, you could make another immutable : 

Your code should use spacing. Note how when you posted this question you used paragraphs with line breaks. The same this helps with code. You should also stick to PEP 8. Just changing that and using brackets on gives