Without physics you can use and also register rotation entity modifier to make it rotate from its current to the desired angle. When you add physics, you should no longer directly rotate an object around it's center, you should to use forces and impulses to give the body a spin. In your case: 

You are asking two different things in the title and body of your question. The answer to the question in the title is: use 

MouseJoint is not a good idea, it will get out of sync too. It's really meant to be used to make the body move towards the point. is exactly the same as setting the position and rotation of the Sprite. You just have to be setting the coordinates in meters not pixels. I am not an expert on multiplayer, but the latency will influence it always. You should probably send the velocity AND coordinates. Each time you should call and . So the body will be correcting its position with each update and also moving approximately the correct directions between updates. in any case you should be doing all checks on a server (one of the client can be the server) and clients should be only presenting the results. 

You question is very broad. This is very dependent on the platform you are using and the framework/engine if any. The answer is most likely: They are loaded into video memory when your code/framework/engine load them there. Your other question is related to culling: $URL$ The assets are most likely to be loaded to (asset, video) memory, but not rendered. But again, it is platform dependent. 

Kinematic body is not influenced by gravity and other forces. It's like a static body that can move by setting the velocity. If you bump into it, it won't change its velocity. 

If I am not going to name the character and I use my own original art that very closely resembles a well-known video game character that appears in my game for a very brief moment, is it legal to add a cameo appearance of the character in my game? In an indie game and meant as a tribute to the original game, but I doubt that makes any difference. Example 1: A scrolling 2D platformer with Super Mario in one level performing a single action and dissapearing afterwards. Not naming the character at all. Example 2: A video game poster inside the game with Sonic The Hedgehog with or without naming the character, with or without Sega logo. 

Agreed with Mikolaj do not copy everything. Send as few data as possible. You can have same classes (representing just the data model, not other assets) in client and server, but do not send them over the net. You want to serialize them on server and deserialize on client. Client should send only commands to server. 

To get the best result, you need to run the simulation like if you actually threw the projectile - just fast forward! And that is quite easy in any Box2D port. In AndEngine call method from class in a loop to run it as fast as you want. You can apply arbitrary forces at the beginning or between each two steps. Note that in AndEngine the class is wrapped in class that doesn't give you direct access to the instance of . However you can extend to get access to fields, or you can simply call method. This one updates all AndEngine physics connectors as well. Just be careful with the performance, play with the parameters. Maybe create a clone of your physics world that will be simplified, containing just the objects directly needed for the simulation. 

This is normal behaviour. It happens because of the Android Activity Lifecycle destroying and recreating the OpenGL context onPause/onResume. From GLSurfaceView documentation: 

Extend the class and add a method to add you own and a method to set some user data. Or implement the touch logic in your new child class by overriding the method. I don't think there is any other mechanism in AndEngine that would allow you to register a touch listener to Sprites. 

You can download full MSDN Library for Visual Studio from the Microsoft website. But I think you need the same version of Visual Studio as is the version of the downloadable MSDN to be able to view it. Here is a link to download page of MSDN Library for Microsoft Visual Studio 2008 SP1, that should contain the information you are looking for. Unfortunately I don't own the MS Visual Studio 2008, so I can't make sure. 

But even if you really take care of all this, you might run into problems. Depends on how much revenue you are making and how much revenue is the other company losing. As an example, look at the image below. It is from one of the big lawsuits recently, EA vs. Zynga. No original artwork was used, no patents and no trademarks infringements. They settled the suit without anyone winning. 

You are setting rotation center in the world, not on the sprite. So if you set rotation centre to (0, 0) the sprite will rotate around left corner of the screen. You must set the rotation center similar to this: 

Only if one hit = one heart every time. For me understanding health bar is no issue - of course I don't know how much exactly I have, but I'd say to myself: Oh noes! It looks like I am under quarter health, better to drink that potion! 

There are only a very few GUI elements in AndEngine. You will have to implement it yourself. Take a look at for the slide gesture. 

Yes, you are missing something conceptually - AndEngine is based on OpenGL ES. Now OpenGL is very well suited to the following use case: 

Methods like showGunEffect(), showDamage() and showMiss() are calls to the presentation tier to actually show the graphics. Now let's make the program more complex: 

I believe you can change the App Name during uploading and update (with the updated Bundle Display Name) and if you don't change the Bundle Identifier all reviews and rankings should remain the same. Users will also automatically receive this update. This is most likely dependent on Apple approval after the update. Hopefully this is still valid with the App Store changes. 

You should definitely detach creation of and . Unless you are working with strictly 1:1 ratio - each sprite you create has different texture - and you create all your sprites and the beginning. The operation to load the texture from file to memory is resource intensive. The operation to assign texture to a sprite is almost free. Therefore you should create textures only once at the start, before any sprites are created in some "loading" phase. Then create the sprites. You can have specialized sprites, like "BulletSprite" that will always show the same texture, so you don't have to pass it in constructor. Instead of using createAndLoadSimpleSprite, consider implementing a sprite factory using this pattern: $URL$ The best practice is always to load all textures first, then create sprites. Usually you will have more sprites sharing a texture. Drawing a Sprite is just an instruction - draw this texture there. In fact, textures are stored in completely separate memory, they are not stored on Java heap. 

Your application is waiting for the signal that the step has finished. You never send the signal, so it never starts. Change your class like this: 

It scales and skews the whole canvas. Imagine you are drawing on the canvas that is not skewed. It is skewed (transformed) only just before it is printed to the screen. See the following diagram: 

From $URL$ Many other physics-based iOS games, such as Cut the Rope and Save Toshi use the same, or simliar 3-star system. However, the former allows the player to end the level with a zero-star ranking, and the latter allows players to get a three-star-plus ranking. Reseachers found that before the release of the original Angry Birds, only 20% of all games were rated with the 3-star score system. After the release of it, nearly 80% of all games were rated with the same or similar scoring system. (Similars are the likes of Asphalt 6, which placing was rated with 3, and achivements were 2, meaning that this is a 5-star score system.) 

Do you want to make the game for yourselves as a hobby project or do you want to monetize the final product? If it is the former, go with Byte56's aproach. But if it is the latter, you should involve other people in the decision as well. Like that TV show where people present their startups to the millionaires and ask for cash, you should create a group of people (jury) who play games and present them your prototypes/draft documents. Based on their feedback, you can decide, or at least you can decide the ties. You can also create an online survey and send to all your "facebook friends". You can involve the whole team to create each prototype. This is to avoid the artist's prototype looking fancy but static and programmer's prototype ugly but playable... 

I've done some research on this topic before and I agree, there are not many crowdfunding projects for mobile games. Searching Kickstarter itself is not easy. But it can be done and some people make their living by doing exactly this. What you need to look for are mobile gaming blogs and webzines that crawl through kickstarter and post articles named like: Top 10 most exciting iPhone and Android games on Kickstarter or tagged with kickstarter. Second page of Google usually has better results, because the first one is all about kickstarter itself. Also tags and categories on kickstarter homepage can be useful, but as you already said in comments - it is not easy. When you start looking for the games, soon you will notice a pattern. Most of the really successful games are multiplatform, meant for PCs too. Very successful projects usually include reboots and remakes of geeky games from the past. I concluded this is due to the demographics of gaming kickstarter benefactors - people who are real enthusiasts, regular gamers and people who really liked games in the past and now have enough money to get to play the games they want. Typical kickstarter visitor is a male 25-34 years old with no children, at least colledge degree and above average income - this is of course kickstarter on average, not just gaming. Smartphone gamer demographics are very different from those of regular games... I don't think many casual gamers are interested in crowdfunding a game, when they have plethora of simple and entertaining games (for free) in App Store/Play Store. 

Look at this image. In your case, V = 1. If you need vector in different plane, just switch the axes. 

The "hard" distance joint holds the paddle in place, it is like it's axis. The paddle can rotate along it, but can't move from it. The four "soft" distance joints are springs (or bungy ropes...) that make the paddle go back to initial position. If you need to move the paddle, you have to move all six bodies. It works exactly as I wanted for one body. But it doesn't work when two paddles collide, because the paddles are fixed in place. I am still working on it, but maybe somebody will be inspired. Simulation created in RUBE. 

You are planning a turn-based MMORPG (no idea how that would work though). So speed is not much of a problem. You can use any kind of service, REST might be good, it's simple. Usually MMORPGs use UDP (not secure, smaller, faster) for things like movement updates where a lost packet or two doesn't matter and TCP (secure, overhead) for secure communication. Most of the games probably use some kind of encrypted, compressed custom protocol over UDP and TCP to make it fast and hard to crack. 

Which means your textures are being resampled using nearest-neighbor interpolation. AndEngine will automatically scale your game to the phone's resolution. If you are not scaling in steps of 2 (e.g. your resolution of choice is 800x480 and your phone's resolution is 1280x768) it will create "bandings". Try or . You can also try whether the following option improves the banding: 

Also your naming convention is a bit confusing. You are calling a fixture definition "footSensor", but the defition is basically just the set of parameters, not the sensor itself. 

show current character sprite frame if add elapsed time to total animation time, else show frame 1 if animation time < 256ms show frame 2, if animation time > 256ms show frame 3 (ando so on for longer walk) update sprite position by distance (if it moves 128 pixels per second, move it 128 * elapsed time in seconds) perform checks draw everything 

BPEL programming language has visual representation and many tools that work with it. It is a workflow language, not a programming language, but it is turing-complete. It is verbose, but it is easy to write for both programmers and business people and it's easily translatable from visual to textual form. I don't think it would make a good game-language, but it can serve as a source of inspiration. And given the amount of BPEL engines and tools, it should be possible to reuse some ideas and/or code. BPEL-like language will not feel like programming, more like routing and connecting systems. So you can have a targeting system connected to a gun system with some logic in between. 

Yes, it is possible. AndEngine has a Level loader that can do exactly what you need. I recommend going through these tutorials. In the final tutorial, creating a whole game, one of the chapters talks about level creating and loading. Look for a class named . 

Design your level as you wish, paint tiles in the Map layer. Create an object layer and set a "wall" or "ground" property to it. Use rectangles to draw ground. In your code, iterate through the these rectangles and create physics invisible objects that will serve as ground. Something like this: 

After a lot of thought and inspired by the other answers, I came up with a schema of 6 two color combinations. I realized that using just one color won't be enough, because I will have to repeat at least one of them, making either good a shade of evil or vice versa (which sounds pretty zen). I've also asked a web designer to help me pick and name the colors. I searched for these color among video games or movie heroes and villains. I've also went through comic book superhereos, anime characters and AD&D famous characters. The six combinations are from top left: