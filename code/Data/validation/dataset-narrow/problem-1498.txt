First, yes, portfolios are a universally good thing for students at any level, not just high school. My preference is to require them and also to provide some institutional support for their creation and maintenance. The initial creation of the portfolio can be a project for a second or third year student - graded or not. If there is a course in web development it might be the natural place for such a project. Rather than just code, however, I think it is much more important that portfolios showcase student writing and communication skills. A student can describe what they have built and the teams they have contributed to with (English/French/...) prose. If possible, the prose should be checked and edited to be clear and correct - support. If the project was a coding project there can be links to the code, but the primary thing is what the student has to say about the project and its value in their education. "What I learned and why it is important." For a platform, I like a web-page (or several pages), rather than a repository. Any code can be either in a repository or a simple downloaded archive file. I would also try to provide a platform with which the student work is permanently available - at least several years past graduation. Ideally the former student could add to it. There should be some way to contact the author, possibly indirectly, through the portfolio. For minor students, the contact likely must be indirect, through the institution. Institutional support is needed (or at least very desirable) to assure high quality and to assist reticent students to bring out their best work. Many students are reluctant to "bring themselves forward" for many reasons: shyness, modesty, ... On the other side, institutional support (editors say) can help some students "tone down" boastful claims that will be seen as a negative by employers. There is a fairly fine line that students may not always recognize. The permanence of the portfolio is important for a number of reasons. The student will come to depend on it, of course, but it is also a way for the institution itself to keep in contact with the student (and vise-versa) in the future. This will make it easier to bring back former students to talk to current students and will also help in future fund-raising. Likewise email addresses assigned to students by educational institutions should be treated as permanent - keeping that link alive. If the portfolio is primarily prose, it is easier to provide institutional support as most schools have professionals already skilled at that, though it takes an institutional decision to provide the support. But it can be considered a positive institutional goal to showcase student works. This is especially true if it aids in recruitment and in bringing employers (and donors) to a school seen as doing a truly fine job. 

The problem you describe doesn't exactly fit this answer, but it might be useful to some with a similar problem. In some such labs it has been observed (and filmed) that students working alone at a station get into some difficulty and raise their hand for help. If the instructor and/or assistant is busy with another at the time, the student with the new problem waits. Then maybe another, and two are waiting, etc. The solution to this is to have students always working in pairs in the lab, doing things like pair programming, pair research, pair writing (very creative), etc. This has been observed to reduce the waiting to essentially zero as the students solve their own problems. When one student gets "stuck" it is unlikely that the partner is stuck in exactly the same way so they can move on. This is a well known effect in professional pair programming also. You still need to wander about asking if you are needed, as a pair will sometimes queue a question till you come around while they work elsewhere. Sorry, I don't have a link to the study on this. I assume it came out of the Agile Community's educator forum. 

Let me note that the problem expressed in the question can arise in a variety of contexts, not just students working in a lab. The solution isn't really to help them learn how to debug, but rather, how to think. Especially, how to work through any problem as it occurs. 

On the other hand, one positive thing I can say about your process is that you give students a lot of practice taking tests. If you want students to do something well, give them a lot of practice doing it. If you want them to do well on tests (including standardized tests) give them a lot of practice doing tests. 

Since you said non-programming, rather than non-CS I'd like to add a couple of very small books by V.J Rayward-Smith: 

I've known many HS teachers who have joined and become valued members. I think it is most useful for those contemplating further graduate study and seeking contacts and research ideas and such. Some have gone on to earn doctorates. However, for your stated goal, you will find that the members there, while not focused on secondary education, will have a lot to contribute to your programming and general CS classes. SIGCSE folk are especially interested in APCS. The curriculum gets developed by many of these people, as do supporting materials (case studies), and many, many of them are AP graders. CSTA, of course, is more directly focused on your needs. But SIGCSE can help you learn early of educational trends before they become embodied in curricula. You can even participate in the development. For example, Greenfoot, an interesting Java environment for beginners, as well as BlueJ (more advanced), were developed by a team led by members (Michael Kölling and his team). He does tutorials, etc. at the SIGCSE and ITICSE conferences. 

The Semantics of Programming Languages is an important and very mathematical subject. Great strides have been made in the past 20 or so years. One book that stands out is A Theory of Objects by Luca Cardelli and Martín Abadi Luca, especially, is an expert in operational semantics. He presents a generalized operational calculus for analyzing all aspects of object-oriented languages. The book is deep, but essential for those wanting a deep understanding of the underlying principles of OO languages and, perhaps, wanting to design future languages. Language is more than syntax. It is the semantics that lets the student form proper hypotheses about programs and programming. Most compilers are still "syntax directed" but Peter Lee, in his doctoral dissertation (U of Michigan). shows how a compiler can be built from the semantics instead. 

Actually, your tree explanation is fine, except that it is the low precedence operators closer to the root. In Java, the "." operator is the strongest/highest and the assignment operators are the lowest precedence. The arithmetic operators are all higher precedence (bind tighter) than the booleans, with && having higher precedence than || A semi-official list is here: $URL$ In fact many compilers will translate an expression (the entire program, in fact) into a tree structure either explicitly or implicitly. But, "binding tightly" is pretty traditional for an explanation also. The scope of an operator is limited by the end of the expression or the occurrence of a lower precedence operator. Therefore the RHS of the OR in your example is the end of the expression, but the LHS of the AND is bounded by the OR operator. In the tree explanation work from lower to higher. In the "binding tightly" work from the higher to the lower precedence operator. 

Note that this answer was posted before a title change to the question narrowed the question. The original title asked for "tools for online teaching." This answer was provided in that light. 

I assume that somewhere you discuss plagiarism and the social good of respecting the IP of others. If not, plagiarism detection is just a "gotcha" that doesn't really benefit the students or your relationship with them. The following suggestion is offered tentatively, and might require tuning. It might also require research on the effect. If the tool is good enough to tell you in real time that something bad is occurring, it is also good enough to tell the student at that moment. So you could build that feature into the tool. However, there is, then, the danger that a student could game the system, modifying things just enough that the warning goes away. So it might be necessary for the warning given the student to also warn that not every "violation" will be reported to the student but will be reported to the instructor. Caveat: This was "seat of the pants - in the moment" design. I can't claim it is best practice. It is, however, based on the principle that fairness and communication are positive attributes in education. Help the student grow in many dimensions, not just the technical. 

Old person horror story. I once worked in Pascal on IBM mainframe terminals. You put a space before every semicolon since the search function would only work on contiguous blocks so mumble and mumble; required different searches. You always "spaced out" every identifier and regretted it when you didn't. 

I think that it is a mistake to try to do this early in the curriculum because the students already have enough to do and this might get in the way and leave them discouraged. Esteem building is good to do early. Reality training cam come after a period of "seasoning". 

Some students find themselves falling behind in a course but still have the desire to do well. Some colleges provide a definite system of tutors in which such students can get additional help. What are good models, in your experience, for such systems? Some questions you might want to answer in giving a model are 

Something like the following has worked for me over several years. In any group assignment, each member of the group also submits a peer review sheet. For a group of two (e.g. pair programming) I ask each participant to detail the most important contribution of their partner AND their own most important contribution. I don't ask who worked harder or ask them to make an evaluation. I ask them for the contributions. In a group of about five, I will ask each member to name the (say) three most important members of their group and to mention the key contribution of each. I tell them that they can include themself in the list of three. I also ask, separately for their own most important contribution. I let them know at the beginning of the course that this will happen and its parameters, so it isn't a surprise. Students see that they are supposed to contribute to a group and are not asked to speak ill of anyone. Keep the questions entirely positive. But you also learn a lot from what is not said and who is not included in the contributor list. If the project happens outside your view, you also learn things about individuals that you can not otherwise know. I've had students I thought were slacking who were praised by teammates for making the team work properly. These peer evaluations are not optional. This same idea was also discussed here: $URL$ It is also, essentially identical to part of this: $URL$ 

Let me note that there may be cultural limitations here. In some cultures it may be odd to name oneself as a top contributor. In others it might be very natural. You can modify the scheme, of course, either requiring or forbidding naming oneself as one of the top people. Use your judgement here. Note also that this solution is based on the Peer Feedback pattern in Pedagogical Patterns: Advice for Educators 

tl;dr: Just say no. This question is difficult on many levels. I seems to me to be a land mine of misconceptions and has the possibility to lead to poor teaching practice. First the difficulties 

Note that good naming will usually mean that you need fewer (if any) inline comments. Providing java doc to document the intent and usage of classes and methods is nearly always sufficient. Also note that I haven't mentioned the capitalization preferences in my standard, though I do observe and expect them: Bumpy case for most things. All CAPS for constants, etc. I'm more concerned with the clarity and instant understandability of the names in the above. Teaching the Standard For students to easily and naturally adopt the standard there are a few tricks that don't involve forcing students. The first rule is to be consistent yourself when you show them examples and when you test them. Even when teaching the lowest level concepts, you can have some metaphor in mind that guides your naming and makes the "problem space" rule natural. For example if you are teaching the a loop to sum an array, it is common to use an example like: 

Although I frequently use a variation on the TV show Jeopardy as a review of terminology later in a course, with everyone serving as contestant, it could be adapted to your needs here. One of the things you would like to know is the current state of knowledge of your students. One of the things you may do when teaching is motivate the study of a new topic by using analogy/metaphor for various technical issues. I envision a Jeopardy game in which the Answers are various social memes and real life situations for which the student "contestants" think up questions. This can be fun, building some sort of "We are the Champions" mindset in the whole class, but also gives you a sense of what will work later and what might not. Building the software to support such a game is pretty easy as it needn't be very sophisticated. However, thinking up the "Answers" requires time and thought in this case. You might be able to find supporting software for Jeopardy online as it is a fairly commonly used educational tool. 

(We know, horses like Trigger can count, of course). The compiler will complain about this, of course since x is only known as an Object reference, not a Horse reference. The sloppy typer will then cast x to quiet the complaints of the compiler: 

This answer will be a bit long, but will give a moderately sophisticated view of OO programming and how to think about it. It is unlikely that focusing specifically on inheritance will be very fruitful for your students. Inheritance is often overused and used in poor ways. The example here is adapted, with permission, from Joseph Bergin's Polymorphism Companion which is, itself a follow up to his Polymorphism: As It Is Played. The program in the book, and here, is a simple simulation of disease spread within a population. The version here has removed a bit of the complexity, but at the expense of some flexibility in exploring the concept of disease spread. There will be eight separate files, two interfaces, two enumerations, and four classes, one of which just explores the value of using interfaces in the first place. The only inheritance is that of implementing an interface. The more important lesson (than inheritance) for a beginner is to learn encapsulation and building objects by composition. OO can fruitfully be thought of as language features for enabling composition. The various implementations of Population are the chief place in this example that illustrate it. The fundamental concept here is that a Population consists of cells of some kind (a generic type parameter in the original, but omitted here). and a Disease spreads from an infected cell to adjacent cells (and otherwise) depending on the characteristics of the disease and the population. In this simplification, the population substrate is a rectangular arrangement of cells (a two dimensional array), though extensions can, for example, use hexagonal cells or other shapes. Note that interfaces are good for defining concepts in a programming system without reference to any implementation. The Java libraries define Set, for example, as an interface, more or less representing a mathematician's concept of a Set. There are various implementations which have different efficiencies, depending on the use. The first Interface here is Disease: