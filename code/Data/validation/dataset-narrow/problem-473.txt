Using for this also seems like overkill. I'd simply declare a char array of size . The buffer is only used locally to the function and is relatively small so can be declared safely on the stack. 

I really just use VBA to get things to work, so some of what I've done feels quite clunky and I'm not sure if that's just the way it is, of if I'm doing things the hard way, so any feedback is welcome. 

You don't need to do this, it's handled automatically for you. By calling loop yourself you're recursing, if you do it enough times, you're going to end up with a stack overflow. My guess is that the Arduino would just reset in this situation and then call again. Since you're not playing, you might not even notice it happen. Your contains . This is also the first line of your method. Setup doesn't seem to actually be using the randomiser, so I suspect you don't need to call it from , simply call it from . Ternary Operator I've got nothing against the ternary operator, however some of your choices do nothing but make your code harder to follow. Nested s should be avoided. Creating a null function so that you can use the ternary operator is unnecessarily complex. The method would be easier to follow if you used constants and spread out the logic a bit. 

If is what it sounds like then the name for should be . What does return if there is no prime within the given bounds? 

The method in the course is responsible to check if the student exists in the course and return once it has executed the strategy. It is totally encapsulated in the course and the caller doesn't have to know about any internals. 

If you don't want to think about or deal with negative numbers you should either change the signature to accept only parameters (which would require the caller to think about what to do in case he's got an ) or you check and throw an exception Just considering positive numbers could be changed to 

Is there a particular reason to use for the parameter to ? It doesn't seem exactly necessary and I usually prefer methods without side effects. reads clumsy. I would rename it to something like or . You should take a bit more care naming method parameters. Parameter names form an important part of the method documentation and should convey their intent clearly. For example here it is not exactly clear what and mean: 

Apparently your solution is quite over-engineered for a problem like this so I just assume you did it for the lack of a proper example (to be honest I usually find it quite difficult to come up with simple, comprehensive examples where the application of more complex designs doesn't seem over-engineered so fair enough :)). Your should not be static. This for example prevents running multiple FizzBuzz games simultaneously. Just create an instance with the specific multipliers as a member and store it as an additional member of your iterator. Static classes which hold states are evil (there are probably sensible applications for it but in general terms they are bad) as they create problems with unit testing, parallelization, re-use, modularity, etc. You have hidden the actual business logic in the class as a static method. A more central place to have that function would be the as it is the one which effectively decides which to create. The most common definition of the FizzBuzz game I know of is this: 

Regarding the complexity, like in Insertion Sort, the worst case scenario is when is sorted. Keep in mind that if you swap the items from stack to stack using the order of the items in will be the exact opposite of the order in which the same items had in . This scenario has a complexity of \$O(n^2)\$. Let me know if anything is unclear. 

There's one thing that is particularly disturbing me: the last block. That's an example of Busy waiting and that's something that should be avoided IMO. A possible solution to this problem could be to store the objects to a and once you have created all the threads you run a for each thread on such list. That being said, I'd suggest to take a look at PLINQ and TPL. One last thing: I'd remove the in the block also. I'd say that the instruction should be used only in a method. See here and here for ways to handle exception when working in an async way. 

Looking at your code, you get the type of the generic param into the method body (which can be seen also as a violation of the Separation of Concerns principle). In order to solve the issue, you can pass the type as a parameter. The resulting code should be something like the following: 

As you are using a singleton which loads the document once, I would say "Yes you will probably see some degradation in performance to service calls if you only load it on demand". If your service is the one and only program which modifies the document then your approach is probably viable. A few notes: 

Maybe it's a result of your simplification for the example but your looks like an over-engineered enum to me. What do you gain from it over using an and a for the current state? In general whenever you need to check for the specific type in order to execute some specific logic then your abstraction is probably flawed from an OO point of view. One design I've chosen in the past for more complicated parser is to have the state execute the transition. Something along these lines (does not compile just showing the idea): 

I've been thinking this over for a while now and I'm pretty sure you're not implementing Dijkstra's algorithm (which is the shortest path between two nodes in a graph). It looks like you're computing a minimum spanning tree (set of edges connecting all nodes with minimal cost). Some additional remarks: 

quadratic complexity which is probably not what the user of the structure would expect. This is probably one of the reasons why doesn't implement indexed access (neither does C#'s for example). Also I noticed that you initialize variables of primitive types like this: 

We get the sets of 2 non-contiguous substrings. For each set of 2 strings do the following: 2.1. Get the last string. 2.2. Repeat operation in point 1. 2.3. Add the other strings in the original set to the calculated sets in 2.2. Repeat point 2 for the sets of 3 strings ( in general) until no more strings remain. 

which behaves in the same way as the original method by using only the lazy evaluation feature of the and operator. Regarding the search problem related to the case of the strings I'd just apply a or to both strings. The end result should become the following: 

Let's take an example. If we have that and we'd need the numbers from to . We just parse to , multiply it by 10 for 3 times (length of is 2 and is 5) and return the numbers from 15000 to 15999 ( is set to 16000 which is the first value that is not allowed). In addition, if you just need an the previous method would be something like the following: 

Pick the element on top of . If this element is greater than or equal to the element on top of , or if is empty, push this element in . If this element is smaller than the element on top of then pop the element on top of and push it in , then go to step 2. If contains any element go to step 1. 

When reading from the file, you create a new node and keep reading until you get to the last node, however you're allocating memory ahead of time. This means that when you read the last node from the file, is pointing some newly allocated memory that you've not put anywhere else. If you then add a new record, the pointer is overwritten and the memory is lost. This is perhaps a symptom of using global variables, which are much harder to keep track of than locals. Does really need to be global, rather than a local variable? static Where you're not going to be calling methods / referring to global variables from another source file, consider making them so that they're confined to that source file (you would then not include them in your header file). So, for example I wouldn't have in the 'main.h' file. It's not being called from any other sources so there's no reason to export it. I'd instead have the function prototype at the top of the 'main.c' file. 

I've only glanced at your code, however it looks like your connection retry (in ) has a scoping issue. In your block: 

In order to support development, I wrote the following tests (apart from , which was supplied with the challenge). 

The end result - after applying the changes in the first solution and the changes for these 3 points - should be something like the following: 

We have a prefix indicated by a string (that has a numeric format alright, but it is a string) We have a max length, let's call it , of the numbers you can consider. The allowed length of the prefix, let's call it , should be We need all the numbers that start with the given prefix and have the given 

In addition to what has been said already (and if I understood the problem correctly), I'd say that you are complicating things too much. Let's think about it (on a single prefix for now): 

and then proceed as you are already doing (randomize the list and write it in a file, or whatever the case may be). Let me know if something is unclear. 

Another thing, when working with strings it's better to work with the StringBuilder class and/or the string.Format method. 

is repeated code (the two cycles are almost the same) and could be transformed in a method. Other things seem ok. 

Another way to go at it (which I personally like the most) would be by using the and operators and not managing s and s. In this case, the would become something like the following (still not tested): 

That way the value of the enum is actually linked to the character it represents. This makes it possible for your to become: 

I haven't used curl, so this is just some general feedback: Indentation Your indentation spacing is very erratic. Sometimes you indent by 1/2 spaces, sometimes by 0, sometimes by 8. This makes it much more difficult to read the code than it needs to be. If it looks like this in your editor, consider using one that will help your format the code appropriately. If it looks better in your editor, then use the preview when posting to CR to make sure it matches. Bracing Your bracing style is similarly erratic. You generally seem to prefer same line bracing however if have at least one statement where the brace is on the next line and you vary whether or not you put a space before the braces. It doesn't matter that much which style you prefer, but try to be consistent with it, it makes code much easier to read. WriteCallback This method has the wrong name (at least if it's doing what I think it is). You write to a connection. You read from the connection. This callback is used to process the response that has been read from the host/webserver. It's storing the information in your . The method should be a ReadCallback. Logical Distribution On the face of it, you're doing a fairly straightforward operation so it's understandable that you have chosen to put all the functionality into your , however if your break the functionality up into effectively named functions it will help with the readability of your code. For example at first glance it's not obvious that these two calls: 

You should in general try to find better names for variables - and and are not very descriptive. You should check the return value of before writing the output. 

Instead of directly sending the message consider making an event available on the class like . Then other code can subscribe to it and do stuff (like sending it as mail or logging it or saving it somewhere, etc). As mentioned in the comment you should wrap all objects you create which are into statements to make sure any allocated resources are cleaned up properly. 

This clearly limits the scope of the loop counter to the loop so anyone reading the code doesn't have to check if the variables might be used further down. It also states the invariants of the loop all in one place. I choose and because using and to denote coordinates in a 2d structure is fairly common in the programming world. For other loops different names will make more sense. Same goes for the outer loop which loops over all words. The inner loops are ok since you are skipping some parts but still the loop counters should be renamed to something more suitable. Also your other variables could use more descriptive names. For example 

Lo and behold you can now delete the class. It serves no purpose other than making it near impossible to get statistics for more than one interface at a time and interfere with unit testing big time. 

The first thing that pops in my mind is the naming you used. For example, from a method called I'd expect to receive a and not a string. The same from . In the method the variable should be renamed IMO as the name is not so meaningful. The same regarding . Also, commented code is only confusing. I'd remove it. In addition: 

As an alternative, you can make it an extension method of the class, and I'd suggest a rename of the method in this case: 

This seems like a method suitable for the dynamic programming method. As 200_success said in his answer, the use of memoization can greatly improve performance. What I want to add to the answer are two ways to go with solving the problem. In-time processing This is the way suggested in 200_success' answer (if I understood it correctly). Let's go at it one step at a time. We have that \$G(0) = 0\$, \$G(1) = 1\$, and \$G(n) = [G(n-1) + G(n-2)]^2\$. By caching the result of \$G(n-2)\$ and \$G(n-1)\$ we can easily calculate \$G(n)\$, so, for \$n >= 2\$ we can use the following algorithm (in pseudo-code): 

In addition to what's been already written, I'd say that it shouldn't be necessary to implement the method. That is a test method and it should be in a test module. Regarding the implementation, I'd make the following operations: