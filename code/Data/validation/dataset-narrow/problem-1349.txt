The closest thing I can find is something called VASSAL. It doesn't seem to be as easy as setting up XML files for the game to work properly, but if you want a board game framework that supports multi-player, there you go. Now your question is pretty interesting. Although to meet your specifications exactly, you might have to Roll your own. And I don't know if XML will be the correct tool for the job. For defining complex rules, either the interpreter will have to be overly complex and specific to work with all the variations of rules you could do in a board game, or you would have to define the rules in some kind of scripting language. 

$URL$ Extremely easy to use. Has BOX2d implemented in an easy to use way. Can build native IOS and Android applications. 

The normals facing away from the camera are shaded black in your setup. Add more lights into the scene that are shining on parts you want lit up, or set up the lighting with a brighter minimum brightness. 

Yes, it's possible. No its not a dumb idea. In fact many of the older racing games did something similar. Super Mario Kart is one example. The rendering uses 2d sprites in 3d space instead of polygons, but the physics engine is all 2d. 

Building games by committee is a bad idea, you end up with all the ideas watered down or not implemented correctly. From the beginning you should have put yourself in the "Lead Designer" position, but now I think it could be a bit late for that. You should start by having them work on some different 1 or 2 day prototypes to get some of the base gameplay down and then go from there. A lot of ideas that sound bad or too complicated on paper are actually really fun. Have each group break off and make a small prototype to test the ideas. Then you have something tangeable to compare, instead of most likely poorly communicated ideas. 

This should work assuming the left, right, top and bottom variables are correct at the time of the collision test. 

The answer to this question is from the link you posted. Specifically you should read the quote from Gas Powered Games: 

You do not want to be copying the actual graphics back and forth, just references to data, and any small data that is unique to each one. 

I am not entirely sure, but in the video you linked of Dirt 2, I believe the water is handled by a 2d height-map height map simulation of the water, and then that data is used by tessellation shaders to make a high resolution 3d displacement of the water without using too much GPU or CPU time. Other games do something similar but use vertex shaders. I have seen some games that use pre-baked animations for the ripples and stuff so they are not additive, and some games use the 2d height map fluid simulation. 

With those restrictions a large amount of game types would not be possible. But there are game types that already have static environments that could work well with this technology. Most likely developers who use this tech will use a hybrid approach of Point Cloud rendering for static environments, and high resolution polygon rasterization on the GPU for character and other dynamic objects. 

Hiding stats stops some casual players from optimizing their builds. However, it will not stop hardcore players from doing so. For example BF3 had completely inaccurate and misleading weapon stats ingame. There are sites dedicated to testing and analysis of all the weapons in the game with nice graphs and charts. This is the most popular one. $URL$ No matter how much you attempt to obfuscate what is happening behind the scenes people will do their own testing and figure out what builds are the most efficient for certain tasks. Hiding the stats in this way just ensures that the hard core players will have far better builds than casuals, further increasing the skill disparity. 

Make a rough guess on how many objects you will need in your game. Put 10 times that amount in the engine. If it doesn't run slow you are fine. If it runs slow, you might need to optomize, or you might still be fine. I would be more concerned with the logic having to iterate through a lot of objects than the a 2d render being slow. The only kind of culling that will be worth rendering is culling anything that is outside of the screen. 

For android it might be really hard to implement that control scheme as a lot of devices are not multi-touch. For the Ipad/iphone, you could have virtual thumb-sticks on each side of the screen reset their position when the users thumbs/fingers are placed down. 

I know there is Unity, and XNA that both use C#, but I am don't know what else I could use. The reason I say C# is that the syntax and style is similar to AS3, which I am familiar with, and I want to choose the correct framework to start learning with. What should I use to be able to do the most possible bit-blit(direct pixel copy) objects per frame. EDIT: I should not need to add this, but I am looking for the most possible amount of objects per frame because I am making a few Bullet-Hell SHMUPS. I need thousands and thousands of bullets, particles, and hundreds of enemies on the screen at once. I am looking for a solution to do as many bit-blit operations per frame, I am not looking for a general purpose engine. EDIT2: I want bit-blitting because I do not want to exclude people who have lower end video cards but a fast processor from playing my games. 

Definitely go with the Software Design course. The Advanced Graphics course is a class on advanced ray traced graphics which are more suited to pre-rendered 3d graphics. You also said you were not happy with your programming skill, and the Software Design course would help you increase your skills much more than the Graphics course. 

Do you mean spin? Spin will cause the ball to swerve in the air. In a true to life simulation, you would only apply a force to a spot on the ball from a certain angle, and the speed, spin, and direction would be determined from that. In this soccer game, I am going to assume the graphics are 2d, but the view is facing the goal, and the ball graphic shrinks to provide depth. So you need some sort of z depth at least. The Swerve, or spin, causes the ball to change direction after it is hit. This allow for shots that look like they are going to end up to the right, but end up moving left. So in the game make the swerve variable a float, and have it change the X direction on the ball, or what ever direction is left and right. 

Any wired Xbox 360 will work when plugged in to a computers USB slot. Windows XP SP 3, Vista, and 7 will automatically install the drivers for you. There are some wired controllers that specifically say "For PC" on them, but other than the packaging they are identically. It is a standard USB device, and you will not hurt the controller, or a computer you plug it into. 

I am not sure, but I think you have each sprite with an instance of its own texture. Meaning instead of doing 1 sprite batch, you are doing 2500 sprite batches. Try replacing spr.Texture with a single local Texture instance. Also you do arithmetic and call functions from inside the spritebatch function call, which could slow it down more. Try to have all your calculations done somewhere else, and try to store the rotations in the correct format instead of what you are doing. 

A deterministic game will only be deterministic when using the identically compiled files and run on systems that adhere to the IEEE standards. Cross platform synchronized network simulations or replays will not possible. 

Corona SDK I am surprised that no one has mentioned this one yet. It is a high performance 2d game engine that runs on LUA and is really easy to use. 

Blender 3D is open source, and free. It is a modeling and rendering application, but it comes with easy to use soft-body, fluid, and ridged-body physics solvers. You could set up a number of slightly different simulations, that match the dimensions of the area in your game, and export the animation data from blender to use in your engine. In the game, just use a regular pseudo random number generator, and select an animation that matches that number, use a few variations on each number to reduce monotony. 

That effect is 2D frame by frame pixel art. You could achieve something similar but I do not think it will be possible emulate that exact effect without doing it manually in a raster art program. 

High movement impulse, with high drag, will work perfectly. For collisions, you don't use the force that is being applied for movement in the collision calculation, you use the resulting speed, mass, elasticity, etc. 

Code via $URL$ Triangles are a bit more complicated, but this page explains two different methods on how to accomplish it. $URL$ 

First off, do some research on the psychology of gambling. You can't expect something that most of the time constantly eats your money without any reward to become addictive. Don't give out free rounds, give out money equivalent to free rounds. Have a constant streams of wins and losses Adjust the payout so that after 1000 spins, the bank is ahead, but not by much. Also it seems you have a enter bet, and then press to spin. You should have a few quick bet buttons, with a preset amount, that pays and instantly bets and spins. As well as a way to enter a custom amount, if you really need to have one. When the player wins, make sure to have flashing lights and bells going off sounds of coins falling, etc. If can set up an area in the world with lots of slot machines with different prices and rules, it will make it more likely that a user will move around to try change his luck or to have some variation. If you can sync these areas up to allow other users to see/hear winners it will also increase everyone's excitement. 

You need two booleans, and When the user presses the jump button, if is , and is false, then call which sets to If the player's velocity is positive then equals If the player is coliding with the ground, then isColidingWithGround equals , else equals . Sometimes the player is still in contact with the ground after the initial jump impulse, and I find that with using these two flags, it prevents jump() from being called multiple times when jump is pressed. 

$URL$ Looks like a good resource, with a list of over 30 different open source MUDs. Just for reference I found this by searching Open Source MUD on google. 

If you are doing blitting with then you should definitely pre-render it inside flash when the program launches or the level is loading Instead of changing the enemies color when hit, you should probably make a hit animation for the enemies and just play that animation when hit. 

Most FPS games use raycasting for the actual gameplay; bullets instantly travel and hit the target when fired. But most games also employ the use of "fake" tracers. Every 3 shots, or some other interval, a tracer will be fired along with the bullet, the tracer will be really fast, but not instantaneous. This is done as a visual effect only, and does not affect the game-play directly, but helps give cues to the shooter, the shootee, and gives bystanders a directional reference to gunshots. Most games that use these kinds of bullet physics are unrealistic, as there is no ricochets, no bullet fragments, and if there is any penetration its usually linear. Some games, such as ARMA II, STALKER(entire series) use more realistic bullet physics with travel time, ricochets, and penetration with deflection angles. I believe these systems are using raycasting, but with a limit that is determined by the speed of the bullet. With these games the muzzle velocity can be realistic as in ARMA II, or looks about right as in STALKER. I greatly prefer having realistic bullet physics, as guns fire projectiles, not lasers. 

The memory in the 360 and the ps3 is very fast, and expensive. If the amount of memory was higher on console launch, they either would have to raise the price or take an even larger loss per console sold. 

You can use really inefficient methods with any other programing languages too. Scaled Bitmap objects = really bad performance. Vector Gradient overlays = really really bad performance. If you want to use the flash native render, use non scaled bitmap objects, and any vector stuff, make sure you use a low amount of curves, with no gradients other than on a small amount of objects. If you want performance with better looking graphics look into Blitting, it is less flexable than the native render, but if you are looking for performance, you are going to have to use this. 

Original texture format does not affect in game performance There may be a small loading time difference, but that is likely dependent on what system you are running on. Use what ever texture format you and your artists are comfortable with. I would personally use png because it is losslessly compressed. Don't fret over a few milliseconds on texture loading, you are likely to save more time by using your own sprite sheets. If you really want to figure it out, profile all the different image loading techniques.