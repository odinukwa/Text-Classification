Functional issues Your code doesn't consider negative numbers to be integral. You're also missing support for things like for floating point. Ultimately, and might be better for your needs: 

Now, there's two issues here. In Python 2.7, gives you a list. The full list. That's hugely wasteful since you never want the full list, only the next element one at a time. For that, there's . Just swapping out those two functions: 

Comparing against (e.g. ) is bad practice. Simply say . It would also be clearer if the name indicated that it could fail somehow. Since already checks for null, could just be . Avoid declaring multiple things on a single line. This is especially egregious when you declare multiple things on a single line that is split anyway: 

(Although since both of those functions return by-value, you're making unnecessary copies here as well. Prefer to return by reference to const, and then don't alias them. ) 

This way, you can refer to or directly. The card suit should be an as well, instead of just an arbitrary string - it'll be easier to compare against. Also it'll make your life easier if you make the ranks just the values 2 thru 14. For example: 

Choice of Members You currently keep a head pointer and a length. The result of this is that is a linear operation. It would be much better to additionaly keep a tail pointer, so that is constant time. Since linked lists do not support random access, it's questionable to have a method like . If you need to index into a container, you probably don't want to use a linked list. Better to not provide it. Unfortunately, this is your only way to get anything other than the first value - which makes iteration take quadratic time! What you need to do is to do as the standard library do and add something like: 

Note that having a key type is highly questionable. Using prevents you from having to deal with any lifetime issues. Don't Repeat Yourself III Let's collapse all of our ers into a single function template. Because we can: 

Now you don't even need a custom comparator, or have to worry about (which you don't have in your code btw), or worry about how to copy this into another container. using I'd be surprised if you saved any characters with all your using declarations as opposed to simply typing everywhere. Using namespaces really isn't bad. Especially when you're talking about five characters... stick to the using declarations when you actually solve a problem. Don't use them to avoid laziness. Also lots of the time, you're writing anyway so I'm just confused at the decision. Your algorithm I, truly, have no idea what you're doing. It doesn't help that you have 6 members in your merge sort class, 4 of which are iterators: 

Having and is easier to grok than , which looks like a point in a path, rather than an individual coordinate of a point. You could split this up even more by putting the adjacent points in their own function: 

Don't Repeat Yourself The core of this problem is writing a line with some number of spaces and some number of stars. We have to do that number of times, for different numbers of stars and spaces, but it's really the same subproblem. You currently have this same logic in two different places - and it's fairly awkwardly written both times (e.g. why are you incrementing down from in the second loop?) So let's just put it in one function: 

you can simply declare inside the inner-most loop. Now, the slowest part of this function is . That's an expensive operation to do - so we want to do it as rarely as possible! As an optimization, we can check if first - so you avoid the expensive logic in all the cases where the outcome doesn't matter. If the product isn't the new max, who cares, right? That is: 

I'm not saying you should do this, but it's worth considering and explicitly ruling out. Move Assignment I would explicitly delete it: 

This lets you do things like drop the destructor, always a plus. Comparators Similarly, your comparators should be: 

If you always use braces, you won't run into issues if you ever add a second line to your code blocks. Also, one statement per line! Strongly prefer: 

That's it. Just implement in the right way. Deal with the busting logic elsewhere. Don't remove the aces and replaces them with 1s, just handle that in the function itself. This way, the function reads like the rules of the game, and makes it easier to understand. Booleans Python has for boolean logic. Don't use . 

Allocation The thing that jumps out at me most is the need for memory allocation to create a or . That's a performance hit, which is why and what will eventually be don't do it this way. It additionally makes the usage of the class a bit awkward. What I want to do: 

Save yourself the lambda. Second, you are using . That is the wrong checker for this problem. That function returns true if the two objects are the exact same object in memory. It could be true for primitives like ints, but it's not necessarily true. What you want to use is which will guaranteed work for numbers. 

That's nice and bite-size. This idea should get propagated through to so instead of starting with we call it (or or something equivalent suggesting that we're talking about single points, not paths). Global Variables Right now, your solver is a little hard to use. You have to call it, then separately, check some global variable to see the result. Global variables are bad for a lot of reasons that I won't get into here, but the important one here is: you want your solver to return the answer. So let's do that: 

We've now reduced dozens of lines of loops and variables, which are error prone, into a one line standard algorithm which is very easy to both reason about and for other users to understand. I don't know anything about chemistry, but I get this! 

Use a up front that you append to. This avoids having to do a branch. Keep a reference to the next min node - this makes you only have to append in one spot. Write a copy function 

Returning for makes sense though - as you may want to support the else case as a temporary. On the other hand, will only ever return so it should return a reference. is for type erasure Throughout, you use . But is for type erasure. It's for those cases where you need to store a functor. In none of your usages do you need this feature. At the most basic, take . Just take it as template argument: 

None of these is difficult to add - but there's no reason to do it in the first place, unless as an exercise. Naming Conventions is a common naming convention for types - but definitely not for member functions. It reads incredibly awkwardly. The fact that the Google Style guide suggests this is a huge knock against that style guide - especially since they differentiate the naming between different kinds of functions! Encapsulation is still a thing. Back-off The back-off algorithm should not be part of the , it's external to that. Otherwise, you're breaking the Single Responsibility Principle. Your lock should lock - your algorithm should backoff. Your use of is unnecessary as there are no references here - everything is a value, so it's equivalent to . None of your backoffs have allocated state, so simply passing them by value would've been also equivalent and less typing. But since logically there can only be one (or zero) backoff(s), prefer to make that much clearer from the interface by providing a default argument of your . Lastly, regarding previous comments about concepts and naming conventions, prefer push and pop: 

Although... Finding the best ranking, II Instead of taking all 5-card combinations of 7 cards and determining the max of that (which would involve 21 iterations), just determine the best ranking looking at all 7 cards together. That's the really the same amount of work as finding the rank for 5 cards at a time, but instead - solve the whole problem. Spacing There's a lot of places where you put spaces in front of parentheses or brackets (e.g. or or , etc.). Don't put spaces there. DO put a space after colons: so should be on its own line. There's a lot more to say, but for now this code is fundamentally wrong. 

Return or Output I feel like should either (a) simply tell you the max value or (b) give you the items that it used. Right now, you're returning (a) and logging, incompletely, (b). (Incomplete because if you use a fractional amount of an item, that's not indicated). I suggest you pick one or the other. If the former, basically just drop the s. If the latter, you'll want to return something like a: 

Next the main methods. makes zero sense as a member function. It should be a free function. Also you have 4 one-line functions that are all only used in one place. That makes it harder to read without adding any value. Just write them all inline: 

(Secondarily, I flipped the order of your arguments, provided better names for them, and am not limiting the value we're looking for to be a . Rather, anything that is equality-comparable to should suffice). The idea of using is that it, as a return type, already encompasses what you want in a single type - it tells you if there is or isn't a value (i.e. was found or not) and if there is a value, what it is (i.e. its rank). We however privately still need a value even in the case, hence the helper function. Altogether: 

You may want to rename to for convention. Similarly to . Clearing Since you are using smart pointers for your list, clearing is very simple. You don't need a loop at all: 

Algorithm is a breadth-first search + heuristic algorithm. The loop structure should look something like: 

So nobody wins and Jane Austen loses. What we need to do then is find all the voters for Jane Austen, and just adjust their votes. There's on such voter (), so we just "transfer" (hence "single transferable vote") that vote to the next ranking: Given the losers function, that would be: 

Check primality for lots of numbers Your original example wanted all primes under 30. The standard metaprogramming mechanism for getting all numbers under 30 is: 

First things first, PEP-8 recommends for variable namings. So definitely , , , etc. Also isn't a great name - what is the number doing there? Perhaps ? Getting all the Inputs will raise when we run out of numbers, and the conversion will raise if the user enters not a float. Rather than having a sentinel value input (what if I want to do ?), just use what the language already provides: