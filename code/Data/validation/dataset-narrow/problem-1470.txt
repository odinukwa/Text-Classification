I briefly discuss spacing, braces, and general readability. Then I open Eclipse and demonstrate [Ctrl]+a, [Ctrl]+i. This instantly indents your code according to a default standard (which is configurable). Since there are so many concepts to cover in class and limited time, this is one shortcut we take. 

In the software practicum that I teach, students develop new software for a real customer. My school has a standard software license agreement that the students, customer, and I must sign at the start of the semester. The agreement basically gives ownership to everyone involved. The software becomes, in a sense, open source. The agreement has two separate clauses. One gives more "ownership" to the customer. There is some flexibility; one past customer worked with the university to modify the agreement. Also, students could hire their own lawyers to represent them. But I have yet to see that happen. 

I think it depends on the goals of the course. Does your course have specific objectives for working in a team? Is the primary goal to learn some aspect of programming? I teach a software practicum course where students must collaborate like a real software engineering team using an Agile Development Methodology. All the work they do is shared. Learning to work in a team is an important skill. But if the primary goal of the course is to teach programming fundamentals, web development, game programming, etc., then I would lean toward individual assignments. It's so crucial to practice programming. You can maximize this with individual assignments. 

You've mentioned before that your students are adults who are attempting to make a career change to a programming role. With that in mind, I think the best thing you can do is show them how what you're teaching helps them achieve that goal. Think about it from their perspective: I'm an (older?) adult, who has had a "real job" for the last years. Now I'm trying to change careers. I want to know how to get a new job, and how to perform the tasks of that new job. So it's hard for me to sit in a classroom and memorize stuff from a textbook and from lecture slides. You and I know that memorizing that stuff will help them in their new careers, but that's not always obvious to students- especially novice programmers. So my suggestion is to always make sure that your lessons directly tie into their goals. Find out what kinds of applications they plan on working on. Make the first assignment a very basic version of that. With each lesson, build on that assignment so that every step gets them closer to a "real life" end product. Instead of saying "okay now you have to memorize that" and pointing to some lecture slides or a textbook chapter, ask "how can we improve our product?" and then show them concrete things they can do to make those improvements. The lectures and the textbook become references that help get them to their end goal, which I think is easier for professionals to digest. For a concrete example, let's say your goal application is a point of sale system. Maybe your first application is a command-line program that mimics a basic transaction. Then the next assignment introduces variables by having different items with different costs. Then maybe the next assignment introduces statements that apply coupons. Then you could have a lesson on creating a basic GUI, or using loops to repeat actions, etc. That's just a dumb example off the top of my head, but you get the idea: use your students' goals as a motivator, and tie your lessons directly into those goals. At the end of your course, students should have specific concrete usable information and a newfound ability to accomplish their goals. 

Paired programming is very effective at work too. We use Skype for Business to share screens (i.e., editor/output windows) and communicate in real time. If you don't have Skype, you can use Slack. Add GitHub or Bitbucket to quickly share code, and you have a very collaborative environment. 

My biggest challenge each semester is keeping students engaged in class. It's obvious that most of them would rather be somewhere else. I don't know if it's the students, my lecture, or both. I wish I had the resources to present a lecture this way. I believe that generating interest is just as important as the content itself, because this builds a passion for CS that will fuel future learning. How do you make your CS lectures more interesting? 

Recursion is sometimes difficult for students to grasp. It's important to understand the concept before implementing it in any programming language. My college professor said that recursion may not make sense today, next week, or next year. But one day it will come to you, maybe when you least expect it. I show this image to help students think recursively. Next, I'll start with a simple recursive program to calculate the factorial of a number. In class, I simulate recursive calls with pieces of paper. I start by writing fact(10) = 10 * fact(9) on a piece of paper. Then I write fact(9) on a new piece of paper and pass it to a student. The student adds to it by writing fact(9) = 9 * fact(8), writes fact(8) on a new piece of paper, and passes it to another student. This process continues until a student must calculate fact(1), which is simply 1. Then all the papers bubble back up to me, and I calculate the final answer. But even with these relatively simple examples, sometimes it takes time to understand recursion. More simple examples help. 

The best tutorial on pass-by-value vs pass-by-reference I've seen is Cup Size -- a story about variables and its follow up Pass-by-Value Please. These talk about variables as cups that can hold different items, and references as remote controls that you can put in a cup. You can have two remote controls in two cups that control the same TV, and replacing one of the remote controls with another one that controls a different TV doesn't affect the first TV at all. 

The idea would be to actually walk through the process of taking a big amorphous problem and breaking it down into smaller actionable steps, and then writing code to accomplish each of those steps one at a time. Spending any time on diagrams at this stage is, imho, wasted time. Students don't have a big picture yet, and diagrams aren't appropriate for the scale we're talking about at this level. Similarly, forcing students to come up with their own glossary honestly sounds pretty painful, and isn't how things work in the real world. I think that's what the answerers were saying. 

I really like Ben's answer, but I wanted to add my two cents: Like Ben and others have mentioned, Conway's Game of Life provides a "wow" factor that's useful in and of itself. It's simple to understand, and easily leads to pretty patterns and cool animations. This inspires students to want to play around with the code, which by itself is pretty valuable. On top of that, it leads to some pretty interesting more advanced topics, such as: Emergence From Wikipedia: 

Find the package in npmjs.com and view the stats (e.g., daily/weekly/monthly downloads). You can sort of gauge its popularity that way. Look for similar libraries and compare their stats. Look at the package in GitHub. View those stats (e.g., # of contributors, # of releases, # of stars). View the GitHub documentation (README.md). Is it helpful, mature, professional? Look at the GitHub commits. Are they recent? Is the repo actively maintained? Finally, just try it out. Sometimes you need to test a few libraries to see which one is better for your application. 

This sounds like a question of vetting. Here are some things I do when evaluating Node.js libraries: 

There are endless examples that illustrate selection. As you know, most useful programs have at least one selection statement. I've found that some students struggle with the concept, so I start small and pick examples that resonate with students, for example: 

Tracing helps students really understand what's happening in the recursive calls. It's also an important tool for when they develop their own recursive functions. If it helps to trace regular function calls, then it helps to trace recursive ones too. 

I built a light but fun AI project using the Twitter developer API and a simple Python program to bring my dog Maggie to Twitter. If you send a direct message to @maggielistens, you'll see what I mean. This program uses a version of an old program from the 60s called Eliza. It acts like a therapist by responding to your commments and questions. It uses regular expressions and text replacement to appear like a real person. It won't pass the Turing Test, but it's a fun way to get students interested in AI and programming. 

I don't know why you need to treat this as a separate thing. Include it in the "mini-reference" that you give them on the first day. 

I'd maybe suggest an exercise of splitting these kinds of statements up into multiple variables and lines of code. So take this line: 

Instead of using diagrams, you might have the students break the problem down into smaller steps and write those steps out in English, or pseudocode. The real goal is to get them to break the problem down into smaller steps though. You might go a step further and break the problem down for them, at least for the first few assignments. Break the assignments into steps, or split the project up into multiple assignments. Tell them what you're doing, so they see the process and eventually do it themselves. I'd also recommend checking out Processing. Processing provides a simplified reference which helps with the first problem, and it's visual which can help with the second problem. (It's much easier to reason about stuff you can see instead of abstract concepts.) There are quite a few questions and answers on this site about using Processing in the classroom, so I'd start by searching here. 

I stil think this is basically a duplicate of this question: Good datasets for intro CS courses? You're asking for a database of interesting data. The other question is asking about interesting data. The only thing you need to do to get from the answers in that question to the answers to your question is to write a little bit of processing code that outputs the data in a format that's compatible with a database. In other words, you're going to have to massage the data. This might require writing a program that calls an API to get data, and then outputs that data to files or more basic files or something. Then the students would take those files and work with them to create their databases. I think as soon as you accept the fact that you're going to have to massage the data, you'll open yourself up to a lot of cool data sets. I think restricting yourself to data that's already in the exact format you need is very limiting, and isn't how things work in the real world. In the real world, data is always in the wrong format. You always have to convert it to something you can use. Stop looking for data in the format you want it in. Start looking for interesting data, and then figure out how to get it in the format you want it in. 

If the system is object-oriented, you can use UML class diagrams to document the design. Eclipse has a plugin called ObjectAid that generates these diagrams from the source code (no additional work required). Students can generate professional documentation from their source code. There is jsdoc for JavaScript and javadoc for Java. These require specific comments and tags, but it's well worth it. Source code documentation is important for future development. For all types of diagrams, there's draw.io, Balsamiq, PowerPoint, Visio, and many more. A picture is worth a thousand words. 

I believe something is lost when you simply copy and paste code. They say that to learn a definition of a word, you read it, say it, and write it. So I think typing code definitely adds value, especially when IDEs like Eclipse have autocomplete and syntax checking. Typing is a learning experience. Unless you are copying from a raw format, copy and paste could bring in invalid characters. For example, try copy and pasting "hello world" from Microsoft Word to your favorite code editor. You'll see invalid double-quote characters pasted. 

It depends on the programming level of the students. In my case, students are just starting out with Java. I tell them to ignore the quirks and multiple ways of doing things (e.g., adding 1 to an int var). Find a way the works and go with it. Then discover the different ways as you progress with the language. These students are new to basic programming concepts and problem solving. Language syntax shouldn't stand in their way. 

Programming involves a mix of long-term and short-term planning. Long-term planning involves questions like: 

The use cases for loops in a command-line environment are not very engaging, but if you're stuck with "pure Java" then I guess that's a problem you're going to have throughout the course. 

You should teach nesting as soon as possible, as it's always a point of confusion. Start with nested statements above. 

So, students should use whichever tool is best suited to the particular problem they're faced with, or even a combination of both. It's not an either-or thing. I should also note that learning about one tool makes it easier to learn about other tools in the future. The carpenter learns about both the hammer and the saw, and that knowledge will later help them learn about wrenches. Similarly, learning both flow charts and pseudocode makes it easier to learn about other topics in the future. "This UML stuff sure looks similar to flow charts I learned about before!" "I need to translate this program from one language to another? I know, I'll translate it to pseudocode first!" 

I think you probably already know these. A university program gives you access to teachers and peers, and provides a structured environment. Self-learning allows you to learn at your own pace, and it's much cheaper but harder to "prove" what you know.