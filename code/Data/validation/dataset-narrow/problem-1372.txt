It varies based on time of day. For example, you'd expect to see more people in the US online at 7pm than 3am. I've seen activity measured at 15-minute intervals throughout the day and then averaged throughout the week. If you've got 5k invites and each person is online for 1 hour per day, randomly distributed, then you'd expect to see in the 200-300 player range at any given time of day. So really if you want to analyze the invite-to-active-player ratio you'd need more information: 

Basically what I think you're trying to do is compare two things: a game where your character has a relatively large number of base stats and everything is based off of a direct stat roll (canonical example being D&D) or a game where your character has a smaller number of base stats but a large number of "special abilities" or "feats" that give bonuses to a stat in a specific situation. And from your update, it looks like you are trying to compare these specifically with the design goal of portability between pen-and-paper and computer games. The design goal is important here, because either method can work in some cases but not others. Overall, for a PC game, the fewer your abilities (in total, including both the base stats and specials), the simpler the coding will be -- consider that every new stat or ability is basically an extra special case that needs to be coded. Since you mentioned Diablo, realize that this game really had a minimal number of stats, only a handful of special abilities granted by equipment, and that's about it... but also realize that as an action-RPG, an overly complicated and detailed system would just make the game much harder to play because the player can't process that much info in real time anyway. On the other hand, as you're noticing, fewer stats offers less self-expression through character creation (which may or may not be important to the system you're designing -- for a total hack-and-slash game, who cares about personality anyway?). That said, your main concern at this point should be what kind of system makes for good gameplay. Keep in mind that the ability to have a stat for every little thing a character might want to do is "realistic" but not necessarily fun; do you really want your characters spending half an hour making a series of die-rolls to determine the hardness and mass of their latest bowel movement? Decide what it is that is the "core" of the game, what do you want the players to spend most of their time doing, and then design the system and stats to emphasize the core. 

Not driven by a single game element, so much as the overall scope of the game. Arrived at mainly through playtesting, I think. 

Depending on the layout of rectangles already inside, if you find that brute-force is taking too many iterations (i.e. that there are too few valid spaces to put a new rectangle after some point in time), an alternative might be to iterate through the entire bounding box, making a list of all valid positions where the new smaller box can go. Then, choose a random element from that list. Worst-case O(x*y) time, which is at least better than the random worst-case O(infinity). 

Iteration on your design. Seriously, that's the best way I've seen. Allow time in your schedule to playtest the game on your own, watch playtesters with the game, and then modify the game based on your results. Every time you do this, the game gets a little better and a little more fun. The more iterative design loops you go through, the better the final game will be. The flip side is, know when it's time to kill an idea. Some things are just not fun no matter how much you iterate (I've heard this referred to as "trying to polish a turd"), and you just have to go back to the drawing board and start again. So in practice (in my experience, at least) it's a lot of trial-and-error, mostly, and when you do manage to find the fun it's pretty obvious that you found it. 

I've seen critical hits in some action-RPGs before, but usually for action-based games the numbers are kept intentionally simple for a reason: the player is busy running and jumping and dodging and shooting, and they really don't have time to do probability calculations in their head. So, you're more likely to see non-uniform numbers in things like turn-based strategy games. A typical example are "rogue-like" games (Nethack, Angband) which have non-uniform weapon damage -- one weapon might do 3d5 damage for example, and another does 4d4, and the game will tell you these numbers and it's up to you to decide which one is better (factoring in other variables like weapon weight, character proficiency, etc.) 

It's still around. We just no longer call it Shareware. We call it the "freemium" model: free to play but with premium content available for cash. The only difference between now and the old days is that we have better ways of accepting payment today: accepting credit cards over the internet (no more "mail a check to this address and we'll send you the full disks in the mail"), for example. 

IMHO, decent multiplayer is still an unsolved problem in the genre, due to the tendency for players to micromanage on their turn, thus making the game take forever. (An exception would be games such as the Advance Wars series, that are so insanely simplified and constrained that they can be played multiplayer in a reasonable period of time.) 

The easiest examples of this are two games that use the same engine, or one game that is a "mod" of another game (which is just a special case of "same game engine" really). And yes, of course you can do that. One of the Warcraft mods took away the concept of destroying the opponent and essentially created what is now known as the "Tower Defense" genre, which is a bit different from the Realtime Strategy genre. Portal and Half-Life 2 share their game engine in common; I'm not sure exactly what genre to call Portal, maybe a physics-based puzzle game, but I'd be hesitant to call it a pure first-person shooter. If you want to get technical, all games using, say, Game Maker are built using the same tools, and therefore share some of the same objects and behaviors. Or even games using C++ that are all using if statements, for loops and pointers, whether they be RPGs or FPSs or retro-arcade games. So it all depends on how loosely you define things. From the question title, I'm guessing that what you're REALLY looking for here is a general list of "game programming" tasks that are used in a variety of games, beyond just "normal" programming -- in other words, what functionality should be common to every "game engine"? And yes, there are a few things: random number generation; displaying sprites (for 2d games) or polygons (for 3d games) to the screen; ability to accept and respond to player input in real-time; collision detection; pathfinding; playing sound effects and background music. 

Coming from the C++ world, the general idea for changing languages on the fly is to have all language text in memory in a table somewhere, with each string (or sprite that contains text) assigned a numeric ID. All IDs are the same in different languages, plus a language offset. For example: const LANG_EN:int = 0; const LANG_DE:int = 1000; const STRING_HELLO_WORLD:int = 0; var StringTable:array /* of string */; StringTable[STRING_HELLO_WORLD+LANG_EN] = "Hello, World!" StringTable[STRING_HELLO_WORLD+LANG_DE] = "Hallo, Veldt!" This takes considerable setup time, granted, but it only has to be done once. Then, in your code, you just reference the table using the string and current language offset: myObject.text = StringTable[STRING_HELLO_WORLD+currentLanguage]; 

You could just as easily ask the broader question: should ANY software include a manual? Amusingly, there's an article on JoelOnSoftware about designing software so that the users don't need the manual: $URL$ While it doesn't answer the question, it hints at it: "Users do just-in-time manual reading, on a strictly need-to-know basis." I would say that is one reason why the game manual is important. It's a physical, tangible object that can be used as reference if the player gets stuck or forgets how certain commands work. (Yes, you can and should include this information within your in-game help system as well, but players don't always like to use that. For one, they might not be able to find it, in which case the physical manual is a suitable backup. For another, a lot of help systems require going through loading screens which seem slow to some players, so it feels faster to look it up in the printed manual.) The other reason is that some players DO prefer to read the manual before playing. Yes, you can include an online document on the disc, but it's easier to read a printout than a computer screen. For the sake of saving a couple bucks, are you going to take some nontrivial portion of your players and make sure their first experience with your game is frustration at not having a manual? There are other psychological reasons. A manual adds perceived value; you didn't just buy this disk with data on it, you also got this pretty book absolutely free! More to the point, manuals are so ubiquitous in games that if there isn't a manual in there, the player might assume this was a manufacturing error, and you can expect to be taking a lot of tech support calls (and handling a lot of returns) when players assume something was supposed to be there and was missing. 

The pitfall here, as far as I can see, is that you're treating programming and game design as the same task, when really they are separate tasks. As you suggest, this isn't a programming or algorithmic problem (you can code the battle system any way you want), it's about what is fun and interesting to the player. The answer is, look up resources on game design and game balance. There are actually universities that devote an entire four-year program of study to the topics you're raising, so just giving you a quick-and-dirty answer is impossible (the same way that you'd probably be stumped if someone said "yeah, I've got this idea for a game but I don't know how to program it, what should I watch out for?"). There are books, courses, and online writings out there about game design; seek them out. 

Unfortunately, job titles vary from company to company, so a "programmer/analyst" at one place might just be a fancy term for "programmer" while at another place it might involve the creation of software specs and design docs, and in another it might involve budgeting and scheduling. So "Programmer analyst" is vague - you really need to list your skill set. That said, can one transition from "programming" to "game programming"? Sure. Game programming can be thought of as a superset of programming: it's standard programming stuff plus the game-specific stuff (realtime input, graphics, networking, etc.). So, you've already got a foundation. Keep in mind: The game industry is insanely competitive. About half of the people in your class probably got into programming in the first place because of an interest in video games. Finding someone to pay you to make games is going to be an uphill battle. Especially if you have no field experience as a programmer, just a degree. (Real-world experience counts for a lot.) There's no rule that says you can't be a programmer by day and make games on your own time at night, as a hobby. In either case, take the time to learn how to do game programming (i.e. make some games on your own to teach yourself these skills). If you don't want to because it's too intimidating or just not fun for you, what do you think it'll be like when you have to do this stuff every day because it's your job? If you are determined to find a game programming job, there are a few paths from here: 

Every company's interview process is different, of course, but I think you'll find more similarities than differences between game industry programming, and greater software industry programming, in terms of what the interview is like. The biggest difference is that in the game industry, the person interviewing you probably won't be wearing a suit :) 

In addition to using additional differentiating features beyond color (such as shape or text), using a different amount of color saturation in different colors will make them look different, even if the colors themselves appear the same. 

Also arrived at through playtesting. Earlier 4X games actually did have quite a bit of micro-managing, and in fact it could be argued that for SOME players who enjoy that level of control, this is desirable. To cut down on this, it's generally a matter of simplifying the mechanics and automating certain processes. (Note that simply giving the player an option of full hands-on or automating is not optimal; if the automation is just as good as micro-managing then there's no point to letting the player take control, but if it's significantly worse then you punish players for NOT micro-managing.) 

I think it might be a simplicity thing. As a player, it's easier to think in 2D than 3D. The game I'm thinking of was the old FPS "Descent" which actually required navigation in all three dimensions. Great game, but not palatable for some players whose brains just weren't used to thinking in 360 degrees. 

This is a very common problem, and there are a few exercises to get around it that I ask of my students. Try this thought exercise: take one of your designs that's too big, and ask what you would do if you had to cut 90% of the features. Here's another idea: change your design so that the game could be played to completion in 5 to 15 minutes. Can you use clever design to restrict the scope of the game so that the play time is incredibly short -- a competitor of Minesweeper more than Final Fantasy? Identify the "core" of the game -- what's the one thing the player does over and over that's fun, that really drives the gameplay (or alternately, the one unique mechanic that makes your game stand out from the genre)? Implement that only, consider everything else as fluff. You can approach this two ways, either as a serious attempt to reduce a genre to its essentials, or as a parody of the genre that lampoons the inherent banality of the core mechanics. 

The first (unasked) question is, should you be designing the battle mechanics of an RPG before any code has been written, in the first place? Probably, yes -- but be aware that if you're making an RPG on your own or in a small team, it is not the mechanics or game engine that is the challenging part, but the massive loads of sheer content you have to create in terms of every single level, character, NPC, dialogue tree, weapon, spell, treasure chest... I don't know you or your team, but I run into a lot of students who want to make RPGs because they love to play them, so my first instinct is to make sure you know what you're getting into! Second, yes, I'd say that getting the game mechanics down on paper is a good first step. A good second step would be putting them in a state where you can actually test them "by hand" without writing code -- paper prototyping, in other words. Play out your combat system (or a simplified version if needed) as a tabletop game and see if it gives the player interesting decisions to make, and modify the mechanics accordingly until you reach the point where it works well. When the mechanics are fun, work on the balancing part, figuring out the exact formulas and numbers in such a way that the game is neither too easy nor too hard from a pure "stats" perspective. That would be a good time to work on the AI as well, to make sure that the enemies are choosing their moves in a way that dovetails with the stats-based challenge level. You can do all of this without writing a line of code, and it's a lot easier to change your mind and try out new mechanics when you can do it in five seconds with a pencil.