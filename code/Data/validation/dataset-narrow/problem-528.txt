Members Vs Globals It's odd that you have global variables defined in your Blackjack.cpp file. These: 

Your code is a little confusing. You're using names like and passing a to , which is then checking for 'aeiou' etc. I think of vowels as letters, so on the face of it you appear to be checking whole words against individual vowel letters, which probably shouldn't match. That said, maybe the file is ordered such that it's actually only reading letters at a time. Either way, your code is unclear. As has been said in the comments, whilst you've technically used threads to perform the printing, it's unlikely that this is the strategy that was expected to solve the problem. There are many approaches that you could take to solving the problem, one of which might be something like this: 

Naming As an aside, if you haven't already you might want to read some of the C# naming conventions. Although they generally only apply properties/methods, it's fairly unusual to see even private methods that don't use Pascal casing for their names. 

Naming I think you're naming convention is OK, it seems consistent which is the most important thing. Some of your names could be a bit more specific: 

When reading from the file, you create a new node and keep reading until you get to the last node, however you're allocating memory ahead of time. This means that when you read the last node from the file, is pointing some newly allocated memory that you've not put anywhere else. If you then add a new record, the pointer is overwritten and the memory is lost. This is perhaps a symptom of using global variables, which are much harder to keep track of than locals. Does really need to be global, rather than a local variable? static Where you're not going to be calling methods / referring to global variables from another source file, consider making them so that they're confined to that source file (you would then not include them in your header file). So, for example I wouldn't have in the 'main.h' file. It's not being called from any other sources so there's no reason to export it. I'd instead have the function prototype at the top of the 'main.c' file. 

This can be rewritten using a helper function (or alternatively a for-loop), which may look something like this: 

as you are creating as a copy of ; any change to changes as well. Also, you can iterate through your unique values in instead of checking if each element is in . Sorry I could not be of more help. Let me know if anything is unclear. 

I have written a script that I believe works and covers all edge-cases. I am curious about ways to improve upon speed. While the given example below covers a multi-dimensional array of , my actual use case will be (where depends upon the number of data parameters being searched). Given individual arrays of data points, the goal is to combine them into a multi-dimensional array and find the columns in which all conditions are satisfied. If the same column of each row satisfies a given condition, the index that corresponds to that column is output; otherwise, an error is raised. I have included a small named because it has many other functions relevant in my main code, though I've only included the parts relevant to the goal in this question. 

I am trying to write an algorithm that can find user-specified nearest neighbors. By user-specified, I mean that the user can specify whether it's a general nearest neighbor, a forward-nearest neighbor, or a backward-nearest neighbor. The idea for this code was inspired from this SO post. While it isn't ideal to search the entire array (perhaps use searchsorted as an alternative), I want to find all occurrences of the user-specified nearest value in the given data array. While there are other techniques that can be used to achieve the same goal (such as using the cumulative sum of differences of argsorted values), I feel the code below is easier to read/understand and is likely quicker since it performs less operations that require traversing the entire data array. That said, I would like to know if there are better approaches (in terms of speed) to achieve the same output, as this code will be applied to a dataset of at least ~70,000 data points. More than the value itself, I am concerned with the indices at which the values occur. 

The line will never be executed, so should be removed, it's just confusing. Include Order I always include system includes, before project includes. This is partly because I don't put includes in my header files, but it's also because I know that the system headers shouldn't depend on my headers, but my headers may depend on the system headers. Essentially, include files in the order the compiler is likely to need them. You should also pick a style. If you're going to include dependencies from headers then don't also include them from your cpp files. At the moment 'Circle.cpp' includes 'Point.h' which is also included from 'Circle.h'. When you're working with very large projects even this small duplication can add up to noticeable compile time differences. Polygon Your polygon class feels like an artificial abstraction. If you're not planning on adding any functionality to it, and you don't need something that can refer to 'Polygon's, rather than just 'Shape's then I would remove it. Naming You mostly use descriptive names, however should 'tempPoint' 

You have your own version of this, however I would tend to use the exact case where possible, which you haven't done. Your tests for ignoring numbers > 1000 only use one value (1001), only have a single instance of the value in the string and only have the value at the end of the string. This could be simply implemented as ignore 1001. Think about naive implementations when writing your cases in order to make sure the implementation does what's expected: 

One alternative method I have yet to explore is using set intersection/unions to find the same indices, though I'm not sure if that would necessarily improve performance. I posted a similar example some time ago, though I later realized the code had bugs and could have been improved upon as an example. 

Since I could not get to compute a derivative successfully, I wrote a script to compute it manually. Running the script below will output a plot of two functions and over the interval . 

However, I've heard that it is good practice to modify the bins such that the observed counts are above a threshold (typically 5, sometimes less) as a large number of bin counts below such a threshold can result in a bad fit (assuming minimized chi-squared). If the observed bin count is less than this threshold, then the bin is merged with the next bin. Assuming a distribution (such as a Gaussian) with a central peak, the next bin would be the next-right bin (i to i+1 bin) when the bins are left of the central peak while the next bin would be the next-left bin (i to i-1 bin) when the bins are to the right of the central peak. I've created an algorithm that I believe works and covers all-edge cases (assuming a single central peak). I was wondering how it could be improved in terms of speed/efficiency. I also feel like I am duplicating code using similar approaches in two while-loops; can this be averted? 

Exit You exit if there is insufficient memory to allocate a . The exitcode 0 is usually reserved for a successful program exit. You should be passing a different value to exit (usually a negative number) to indicate failure. Heads or Tails In your method, you're not updating your tail pointer, what is going to happen if the tail happens to be pointing at the node that contains the value you remove? Similarly, what happens if is pointing at the node that's removed? reset I'd honestly expect this to clear/flush/empty the list, not just reset the pointer that's used for iterating over items in the list. This is likely to be confusing. templates Depending on what it is you're practising for, a good next step would be to adapt your so that it can support a templated value type. You could then extend the list to store and retrieve values of any type. 

The workbook then has another worksheet for each tutor. The tutor worksheets are almost the same as the master sheet, however they have an additional column which is the total number of hours used by that tutor. 

Honestly, the amount of time you had initially to write the task is a side issue, you presumably had the option to revisit the code and make it the best you could offer before posting. Meaningful naming costs very little time and usually pays for itself with maintained understanding. It is the biggest step you could take to make your code more approachable. The more approachable your code is, the more value you are likely to get from reviews as reviewers will spend less time getting to grips with what you're doing allowing them to focus more on the how and why. 

Notice that the getters and setters come before the static methods. Generally they come first, then other methods come afterwards. Also you should probably have the static methods in another class, because is feels like a model object that just contains data. -> otherwise it will collide with get/set, you can see in your code that your get thinks the color is first time get is called 

As you can see there are no longer any magic constants. NOTE: EcmaScript 6 is possible, you just need to transpile it into EcmaScript 5 

Question Is there a better way to do this conversion, i know about , but since i need it for each key, then it is not really feasible. Also what Type would of be, i keep getting type errors when i try to give it a Type 

You know that for this that you want to get the and out of so you just return a new with and , the smart thing with promises is that is it a builder pattern, so can call again and now the parameter will be what was returned in the last , so all power is given to rather than 

You would want to change this value elsewhere. Maybe getting the colors from or a database etc. Lets do it with 

I'm not sure I really buy into this as an idea. I can see it being useful where you want to do things like collect validation errors, but I'm not sure I'd want it to be responsible for swallowing exceptions and putting them into a list. Also, in your method you're doing this: 

Parameter Validation It may seem trivial for such a small class, but depending on the use case you should consider if you need to add validation to your constructor. Is it really valid to construct a with a or empty string for example? As has been said by @Rick Davin, do you really want/need the setter for and to be public, does it make sense for a object to change its name? If it does make sense, then again, you should consider if rather than using the auto property you should be performing validation in your methods. 

Your class has a member which stores . However, in your method you're not using the stored value. Instead, you're working out the same thing and using that to perform the split. Either, lose the member from , or update to use the already calculated member value. 

It's quite an interesting plugin you've got there. This isn't a full review, just some initial thoughts I had while I was looking through the code. Constraints I've never used the @NotNull constraints, but from what I can tell they basically introduce compiler warnings so if you do something that could result in assigning a null to one of your fields marked with a @NotNull constraint you should get a compiler warning in the IDE. If you're paying attention to the warnings then you shouldn't really need to check for null in your methods (although I probably would anyway). If on the other hand you're not paying any attention to these warnings, then the constraints probably aren't doing anything for you. Responsibilities Your class is quite large. It seems like it's got at least two responsibilities. The first is maintaining the list of all nations and the second is supporting the behaviour of an individual , adding towns, relationships with other Nations etc. I'd consider trying to split this functionality into two classes. This would make each classes responsibilities more cohesive and easier to follow. Static State The map is shared across all instances of Nation. I don't really know much about the way Bukkit manages calls, but does it support any kind of threading that can result in multiple calls hitting your plugin at the same time? If it does you might need to protect the map with some locks. 

Since the sum changes with each iteration through your dictionary values of , I don't know of a way to pre-compute the right-side sums before-hand. This would be a little easier if you could use external modules. That said, you might see a slight speed-up if you use more comprehensions. For example, you can get via . Also, use (not ) to check zero equality and use (not ) to check . Also, you are iterating through all possible combinations. In the case of using and , you know that and . So you know that your lower bound is cut-off at 76. Those are 76 permutations that you do not need to use. You can include a statement at the lower bound since you are incrementing downward (), but I would instead use this lower bound as the starting point and iterate by incrementing upward as you may find some other way to restrict the sums in the upper limit. Lastly, the use of globals and non-descriptive variable names makes it hard to edit the code. For example, instead of , instead of , etc. Also, you can pass into . I personally prefer iterating over lists instead of dictionaries since you can use zip. I don't have a full solution for your problem, but it may help as a start.