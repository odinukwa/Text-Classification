Looks \$O(N)\$ to me, making your total time complexity \$O(Nm)\$ worst case. The other guy has 2 separate loops, one \$O(m)\$ the next \$O(n)\$, for a total time complexity of \$O(m+n)\$ or \$O(max(n,m))\$. Take home message: Ditch the \$O(N)\$ array initializer, it's not worth it. Use 2 separate passes, like the other guy did. 

Style Naming: You name your side-effect-free functions in a way which makes users think that they have side-effects. Instead of naming them with present-tense verbs, name them with past-tense verbs, like instead of , instead of , etc. Your indentation and bracket usage are spot-on unless otherwise noted. Errors 

I left in the debugging print statements as I feel that they make for reasonable documentation. Side note: Please use functions and proper variable names, like the ones I introduced. Note: This has not been tested with the UVA Online Judge, only on my PC. PowerShell screenshot of timed run: 

And why restrict yourself to arrays of ints? With generics, you could have the following modifications and make this rotation routine work with all types of arrays of objects (note that is not an object, it is a primitive type, you'll need to use , which is the object-oriented wrapper type for , instead of . Same goes for and other primitive types, you'll need to use arrays of their wrapper types, look this up). 

Suggestions I guess you are coming from a C/C++ background. Java arrays have a property called , which gives its size, so you don't need the parameter . Just use wherever you have used . I actually once thought that swapping the first element with every other element times was an original algorithm for rotating an array I had thought up myself, and it's in-place but this has a time complexity of . There exists a better algorithm working in time, which uses the idea: Instead of moving one by one, divide the array into different sets where the number of sets is equal to the GCD of and and move the elements within the sets. In Java, the code would look like this (note: This only does a left rotation): 

Again, is it worth it? Sometimes the clever thing is not to be too clever, and keeping it simple beats trying to make it pretty. 

Indeed, did you test how it behaves for very large (or very small) values, nevermind the performance? What will happen if I multiply by another one? What is supposed to happen? 

the else-return bloc doesn't serve any purpose. The same with calls at the end of methods (, , , , ): redundant. These methods are exited anyway. You don't need to use both and clauses. It's one too many. Eg.: 

A red flag goes off for me every time I get to hear "this class does this, and that etc." - this is at odds with Single Responsibility Principle, stating that class should only have one. Do one thing, do it well. The infamous suffix is a code smell, too. How vague is that? All too often it actually means "I had no idea how to call it". In this case it's more of a naming issue, really - your doesn't really manage anything, it just builds database connections. Not connection strings, but connections themselves. Correspondingly, I would rename it to or perhaps - since it's not parameterized - . It describes what it does way more accurately. I would also try to be consistent - if you have: 

There, I'll say it: it can't be done. C# doesn't allow identifiers to start with digits. All workarounds either won't meet all your requirements (eg. @radarbob's answer, while clever, doesn't let you narrow down numeric values to a predefined set of legal ones, which I understand to be your main goal) - or will get you on a ride that ends up back on square one (if you use a dictionary as @Malachi suggests, then the name of this dictionary will go upfront, and it still doesn't start with a digit). Underscore prefixes are as close as you can get. Abusing Unicode a bit might work to a degree: 

How do you know the method you're looking for will always come up first on the list returned by ? If you only expect one, use . But indicates you consider the possibility that more than one method matches your given criteria. So, do we have some guarantee it would always be the first one in our way, or are we just "feeling lucky"? :) This looks pretty fragile to me. This is subjective of course, but I have to say that since this method is actually less functional than and the implementation is rather brittle, I would personally veto this extension in a peer review, since I don't believe whatever readability improvement it brings to the table justifies the trade-offs. I think this is a textbook example of what Jon Skeet calls evil code. It's not wrong as in "doesn't work", it's sort of clever, its "magic" can even have some appeal to it, but it's fundamentally unclear and dangerous. I highly recommend this talk: $URL$ If you really want such syntactic sugar, I'd ditch generics and reflection-based approach, and replace it with hardcoded extensions for , , - come on, it's not like there's dozens of use-cases anyway. Oh, and have them return a to distinguish between input actually converted to the default value, and not converted at all. Like so: 

I know that you're supposed to create the slowest-growing function possible, but that doesn't mean you necessarily need to make your function the slowest possible (LoL!). As far as I can determine, your code for the Ackermann is mathematically correct - according to both Wikipedia and my (admittedly poor) sense of mathematical intuition. 

Type Coercion is not readable! Don't use implicit Boolean coercion of numbers in code which you claim to be "readable" - it isn't. Use proper comparisons in readable code, and leave the cool weak-typing hackery for the golfed version. How much does writing out the actual condition improve the readability of the code? Everything else seems to be fine - naming, indentation, and all. 

You'd retrieve the result with a dictionary lookup similar to . You'd simply do preceded by , where is the name of your dictionary variable. 

Now, you feel like you've probably lost all your beautiful formatting! Not to worry - to the rescue! It'll get you a containing the representations of all the elements in the , separated by commas and spaces with the whole thing enclosed in square brackets. So now we get to . Why hard-code ? I'll show how you can get the maximum number up to which to check for perfect numbers as a command line argument, and improve usability while at it! 

Type-alias to and import it to reduce some visual clutter. Also do the same with by aliasing it to to reduce visual clutter even more. 

I am going to focus only on the time aspect of your code, not the style or anything else, as that is not what you have asked for. i hope there will be others who will comment on that too. Obvious Culprits 

(This is in fact what I translated into Java, having coded this much earlier for a personal project). This is not as memory-efficient as @coderodde's iterator version, but it is algorithmically simpler and easier to understand, I hope. I put in a few tests in so that you can check that this code does the same thing as yours. Note that here you can replace the and with and to get an even more general version of the code which can find the Cartesian product of any collection of s. Here, you should also swap 

Because the last two lines of code are the same for both cases. Then there's the loop iterating over the nodes sort of repeats in and . It's a bit of an awkward construct... which you already implemented once as . Why not reuse it? The class can just iterate over itself: . The clunkiness of traversing the list node by node gets abstracted away. The main takeaway in my opinion is that you should start writing unit tests for your code. It not only helps to catch out bugs, but also implementation inconsistencies, as it forces you to think about the contract and all the edge cases. I'd also put more emphasis on making code documentation actually useful for a hypothetical developer who'd want to use your code. Try to put yourself in their shoes: would you be happy having these comments to figure out how to use the class? 

Correctness Does it even work? Did you write unit tests for it? For example I can't see where the method makes any use of argument (other than to assert it's not null). 

It's not bad already (save for the weird formatting of parameters, what's with commas at the beginning of the line? : ) But that's a matter of taste, and beyond the point). You could return to the trick you used in your previous implementation to avoid breaking the chain and get rid of value reassignments by pushing into the predicate, like so: 

We've cut on verbosity, but it's debatable to me whether it improves readability. It's harder to achieve the same thing for , although you could pull it through if you added a helper extension: 

doesn't make sense to me. When your code is conditional, DRY (Don't Repeat Yourself) and try to extract whatever is common for all execution paths. Eg. 

The last trick I can think of would be to convert these conditionals into instances, and pass them to the LINQ chain. I haven't got a C# IDE on this computer, so this code could be syntactically incorrect, but you get the idea: 

There's no use in putting "generic" in the name. Any C# programmer knows that indicates generics by itself. Case in point: in .NET we've got and - not . (So "drop the the" ;) ) 

isn't really ugly. It's a mouthful, yes, but that can be improved with better parameter names (something I'm not doing for you right now - I hope I've indicated how to do it on your own). Don't worry - you'll get used to it. I nowadays find that easier to read than a couple nested loops. Here's the current code (I might throw in more improvements later): 

The way you do it - you are reimplementing division and remainder from scratch with a loop. This is, well, useless. The way you're doing it right now is OK if you can't use the above (course restrictions?), which would have helped a lot in this case - you could have used it to get rid of the loop altogether, just looping over the allowed prices. What can be done for your code is moving out the part which reimplements division and remainder into functions and using them, but then there remains no difference between the way I do it and the way I suggest for you to do it here. (Note that the extraction into functions is necessary for reducing code duplication and extending your code to support more prices). Here is my take: 

For , an algorithm is to do it the normal, C (pointer-based way). Traverse the list maintaining references to 2 elements, the current element and it's previous element. At the element to be removed, set the field of the previous reference to refer to the element following the current element. This would work far better with loops than and . Again, imperative and functional don't really mix well in the same part of the program. Take a look here for a reasonable functional singly linked list in Scala. 

You have an unrolled loop, which is good for performance (especially because in Java the size of an is fixed to be 32 bits). However, you could consider turning it into a loop if this performance is not required, that would reduce code duplication. Which means that you could also try: 

The loop searching for the required number can and should be extracted into a function, which receives the initial value of as a parameter, instead of hard-coding it to 500. The timing and actual execution should be moved into a function, which is called using the standard script idiom of . The floor (or integer) division operator makes all those casts to redundant. Use a proper benchmarking toolkit for timing execution, with recommended best practices, e.g. . Last but the most important - the idiom is frowned upon in the community, when an equivalent can be used without control flow redirection. It makes reasoning about the code more linear. 

It compiles, since ᒿ != 2. But it won't work for every digit - see $URL$ if you want to try. Even if it did, I wouldn't recommend doing this in production code :) All in all it's a fun thought exercise, trying to find a workaround and kind of trick C# into doing something it's designed not to. But the truly elegant way is to embrace the language the way it is, and not try to hammer square pegs into round holes. If you were hell-bent on using extension methods, at the cost of being unable to rule out illegal values in compile-time, here's make take on it - more heavy-weight, but providing type and conversion safety. I did it for the heck of it, I know it's not the perfect solution. It resembles @radarbob's answer in that it puts extension methods to use. Let's define the basics (it can all go into one static class): 

You have not implemented exception handling (the last requirement). Eg. if calling code passes to or , it won't crash straight away, but as soon as you call , it will result in an unhandled once it gets to this null "fruit". Also note that we don't know what calling code may pass in as an argument - could be some object that implements one of the interfaces, but actually explodes once our code calls its or ... The requirement states that it's the responsibility of this code to handle exceptions, so if this was my homework, I'd prefer to be on the safe side here. Less importantly, you implemented as a property of rather than a field (which is what the description asks for), although public fields actually are considered a bit of a code smell, and a backing field is automatically created for properties, so I would leave it. Aiming at good code style you could make it immutable though (as a field, or a property with a private setter), and set it in the constructor - it stands to reason that name of a given fruit isn't subject to change. and could be too, but that's nitpicking already. Apart from the lack of exception handling, it seems okay to me. I like that you used some modern C# features to cut down on verbosity.