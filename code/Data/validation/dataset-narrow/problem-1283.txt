Game Maker HTML5 is supposed to have an "Internal code editor with user definable syntax colouring". So if you're able to write some Javascript on the client side, you can use socket.io. It's a node.js module that does WebSockets and way more, and it's really easy to use. 

No one can tell. Ten years is quite a long time when speaking about programming languages. In the beginning games were written in assembly, then there was a major shift towards C, then a major shift towards C++. There's arguably quite a big shift towards more "modern" languages (such as C#, Java, Javascript...) now that the mobile & web games market is taking so much space, even if C++ remains strong in the PC & console world. Is this situation going to last long, like in until-2022-long? Really, you shouldn't bet on it. My belief is that one of the main technical reason why we still stick to C++ is memory management: with consoles being so limited memory-wise, you can't afford to leave the memory control to a virtual machine. So if next-gen consoles come with a massive amount of memory, C++ as we know it might very well disappear. But it's even disputed if the next-gen is still a relevant concept. Maybe the living-room convergence people have been talking about for years will finally happen, and there won't be a market big enough to keep the AAA game industry as it stands now. Maybe cloud gaming will become the norm and games will be running on huge server farms that won't require such a fine-grained control of the machine. 

Unfortunately, Unreal doesn't make a distinction between the different kinds of iOS devices (they're all ), so you're out of luck. Also, when submitting an app to the Apple Store, you only have one build for all devices: you won't be able to do it manually by making two different builds. This is probably for a very good reason (Apple trying to keep compatibility between device types and iterations?), so double check that you really want to make a distinction. And if it's really the case, yes, you'll have to use some heuristic of yours, such as the display resolution. 

Ideally, your should have no explicit reference to its components: , , etc. It should rather maintain a list of pointers to a base class, ideally serialized from data: 

And it gets worse further on, of course. So if you're in this case, you might want to try some more advanced solutions. I suggest you take a look at Peter Freeze's article in Game Programming Gems 4: "2.3 Solving Accuracy Problems in Large World Coordinates". IIRC, he suggest a system that might suit your needs, it's indeed some kind of multiple different co-ordinate spaces. That's just some hints, you'll probably have to use some recipe of you own to get this running. Somebody that already implemented that kind of stuff might help you more. Why not firing an email to the guys behind Kerbal Space Program for instance? Good luck with your game! 

You need a combination of scale and translation matrices. You could first go to a "normalized" screen space (origin at 0,0 and scaling to 1,1) using, in pseudo-code: 

You could read some Gamasutra features. That's usually a good source of information, from people that actually ship games: 

The closest intersection (i.e. the smallest t) will determine which screen is touched, and your pointer position in room space. You'll then have to transform that position from room space to this particular screen space. You can create a transformation matrix from screen space to room space, and use the inverse to transform your intersection point. 

There's an implementation of runtime-compiled C++ for gameplay code here. Also, I know there's at least one proprietary game engine that does the same. It's tricky, but doable. 

If you use the linker switch, it is safe to link your application against DX11 .libs and run it under Windows XP, as long as you do not call any DX11 function at runtime. This is equivalent to using and , except that it is far more convenient: no need to go for the old-fashioned way. This is for instance what the UDK is doing. Make sure that you check the OS version before you create your renderer, and only use the appropriate DirectX version afterwards. Another common option is to use different executables, one for DX9, and another for DX11. This is way simpler to setup, but to stay user-friendly this requires a separate launcher that tests the OS version before running the right exe. 

Make sure is really a 2-dimensions array of size . E.g. if that's a plain old array of pointers, its declaration should be as follows: 

For the general case, it's probably possible to write an entire book about it, but my guess is that working with triangles instead of quads would already be a good start. 

The XML describes one instance of a mob, i.e. the traits of one specific mob (it's personal personality and intelligence). The Java class describes the general structure of all mobs (their traits: personality and intelligence). Typically, a game engine would serialize the XML data at runtime to create actual Java objects (= instances of the class). 

Find the path to the SDL.dll you're using, let's say it's . Possibly, you've added this path in some VC++ directories dialog. So Visual Studio tweaks your environment variable before you run the game through it. Or you've set the working directory for debugging your project to this path: by default all DLLs in the working directory can be loaded. You've got several solutions: 

You can start with a simple solution as the one exposed by tesselode or Mr Beast. But if you start mixing complex things, i.e. a bullet time while a slowdown spell is cast, you'll get stuck. I suggest you implement a clock hierarchy: 

If I recall correctly, there's a hierarchy of configuration files in UDK. At the lowest level you have BaseInput.ini, then DefaultInput.ini, and above all UDKInput.ini. Each configuration file adds/removes/overrides values of the one below with the following syntax: 

Yes, but only a bit. For game programming, especially gameplay programming, it's essential to have a good use case before writing any code. E.g. what is the player supposed to do, where is he supposed to go and how, how does he interacts with the world, etc. This can be a storyboard sketched on paper, or come out from a discussion with a peer... This is part of game design, and it'll be foolish to start coding without even a rough idea of how the game is supposed to be played. But games have to be created iteratively. You can't create a huge spec for your game and hope it's going to be fun to play. You need regular playtesting to find out what works, and what doesn't, and keep iterating. The quickest the executable runs, the quickest the game design can be tested, the best the game gets at the end. So it's always better to start coding ASAP, from a very non-formal game design, see what gets out, and keep going. One thing for sure, as you're coding alone, you don't need any fancy software design document or methodology, the source code is the design. 

Kickstarter and similar are all the hype at the moment, as you stated yourself you could try taking advantage of that, but be aware that this isn't an easy path to follow. Examples: OUYA, Occulus Rift (not middleware, but game-related). Charge for support This might be a good option. Release your engine & framework as freeware or even free software, and charge for advice or troubleshooting. Example: Torus Knot Software for the Ogre project. 

You could have a special kind of entity that plays an animation right upon creation, and auto-deletes when done with it. Just spawn it when you boss' health reaches 0. 

So yes, you're heading in the right direction with your method 2. Just overriding the values isn't enough though, you will get jumps on the client, what you need to do is smoothly & continuously interpolate to the server values. For your actual bug, I'm not familiar with Bullet, but you're probably missing some values e.g. you've set the linear and angular velocities, but have you set the accelerations? 

Depends on the context, really. You have several kinds of 3D, and a "3D game" can mean any of them. It could mean the game has: 

If you have the stick position and pointing direction, and if those are correct, one solution is to do a raycast. Create a ray starting from your stick position (O) and expanding in its pointing direction (D), and test the intersections against your 3 planes. Check for instance this blog post for the math: 

This is working but far from optimal. Quaternion multiplications mean tons and tons of operations. I was curious about various implementations such as this one, and decided to find from where those came. Here are my findings. We can also describe q as the combination of a 3-dimensional vector u and a scalar s: 

Of course you've got line segments instead of arcs, but drawing arcs in an HTML5 canvas kills performance, so I wouldn't recommend it. Just subdivide your sphere until the result looks OK. There's a bunch of 3D engines for Javascript that implement software rendering. For instance, you could have a look at Three.js for inspiration. That's if you want to do it all yourself, on the CPU. You could also use WebGL, there's already a tutorial for that. Browser support is not very broad yet, but it's supposed to be the future. 

Swing Swing Submarine published a bit of info for their Blocks That Matters sales. It appears that Steam and Indievania brought them more revenue than Desura. 

I have to put the emphasis one last time on this: communicate. Ask you colleagues, not only your lead, not only the programmers, everybody that will use or test or evaluate this system. Don't fear about asking stupid questions: when in doubt, it's always better to get the information right now than to wait weeks for a meeting or a review. The reality of game programming is that you're not going to create brand shiny new systems everyday, it's a job of keeping focus and getting the things done quickly and efficiently. Pull yourself together, get to work, and good luck! EDIT There's extra info I find useful in Leo's comment and dhasenan's answer, I'm shamelessly steeling that from them to complete this answer. I didn't write about how to deal with inter-dependencies. The module you're rewriting is probably deeply coupled with the rest of the game, that's why you get so many errors when changing something. So there's two solutions: 

If there's something specific to video game development, it's this: we're not doing rocket science, or a complicated research work, we're part of a creative process. When doing something, you have to craft a first version as quickly as possible so it can be tested, played, frown upon, and modified. You can't spend weeks doing "one very long piece of work" without delivering a bit. 

If you're OK with commercial software, it looks like this is the kind of things Natural Motion is selling with morpheme. 

Ha, found it with more googling. D3D9: call and check the of the provided structure. D3D11: call and check the of the provided structure. Video chipsets vendor IDs, retrieved from this list: 

This is the good ol' paying license, still a very strong proposition and the basis of most of the mainstream video games middleware. You're probably not in a position of offering only that, as you need a very strong and proven product to convince clients to pay directly for it. Examples: Unreal Engine, Autodesk Scaleform, Havok Physics. Freeware, Shareware 

EDIT 2 That's if you want to keep a "tiled" fog. Overlaying a translucent image as suggested by Panda Pajama in his comments might be a much simpler solution, but it will give you a different result. Once again, this is an artistic choice you have to make. 

If both methods give you the same result, and if you're not programming it, let your programmer decide. If it's easier for him to implement this one way, why would you force him the other way? 

Basically, RTFM. So either you work for a certified Xbox 360 publisher, and/or you're already in contact with a Developer Account Manager, but that would mean that you're already an established developer so you wouldn't be asking this question. Or you request to join the Registered Developers Program that allows indies to access devkits and the XDK. This is done simply via email. This seems to be less restrictive, but you'll still have to prove that you can make proper games (e.g. you have "personnel with significant previous professional game development industry experience"), sign an NDA, and probably purchase a devkit.