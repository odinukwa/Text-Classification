Remark 1: If the graph $G=(L\cup R,E)$ is bipartite, then the vertex-edge incidence matrix of the inequalities $x_u+x_v\leq 1$ for all $(u,v)\not\in E$ is totally unimodular, and one can solve the clique problem on induced subgraphs of $G$ via linear programming. Thus, for bipartite graphs $G$, $CLIQUE(G,k)$ has a small (albeit non-monotone) circuit. 

Footnote$^{\ast}$ The Bellman-Ford-Moore algorithm for this problem takes as subproblems $f_k(j)$ = length of a shortest path from the source vertex $s=0$ to vertex $j$ using at most $k$ edges. The terminal values are the lengths $f_1(j)=x_{s,j}$ of edges incident to the source vertex. The DP recursion is: $f_k(j)$ = minimum of $f_{k-1}(j)$ and $f_{k-1}(i)+x_{ij}$ for all $i$. 

P.S. [added 27.02.2017]: Here is my attempt to answer Question 1 (affirmatively). The idea is to combine a simplest version of the "combinatorial Nullstellensatz" with an estimate for the Zarankiewicz problem for n-partite hypergraps, due to Erdos and Spencer. Modulo this latter result, the entire argument is elementary. 

N.B. We can easily compute $\mathrm{Maj}(x_1,\ldots,x_m)$, if we allow additional boolean valued gates $[\rho]:{\mathbb R}^2\to\{0,1\}$ for binary relations, where $[\rho](x,y)=1$ iff $x\rho y$. Namely, we can first compute the numbers $z_i:= \sum_{j=1}^m [x_j=x_i]$, and then output the maximum or the minimum of $x_i\cdot [z_i>m/2]$ over all $i=1,\ldots,m$ (the most popular value, if there is one, is unique). So, my question seems like a "purely technical" one: the problem is that neither predicates $[\rho]$ nor multiplication by their outputs is allowed in tropical circuits. But then the question is even more "disturbing": how can we hope to solve "big" problems without being able to solve "merely technical" ones? I therefore hope that someone knows at least some "high level" argument(s) towards the NO answer. 

In Model Checking Recursive Programs with Numeric Data Types, Hague and Lin presented a NEXP-complete language under logspace reduction, called $ \mathtt{SUCCINCT~0\mbox{-}1~KNAPSACK} $ composed by strings \begin{equation*} a^m \# a^k \# \theta, \end{equation*} where $ \theta $ is a Boolean formula with variables $ x_1, \ldots, x_{m+k} $ satisfying that the string $ b \# a_1 \# \cdots \# a_{2^k-1} $ defined based on $ \theta $ (described below) is a member of $ \mathtt{KNAPSCAK} $, i.e. $ \sum_{i=1}^{2^k-1} a_i z_i = b $ for some $ z_1, \ldots,z_{2^k-1} \in \{0,1\} $, where $ b $ and each $ a_i $ are precisely $ 2^m $ bits (leading 0s permitted) binary numbers. The string $ b \# a_1 \# \cdots \# a_{2^k-1} $ is defined based on $ \theta $ as follows. Let $ (i)_{2,k} $ be the $ k $-bit binary representation of $ i $. 

It is not hard to show that $ \mathtt{SUCCINCT~0\mbox{-}1~KNAPSACK} $ can be reduced to NP-Complete $ \mathtt{KNAPSCAK} $ via linearspace reduction. Moreover, since any language in NEXP is logspace reducible to $ \mathtt{SUCCINCT~0\mbox{-}1~KNAPSACK} $, we can say that any language in NEXP is polyspace reducible to $ \mathtt{KNAPSACK} $. (Here we can combine logspace and linearspace reductions. Since the output string after logspace reduction can have polynomial length, we can use polynomial space overall.) 

$P_n(x)$ = minimum or maximum of some arithmetic combination of the subproblems $P_m(x)$ for $m < n $. 

Take now two new nodes $s$ and $t$, and draw an edge from $s$ to every node of $H_n$, and an edge from every node of $H_n$ to $t$. The resulting graph $G_n$ still has at most $2n+dn=O(n)$ edges. 

P.S. This "length times width" argument (when all $s$-$t$ paths are long enough) was earlier used by Moore and Shannon (1956). The only difference is that they do not allowed rectifies (unlabeled edges). So, this is, in fact, a "Moore-Shannon-Markov argument". 

Note that if $C_1,\ldots,C_r$ are all maximal cliques in $G$, then $CLIQUE(G,k)$ can be computed as an OR of $r$ threshold-$k$ functions, the $i$-th of which tests whether $|S_a\cap C_i|\geq k$. Thus, if $r=poly(n)$, then the entire circuit is of polynomial size. But what about graphs with an exponential number of maximal cliques? (A clique is maximal it no vertex can be added to it.) 

P.S. One obvious difference could be: HAM covers [n] by just one (long) cycle, whereas PER can use may disjoint cycles for this. Thus, to project PER to HAM the hard direction seems to be: ensure that the absence of a Hamiltonian cycle implies the absence of any covering with disjoint cycles in the new graph. Is this the reason for HAM not being a projection of PER? 

This language is in $ \mathsf{SL}^=_\mathbb{Q} $, the class of co-exclusive rational stochastic language (YS10). (More details were added below as Appendix 1!) A language L is in $ \mathsf{SL}^=_\mathbb{Q} $ if there exists a probabilistic finite automaton (PFA) $P$ defined with only rational numbers such that every member is accepted by $P$ with probability $ 1 \over 2 $ and every non-member is accepted by $P$ with probability different than $ 1 \over 2 $. $ \mathsf{SL}^=_\mathbb{Q} $ is also exactly characterized by 

P, NP, and NP-Completeness: The Basics of Complexity Theory by Oded Goldreich would be an another good introductory book. After introductory contents, I would like to also recommend The P=NP Question and Gödel’s Lost Letter by Richard J. Lipton. 

There are also some computational models: Here is the first paper: Rusins Freivalds: Ultrametric automata and Turing machines. Turing-100 2012: 98-112 

The language $ \mathtt{MOD_p} = \{a^{ip} \mid i \geq 0\} $ (for some prime number $p$) can be recognized by a $ O(\log p) $-state bounded-error quantum finite automata (QFAs) but the proof is non-constructive. The best known constructively obtained number of states is $ O(\log^{2+o(1)}p) $ for bounded-error QFAs recognizing $ \mathtt{MOD_p} $. REF: Section 4.2 of (Ambainis and Yakaryilmaz, 2015). 

As far as I know, it is not known whether $ \mathsf{NP} \subseteq \mathsf{IP(2pfa)} $, where $ \mathsf{IP(2pfa)} $ is the class of languages having interactive proof systems with some two-way probabilistic finite automata verifiers (Finite state verifiers I: the power of interaction by Dwork and Stockmeyer). Does anybody know any progress on this issue? I know the following results: 

Let $A(f)$ denote the minimum size of a (non-monotone) arithmetic $(+,\times,-)$ circuit computing a given multilinear polynomial $$ f(x_1,\ldots,x_n)=\sum_{e\in E}c_e\prod_{i=1}^n x_i^{e_i}\,, $$ and $B(f)$ denote the minimum size of a (non-monotone) boolean $(\lor,\land,\neg)$ circuit computing the boolean version $f_b$ of $f$ defined by: $$ f_b(x_1,\ldots,x_n)=\bigvee_{e\in E}\ \bigwedge_{i\colon e_i\neq 0} x_i\,. $$ 

One "obvious" obstacle is finite vs. infinite domain issue: boolean circuits work over finite domains, whereas Turing machines work over entire set $\{0,1\}^*$ of $0$-$1$ strings of any length. So, to derandomize probabilistic boolean circuits, it is enough to take the majority of independent copies of a probabilistic circuit, and to apply Chernoff's inequality, together with the union bound. Of course, over infinite domains, this simple majority rule won't work. 

Held $\mathrm{BPP}\subseteq \mathrm{P/poly}$ in these two semirings, this would mean that randomness cannot speed-up so-called "pure" dynamic programming algorithms! These algorithms only use Min/Max and Sum operations in their recursions; Bellman-Ford, Floyd-Warshall, Held-Karp, and many other prominent DP algorithms are pure. 

It is known that there are at least $2^{2^n/n^{3/2}}$ matroid functions; see Knuth 1974. So, matroid functions of $n$ variables with $B(f)\geq 2^n/n^2$ exist. (Clearly, even non-monotone circuit complexity of some such function is exponential.) 

So, the only "dangerous" in my question are polynomials $f$ with very large gaps $T(f)/B(f)$, like the spanning tree polynomial (where this gap is exponential): for this polynomial $f$, we have $T(f)=2^{\Omega(n)}$ [Jerrum and Snir], but $B(f)=O(n^3)$ [Floyd-Warshall DP algorithm for graph connectivity]. 

Edit: I choice the answer with highest score by December 06, 2012. This is a soft question. The concept of (deterministic) algorithms dates back to BC. What about the probabilistic algorithms? In this wiki entry, Rabin's algorithm for the closest pair problem in computational geometry was given as the first randomized algorithm (year???). Lipton introduced Rabin's algorithm as the start of the modern era of random algorithms here, but not as the first one. I also know many algorithms for probabilistic finite automata (a very simple computational model) discovered during 1960s. Do you know any probabilistic/randomized algorithms (or method) even before 1960s? or Which finding can be seen as the first probabilistic/randomized algorithm? 

Although this is not a direct answer to your question, I would like to recommend the following book: 

If the number of matrices is fixed (i.e., given a part of the input), then the problem was shown to be NP-complete in The complexity of the max word problem and the power of one-way interactive proof systems by Condon (1993). You can download the related technical report (1990) for free. The first paragraph from the technical report is as follows: 

The main credit should go to John Fearnley! Here is a PSPACE-complete problem given in (John Fearnley, Marcin Jurdzinski: Reachability in Two-Clock Timed Automata Is PSPACE-Complete. ICALP (2) 2013: 212-223): \begin{equation} \mathtt{SUBSETSUM\mbox{-}GAME}=\{ S~ \forall(a_1 , b_1) \exists(e_1,f_1) \cdots \forall(a_n , b_n) \exists(e_n,f_n) \}, \end{equation} where 

This rule holds also in the uniform setting: I admittedly used "$t(n)"$ for the size of circuits - this could well be the running time of Turing machines. The reason why this does not show the BPP = P lies in the inherent non-uniformity of what this rule delivers: when the dimension $n$ grows, we are forced to compute majority votes of growing sets of Turing machines. 

It is possible to "embed" $CLIQUE(m,k)$ into $CLIQUE(H,k)$ for a particular graph $H$ on $n=2^m$ vertices. In particular, Bollobas and Thomason (1981) have shown that, if $H$ is a Hadamard graph whose vertices are subsets of $[m]$, and two vertices $u$ and $v$ are adjacent iff $|u\cap v|$ is even, then $H$ contains an isomorphic copy of every graph $G$ on $m$ vertices. Can this fact be combined with Razborov´s lower bound (of about $m^k$) for $CLIQUE(m,k)$ to conclude that $CLIQUE(H,k)$ requires monotone circuits of size about $m^k$? A potential problem here is that, even though the graph $H$ "contains" all $m$-vertex graphs, these graphs are not on the same set of vertices. And Razborov's argument rquires that positive and negative inputs ($k$-cliques and complements of complete $(k-1)$-partite graphs) are graphs on the same set of vertices. Moreover, all positive inputs ($k$-cliques) are just isomorphic copies of one and the same fixed $k$-clique. 

What is the simplest computational model for which the emptiness problem is undecidable? Emptiness problem for a computational model (e.g. finite state automaton, alternating pushdown automaton, bounded-error quantum automaton with a counter, deterministic LBA, etc.) is to determined whether, for a given such machine, the language recognized/defined by this machine is empty. Here the description of the machine should be finite! I know that the word "simplest" is a little vague. There could be more than one answer for some incomparable computational models. As a special remark, I believe that the question would become more interesting by focusing on unary and binary alphabets separately. Note that there are many computational models for which the halting problem is decidable but the emptiness problem (and some other problems) is (are) undecidable, e.g. Linear bounded automata (LBAs). 

In the unbounded-error case, it is known that both realtime quantum and probabilistic finite automata can recognize some uncomputable languages if they are allowed to use arbitrary real numbers in their transitions (Rabin, 1963; Yakaryilmaz and Say, 2011). In the bounded-error case, we have a similar result for poly-time quantum Turing machines as well, i.e. the cardinality of $ \mathsf{BQP}_{\mathbb{C}} $ is uncountable (Adleman et. al., 1997). My question is whether any bounded-error probabilistic space (time) class defined with unrestricted real numbers contains an uncomputable (or a recursive enumerable) language. It is also known that (Watrous, 2003) if we restrict ourselves to algebraic numbers ($\mathbb{A}$), for any space-constructable function $ s(n) \in \Omega(\log n) $, \begin{equation} \mathsf{PrQSPACE}_{\mathbb{A}}(s) \subseteq \mathsf{DSPACE}(s^2), \end{equation} where $\mathsf{PrQSPACE}$ stand for unbounded-error quantum space. Any partial answer (for the case of bounded-error probabilistic computation using non-algebraic transitions) violating this upper bound would also be nice. 

(see, e.g. here on how this happens). Again, almost all graphs have $t(G)\geq n^{1/2}$. However, the best remains a lower bound $t(G)\geq \log^3 n$ for Sylvester matrices, due to Lokam. 

The "uniform convergence in probability" results from statistical learning theory yield the tool for derandomization. 

But is this (infinite domain) a real "obstacle"? By using results from statistical learning theory (VC dimension), we already can prove that BPP/poly $\subseteq$ P/poly holds also for circuits working over infinite domains, like arithmetic circuits (working over all real numbers); see e.g. this paper of Cucker at al. When using a similar approach, all we would need is to show that the VC dimension of poly-time Turing machines cannot be too large. Has anybody seen any attempts to make this latter step? 

Note that Question 2 still remains open: the "naive Nullstellensatz" (at least in the form I used) does not hold in tropical semirings. 

Concerning $Q1$, a word of caution is in order: even logarithmic depth if far from being understood, not speaking about poly-logarithmic. So, in the non-monotone world, the real problem is much less ambitious: 

One can define arithmetic analogues $\#C$ of most boolean circuit classes $C$ by just using $+$ instead of OR, $\times$ instead of AND, and $1-x_i$ instead of $\bar{x}_i$. For example, $\#AC^0$ circuits are $\{+,\times\}$-circuits of constant depth with unbounded fanin $+$ and $\times$ gates, and inputs $x_i$ and $1-x_i$. Agrawal, Allender and Datta have shown that threshold $\#AC^0$ = $TC^0$. (Recall that $AC^0$ itself is a proper subset of $TC^0$; take, say, the Majority function.) In other words, constant-depth threshold circuits can be efficiently simulated by constant-depth $\{+,-,\times\}$-circuits, with just a single threshold gate! Note, however, that my question is about monotone circuits (no Minus "$-$" as gates, and even no $1-x_i$ as inputs). Can one (last) threshold gate be so powerful also then? I don't know this stuff, so any related pointers are welcome. 

Appendix 1: More details on $ \mathsf{SL^=_\mathbb{Q}} $. Here I use another model, which is simpler than PFA to program in our case. An $n$-state Turakainen finite automaton (TuFA) $ T $ is a 5 tuple $$ T = (S,\Sigma,\{A_\sigma \mid \sigma \in \Sigma\},v_0,f), $$ where 

One-way alternating pushdown automata (1APDA) can recognize any language in $ DTIME(2^{O(n)}) $ (Alternation by Chandra, Kozen, and Stockmeyer, 1981). By replacing a pushdown storage of a 1APDA with a counter, we can obtain a one-way alternating automaton with one-counter (1ACA). My question is about 1ACAs on unary languages. Can 1ACAs recognize some unary non-regular languages? Note that one-way nondeterministic pushdown automata can recognize only unary regular languages. 

Most of its chapters are related to complexity theory. The book can be seen as a nice collection of the results from some important research papers. You can get the papers from the results! 

To get more, I think this paper is a good starting point. To check the related recent developments, I can also recommend to check the papers listed here: dblp: Christos A. Kapoutsis. 

Similarly, we can define some complete problems for each level of polynomial hierarchy (PH). But, of course, in case of being complete at some level of PH, we need to release the condition of having only two natural numbers after each quantifier. 

Just few remarks. First, I cannot quite see why we need a referee at all. If his/her function is known for the players, why then they cannot just simulate the referee? Alice sends $m_A$ to Bob, he (without seeing $m_A$) computes $m_B$, after that he computes $f(m_A,m_B)$ and tells the result to Alice. Perhaps you assume that $f_A$ is not known to Bob, and $f_B$ to Alice? 

Let $K_n$ be a complete undirected graph on vertices $\{0,1,\ldots,n+1\}$. (My apologies to purists: I should write $K_{n+2}$, but so is simpler.) By an $s$-$t$ path in $K_n$ we will mean a simple path from vertex $s=0$ to vertex $t=n+1$ (no repeated visits of vertices allowed). We want to represent these paths by $s$-$t$ paths in a DAG (directed acyclic graph) $G$ in the following sense. Each edge of $G$ is either unlabeled or is labeled by some edge of $K_n$. Multiple edges joining the same two vertices are allowed. A path $p$ in $G$ represents a path $q$ in $K_n$, if each edge of $q$ is a label of some edge of $p$, and each label of $p$ is an edge of $q$. The order of labels in $p$ is irrelevant, that is, it is enough that the path $q$ is represented as a set of edges, not as a sequence.