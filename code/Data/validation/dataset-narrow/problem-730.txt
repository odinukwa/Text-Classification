Slightly cleaned up version I took your code and made it more terse. a) There are a couple fewer fields now. Instead, they are accessors that calculate the same thing on the fly based on the minimal set of fields that store the state. As a rule of thumb, the fewer fields we have in our class, the easier it is to maintain correctness. b) Similarly, a couple of functions were erased/replaced with TS/JS alternatives that are available out of the box. This code is probably NOT fixing the "slowliness"/"glitchy" issues you mentioned, however it should be now a bit easier to debug the component since there are less moving parts. 

I am inclined to disagree. The test that verifies step execution order seem to be targeting the internals ("implementation details") rather than the contract. 

"Newspaper" Make code read top to bottom aka newspaper style ( is the entry point which invokes , therefore should go first). Forcing the reader to jump around the code is distracting from the act of active reading, therefore leading to avoidable complications. 

Your idea with buckets is a brilliant way to balance between the rigid upfront-allocated segments I described in "Even memory allocation scheme" on one hand and the bookkeeping-costly linked lists I am using in my code. Thank you so much for showing that! This is the most valuable part of the feedback!! 

There's function that takes a predicate to filter by. It's funny that your question mentions the filter word which happens to be the name of the function. Here's an example of usage: 

Overall, the code looks pretty good. Definitely much better than many other JS examples in CodeReview. A few minor points can be made though. DRY - Don't repeat yourself At the very minimum, you can reuse some code by encapsulating it into a function. You can define which will be responsible for the details of showing/hiding a section. The decision on whether a button/panel should be visible or not remains in the control of the caller... Variable naming Similarly, I'm unsure if the selectors and more than in one place... I personally am a big enemy of variables like , , , and so on. It's not so difficult to spell it out: . IE is a beast As far as IE page renderer goes, I can't provide much feedback because I don't deal with it. 

It is really hard to solve the problem since the question is not providing all the necessary details. Assuming you have a factory for your Http observable (call it ) you may do something like this: 

Injectable I am very positive your component does not have to be annotated with , therefore it should not be. The component is not really being injected anywhere, right? 

First of all, I recommend you to ensure your code is correct (see my comment on your question). Here are a few suggestions about improving your code. 

Since you're using / (which are great), I recommend being consistent about using carefully. Example: 

All these things seem very excessive and result in a messy code IMO. Update 1 Updated the code to use symmetric and based on the same encoding. Update 2 Frankly, I am not finding the updated question very explanatory. The signature of the original function does not declare meaningful parameters. So I had to guess what their meaning is. I also don't understand why a regular won't work for you. It's trivial! 

Became (longer because of the name, but the branching is almost eliminated by a ternary operator that cleans the input): 

My approach, design, implementation, and performance description I've solved a similar problem in the past and recalling the way I attacked it back then. To reach the bottom right cell, we need to either reach its upper neighbor and move down, or reach its left neighbor and move right. By induction, for the upper (or left) neighbor to be reached, we in turn need to first reach their upper or left neighbor and make a single move. And so on, until we find that we're at the top left position of the grid. If the "neighbor reachability moves" were recorded, replaying them in the reverse order results in the path we are after. Graphically it can be represented like this 

One thing I wanted to mention is . What is the point of it if you are not using with s? Knowing that is not a recommended thing in (quite limiting, huh?) I don't see any gains here. Why not consider sticking to s which allow you a lot more than simple ? You only need to remember to on the end caller site, and use / or wherever it's absolutely necessary. 

Context I'm playing around the concept of a Finite State Machine. While I understand the basic principles behind it, I want to implement a simple, yet generic class which could be reused in the future projects. Focus The code below intentionally separates the and interfaces from the class which implements them. This is done in order to distinct the from the of a given instance of the state machine. This also allows providing the minimum necessary information about the state machine when it's being constructed. In other words, this separation is on purpose. What I want help with, are a few things I either don't like or don't know: 

All of these scenarios are failures from the business perspective which only vary in scale. Here are a few techniques you may want to consider as countermeasures (you can search for more). Client-side filtering or Infinite scrolling be helpful for keeping the UX enjoyable. The infinite scrolling may be not very easy to implement very efficiently. Also, both techniques are unlikely to help with the responsiveness and stability issues in worst cases. Server-side filtering ("search") and Pagination are a couple of effective ways to guarantee that the amount of data given to the client has a controllable limit. These things require either the API changes or client-side changes or both. Disclaimer I apologize in advance if my answer is too broad -- your question does not include a concrete set of aspects you'd like to get covered in review and I tried to point out some small and some bigger things. 

Also, some of the elements that you access via jQuery, are static. There's no point in searching for them many times like . These instances can be hold in constants, so that there is a bit less code and a bit less calculation at run time. 

Feedback I am looking for Here's the list of things I am interested to hear back (in order of significance): 

Update It is indeed much better to avoid unnecessary loops. I'd still use a "registry" of known coins to keep code generalized: 

Another variant of the code I took your second (more functional) example and polished it a bit. *) The keyword is used instead of the in two places. This prevents accidental/undesired re-assignment of a value to a local variable. **) the type of the and can be inferred. ***) The is simplified, since already returns you a map object. 

the is now responsible for holding the data related to the specific Question (both, question and the list of answer with corresponding behavior). This is not really the "Strategy Pattern" yet, but it is a first big step towards it. In Strategy pattern you normally do not mix the data and behavior in the same class, but rather separate them. We declare a property that will hold the important dependencies (aka Services) that are required for a given Card to do it's work in answers' actions. This allows the card classes to stay regular TypeScript classes instead of being declared as services. This also means that the with the services should be provided from the outside. In TypeScript we can use the to enforce client pass in the context. 

Naming Things One, two, very-few letters long variable names are a bad practice. Even the things like indices can and should be given a real name. If something is called an , or , or , it should be treated as if the thing does not have a reason to exist. If a variable or a parameter exists only because it's enforced by a library/language (e.g. will give us an index and an object args), it is possible to explicitly show which of them are unused by naming them . This is a common practice in functional programming. A very nasty side effect of names like , , , is the added code complexity which appears out of nowhere. The code is not self-explanatory anymore, and dealing with it requires constant on-the-fly translation, which in turn makes the reader think about unnecessary details rather then the intent of the code. This is even applicable to the innocent looking variable/parameter, because without looking around nobody can tell what does the belong to... DOM and JavaScript Depending on the context, it may or may not be a good idea to manipulate HTML DOM directly via JavaScript/JQuery. Say, in modern single page application frameworks (like Angular, and similar) it's considered a bad practice to deal with DOM in the way it's done in the sample code. Even with these frameworks, there are exceptions of course, like the cases where one builds a widget library. Reduce Mutable Things Try to declare all your variables as when possible. Otherwise, make them be . Practice shows that the side effects and nuances of are in the best case not obvious to the most of JavaScript developers, and in the worst case -- very confusing. Terse Code Assuming it's okay to use relatively fresh features of ECMAScript 6, certain things may be written more compactly without losing readability. Syntax constructions like "fat arrow" (), spread operator (), string interpolation, etc. are extremely powerful. The fat arrow may be very effectively combined with /, , , , and many many other functions that can accept lambdas. Here are a few examples of slightly improved function. Notice that even this code may be further polished. processData