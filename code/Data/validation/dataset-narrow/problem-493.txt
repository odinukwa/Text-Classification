I concur with VisualMelon's observations on this constructor: there's no reason to prohibit empty inputs, there's no need to populate the pool yet, and there's no reason to require rather than . 

The first, obvious, issue is that generating the set in memory uses a lot of memory. However, making a lazy version is a bit more advanced, so don't worry about it for now. 1. Code to the interface, not the implementation 

The code is quite monolithic: calculation and presentation are separate concerns, and while I appreciate the context given by showing the presentation, it would be better to make clear that they're separate concerns by separating them with whitespace and commenting briefly. Also on structure: separate constants () from variables (, , ). 

Then is essentially but calling instead of doing a lookup in a map. This is arguably slightly more elegant, but does run into problems with stack overflow if is too large. 

I'm not familiar with Spark. It's obvious that this code isn't thread-safe ( isn't thread-safe, and is accessed without any explicitly locking), but I don't know whether Spark provides the thread safety. The cookie handling is missing two important parameters: 

Optimise algorithms before loops I've spent half an hour on the bus thinking more about the problem you're trying to solve, and I think that there are still algorithmic improvements which could be made before worrying about micro-optimisation. 

I'll give you one more hint about improving the complexity: the fact that they want the answer modulo 109 is a really big clue that you shouldn't compute it solely via . 

In my opinion the overhead of pre-calculating a value which won't be returned until the next invocation of is a trivial cost to pay for the simplification. 

Where are the comments to explain the meanings of the variables? We're forced to reverse engineer them. 

Secondly, doesn't seem to need to be a parameter or a field: the calling method never reads its value, and the called method always assigns to it before reading it. 

This comment is a message to you about how to use the template which some system (Leetcode?) has given you. It's not a message to the maintenance programmer about your code, so you should delete it as soon as you've implemented that method. 

This reinforces my first point about the type: the result is returned as a return value, but a very close approximation of it is also returned as a side-effect, modifying the argument! There is a case to be made that in computer algebra systems the majority (if not all) of the objects should be immutable, and the functions pure. 

In answer to your question as to alternative ways to make your subject pick up the changes: there are two options which I'd use before reflection. The difference between them is the direction of control. Option 1: callback. Make the static method take a third argument, probably of type , and call that action instead of . Option 2: event. Give an invoked by 

Just a minor note to add to the existing answer: can be constructed quite cleanly from standard Linq methods as 

There are two main tricks which you're missing: Caching In the extreme case that you're given and , you compute the 10000th prime 4000000 times. It hasn't changed. The method should use a persistent (maybe , but I suspect it would overflow) and only do any computation if the value isn't already found. Sieving Trial division by every number up to the square root makes sense in some contexts, but not in this one. Since you're computing primes in order, you can easily do trial division only by primes up to the square root. Note that since this means accessing the cache, it probably implies refactoring to inline into , since otherwise you have potential inconsistencies. Other notes 

This is a red flag that this code isn't yet ready for other people to review, because you don't seem to have reviewed it yourself. It's not quite the only comment, but there are only two more. The node class really needs explicit documentation of the invariants which are assumed to hold, because otherwise there's no way of checking whether the methods which modify it maintain / restore those invariants. For this reason also I would say that the code isn't yet ready for review. 

I find the variable naming a bit counterintuitive: why not name the variables in order and require ? But more importantly, the two calls between them take \$\Theta(N)\$ time, so the entire loop takes \$\Theta(N^2)\$ time. It would be asymptotically better to pre-calculate lists which give the minimum value in each prefix and suffix, because then the whole thing can be done in time \$\Theta(N)\$. 

Simple: don't repeat yourself. Here I'm not referring to copy-paste code, but to repeated calculations. How many permutations beginning is the code generating and then discarding with an on the second ? I make it almost five million. If the numbers include and , how many permutations beginning is the code generating? How many beginning is it generating? How many does it need to generate? So two keys to making it more efficient are to build the stacks up incrementally such that you only push an operator when there are at least two numbers on the stack; and to use a dictionary or some similar mechanism to identify expressions with the same numbers and the same resulting stack, so that only one of them is combined as part of larger expressions. One approach would be to only work with closed expressions (i.e. those which give a stack of one number) and to only combine them in descending order (since that's what we want for division and subtraction). As a bonus, this fixes something which IMO is a bug in the original program: Countdown doesn't require all 6 numbers to be used. 

I'm not seeing the point of or . The relationship between and is just the transitive relationship through , so the total number of lucky triples is the sum over of (number of which work with this ) times (number of which work with this ). Emphasis on number of: there's no need to generate an or to count them in any particular order. 

That's going to preclude an elegant solution (with or without Linq). In particular, uses O(n) space, so that's out. (So's ). Technically you could say 

Pretend for a moment that we're not using . The benefit of with something like image processing is that you can keep the CPU busy even when one of the coroutines is blocked on I/O. But half of the I/O has already happened (maybe more if you're always scaling down rather than up). If you want to make an async version, the image load should be async. 

Both of these issues can be finessed by limiting the muzzle velocity severely, but the constructor doesn't place any limits on muzzle velocity. In fact, it doesn't even complain if it's negative! I think an would be appropriate in that case. But just to make it clear: the main point here is that the calculation would benefit from some comments to explain the derivation (or point to a reference) and the limitations / assumptions. 

raises a red flag. Why isn't it using ? You write to a memory stream and then write the contents of the memory stream unmodified to a file. It seems that you could simplify this just skipping the middle-man. 

MSA? NSA? SRF? If you want to obfuscate the code, try putting Proguard or a similar tool into the compilation chain rather than obfuscating the original source... Also, Java conventions (which I think Android follows) are that class names should start with an upper case letter, so it should be (and there are some other classes which also don't follow the convention and should be fixed). 

As far as performance goes, it seems to me that with online judge questions in general you should assume that it's not required to iterate over 10^9 cases. I'm not going to describe an algorithm in detail, because that would IMO be missing the point, but ask yourself this: if the problem statement said \$1 \le N \le 1\$, would you still want to iterate over \$Q - P\$ cases or would there be a constant-time solution? 

However, is the correct type to represent a monetary amount. There's a case to be made for using to comply with the spec and then converting it to . There's also a case to be made that you should talk to the person who set the task and suggest improving the spec. 

Note: I don't really think is a good name, but it's not an easy class to name so I'm using it as a placeholder instead of . 

Should be a ? C# has had the keyword for some time now. It may make things slightly harder for review without an IDE, but most of the time it makes code more readable by reducing repetition. 

It's generally good style to use -style loops where possible, because they're slightly less verbose (and hence easier to read) and they eliminate some classes of error. 

As hinted in default locale's point 9, you're brute forcing over the wrong space. If your space is keys of length 4 from an alphabet of 256 values, that's a search space of 4294967296 keys. But if the ciphertext is 4000 characters, the 11-character crib gives you a search space of 3990 offsets at which the crib might be found. (Since the comments suggest that you really have a 16-character crib, you should use that instead to reduce false positives). In other words, my high-level review is that you should throw almost all of the code away and start from scratch with a different algorithm. Without filling in all the gaps: 

seems like a specialisation. Is the reason that you haven't made a version which takes a general YAGNI? There are a number of options here: 

The number of trailing zeros doesn't change when you mask away the ones above the lowest one, so I don't see that this is any clearer or simpler than