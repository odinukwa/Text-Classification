This bit of code is a prime example for what I am referring to, and is a good learning opportunity as well. Let's refactor it together. We will start with the sub declaration. As Mat's Mug will likely point out, you require 'WS as Worksheet' but this declaration is implicitly ByRef which means the object passed will be modified by any later actions on that object. To me, it looks like you are trying to use a Sub here to return a value (which is the purpose of a function). You have two options: 

We could improve this a bit further by employing the use of constant values and such, but overall this will point you in the right direction. Note that, with the improved code, I made sure to use clear variable names. Most users will understand what means in context, but is clear to any user. Even better would be so that, even if your reader was completely dumb to reading code, they would know what that variable was. Same goes for naming s, and s. Best of luck! 

The beauty of is that you can have code within the or you can leave them empty and only have code in the block. Arrays This is the meat of what you are looking for. From your code, it looks like you misunderstood how to use arrays. Basically, arrays improve performance when the computations are done in the array (this is because they are being done in-memory versus in-worksheet). When using an array for your purposes I would suggest setting the array equal to the entire range with your data in it. So for example, if you have a table on worksheet in `Range("A1:Z100") your array would be: 

As I noted in chat, you will want to pay particular attention to code smells. To start, make sure you read this article ($URL$ and his other articles as well. While some of this stuff may be difficult to implement at first, breaking bad habits now goes a long way. That out of the way, lets dig in. Hungarian Notation I used to be a big fan of hungarian notation. My code was riddled with oFoo and sBar. Hungarian notation is harmless, right? It wasnt until Comimterm pointed out to me that I had completely missed a potentially code breaking variable that looked like it had a type, but was never defined with a Type. As a result, I never saw it. Inevitably, I forgot to fix it too, and it came back and bit me in the butt. Why is hungarian notation so bad? I'm glad you asked. Most commonly, it allows us to become lazy as we are declaring variables. Take your classQueryMetaParameters class for example. The name in itself is a mouthful. If you create a new instance, you have to declare it as a classQueryMetaParameters and, to boot, you dont get much help from intellisense until you hit the Q. Second, within the class you have this little nugget: strDatabase. I don't know about you, but I have no way of fitting a database into a string. Of course this isnt actually a Database. It is likely a DatabaseName, or DatabasePath, or DatabaseSomethingOrAnother. Why don't we have to be a little bit better with our name? Because we could have a recordsetDatabase, and a strDatabase and the compiler will compile happily. The key here is this: you, as the programmer, knows what strDatabase means but no one else will. Trust me, when you have to fix the project a year from now, you will be kicking yourself in the butt. Defining Custom Classes This one I stole from @Mat's Mug so full credit goes to him. Frankly, I thought the suggestion was borderline cumbersome at first, but it has made a tremendous difference. Note the code below: 

Nine times out of ten, this procedure will do exactly as we expect it to. It will find the "bar" worksheet within the workbook running the code, and then rename that sheet to "baz". What would happen though if we paused our code after Activating the sheet (perhaps for debugging?) and then a different sheet was activated. Now we have a bug. This is easy to overcome: 

The firs thing worth pointing out is that you are ignoring a lot of special meaning with your current approach. Aspect ratios are a function determined by and thus we can use an aspect ratio and an inputted and to get the aspect we want, instead of looking through a list that are just saying the same thing in different ways. I took your original code and calculated each aspect ratio in order. Here are the results: 

Now you've really upset the worksheet. It has to update calculations, it has to resize stuff, fix formatting (if in a table), check number formatting, etc. It is a costly operation. If you're deleting a lot of rows...avoid it at all cost. Enter the world of arrays. Not only are they fast but they are easy. becomes . Once you load in the data to the array (Data) you can manipulate, access, delete the values all you want. The worksheet doesn't care. It doesnt see what is happening to the same data it was previously responsible for. Putting It Together I am not going to go through the code line by line, particularly because I already provided in-line comments to help make the code a bit easier to read. This will be a broad explanation of what the code does. 

I apologize for the very basic example of how this would work. I usually use this on pre-built Excel tables where I am extracting data from, and I use a class for this process to make it a bit easier on my end. These are the principles though. 

I highly suggest learning Type conversion functions as well. In Closing There is much more to learn beyond what I have highlighted, so don't get discouraged when, at the end of making these improvements, you still have more to learn. The key is to improve with a purpose. I strongly suggest learning about 'Clean Code'. I left notes within your code as well to help you along. The most important part is that you hold yourself accountable for improvement. I can honestly say that my code from three months ago is bad, and my code from six months ago is repulsive. If you can look back and not see the flaws within your code, you arent pushing yourself enough to improve. Best of luck! 

Open the Developer Window Press and then . Check the box for . While you're in there, I recommend going to the general tab and selecting under error trapping. 

Somewhat recently I encountered an issue where my projects were simply taking to long to run. A lot of my macro work comes down to taking multiple tables (generally formatted in the same way) and joining together these tables based on specific users. This led to instances of loops that would loop over one table nearly 100k times, searching for a value in a table of a similar size and it would do so repeatedly (10 times or more). I ended up developing the class below for this task, but I am certain that there are things I simply don't know, or could do better. What this class does is basically provide a Dictionary with some additional methods that allow me input tables and return a Dictionary I can retrieve values from. The main reason why I built the class was that I didnt want to keep writing loops that would simply loop over a table and add a dictionary with the only differences being the number of dimensions I needed. I hope this all makes sense. Any advice is appreciated! 

What I did is I still got the row that was needed, but now the error that would occur without the row is immediately surfaced. It may look the same, but by putting this approach into practice your code will naturally stop because the logic will tell it to since it will only continue to the next process within the if block. At first, putting this style into practice can be somewhat tedious. Where we could previous just use a mess of If blocks, we now have to use functions, and we have to consider how we want those functions to return variables. In the end though, this approach (at least in my experience) makes it much easier to surface the error where it happens, and to keep the code clean. I want to also note here that the practice of a Cancel method is dangerous, and is a code smell in itself. Cancelling the routine, if necessary, is innocuous. The danger comes in when you rely on Cancel. Finally, think of Workaholic subroutines this way: they may work really really hard, and they may do their job perfectly every time. But just because they can brute force it on their own now, doesnt mean they can do it forever. It is much easier to debug a team of subroutines, each with their own task and responsibility, than it is to look at the one guy who is responsible for ten different things. If you think of it in this way, it becomes much clearer why subroutines and the 'S' of SOLID becomes important. 

A constant () should follow the UPPER_CASE style. This makes it really easy to see when the constant is then used within the code. Special prefixes (, , etc.) hold special meaning, and should not be used within variable names. While it may make it look nicer, it will also make it more difficult for an outside reader to determine why the supposed is acting strangely, and they will assume that it is a bug within the language. They will not innately know it was a bug you introduced. 

Overall Observations There are a number of inefficiencies that are holding you back. First, you are still using , and . While there is a time and a place for each of these, it is preferable, by far, to avoid them. You can do this by fully qualifying your references. 

Which is fine if it is what you meant but it may not be what you meant. The thing is, not only do you not know what the Activesheet is at the time of the code running (unless you Activate it, which is it's own problem) but you also don't have control over the type going into Foo. It could be a String, or an Integer, or a Double. If you use it'll be a . will happily take anything you give it, which is a problem. To solve this, be smart about your code: 

Why is this little change better? It is using the active sheet! While not ideal, it at least ensures that points to the same worksheet unless we explicitly change the worksheet it is pointing to. It is stronger than the reference. Even better would be: 

Walk yourself through this, and count how many processes it is responsible for. If I was refactoring your code I wouldnt want to touch this with a ten foot pole. There is just too much there, doing too much at once. There are ten separate clauses, and at least a few cancels in here. This is a prime example of what subroutines are meant for. Consider this (somewhat hasty) example of using a function, and bubbling up the error at the same time. 

Neither of these changes will change the performance of your code, but it will make your code easier to read and understand, and it will start teaching you some coding habits that will be important later. Now, let's tackle that pesky . I must say, there is no habit that must be broken sooner than , , , , and . There's good reason why this is a bad habit. First, it makes your code unreliable. While the ActiveSheet could be the correct sheet, we have no way of absolutely guaranteeing. For example: 

Note the subtle elegance of the code. I didn't notice the effect this has when I first started writing classes in this way, until I had about 10 different classes and I had the RD explorer open. From top down: 

This will return a 1-Based array that you can then loop through. Now, for example, if Column "C" should equal "B" * "A" you can do this: 

This allows you greater control over your code, and reduces the risk of errors being raised. For more detail on this, check out this link: $URL$ . Dim Blocks This is a lesser known rule, but is is an important one to learn as soon as possible. Not only are blocks ugly they make it harder to see bad code. For example, how many variables do you have declared but never used? What about used and never declared? These are both code smells (with the latter being very likely to cause an error). To avoid this, declare your variables as close to their first use as possible. This comes with the caveat of not declaring them within Loops. Once you follow this practice, your code becomes easier to read and maintain. Variable Names Variable names should be descriptive, but concise. This sometimes can make it difficult to find the right name, but descriptive names make a difference. For example is a decent name. We know what it is. On the other hand is obscure. I have no clue what this means. When writing code I tend to think of my procedures as having and so becomes and becomes . This changes a bit as you get into and but, for in a simplified state this principle works fairly well. Dont only every use and though. There are other situations such as which is really a and (fairly strong) which can be . Loop Iterators Loop iterators get away with being able to be less descriptive. Using is generally fine (though if you need that many loop iterators, get help). Be forewarned though that is difficult to distinguish from and is generally used in equations. Loop Iterator Types As noted in another answer, the type of should pretty much never be used. That is due to the limit of an which is ~32,000 whereas the limit of a long is ~2,000,000,000. Yeah, is able to handle much bigger numbers. Option Explicit To say that is vital would be an understatement. I started using it, at the advice of others, and it literally has saved me countless hours of debugging for what would, otherwise be, stupid mistakes. You can type manually at the beginning of every routine, or you can use this shortcut to change the setting: 

The beauty here is that not only will our code raise an error explicitly related to the source of the problem, but we also have a very modular way of adding additional support. For example, if we wanted to support a worksheet (for whatever reason) we would want to update the error message, and add just a bit of additional code: 

Ok, so this ended up being a little bit longer/more complicated than I hoped. I will do my best to explain so that you can follow along. Please ask questions if you get lost or confused! Code first, then explanations: 

The Routine as a Tool Before I get into any of my suggestions below, I can't stress enough how important it is for someone to not use a 'tool' like this versus learning how to code efficiently. There are plenty of macro-recorders out there, and its nice to have something 'quick and dirty' when you're learning, or when you just dont have time to code it yourself. That said, I cant imagine a scenario in which using a tool like this is more beneficial to the user than learning the 'why' of what the code is using. That isnt to be harsh, or to say that this project is unusable. I am a huge proponent for writing code to learn how to code. In itself, this project has taught you about coding more than not writing it would have. Does that justify using this instead of continuing to develop as a programmer? Certainly not. In fact, I would give yourself, at most, three months before this project is dead. If, at the end of the next three months, you find this tool still useful then you are doing something wrong. Particularly, you are not yet using arrays for your loops, and as a result you are directly referencing the sheet. I can guarantee that, for larger loops, this is costing you time. For a bit of perspective, I can loop through 60k rows of data in a matter of seconds (if that). Try doing that with a range reference...well I would recommend not wasting your time. I can't stress enough: use this project as a learning tool, but not as a practical means of writing code well. Pet Peeves Most of the problems with your code are really stylistic choices, or decisions you've made that you just didnt have enough experience to know why they're bad decisions. Whenever I review code, I look for the things I used to do (and that were holding me back) but I just didnt know it yet. First: naming conventions. Spend some time learning them, and learning why they exist.