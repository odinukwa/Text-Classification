Those are two signs that you should not use but store the values as integers. You've already did that in , I'm sure you'll be able to do it for too. :) Smaller local issues Now that the main issue is out, let's look at smaller local ones. 

You can do better than declaring an epsilon constant: encapsulate the equality test! It's an implementation detail and easy to get wrong. You should care more about spacing: at least make it consistent, eg. avoid this: 

You said that the distance between two cities can't be guessed. Does that mean that is different from ? If so, the only thing you can do is to store nÂ²/2 distances, n being the number of cities (since ). If you don't want to have to guess which city goes first, you can specify some order: the first city in lexicographical order always goes first. 

Of course, you don't need to only use nested functions, you can also define or before defining . OCaml tends to only use functions that were defined "earlier", so using for this is abusing the system. 

You can use a tail-recursive function if you want but this won't help since you're probably going to overflow before doing a stack overflow. Purely functional from the outside Now the implementation seems functional but there's still this "memo" array that we would like to hide. Well, closures are the perfect way to achieve this. This is called the "pattern module" in JavaScript. Here's the full code: 

I didn't know you could end loops and functions with . Deleting the would prevent confusion with the syntax for classes. 

Adding the 'Z' means you're saying this is an UTC time, but it's not since you've used instead of . I live in UTC+4, and the you're returning is 4 hours off for me. getMetaNode 

In typical MVC, the model doesn't have to know about the controller: it's the other way around: the view and the controller know about the model. This allows you to test your model independently. 

It's up to you to see if you find it more easy to read. I'm afraid I can't help much with the way you use verlet integration. Last comment: Try to avoid passing the key events around too much, or try to be more 'semantic', eg. send to instead of . 

In a more "high-level" language, you wouldn't have to write this function, and it would be in the library. You can now rewrite your forward/backward loops easily: 

Come on, you don't need a function for those! Overall, don't be overwhelmed by my comments. The code is nice, but there a lots of little things to improve. :) 

The choice depends on your application. There are exceptions that you really don't want to catch because your program really cannot continue to work. For example, if your main task is backing up, what can you do if the folder is not writable? You probably want to say so to your user: just fail is it's a command-line app, and explain the error to your user if it's a GUI app. To be able to do that, you must be able to distinguish between various exceptions. The best way to do that is to only catch the exceptions you expect. For example, os.makedirs can only throw an OSError, so that's what you need to catch, as you did in . However, printing the exception is not engouh: if you catch it, that means you can do something about it. 

You're only focusing on one-letter edits here, but what about deletions, insertions and even transpositions (dog -> dgo)? The Damerau-Levenshtein distance handles them. And finally, is poorly named: I already know that the type change, I want to know about semantics! Something like would be better. 

It's OK to use , reimplementing it yourself won't save time, especially since the Python version is possibly faster if it's written in C. It's possible to be more concise and clearer though: . You should use a list of list to represent a matrix, not a list of dictionaries. As points out, is enough to populate . However if you're not familiar with list comprehensions and map, it's OK to use normal loops. Python doesn't really have constants, but a convention is to do and then use everywher, denoting that it is a constant ("verti" is not a good name, by the way, "vertical" is better. Use code completion.) is bad practice, you need to catch specific exceptions ( in this case). And you need to understand why those errors are thrown! This could be a bug in your code. 

The second option is better, because the possible error is explicit. However, in lots of case in Python, you should follow EAFP and go for the statement. However, we can do better. get(value, default) In BeautifulSoup, attributes behave like dictionaries. This means you can write to get the class if it exists, or the empty string if it doesn't. 

I have been facing the same issue for a few months, even though I didn't write that much functional code before switching. Please take my comments with a grain of salt even if I say "do this" instead of "this might help but I'm not sure". 

is statement in Python 2, but a function in Python 3. I'd advise you to switch to Python 3 since Python 2 will soon be the past of Python, and at least write things such as to prepare yourself to write Python 3. There are a few major differences and many small differences between the two version, so the earlier you switch, the easier it will be to get acustomed to Python 3. Also, remove debug prints when you don't need them anymore. 

Also note that you can evaluate XPath expressions using the standard , thus not needing rolling your own. If you need something else, maybe reuse the source code of to suit your needs? 

is not informative enough, try to find a variable that conveys that this url will let you fetch the repositories of an user. Did you consider that could contain a which would cause you to output wrong html? Fortunately, GitHub prevents such things to happen. Declare at the top of your function. Here's why. The way you're building your html string is dangerous. It's also hard to read and easy to get wrong. As Philip suggested, using some sort of template would be a good idea, but there's no way to do this in standard jQuery (jQuery templates have been deprecated, and the way forward seems to be JsRender which is not yet Beta). Fortunately, your code is not big enough for you to need that. Instead, use , and wisely: 

I'd like to focus on the function to make the work of codesparkle more manageable. :) Exceptions handling The first, high-level problem is the way you use try/catch blocks. Exceptions are not here to get into your way! They're great tools that let you write robust programs and focus on error conditions only where necessary. Writing "Problem opening file" and continuing execution as if nothing had happened is a really bad idea. The truth is that if you can't open that file then your program is useless. So you might as well show the error to your users and quit the program once they acknowledged it. I removed all try/catch blocks from the code since your function already says and because is not the place to handle exceptions. Declarations 

First, you might want to know about list comprehensions, this can be written as . Second, Don't repeat yourself! Having duplicated code increases the likelihood of errors, eg. when you only fix one part. It is easy here, you can simply move the loop out of the conditional. You can also use a regular expression to remove the conditional entirely (untested): 

Please don't do that! You're not gaining anything, the first reason being that it's going to fail very quickly if you really get or . The second reason is that there's no reason to get null here, why would that happen? You're simply calling this function from , it cannot be null. When not for useless optimizations, this practice is called defensive programming and is only useful in a few specific scenarios. 

Please don't use global variables, you don't need them and they only clutter your code. The good thing about a function is that I can understand it by only looking at it. With global variables, it's not true anymore and I need to be aware of all those variables. 

You're going to block everything while the requests are done. I think using threads could help, but that's probably overkill here. 

The first thing to do is to profile your code. Hashcash is really designed to make you perform 2^20 hashes: if you do more work than those hashes, something's wrong! Profiling 

Wich is nicer as you don't have to worry about the extra space between the two values. Encoding You don't need to convert to UTF-8 before writing the file back. What's wrong with ? 

Thanks for sharing your code! Let's see what can be improved. Design You're mixing a lot of things in your code. This makes it difficult to read and write. It also violates the Single Responsibility Principle. I'd recommend separating those three "responsibilities" in different functions/classes. The easiest way to do it is to have three functions: 

In your specific case, the second snippet shows the best way to go as your code is simplified and makes more sense. Make sure to seperate two if blocks when they're not the same, otherwise they might look like if/else and confuse anyone reading that code (including you in a few days!). 

Defensive programming is not recommended in Erlang, which means you could/should remove the and clause. Using lists:nth is generally bad practice since it has a complexity and this means using your list like an array. For fixed-size lists, use tuples instead. Here's an example: 

No, it's not bad per se. You did an excellent job to keep the nesting under control with those helper functions, and the code is actually easy to read and follow. 

Warning: I'm going to nit a lot about accessors: it's important to think about them and not blindly add a getter and a setter for every value. 

Nothing much to say here, so I will talk about coding style. :) PEP 8 says that you should write . If you don't like it, you don't have to, it's just how most Python coders write code. Second, should be . Third, PEP 8 says you need a double space before inline comments (). Fourth, this isn't really a comment, and would be a better fit in the docstring. Fifth, about indentation: don't mix tabs and spaces, and no trailing spaces after your lines. (You didn't have any trailing spaces in this function though). 

A default constructor is provided by Java already, only use that if you need to put something in there. 

The issue is that is less readable than , so if you want to create a new variable, make sure that the name carries your intent. You can go for "normalizedState", but since you're only trimming (and are not normalizing capitalization for example) then a variable is useless. 

You can then compare this to the time it takes for your program to complete, and see where you're losing your time. Another option is to use microtime to benchmark the time you take to actually do computations, and the time to and . Optimization, what for? Since it's probably a one-off script, why do you want to make it fast? Once you have your ngrams, you can reuse them and forget about this script. Is there a good reason to improve this script? If the problem is more specific than "takes too long", than we can help: too much RAM? takes months? Specific strategies can help for specific problems. 

Make sure to use whenever possible, since it doesn't do type coercion and avoids bads surprises (I think the only correct instance of == is when you get an integer value as a string from your html and want to avoid using ) Consider using a switch statement over the value of button. (And test if the quantity > 1 inside the switch statement.) 

is indeed an interesting optimization (x2 improvement). It would be more readable to make m go from to . You can avoid computing . is enough to compare the distances. When printing the distance, you can use . First set to , this will avoid you the case and the resulting duplication: you'll always find a distance shorter than infinity. 

It now works on all types supporting . size_t I think is more idiomatic than for your M matrix, since you're not storing a size but a distance. Performance: You could improve memory usage by storing only two rows of M. But this would prevent your from backtracking to print the alignment, and isn't a huge win anyway (except if you're working on very large strings). General comments Your code is really straightforward and well-written. The algorithm is simply translated, and the rest of the function is simply the initialization: there's nothing complicated, and the code is easy to read. Good job! 

The point is to run the profiler after each optimization and try to see if there is a new bottleneck arising. 

I prefer handling error cases first, even more so when they are really short. It helps knowing that the is the normal case. When putting the error condition last, you can not see it and have to remember "maybe there's something else", which is cumbersome. For example: 

Consider using XSLT 2.0, which can't hurt but could help if you need a XSLT 2.0 function in the future. Also note that you don't need since you're outputing text. Ditto for . 

Blame the tool, but keep your code DRY. The best solution would be to find a way to launch the debugger whenever an ASSERT fails. You could then use the backtrace and select an upper stack frame. Even if it's not possible, you still have access to: 

Typo! To avoid this, you should use a variable: or and . Any typo will then be catched by Python when running the program. The uppercase is just a convention to say it's a constant. Unfortunately Python enums will only be usable in Python 3.4 which is will only be available in three weeks. And Python 3 is incompatible with Python 2, so it may not be practical to switch. Exceptions 

The point of exceptions is that you can catch them anywhere in the code. You can catch this one in as you did, but also in and even when calling . That is, you could write: 

(I don't know about your application, but I guess can never be called when we're already in front. If it's not true, then we need to keep and which will call themselves.) At this point, I have two big issues left: I don't know how to decide what is the other side, and I don't know how to get its name (, used in the call). Since I don't know about this, I decided to resolve another issue, even if it is minor. This issue is that the logic looks wrong. It would probably be simpler to use something that is more than a value, and HTML5 data-* attributes are perfect for this since they are key-value and supported by jQuery. You can then replace the last five lines by this single one: 

This only makes sense if the view is a kind of GUI which can throw events at the controller. I don't think it's the case here. 

Since you're in the context of your application, is it possible to give a more meaningful name to the function? 

Nope, I think using the name is a good idea. It's a common way to provide replacements in Python, and this is way the standard library does things. However, you need to do things correctly. Again, see the "Boilerplate" section above. Oh, and PEP 8 recommends against underscores in module names unless it improves readability, but I think is readable enough. However, simply adding in front of a module is not such a good idea, because you just lost an opportunity to explain what makes your lxml different. Since it seems specific to the file specification you use, why not use that in the name? 

You can notice that the if blocks are still repetitive. You can use a dictionary to store the shipping costs. 

the expected and actual values, which lets you easily find out if it's the call with 1, 2, 2 or 0, 1, 2 that failed; the test name (doesn't seem to help much here, but would help if you called your helper function from multiple tests.) 

should return a boolean The following code has unneeded parentheses. This is defensive programming, and I don't think it's good practice. If $arrSearchCriteria is not an array, you should fail hard, and not let this go unnoticed, since it will probably happen only during development. 

The code won't be perfect after those changes, but we're getting there! I think the data structure would still need work, because while is now fine, will still be weird in the sense that it only looks at and and discards the rest. Just like , it works, but it's a code smell. 

This script is insecure because there are a few small issues. And such issues can often be combined to produce bigger issues, so it's important to be wary about them. First, you're not restricting the path of the image to . An attacker can ask for . It will fail because you check that the id ends with '.jpg'. But what if the user sends ? Did you check that is not going to try to split on a comma? A simple fix: get a list of all possible file names first and only allow an id which is in the list. Second, you're sending the full answer. I don't know how this utility works, but an attacker can probably gain useful information just by looking at the output. He will know that he should look at vulnerabilites. More generally, any information sent to an attacker is another thing that can be exploited. Third (this is not necessarily an issue), but it's possible to list all files by simply trying all combinations and see the output. It's even possible to see what's already converted and what's not with timing attacks. I'm not saying that fixing these issues will make your code fully secure, but it will be a step forward.