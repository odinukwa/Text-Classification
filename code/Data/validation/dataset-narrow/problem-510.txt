too many hardcoded strings Technically I find it's ok but to my taste there are too many hardcoded strings. I wouldn't say anything if it was just data but since they are property names I don't like them being strings. You could use to replace them with something more dynamic but then the test would not be very readable anymore. 

This method should be a static one because it doesn't require any instance data to work and much less protected. Are you really going to override it? 

ViewModels What about the views? You don't need three of them. I guess you have three categories. You add one category and you need to create a new view for it and adjust all your queries - a lot of work for a small change. I find you should have only one view-model with a single view that can recursively (or with a stack) display all categories. You start with the ones that have no parents and and get then the ones that have this one as their parent and so one until you have displayed them all. A new type for the results: 

This can be use just like a so we can put it inside and rewrite the method for enumerating paths like this: 

Consider splitting the method into smaller pieces. Each piece should configure only one entity at a time. You could write them as extensions so that you an chain them: 

Your doesn't have to be . You are not using any resources and clearing a dictionary isn't doing anything useful. 

Most properties have simple requirements so it should be possible to register their Dependency Property fields declaratively. I made a small experiment and it seems to work just fine. The first attempt supports and attributes. It looks a little bit like JavaScript ;-) 

If you define contants then you should decorate them either with the keyword or the one. By doing so you clearly inform that this value naver changes and you also cannot overwrite it by accident. Overall your code isn't bad. I find you use very good and meaningful names, early returns, not too much nesting. Just a few more helper variables like @Maxim suggested and it's fine. 

This null check shouldn't be there. It means that the method can return a null. The .net's convention is that in such a case an empty collection should be returned. 

You should avoid unnecessary nesting and turn this condition into a positive one so that you return whent the value is null-or-empty: 

Because your models are tigthly coupled. You need to loosen them by introducing some abstraction - either an interface or an abstract class. All your model names sound like base classes. What is a ? What is a ? What is a ? Those are very general concepts and you alredy try to differenciate between them by setting a of a - whatever the value means. You should find a better name for it - or a different . (Further reading: The Open/Closed Principle) So instead of creating a for each dungeon inside of a constructor consider this design: make the dungeon abstract: 

The fastet version should be however this LINQ free one. Here you import the lists directly into the hash-set. 

We do not return from methods (unless it's a factory method). You should return the actual result or fire the event there. 

I find you did well. Especially using the helper variables to give a meaning. As the other answer suggested it's technically possible to use but then you don't know what is. Using helper variables is always a good thing and you should keep it that way. Don't make it short just because it's possible. It's better to write a little bit more and still know what you did few weeks later. 

In your example calling is unnecessary too. The group is already created and calling just enumerates it again. 

BuildQueryURL method This method is in a very bad style. It's supposed to build a query url but you give it a name-value-collection that you modify it inside the method! You should split it into two methods. The first one should only and the other one only build the url without modifying any other values and causing unexpected behaviour. I'd be really supprised if I used it and found that it actually changed the parameters too although it's name doesn't suggest anything like that. 

method should not have side-effects. This means, as far as possible, it's always better to use pure methods. Applied to your code should return some result, e.g 

Ok, with the new design both services can still send messages but you can send a new message each time instead creating a new instance just to send a new message - so they are now real notification-services and not just notifications. 

It's pointless to have both the constructor and a get/set property. Make the property either readonly and required via constructor or leave it optional and get rid of the construtor. 

Here you could split the logic up into multiple methods for example you could have one generating the alternating sequence that you can validate with a test: 

I want to make the creation of the pack Uri for WPF resources more verbose so they are easier to read and less error-prone and I thought I implement it using the builder pattern. 

This is not a user friendly API. You first need to create an instance of the class and then you can search for duplicates. These methods could just return the result. If you want to implement multiple algorithms for searching for duplicates you should take a look a the Strategy pattern. 

If you really create a list and prepend more items to it right away in the next step then combinding the the constructor with the collection initializer is another option that might work for you: 

Then I guess you shouldn't have gone with the Strategy Pattern but with inheritance. This would allow you to define types with different names and craete them from different names too. (I wouldn't in this case). 

You put the first two cases into the static factory method . It'll encapsulate the parsing part so you have implemented it only once. Then you need to encapsulate the equality. You do this by implementing the interface. You should do this very carefuly because both the and methods are important for the performance. This new class can now be very easily tested for: equality, parsing and performance. 

This means it should not have any side effects. Properties are expected to be cheap and their purpose is to access data (quickly). If an operation can take some time it should be implemented as a method. On the other hand the property would never return a so it's actually useless too. You could never tell if an object is not-initialized. 

This is not a local function, it's a variable of type and as such it should be camelCase and not PascalCase. This is a local fuction: 

Mixing dictionaries with lists and arrays makes it only unnecessarily complex. As far as the hard-coded is considered you should at least use the if you need this optimization which I doubt. It could be so much simpler with LINQ 

You already have got a nice and simple solution from @GavinCoates so I only would like to add a couple of comments about your code for your future coding experience. 

Extracting methods To extract all methods use the extension with the coalescing operator so that you don't have to check for later. You use an empty collection. The loop simply won't execute. Finally you get unique methods with . Creating SQLParameters In order to create a query for each result you create a . You add each method to a list with parameter names and at the same time add the parameters and the values to the command. The parameters have counters. The first counter needs to be because it is just going to be added and it has to match the counter in the parameter line. At the end you build a string with parameter names that you can use to build the final query. Example : 

Now each extension uses only what it really requries. It's much easier to test because you don't have to create complex objects. Try to keep things as simple as possible. 

Encapsulation Try to encapsulate the logic in appropriate modules rather then creating a bunch of static methods. It's easier to test and who knows, maybe you'll need it later somewhere else so if you do it right the first time, it'll be copy/paste the next time.