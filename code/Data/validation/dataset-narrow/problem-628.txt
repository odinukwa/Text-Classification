This way, you have the benefit of the Copy-Constructor, and the functionality of the clone as well, if needed. After having said all that, I can't see any other significant issues in your code's functionality. It looks about right, and nice and clean. If you create a copy-constructor, it would look something like: 

As far as I am concerned, this function should be removed entirely, and a simple presentation-layer system should be added that simply appends a after each bond description from the query: 

For your performance problems, taking nearly an hour really is a problem. The reality is that your code is not the biggest problem, but the overall algorithm.... Making parts of your code faster will not do much, but making your code do things in different ways will help. Non-performance problems 

one sixteenth of a circle is 22.5 degrees. centering that is at 11.25 degrees. So, you add 11.25 degrees to your angle, rotate it a further 180 degrees, Use the Modulo to bring the value back in to range, then divide it by the size of each segment. This returns a value from 0 through 15 (for the 16 segments). So, add 1 to get your 'orientation'. It does not care about the degree amount as long as it is greater than -191.25 ... to start with... (the modulo operation is funny with negative numbers...) Here is a jfiddle 

(well, I also checked that only perfect squares have an odd number of divisors - which is true). What is the truth about the sum of digits? Well, it is true that all perfect squares have recursive digit sums that total 1, 4, 7, or 9, but the inverse is not true. This is obvious if you take the value 7, which is not a perfect square, but has the digit sum of 7. When I looked around, I found this entertaining read: How to check if a number is a Perfect Square. It is quite clear that this is the second line of attack for checking whether a number is a perfect square. The first line is to check the last digit (which excludes 7, by the way). Even once you have done (and passed) these two tests, all you can say is that the number is likely a perfect square. You still need to do the hard work to confirm it. As an aside... why do you use recursion for the digit-sum. Something iterative would be great: 

and they essentially become a prt of your locking system, and that can result in lock-conditions that are unexpected when you created your class. To make the class completely thread-safe, and have just a single lock point, and still keep isolated from the out-side, I recommend using a dedicated lock instance. It typically looks like this.... 

Convert the search string ('are') to a byte-array in the same encoding as the file. Open a memory-mapped byte-buffer from a File-Channel on the file. Scan the ByteBuffer, looking for matches to the search byte-array count the newlines as you go. close the ByteBuffer 

There are two parts to this problem as well. The first part is getting the user input, and the second is identifying and processing the sequences. I will assume that you can process the user input adequately, and put it in an array of integer . You use an which is not, in my opinion, a great container for doing arithmetic on... This problem can be solved by managing three variables, and keeping a and total. First you need to ensure you have at least 2 items in your values array, and, assuming you do, you initialize your three variables: 

First up, that inner part is doint a "side-effect" operation that can be avoided. Functional-programming purists try to avoid side-effects in streasm as much as possible. SOmetimes it is unavoidable, but you could easily re-write that line as: 

There is a much more efficient way to do this, involving two pointers, a 'right', and a 'left' pointer. They both start at 0. The trick is to inspect the value at the right pointer. If it is negative, increment the right pointer. If it is positive, move it to the left pointer, and increment both pointers. This allows you to move all the positive values to the beginning of the array, in the order they were found. All you need to do then, is to zero out all the values from the left pointer to the right.... I assume that 0 is considered to be 'not positive'.... 

Given the large size of the potential result set, the previously suggested iteration mechanism seems appropriate. I looked at this and thought 'nice challenge', and I looked at your code, and figured there were too many loops. The way I see you doing the work inside the loops also looks cumbersome... I figured it would be 'neat' to have a generator that created all the segments on an as-needed basis, and did not do the actual work.... then I played with it, and found there were some potential optimizations. So, the parts of your code that are potential performance problems: 

Now, each button has their own listener. The anonymous classes have small code blocks. In Java8 (when that's supported) you can contract it further if you need using a FunctionalInterface call, something like: 

Why is that needed? The only place a cloner can be added, is in that method, so why not just have the cloner added in the constructor (and make that public)? 

Because the and repeat in two different places, you include them all in the first count. Since this is homework, writing out the full solution would be counter-productive, but, if you have: 

Then, inside that system you do not need to keep creating internal arrays. The array-portion is merged in to the temparray, then copied back (or visa-versa - copied in to the temp array, then merged back). Still, if you insist on creating mini-arrays for each merge set, you should at least consider using the native code in Java that does the bulk of the work.... for example, you could 'lose the right/left array methods, and your mergeSort could look like: 

Performance - I am not sure about this one, but I doubt your solution will be as well-refined as the native one. Reliability - This solution is likely to be buggy, and is not going to be as upgradable in terms of look/feel as other components. This is a big deal.... the native components will be more responsive to that sort of context change. Over complicated design: I think you are reinventing the wheel here. There is nothing in your design that I can't see in the native implementation.... I think the model/view differentiation is better in the native JList. 

Well, your code is hardly a bash solution, is it? You use , , , and .... Additionally, your code is dumped on a single line, and it makes it hard to read. Why not put it in a script, and have separate commands on separate lines.... like: 

There are three significant algorithmic comments i have for this solution to the problem. The first is that, if the method gives you a a temporary storage area, that's a strong hint that you should not need to allocate more space.... is a problem... The second issue I have, is that this problem can be solved relatively easily (but slowly) with recursion, and no additional space passed in as an argument at all. Recursion has limits on the size of the available stack, but, at the same time, it will be able to accomplish a lot. What the recursive solution does not do, though, is easily short-circuit solutions that are not possible, you can only solve so much without moving state around. Here, by the way, is a recursive solution (not the best answer): 

Adding a second answer here because this answer is directly targetting your actual question: "How to make the palindrome program more efficient". ince the fastest answer I tested has not been mentioned yet in this review, I figure it is worth outlining here... Personally I feel that the int approach to dealing with it is more intuitive, but I set out to prove this, and I was suprised, so, here is my test program.... First, it generates a million integer values stored as Strings in a char[] array. It then repeatedly 'scans' those values and checks each value to see whether it is a palindrome. In the spirit of the initial program, the test here is really whether converting the value to an int and then doing numberical manipulation is better than keeping the value as a String, and doing String comparisons..... I chose two different mechanisms for String compares.... Bottom line is that keeping the values as Strings is about 50% faster... huh. Half the time. The most efficient method is: 

Now, you need error handling on the Scanner, and it needs to be closed as well. Without that, you have a program that is ugly when a user types in . Since you have no error handling, you may as well just junk the lines with the Integer... And, there is no reason to convert the StringBuilder to a String directly... Without error handling, you can: 

The indicates that should become , and so on, but should become . This allows us to then make the "simple" nested loops: 

Using a Stack (really, a Deque - or ArrayDeque ) would ba a typical choice, but in this case, I feel that converting the primitive int values to an Integer would be unnecessary. Using an array would be simple enough.... especially because there is an upper-bound on the stack size. So, taking that all in to account, I would suggest the following changes: 

Your concept is an interesting one, but it has a number of concerns in it. The most significant issue I can see is related to the errors that can be returned. There's no way to match an error to the function that caused it. Other concerns are that your error channel is unbuffered, which could potentially leave go-routines unnecessarily hanging around waiting for the channel to be drained. Still, even if that's OK, there's still a usability issue. My concern here is about the requirement to manage a relatively sensitive life-cycle outside the Pool code. Your user has to know that they create a new Pool, then Run a few items, and then Wait. The order cannot be changed, and you cannot reuse a pool after Waiting for it. My feeling is that you could use a much simpler mechanism of having a single mechanism that "does it all". The user's code would look something like: 

We will have to create those channels (with some buffering) on the ... but, that's how we communicate the add/remove from the client. How do we handle that on the server? Currently the server code looks like: 

I have a few comments on your code and algorithm. First, I don't understand why you cannot use recursion or a stack. You have not elaborated on this. If it is because this is a learning exercise then perhaps I can understand, but it is a poor example of any normal data-structure manipulation... If this is a real application then I would have to question the whole thing.... Essentially you are taking a list of Data, and converting it in to a List of data.... there is no apparent manipulation of the data at all (at least from the end-user perspective). I simply do not see much value in this code. Still, assuming I am missing something important, what about the actual code? Unfortunately recommending changes while not using a stack or recursion is very challenging.... it's like you have been told to screw two pieces of wood together, but you are not allowed to use a screwdriver.... Ratchet-freak's comment/suggestion to add the parent-node is the right solution... and that fixes a lot, but, without that, there is nothing I feel happy recommending other than some big-picture structural items.... Your class is being treated as the source-data for a loop: 

By ignoring the error, if you start your program twice, the second program will panic with a nil pointer reference on the call (since will be nil) That call should also have it's error checked too! Again, using both and is confusing. In general, you should specialize your network services/processes when you can. You use and when you should probably use and (you get a instead of a ) - and your connection is a and not a (you should change the parameter type on the handler function too). Your client side has similar issues, but I think you can figure them out as you go based on the above. 

Note that your work contains far more data state changes than would be necessary using non-stream functionality. The fact that you have to scan the entire line and convert all values to ints means that all the data is in arrays already, and there is no real benefit for any optimization in the streams using short circuiting. Additionally, your result is not able to be run on a parallel stream because it would not survive in the Iterator stage. Correlating two active streams is not an operation that is supported using any 'natural' mechanism in Java8. But, there are ways to do it using non-stream mechanisms, and also much more natural Java8 ways too. Stream Solution First up, use a stream for the file IO. provides a stream of the lines in a file. Next up, instead of streaming over the values in the source arrays, use a stream of what the two arrays have in common, the indices. Stream over the indices. By streaming the indices you can process the data in a natural stream way and pull the data by index from the corresponding positions in the sources. Finally, the operator should be supplied as an input lambda, and not built in to the stream-iterator-stream translation. The solution I would use, if forced to use streams for as much as possible, would be: 

Answers Your CTE is convenient, but it should be doing a lot more of the heavy lifting for you, and it is also over-generous with the selection. Your intention is to report on answers for the specified user (UserID or Display Name). You should be filtering those answers out immediately. Also, the inner join to the Users table is just for the display name is a problem too. Also, there's a little trick with CommunityWiki or a couple of other posts types, where the DisplayName is actually populated on the Post table. So, your Answers CTE is: 

Note a few things in there.... my Computer is a 4-core i7, and it has slow performance on your locking when there's 4 threads at 100% (two producers, 2 consumers). Something 'odd' happens then. The rest of the time it is fairly predictable. The single-sync code is slower than yours for simple cases, but starts performing better than yours under high thread imbalance - where there are many more consumers than producers, or the other way. Double-ended Synchronization Still, the results are interesting for their variance.... but, what if I used a similar double-ended synchronization system to your double-ended locks? What would happen then? 

You have correctly implemented the optimization , but, there is a more efficient way to do it... calculates the square of for every iteration through the loop. The product is not hugely expensive, but it is also totally unnecessary.... You can calculate the square-root of the upperlimit just once, and then reuse that calculated value as a direct comparison for . Consider: 

but, that code will not compile because you need to return an int value after handling the exception. You know that there will never be an exit from the onException, because it shuts down. The compiler does not know that, so the compiler makes the wrong assessment of the exit path of the method. I recommend you change the signature of the onException class, to have a return type of . With that, you can have: 

That method will not be able to work in a public context at all if the calling class is not in the same package as Node (). There is no reason to ever expose the Node class to the public. Just remove the method. Recursive insert The recursive insert mechanism is a little hard for me to follow. Part of the problem is the variable name. I would call it something like or . It is not the root. The following code is too complex: 

The combined parallelism/primitive would be easy to implement using Java 8 streams, and abusing that the Polygon data is public... 

Consider this... I put this code together to illustrate what I would consider doing. Use it as a guide. I am not thrilled with the int-stream generator, I think there's a better way, but this review really focuses on the concurrency and other bugs: 

See how, as you go, you can "shift" the value from the one side to the other? This makes the solution a simple \$O(n)\$ complexity. 

Now, if the size of the is the same as the , you're good. The Map is an IdentityHashMap where the key values are all identical instances (using ). It supports a null key/value so that should be fine too. 

Your algorithm is logical, but a little trick can make it much simpler too. Because applying the trick makes the code so much shorter, it seems better to just point out some smaller issues in your code, and then show the improved algorithm later.... So, first up.... the method name: .... really? Java convention is to have camelCase method names, not PascalCase. The first letter should be a lower-case. Your variable names also are horrible.... , , , and . With and variables I am always looking for cartesian coordinates or something. Choose more meaningful names. Your handling of 0 and -1 is also broken. Since there are no bits set in 0, and no unset bits in -1, they are impossible to provide a solution for, so the best thing would be to handle them as exceptions. Returning -1 for an input of 0 is broken, and overflowing on the input of -1 is inconsistent too. So, having said that, the best algorithm to use is to identify the right-most change in bit values... where bitn and bitn-1 are different. Then, just swap them. A swap is easy to do with and XOR: