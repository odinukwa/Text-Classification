Use different IP network on the Ethernet and WiFi interfaces. It might be as easy as changing the network mask to split the 192.168.137.0 into two networks, or not. It depends on your whole network configuration. 

Addresses starting with 169.254 are special private addresses (called Link-local address or APIPA - Automatic Private IP Addressing) assigned when no DHCP server is available. Basically they are meant as an automatic, temporary workaround for a machine that cannot get a regular IP address and you should not rely on them for connections. Particularly they will not be routed, so it's the reason why you cannot reach your Pi from Ubuntu on the Ethernet. At the same time Microsoft handles these addresses specially to allow connections (How to use automatic TCP/IP addressing without a DHCP server) and this might explain why you get a connection from Windows. 

JuiceSSH is an SSH client which in its free version offers only shell (text) access. JuiceSSH Pro - a paid version of this app - allows X11 forwarding and integrates with an X Server app. Refer to the How to tunnel X over SSH using Port Forwarding guide. On Raspberry Pi side you need to ensure option is set in . And then you need to add an environment variable before running your program. 

I’ve got a raspberry pi running headless, playing an audio stream through mplayer over wifi. Crontab loads mplayer on boot, as well as a couple scripts: 

I am working on a project that involves a raspberry pi acting as an internet radio client which the public can access by plugging their own headphones into a 3.5mm (1/8”) jack. They will have access to volume control and nothing else. The project’s constrains are: 

It works for a while, usually from 3 or 4 hours up to 3 days, but eventually it becomes unresponsive. the wireless goes down, and doesn’t come back up, It will not take input from the keyboard. It seems to have crashed. I’m using a wireless usb card with chipset RT5370. I’ve turned wireless power saving off. I’ve tested the current to the rpi with a multimeter. it is 4.9V. I don’t think it’s an issue with the wireless card or power. I’ve looked at the syslog and the kernel log, but I don’t really know what to look for, and can’t find anything obvious. What might be causing it to become unresponsive? ***Edit, more info: I've set up hardware watchdog, and also have Crontab set to email me when the system reboots. I now know it has been crashing/hanging when it is unresponsive. I've started systematically eliminating software and hardware, and it's looking like the problem lies in the interaction of Mplayer, the Wipi, and my bad wireless connection If I disable Mplayer, or use a more reliable internet connection, it doesn't hang or crash. I am putting this together for an on-site installation where I will have no control over the router, so it can't crash just because there is an interruption in connectivity. Here is what the cronjob for Mplayer looks like: 

I am using Logitech Media Server (formerly SqueezePlug server) as a streaming server at my home. At my work laptop squeezeplug client installed. I believe that it's a better solution than DLNA. (I'm using DLNA to stream video to my TV by the way.) There is a installation document for Logitech Media Server: $URL$ Also; There are many solutions work as 'streaming server' to use on RPi. $URL$ $URL$ $URL$ 

If you have error like 'FATAL: Module r8192cu not found.' that means you haven't r8192cu module installed. You have to install it first. Please look at that document : $URL$ 

You may not install PPA's onto your Raspberry distribution because of those for prepared for Ubuntu. If you are sure those PPA's for your distribution, you have install some packages to avoid these errors. First of all; find the deb package which contains program/application/script that you cannot run. Then install the package. 

I am using a Python script and Dropbox to put pictures which taken by my RPi server to my dropbox account. So when RPi takes picture Dropbox sync it to my computer automatically. Also i am using a Pushbullet service call to inform me about taking a picture. (You need to login pushingbox.com and create a scenario for this.) You need 2 scripts; 1) dropbox_uploader $URL$ First, download then run dropbox_uploader to configure it. It will ask for your dropbox credentials and path for pictures. 2) shot-pushinbox-dropbox.py 

Because somewhere on the way you must have configured an APT repository pointing to an HTTPS URL (check the files at ). Per the error message to fix the problem you need to run: 

No. You cannot run visual environment within an SSH session. To have (almost) "the exact same experience as going the whole nine yards and using an external monitor and peripherals" you should set up VNC. RealVNC server comes pre-installed on Raspbian, but you need to enable it. Refer to the official documentation for detailed instructions. You might however need to install VNC client like VNCviewer on your Debian machine. 

You need to transfer the file to your local PC. You can do it with command which accepts the same login credentials as . For example, if you connect to the Pi with and saved the image to user home directory, execute 

In Raspbian Stretch the script has been changed to a one checking existence of file (on the other hand, created/deleted at boot time). It doesn't check the on each login, but on the other hand if someone used an automated tool to change the password, they need also to explicitly remove the file, or reboot the machine: 

I've found a workaround, but would still love to hear an explanation for the behavour exhibited above.. After a bit of experimenting, I found that eliminating R3 got the voltages within bounds of the GPIO threshold states. When the switch was open, V at GPIO was 2.85, when closed, V was 0. The problem was that every time I connected my headphones, I would hear the loud pop from the high dc offset which is somehow created by the interaction of the headphone amp and gpio pins. Not good for ears or headphones; I don't know what it might do to the life-expectancy of the Pi. I've decided to keep R3, but bypass the headphone amp, and use a 1k log pot to give volume control. Sound quality is still quite high, and there are no noises when connecting or disconnecting. I would still love to hear any solutions or explanations for the behaviour exhibited by the circuit with the headphone amp, but for anyone else who wants to have a headphone sensing jack for their Raspberry Pi, here's an updated diagram. The kind of jack I'm using is 3 conductor 4 contact, like this one. and I'm using a 1k dual gang log pot, such as this one. Here is my final circuit, same values as before, but with the added 1k pot. The switches just represent the behaviour of the headphone jack. 

You can do this with Apache Rewrite Module. By default Apache comes with rewrite module installed, if don't please do this. 

Because on ext filesystems 'root' user has extra %5 reserved space on filesystem while formatting. Although 'df' command show as %100, you looks you're using that reserve now. If that reserved space filled up you will not create file/dir on filesystem neither. You can check folder sizes by that command: du -h / --max-depth 1 You will get output like this: -# du -h / --max-depth 1 7.5M /etc 16K /lost+found 1.1G /data 8.8M /bin 1.5G /lib 873M /var So then narrow your search and look for other folders such as /data in my example. Delete some files on your filesystem to get free space. 

You can't run a program which need run on X via /etc/rc.local file. You should use LXDE autostart configuration. Commands globally executed are stored in the /etc/xdg/lxsession/{profile}/autostart file, and in addition, other commands can be locally specified in the ~/.config/lxsession/{profile}/autostart file. If both files are present, all the entries in both files will be executed. $URL$ • Create the folder /home/pi/.config/lxsession/LXDE • Put a file named autostart in this folder, specifying the full path of the file to be executed: e.g. python /home/pi/pirun.py • Make the autostart file executable by chmod +x /home/pi/.config/lxsession/LXDE/autostart 

Now, to reach a service on your Raspberry Pi using the Dynamic DNS address, other devices (clients) on the internet will first ask the DDNS provider for the IP address for your device and domain, and it will respond with your router's address. The client will then contact your router and in this stage, the router must forward incoming packets to the Raspberry Pi. That's what you need port forwarding settings for. 

where is the IP address of the network device you want to monitor. This will show you incoming and outgoing traffic for the specified IP address. You can also try Wireshark. For both tools there are countless tutorials on the internet, but your filtering requirement seem to be really basic. 

Repositories for officially released versions contain latest stable release. Repositories with the suffix contain Debian 7 and 8 backports introduced into staging, but not yet officially released. Repositories for not yet official Stretch contain latest releases according to their release cycle. 

This is a trace of a default script (introduced in the November 2016 Raspbian release) which checks if you changed the password for the user . The script is stored in and displays a warning if the SSH deamon was turned on, but the password for the user had not been changed from the default one (). It is called on each login. The script in its original form: 

I am using Moebius[1] on my raspberry pi. It's a Debian derived minimal distro. Because i am using raspberry pi as a headless server i don't need GUI like you. [1] $URL$ 

Rpi can't get dynamic IP address from your Windows7 laptop, because there are no DHCP server running on Windows 7. You have to set static IP address on Rpi which is in same network with Windows7 laptop. Step by step instructions. 1) Connect your Windows7 laptop to network via wireless ethernet adapter. Note the IP address. (Let's say its 192.168.1.10) 2) Give a static IP address to Windows7 wired ethernet adapter. This IP address should be on different subnet than wireless adapter. (Let's say it should be 10.0.0.10) 3) If you haven't monitor or TV that connected to Rpi, you should connect Rpi to your router temporarily to set static IP address on it. Let's say it should be 10.0.0.20) 

I guess your image is OpenELEC as @Lawrence said that. OpenELEC uses squashfs compressed image filesystem so you can't edit without uncompressing. To uncompress it, convert your sd-card content into image with dd command in another computer which runs linux. 

I am using a usb soundcard connected to a headphone amp to give me volume control, and higher quality sound. for the robust plug and sensing capability, the headphone out is connected to a breadboard which connects to a high quality 3 conductor 4 pin barrel jack and contains a circuit that interfaces with the RPi’s GPIO. The jack contains a switch which is normally closed, and is opened when a plug is in the jack. I’ve attached a link to the circuit on the breadboard. The circuit behaves properly when the headphone amp is not turned on, or when the sound source is ungrounded, such as a smart-phone, but when the soundcard out is used, or the headphone amp is on, the GPIO digital pin remains high. I think it is an issue with the relative grounds of the RPi and the headphone amp. I found the circuit I'm using here. I’m not very savvy with electronics, so I'm not sure what changes to make to get the proper behaviour, but it feels like I'm so close. Is there a simple solution? Here's the circuit I'm using: R1=100k, R2=50k, R3=10k, C1=0.1uF fritzing circuit schematic 

After starting service, check your server is running at default port $URL$ You can set up media server from web interface. Then, install client application. You can find packages list at $URL$ Install application, then run squeezeslave, it will find your server. You can find more information about squeezeslave at $URL$ 

Log outputs should give clue. Update: Since you're saying that it works with NFSv3 not NFSv4, you should do extra things to use NFSv4. Create a directory to share in /export folder. 

Use Berryboot[1]. It's a bootloader that can install more than one OS into an USB flash disk. Berryboot has a feature like VNC to boot screen this could be what you want. You can connect through VNC when RPi booting, at this screen you can choose into OS what you want to boot. I'm using Berryboot with 3 OS installed. PiBang[2] as desktop with GUI, Moebious as server, Xbian as media server. At the boot sequence i can choose what OS going to boot. [1] $URL$ [2] $URL$ [3] $URL$ [4] $URL$ 

You can use DAAP protocol to listen music from your Pi while not in your local network. For Pi, you have to install "mt-daapd" daemon to your Pi distro. Then use ssh port forwarding to add security. With ssh forward your port (6689 by default daap) and use any Daap client such as iTunes, MPOD for iPhone etc. I have wrote a blog entry realted to this issue, but sorry it's in Turkish :) $URL$ 

Regarding the use of the "Raspberry Pi" trademark / logo the guidelines are published on the Trademark Rules And Brand Guidelines page. 

No. Google never distributed Chrome for Raspbian and they ceased their support for 32-bit Linux versions in December 2015. 

The configuration in which two separate interfaces on a single machine are configured in the same network is not correct. The situation you described is expected as the return packets from the Pi to the Windows machine might be sent through the Ethernet once it's connected (and, of course, not reach the destination). 

It's for non-login shells, you are expecting it to be loaded for the login shell. And it's the same for any bash instance, regardless of the "Linux distro". 

There is no need for the dual-boot in the scenario you described. Kali Linux is a Debian-based distribution (just like Raspbian) which installs a certain set of packages by default. For most use cases it doesn't have any features (code) on its own, and does not require these packages to be running specifically under Kali Linux. You can install your required packages with APT, configure, and run them on Raspbian. An additional advantage would be that you would learn the tools dependencies and configuration.