I have created a mini Android game. The aim is to catch aliens in space. You score points for each aliens, there is a pause function and you can change the level of difficulty and change spaceships. 

I needed quickly to represent a list in json format. I wrote the following front-end in jinja2 with google appengine. 

I read about lookups in lists and I think that is what I did. I would like to compare it to a skip list, a binary search or a B+ tree. 

I wrote a small aggregator app that aggregates values from a json http post request and outputs the aggregated values. Now the aggregator function is somewhat large but the output appears correct. I start it with gunicorn: 

I wrote a build file for a mini Android game. I use this buildfile whereupon travis reports success. But I'm not always sure of what I'm doing. 

IIUC I should decouple UI logic from the model and controller in my project. I didn't succeed and had to resort to etc in my game logic: 

But how can I improve it? I would like to make it easier to test the thing (my next work should be to add multithreading to the malloc implementation). Should I use a testing framework instead? 

I have written a "better" program that does the same(?) output in safe ways. You don't have to see the original code because it isn't mine. The following is my code to solve the assignment in a neat way. Figure.java 

I have some code where the purpose is the decide if a char is between quotes in an expression. For example, has a between quotes. The function that I want to test is 

I see some opportunities for improvement, which will get this up to about what we expect from a . First, the imposition that the stored elements are is not optimal. Sooner or later you will want non- elements, and you will not want to write and maintain another for each data type you want. is, in fact, the least useful element type I can think of. The solution is a class; instance objects would be declared ; a programmer will expect this syntax and the reusabilty it produces. Second, there should be no method as it is unclear where the new element is added. Instead, we expect methods like for O() insertion at and O(N) for what you are currently doing with . Third, you may recognize your as being O(k); this is because you've actually written a queue (with minimal modification, a deque), which extends a real . A real has no need of a tail pointer ( here). 

Then, you can make your list of number formats more declarative; construct an array, output the descriptions, and have the user pick what will effectively become an index into the array for the source format. Then read the destination format and numeric string, in either order. As it stands, the input method is needlessly coupled to a finite set of formats and their names, as is the source/destination pairings. I once wrote a hex-by-default calculator/expression evaluator in assembly, so I'm the last guy that's going to call a wheel-reinvention foul on you; in fact, I like the general theme of your code because I've never seen a number formatter that covers absolutely everything, like your binary output's adding leading zeroes to pad 4 bit groups. Bravo on making a wheel that spins exactly like you want it to. With regard to the conversions themselves, I see more twos complement math than is necessary. In particular, I see several s while converting to binary. If I'm interested in a number's binary representation, I will probably find the equivalent ones complement operations in your code just as readable, if not more so. The sequence: 

This would let you compose and reuse a collection of funcs into a DefaultFuncs and then reuse it -- default funcs is really just an elaborate Tuple tricked out so you can call into the functions from the owning NeuralNet instance All of these are functionally identical approaches (it sounds like you've already got the thing working and just want to clean it up). The main reasons for choosing among them amount to where you want to put the work #1 is good if the functions correlate and you want to easily tell when a given net instance is using a set; #2 is just syntax sugar on what you've already got; #3 is really just #2 except that you compose a function set as class (perhaps with error checking or more sophisticated reasoning) instead of a a dictionary 

This could actually be improved further by replacing 'is_number' with a function that did the float conversion and converted all non-numeric values to -1; then you could just have a single test in the get_input function. I did it 'the long way' so the logic is clearer. The last thing to look at is the layout, it would typically look like 

If after all that you still can't get the perf you want, you might want to look into using numpy for the heavy duty tasks. 

I'd start with the caveat that you're buying some syntax sugar at the cost of possible bugs - the need to do the attribute resolution, and as you point out the possibility of name clashes, makes it seem like it may not be worth the effort unless you need to access these class properties in lots of places in your code. That said you can simplify this by converting your sections - which are dictionaries -- to namedtuples: from collections import namedtuple 

It was somewhat more problematic to create the layout in XML compared to the small game engine and controls. Maybe we can rewrite the code more object-oriented because it is rather procedural at this time. The game is open for testing in an open alpha and the source is available at my github. Main activity 

The above sets a pager and greps the environment variables for a variable. I run the script from my shell after I start it: 

When testing your solution compared to a regex, the result looks like the regex is slightly faster in this test. 

And the exception was a ConcurrentModificationException. So I rewrote it like this instead, then it doesn't crash, but is it correct? 

I have similar to the above in several classes, passing on an android activity and/or a textview into model and controller objects. Will this be a problem and is it possible to solve? 

My allocation and deallocation functions look like the following but I didn't do it yet for a `struct only for arrays and matrices but I think that I can have an array of structs with one struct and use these functions for the struct. 

There are several unclean errors with wrong variable names because I copied the code from an example but the output is good: 

I make a mini adventure game demo for Android where the player can move between places and NPC characters can enter and exit the places and perform random actions. The "dirty" code is the UI for Android while the game engine is very good and clean. I have this class which is quite unclean but it works and therefore I want a review. 

The differences are related to floating point accuracy and performance. In my original design, the iterator would endlessly spit out the initial value if the step value was too small in comparison, literally . In addition, if the increment was not perfectly represented as a float (e.g. ), error would pile up on the output after many iterations. By incrementing an integer and multiplying by instead, the iterator would eventually halt and always yield the most appropriate float. The reason I did not do this initially is that I had integers in mind; while all numbers in JS are supposed to be of interchangeable real number type, it is theoretically possible for a JIT or something to optimize into integer addition if it was always used that way. Integer math is way faster than floating point math, and addition is much faster than multiplying for either type. Math between a float and an integer is actually the worst, since conversion eats time too. After some testing, I have concluded that only very few cases (e.g. asm.js style for caller & callee) will allow that optimization to occur and translate into a tangible performance difference, and on many platforms it can just as easily be prevented by using and or overshadowed by call and return time. Given time, ES6 implementations may evolve to do better at this, and a special fast integer iterator will be justified, but for the moment, the suggestion of multiplying the step instead of repeatedly adding it is sound. Finally, the original code fails to produce number sequences of a single element because it returns early if the second element will be beyond . The intent of the early was to make the iterator empty if was the wrong sign. I tried to combine that idea with invalidating the iterator if you gave it equal to , for e.g. not iterating the indexes of an empty array or string by using , but that doesn't work. It's better to spell out both conditions, and the final correct code is: 

This has a couple of advantages 1) not hitting the disk for every query will be much faster 2) the dictionary lookup faction is much faster than straight for loop comparison, since the dictionary uses hashed values instead of more expensive string compares. As an aside, you should look into readlines, which the usual pythonic way of reading text files with info on lines. For the longer term this is a great application for Python's built in database functionality (with the sqllite module). You could convert your existing text files into a sqllite database and then your lookups can be much more flexible and precise ('find spectrum and power for stars with id > X and < Y' sort of thing). You probably also want to set this file up so you could call it from the command line, which would involve using the argparse module to grab command line arguments and out them into known_stars, master_list and output_file 

For combining (1) and (2) you can reverse the sort by only trying if your are under a test directory Also this is a great use for a generator / map combo to avoid extra loops 

The main idea here is to use the dictionary CircleSet as a sparse grid: it will only have keys where a point falls into a circle. I'm using a separate set() object to track intersections so that the 'overlaps' function does not have to look at every value and see if there are multiple entries, but you could ditch that and do 

Plus you can use safe_substitute to allow more error-tolerant display so you don't bork your server. 

If you don't really need to constrain your declaration to one block, stick with and . You can still stick it in a hash or factory class if you like. That's the idiom that everyone understands, and it will do the same thing. If you don't really need to look up classes by name, use function scopes (again, look up module pattern) to manage your namespace instead of a hash. If you don't really need to be writing JS... well, it seems like you'd really rather be writing Ruby or Python. Those languages have classes. JS doesn't. It has prototypes and constructors and function scope. 

Perhaps I'm missing something, but is there a reason you aren't converting to first with any of a set of functions, then formatting the output in a separate set of functions? e.g.: 

/UPDATE In a more inclusive sense, the pattern you're describing breaks a lot of the functionality that JavaScript provides natively when you use established idioms for creating objects. You lose , you lose , you lose , you lose , you lose , and you lose either lint or . You're also forfeiting your IDE's documentation and code completion for your classes and constructors (unless you're writing code in notepad anyway, or something). It comes down to priorities: how desperately do you need single block "classes" and reflection, and how certain are you that this is the only way to do it? 

Again, that will change a few things logically throughout your code and header, but it will end up far cleaner and clearer than it started. You've got pointers to pointers in C, an often underestimated advantage over other languages, and so far you're doing great with them. If you can handle using them for pointers to arrays of pointers, you can handle using pointers to members as objects. Other than that, the nature of the task demands a bunch of hairy pointer-chasing and a little bit of pointer math, which is tough to read. Stuff like takes a second for me to digest fully. If your comments were at all lacking, I would want some of the longer statements to be broken up and have some intermediates made into local variables with names. However, your comments spell out what's going on very clearly, so I don't think that counts against you. 

Searching this can be done very efficiently using the built in filter function. Filter takes a list and a function as arguments; it returns a list of all the items where the function returns true. For example: 

Another piece of python wisdom to consider is 'if you can do it with the standard library, do!' Field and record based storage is really easy to do with the csv module, which reads and writes comma-separated spreadsheet style files. A file formatted like this: 

Here's a couple of ways to shorten the code, which may or may not involve perf gains but may make it easier to work with. I tested this with plain lists-of-lists instead of numpy.arrays but I think it should work the same way. I used itertools.product to get rid of the nested loops and used sum() to avoid another loop. get neighbors will be called for every cell, and it's going to loop and iterate mamy times. You can get the same result by summing the rows of a subset: 

From a style perspective I like the first option; if you're treating this as a property its clear what you intend For implementation, I'd try a class level default with an instance override to provide the right words to allow for specialization or extension (for other languages than English, say, or use at Oberlin College). Whatever your gender politics this implementation is extensible to new cases and one offs. 

Python has a neat built in called 'zip' which creates a pairwise list from multiple iterables. So you could do: 

I don't think is a standard python construction - does it even execute? In that sense this does not look 'well formed'. Does this execute? It does not work when copy pasted but I think that's just formatting issues. It's hard to write this without some try's, since the standard string > float conversion method is