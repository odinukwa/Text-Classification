No, although there are certain Cisco devices that can act as an IDS/IPS. Cisco has an entire line of products specializing in this, specifically. These will likely be massive overkill for your situation though. 

Unknown VLANs are the primary cause of Input Discards () in my environment; usually from inappropriate VLANs spanning a trunk port. Depending on the services active in the VLAN in question, those counters can increase exponentially over short periods of time. Keep in mind that Input Discards are the result of valid frames being dropped due to an internal forwarding issue. Another thing to note: Input Discards encompass a drastically smaller amount of issues, most everything else results in an interface error. 

I don’t believe Juniper platforms have any compatible outputs that allow access to that information and it doesn’t look like fits the bill quite right. They do, however, have some appealing logging options within the stanza that log to directory. Although I can’t confirm the configuration below gives you exactly what you’re used to receiving with , I’m confident it will provide more. I would test this myself, but my organization might frown on me self-initiating BGP route updates for thousands of routes (event soft resets). Give this a try: 

For the short answer: yes, CAM overflow attacks can be simulated in GNS3, however this goes with a few requirements: 

First and foremost, I must indicate that I am mostly active on the IT Security StackExchange website. Since this current website may reach a different public I find it wiser to tell that, while I adopt the point of view of a potential attacker, all information in this post is given only for educational purposes, in particular in order to understand the concrete threats that are affecting networks beyond myths and oversimplified discourses. I do not encourage nor do I approve the use of the methods described below on any unauthorized network (and I really mean it: if you want to learn get GNS3, that's what this whole thread is about :) !). Sorry for the length of this answer, but despite my researches I did not manage to find any satisfying resource on the web on this topic. Most "proof-of-concepts" are biased either by stopping at the CAM table being filled step and assuming but never really demonstrating the switch reaction, or by using some artificial tricks like clearing the switch MAC table before flooding. My goal here is to provide concrete steps suitable both for simulated and real environments, focusing on the issues related to GNS3 virtualization and common wrong approaches, and most importantly to provide sufficient background information to understand why things are the way they are. 

Not only is it possible, but it happens. The underpinnings of packet switching is that it really doesn't matter how it gets there, just that it does. This sometimes comes with issues in delivering packets out of order because of that asynchronous routing. 

If there isn't an 'in your face' requirement to repair the infrastructure that's in the building right now, then you're going to be fighting an uphill battle. Most managers (and users, for that matter) are willing to accept sub-par service as long as it works; mainly because they want their IT gear to last until it dies. If a degraded level of service has been provided for long enough, people will not communicate issues anymore. They'll simply accept it as what it is, a crummy system, then complain to their coworkers and think it's your doing (you personally). I can't tell you how many times I've run across a user that's had a different issue and, upon further diagnosis, found out there was bad wiring or auto negotiation was turned off that resulted in pathetically slow speeds. My response is always to the flavor of "I can't believe you never said anything...". In essence, if your managers don't see a legitimate need for better resources, they'll accept the heartache is business-as-usual and tell everyone to suck it up and move on. As a network engineer, a big part of your job is going to be communicating those requirements to your higher-management that doesn't entirely understand what you need or why you need it. You can interpret that as 'salesman'. A method that's always worked for me is giving them cold, hard facts, but do not forget the sugar coating... Correlate things that actually matter to them. A few off the top of my head: 

Currently, when the ARL failed to store a new MAC address, the handling of the incoming is aborted, effectively resulting in the packet being drop. The fix is just to ignore the ARL status and continue processing the packet anyway, since this what real gear actually do: 

So you're warned: as stated in Łukasz's answer forget about QoS and expect some oddities. Hopefully here we are not dealing with QoS but with CAM overflow, and except the final bug (of which the correction should be included in some future GNS3 release, I hope) there are two main oddities which are of concern to us: one is affecting the MAC address table size and the other the MAC address aging process. First difference: the MAC address table size tops at 8189 entries This was the main topic of your question but is in fact a non-issue. The CAM overflow attack exploits the fact that a switch is not able to add any new entry to its CAM table, and therefore fallbacks into "behaving like a hub" (as it is often described, I'll come back on this later). Most probably due to a minor bug, it seems that the MAC table is considered full at 8189 entries instead of 8192. However, full still means full: the ARL will still fail to store any supplementary entry and the CAM overflow attack will still be successful. Second difference: the setting is not honored By default, MAC entries should remain the MAC address table for at least 5 minutes (=300 seconds), as defined by the setting: 

Dry-Run and Locate File This way is a little more arguous, since you have to look through everything and make sure not to mistake any s for s. Run the with the option and look through it. 

The content of that message isn't any more protected as when you sent it out. Unless you're using some sort of encryption mechanism to provide confidentiality, anyone along that path (presumably with malicious intent) can snoop in on your packet. Retransmission is accomplished by TCP. The same can't be said about UDP, it just gets discarded since retransmission is often times not wanted (i.e. packets arrive out of sync). 

This is by no means an extensive list, just a listing of some of the common features most people look for. If you want more detail on some tools that are fairly popular, check out IPplan. 

This is a very bad idea; not to mention it will not work how your anticipating it will. If you did split the pairs like this, you would only get use out of one set of them. Auto negotiation will allow a single pair to function by autoing down to 100Mb; remember, 100BASE-TX only functions on pairs 1,2,3 and 6. 

This launches the function every 15 seconds. What this function does is to scan the whole CAM table and check a hit flag associated to each MAC address: 

This flag is re-enabled whenever the switch receives a new packet from the corresponding MAC address, keeping active addresses in the table. You will have to take this behavior into account in order to design a successful CAM overflow attack: 

However, in real gear the whole process behind this parameter is implemented in hardware, and this setting is currently simply ignored by Dynamips' implementation of the NM-16ESW module. Dynamips implements its own garbage collection system which deletes old MAC entries after only 30 seconds, making CAM overflow attacks noticeably more tricky to stabilize (but may be a good training against the "backpressure" functionality described by Łukasz). The code in charge of this can be found around line 2516 of the dev_nm_16esw.c file: 

On incoming packets, if and only if the source MAC address is not present in the table will the CAM overflow have any effect since the switch will have no free slot to add this new one and will therefore skip this step. If the address is already present in the table, the switch will reset its aging timer as usual. On outgoing packets, if and only if the destination MAC address is not present in the table will the switch indeed send the packet through "all" of its interfaces. If the MAC address is present in the table, the switch has strictly no reason to act weirdly: it will simply proceed as usual and send the packet only through the port associated to the MAC address. 

This has always been possible with port-mirroring (SPAN ports). They functionally do exactly what you're looking for. They replicate traffic ingressing/egressing an interface/VLAN and spit it out on a pre-defined port/VLAN. 

If was the only device pruning, all other downstream switches would be needlessly spammed when expected not to. 

It is absolutely possible to communicate through a TCP connection, and as jwbensley mentioned, Scapy is an excellent tool for packet manipulation. However, in your instance, I would stick with something like netcat. Netcat is a low overhead tool that allows you to read/write data over the network. A simple implementation of a TCP connection might look a lot like this. 

There is generally a 1:1 mapping between subnets and VLANs because there isn't a very good reason not to. You could have a big network with 1 VLAN, but why have a huge broadcast domain where all hosts see every broadcast when you can just separate each subnet with a VLAN? It's a waste of resources. Subnets/VLANs are, more often than not, focused around similar uses (i.e. printer VLANs, workstation VLANs, etc.) and allowing for a single entry/exit point makes policy much easier to enforce on the VLAN/subnet as a whole. There are also security implications that sprout up in shared layer 2 domains, so you would stand to benefit from segmenting traffic as much as possible. 

I will now take each of these point individually. Knowing where difference with real gears lies For performance reasons, a lot of switch things are actually not part of the IOS code but are implemented in hardware. This includes the ARL, or Address Resolution Logic, which provides all the methods to add, remove and lookup entries in the MAC address table. Therefore, for the NM-16ESW module to work in GNS3, Dynamips had to reimplement all these normally hardware provided services, or at least push this far enough to allow an unmodified IOS to run on it correctly. The sad thing is indeed that this is unfinished work, as stated in this module's source code header: 

After you do that, you will be able to test and repeat MAC overflow attacks in GNS3 with router-based switches in a stable and predictable manner. Here are two final notes: 

I've raised this issue to GNS3 teams so it can be fixed in GNS3 future updates. I also advocated to raise the MAC table garbage collection timeout from the current 15 seconds to 5 minutes in order to be closer to real gear behavior. Until this gets fixed upstream, it requires a manual modification and recompilation of Dynamips source code but this is a very quick and simple process (there is no need to recompile the whole GNS3, only the binary, and I provided the patches in the tickets linked above). 

It appears our filesystem is full and is no longer accepting log messages. This is also causing premature rotation of some of our files. 

1Note: this is based on HMAC-SHA-256 authentication, but the same process should still be true with MD5. 

From Cisco: Campus Network for High Availability Design Guide - Access Layer Tuning There used to be an idiom: “Switch where you can, Route where you must”. In recent times, that has been completely flipped on it’s head: Route where you can, Switch where you must Tons of enterprise switches support some level of routing now. We can’t stand behind ‘my device doesn’t support that’ because that’s not the case, anymore. 

I've looked in the Juniper Knowledge Article: How to resolve the '/var: filesystem full' issue which occurs as result of the WTMP file not being archived, but my WTMP file is resonably sized. 

The process of establishing that connection is sending packets. I think you're referring to how TCP establishes a connection before sending data. So in that case, you would need a successful 3-way handshake before you can transfer data.