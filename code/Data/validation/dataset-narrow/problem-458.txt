Which seems simpler. Note that the parentheses around the division are unnecessary as division is higher precedence than subtraction. Not normally a big deal either way. They do slow down the loop slightly though, so if you have performance issues, you could try removing them. With high enough iterations, it could shave off noticeable time. 

Given the description, I'd probably call this instead. You're using it for a heuristic, but the function itself is not a heuristic. It returns an actual value. You then use the exact value as a heuristic for which move is better. That's a characteristic of how you are using it rather than a description of its nature. 

The paradigm that I've seen is to put the class loading in a separate file that is required based on the page. Also note that it doesn't seem like you'd need every class on every page. Shipping leaps out at me as a class that is likely to be used on only some pages. Also Login (except the single question -- is the user logged in, which might live better in User). I'm more accustomed to seeing the class files loaded right before they are used. In particular, the Database class is often loaded right before the first connection is made. See WordPress for an example in the require_wp_db() function. Incidentally, this is an example of a question that might be better off on Stack Overflow. You aren't really asking us to review your code. It's more of a PHP question. 

One of the problems with C is that the at the end of a block after an may mean that you are done with the or it may mean that there is an . The C compiler won't care if you have a hundred lines of whitespace before the else, but people have a reasonable expectation that done means done. Please either cuddle the or at least make it the vertical equivalent: 

This will likely work as your program is written now, but it is not robust in the face of possible changes. In particular, if you changed how you handled an inactive region B. It would be safer to check if region B is active (missing macro) and explicitly return 0 when it is not. It is also vulnerable to direct manipulation of and . Since this is C not C++, you have no encapsulation protection. If you do keep this the way it is now, you should comment it so that someone modifying this code in the future knows what you have done. Essentially you have optimized this based on the fact that an inactive region B will have both start and end set to and . 

What's this cast out of and then back to get you? If it gets you something, this would be a great place for a comment. 

As a general rule, you want to put the interface on the left side, not the implementation. This makes it easier to change the code later with a different implementation of the same interface. 

New Algorithm But we can do even better. Note that this runs times iterations. But we don't actually have to check every category against every product. We just need a way to look up the category for a given code. 

Note that if you want the exact original functionality (match any string that contains the number 5), you could say 

If I had these variables, I'd call these something like and respectively. When I see a plural variable, I expect it to contain multiple things. That is, I expect plurals to indicate collections. These don't hold the open tags and elements, just the counts. But I actually wouldn't have these variables. More in a moment. 

Again, I could easily tell that these stored Peggy and Sam Nodes. What I don't know at this point of the code is what a Peggy or Sam Node is. This suggests to me that this is the wrong place to be declaring these variables. You may want to thing about how you use class fields. I see no reason why any of these couldn't have been set in the methods where they were used. As a general rule, shouldn't need class fields. If you do need fields, perhaps you should have created another class where fields would make more sense. Perhaps . Your depth-first search and other methods might make more sense there as well. 

Note that I renamed it. I don't like as a name because total is singular but you're defining an array. I would expect something named total to be the sum of the items or something like that. I'm going to leave off describing what to do with totalPoints, as you haven't written code using it. Again though, I don't like the name. 

Given this example, you don't need any variation of the Factory pattern. You could just create the objects directly. As a general rule, you shouldn't look to use design patterns. You should meet problems that can be solved by the design pattern. You don't have a problem that needs a design pattern to solve. Example of a problem that needs a Factory pattern solution: given a passenger count and a cargo weight, return an object representing a plane that is capable of carrying those passengers with that cargo. Example of a problem that needs a factory method solution: define an interface for a plane and another that will allow you to create a plane object. Give the interfaces to two partners. Have one write a that implements your factory interface and the other an . Both should return plane objects that implement your plane interface. 

In your for loop, I don't see any reason for the inconsistent variable names. Why tries and attempts? Why not 

This reduces your repeated code. Of course, it won't work as well if the exceptions aren't just off by one in the ranges. Although if 1050 were supposed to get the 0 set, then you could use an || to move that value from the 3 set to the 0. We might be able to suggest something better if we knew what odNumber, k, h, k_inv, h_inv, and f were and why they are related. For example, if odNumber is the Orson Dines catalog number of a set and the other numbers are dimensions of the parts, you might put those in a database. Then you could read the values from the database as necessary. 

You don't actually need to return anything in this case. Just let it fall through and the compiler will automatically return the appropriate value. 

I don't quite understand why you are marking it as unvisited. You did visit it. You just found that it wasn't on a valid path. OK. So is not visit status. The earlier comment was wrong. 

So if the array is full, we can no longer set any elements? That seems like a bug. We should not be able to add elements in that case, but we should still be able to change existing elements. Write instead