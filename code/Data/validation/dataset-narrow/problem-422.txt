By using , which effectively says the referenced data will not change by using the other pointers, again, more optimizations can occur. 

The adage is cute but not universal. To zero a string, code only needs to . This is a performance issue in the general case - here is not a major issue either way. Best to follow group's code guidelines on this matter. If coding guidelines encourage initializing arrays, this is very usually accompanied with initializing all variables. 

It is not clear is always in the range [0...63] when is executed. I'd expect cleaner code in that shows this. 

There is lots of small stuff that muddies seeing the overall flow. My apologizes for only a primarily low-level review. 

and not used. Consider deleting. Why does code use for size information such as and others instead of ? It the goal to work on 32-bit platforms or smaller? is the best type for size and array math being neither too wide nor too narrow. Mis-match format various places such as used, expected. 

Minor: Style: I found the vertical spacing excessive creating challenges seeing the overall flow. YMMV 

Since alignment is certainly something less than 127, any integer type will do for our purposes. Could use , , . The cast of is redundant other than to remove the My GCC 4.5.3 compiler says the on the return type is ignored. 

The net effect of is 1 of 1,000,000 different results. (Seems weak and is reminiscent of an online poker hack that use the second of the day as a game seed: Only 24*60*60 different decks). Recommended to use more of "now" to achieve more than a paltry 1,000,000 different results. Example: 

A index in a recursive function is 1) used incorrectly 2) should be avoided. The goal of a function is code re-use. OP's relies on , which although good to initialize, only happens once. Subsequent uses of OP's would need to somehow need to do Even if code set before each call to , code has trouble in a multiple thread environment, unless separate copies of are employed. Conclusion: do not use a . There are better approaches. 

Cast not need. Modify for out of memory to free - not needed if code will simply exit, yet good practice to put your toys (code's pointer) away. 

has the same value of , yet incorrectly fails due to differ signs. Values of 7, 10 and 15 throughout code should 1) be driven by a common named constants and 2) not a magic number. IMO, for typical and I would expect 9 and 17 significant digits printed to allow round-tripping the text back to the FP variable. (Of course this is mostly debug code.) goes against the spirit of IEEE math. Even if both are both NaNs with the same bit pattern, they are not equal. Unsigned fixed width types makes sense for . I'd use rather than Potable code should use fixed width for 

Limitation "only sorts arrays of pointers." --> Op's code handles pointers to objects. Pointers to functions may be wider than . 

Pedantic code would inspect and as code really as 3 outcomes: Same, Different, Failed to compare. Should occur, the comparison is uncertain. I would expect return codes from to reflect the above 0:Same, 1:Different, Negative values: various open/read/close errors. 

Consider instead functions instead. To catch negative values, use a signed version. Oddly, is "valid" non-overflow input. 

Fundamentally, code is relying on with a greater precision than . Better to code a solution without this reliance. Else how to code a version? only uses as a non- to do trimming. I'd expect code to cope with a string. The code modifications needed are small. Re-order for clarity by starting with space and sign handling. Suggested layout: 

Using upper case in one situation and lower in another looks wrong. Although on further examination, given the case-less compare, it is OK. 

Pedantic code would check (pesky embedded null characters again.) and once a line was read, look for a rare input error with before calling . If null characters in a line are a real concern for correct functionality, is not the function to use. -- Minor: Extra outside 

Respect the presentation width. This should be easy to accommodate if code is auto formatted. Time spent manually formatting is inefficient. 

Use error detection With non-numeric input, and following code will not function as expected. Handle bad input. For now, simple whine and take your toys home. Later you can add more sophisticated error handling. 

To insure output is seen before read, flush the output buffer after writing to , especially if the last character is not a . 

Amend --> to better convey function's interface and allow calling with a array. is the "Goldilocks" type to use for array indexing and array math without being excessively wide nor limiting. Re-order parameters. goes with yet is separated by . Many C library functions list the result pointer parameters first "output" and then the "input". 

In general, OP is attempting to use where it is not the best tool. Although named "str-n-cpy" and sounds like it should do string copy respecting a buffer size of , it does not. Although named "str-n-cat" and sounds like it should form a string by appending 2 string respecting a buffer size of , it does not. Certainly this is to be "safer" code, yet with incorrect usage code would have been as "safe" with . Consider other approaches. In particular, when a string operation encounters an insufficient buffer, simply truncating the result is weak. Better to fail or report the error. 

Primary review requests (of the non-test code) Portability concerns: Might a common or rare case fail on some select systems? Handling of exceptional/error cases: Any suggested alternates? Performance concerns are appreciated when they are backed with real measurements. General comments (on any code). 

Much like coveted 1 and 2-letters URLs, creating a constant named can easily collide with other code. Further, looks like a for my tastes. 

Incomplete prototype declaration. Using allows following code to wrongly pass parameters and the compiler does not warn. 

Do not include files before . should do this to insure is not dependant on some file tidy up, remove , etc. Good use of functions. Print-like functions should return . 

Complex macros: Unclear as to the value of . Instead make a function. Clear pointers. should not assume what the calling code does afterward with and its fields. Since this code frees the allocation, then the pointers and zero the count. 

Seek clarification or state functionality on edge cases "program needs to find the min element in each column. Then it needs to multiply the row in which the element is, with the difference of its indexes". What should happen if the min value occurs twice? Fold like functions together Only difference between and is the header text. Pass that in. 

Avoid empty parameters lists: Rather than , use . This approach will certainly cause a compiler warning should code call whereas will not. 

Error: Lost pointers. may reallocate and then that function never free the newly allocated memory. will then free the original value of causing a double-free. Likely code should be re-worked to pass the address of to . 

I have found a sample usage of the routine (maybe in the header file) surrounded with a useful asset. 

Minor: Why isn't the first vs. . Just to maintain symmetry? Why use instead of ? Portability? If C99 or later available as the minimum standard, better to use . 

Architecture idea: Code reads the entire file into memory, coverts it and then conditionally writes it out. 

The various calls to like code suggest that a helper print function should be written. For printing , I find more informative than . Rather than allocate to the size of the type, allocate to the size of the de-referenced pointer. It easier to code correctly, review and maintain. Putting the part first insures any integer math is done with at least width. Checking for a allocation makes for robust code. 

Simplify coding, review and maintenance. Is a ? Why bother attempting to co-coordinate the type of member with the call which may be in another file? 

Including .c files can be done, yet forming .h files with the global functions and variables and using separate .c compilations is more idiomatic. 

The following runs down each string twice, once for length determination and a second for copying. It "parses" the variable arguments only once, but then does need to save those results somewhere. 

Consider the end of piped user input may not end with a , so although a trailing is very common, it is not a cerrtainty. Recommend to test for . 

Design The below set codes in C functions for types: . Each function calls a "wider" function when is large. Should the widest math prove insufficient, a slower bit-by-bit version is called. 

Weak functionality Below are 7 test cases that failed OP's code. Sample working code provided. is a bit ponderous, yet useful as a test competitor. 

Minor Format to presentation width With an auto formatter, this should be trivial to shorten lines past presentation. 

Weakness Unnecessary loss of accuracy. The unposted is unclear, yet it certainly is returning a truncated result. Instead of truncating the 96 bit values to 52(53), a better answer can be formed, like above by using "round to nearest even". This implies a potential increase in exponent. And an increase in exponent can lead to infinity.