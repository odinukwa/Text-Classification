In both of your calls, you're asking for the two different parts to use the same mapBase and tileBase - in other words, the same area of VRAM. To make matters worse, you're actually asking the console to overwrite its own memory - it'll use the same VRAM for the map and the tiles. There's a very handy tool online for checking these VRAM allocation conflicts, and you can fiddle around with it to find some good numbers for you. However, there is one big problem: your 256x256 background is going to use up a full bank of VRAM. The NDS has 2 graphics engine, a "main" engine and a "sub" engine. The main engine has access to much more VRAM than the sub engine, which can only use one 128KB bank for backgrounds - and the console also counts as a background. You will therefore have to exploit the fact that the screen is only 256x192. The simple way would be to just move the console to the end of the bank, but that isn't possible on the sub engine. Instead, you'll have to move your background deeper into VRAM, say to map base 1 (16K), while the console occupies base 0 for the 4KB of tiles and base 2 (4KB in) for the 2KB map. Note that you must limit your background with this approach. That means you'll want to do the following initializations: 

There are a number of reasons why a PC port can take a while. (I apologize if I seem to be repeating myself somewhere; this is sort of written on the fly.) Adapting controls and gameplay When you're playing on a console, this alone puts certain limitations on what you can do, since all the user has is a gamepad. Just creating 1:1 mappings between keyboard keys and controller inputs is not always a good idea - if even possible - so sometimes it takes longer to figure out a good solution. Hardware abstraction/Fragmentation When you develop for e.g. a Wii U, you know exactly how a Wii U behaves, because all Wii Us are identical. This is not true for PCs; you have many different graphics cards and CPUs, and sometimes something won't work on some of them. It takes a lot of testing to uncover these bugs, and fixing them also takes time. If you've never used your engine to make a PC version, you also need to code your hardware abstraction accordingly. Some games want to support multiple DirectX versions and OpenGL for Linux/Mac, and all of that takes time to write if it hasn't been done before. Resource contention On consoles, the game doesn't have to compete with an OS for resources, etc. - not a whole lot of stuff goes on in the background. On a PC, you have the OS running, you have a plethora of background programs, and this all means you won't get as large a share as you were hoping for. This means you sometimes need to perform additional optimizations, especially for players on lower end systems Improving assets With a console, you have a fixed target, so you write shaders, etc. to match that target. On a PC, some graphics cards support more advanced features, and maybe you want to use a better shader for those. Well, that means you'll have to write that shader. Platform-specific stuff Console SDKs may have a lot of convenient features that don't map over easily to a PC - for example, it might provide access to hardware timers or a good sound API. Those things aren't usually available on PCs; you need to use other ways of accomplishing those things and maybe that changes how you have to abstract the platform differences. 

This way you just import the file/module and use it as a normal dictionary. If you want to add scripts, you can make use of the dynamic nature of Python and 1st class functions. You could do something like this: 

Although I believe that would be against data driven design. To be 100% DDD you'd have infomation (data) specifying what would be the functions and code that specific weapon would use. This way you don't break DDD, as you don't mix data with functionality. 

(I'm sorry to submit the answer instead of a comment, but I don't have rep yet.) Vaughan's answer is great, but I'd like to add my two cents. One of the main reasons you'd want to use XML or JSON and parse it in runtime is to change and experiment with new values without having to recompile the code. As Python is interpreted and, in my opinion, pretty readable, you could have the raw data in a file with a dictionary and everything organized: 

I think reducing the effectiveness of Defense is not a good option. Depowering a player leads to a bad game experience. Why not go the other way around? Why not powering up the Attack as time goes by. This makes scratch damage increase with time, reducing the incentive of blocking. In mid-late game, a character can kill another while wailing on him while he's defending. Some pnp rpgs implement a "tension mechanism". Each turn tension increases by one. All the rolls have the added modifier of the tension value, pushing the battle towards an end. Another idea, coming from Fighting games, is an attack that goes through defense. I don't know if your game is turn based or real-time, but this attack could also open the opponent to a combo or disable him or some of his abilities temporarily. I believe the trick is not to undepower defense. Make other options just as good as defense, or reduce the times where defense is a good option. 

(The tool uses BgSize_B16_256x192 when used like this, but libnds doesn't define that constant, so I've changed it.) There is some chance that the actual console or some emulators will still break with this, because you're allocating beyond the 128KB limit, but as long as you don't try to write beyond, you should be okay. If it turns out that it still fails, another option would be to use this: 

Since Hearthstone is written in Unity it is trivial to decompile the scripts (because .NET), and this does in fact allow us to see the algorithm for deck building. The algorithm (found in ) is actually very simple. It basically tries to pick random cards to bring the deck to the following distribution: 

With a Label, the only way would be to keep your text in a string variable and manually handle all key events by changing the string variable accordingly. Clearly, this is far from ideal. If you want a quick and dirty textbox, you should use TextField, which does all of the hard work for you. Of course, this assumes you're sticking with the classic UI system, which your code snippet suggests. If you're using the new UI system, add an Input Field to a Text control. 

The function takes an argument to specify the number of cards to pick, and it will attempt to randomly pick that many cards matching the first unmatched criteria in the list above; if it cannot pick enough cards from matching that criteria, it moves to the next one and continues until it has enough cards. If all criteria have been processed, it just picks random, valid cards regardless of the type or mana cost. When asking for recommendations, it picks 3 cards; if you ask it to finish the deck for you, it repeatedly picks one card until the deck is full. This only applies to personal deck building; cards for Arena decks are picked by the server (see class ), and might therefore follow a different algorithm. 

See Ultima Online. It has 3 Attributes: Strength, Dexterity and Intelligence. 3 Derived Attributes: HP, Mana and Stamina. And a ton of skills, from weapon related skills, healing, stealth, cooking and even forensics. No levels! Character development is continuous rather than discrete. You improve your skills by using them, an by increasing them you also increase the attribute related to the skill. IMO, it's the most interesting character development mechanics in a game. It would rock in an sandbox single player game. I think the levels in TES games are not really needed. 

I like the ideas of Rechargeable item and item with a Cooldown, but, as Nicol Bolas said, that doesn't make people use them. In fact, to disagree a bit with him, as I'm more inclined to hoard a rechargeable item than one with a cooldown. The Cooldown is tricky too. If it's too short, maybe the attack shouldn't be too powerful or it will ruin the game's balance. If it's too long, players may save it for the "really tricky and hard boss" that may never come. Are the players aware of the coming challenges? Can they see the enemy before engaging them? See MOBAs (DOTA, LoL, etc). A character's ultimate attack is the big powerful attack, that has the biggest cooldown. A player may or may not engage an enemy depending on whether the ultimate attack is recharged or not. My take on the matter is a bit more "gimmicky". What about an item with a cooldown that "levels up" the more it's used. It starts weak, or with only one effect, and with use it gets better. With some time invested by the player it may become a really powerful item and a viable strategy. It also plays with the players curiosity, making him want to discover the new abilities. 

I imagine most people don't create indie games necessarily to make money. If they are thinking that way a lot of people might be thinking in long term monetary gains. IE they would rather put a game down on their resume that shows they have experience making a game which could possibly give them a leg up on others who don't. Then you can say you started to make money from your indie game when your employer tells you it was your game you listed on your resume/cover letter that set you apart from others. You also got to consider the crowd that your game will be bought by. The most impressionable gamers are probably the younger ones who can't afford games right away and must wait for something like a BDay/XMas or beg their parents to buy it. More than likely the only games they will be subjected too will be the heavy marketed games by those who throw millions into it. That leaves you with a smaller crowd of people who are more curious about what could be fun on an XBox/Mobile device etc. rather than actively seeking out the best indie game ever made. You might even then be hard pressed getting someone to pay more than $5 for a game if they think they won't play it more than a couple of hours or while they are on a plane or something. You also must consider that anyone you distribute your game through is probably going to take a cut of your profits as well. Someone may say they have the tools to advertise your game but they sure aren't going to let you use them for free when there are 100's of other good indie games out there that can be sold as well. So all in all if you are trying to get into indie games for money you probably have the wrong idea. I think the best thing to do is put it down on a resume. If you think it gives you a leg up in the hiring process then it definitely has a positive expectation on your future monetary gains.