This code can be simplified a lot, and in to a single update without the cursor. This may be a problem, though if your transaction log is not large enough to accommodate a mass update to all your records. Right, how to simplify the update? First, build the case statement in to the logical table... Consider this: 

Metrics like the cyclomatic complexity are only useful when taken in the context of your code. For example, your method has numerous calls to JSONObject where it could throw a JSONException. Each of these calls adds one to the complexity (or should do). On the other hand, I think your exceptions are not overly complicated, and the code looks fine. So, in this case, I would look at the code, and note that with 5 calls to and at least 8 conditionals, that's already a complexity of 13... Then the additional 2 catch blocks, brings you to 15. For the method, as I look at it, it seems just fine (the complexity does, anyway). I would be more concerned about two other things (bugs).... You have a concurrency bug (same bug twice), and a poor Logging bug (multiple times). Concurrency Bug Your code: 

Splitting A trick of loading an empty-string in to your decode-routine to output a space, will allow you to use a regex to split, and process each line, in a stream: 

That should be almost the same bhaviour (except that it is called , it is thread-safe, and that the enum fields are now also final, and private). Static initializer blocks are uncommon, but can be very, very useful. 

You have non-final non-private statics, and I presume they are accessed from all over the place. Additionally, the is public? Your classes should be properly encapsulated, and state changes should be only possible from triggers that are managed from inside the class. The messages in places like: 

That function (not a lambda) takes a partial solution, it generates all positions on the next row, and, if the position has no conflicts, it adds a new (extended) partial solution, and outputs that. The outer part of your qu method loops through the partial solutions so far, and then 'calls' the inner part. Taking the outside part, and making it functional, I came up with: 

In the hashCode method, I suspect this is auto-generated code. It's OK, but I thought there would be a way to integrate but there may not be. AdjacencyList This code looks fine too. The one comment here is that I would prefer to see a more batch-oriented integer conversion of each line. I would have a method like: 

Note, in the above, that , , etc. all are actual wires. It would also be idiomatic to resort to having everything in pointer-space, and use the keyword.... returns a pointer to the value. The result would be: 

Ohhh... a juicy question. Your specific concerns are about the GET calls, but let me address some other things first.... General You have put your entire server-socket loop inside the constructor of the server. Server socket loops are never pretty, and I can understand your uncertainty of how to handle things, but I would suggest one of two things: 

Obviously the tail of the file is harder to do. This is a much more challenging situation than getting the first 10 lines. You have chosen a system that requires complicated byte manipulation to get bytes in to chars, and I don't believe the system will work for non-ascii files where the character encoding of the data may have a second-byte of 0x0A causing a mis-parse of a new-line. For simplicity sake I would still recommend you use a forward cursor, and a circular buffer. This will work for all files regardless of the size, but the performance will be related to the size. On my system though, even 20MB files were done within moments (0.3 seconds according to the bash 'time' command). So that are not too large (a couple of megabytes), and is easy: 

Overall your structures look OK. Your actual XML document could be indented more neatly, but it's OK. I would recommend that you change your element to have an attribute. Using the PCDATA space is not a great place to put a numeric value.... Actually, I would recommend adding a attribute to the element (seems like a logical place to put it).... 

When I have encountered this type of problem, it typically involves creating some ugly code in your method to do that iteration. In essense, there is no way to do things any differently, you have to iterate, and collect the UUID's (but, you could wait for Java8 and do lambdas ..). But, there is no reason why you have to do it outside of the class. A trick you can do which keeps like-code together, is to put a static method on , which does: 

You are right, that's not legal in Java, but there is a relatively common trick to doing this sort of thing (and this trick can sometimes make complicated constructors really quite simple): 

A few comments on this... What is a character? In your code, you are only counting non-spaces as characters. But, if the user enters that counts as 10 characters to me..... From my perspective, Characters can just be . Still your definition appears to be 'non-space characters'. Using that definition.... Now, about the regex. You describe 2 ways to count words, and one way to count non-space characters, and then, for some odd reason, you count newlines as well. So, if I were to suggest that the best way to do it was with just one big, and few small regex... ? The big regex is the most complicated to run because it needs to do more complicated matching on a larger value. By stripping the value sooner, you can make it faster. Note, you do not need the word boundary markers when dealing with either or . 

@mjolka was able to identify the root problem before I was ;-) There are two issues in addition to what he has pointed out. The first is that it is very bad form to create new Random instances on each partitioning. Random instances internally synchronize on some logic structures, and cause a lot of overhead in their creation. You should instead have a different mechanism for the partitioning. Additionally, your naming is horrible: 

Apart from that, really, everything looks sane, and far better than a typical perl hack. I am impressed. About perl using all your memory... are you sure? perl may just be struggling to allocate more than it is allowed. Do you have a ulimit condition that is constraining memory allocation? Are there problems with heavily fragmented memory? (You're not running 32-bit, are you... just checking?) As it happens, for a task like this, you may find that everything is better with a language other than perl. Not to dismiss perl as incapable, but with the XPath expressions and other items your code looks surprisingly complicated. 2.5gig files are way beyond the normal I would consider for perl performance. 

in your case you should use lower-case You can remove the utf-8/unicode declaration if you encode the values in the more-pythonic way of unicode escapes. 

There are a number of things here to comment on. First up, you don't ask for anything in particular to be reviewed. So, I just scanned the code, looking for 'oddities'. There are some aspects which concern me. Marker interfaces are seldom a good idea. Why do you have ... I cannot see a single place where you actually use it as the marker. All actual usages are defined as either or . It adds no value that I can see. Additionally, you have a complciated SerializationProxy mechanism set up. I cannot see a reason to have it though. What's wrong with just plain serialization? If there is a reason, I can't see it, so it should probably be commented. Serialization proxies are an ugly workaround to an overly complicated process. Don't make it more complicated unless you really need them. By all accounts, the whole purpose of these classes are to provide a way for a class to encapsulate a lot of data fields, and then allow those to be serialized. The data fields are stored in a Map. Classes of this type are unfortunately bulky, and ugly. Unfortunately, though, your solution is still bulky, and a different sort of ugly. I would stick with the more traditional format of having a whole bunch of setter methods, and instance fields. Keep it only a standard form of ugly, not an indirected/abstracted ugly. Finally, the use of Optionals is.... unconventional in this format. Perhaps things will change more with Java 8, but I can't see a reason why the methods have to return an optional, when a null will suffice. You are creating a lot of typically unnecessary overhead.