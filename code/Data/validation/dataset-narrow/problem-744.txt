method has signature. You should avoid such methods and use instead. It is acceptable to mark event handlers with . is used only in event handler, so do the following changes: 

Also I recommend to extract all subconditions to methods with appropriate names. It will make your code much more easy to read and understand. 

Thanks @Nikita B for pointing out that should be done before . In your case you can just return from the method if there are no elements in the : 

If some arguments of a public method is invalid you should say about it to user. The native way in .NET to say about something is wrong is an exception. So instead of returning some "invalid" value throw an exception: 

you didn't pass parameter name and actual value. I recommend to use 's constructor that takes 3 arguments: message, actual value and parameter name. Here 

The advantage of this approach is you can forget about and other -methods. If you need to add another character in the game, you'll just put in one of the arrays. No additional actions required. Also use camelCase for local variables instead of PascalCase. I mean you should write in the code above instead of . Another one recommendation is using of keyword when the type is obvious (but I use it evrywhere :)). 

Use to name local variables instead of words separated by underscores. Although there are no guidelines for them it is common practice among C# programmers. You should always call to get instead of creating . , and any other writer implement and thus should be used within section: 

Data Handling & Security You use prepared statements, which protects you from SQL injection, which is good. However, the way you handle passwords could be improved to increase security. It's not a good idea to semi-randomly apply sanitation functions to user input as it results in dirty data. for example really only makes sense when magic quotes is enabled, so you should check that first (and then only strip the slashes in some init file, not every time you access GET). For example, if a user has a password like this: , stripping slashes reduces the password length from 9 to 6 characters. Same problem with , only much worse. If my password is , now my password is . You also don't need . As XSS protection it's not sufficient anyways (and definitely not needed for passwords, which aren't echoed); You should HTML-encode data when echoing it instead. There's also really no need to have a length restriction on the password, especially not one that is shorter than what your hashing algorithm allows. Hashing Simple sha is really not good enough anymore, as it's too fast. Use bcrypt instead. Error Handling Don't echo database error messages directly to the enduser. They won't know what to do with it, and it may provide attackers with information or enable some forms of attacks (such as error based SQL injection). It's also not a good idea to echo anything in a function, as side-effects like that make it harder to reuse. Structure I think your structure is pretty clean, and your code easy to read. Just a couple of small points: doesn't seem to have any purpose. I wouldn't call the constructor inside a function of the same class, but just use it directly. I would also not pass a magic array to the constructor, as it's hard to use and reuse (I have to guess how the array must be build and what it must contain, and I have to use the pre-defined array keys). Instead, just change your constructor to . This increases clarity and reduces future bugs. Misc 

First of all, why has 10 elements and everywhere you counting from 1 to 9? Let this array to have 9 elements and count from 0. 

Solution Methods should have PascalCased names as well so and have to be changed to and respectively. WithinSingleEditDistance You can simplify a bit your loop: 

method not only pauses a game but also resumes it. So either give another name to the method or split it to two ones like and . Also this code 

Using UPPERCASE_CONSTANTS_WITH_UNDERSCORES violates naming guidelines used in C#. Just use PascalCased names. 

I recommend you always use instead of type-as-string. There are cases where things like just will not work. One example is implicit data templates. 

Let's see example of how you can remove from the . First of all, view -model should implement interface which contains event: 

If you are adding something to you don't need to call since it will be called automatically. So this code 

Also, can you say what purpose of ? :) You perform swapping of array elements many times and repeat the same code in all these places (loops commented as shuffle arrays). Define the method and use it: 

In my opinion using bool return values is appropriate for methods that are purposed for checking some conditions. Examples: 

If and in your code is the same and you supposed to call instead of in the inner loop then your code can be significantly simplified: 

Also will wrap your internal to readonly collection preventing user from changing it. And then if user want to use array he will just call on returned value. 

Looking on this lines some people can say that omitting curly braces is very very very bad. Although I don't mind to place them for every I decided to go away from this "rule" some years ago. I totally understand what problems curly braces should prevent but I need to say that I never had any issues with s without them. So it is just a matter of taste. But you can use them and if you feel you are not experienced enough it probably will be better. 

First of all, I'm going to assume that this is for educational purposes only. If not, see Don't roll your own and Don't be a Dave. What you have is basically a variant of the caesar cipher (well, more or less). You take each character of the input and add a fixed amount (the key) to it. Some parts of the output also depend on previous calculations, but not all of them (not at the beginning or at the end). I haven't yet looked into it in-depth, but the first problems I saw are: 

Performance It works fine for me in Opera and Chrome, but it is buggy in Firefox. Profiling reveals that is responsible (big surprise :) ), and there is not much to optimize without changing the whole concept. Two minor optimizations might be: 

Of course, this still doesn't add anything over the much simpler implementation of just returning directly, but it should show the advantages of lambdas in general. 

If this code is representative of all your code, then yes, I would suggest a complete rewrite, using more modern concepts (OOP, MVC, template engine, some framework, etc). Until then, I would probably take the website offline, or at the very least add a web application firewall to the server. Security Your code is currently vulnerable to SQL injection, XSS, and CSRF. You need to look into prepared statements to be secure against SQL injection. Some frameworks also provide ORMs or query builders, which may make it easier for you to securely access your database. You then need to HTML encode user input when echoing it. Most templating engines also provide this functionality, and some encode per default (which I would recommend). Most frameworks also offer some mechanism to protect against CSRF. Structure Your code is too long and not well structured, as you don't have any functions. Because of this, it also contains quite a bit of duplication (eg the edit/add forms which are quite similar, duplicated select queries, etc). Most frameworks would make it easier to structure your code well, as they for example use MVC, or expect you to program things a certain way. Misc 

is bad since you throw the same exception for different parameters and without any details. Also I believe suits much better for . And you doesn't check on . Also it would be better to have ability to pass any as rather than only. The same can be applied to return type of the method: can be replaced with which allows you to use and . Benefit of this approach is that returned collection will be immutable (of course you could use , but I prefer in this case). Thus I would rewrite the method like this: 

First of all, don't use underscores in fields names. Fields like , and so on should be renamed to , . You should use camelCase for private fields, parameters and local variables. Also don't shorten parameters. Use instead of . All methods in C# should be PascalCased. It means you should change to . 

Every time you need to check if a value is presented in a dictionary and if yes then get it, you should use the method to avoid double search of the value by key. So instead of 

You didn't move every class to separate file. You didn't define all your magic numbers like 21 and 52 as constants. Also there are blocks of code that can be significantly reduced. For example this code 

Looks like C-style. If method returns enum return enum. Define a field in like and return it. And then compare result in all s with rather than with zero. Do this for all methods where at now you return 0 as . 

You've been already told in your previous post that you should use instead of . Although it is completely up to you using of is common practice. 

Combining both of these functionalities in the same class can get confusing quickly. construct Why does the constructor do sanitation? You already have , shouldn't that be responsible? And where is the result actually checked? basicSanitize The name alone already suggests that this isn't a great function. It's so generic, this function could be doing anything. Let's look at what it is doing (adapted from my answer here, as these kinds of functions are quite often combined, even though they shouldn't be): 

User-based salts are managed automatically for you, and it uses multiple rounds of hashing, slowing the process down, and thus increasing the resources an attacker needs to crack your hashes. You can still use a pepper with bcrypt if you want to. For more information about password hashing in general see here. Misc 

Your constructor also defined etc without using it. If you want to stay with your approach, the assignments should look like this: Input Checking Right now, you just accept anything the user passes. For example: 

No, this isn't the right way to use OOP or MySQLi. First of all, you only provide two methods to access your wrapped mysqli instance: one to get data, one to post data. This hides a lot of useful and necessary functions. You can't even use prepared statements with your code, making it incredibly insecure. You also didn't really gain anything with your functions. With your functions, your code is: 

As KIKO Software and the documentation for crypt said, . It's safer (it applies multiple rounds of hashing, thus increasing the time it takes to decrypt the hash), and it will manage salts for you, which means that your code will be simpler. If for some reason you do not want to use , note the warning from the crypt documentation: 

You should release COM objects in block to ensure that references are released even if an exception is occured. For example: 

Please use conventional naming of properties. instead of for example. Also, why do you use instead of if you use index only to get an element of collection? Use and your code will be much clearer. First thing that should come into your mind when you encounter many and calls which need to determine if an element should be added into a collection is to use . Use for and . Main problem of your code is a lot of repeating loops and duplications like . Please learn programming basics and particularly C# basics. All your code can be rewritten like: 

View-model should never think about view if you want to write good WPF apps which means you should use MVVM correctly. Your and properties violate this rule. What are these indices? Where are they used in the view model? As I can see you use them only for updating view: 

I agree with all things said by @TopinFrassi and want to add some additional notes. If you have the same code repeated multiple times extract it to a method. Define method like this 

So if you are able to check that call of a method can cause an exception before its execution, create the method for checking some conditions and call it before: 

It is completely wrong. You should expose a property which defines kind of day state and then react on changes of the state in view via binding and converter or triggers. So you need to read again about MVVM and take a look at examples of proper implementation of it. 

Error Handling Returning false isn't a great way to handle errors. The calling method has no idea why the code failed, only that it failed. Throw exceptions instead. Also, sometimes you don't even return false, but just ignore errors, which makes it really difficult to find bugs. Functions Your functions look good to me. Their scope is narrow (most of them either load or save stuff), which is how it should be. You could further improve your code structure by putting these functions in appropriate classes. For example, and could either go in an class, or in an . Naming Don't shorten variable names, it makes code hard to read. , , , , , , and so on are very unclear. 

Initially, the code is a bit more complex, but it's more reusable and adding new items is easier, if that's something you expect in the future. If you know that the only difference in the keys is always going to be in the first two keys, you could also handle that as a special case, remove it from the array, and use for the rest. 

* this would somewhat increase security as it makes it more difficult for an attacker to use leaked sessions. Of course, if the attacker has eg XSS, they can simply read out the user agent (or use CSRF to perform any action the victim can perform); still, it's a good idea as defense in depth. 

Now it's still easy to use these functions, but you get rid of the duplication, which increases maintainability. 

As soon as you print double digits, your pyramid doesn't look quite right anymore. This will only get worse with three digits, etc. But if this wasn't a concern in the question, then your implementation looks fine. Naming @Heslacher already mentioned , but all your other variable names are also not expressive: , , , , . You should avoid using one-letter variables except in a very limited number of situations ( and for loops in case there is no better name, and for coordinates). Better names would be: