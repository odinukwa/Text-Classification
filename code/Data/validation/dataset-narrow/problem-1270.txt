You should probably start with an open source 3d physics engine like Bullet. Remember that games that have funding can hire professionals that are well versed in kinematics that can draft models in math-lab and then have programmers implement them in the code. So the best way to fully implement a systems like this would involve learning about cars and physics, I think that is beyond the scope of one question. This might help you get started? Car physics for games: $URL$ Open source 3d physics engine: $URL$ The Disney car 2 game uses this engine. This is just a short video that demonstrates what you could achieve with an advanced 3d physics engine like CryEngine3 $URL$ Basically, I think this question needs to be broken down to smaller questions, some of which likely belong in SE physics. It is too broad a subject to be properly covered in the current medium. Development of such a project is incremental in nature, you have to take a step before you can walk and walk before you can run. So I'd suggest starting with a small and rudimentary car simulator and adding features. That way you can allow the time needed for each feature, to study it in depth. Perhaps like you suggested if you find like minded programmers, each one can focus on a different feature once you have the skeleton of the engine running. It is sometime possible to negotiate a deal with a company to use their existing engine to make a game in exchange for a portion of the profits or a large sum in advance. 

You would need to cap the framerate to a framefrate the player's machine can handle constantly. (the lowest framerate the game reaches when computation is heavy) Calculate the distance from the current position to the first destination. Divide that distance by the speed you wish the character to move at divided by the current framerate to get the amount of frames it would take to reach the destination. This could be a none integer number such as . We round this number to the nearest integer number and calculate a fake speed of . We now move the object at this rate each frame. 

I would need to see a video of the game first to give a specific answer. I personally would implement functionality to pause and reset the game and also to transition to the next stage. In most cases I would not pause the game in stage complete / game over state and simply display a sprite with the relevant text. Then I would either transition to a new level or reset as needed. I don't think you really need to use this hack / work around and instead ask about the problems that stem from your attempt to pause the game. Alternatively you could put focus on completing the game and ignore code smell. If the game is fun and it works, it really does not matter how clean and tidy the code is unless you wish to extend it or use code from it in other games. 

A texture-atlas (is often taken to mean a large 2d image that) contains many textures. You can think of these as 2d images "painted" over 3d objects or otherwise applied to them as part of a shader to explain to the renderer (the part that converts 3d data into a 2d image) how they reflect light (normal map) or if there are any grooves, bumps or cracks on their surface (bump map) or possibly something else altogether like opacity and what not. This term (texture atlas) will often be used in a game environment. Any 3d object (e.g a weapon, a garbage can) or character can have a texture applied to it. Especially 3d levels may require multiple different textures for various walls and elements in the 3d scenery. All these textures can be contained accessibly and effectively in a single large image composed of many squares (subregions) devoted to a specific model. 

How many attacks (turns), should it take to defeat that boss / minion? How should different skills, buffs, debuffs affect battle? Should it be hopeless, should winning be less / more likely? 

One last thing is that if you are using the Object Pool pattern and an entity gets reset because the creature died (for instance) and respawned somewhere else, a reference will still point to the same entity (fault) and an ID will no longer remain valid. ID 5067 points to address 0x8765 creature dies and another spawns new creature ID is reset to 7073 Someone checks for ID 5067, it points to 0x8765 but that creature is now registered with the ID 7073 so the entity ID database knows you used an obsolete ID and informs you, the creature you have tried to reach is no longer active. That and all the wonderful reasons Byte56 mentioned are why it is a good design to avoid using references directly. 

"I want to see where my movieclip colliedes with another another movieclip." Actionscript offers pixel perfect collision detection between bitmapData objects. It does not offer straight out of the box a tool to detect the exact points where the two objects overlap. How to detect where two objects are 'touching' on another? 

I will try to clear it up. You are checking if a bubble can reach the top.. Don't. Run your DFS starting from the top and simply remove (drop) unvisited nodes. 

You do not need to have a different collision callback method for each type of collision. You could implement one callback: To treat different types of objects you can have collide-able objects implement an Interface that has a function, collideWith(obj); and perhaps and possibly Then each object checks the attributes of the object it collided with and responds appropriately. For instance a bullet may pass through a wooden wall, bounce off a metal sheet and knock off a tin can. The insides of will look like: 

This can be summed up to (with some algebra) - I will omit .(x,y) for readability (they are still points, not one number) 

Generally I think it boils down to code maintainability. In your current design, would adding a new component require you to update all the others respectively? Or would it suffice you add some code in one specific spot. If it's the former than you may be doing something wrong. The reason I often use systems is that I don't wish to expose all the data (instances) to all the components. I also don't want to "spread my code to thin". If there is code that is strongly related I'd rather have it in one place where I can update all of it in one full swing. Using a system (at least) appears simpler because all the interaction between objects is handled by a specific external unified body of code. This way I don't need to expose aggregations of instances to every specific component. On the other hand it is important to avoid the "God Object" Anti-Pattern. Each aspect of interaction should be dealt by a unique system relevant to that specifically. This (I think) helps me when I find data has been corrupted. I know more specifically where to look and how to track the fault's source. There is nothing wrong with combining this approach with the alternative one when this becomes relevant because a certain behavior / interaction is perhaps unique to a specific component. It can be avoided though by having the components interact with the system. 

sqrt is a wasteful function in processing time. $URL$ That will allow you to detect collisions. The issue is that collisions occur in-between the movements. When you calculate and check for collisions, you need to find the time of collision and base the result of the collision on that factor. It is easier to use a pre-built tested physics engine if you wish to address this. 

It is possible, the limitation is not in the software. Depends on the resolution of the video and the total amount of frames, it could use a lot of memory. The reason a video is not saved as collection of jpeg's or png's is compression.Raw video data in a resolution of 512 x 512 and a frame rate of 10fp that lasts about one minute would take about: 

Credit to prof. Shlomi Rubinstein If you are using weighted edges, you can accomplish the same thing in polynomial time by running Dijkstra instead of BFS to find the furthest vertex. Please note I'm assuming it's a connected graph. I am also assuming it's undirected. 

In reality I am pretty sure the bullet would pass through a plaster wall, that was just an example for a third option. You will probably need a mass property if you have many objects of different sizes. For instance, a tin can will be low density and have a low mass value, meaning it will bounce off when hit by a bullet and the bullet will continue in its trajectory. Some items will need to be of a fragile variety such as glass, so you will destroy the item if it is hit by a bullet and animate this process. All the properties I described exist in physics engine except fragility, however physic engines mostly assume objects cannot pass through one another. You could try and override that behavior programatically. Simply by not checking/acting on collisions between bullets and materials of low density. 

Even if you do use splines, doing spline computations during the game is wasteful. Normally one would break the spline in advance into a series of even segments (specifically positions on the spline with similar distances between them) [p_0, p_1, p_2 ..p_n] and use this to guide the players' character motion. The logic is still very much 2d in nature.. move right, increase your characters value and advance towards specifically: 

Where is the original array and is the new one. You can save these arrays in your code. While this is not impossible to crack, I suspect I would not bother trying. I imagine most gamers (99% +) would avoid trying to edit a file like this. If you really want to go the extra mile, there are some encryption techniques like RSA that are not very complicated to implement. 

Then use with a tiny amount to slowly increase the speed in that direction If the angular speed is too high, stop increasing the speed: 

& are our current speed on the x and y axises. & Is the time it would take you stop only vertically or horizontally considering your current speed in the relevant axis. & are the distance on each axis. tl;dr:you continue to accelerate (if possible [unless you reached top speed]) on x-axis until you reach a spot where the following condition is true: 

Original answer: Why would you implement threads? Unless they are used to resolve a performance problem, they are a waste of time you can invest in your next game project. If the game is not processor heavy I am not sure threads are a valuable improvement. They mostly affect systems powerful enough to handle the game without threads in the first place. To answer your question: I believe there is no advantage in using multiple timers. One timer saves on memory and processing time. As far as I know, one time can be used with multiple threads. That is an issue that could be resolved in another question if you encounter a problem with threads & timers. Reply to Krom Stern: Why threading is negligibly important in simple 2d games: 

Math.sqrt() is indeed very expensive but you can always use fast sqrt instead. I generally would avoid this altogether. Spatial indexing works for circles of all sizes. Start with a simple grid which has been proven to be the most efficient anyhow in many tests. Use a 2d array of circle lists to conceptually divide the space to 2d-grid of squares. 

How to check for intersection between rectangles? Assuming these are the corners on the left side of your bounding box , (x is the same on both). 

What is the least computationally complex way to find two points such that the distance between them is greater or equal to any other pair. Remember hearing something about how you could find such a pair by randomly picking a point , finding the point furthest away and then finding the most distant point from it, . The diameter is then the distance between and (i.e ). Is this correct? Can you prove or disprove it? What is the correct way if this is incorrect? 

This article about threading suggests it is mostly used to take advantage of multi-core systems and while older CPUs like my SU4100 exist that have multi-core, they are still more than powerful enough to support a well built 2d game without threading. 2d-Games have matured 15 years ago. If you look at great 2d games like 'Castlevania: Symphony of the Night' you will see that technology did not greatly affect the quality of 2d games since 1997. It did completely revamp the looks of 3d games since Quake(1) which has little relevance here. When I said high-end systems, I did mean modern systems in general. I corrected that now.