Applying a matrix to your SpriteBatch transforms the entire draw call at once. This means you don't need to use your camera in your DrawTiles method at all. It could become a lot simpler like so: 

It's worth noting that I didn't align the red lines with the exact edges where the black meets the blue. You could do this if you want, but it's not strictly necessary. In many cases the lines can be pretty rough estimates and it'll still work just fine. Obviously, the goal is the be able to make the source image bigger (wider and taller) without stretching the borders. The 9 patch method does a pretty good job, but just keep in mind that the middle (4) and the sides (1,3,5,7) will still stretch. Depending on your texture, the effect might be great, or it could still look stretched. You sometimes have to fiddle with the numbers to get it to look okay. When you render the box, typically the corners (0,2,6,8) won't stretch, the top/bottom (1,7) will stretch horizontally, left/right (3,5) will stretch vertically and the middle (4) will stretch in both directions. There's a couple of ways to think about these 9 patches. One way is to think about them as rectangles, which they are, but another way is to just think about the distance between the lines and the edge of the image. That's what I've done in the following algorithm from MonoGame.Exteneded. 

The idea here is very similar, except that you can create more than one instance of it and run them in a loop. One difference with this implementation though is that it returns false after the action has fired rather than repeating the action over and over. I'm sure you could make the modifications to make it repeat if so desired. 

Algorithms are specific solutions for specific problems, for level generation you don't need algorithms, just logic. First of all you need a specific idea how the maps should look like, then you need a few abstract data types which describes the features of the map, in this case those could be: player start point, platforms, pathways. Now you have set those you need to distribute them: where should platforms be placed and where the player start point? Also how many platforms? When you have done that you can connect the Platforms by Pathways. Having that basic structure set up you then can place game play details: you could connect a few platforms by jumpers and put item spawns on others. Short example pseudo code: 

Basically the world gets devided into chunks, and get loaded and unloaded depending on the distance to the player (in the background). When the player enters a area that isn't loaded completly yet a loading screen is displayed. In the case of single player games, such as the "The Elder Scrolls"-Series, the chunks are divided after distance from the player, things in near chunks are calculated in-detail, frequently, the more far away the chunks are the less frequent and the less detailed the calculations become to save processing power. The things in far away land might even only ever updated when the player approaches them, the player won't notice anyway. Another thing is LOD (Level of Detail), each chunk of the landscape mesh is saved multiple times in different detail levels, for chunks far away only the lowest detail level is kept in memory, for chunks near the highest detail level is used. For procedurally generated landscapes, like those found in the Diablo games, when loading a chunk it is checked if this chunk was already generated, if yes it is just loaded from the hard disk, if not a new chunk is generated which is then saved on disk. In the case of MMORPGs, such as World of Warcraft, the whole world is calculated and saved on the servers... the invidual clients wouldn't be able to do so. If the server isn't powerful enough alone then the chunks are distributed between multiple servers. The distance can't be used here because the players are everywhere, all chunks need the complete power. 

And much more. I'd download it and play with some of the samples they have included that demos much of it's functionality. 

Data drive your characters with LUA scripts or even XML files. When you interact with an NPC, grab the file that is attached to it, read it in, adjust for any game variables that may have been triggered, and product the valid response. The biggest gain from doing it this way is you can easily go in and manipulate the dialog, add new characters, etc. You also avoid mucking up your code base with special logic in handling each and every case. 

There's nothing quite like the routine of tweaking a variable, compiling code that takes a few minutes, executing the code, realizing that your tweak was in the wrong direction and repeating the process all over again. I would like to start interacting with my game logic while a session is in progress. What are some of the ways you've handled doing this? I would be open to hear solutions for iOS, C/C++ and C#/XNA. 

I have seen a couple of things in the past where I have seen a crowd majority buck their heads. One really sticks out in my mind: Little Challenge In a prior project, I leaned against the word 'casual' a little too much. I imagined people picking up this game and simply solving a simple feat and moving on. I didn't integrate any kind of losing mechanism per say, but left that for the player to determine. A 'did the player meet his/her expectation' type of situation. Judging from the feedback I received I see not giving a clear losing mechanism a mistake and a missed opportunity. It seemed that those players who wanted a way to lose actually enjoy knowing they've lost. I guess that may sound obvious, but I wasn't quite thinking about it that way. Reward a Player By nature humans are always trying to achieve that next best thing. I think there are some instincts at play there. At a young age our mind was a buzz when we got a new toy, for example. So in a game I imagine that a player who is given something along the way will improve the fun-factor. I assume this is exactly what Achievements are targeting - a direct reward. 

As you can see custom content importers can be quite daunting at first, but once you've done a few of them they are not too bad. I hope this clears some things up for you. Finally, to answer your other question. 

If you can't see the MonoGame Pipeline Tool in the list you'll need to "Add..." it manually. This can be a little tricky because it installs into an odd folder by default. On my machine the is located here: 

The downside is the extra effort required to setup a content project and manage the process of building your optimized XNB files. Here's a quote taken from the link in your question for clarity. 

I suspect your issue lies in the way a sprite batch works in MonoGame. The performance cost is coming from using different textures for each tile. Let's take a peek into the MonoGame source code and see what's going on. If you follow the code down through SpriteBatch.End you eventually end up in the SpriteBatcher.cs class around about here: $URL$ 

If you're not using the NuGet package for some reason, the DLL lives with the Pipeline tool in a rather obscure place. On my machine it's located here: 

You might also need to use some tolerance checking on the Delta values to see if the user has actually dragged a significant distance. Not sure. That said, it does seem odd that the API behaves this way, it could it be a bug in MonoGame. It might be worth bringing this up on their forums and/or checking it against the behavior of XNA. 

Yes, you can develop with MonoGame without relying on XNB files. I've been doing it for over a year now and for the most part it's fairly straightforward. The main thing you are likely to have trouble with is 's. What I do is pre-render my fonts onto a texture and render them like normal sprites. I've got a little tutorial over here: $URL$ I've never had any trouble with files and files work okay too but you have to make sure they are in the correct format. I haven't tried using shader's or anything else really, but I have created a couple of complete games. 

The big advantage is that you will have much greater artistic control over it, since you can create textures like this with almost any application and can replace them by more complex sprites if you ever want to. 

In most games the physics are not synchronized as it either requires a lot bandwidth or a completely synchronized network code. The synchronized network approach means that at the start all data is the same for all clients, and the whole game is calculated on each client in the same time steps. Just the controls the players push are transferred. If all game logic is deterministic then all games will keep in complete synchronization. Upside of this is that this approach only needs a few kbit's to work properly, no matter how complex the game is. Downside is that the controls of the players are delayed by the lag and that it requires a fixed time step that is the same for every player. A fixed time step also means that if one player lags all players will notice that lag. This approach is/was used by strategy games mostly due to the large amount of units. A quick note about determinism, floating point implementations can differ from processor to processor, so they are deterministic as long all devices you target have the same floating point implementation, if you can't be sure of it you'll need a physics library which uses fixed point math. 

You just need two different clocks instead of one, one for the time relevant to the gameplay and one "true" time. 

Is this a PvP game? If so you should look at ELO ratings: $URL$ There is a pretty basic idea behind it. Each game changes your rating, this change is solely based on your rating and the opponents rating and wheter you have won or lost. 

Fail Early, Fail Often Well, it is pretty hard to 'fail early' when your project is out of the door. Hopefully the feedback you gain from the above will shed light on processes that may have been pretty dark to you. There are problems that you will run against that will sting pretty bad. It'll be pretty difficult to just forget those. To make sure that you don't forget the problem areas it could be handy to write a 'Core Value' type list that you keep at arms reach. Keep them available for others to see and for you to see. When the your next project starts I might be inclined to bring some of these to the table to get other people's perspectives. If you have new eyes on the project you might get feedback that could shed new light on solving a particular issue. As long as you're aware, and you keep your problems in the light, you're bound to solve those issues. Write It Grab all of the writings and bring it all together. 

It probably sounds obvious, but... Don't full-screen your game while you're recording the video otherwise it will 'obviously' be incredibly slow because it captures your screen resolution. I'm guessing this is what you're being bit by. FRAPS will take care of this just fine. So will many others but I found FRAPS the most convenient and easiest to use. I used FRAPS to record and Windows Movie Maker to put together some maps I made in Starcraft II -- example. 

I would really like to hear how other independents generally approach marketing their game with limited resources. I know how critical marketing is since I've seen it first hand on several fronts. I've been part of teams that didn't put an ounce of marketing into their project and didn't come close to meeting expectations. I've also poured a lot of time into visiting forums to discuss our previous title which resulted in minor bumps over time. I really think Wolfire is doing some amazing grass roots marketing with the way they are managing their community around their Blog. They've massed a following that is willing to pay (far in advance) them for their game before they finish it to help support them. That's awesome. But how many people are really willing to divulge such information that early? Should that be a concern? Should I start talking about my next project before I really have anything implemented? What has worked for you? I would be particularly interested to hear how people approach Apple's iTunes store. I believe we're looking at around 33,000 games on the store these days. 

Supply white and the brightness will remain unchanged, supply black and the sprite will become black, supply something brighter than white the sprite will become brighter. (Brighter than white would be 2.0, 2.0, 2.0, 1.0) As a added bonus you can also colorize the sprite this way, supply pure red and it will become (dark) red. And you can draw them half-transparent too by changing the 4. parameter, the alpha channel. If you don't need that just multiply by a single float instead of a vec4. 

The problem with adaptive difficulty is that games live from problems the player "overcomes". If you analyze the strength of the player then that is very linear and predictable. Either it is too easy all the time or too hard. I would suggest the opposite: Instead of changing the wave difficulty depending on the player strength let the player adapt to the difficulties ahead. Generate one difficulty progression at the start of the game and let the player know it in advance. If in 2 waves enemies will come that are resistant against arrow towers, tell the player. He will than be able to change his strategy accordingly. Add a user select-able difficulty level and you should have a game that is enjoyable for both "hardcore" gamers and "casuals". How you generate that wave progression is a different question and will require a lot of tweaking values until you get a satisfying result. I would suggest first putting down some "milestones" and then interpolating between them. E.g. 

For calculating things less often while catching most errors from this you'll need to predict if the object will change the grid cell it is in soonly. 

So far so good, now we can already check if the two hexagon's intersect. But it get's even better. This solution will work for any convex shapes (for example triangles) and any sweeped convex shapes (for example sweeped octagons). However the more complex the shape the less effective it will be. 

Have you thought about using a good API to help you with your flash development? Take a look at Flixel and Box2D. 

AI in MMOs are pretty ignorant. You're dealing with a world where you have the potential to reach millions of players all of varying skill. If AI in MMOs were really present you would see creatures constantly rush attack your healers, then go after the cloth wearers, etc. But we don't see that. We see a system that gives a mob x health and an attack rating depending on it's level, and a faction that it falls under (which makes it attack people whose faction differs). They run (sometimes) when health < y, and might trigger more mobs to help if condition x is met. The system might do a DX roll to see if the attack/spell hits or not, and goes from there. If one player is attacking a lot (raising threat), creatures turn to that player. So this system is very, very basic. There's not a way for a casual player to flip a 'casual' switch. From there we do get into some 'advanced' encounters that appeal to the hard-core crowd. But even these are not fully automated by AI -- they're scripted events. Once a high level guild takes a week and figures out how to kill the King of Dreams, then they can pass the encounter details to casual players. I remember back in EverQuest that you could start a conversation with NPCs and you could trigger different actions by saying certain things! Some linguistic AI. 

I would supplement those questions with specific questions relating to the team and project that you personally want to know from a management position. 

Big companies tend to create group atmospheres. Artists will hang out with artists. Programmers will hang out with programmers. Testers will probably hang out with support. You will have to make an effort to network (lunch, activities). There is no reason why you wouldn't be able to create good relationships with developers.