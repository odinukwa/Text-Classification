My blaster is driven by a Pi gpio. It is powered from 5V and the IR LED is switched on and off via a gpio connected to the base of the transistor. I've used it to send fairly standard IR remote commands which are typically quite short, of the order of 40 bits of information. You should note that the IR signal is built on top of a modulated carrier in the region of 38 kHz. You typically send a bit by a burst of carrier (say 400 Âµs) followed by a gap whose length determines whether the bit is a zero or a 1. Air conditioning units tend to have much longer commands, being perhaps several 100s of bits long. I haven't tried to send such commands (I don't have such a device) but in principle it should be possible. Of course there are the commercial solutions such as the one pointed to by Steve. 

Generally a continuous rotation servo is just a modified standard servo. A normal servo takes pulses (typically 50 times per second) of between 1 and 2 ms in length. One extreme moves the servo to a fixed position clockwise, the other to a fixed position counterclockwise. Pulse lengths between those values move the servo to a proportionate position. Continuous servos also need pulses (again typically 50 times per second) of between 1 and 2 ms. One extreme rotates the servo at a fixed high speed clockwise, the other at a fixed high speed counterclockwise. Pulse lengths between those values move the servo at a proportionate speed. Pulses of 1.5 ms in length should stop the servo. In short, nothing will happen until you generate PWM at 50 Hz with an appropriate pulse length. 

There are several different GPIO numbering schemes. You need to ensure that the software you are using is using the numbering scheme you expect. See $URL$ for the gory details. The most popular numbering schemes are 

You'll need to weigh those advantages against higher code complexity compared against the standard SPI interface. An experiment in bit-banging SPI on the Raspberry Pi 

As far as I am aware this area is only relevant to those who want to write wiringPi extensions. An extension is a software module which extends wiringPi by adding support for a new type of hardware chip. E.g. if a new chip is created with 128 GPIO you could write an extension to use those GPIO with the wiringPi digitalRead and digitalWrite commands etc. The pinbase for the chip would be the number to be used for the first GPIO on the chip to distinguish those GPIO from any other currently being used by wiringPi. 

The code is not formatted properly so I did not try to run the script. Are you sure you copied the code properly? I would expect to see a set up of the GPIO numbering system to be used, i.e. GPIO.setmode(GPIO.BOARD) or GPIO.setmode(GPIO.BCM). Neither is it clear which SPI channel you are using as this is concealed within the MFRC522 class. For the sake of answering your question I will use Broadcom GPIO numbering (BCM in RPi.GPIO code). I will also assume you are using SPI channel 0. SPI channel 0 uses (Broadcom) GPIO 8, 9, 10, and 11. Make sure you do not use any of these GPIO for your keyboard matrix. See $URL$ 

You need a receiver tuned to the frequency of the transmitting device. They can be bought inexpensively from the likes of eBay. E.g. this 433 MHz module You can power the receiver from a Pi 5V pin. This means the data line will also be 5V. You need to use a pair of resistors as a voltage divider to cut the 5V data line to a Pi safe 3V3. This would let you receive the signals on the Pi. Making sense of the signals is a separate issue. You'll have to search for someone who has decoded the device or do the hard work yourself. 

NOTE. Do not download a package directly from Debian, always use the Raspbian repository. Downloading from Debian is likely to get you a package built for the wrong CPU architecture which is a pretty sure way of breaking your system. 

You can use multiple USB serial dongles. They will appear as /dev/ttyUSBx where x will be a small number such as 0, 1, 2. You can use any serial software you want. They will all use the Linux serial driver "under the hood". You can connect one serial device directly to the Pi expansion header on TXD/RXD (GPIO 14/15, pins 8/10). The device must be 3V3 TTL (i.e. 0V for low and 3V3 for high). Voltages outside that range will eventually destroy the GPIO and the Pi. You can use any serial software you want. They will all use the Linux serial driver "under the hood". 

You can use an external pulse width generator or one of the modules which uses DMA to time the pulses (e.g. servoblaster, (my) pigpio, etc.). Alternatively use software which supports the hardware PWM pins on the Pi (e.g. pigpio). 

I believe the Pi will be fine with that arrangement. The voltage (3.4V) is slightly larger than the official 3.3V limit. The excess current will be easily handled by the GPIO protection circuitry (excess voltage 0.1V, resistance 4700 ohms, current 21 microamps). Remember the resistance values may be +/- 20% anyhow. 

The activity and power LEDs on the Pi3 are now connected to a GPIO port expander hanging off I2C bus 0 (the bus you must not use on the Pi3). There is a mailbox interface to the LEDs. An (untested by me) example of using the mailbox interface for the activity LED is given at $URL$ I presume if it works for the activity LED it will also work for the power LED. 

I have done a bit of experimenting with the general purpose clocks. This information appears to be correct (on the post date). Refer to $URL$ pages 102-108. The clock frequencies were determined by experiment. The oscillator (19.2 MHz) and PLLD (500 MHz) are unlikely to change. Clock sources 

Here is the list of processes which are started by Debian on my Pi (this is Debian I'm running, NOT Raspbian). I suspect they are pretty much all necessary for your application. They do things like provide a wireless network, read/write files, log events, get the time, accept key board entry, display on the screen etc. etc. You could stop any you don't need. I think that would be a pointless exercise though, they won't be taking any CPU when dormant (perhaps 99.5% of the time) and use an insignificant amount of memory. 

EDITED TO ADD My assumption is wrong, the man pages are not installed with the Raspbian wiringPi package. One work around is 

At the moment you are doing what is called a "busy spin", consuming all the CPU time in your while loop for no purpose. 

When you use RPi.GPIO you can specify one of two gpio numbering systems. GPIO.BCM says you will use gpio numbers as defined by Broadcom. GPIO.BOARD say you will use pin numbers. The following diagram shows pin numbers and the gpios connected to them on a board with the 40 pin expansion header. 

The .dtb are the compiled versions of the text files. They are not intended to be read. You will need to find the corresponding .dts files. Look for the .dts files on github under $URL$ 

Some people have reported success using the module combined parameter to trigger repeated starts. I have done so myself but I have not found it to be reliable. In my tests eventually a I2C segment will fail and from then on I2C transactions will go wrong. To recover the situation I stop using the combined flag (see i2cz for details). 

It may just be the difference between configuring the gpio as an input or an output. I expect gpio export 17 out configures gpoio17 as an output and actively writes 0 or 1 depending on the last setting. I suspect gpio read 17 is (erroneously) setting gpio17 as an input. It will no longer be driven by the Pi but will take the value of the external circuit (which seems to be driving it low). You could check by using my pigpio pigs utility. 

I suspect this is an unwanted feature (perhaps a bug) within wiringPi. If you use GPIO18 for PWM wiringPi assumes you want to use hardware PWM and tries to program the hardware PWM peripheral. However unless run as root wiringPi has no access to this hardware and will crash. A workaround is to run your program as root, i.e. precede the command with . 

That is a fault in pigpio/gpiotest and/or the hardware revision returned by the Pi Zero W. gpiotest relies on pigpio to tell it which GPIO are safe to write. pigpio relies on the hardware revision returned by the Pi to assemble the list of safe to write GPIO. If pigpio does not understand the hardware revision it defaults to granting access to GPIO 0-31. I shall change the default to the 40 pin header in pigpio (GPIO 2-27). In hindsight that is probably a better default now. What revision does your Pi Zero W report? 

The SPI library uses the SPI hardware. I suspect the Adafruit code was written before the SPI library was written and uses a technique called bit banging to access the MCP3008. Bit banging will be much slower than using the SPI hardware. 

What CPU utilisation do you expect when the code is in a continuous loop? I expect 100%, anything less and there is something wrong. Is there any reason 

The 5V power rail is driven directly from the micro USB socket (power supply), i.e. it is unregulated. Its quality depends on the quality of your 5V power supply. 

modprobe is not in a standard user's path as it is not runnable as a standard user. It requires superuser privileges to run. If you use the command sudo modprobe the command will be found. sudo which modprobe will show its location, normally /sbin/modprobe. Try launching the script using sudo, i.e. precede the command you use to launch the script with sudo. 

The official image include Wolfram Mathematica. Wolfram Mathematica currently only works on wheezy. If Wolfram Mathematica ever works on jessie I'd expect the official image to change to jessie. 

Stop worrying about system services. They will only take CPU time if they are active. Normally they will be dormant waiting for an event. Of course they will occupy a little memory but if you run short of memory they will be automatically paged out to the SD card. 

The most accurate way to send pulses from the Pi is probably my pigpio library. Examples include a Python morse code program transmitting to a LED, with the basic pulse length being 40 microseconds. The pulses can be as short as 1 microsecond. 

The RPi.GPIO module uses software timed PWM which stops when the script is exited. Your only solution with RPi.GPIO is to leave the script running. If you can use GPIO 12, or 13, or 18, or 19 you could use hardware PWM. You would need to start hardware PWM with wiringPi or (my) pigpio. If you leave the pigpio daemon running you could control PWM from the command line. 

Presumably the gpio utility is not installed. The gpio utility is bundled with the wiringPi library. Install wiringPi (if using Raspbian) with 

I suggest you add the mount to either the root or your user crontab. Given that you are currently using sudo the root crontab appears to be the most appropriate. sudo crontab -e # to edit the root crontab Add a @reboot entry to the crontab. You need a line such as @reboot (sleep 30; /bin/mount /media/disk1)& That'll wait for 30 seconds before mounting the disk. 

Power off Connect your device to SDA (Pi pin 3), SCL (PI pin 5), ground (Pi pin 6) and 3V3 (Pi pin 1). Power on Your device should be visible on the I2C bus using i2cdetect 

On mine you assert a chip input to write new data to that chip and de-assert it afterwards. Yours will be similar as documented in its datasheet. 

I'd take the ser = serial.Serial(chip, baud) and place it in the initialisation part of the code, perhaps after root = Tk(). If you repeatedly open "/dev/ttyACM0" without closing it your code will crash eventually. Another problem is that the Arduino is continually sending readings which you ignore. You should be consuming all the readings otherwise strange things will happen as the buffer fills and is left with half a reading. Find a way to continually do the reads but hold the value locally on the Pi. Print out that most recent local value when "a" is pressed. 

There is no program logic difference between the os system calls. They will both run if uncommented. There may be a difference in the side-effects. In particular your script may be changing GPIO 6. You have a pull-up set on GPIO 6 which means that the default button state is True. That suggests the other end of the button is connected to ground. In that case your logic is wrong and to detect a button press you should use if not GPIO.input(button). If the other end of the button is actually connected to 3V3 you should be using a pull-down instead and the current logic will then be correct. 

pigpio has a Python module which can control the GPIO of a networked Pi from a Windows, Mac, or Linux PC. 

I will be publishing the code as a complete class within a day or so. It will probably replace the current wave_PWM example at pigpio examples. 

The using mode call has the advantage of seamlessly changing from one frequency to the next as well as appearing to work properly. When you have finished with a waveform it is best to delete it, that allows for the resources to be reused. See the update() method of Wave PWM 2 for an example of what I mean. 

The bcm2835_peri_read documentation may be wrong or just misleading. Try passing the address you want to read rather than a pointer to the address. e.g. change 

If the GPIO column has a V it indicates the pin is connected to the power rail and not a GPIO. Where 2 figures are shown separated by a / the first figure is the GPIO number used on the first revision Pi B boards. Here is a simple RPM counter.