D is the vector that moves A into B so if t is between 0 and 1, D·t is a "proper fraction" of D so the point A + D·t lies in the A_B segment: the brown points comes when t is between 0 and 1 and the dark green one is when t > 1. Now we can simplify things if we move the circle's center into the Origin. This can be always done because is a simply change of coordinate system that preserve geometry, angles, intersection, measures etc. 

As you see P' is in length greater than r while P" is less than r. Since both the vector lenght and r are positive numbers, the relation of order of being greater or less than are preserved is we compute the relation between the lenghts squared and the radius squared. P*1 and P*2 are the point that makes the |P|² equal to r² As mentioned in the pre-edit section, we arrive to get a quadratic equation where t is our variable. As is known solution values of t range from the case when t is a couple of complex numbers - that means no intersection; the case when t are two equal solution - that means that there is one intersection; the case when there are two distinct solutions- that means that there are two intersections. The Discriminant is used to discriminate the previous condition and a validity test is done on t to see if it a valid intersection but outside our segment - i.e. the solution t has to be real and between 0 and 1 to be considered a proper intersection that fall in the segment A_B 

I suggest you to embed an interpreted language into your game engine. This is a quite proven strategy, the main reason you should not write your custom "script parsing procedures" is that you will never get enough. You will add functionalities to your script engine over and over, until it will start to look like any general purpose interpreted language out of there (but more ugly). Good choices are: Lua, Javascript, Python (maybe Ruby), Guile and probably many others. The best way (in my experience) to manage this integration is to export a Façade that both simplifies your script manipulation duties and let you to decide what/how expose of your game engine functionalities. In practice your game engine adds the instance of the Facade to the interpreter context and ask such interpeter to evaluate a script file; that script will find an istance of that Facade in the global context when executed. A good strategy is to let your game engine to delegate to a script set (found in specific folders) the execution when something happens (onInit, onBattleBegins, onTick, onProgramCrash ect). This is how every -base plugin system works for every program usefull enough to deserve a plugin system for customization. If you are good enough, your game engine has some sort of event management system. In this case you can write a generic extension of your reactor that looks for scripts as event handlers. One last thing, consider to write all your game engine using an interpeted language. I can hear you from here "what about interpreted slowness?" This is a quite false problem: every interpreted languages allows extension at different level: to extend is easier than to embed. An higher level language let you to focus to the matters of your application: when the things start to go slow you can profile your modules to see the bottlenecks. Once you have a bottleneck you can try to fix that or to reimplement that using a lower level language. 

the circle approximation for the infinitesimal neighbourhood of the spiral in t [DISCLAIMER] This is not intended to be a rigorous mathematical treatment: it does not take into account the contribution of the differential of f nor say what types of function can not be used. 

I always suggest to try to stay peer-to-peer in communications. This generally avoids bottlenecks and single-point-of-failures, in other words it scales. In you case i would set up an Reliable UDP connection and use a reactor to unify network and gui events. Obviously this does not resolve the problem with Service advertising beyond the local network, in this case an index server can not be avoided. I am aware that this is only an arhitectural indication; I can't help you more to the point because of my lack of experience with cocos2d but I hope this can help anyway 

What about Bézier curve? A segment is basically a first degree BC but you can construct second or superior degrees curves that are still segments. I suggest to you to use a cubic BC having the two control point laying on the segment itself. Doing so you can control the speed of the point when moves out the first position and when it reaches the final point. These are the recursive formula for BCurves 

In this method you iterate the containing object looking for the method "does%s" % eventName. something like: 

If you need just to take into account a displacement, you simply have to know where your origin is in standard coordinate system (the one the listener returns). Say that your (0,0) is at (150,322), this means that when you get P = (x,y) you can get P' = (x-150,y-322) to get the point in your coordinate system. To make it clean try to transform your origin P = (x=150,y=322) => P' = (150-150,322-322) = (0,0); lets take a point that is 100 pixel on the right to your origin: P = (250,322) => P' = (250-150,322-322) = (100,0), that is what you need. If your coordinate system is not simply a displacement of the one your system provides (rotation, shear, scale involved), a change of homogeneus coordinate system is required. EDIT: As pointed out, the requirement is that the coordinate system has to produce the same range coordinate even if the view area resizes. I assume that the aspect-ratio of the view and the scaled coordinate system is not an issue. Let say that the dimensions of your view area size is W x H and your system gives you values for x and y so x: [0,W] and y: [0,H]; we want that the transformed value to be x: [-w,w] and y: [-h,h]. Let start by computing the transformed x: x' = x/W => x : [0,1]; x' = x/W · (2w) => x : [0,2w]; x' = ( x/W · (2w) ) - w => x' : [-w,w] and hence y' = (y/H · (2h) ) - h => y' : [-h,h]. You have to know - or ask the view for - W and H and set w = 319 and h = 239. 

Now we have a simply way to compute the lenght of P when t varies and say for which t P crosses the circle's boundaries. 

Qt does support OpenGL. Take a look to Open Inventor and consider if make it sense for you to go straight to an higher level 3D API. 

One can opt to rectangles but the show a small Area/perimeter ratio compared to cirlces. The bigger the border the more particles will leave. While the cicles exhibits the best A/p ratio, can not be used for tessellation, so you should indagate for some (possibily semi regular) tessellation with a good average A/p ratio. Obviously computing the tassel index by cell coordinate should be simple so consider this before to try a very exotic tasselation.