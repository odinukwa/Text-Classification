BigInteger operations are slow. Each iteration through the process you are creating a new BigInteger, as well as a new instance. These instances are likely more expensive to process (and garbage collect) than the time saved through lock-free management. Still, using a three-state operation you can solve this problem without the class: 

the circular dependency is real, and, as a result, you can't have linked with both , and . It works with only one. you will need to rebuild your test cases - they are now horribly broken. 

use a loop that counts back from the end of the input/output. Then you don't need special odd-length input handling. identify whether an input char is going to be a high or low nibble in the result. use a lookup table (low/high nibble) to find a byte value for that input. use a bit-wise OR to add the low and high nibbles together use bitwise AND and bitwise right-shift to convert the input character to the output byte/nibble position. 

I can believe it when the replace is the problem... it's creating a mess of nested code that's creating a lot of intermediate string values. There's not much I can see to improve, though. The nesting can be reduced by combining a few of replaces...: 

Method extraction. Even for simple programs, having multiple responsibilities in a method is poor practice. Consider simple extractions, like: 

Your code is neat, and, within the confines of the "Solution", you have solved things well. The algorithm you use is the right one, it's implemented well, and it's all clear. I like it. There's only one thing that concerns me. The interface of the class: 

Could this be considered a basic brute-force? Sure, for a limited use-case, but even then it is pretty inefficient. To be clear, normally a brute-force system requires checking all combinations against some hashing function to see if the hashed result matches the hashed password. For example, imagine the password is "password", and the hashed version of that is: (that's the actual MD5-hash of "password"). What you normally have for a brute-force system, is the hashed version, not the original version. You would normally have to generate many possible passwords, and hash the results, and then see if the hashed results match the known hash, and from that, deduce that the passwords must have been guessed. In your case, you are just checking each letter 1-at-a-time, against the raw password. That's not a very realistic situation. Still... you are brute-forcing things. Let's work your algorithm to make it more efficient though. What you are doing is reading files until you find one which has a password that is only letters through . How about code that does the negative of what you have: 

Then, you should have an anonymous listener that handles just that one view, and it calls back to the non-anonymous handler: 

It is almost always a problem if you see multiple of these systems in the same class. Thread safety is complicated. Each one of those strategies has complications, and combining them in one place compounds the complications, and never simplifies them. Volatile Further, in Java, the concept is hard to describe, and use cases for it are limited, and it almost never solves the problems you think it does. Additionally, volatile semantics changed in Java 1.4 and what it did before that is different to what it does now. Worse, in your code, the usage of solves nothing, and just makes things slower. I would even go so far as to say that any time you think you want to use , you are wrong. Think of volatile as being like the "GOTO" of concurrency. Sure, there may be cases where it is useful, but normally there is a better way to do it: 

You already have the static methods on that class, why not make them constants: ? As for the remainder of your code, your code is neat, the generics look clean, There's no need to add another level of abstraction. 

it creates a random number generator it generates a random number it opens and reads data from a file and then closes it. it generates another random number it opens and reads data from another file, and then closes it. it generates yet another random number then another it builds a string value from a number of components. sets the value of the field to this string 

Now, this is an encapsulated object. To extend this object, so that interested parties can 'listen' for rotation events, you can have listeners registered with the class, with 'callbacks' that get fired when the rotation changes.... This is called the Observer Pattern. You should take a moment and read through all the common patterns, and you will discover a number of tools you can use for common problems. 

If the bounds have been previously calculated, then it will be very fast. If not, it will have to do a lot of work, and additionally create a bunch of instances of . In essence, if you check the bounds often and don't change the Polygons, then your bound-check is amortized quite well. If not, then you are doing a lot of unnecessary work. In order to improve the elapsed time (execution time), about the only two things I can recommend are: 

I believe the overall strategy of managing a 'diff' concept is, in the long run, the right strategy. Additionally, the concept of the Holder is good too. The problem with the global read-locks, and alternatively, the blocking write-lock while the data is flushed, is hard to overcome without introducing more granular locking. I have taken the liberty of re-implementing your code with some alternate schemes. Note that there is no global Lock mechanism. There is a single AtomicReference which contains the current 'strategy'. The simple strategy has almost no overhead, and will have no performance impact on the general use case. The more complicated LoggedThrough class extends the PassThrough strategy, but it logs all operations going though, and does not pass the values back, unless the recording is complete (the snapshot done). Once the snapshot is complete, the LoggedThrough class can fall-back to a strategy of handling each Holder independently as they are called (get, put, etc.), and a background process flushes any inactive values. The 'magic' in this granular locking is that each Holder is individually synchronized, and knows its own state. This state can be safely dumped to the backing store, and when it does, the Holder becomes a simple pass-through entity. 

Note how you can use the blocking nature of the actions queue to handle most of the logic in your code. 

ICMP does not appear to be an option for you... you say you are pinging 'servers', but I think what you mean is that you are pinging 'services' (actual applications running on the server). You connect to the host:port combination. You could even have multiple services running on a single server. A brief run-down of your code suggests: 

Be careful there, it's possible that t.x and root.x are very, very, very close to each other, but not quite the same, due to some rounding value in a calculation, or something at the 15th decimal place, or something. 

First up, let's both simplify your low level class, and correct the Generics at the same time. Stack The issues with the generics are "obvious" by the numerous times you cast values that should be generically correct anyway. You also have overly complicated logic in your push method: 

For the most part, that's nice code. I can read it somewhat easily, and for the most part, it is logical, and structured. There are a number of issues in your code, though, some style issues, and some functional issues. First up, the style issues. Using the existing libraries There's a nice feature in ThreadLocal in Java8 that allows you to have a supplier for the structure. Consider a method like: 

A big part of this system is the use of listeners (and interfaces). The is how the model communicates with the Controller.... the controller then uses those events to trigger changes in the view(s). The View Most of your code duplication is related to the view. I strongly recommend that you create an enum called 'CalcButton' (or similar), and this enum looks something like: 

It ran about 25% faster overall than your code. The individual average latency on each next() call is slightly faster at 4.7us (instead of 5.2). The big difference, is that your code calculations are significantly slower, so my code 'spins' a lot faster.... While your code retried 75,000 times, my code retried 4.5million times. The difference is that your code computes and throws-away a fib number, whereas my code uses it as a spin-lock and only computes the fib number when it is free to do so.... hopefully that reduces memory churn... maybe. I create no garbage in my spins, your code makes two objects each wasted cycle. So, I run all threads at 100%, but I get results slightly faster, on average, and my overall run time is reduced. I believe the imprved latency is because the BigInteger.add operation is relativey slow, and in your code, the 'latency' of each call is in increments of that time. For example, if an add takes 4us, then your code will return in either 4us, 8us, 12us, 16us, etc. My code, on the other hand, can 'delay' for partial amounts of time, and then return after a single 4us calculation. But, if the partial delay is beneficial, would a blocking system be better than a spin system? Note that your algorithm kept 4 threads busy for 91.5ms, and mine kept threads busy for 72ms. Combined that's 370ms of CPU time vs. 290ms CPU time I tried using a Reentrant lock instead, with the code: 

There are a bunch of things which you should consider revising, including the basic concept itself. Here your concept is to read each line from the URL, count it, and throw it away. Your code does nothing with the data? What's the point? Regardless, even if the sole purpose of the code is to count a URL's lines, the code should be revised to take advantage of Java Best practices. First up, it's a cheap shot to treat the constructor the way you do. Yes, it throws a , and yes, that is a subclass of an , but they really should not be lumped together. Your method is listed as throwing an anyway, so why handle the exception inside the method and throw nothing? The calling code will need to handle the anyway. Just throw the exception and be done.... but also throw the . Next try-with-resources is your friend. Resources treated that way will not need the block at all. Finally, Java 8 does have some fantastic InputStream-to-Stream methods, use them. Specifically, the method: Your code could be something like: 

This is a much better way to show the critical logic of your program, and still make it readable. Next up, in your new AlternateHostnameVerifier class, I would recommend you implement all the interface methods fully. Leaving two of the methods as stub methods is only a short-term solution. In the future the apache-commons implementation may change and call one of the other verify methods, and then you have a sudden, unexplained bug. Specifically throwing a is a much better alternative than leaving it blank. Finally, I have a preference for methods that can to simply 'return' when they succeed rather than trying to break out of loops and keep track of variables outside of the loops. In this case, you have which tracks the state. you can eliminate this variable if you just 'return' each time you set it to true, and otherwise always throw the exception. So, you can rewrite the code as: 

Now, index 4, in our function, belongs at position 2, so we save away the index 2 value, and put the index 4 value there instead: 

JDBC Connection pools are relatively complicated 'animals'. I strongly recommend you leverage the functionality that others have built. For example, Tomcat, WebSphere and I am sure other applications servers have good connection-pooling processes. Additionally, stand-alone applications can (re)use things like the Apache DBCP component (which also supports PreparedStatement connection pools) 

I think, even though this is a special case, that this is the most important reason: when running your Java program through a debugger like the one built in to Eclipse. When you are stepping through your program the debugger will use the method to show you the state of all your variables. This is where, in many cases, you will value the toString() more than anything else. when developing or debugging a program it is often convenient for you to add 'println' statements, and they can be things like: System.out.println("Processing customer " + customer);` 

The same can be done in the tags code block. Arrow Code JavaScript is particularly vulnerable to arrow code, especially given the regular callback functions embedded in the code. You need to consider each opportunity you have to prevent nesting statements deeply, otherwise your readability suffers. Consider this code: 

;-0 It makes just as much sense as your complicated formula, and.... it produces the right result, faster. 

Is it an ugly practice? No, not by itself. Method chaining like that is even expected in some circumstances - Java streams come to mind. Your code is pretty clear, and the only changes I would suggest are: 

Note how the methods are no longer static, and their implementation can have private access to the root instance (if any). DFS1 

All in all, it looks like the code is relatively well structured, and it looks like you have some good ideas in there. 

You are right on the time complexity, but wrong on the space complexity. because you copy the data from the String to the buffer, you incur an \$O(n)\$ space complexity too. vnp has suggested an alternate algorithm that scales at better than \$O(n^2)\$, but you can also significantly improve your current algorithm. Your current system compares each character with every other character twice.... Consider the word "and", you will compare with and , then compare with and , but you have already done the and comparison. What you need to do is alter your inner loop to restrict the range of the comparison. Consider the following: 

As for your variables, they are nice descriptive names, but, in Java, it is common to use what is called 'camelCase', where the first letter is lower-case, and the subsequent first-word-letters are Capitalized. Also, while it is often convenient to shorten long parts of variables, the abbreviation of 'user' to 'usr' is not saving you much..... So, for example, your variables : 

Using a should always be your preferred choice when doing String manipulation. It does not always make sense, but almost always. Additionally, indexOf takes a 'from' location, and it makes the whole thing easier.... Convert both inputs to lower-case, then do the matching using the lower-case versions, but the substrings using the unknown-case. The complicated assign-in-where-condition logic makes the loop conditions easier, but you do need to understand what this does: 

Note that there are no reasons to have file handles.... and the lines are kept in the default variable at all times. You would use it like: 

With Java performance it is important to create methods other than the main method. Java compilation is method-based, and it often relates to how often the method is called. Since the main method is only called once, it is seldom optimized very well. In addition to that, Java is also slow, as it requires access to the console, and it is synchronizes, and flushes it. As a result, many println calls are also slower than fewer larger printlns. So, batch up your output as much as you can. All in all, create methods, batch the output, and .... use a binary search. Then, use some useful Java native methods. Split is a good one, and also try-with-resources for the input streams. With the format of your input, a Scanner may be simpler too.... 

Your "fluid" example is fine, well structured, the newlines are consistent, and is in line with code styles that I have seen and like. It is perhaps a bit too soon to say it follows "best practice", but it does look right.