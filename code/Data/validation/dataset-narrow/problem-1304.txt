I do not know how it is done there nor can you ask that specifically unless you contact the creator of that demo. What you can do is use a static body for the floor in it's present (current) state. Then use something similar to the bridge demo here (tap arrow key to the right -> three times): $URL$ When you release the bridge here you'll need to create a static surface where the bridge was. Also, you may need to create the flexible bridge with the correct constraints when the user clicks the mouse. One last thing is that it appears the surface is being pulled from multiple points. Not just the one where the user clicks but also a couple if nearby ones. 

At a certain point the character will begin to supposedly run on the ceiling. How do I keep track of this since the chracter is touching both the ceiling and the floor of the tunnel?know I need some way to know where the character's feet are positioned, keep track of it and allow this to change when the character is moving fast across curved surfaces. 

Pick a small percentage representing your speed : s = 25%; Divide the percentage by 100 : s /= 100.0 Use this method: 

There is a simple approximation you could apply here. Lets say the movement pace you want is 1.0 units per frame. You start with and a Lets say the function returns a position on the bezier, now you do a binary search like approximation: 

It depends. If the elevated surfaces could lead to other rooms, it could get very complicated unless the A* optimization function you are running is tailored with information specific to that room layout, it may need to search every possible path (like BFS). How to handle this issue: Complexity: You need a meta graph that represents rooms; i.e to get from room A to room D I go through A => E => B => D. Each room has a few exit nodes, so instead of searching the whole map, I first search the meta graph that represents each room as a single node and then inside each room, I only need to search from the entrance to the closest relevant exit. Sparsity: To represent the sparse 3d matrix of surfaces, use a hash table, every elevated surface in a room will have a vector key position in the hash (x, y, z). Each surface will be able to access any other surface in (x +/- 1, y +/- 1, z +/-1). Since you separated the world into rooms or sections, the A* graph hash for each room will be reasonably sized. 

Before you do anything read the first paragraph here First and foremost, running hundreds of threads isn't going to boost performance. It is going to instantly ruin your game. Why ? Because afaik in Windows and Linux the schedulers wakes up every millisecond (possibly more like 3) to check if another process needs to run. So if you have 50 tanks and 100 soldiers that means that you can hope for 7 frames per second. Sounds great to you? based on this link Each tool has advantages and disadvantages. If you don't need the advantages, you still suffer from the disadvantages if you misuse it needlessly. tl;dr Basically, threading is "Would you do that for me? But don't stop doing this while you do that other thing. It is also sometimes, "Would you do that big task faster if I break down into smaller separable chunks?" Multithreading is advantageous for: 

There is an easy fix for it.. You could simply batch rename the extensions in a command prompt using something like 

What we'll do: We'll maintain a list of a minimal amount of points needed to follow the player (we'll use it to find the shortest path towards her). Pseudo code: 

Draw line from their position to all the neighbors' positions if the current 's is lower than that of the neighbor. Draw a circle in the 's position. Draw the number in the center of the circle and on top of it. 

You need to declare variables that will contain the played character's position. Decide if the game is 2d in nature or 3d. You need to do collisions an play a sound during a collision like any other game using tutorials to guide you. To compute the sounds intensity, define sound sources in the map and then compute the distance from them, the sound intensity could something like ~100% / distance. You could also consider walls as something that dampens sound. 

Connect the two rooms, add the new room to the , remove from the and repeat until all rooms are all successfully. 

What you may wish to do in this case is check the timer when you printing the text on the screen and decide on an of time that it will take to print each letter in the paragraph. Then each frame check the and print this portion of the text: 

A slightly superior move: player X can win in two moves in three ways (one column, one row and one diagonal) and also blocked one victory path for player) (the column). 

From the comments I'm guessing you are currently using plain text as your saving method. If you want a quick fix to make things less accessible to the average user, instead of saving your text as it is, edit each character to be of what it currently is and then when reading the file switch it back. You could also do this: for writing and char = (char + 156)%256 for reading. If you want something more complex, please feel welcome to comment and I will suggest a stronger form of protection. For example if you wish to continue using text you can randomize an Injective function that receives a character and returns another character. An injective function has an Inverse function, which you can then use to read the text. To create an injective function randomly, simply shuffle an array of integers from 0 to 255 and use the value in the index i to represent 'i' in your files. To create the inverse function, create another array and run over the array like this: 

Updating game state frequently. Stored all data on a server DB. Run game as HTTP POST/GET requests, not a concurrent game server. 

If you are doing a classic 2d platformer (which you [the OP] are not [this answer is directed at people who are doing it]) then you could use something like DragonBones (open source). Even in your situation, you could make some considerations and implement something like this. If you must have the tool look perfect from a lot of angles and can't compromise on the variety of angles and authenticity then you need to make the animation in 3d, attach the tool to the animated model and render away (this of course would result in the texture atlas you wanted to avoid). To get one image of a 2d tool looking good, you have to keep it bound to one plain. This means it cannot be moved very freely and will only look good when it's viewed from the side while most 2d rpg let your see the character from 4 - directions, this looks best when you can see the character only from the left or the right side of it. You can also make one tool of each type, i.e sword, staff, mace and etc. , then use different color color palettes to get multiple similar but slightly different results. 

Since you wish to have three types of buffs, you will need a priority system. Which types of buffs comes first? Do you completely change the stat and then add values or ignore other buffs? Since you wish to use OOP I would use an Interface for this. Every spell, weapon or piece of equipment that is imbued with power should implement the the interface. The interface will include a getter function that classifies the type of buff and when it comes into play(priority) and another getter that determines the potency of the buff for the calculation. Weapons or equipment that is not buffed should implement the interface and possibly return some generic value such as -1, 0 or null for these values. 

I need a method to divide 3d space into random axis aligned box shapes. For now I am currently dividing the 2d space for testing purposes. The most immediate approach I came up with was to define a rectangle of size (1, 1) and then recursively split all existing rectangles to two uneven rectangles alternating between axis X and Y.