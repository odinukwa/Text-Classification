You should just have one component for your laser. The source object would just have the laser component. The "redirect" object will have an additional component called . The laser component casts a ray, if that ray hits an object containing a component, the "redirect" object powers up its own laser. Think of the laser more as a trigger to power up the cubes. When the cubes are powered up, they emit their own laser in the direction defined by their rotation. This allows you to redirect the laser as many times as needed. 

When serializing data, it's best not to rely on special characters for data separation. Instead, simply let the receiver know how much they need to read to complete the data. Like: 

LWJGL is a library. Slick2D is a library. OpenGL is a library. All three are libraries. Slick2D uses LWJGL (and both are frequently used at the same time), both LWJGL and Slick2D use OpenGL. 

Blackboard systems started in AI programming. Their context in Entity systems is less of a problem solving role, and more of a "place to exchange information" role. The implementation of the blackboard system can very a lot. Even to the point that you wouldn't be able to tell the difference between that and a message que. It's just a known place to put information that all the entities have access to. I wouldn't worry too much about the exact definition. Many things game development are just loose guidelines, not rules. And actually the main thing you should be getting from that other thread is to focus on the simple solution. There's no need for a complex system, when a simple one will do just fine. 

A few ideas I had that were too long for just a comment: 1) Maybe have an opening scene before the user enters the first level that displays several birds attempting to sit on one branch and then the branch starts to break and the tree starts to fall so one larger bird flies from the branch to a different branch on the other side of the tree and this everything. Kind of a tutorial but with no text. 2) Definitely have some sort of branch bending animation like I alluded to in point 1. This would allow the user to realize that they're putting too many birds on one branch. 3) Bad sounds. Like creaking of the tree as you put too many birds on one side or the other. 4) To go with sounds, this would be very tough but you could have music that seamlessly gets more faster-paced/scary-sounding as the bird placement gets more precarious. 5) Maybe phone vibration that has increases in intensity as more bad stuff happens. 6) Having a score that increases when the player does something correctly and decreases when they do something wrong is a very common way of telling the user if they're playing correctly. Just an idea a friend of mine thought of: You could include levels where there is wind and the birds become necessary to prevent the tree from falling. Just an idea. Oh! And you could have an animal scare birds like a cat that climbs the tree that throws off the weight so the user needs to re-balance the weight without getting the birds eaten by the cat. Again, though, your game. 

So, I'm not really sure where to start with this question. Feel free to tell me I'm stupid and Off Topic but I'd also like you to tell me why. So, the maps in the game I am designing will consist of lots and lots and lots of voxels. Most of the voxels will just sit there and some of them will have methods run when they are touched or something happens around them. However, some blocks will constantly being doing something. Now, I'm not sure if I should have a array in every chunk (Group of voxels) that contains all the 'active' blocks or if there is another way. I know that some voxels will run code when they are loaded that makeup for all the time that they hadn't been doing anything but I may need to constantly run some voxels. (Machine that overheats or powers something can't just be loaded in 20 minutes after it blew up; or can it?) So, now that that basic background is over, here is my question: Will an array storing all active entities in an area suffice as a way to run all the frame by frame methods of the blocks? Or is there a "normal" way to do this that I am unaware of? EDIT: I just realized that the client that does rendering will not do a majority of the operations for the game engine. I will have a server that does it. The answer to this question is still largely relevant and helpful though. I just thought I'd mention my change. 

I'm assuming your code is a check to see if the player has fallen off the screen, below the view of the camera. In this case, you do not want to hard code in because you may later want the change the size of your camera viewport. Instead, change the entire inside of your statement to the following: 

This finds the distance from the current camera height to the fallen player, then moves the camera down far enough to where the player is falling from the top of the screen like doodle jump. This should work and yes I know the code is really ugly but I'm at work right now so I didn't want to post any solutions that may not work because I can't test. Comment on this if something doesn't work and I'll try to help. 

Now, I don't believe you can return a reference to the button as it is a function and not a structure, however, you can just have global variables like and that you use in the function (i.e. ) and then just change those global variables in another function when you want the button information to change. Also these global variables can just be public if you want to modify them from another script or you could just do some simple encapsulation (that means having and functions). 

The code below is working and taken from my game. I don't know if this is the most fashionable way to make the matrices, but it works for me and supports the older hardware the I'm targeting. 

Your new script will need to reference the gameobject that holds your health script, or directly reference your health script from your new script. For example, I would modify your existing health script (I'm going to write it in C#, but you can convert it to UnityScript if you prefer): 

There is another option. The player and the level are both members of the game object. However, I think the most common practice is to make the player an object inside the level. This has numerous benefits. For example, the level will process collisions between objects. Adding all the objects into the same level pool allows you to reuse the collision code with the player object too. It allows the player object to more easily interact with other objects in the level. The code you use for moving the player from one level to another could also be used for moving other game objects from one level to another. And so on and so on. I don't think "because it's a little more difficult" is a good enough reason to break the common object oriented structure. It's good to follow the standard structure even when you're the only one working on the code. Easy to understand and expected code structure is crucial if you were to ever have someone else work on your code. Keep in mind, that "someone else" could be you a few years from now when you're looking back at your code and wondering what the heck you were doing. 

So, I want it to be very easy to create all the entities of my game and for other people to come in and do the same. I was thinking I could just let the users/myself create an XML sheet the stores all the properties of each block (Like a Terraria or Minecraft voxel) and add Lua scripts that are referenced in the XML for additional functionality of any of the blocks. I'm starting to think It would just be easier to let the user create a JAR file full of classes for each block. And then that JAR file could easily be used to get all the blocks. It'd just be interesting to reference all the blocks by a block id without storing all the classes by ID. Or I could give each class a static id. But that's not important. Okay, so my short question is what are the pros and cons of storing all the the different types of blocks as classes versus in an XML sheet with Lua for additional functionality? UPDATE: I will probably go for the only use Lua approach. I found about it just recently and it appears like it could be the best method as of right now for me! 

Very quick to do. But you may have to tweak it more depending on the style you're after. Original image source. 

I implemented a chunking system for my game when I was fiddling with infinite worlds (not sure if I'll keep them or not). For use with a single file, at first I used the chunk's world position to calculate a byte offset into the file. This assumes a static chunk size, or at least a static maximum. However, if the user were to head off in one direction for a while, this file would become pretty sparse for it's size, since there were large areas of land that hadn't been generated yet so there was blank spaces in the file. I also tried a two file system. One file holds a map of "chunk position" to "chunk file offset" pairs. The second holds all the chunks. When a new chunk is generated, it simply goes on the end of the chunk file, and it's offset is stored in the position->offset file. This one was an issue when you had a LOT of chunks and finding the offset in the position->offset file took a bit of time. If you find it feasible, you can load the position->offset data into a hash-map on load, to have quick access. I'm using the second one option for now, but may switch to something else if I find that the performance is lacking. Maybe with this information you'll be able to create something that works for you. Good luck!