Actually Halo 2 used fewer polygons for characters than Halo* which makes it an instructive example. A lot of people assume more polygons equals better graphics because it's an easy number to directly point to, but it's not hard to think of an example where no, more polygons isn't better: Imagine a sphere comprised of a couple hundred polygons, and another sphere comprised of a couple thousand polygons. They're both just spheres. Now imagine the first sphere is rendered with a specular map for shiny highlights and a normal map for subtle texture on its surface, while the second sphere is rendered with basic Garoud shading. So now which sphere looks better, the one with more polygons? I'm not saying that polygon count doesn't matter at all, but rather it's just one of a whole complex set of factors that determines the look of your graphics. Textures matter a ton, lighting matters a ton, etc. The reason sequels on the same hardware look better is simply that the artists are getting more practiced at creating graphics for that hardware. *A couple years before Halo came out I had a conversation where I argued that we needed better lighting rather than more polygons, and everyone else piled on to crucify me for criticizing their polycount dogma. After Halo 2 came out I wished I had a time machine to go back and say "I told you so!" 

None of the other answers addressed a basic misconception in your question: the iOS SDK does not cost any money. You can download Apple's developer tools for free. However you will only be able to test in the simulator for free; in order to deploy onto device you need to purchase the $99/year developer registration. The fee is for the ability to publish, not for the SDK. Subtle but important distinction. So no, there is no way to make an iPhone game without paying a fee. Android does not have any fee to deploy to device, but the individual marketplaces have their own policies. 

What you want to do is program the chef to move toward its target destination; every frame in Update() check if the chef is at the target, and if not move a bit toward the target. Then clicking on a pot sets the target position. Something like this pseudo-code: 

The semantic quibble Gregory made in his comment gets at the root of the issue here. Flash is a very established gaming platform because of the combination of ActionScript 3 and a host of powerful multimedia capabilities. While JavaScript was always just as good of a language, only recently has it been coupled with the powerful multimedia capabilities of HTML5. As others are pointing out, you can compare ActionScript to JavaScript, and you can compare Flash to HTML 5, but comparing Flash to JavaScript is like saying "Which is better, Linux or C#?" 

You want to get real familiar with a handy-dandy 3D math operation called Dot Product. Pretty much all 3D graphics libraries include this 3D math function; for example $URL$ The dot product can be used for a number of things, but every use boils down to: when you take the dot product of two vectors, the resulting number tells you how close they are to pointing in the same direction. Exactly the same direction results in 1, perpendicular gives 0, and exactly opposite directions gives -1. For this specific problem, one vector is the direction the camera is facing, and one vector is the direction from camera to a block (subtract the position of the block from the position of the camera). Get the dot product of these two vectors, and if the result is close to 1 then the camera is pointed at that block. Do this in a loop for all the blocks. 

Don't directly translate the object in response to key presses. Instead, increase the speed in response to key presses, and then translate the object's position using that speed. That way the speed changes every frame. pseudocode: 

I don't know how this feature would be implemented in your specific development environment, but the solution to the problem you describe is masking. Basically, apply a mask to the progress bar in the shape of your letters and then the stretched rectangle won't be rendered outside the mask. 

First code, code the normal movement of the character to progress a constant distance toward the target position every frame (ie. inside the Update() function). Then put that movement code inside an if statement for if the character is being knocked back. Only move toward the target if not being knocked back. If being knocked back, move toward the knockback target instead. Set the knockback target and the "is being knocked back" variable when the player is hit, and clear them when the knockback target is reached. For the actual decelerating movement toward the knockback target, there are a number of ways to do something like that. One simple way is by decrementing the movement distance every frame; instead of moving a constant distance every frame, the "distance to move" variable gets smaller every frame. Another way would be using what are called tweens, setting an "ease out" value for the movement. Tweens are slightly more complicated to setup, but once setup will make it very easy to do short targeted movements like this all over your game. 

First off, I assume you are talking about skeletal animation (especially 3D graphics) since animation blending pretty much only applies to skeletal animation. If you are talking about 2D sprite-based animations (you didn't specify in your question) then you can pretty much forget about animation blending. With that out of the way... 

While 24fps is the framerate of movies and that gives the illusion of movement visually, there are a couple of caveats to consider. First off, movie frames have motion blur in them naturally and that makes fast movements look more continuous between frames. Games generally don't have motion blur to connect fast movement between frames, so they need higher framerates in order for fast movements to look continuous. Secondly, our sensitivity to responsiveness is greater than our sensitivity to visuals. In other words, in a fast paced twitchy game the controls will feel sluggish if there is too much of a lag between when you press a button and when the game responds. The difference between 30fps and 60fps in responsiveness isn't going to be noticed on a slower paced puzzle game, but will be noticed on something like a multiplayer first-person shooter. 

Most scripting languages are a lot more expressive than the language in the core engine. Often the engine is written in a relatively low-level language (eg. C++) for performance reasons, but the gameplay code doesn't need to be as performant and so the priorities shift toward being able to express functionality easily. For example, dynamic vs. static typing. Another example: garbage collection vs. manual memory management. 

To expand on ClassicThunder's presumably correct answer (I don't use XNA), what you are seeing is called backface culling. 3D graphics pipelines usually do this in order to reduce the number of polygons that they have to render; polygons facing away from the camera are usually on the far side of the object and thus not visible. You can turn off backface culling, or you could duplicate your polygons (with the duplicates located in exactly the same place but with normals facing the opposite direction). 

This is an issue whenever you render the pixels in an image, whether you're drawing freehand or are writing an algorithm to calculate the pixels for a 3D polygon. It's just a side-effect of the fact that the image is a square grid of pixels. "Anti-aliasing" is when you disguise the stair-step look by blending the colors together along the edge pixels. 

If you're unfamiliar with coroutines, that line "yield return null" in the middle tells Unity to pause this function for a frame before picking up where it left off. So this code gets stuck in a loop until the animation stops playing. 

I would suggest a synthesis of the previous two answers. Basically, I agree that it is enormously important to learn how to take an idea and ship a complete, polished game. The internet is littered with half-completed projects that someone started and then got bored of. The ability to stick with a project from beginning to end, what I call "finishing ability", is rare and precious, and gained by forcing yourself to practice it. However you are not at that stage in your learning yet; I would not recommend doing this with your very first game, but rather make a few smaller games to learn with before working up to your first complete project. (aside: I've never really pinpointed this before, but now that I'm thinking about it, I think finishing ability is the main thing I see separating experienced developers from novices) 

What you should probably do is get the dot product of the surface normal and a vector pointed straight up: if the trace crossed the floor then the dot product will be near 1, while if it was a wall then the dot product will be near 0, and if it was the ceiling then it'll be near -1 The threshold of how near is a value you can tune to see what works for your level: 

About the only game programming concept that I really think you need to know before you start is to understand the game loop, and that's basically the same concept as the main loop in any program: update the game state, render the game, flip the drawing buffer, repeat forever. I didn't sit down and read about any game programming concepts until after I had already programmed a couple simple games and then hit some snags that I needed help on. For example, I didn't start reading about AI techniques until I started developing more complex AI in later projects. I suggest taking patrick's comment and then hitting up google or coming back here to look up specific questions once you hit a problem you need help with. 

There are game development communities on $URL$ and $URL$ However nobody will react well to some random person just barging in with an idea, and it is crucial that you understand why. The first article on Sloperama addresses this issue: $URL$ Although his advice talks about selling the idea, getting others to make it for you amounts to the same thing. Basically, you are going to have to build it yourself because noone else will do it for you. That doesn't mean you have to do every bit personally (ie. do all the programming, create all the art, compose all the music, etc.) but it does mean you have to work hard on it. In order to get anyone else interested in your idea you have to be coming to the table with a lot. It helps a lot to have developed games in the past, so I might recommend setting your great idea aside temporarily and go develop a few small games (Tetris, Pacman, that sort of thing) on your own to develop rep. ADDITION: Your use of the term "baby" in describing your idea is a red flag. That may mean you are too in love with your idea and expect other people to just do what you tell them. I hope this isn't the case, because you have to realize that unless you are hiring/paying them (up-front cash, not a promise of future profits) then this venture is just as speculative for them as for you and they'll rightly expect to have a lot of creative control too. Basically you should look at it like "hey does anyone else want to work with me on a shooter?" and then the details are worked out in collaboration with them. 

Anyway, at a high-level the way you use the new animation system is by setting up a bunch of animation states in an Animator controller, assign parameters to transition between those animation states, and then when your code passes values to the animator it will transition between animations. Whereas in Legacy the animations are attached to the model directly and your code plays animations by name, in Mecanim the animations are used in an Animator and the Animator is attached to the model. This indirection is the first thing to understand; it can seem a bit odd since the animation clips can be part of the model (ie. part of the fbx file that was imported) but this indirection also allows you to share animations from other models. refer to $URL$ Create a new Animator controller, and then open the Animator window to edit it. First click the + button in the lower-left to setup parameters you'll use (eg. a float called Speed). You can drag animation clips into the Animator (click the right arrow on a model asset to see the animation clips) and then right-click the animations to set transitions between them (eg. from Idle animation to Run animation when Speed is greater than 1). Finally select the model in the sene and drag the Animator asset to the animator slot in the Inspector. At this point the code to trigger animations is pretty simple; Mecanim is designed to handle for you all the complex work of deciding which animation to play and transitioning between them. In your code you need a reference to the Animator component; there are a variety of ways to do that, one of the simplest being GetComponent (this is C# code):