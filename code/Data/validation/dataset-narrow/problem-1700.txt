I'm having some trouble trying to figure out how to use the GPIO status registers. These are used to set up monitoring of some event (e.g. GPIO input rising, falling, etc.) and then you read the status register to figure out whether the event has happened yet. The datasheet suggests I should write a value into to monitor those pins for a rising signal. I have written there because I want to monitor and . However if I read back the value of , the value I have set does stay there for a few moments, but then it is set back to zero, disabling the triggers. So when I inspect to find out whether a GPIO event has happened yet, it tells me that no, it hasn't - because it stopped monitoring that GPIO pin. Why does get set back to zero shortly after I have set it? Am I using it incorrectly? I'm running a barebones Arch install on the Pi with no extra programs running other than the usual basic system ones - certainly I can't see anything running that should interfere with the GPIO settings. 

A quick solution would be to use rsync, which makes a local directory look identical to a remote one. Unlike DropBox, you would just have to perform the sync operation manually when you wanted things up to date. Unlike a version control system like Mercurial, rsync won't keep history or backups, so it is very easy to accidentally delete files (or very hard, depending on your point of view - a sync might just download your deleted files again.) 

This script multicasts the video, and it can be viewed on another machine on the LAN with a command like this: 

causes the video to be played as fast as possible so it will run in real time, as opposed to running it at a fixed framerate and lagging if the Pi is capturing frames faster than this. There's still some lag with this method, but no worse than the other methods. (Tip: if you're plugged into a router or switch that supports IGMP, make sure is not firewalled on your machine, otherwise when the router asks your PC whether it wants any multicast traffic the PC will never respond and you'll never see any video.) Recording to disk As I mentioned recording in the comments below, I'll expand on that here. You can use a command like this to record the network stream to disk: 

This happens if you're unfortunate enough to sync at exactly the same moment the server itself is being updated. Usually if you wait a few minutes it will start working again when the server is again fully up to date, but it's possible your repeated attempts were causing some sort of caching of the incomplete file to take place. The fact that it started working the following day makes perfect sense - by then the server was up to date and any caches would have been flushed and updated too. 

Personally speaking I try very hard to only buy 12V or 5V devices, and then I create adapters to run them off a PC power supply. Then you can either connect them to your PC so they switch off when you switch your PC off, or you can buy a cheap PC power supply and leave it running 24/7 without connecting it to a computer. You would need a certain minimum number of devices to make this worthwhile - if you think a bunch of power adapters look bad, a bare PC power supply isn't much nicer. In my case all my equipment is in a standard 19-inch rack, so at least I can hide the supply somewhat. This isn't a quick solution though. You have to be willing to solder up custom power cables for each new device you use (since they all seem to use a slightly different power connector) and you need to build junction boxes or similar to split a single power rail into multiple power cables, one for each device. You'll also have to come up with some solutions for devices that require non-PC voltages, like 7.5V. Don't be fooled into thinking you can do the trick often done to run fans from 7V though, where you use +5V as GND and +12V as VCC. When you start connecting devices together with shielded cables the shields will connect all the GND lines together, and suddenly you're shorting +5V to the real GND via one of these cables. This will either short out the power supply (which will promptly switch off, no harm done) or more likely it will deliver a substantial current across the cable making it get very hot, and possibly melting the insulation. To do this correctly you can often get away with a voltage regulator, since most devices like this only require small currents. If you're only looking at a simple way to power your Pi and all its peripherals, maybe an old PC case would be the way to go. They're easily come by (often for free), there's plenty of space to mount the Pi, USB hub, and even internal hard drives, and if you've got an older LCD monitor that runs off 12V then you can even power that from the case as well. 

Look at for the meanings of the symbols in the filename. The ones in this example use the day number (0=Sunday, 1=Monday, etc.) followed by a and then the time. It starts a new file every 15 minutes. Just to be clear, this recording command is meant to be run on a remote PC (not on the Pi itself) although it will probably work on the Pi too (untested). Since you get a new file every 15 minutes with the day and time in the filename, it means that after one week you'll start to get filenames generated that have already been used, causing the oldest files to get overwritten. In other words, you'll end up with a rolling loop of the previous week's worth of footage. This is ideal for a security camera where you will rarely need to go back more than a week. As a side note this produces about 500GB worth of files, so you may want to adjust the bitrate, resolution, or overwrite the files sooner (say every 24 hours) if you don't want them taking up so much space. 

Assuming you're compiling on the Pi itself, you'll probably need to install some development packages, as precompiled binaries don't need header files present to run (so they're not installed by default.) I think in this case the name of the package you want is probably , which will put gpio.h into . Because the file sits in it means you don't need to specify this part of the path either in your code or to the compiler, so as you have there is enough, once you've installed the correct package. 

The problem is that the Pi's USB connection to the PC doesn't have the data pins connected - only the power pins. So you can't use this to speak USB because it's not wired up. Your only option with the Pi would be to 'bit bang' USB using the GPIO pins, but this is very slow and potentially unreliable. I suspect you would only really be able to emulate a keyboard or mouse - anything higher bandwidth would probably be too much for the CPU to cope with, given the tight timing requirements of bit banging something like USB. Another alternative would be to find a device that lets you connect two computers together via USB, to make a kind of network. But then you may as well just use the Ethernet connection... 

If you were to run your process in real-time, it's possible you would get the timing tight enough to work most of the time. Maybe to be more reliable you could use a buffer IC to receive data from the device, so the Pi can then query the buffer IC at a more irregular rate. I'm not familiar enough with the device, but perhaps it would be possible to connect it to the Pi's serial port instead, if the speeds are compatible? Then the timing and buffering is already taken care of for you, and all you have to do is decode the bits arriving in from the serial port when it suits you. 

Just to add to the already correct answers, there's enough leeway to enlarge the PCB holes to M3 size so that you can use standard PC floppy drive screws, of which any PC enthusiast is likely to have a surplus. These often fit into the brass motherboard stand-offs that come with PC cases (and are readily available online) so it makes for a cheap and easy way to securely mount the Pi. Just remember to use a drill to enlarge the holes, as forcing an M3 screw through the original sized hole makes cracking sounds and so you risk snapping the PCB that way. You also need to avoid the older screw design that has a washer molded into the screw head, as this makes the screw head diameter too large and it scrapes against surrounding components like the micro USB connector, while being screwed in. Newer screw designs (~mid 2000s) seem less likely to have this shape so aren't a problem. Here's a photo of a Pi mounted with floppy drive screws into motherboard stand-offs, which are themselves screwed into a plastic case (after drilling 2.5mm holes into the plastic to ensure a tight fit for the standoffs). 

As of 2017 (or perhaps earlier) is no longer the preferred method, with the Pi devs recommending people use V4L2 instead. So this method allows you to stream H264 via RTP using V4L2 instead of . I noticed this method results in fewer dropouts and allows a higher bitrate: