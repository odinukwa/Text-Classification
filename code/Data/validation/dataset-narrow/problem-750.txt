I have to read a from a buffer, read a from the camera's current settings, add them together, keep new value within the bounds 0 to 100 and write the new value to the camera's current settings. This seems quite easy to me, and yet here I have a rather large bit of code. The brace style is company-mandated. Is there a way to remove some of the complexity from this code? Ranges: : full range of . and : 0 to 100, 0 and 100 included. : To be between 0 and 100, 0 and 100 included. Header file: 

That said, perhaps assigning to a separate variable would help with keeping the line a bit shorter. On the other hand, those function names need work; sounds like a variable name. Actually, so do the other function calls here. Try prefixing with for anything you're pulling from memory and for anything you're going to be asking the user. (Or .) Then you'd get which clearly shows what the function's gonna do. (Recipes also do this; they'll tell you to cook or bake or braise or stir or fry or ... rather than just and voila.) So this is what I mean - it's pretty readable, you can see what's going on, but there's a few things here and there that could be better. 

Keep in mind that you need to also deal with the fact that could contain . You would get NullPointerException right now. Either explain via the documentation, or fail-fast and check the list of nodes for before running your entire algorithm. 

When dealing with ranges, I prefer to write an if statement as a range, rather than two separate conditions. Consider instead. This goes for all cases where you have ranges like this. Magic Numbers Your third method is filled with magic numbers! What do 622126, 622925, 6011, 644, 649 and so on even mean?! In this case, I think they're all connected in some sort of way. You should add a comment in the code stating where you got the numbers from. Simplifying the algorithm 

Is either a spin loop or does not check the fast enough. Or so I think. If there is no timeout for and it does block until input is required, then stopping the application whilst it is waiting for input will lead to the application only actually shutting down AFTER the input has arrived and been handled. In case of a system shutdown, or programmed shutdown, this input may never arrive. The JVM will handle power situations for you, forcibly killing your thread, but if you were to use this as a library and another thread was told to shutdown the application your application thread wouldn't be shut down. If there is no timeout for and it does not block until input is required, then you've got a spin loop. When running, the application will check thousands of times whether you've got input, and then pass the non-existing input (maybe as empty string, maybe null), through your commandhandler. This is a waste of system resources. By setting a timeout on the input reading, you can resolve this issue: By blocking for only 100ms (or so) for input, you can reduce the amount of checks to about 10 per second (which is easily handled by processors), whilst at the same time maintaining a fast response upon shutdown. Secondly, your code is not threadsafe. There are certain cases which will cause things you do not want to happen. If two threads call at the same time, then... 

This sort of statement, I'd wrap in a function. Bit manipulation tends to be very low level stuff and looks out of place in a function responsible for doing high level stuff. 

Here you make a new variable just so you can locally store to it... why not name your "key" "header" in the first place? 

This would skip one cycle from the loop and remove a branch. Testing this version gives no large difference, and I see durations in the 120-140 ms range as well. Basically, I think the current version you have is good enough. If you do want to go FASTER, though, here's what you'd do: Don't print any output. The resulting code runs within a millisecond. String concatenation and output buffers hate you big time. Using gets the calculations down to 80 ms, but then printing the result takes another 40 ms. The code you have will run about as fast as things will go. Readability What you can improve on is readability. For one, I'd add spaces around operators: 

But even when edited it looks weird. Your getters/setters are hindering you here, ideally you'd just do something like this: 

There's a lot of negations in here, so maybe we can flip the variable's meaning and get clearer code? 

It's not bad to have multiple returns. However, here you have needlessly complicated the look of the code by mixing various types of braces, putting in a double return... lemme rewrite it like so: 

The flaw in your algorithm is that you're summing for each item in each array. That means you get \$O(n^2)\$ for time complexity. Sum once, then add to the left side whilst removing from the right side. This will give a time complexity of \$O(2n)\$ (once to sum, another to move each element over from the left to the right side). Additionally, once you have found 1 case in which both sides match, you can stop looking for that testcase. 

The method signature mentions , and . The comments above the method describe , and . I think you'll be able to cut most of the comments away; but documenting what is for would help. Looking in greater detail at the comments you have... 

I made a mistake when I told you to use an abstract factory (ehehehe~). What I really meant was a factory. The difference is that a normal factory doesn't have an abstract superclass and that it just creates objects based on the provided parameters. Basically, and disappear. stays. Additionally... When looking at new critter types, I realize I'm hopelessly uneducated about marine life. You'll have to add the new class and the corresponding mapping to , though. I wish there was a way to fix this... (There are, but they're evil, IMHO. I envision stuff like making a map of ...) 

You might want to fix it so that they all use the same scanner, but you'll have to test carefully there, because users might be capable of entering things like "10 20" which is two separate ints (they'd answer 2 questions at the same time). 

In total you iterate over nodes needlessly 36 times. If I added another layer, making it a tree of 31 items, you'd needlessly iterate another 280 times. This adds up very, very fast. If you keep a reference to the last node added, you can just get the tail node, make a new node, set that to tail's next, then set the tail reference to the new node. And this is why you do not write your own . Data structures are complex and it is easy to screw up or forget something. Use the built-ins so you can benefit from the help that already exists (many people use the generics, so if you have an issue, people know the library that you are using and can help you), and because it will do a better job than you will do. Besides, why write your own when you have a problem to solve? 

Next, once again identify that there is duplication in handling of string appending - you handle in multiple places. Create a separate function. I gave it a bit of a poor name, since I haven't actually checked your business logic yet - I'm just optimizing this based on patterns! 

Additionally, could use a better name, I have no idea what it stands for. You use it both as a temporary variable and as something important. It's... related to the , but I'm not sure how. 

This slab of code has only 1 output variable, . You could move it to a separate function to try and keep understandable. 

Could go into a separate function . You could then write a test for in particular, increasing coverage and further reducing your CRAP score. 

Basically, what you don't do is check for duplicates. Now, there's two things this could mean: First option, you don't actually support duplicates. It's logically impossible for there to be duplicates. In that case, you should take an ordered, unique collection as input (a sorted set, as it were). A weaker alternative might be checking if you have duplicates and throwing errors for that, if altering the signature is not possible. Second option, you do support duplicates. In that case, you should alter your code to support duplicates. 

And at first I was like "Why would you do this?" It makes no sense! The amount of matches left doesn't belong to 1 player, does it? Do they have their own matches? Isn't this a game where the matches are shared between the players... Oh. You've made them shared between the players! Makes sense, I guess... Except you've just made them shared between ALL the players. Which is not so good if you ever wanted there to be multiple games happening at the same time. If you instead relocated the matches to the game (like I did a bit earlier with , then you can change the to take a object and obtain the matches that way (). 

Perfect for prototyping. I restrained myself from programming a version that did not re-display the pattern, since it's not stated in the requirements (But it would make a rather boring game if I did). I wrote this quickly. I wrote this without an IDE. My goal: Learning how to prototype better. I'm interested in finding ways to test game mechanics faster. That means I don't want to write much code and I'm not interested in polishing it up nice. I just want it to work so I can test whether it's any fun. If it is, I can rebuild a clean version. For the answers, this means I'm looking for how I could alter the way I write code from the start, rather than refining it pass by pass. The code: