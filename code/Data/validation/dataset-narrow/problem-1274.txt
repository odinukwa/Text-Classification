As you note, every vertex can only have one normal. That means that, depending on the lighting appearance you want, you may need to duplicate vertices. Specifically, if you want the edges of the cube to have a sharp boundary, then you will need to have separate vertices for each side. Make new vertices at the exact same position and use each duplicate for a different face. If however you want to keep the vertices shared between multiple faces and have the lighting smoothed out over the edge, then you should set the normal of the vertex to the average of the normals of its faces. 

The answer to your question really relies on precisely defining "outdated" and then comparing that definition against the features of the development tool. For example, does the tool support your (presumably modern) target platform? Does the tool support the quality of audio you need? etc. Although you should probably make such a list of requirements as part of evaluating the tool, another important aspect is playing examples made with this engine. Have you tried a bunch of games made with AGS? Do those games demonstrate what you have in mind? Trying out concrete examples will go a long way toward confirming that "yes, this is the right tool for my project." Just be wary of basing your judgement entirely on examples others have made rather than your own investigation of the tool. 

Whether or not your game is a good fit for JavaScript development depends on the game. You didn't describe your game, so there's no way for us to answer the question in the title. However I can say that your hacking concern is not a problem here. Not because JavaScript can't be hacked (it can, and easily) but so can every other client-side technology. One of the basic tenets of multiplayer game development is "never trust the client". Design your game in such a way that anything you need to protect from hacking is running on the server, because the client will be hacked. This means only send UI commands from the client (eg. "the player clicked the Bomb button") and calculate the results of player actions on the server. Then the server sends back to the client the results of those actions. Since no matter what technology you relied on you should design your game with the assumption that the client-side component will be hacked, the hackability of JavaScript isn't a consideration when deciding whether or not to use JavaScript. 

I generally don't think in terms of a memory snapshot, but rather I just make a list of which values need to be saved between sessions and save those values into an external file. This depends of course on the needs of your specific game, but usually I simply save the state of the current level (ie. where all the enemies are, what their health is, etc.) and then higher level stuff like what levels the player has already completed. 

It looks like the Wings3D object doesn't have texture coordinates. There is a texture applied, it's just not applied correctly. Without texture coordinates, it'll just stretch a single pixel of the texture over the entire object. 

You're going to need some sort of external server for the players to connect to over the internet. SharedObject means "shared between instances on this computer", but players on other computers have no access to this information. You could do this with your own highscore server, but there are also third-parties that take care of this. I'm no longer familiar with what all is available; I know Mochi used to have a highscore server you could use but I don't know if that is still the case. You could also use the highscore API provided by Kongregate if you publish your game there. 

That sounds like a pretty fundamental change to me, not a simple rule change. I think fundamental design choices like that should be made before you even get to writing any networking code, either with offline prototypes or even paper prototypes. That is, prototype the gameplay without doing any networking. That would mean writing a game that is multiplayer locally (ie. both players are on the same computer) in order to test gameplay ideas. I mean, at my job we once took a game that was already halfway developed turn-based and converted it to real-time, and yeah that involved a massive rewrite of the networking code. In retrospect, that was a really inefficient way to approach things, and we pretty much decided "never again." 

On the one hand, your distinction between internal and external transitions looks like kind of a false dichotomy to me. In both cases what you have is tiles depicting a transition from two types of terrain, say sand and water. The only difference is how much sand is depicted vs. how much water. That isn't any sort of technical distinction, just a difference in how the artists choose to draw the tiles. That said, the main technical difference I would expect from different tiling choices would be in collision detection. For example, if the character moves through water but not sand, then is this transition tile considered water or sand? However this is similar to the case you pointed out in your question, a technical situation that could easily be addressed by altering the bounding box of the tiles. 

The best 3D engine I know that uses Lua is Leadwerks. That said, I would also tend to recommend Unity for 3D games. You won't be programming in Lua, but it'll be a similar gain in productivity. 

That disintegration effect is clearly some complex shader work, and the hologram shader on 3D models from your first link may be tricky too, but everything else is easily done with a cubemap and/or additive blending. For the computer monitors, that's just a standard texture in a material with additive blending. For the freeze effect, that can be done with a cubemap, and for that second hologram model you could do a cubemap AND additive blending. 

You can use Flash Professional to create graphics and do your animating, building the content as .swfs, and then import those into Flash Builder where you do all the programming. Flash Builder doesn't do anything with .fla files directly. 

Simply choose the facing for the character that is closest to the angle of the shot. 8 sets of sprites would be nice for that, but I imagine just the 4 cardinal directions would look fine too. Character faces North for any shots between NW to NE, character faces East for any shots between NE to SE, etc. 

Yes this is a real consideration (or rather something similar along these lines) but no I'm not aware of any specific resources that provide guidelines. 

I would use the term "story engine" for what you're describing. It's a code module to handle the story, just like a physics engine is a code module to handle the physics. You'll also see terms like "tile engine" for a code module that handles graphics tiles; basically, a code module that handles a single aspect of a complete game will often be referred to as a engine. It's used more or less in the same way as "library" (as in "audio library.") Both your possible definitions for the term "game engine" apply. For example, Unity is a 3D game engine.