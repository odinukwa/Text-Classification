Be 'topRight'? It makes it easier to understand what you're doing... You're also being inconsistent with your use of member field naming. Triangle has 'm_vertexA' etc, but also has 'edgeA'. Pick a naming style and be consistent. If you're going to prefix with an 'm_' always prefix it. 

So, you only assign to it the first time you add an item?!? This also seems to result in a bug, where if you before you've , you will do: 

Static I don't particularly like statics, it's very easy for them to be misused. Static members are shared across all instances of an object. In it's current form this isn't going to be a huge issue for your class, however it does restrict it's reuse. Since changes to will impact all instances you can only really have a single running at a time. I'd make them into instance variables and amend the functions that reference them as necessary. User Interaction Consider pushing the user input/output away from your class. This isolates your logic from your user interaction. It'll make it much easier for you to replace the front end (for example with swing or a web interface) if you decide that you want to go in that direction. Something like (class/interface names aren't great but they convey what I'm trying to suggest): 

I've developed a spreadsheet that has evolved over several years to help keep track of the number of student contact hours that have been used to help flag up when students have run out / are running out of allocated hours (so that additional hour requests can be made if necessary). There is a master workbook, which contains the VBA (below) and several worksheets. There is a "Master" worksheet, which is used for the consolidated view. This has columns for the students name, allocated hours, total hours used and then several columns with one for each month. 

Without any context, this looks confusing. There are two things to consider here. Use a naming convention to avoid conflicts There are various naming conventions that can be used to give variables names. They each have their own followers, benefits and drawbacks. If you use different conventions such as 'snake_case' for member variables and 'camelCase' for method names then it can help to avoid conflicts between them. Alternately, some places will prefix member variables with a known value e.g. 'm_rowCount', or be explicit about get methods 'get_rowCount'. Find a convention that works for you and adopt it. If you can't work around a conflict, then: Prioritise the public interface Your classes public interface is the one that is used by external clients. In many ways it is more important than the private implementation. If you decide that you want to rename a private field, you only have to fix any references to the field in that class. If you decide to rename a public method on the class, you may have to refactor many dependent pieces of code to take account of the rename. If you have to make a decision about which name to get right, make it the public one. 

Extend your regular expressions to encompass is_within_range My regular expression knowledge has some holes in it, but my reading of yours is that you're ignoring any leading zeros, then matching any number of digits for the relevant numeric fields. You could amend this, so that it actually checked to ensure that after any leading zeros, there were up to 6 digits. I think you need to look at replacing the with , but I would have to check it to be sure. This would effectively bound the numeric inputs to within the range expected by your function. You could do a similar thing to bound the range of alpha column option. If you do both of these, then the method becomes redundant. Don't initialize variables to unused values This may be subjective, however you do this in a couple of places: 

magic numbers You use some defines at the top for magic numbers, however you also use 5 in several places like this: 

Depending on the overhead of The AllocHGlobal / FreeHGlobal and if you're going to be marshalling the same structures over and over again you might be better off going with something like: 

If you're going to be capturing groups of objects then you're going to need to be very careful about the order that you capture those objects in order to prevent deadlocks where one method performs: 

White Space As was mentioned in the comments by @Aluan Haddad, your initial code was missing white space between things like operators and operands. As it stands, your code is still missing standard white space, such as a blank line between methods, a blank line between the end of your section and the start of the code. It makes your code feel a bit cramped. Const If you're not going to be modifying the contents of variables passed into functions you should be declaring the parameters as . This helps the client to know that it is safe for example to pass a string literal into your function. Users are unreliable Even well users with good intentions make mistakes. You're not capturing all of those mistakes with your current code. What happens if the user puts two spaces between parts of their name? Cleanup In , you up a buffer which you never clean up. It may be that you've intentionally done this because you know that it will be cleaned up anyway when the program exits. Alternately it may be that you've forgotten to do it. Generally I'd suggest always cleaning up after your 's because that way whoever is reading the code knows you've thought about it. Naming Some of your names are good and appropriate (, ), others are less descriptive (, ). Good naming makes your code a lot easier to follow. Live up to your promises says that it returns a . It doesn't. Be consistent prompts the user, outputs what they tell the program, then returns the value. on the other hand parses a string, outputs the initials and then doesn't return anything. The prefix really suggests that the methods should be doing a similar level of task. Separate out user interactions could be written in such a way that it took in a name and returned a string containing the initials, then it could be called from future programs that had different user interfaces. At the moment, it has a in it which makes this more challenging. Try to isolate your user interactions (inputs/outputs) from your main logic (string processing in this case). Allocate how much? allocates sufficient memory to store every character from the persons name. Is this really required? Since you've declared a buffer for the persons name as , should this really be a constant that can be reused so that doesn't need to malloc, it can just have a local buffer? Multiple declarations on a single line I don't really like them. I find that they make it hard to locate variables so I would avoid this: 

One more thing Processing concurrent client messages also introduces a question of whether or not synchronisation is important. It's possible that the third message received might be processed faster than the second message, resulting in it being sent back to the client before the second. If ordering of the messages is important then either the server would need to manage this, or a message structure would need to be passed (for example that contained a message id) rather than just the text. 

Serial2 Vs MyBtooth It looks like you started off using , then defined to make it more explicit when you were talking to blue tooth vs serial. There are some lingering references to in the code that should be updated so that it is consistent throughout. 

This is because your is using the return value of to indicate two things. It either indicates that has failed, or it indicates as in my case that the call to failed. min3 When I first saw your method, my initial impression was that it seemed quite verbose. You've already defined a macro in 'telephone_book_utils.c', why not define a MIN macro: 

It's generally considered bad form. One declaration per line means the declarations are less likely to get lost. 

I'm adding this as a separate answer, because I feel a bit like I'm missing something, which you may well be managing in another class that you haven't posted (and this is too big for a comment). Looking at the problem you've said you want to avoid this situation: 

map map is a collection in the STL, so I would tend to avoid using it as a variable name. I'd also consider using a two dimensional array to represent the play area, rather than a 1 dimensional array. That way instead of doing the hard work yourself: 

Naming Whenever you have a simple method that starts with , it's an indication that should should consider making it a property (in this case a read only one). Unnecessary variable The variable is unnecessary, you might was well return simply the result of the . Alternate for higher .Net versions Depending on your .Net version, you might also want to use string interpolation instead. If you combine these three things then your becomes: 

Define an API The first thing you should do is define a function to wrap the implementation. This gives it a name and a defined interface. You can then set expectations such as the first number is the largest, the caller needs to pre-allocate a buffer for the result, etc. Naming It would be easier to follow your code if and had more meaningful names. could be or etc. Unused variables You define variables and , but don't use them. If you don't need them, get rid of them, they simply add unnecessary noise. carry? Do you really need your carry flag? You could simply combine the code that sets it with the code that checks it: 

Could be abstracted into an method which would make the code easier to follow. Recursion This is odd: 

On the whole, I like your approach and found it very easy to follow. There are a few things to consider though. TestHarness I don't like having methods in classes as test harnesses. I would prefer to either see JUnit tests, or for some kind of MergeSortTestHarness to contain the method that exercises your class. This creates a separation between the code that does the work and the code that exercises it. It also forces you to use the public interface to the class. At the moment, you've got which presents generic methods and contains a generic class, but has a private method that's called by main that creates a random list of integers. This method clearly doesn't belong. Variable Naming When I first saw this code in , I thought it was going to be a bug: 

Error Handling You don't have any error handling in your application. What do you want it to do if it fails to copy one of the files (for example because of a sharing violation, network error, permissions error)? Should it continue, ignoring the file, ask the user, abort? At the moment, the program will just crash. 

If you're running tests from within Visual Studio, then Categories are interpreted as 'Traits', so again you can easily exclude them from the tests that you're running, or just run the specific category/trait. NUnit itself and the console runner support multiple category attributes (so you can mark all tests 'IntegrationTests' and mark db tests 'DBIntegrationTests' then run subsets), however not all test runners recognise multiple categories (the default VS runner seems to just pick the first one). 

Since you're rethrowing and is a local variable, it's going to be lost. I'm guessing you probably shouldn't be rethrowing and should be falling through to return result. 

I haven't used any parentheses... Overflow checking You don't limit the size of the input stream, so it's possible to overflow the input: 

Locking? The locking you're implementing is cooperative locking. All parties within the system need to comply with the locking process in order for it to work. With networked file systems this is often not going to be the case, you may be competing against various other applications accessing the files (explorer, cron jobs, shells etc), although you could manage this at an operational level. With that in mind, whilst your locking code can be used to drive your menus to help prevent the user getting into trouble, I'd suggest that the code that actually performs operations needs to be aware that it might not really have exclusive access and be ready to handle errors appropriately. Paths It feels like you're assuming all clients access a given folder/file using the same path. Again, you may be handling this at an operational level however it's worth asking if your system will work if two users map the same network folder to different drives, or if there are nested network shares and two different users access the folder from different share levels. i.e. These shares exist: 

With returning an . It also begs the question, should also be taking in a parameter for the value field of the ? Names are important Good naming reduces the likelihood of confusion and hence bugs. Your naming isn't great. What does do? Check for a particular value, any value, same value as the cell tested, it's not clear from the name and again, as you've omitted the code there's no way to know what it's supposed to do. The bigger problem is that with option 2, you're poor naming has introduced what looks like a bug. You construct your cells using , which is easy enough to follow: 

Or you may want to define your list in terms of a template and take in a pointer of the relevant type. This could be a if ownership of the data doesn't pass solely to your list, or it could be a if the node that references it will be the owner of the Data. Append Looking at your current implementation, what happens if a is passed in that already has its and pointers populated (with the given interface I could assume that I could insert a Node chain). These pointers aren't checked, they're overwritten. This is part of why I don't like the interface... Remove What happens if you're asked to remove a node that isn't in the list? Currently nothing. It feels like this method should either be returning an indicator that the object has been removed, or more likely throwing an exception to indicate that it hasn't.. 

Leaky abstraction Your contains a public method which returns a raw handle to the socket. With it, a client can call any methods it wants against the socket (send/close/recv) without having to use your abstraction layer that you've built. This method shouldn't exist, it undermines all of the other protections you've put in place. This can obviously cause issues, since for example your call in needs access to the raw handle, however the number of classes that need access to the raw handle should be limited and IMO explicitly managed through the use of s. Naming is a bit too close to datagram socket, which isn't what it's modelling, it's constructor explicitly sets it up as a stream socket. I prefer to model it as such by either calling it or . Connect is an action, so is something I would expect to be used in a method name, not in a class name. Connectable would be better (although personally I would merge the functionality between and together because they both only really work on streamed sockets. ConnectSocket - DeadEnd provides a default constructor which doesn't do anything (). Why? Protected members stores information as protected members (port and addr). doesn't appear to ever be used and port is only ever used in the constructor, why isn't it just a local variable? There's a similar situation with , is never set, there is a constant that is protected (does it need to be, rather than private? does it even need to be a class level constant rather than a method level?) remove_socket It looks to me like remove_socket iterates through all of the sockets, even after it has found the one it's looking for. Are you expecting the socket to be in the list more than once, or should it return after removing the first one?