Why is that function part of ? You don't do anything related to the class at all; this function should be freestanding. The parameter should not be passed by value, but by instead. is expensive to copy, and the function does nothing at all that would justify this extra cost. 

This means that you have to synchronize the accesses to the contents of your queue, either by wrapping them in , or by handing out a mutex together with your queue. The approach is likely more robust, as you can't forget to take the lock before accessing, but requires your to be trivially copyable, which can impose quite strict limitations. 

There are different algorithms for finding the most significant bit, but usually an iterative approach works well enough. The general idea is to iterate the number bitwise from the most significant to the least significant bit, checking whether the current bit is set. If it is, return the current bit position. In code, this might look like this: 

Here are some general coding style tips and improvements you could (and should!) make. I did not actually review the inner workings of your code since I am neither familiar with Eigen nor with the algorithm you are trying to implement. 

Please don't . It's use is uncommon nowadays, and you are unlikely to encounter it in code that is supposed to compile on any compiler that is not MSVC. Only choose to include it if you can show that it has a significant benefit. Don't . Do instead. is a C header, is its C++ equivalent. Speaking of includes, you are missing which is required for . Don't use and . Starting from C++11, C++ has rich random number generation facilities in the standard library, which allow for much more fine-grained control of the underlying RNGs and distributions. If you use C legacy functions (such as ), only use the functions supplied in the namespace (i.e. instead of ). The existence of these functions in the global namespace is not mandated by the standard. Pass parameters by reference or const reference where appropriate. For example, should likely be taking both its arguments by const reference since they are not modified and probably above the size threshold for efficiently passable objects (although I don't know anything about the big integer library you are using). Don't do timekeeping with . Use the facilities provided in the header. They are much nicer to work with, enable fine-grained control and are less prone to unit conversion errors etc. (same as with /). Your -function is doing way too much work. Split it up into multiple different functions with clearly defined responsibilities. Don't start your functions off by declaring every variable you are going to use at some point throughout it. This kind of forward declaration is an old pre-standardized C legacy; neither reasonably modern C nor any version of C++ require it in any way. In fact, it hinders readability to an extent, because the reader has to keep juggling all those variable names mentally, most of which will not be used until much further down in the function. Don't use , use for reading things from the commandline instead. Also, don't use , use the format capabilities of . Again, both and are legacy C functions and are somewhat restricted in their use. Don't use C-style casts (i.e. casts of the form ). Instead, use on of , and where appropriate. The following line (taken from ) is almost surely undefined behavior: 

looks much nicer. Includes You are missing an include for . Preferably, that would be , although there are at least five other headers guaranteed to define it. Similarly, you are missing for , and the whole package, and for . Finally, you are also missing for , for and , and for everything -related. Please be more careful around your includes! Another thing that bothers me a little is that your include are not sorted alphabetically. While this is not a problem per se for such a small project as yours, it can grow to be a quite a nuisance in larger projects with dozens or more of includes. Ordering your includes from a to z makes getting an overview over them much easier and helps verify whether all includes are actually there. Typos and Spelling Inconsistencies Finally, the most pedantic and least useful code review point of all! contains a member variable spelled . However, in the constructor, you have the comment 

There are a lot of different opinions on when to leave space, but most developers agree that more whitespace is better than less. Use telling variable names. What are 

Whether exists in the global namespace is entirely left to the implementation. As such, your program might not compile with a conforming standard library (although, to the best of my knowledge, all big standard library providers provide those functions). To circumvent this, utilize the versions of every C type and function you use. It would be nice of you to order your includes alphabetically to facilitate include checking. Some of your comments don't add much to the code, omit those. For example, is something that is perfectly clear from the corresponding code line. Also, it is a lot more common to see comments before the line they refer as opposed to after, so you may want to change your comment style. is not the C++ way to define constants. Use , and with file-scope variables where appropriate. This allows you to have typed constants as well. There is no need to write out in lines like ; suffices (structs in C++ are not like structs in C). Don't use . It causes unnecessary performance degradation through flushing where a simple would suffice. You don't need to write out in type names such as or ; and are enough. While there is inherently nothing wrong with adding the part, most people just omit it. Ultimately, it's your choice. Since never terminates, you have some dead code at the end of , which you should remove. Of course, it would be better if actually terminated. The command line command you supplied to compile your program does not include warning flags. Compiler warning flags are oftentimes very useful in catching stupid bugs early, and not providing warning flags on Code Review always makes me suspicious that you either don't know about them, don't use them, or are trying to hide the fact that your code produces warnings, neither of which are particularly good (clang does accept your code without any utterances, however, so I assume that you did actually compile at least once with warnings enabled). Also, is not strictly necessary to compile your program, so I'd have omitted it here. Boolean checks such as can simply be reduced to . There is no need to compare with and since the value you get is already a . 

Do not include files. This is not only horrible practice, but will also lead to ODR-violations, which means that your program will have undefined behavior (assuming that it passes compilation and linking, which it currently does not). Make sure that your program compiles when all your files are passed as source file to the compiler, not just . 

Most of the above points are relatively minor. The ones I would deem most important are, in order, point 7 (of course), point 8 and point 2. In general, your code is already pretty good, so the most important thing for you should probably be adapting more good practices. In particular, I recommend you to take a look at the C++ Core Guidelines which is (to my mind, at least) the most comprehensive C++ style and coding guide currently available. 

Edit: I removed the section on returning as it was utter nonsense (Thanks to Sebastian Redl for pointing this out in the comments). 

Don't make assumptions about the signedness of your type, which seems to represent the size type of the array. Oftentimes, will be unsigned (e.g. because it is ), which means returning on not finding a value might be unexpected behaviour for your users. Check that is greater than zero. If it is not, your program invokes undefined behaviour. Take by const reference since you don't know which type it will be, whether it will be trivially copyable and so on and so forth. The same is true for , and ; you should either make them pointers to elements in the array or make them store the index to their respective elements instead. Be careful with overflow. In particular, may overflow the passed size type and you may end up getting nowhere. Instead, divide them separately and add the results together. 

Thus, your implementation is currently not a valid iterator in the STL sense (which was also already noticed by nwp in the comments). Your interface is a little confusing The class that you wrote, , does not only serve as an iterator, but also as a kind of iterator factory. Code such as 

I hate to break it to you, but is not really a , at least not in the sense that you define it right now. The problem is this: If you have a base class, and you choose to derive from it, you should have a (meaningful) implementation for everything the base class requires you to implement. It takes no expert to see that this currently is not the case at all. But where is the actual problem? One issue is the interface of , in particular what methods it requires: 

Since "formatter" with two 't's is the correct spelling of the word, you might want to change you variable name. Another comment of yours reads 

It is important to note that the least significant byte has the index 1, not 0, because we reserve 0 for the occasion that no bit is actually set. Alternatively, if you use either gcc or clang, there is the builtin which returns the number of leading zeroes, greatly simplifying the computation: 

which is not only shorter, but also more efficient to compute. Why do you define almost all your variables at the top of your function, although they are not used until much later? This is a bad practice, because it increases the mental load everyone reading your code has to deal with. I don't want to remember the types of eight or nine different variables while focusing on code that doesn't even use them. Just define them right were they need to be defined. Overall, you use too much. Only use when you are working with characters or single bytes, otherwise use , and everything larger or equal in bit size. You are not gaining anything through your use of except a high chance to trigger ub several times over in your code (You are likely not even saving space because of alignment concerns on most common modern platforms.) Don't a single character; that's wasteful. Use for that. Don't include . Unless you have a concrete compilation performance concern, it won't do anything for you. And even then, it is not standard, and most people who use compiler other than MSVC will likely complain about it. Split your code up into functions. is not the right place to write problem-solving code, only to put things together. Do yourself a favor and organize your code a little more, it will help you keep a good overview over which part does what and make other readers not turn away on sight of that huge god-function. 

Still, one of the most important rules in performance optimizations is: Measure everything you care about. As long as you do not measure, what you are saying is basically that you do not care about performance. Optimization only works if you can identify the culprits and bottlenecks that make your code slow. 

Header file the current source file implements (i.e. for a file called ) if any Headers from the same project you're working on Headers from different projects/libraries (in your case, , for example) Headers from the standard library 

or similar to avoid indexing and bounds checking errors (for example, you could run into problems with your version here because might not be big enough to hold all index values for ). Don't rely on implicit conversion when assigning values to types. The correct initializer for a single-precision floating point number has the form , for example (meaning that you should write instead of ). Implicit conversion can sometimes really ruin your day because it can lead to unexpected results which are hard to diagnose. Don't use , use instead. will also flush the underlying stream buffer, which you usually don't need to do and which can harm performance if you are doing a lot of I/O (also, if you really need and want to flush, there's ). 

is discouraged in modern C++, as is reliance on the C preprocessor in general. Just define your constants with and (depending on the situation) . Don't define raw arrays. Use for fixed size arrays, for dynamic arrays, or any other standard container class. Don't use arrays if you mean strings. C++ offers for general string handling and for string building. Use standard algorithms. For example, your first for-loop could be replaced with a call to . 

Where are your includes? I only see . However, there should be a lot more: for , for , for , for , etc. Add them, or a conforming compiler may refuse to accept your code. Why do you even include here? You don't use anything from it! You don't forward declare , thus it shouldn't be visible further up in . A conforming compiler actually has to reject your program because of this. Maybe you wondered about me mentioning instead of without the prefix in point 1? C++ only guarantees that the legacy C types exist in the namespace (provided that the right headers are included) whereas their existence in the global namespace is not mandatory. You should thus prefer the versions of those functions at all times. What is the point of using over normal / here? Normally, standard containers support allocators through template parameters in order to facilitate the use of different allocation managers and schemes. However, your code doesn't take an allocator template parameter, so there is nothing useful you can do with allocators here. Building on point 5: If you remove that useless , you can actually simplify a lot of your code to use ///etc. to move and copy data around. Let's take a look at . There is an issue here that you don't seem to have thought through thoroughly: is of type , which is not only unsigned but also larger than on many common platforms (most importantly, x86-64). That means that I can easily exploit your code to have undefined behavior if I make a string bigger than characters, in which case your code will have undefined behavior due to signed integer overflow. It is good practice in general to ensure that loop iteration variables are always the same size (or larger) than the loop bound type. Utilize the copy-and-swap idiom for move assignment operators. Instead of calling manually and then tediously reassigning values from one object to another, just the contents of each member variable with its equivalent on the move-from side and have the destructor of the move-from side handle the cleanup eventually. If you are striving for correctness, the move constructor should be , as well as both s, and and , too. seems dubious. If you are following the specification, that code should probably be , since the default value for type is (as for all other integral types).