This is ok as a start, however it's possible that the player could end up with 5 aces etc. Is that really what you want? With a pack of cards, there are many cards that have a value of ten (10,Jack,Queen,King) yet your current random approach thinks all card values are as likely. In reality, the chances of you getting each card decrease as cards of that value are removed from the deck. Consider adding a deck class that you initialise with 1 or more packs of shuffled cards when constructed then remove from the deck as each card is drawn. This would make your draws more realistic and allow you to reuse the deck class in any future card games you may construct (such as poker). Duplicated Code - Player Vs Dealer Dealers and players are almost the same. You're performing the same calculations in that you are performing in . This could be generalised if you were for example to add the concept of a Player (dealers are players to, they're just automated) to your class. You could do something as simple as this: 

This is hard coding knowledge about the external environment into the class. This means that if in the future you decide to move/rename the method you'll have to update the class as well. I'd consider passing the information instead into the Snake's constructor. You could pass the initial snake coordinates directly, or my preference would be to pass the function into the constructor. 

You load with the number of times you want to run the loop, then the instruction basically, decrements and jumps if the result isn't zero. Testing bits Your approach to testing bits works, but it's rather long winded having to push them onto the stack and pop them off into a register. Instead, you can use the instruction, which s two operands together without destroying them and sets the flags accordingly. So, you can perform this combination as the main body of your loop: 

The connected flag isn't set in the thread, it is set in the worker thread, after it has been started. This means that it's possible to call twice in succession without this guard triggering or an error being raised: 

Note: This won't work currently with your code, because of the way you have implemented . Consider Your API At the moment, the users of your LinkedList know everything about the structure, all of its members and the data structures that it relies on. You've indicated that you've done Java programming before. This approach is the equivalent of declaring all of your classes members as public. This might be what you want to do, but I would tend to avoid it unless there's a good reason for it. A better version of your header files definitions might look like this: 

Moving the Mouse The first thing you do is . The question that immediately springs to mind is do you need to move the mouse? Unless the program your are interacting with actually tracks mouse movements in an attempt to detect bots, you probably don't need to move it. Most of the times in the programs I have written I have been able to just send mouse click events at the relevant coordinates. The library you're using supports a method that will simply set the coordinates of the mouse. However, as ClickMouse calls this under the hood, this might not work for you. I'd try running the script with just two clicks and a longer wait between them to detect if the program really requires the movements or if it's only concerned by the clicks. 

It looks like it's updating the head of the list as it iterates through to print. It's not of course, it's using a local variable that's actually iterating along the list. The name is a bit misleading, or or something suggesting that it's expected to move along the list might be better. left = !left At the end of your split loop you can do: 

@venerik had already covered the majority of the code, however I think it's worth mentioning that checking: 

I've only really started looking at MVVM and WPF in the last couple of days, so I'm at the beginning of the learning curve. That said, your 's looks wrong to me. My understanding is that the MVVM dependencies should essentially be: 

kbhit and direction changes You're using your function to detect when a key has been pressed, however you're not actually checking that the key hit was one that is valid for your snake movement. Consequently, if another key on the keyboard is pressed you set direction to an unknown value which results in game over. You should be validating that the input is an expected value before setting it to direction. snake_pos This looks very counter-intuitive. Why would X need to be more than horizontal? Why would Y need to be more than vertical? Maybe you're looking for a two dimensional array ? 

If the target value isn't found in before you get to the end of it, then you fall out of the loop at which point the code will return an unspecified value to the caller (you have a similar issue in ). 

Buffer Safety You're using a fixed buffer size for your names(15 bytes), however you're using to read the input directly into the fields. If the user enters more characters than the buffer can handle it will result in a buffer overrun, trashing whatever happens to be in the memory afterwards. Header Files / modules Rather than having a header file for each operation, I would tend to have a header for the section of functionality. Possibly 'accounts.h' would be appropriate. This header would define all of the relevant interfaces (add,modify,delete) for your structure. Personally, I'd also put the implementation for these methods in the same '.c' file, rather than distributing them across different files. They're performing actions on the same data structure, so it feels like they belong together. As it stands, it is weird that add is in main.c and the rest of the functions are in different files. switch/break/return You've got a switch statement: 

There are a couple of concerns with this process: As there are no checks at this lower level for the nested directory lock then if for any reason the higher level decision making gets out of sync it may attempt to gain a lock that it shouldn't. LockEntries are compared based on 'path,user,time': 

'remove' naming From the class header it is not obvious that this is going to be a never exit thread worker method. I would be concerned that a future client might try to call it to remove one item from a queue. Consider renaming it and making it private. Worker thread Your worker thread has no termination condition. You should provide a mechanism to signal it that processing is complete and it is time to terminate. If there are no items in any of the queues (such as when the thread is initially created) then the thread function will spin, draining resources that could be used on other things such as inserting items into a queue. One approach to improve this would be to count items managed and wait while it is zero, or use a single flag that is set when items are inserted and have the thread wait on it if it fails to read from any of the queues. initWorkedThread If this is called twice you will start multiple worked threads. Is this expected/desired behaviour? I would assume not, in which case you should add protection to stop a second thread being started. One approach might be to make the private and have it called automatically from the constructor. With the current approach if two threads are started, there is a race condition between checking the queues size and removing an item. 

Synchronisation I think overall, the way you've synchronised between the consumer and producers is fairly tidy, although your variable names could be improved to describe what their function is. is clearly a , but what's it being used for, how is it different from ? For the scenario you've built, having the consumer wait until all of the producers have completed seems to work ok, however in the general case, where producers might take different amounts of time it might make more sense for the consumer to handle information from each producer as it is complete. 

The point of a header file / class definition at least in my head is to separate the interface to your code from the implementation of your code. Not putting parameter names in your function declarations makes your interface incomplete. Sure, you know what the parameter is, but your wrote the code. From reading your class header I don't have a clue what the string might represent, there's no comments to tell me, no name, so I'm either relying on your documentation (?) or have to look at the implementation to figure it out. Default parameters Default parameters only effect code that can see them. You've defined default parameters for your methods, but only in your implementation file. I find that a little odd. If it's a good default, it should be in the header. Naming Descriptive naming is important and significantly reduces the learning time for people new to your code. I had to look up to see what it was. It probably makes sense if you have experience in that area, but as an implementation of a folder structure it's not the first name I'd be looking for. to me means 'print working directory', so seems like an odd name. Perhaps would be better. is very non-descript. It's a list of metadata, why not call it that? You have a similar issue with your method naming. doesn't really say 'read the directory and return the meta data to me`. Blank Lines Some of your blank lines don't really make sense to me, they make your code harder to read. Consider this: 

As it stands, the property can only ever return an , that isn't null, this is enforced by the compiler. All your tests do is make sure that the type of the property can't be changed. In rare cases you might want to have tests like this (for example if you had a versioned API and you wanted to ensure that changes didn't impact released versions), but generally you want to be testing the behaviour or methods, not the implementation. Without looking at more of the production code (which you haven't posted) it's hard to say what approach you should taking to writing tests. The class is partial, which suggests there's other implementation elements somewhere. Looking at this method: 

This could be refactored into a method that takes the winning player number. There are other repeated blocks that again could be refactored into functions to reduce the overall amount of code and make it easier to follow the logic. For example, ?: 

Singleton? Does it make sense for an application to have more than one instance of the class? If not, then should it be enforcing this through some kind of singleton model? Cleanup and Self Contention As far as I can tell, the code you've posted doesn't actually track which locks have been created by a particular instance of the (or the application it is running in). If a bug/crash/network failure results in not being called then the 'lock file' will end up with an entry in it that isn't necessary. If the user starts up the application again, does it take over responsibility for those locks? Is there a cleanup app that allows locks to be removed? Are warnings raised when locks have been held for too long? It feels a bit like your class should be tracking entries that have been added by it and then ensuring that they are removed as part of the , however that might not actually make sense in the context of your overall application. I'd also be a bit concerned that if you're locking by user it would be possible for a user to run two instances of the application (I do this all the time with explorer) and perform two interacting changes without realising it as both instances believe they hold the lock. This is often overcome by storing an additional piece of information, such as the processId that holds the lock. 

Overall On the whole I like your approach and your tests look pretty robust. I have tended to have simple 'does this execute' type integration tests at a repository level that are manually validated, since they only really need to be run if you're updating the repository or the underlying database. I then rely on higher level use case integration tests, where the repositories are used under the hood, to flag up any data discrepancies. Your approach of having the tests cleanup after themselves is a nice tidy approach. Consider Categories It looks like you're using NUnit and if you are, then the one thing I would suggest you do though is mark your different types of tests using categories. I leave most unit tests without categories, however I mark integration tests with categories so that they can easily be excluded / included into builds. You can use the attribute at either a 'Test' or a 'TestFixture' level. 

The shadowing works, and the correct implementation is invoked. However, because you're invoking the implementation from the base class: 

Are not always the same, which is akin to saying whilst , . This can be demonstrated with a simple test: 

Naming/Function Prototypes If you're going to go to the effort to declaring your function prototypes, it's worth adding parameter names so that it's clearer what the expectations are. Looking at the following prototype, do you really have any idea what it does? The only hint is the pretty nondescript name of the method . 

It's error prone if you decide you need to extra behaviour to the for loop and forget to add the braces when you do. I'd prefer to see braces wrapping the for loop... 

Various things about your code seem odd. Field level values There's no reason for these variables to be declared at a class level, you only ever use them within a single function: 

the allocated array is never cleaned up by your application. You should have a paired delete somewhere in the code when you're done with the array: 

Formatting Your indentation is all over the place. Using a consistent form of indenting that reflects the scoping of statements makes your code much easier to read and makes bugs easier to spot. Consistency Be consistent with your interface. You define in terms of the data item that is to be stored in the queue. This is good, because it hides the implementation. However, you define as returning a . This is bad, is an implementation detail, there's no reason for the caller to need to know it exists. should instead be returning an (as this is the type stored in the queue). Print statements Your print statements don't belong in your queue. Part of the reason that you originally submitted code that didn't allow access to the values stored in the queue is because you put the print statements within it. Separate the concerns of your classes and test the boundaries. If you had originally tried to write your print statements in your is would have become clear that you needed dequeue to return something in order for you to be able to print it. Mains don't belong in collections Your main method doesn't belong in the Queue. It's not part of the Queue, it's part of your test harness. You should put it in a different class. This will help to enforce the boundaries between what is the Queue's responsibilities and what is not the Queue's responsibilities. Returns & Elses Where possible you want to avoid nesting statements too far. In your dequeue, you're doing this: