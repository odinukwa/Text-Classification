Basically that's saying if the U key AND the K key are pressed, OR the O key, do the action. Or depending on how you have things arranged, you could do something like: 

All this code would go inside the method, so you know the mouse is in the correct place when calculating the distance. Alternatively, you can cast a ray and use the variable from the class. 

Also note that the and methods both accept a parameter, this defaults to the local or coordinates. If you always want to rotate around the world axis you'll have to pass in the variable when translating or rotating. 

You're drawing faces for the the terrain right? Just like you're computing faces for a voxel, you can compute the normal. The normal pointing outward of the voxel is the same normal pointing outward for the face you're drawing. If you have access to the vertices, you can compute the normal formed by the surface triangle you collided with. Or more simply the normal is just the voxel pointing to the next voxel that's empty. For example: 

If you're using version 5.3.3 or above, use this line instead instead of the last line above, delegates is depreciated: 

I've implemented something similar to this. I wrote up a post about it on my blog: byte56.com/2011/06/a-light-post. But I'll go into a little more detail here. While the codeflow article linked in another answer is pretty interesting. From what I understand, it's not how Minecraft does its lighting. Minecraft lighting is more cellular automata then traditional light source. I assume you're familiar with water flow in MC. Lighting in MC is essentially the same thing. I'll walk you through a simple example. Here are a few things to keep in mind. 

Have a matrix of chunks that make up the visible area around the camera. The chunks will use modulo, just like in 2D, to determine which chunk of your wrapped 3D world they should contain. 

Yes. You'll find resources for the Unity path finding system by searching for "Unity Navigation Meshes". You can find the documentation for it here 

Remember that what you display on screen, and what's in memory are two totally different things. Imagine you have a window that you need to fill with data about the world. You fill the window from left to right. While you're parsing your data to fill the world, if you reach the end of the world, simply loop back around to the beginning of your data. Using a modulo operation is ideal. Remember you need to do this for everything. Projectiles, rays, players, physics; they all need to have their positions wrapped when crossing the world bounds. Each player shares data, but has their own perspective of the data. Their windows are populated differently depending on where they're standing in the world. This means there's no need to create clones, or teleport anyone. Essentially you are creating clones, just by rendering characters to each other's screens. 

Then you'd had a different script for changing the position, rotation etc, depending how you want it to behave. The easiest way to accomplish all of this without having to write as much code? Create the game object in the Unity editor first. Once the game object is equipped with the sprite you want and the behavior scripts and all that. Drag and drop it into a resources directory. This creates a prefab. Prefabs are just what they sound like, pre-fabrications. They're complete objects that you can then reference and create on the fly. You'd create those like: 

This is a delegate method because we're going to treat it like a variable that's going to be passed around. There's no body because we're just telling C# what we want the signature of these delegates to look like. Next we create our event: 

You'd likely offset the choices above with other benefits like only allowing certain weapons to unlock in the harder difficulties or higher level caps. Additionally, to help mitigate the risk of having a bad save, checkpoint or otherwise, have the save system use a rolling save system with 3 or 4 save slots where the oldest gets overwritten. 

Unity does not have this kind of "direct mode" rendering, you won't be calling in any update loops for Unity. In Unity you need to create a game object, then attach scripts to that game object. Those scripts will control how the object behaves, if and how it's displayed on screen, if it's part of the physics system etc. To create a new sprite to draw on screen you'll need to create a new game object, then attach the SpriteRenderer script to it and set its sprite. 

There is another alternative. You can implement your own click system, and use the method instead of the build in ray cast that Unity uses behind the scene. The sphere cast is similar to a ray cast except it is larger than a ray. Any object inside the sphere's cast radius will be returned as a hit object. I created a video course for Unity, and the ray casting video is one of the free videos to watch. 

Combined changes roll over to the most significant change. For example, if you're incrementing the minor build number, the revision and package both reset to 0. Even though the categories are defined, there's still ambiguity for what kind of features actually cross over between a revision and a minor build number. It's up to you. If you make lists of the features that will need to be implemented before each increment, you'll also have a plan to follow, but in the end it's your decision as to what fits into each category. 

You'll see that two Static Trigger Colliders will not interact with each other. If you want your collectibles to have their trigger methods called, your cat needs to be one of the following: 

Once you have your exit object defined, you know it's location, and can use that when "teleporting" your player: 

It's something you should look into. There's an article on MSDN about this warning. Essentitally, it's a matter of optimizing you code, but it's important to profile the code so you know what to optimize. These are the steps listed in the article: 

Start with a full list of rooms. Pick a starting room. Navigate from that room to all connected rooms. For each room you visit, remove it from the list of rooms and add it to a list A. Once you've visited all your connections, any rooms remaining on the list are not connected to the starting room or any of the rooms on list A. You can then continue by selecting a room from what remains of the full list, and navigating again. This time adding to list B. Continue this process until you have no more rooms on the original list. You now have lists of all the connected room sets. Problems like this are easily adapted to graph theory problems. For example, the problem you've described above directly relates to connectivity. 

You get the path the same way you'd move the object when you shoot it. Just have a tight loop that simulates the movement of the object and keep track of the position every so often. Now you have a list of positions, if you draw a dot at each position, you have a dotted line the represents the path of the object if it were to be shot from that angle. 

(doc) is used to create an instance of a prefab. Essentially a clone of the object. Using doesn't work because only one camera component per object is allowed. 

I've tested this out. I saved my game right when a physics object was falling towards a ramp on the ground. I then loaded the game and watched where the physics object ended up after hitting the ramp and rolling to a rest. Each time I loaded and watched the object, it ended up in the exact same spot, pixel for pixel (I took screen shots and compared). I performed the test five times with the same result. So then I thought I would save it again, a little farther along its fall before it hits the ramp, then load again. The next time I loaded, it ended in a different place! However, now every time I load it, it ends up in that second spot. Now, every time I load the game it always ends in the same spot, but that spot can change depending on the starting conditions. 

I'm making a historically accurate game where the player can interact with past times and shape the future. The entire game is scientifically generated with math and real physics. (no, it won't have dragons! lol) The game will run real time and simulate the entire Earth (at first, then at level 56 the player unlocks universe mode where the whole universe is simulated). The player can build anything they want and it will use physics to simulate each creation based on the materials it's made of. Like they could build a rocket with solid fuel and it will launch realistically, as long as they shaped the nozzle correctly. Anyway, I'm at the point where I'm simulating the dinosaurs and I want to make it accurate. I know we can't know exactly what the political structure of the dinosaurs was since most of the writings were destroyed in the comet strike, but most people know that our political system is based off theirs. I was considering just modeling our political system and then applying mathematical regression to the algorithm to regress it 100 million years. However, I'm worried about the limitations of floating point numbers and I think that errors will compound. That would leave me with a political system that's really inaccurate. What strategies can I use to develop a political system from scratch? P.S. I'm mostly talking about American dinosaurs, because they had the most impact on world politics. 

This tool allows you to point and click to select points, and then draw a Line, Polyline or Polygon. It will print out the points data required. 

Note: You may want to add your timestep into this equation, otherwise you'll have to set and to something like: . Basically, and should already have the time factored in if you don't include it separately. It would be preferable to add some kind of wrapping code to wrap when it completes a circle, but it's not strictly necessary. 

Unity seems to be a popular choice lately. It will allow you to run on iOS, Android, Web, PC, Mac. Although, you're question needs to have more specifics like what kind of games you want to make, what features you must have, etc. Otherwise it's a just a "What's best?" question, which isn't good for this site. 

So, if you're using version 2.x, no, LWJGL cannot support multiple displays. While it looks like there might be plans to do so in the future, I wouldn't plan on it for your own game, and I wouldn't start using the alpha for your development either. 

The best way is to use a library designed to provide GUI functionality. This will be specific to how you want to use it, and what you're using already. Here are some common ones: 

Likely the cheapest pass you can find that gets you in. Also, purchase early (before Feb 2). Looks like the Expo pass would suit you since you're not sure what to expect: $195. 

Once you have that list, you can sort it based on depth, or the one closest to the bottom of the screen wins, or whatever you want. 

Delta time is the amount of time since the last update. You're getting 16 or 17 because it has been 16 or 17 milliseconds since the last update. If you want to know how long your game has been running, do something like: 

The new iPad has a resolution of . That means in landscape mode (assuming you don't want to stretch the image) your background image would need to be 1536 pixels tall and at least 2048 pixels wide if you don't want a repeated portion in the same scene. Now you can either scale down for the other devices, or you can create additional art for the other devices. If you're scaling, just scale the height of the image and allow the scrolling feature to buffer any aspect ratio changes. 

It's not as in-depth as Dwarf Fortress, but it's a start. Now as you can imagine, (and as Johnathan Hobbs mentioned) the more these races expand, the more cells are being simulated. Not only are more cells being simulated, but the simulations are more complex as there are now structures to build/maintain, battles to wage, commerce to... commerce, and so on. This gets heavy for any language. Javascript might slow down sooner. However, you can always sacrifice complexity for improved speed. It's all a simulation (albeit complex), you're just recording the important events along the way and calling it history. I also just found a Bay12 forum post for people brainstorming how to make the Dwarf Fortress world generation faster. I haven't read through it, but it may provide some hints if you ever run into issues with your implementation being too slow. 

Alternatively, I'm not sure how you're creating the component in the first place, but I'd pass in the game object you want to attach. 

The byte code for that tile is 10101000. You probably see where I'm going. You set bit positions in the byte representing connections. This is far better than trying to do some big if/else chain that I've seen before. When you're looking to place a tile, examine the tiles around it and create a byte along the way. Set 1's for tiles that have roads (or whatever you're looking to connect) and 0's for tiles that don't. When you're done, you'll have the byte code for the exact tile you need. Note that when creating the assets you can reuse a lot of them by simply rotating and assigning the correct byte code to it. EDIT: Updated images to be less crappy. Yes those are better than before.