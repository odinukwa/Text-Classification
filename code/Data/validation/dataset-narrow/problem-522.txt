Also note that if none of the words are "long", then the loop method will go into an infinite loop, while the other methods will return an error. 

One strategy: Do binary split of , and for each split, keep track of the smallest number of that is greater than or equal to the largest element of each branch and the largest number of smaller than the smallest element of the branch. Once those two numbers are adjacent, don't split that branch any more. So, taking your example . I'll split , with scores in brackets surrounding each branch in bold. At iteration 0, I have {[120]( 100 100 50 40 40 20 10 )[5]} That is, I haven't done any splits, so everything is in the same branch. The largest number of the branch is 100, and the smallest number of larger than that is 120, so 120 goes on the left of the branch. The smallest number of the branch is 10, and the largest number smaller than that is 5, so 5 goes on the right. In iteration 1, I have: {[120](100 100 50 40)[25]} {[50](40 20 10)[5]} iteration 2: {[120](100 100)[50]}{[50](50 40)[25]} {[50](40 20 10)[5]} Since there are no numbers in between 120 and 50, the first branch is done splitting. Since there are no numbers between 50 and 25, the second branch is also done. So the next iteration moves on to the third branch: {[120](100 100)[50]}{[50](50 40)[25]} {[50](40 20)[5]} {[25](10)[5]} Iteration 4: {[120](100 100)[50]}{[50](50 40)[25]} ]} {[50](40)[25]}{[25](20)[5]} {[25](10)[5]} At this point, I’ve done all the splits I can, and I can just read off the ranks; each rank of a number from is the count of distinct members from to the left of the first instance of it, plus one. 120 is all the way to the left, so its rank is 1. The first instance of 50 has one distinct element of to the left of it, so its score is 2. And so on. The dense ranking requirement means that you'll have to get rid of duplicate members, but other than that this algorithm should be logarithmic time, rather than linear time for your algorithm. 

But it mixes multiple version translation in a single piece of code and will look ugly after introducing of more versions. What is the best way to deal with versioning generally speaking then? I would prefer a single sectioned query to deal with all versions in a unified way instead of running stored procedure with multiple queries if possible. P.S. I just think that is a must feature here... 

Nothing really interesting so far - we just defined equality logic for configurations to help detect changes. Here are some fake implementations to make test work: 

I would not personally put LoggingService implementation inside factory, as it reduces testability and usually needed to play some tricks with generics type parameters only. To have a predictable behavior according to your design it might look like: 

There are a lot of numerical properties to be invoked many times with an expensive calculation. Let’s say for the sake of example, they expose a Factorial: 

Defines a merge of JObject field content to object, creating one if missing. As shown, there are the following permutations of mapping declarations: 

How do you handle ? It is really useful in many TPL or business scenarios, but handling is a real pain. I defined the following three extensions to help myself a little bit. They can be used this way: 

if you're having trouble understanding , consider the case of generating the 7th number. This is going to be 4+7+13. But 13 was calculated by 13 = 2+4+7. So the 7th number is 4+7+(2+4+7) = 2*(2+4+7)-2, which is 2*(6th number) - 3rd number. So the nth number is 2*(n-1)th number - (n-4)th number. This does require handling the first few rows separately. One way is to manually create them, and then if you don't want them, you can delete them afterwards. Note that if you're deleting them, then you don't have to fill in the ratio column for those rows. You will also have to initialize to the proper value. 

(Note that if an block has a return in it, you don't need to follow it with "else"; you won't get to what follows the block unless the condition was false). As for the function, you don't have to loop through every integer up to sqrt(n), you just have to loop through primes. Your and functions are rather useless. Just do and , and then use and instead of and (note that is a reserved word in many languages, so it's probably a good idea to not get in the habit of using that as a variable name). Instead of doing , you can just replace with , etc. You could rewrite your function to add neighbors according to various conditions, rather than having a separate dictionary for each case. e.g. 

Intensive use of mutable static state always fights back. I would split it to three projects: School.dll 

It does not sound like creation for me… We are not generating code at run time here. What we deal here with is just a set of converters, which is solvable though the composite pattern. Let’s define an abstraction (you could extend it with ): 

Mixin type emitter (Well, not sure that implementation really looks readable - I hardly understand IL. But it works for method delegation :) 

What do you think about this file system manipulation helper? There is an utility class Folder which I can use to define directory structure of my app: 

Unfortunatly, Reference Types (classes – heap allocated) are very bad choice for the Math. Using them untolerabably slow downs calculations and significantly increases resource consumtions. We could define our own struct type, but it looks like a some kind of trade off – it is not 100% type safe. Let’s define an algorithm using a generic struct : 

I would not put dependency on singleton in this class – it means two responsibility for - format properties and orchestrate AD API. Let’s define this helper class to be more explicit on your validation scenarios: 

Updated Here is a little bit of cleanup. Now you can get back reference to before blocking starts: is a non blocking call. It also works with and in the view. 

There was a previous question that I answered regarding Tic-Tac-Toe that I'm too lazy to look up, but this is a common enough subject (as you are apparently aware, there's even a tag for it) that you might want to take a look at other questions and see what applies to your program. Taking a broader look than the other answers to your question, why are you even checking for a win in the first place? If your program is running this function after every move, that's horribly wasteful. All you have to do is check whether the new move creates a win. You only have to check the lines the new move is in, and you only have to check two locations for each line (you know that wherever the current player just moved has their symbol in it, by definition). Also, any time you have , you don't need an ; if the first is satisfied you won't reach the rest anyway. 

So .. you're repeatedly subtracting a number from another number, and seeing how many times you can do that without going negative? There's a word for that: division. EDIT: Since you want the actual code 

In your first thing, you're checking each character one by one to see whether it's a decimal point. Using string functions, you can just do: 

At the moment there is an method. However since you should add cans and not set cans, you should rather take as an argument the number of cans you should add: 

Beyond the requirements The two setters are superfluous and can be removed. Also, Java class naming convention is CamelCase so you should rename to . Since your class is not meant to be inherited, you can mark it . Here is the full resulting class 

Meter I think this class totally useless since you only wrap an (for nothing ?) Don't you think it's a bit redundant to write instead of ? I would remove it. CarType As Tunaki said, I won't couple the distance into the , this has nothing to do with a . Don't you have the feeling when you compare , and that there's a lot of redundancy ? From my point of view, it's screaming for an enum since the only difference between all of that is the value of . I would refactor all of that into the following: 

This is the kind of test I would write (I picked a convention for the names, you can choose another since it stays coherent). Given the previous refactors, the test implementations are more expressive now: 

Update Following your comment, this is how I would implement the file creation based only on a date + a counter (if needed) 

What is your desired output? Your function has no return statements (other the one commented out), and the only print statement is in the block. Have you run this function? Unless I'm missing something, it won't do anything if you input 0. And when you strip out the last digit, you don't actually store it anywhere, so it's just gone. You seem to be doing double tabs for your indents, which makes it hard to read once you get several levels deep. Also, you can save yourself an indent level after the block; since you have nothing but an block after this, you can put a return at the end of the block. Then you won't ever get to the block unless the condition is false, making the redundant. So you can get rid of that and move everything in an indent level. You don't show what face_value is, so it's hard to evaluate your code when it comes to that part. Also, unless I'm misunderstanding, the block should be something like this: 

If something is called "RiemannSum", then it should return a sum. If you want summation to be a separate method, a better term would be "partition"; you could do RiemannPartition.sum(), for instance. Several other variable names are bit unintuitive to me (e.g. rectangles, index). You can eliminate several lines by doing: 

DDD How often have you heard from your domain expert manually managing room booking in his/her Excel all those terms like , , ? I bet that never. This stuff does not belong to the domain, does not solve any business problems, and probably should not exist. Having names like that clearly indicates the problem - those words are not in the Ubiquitous Language. Domain logic is way too corrupted with technicalities. Sure, no database related code should be allowed in domain. P.S. It depends on the task, but I could probably load all the data in memory and run here easily. Design What is the Software Design? All the things helping you to keep your project maintainable and that you cannot change latter easily. What helps keep project maintainable? Placing dependencies in a way where volatile components depend on a minimum amount of stable abstractions using Dependency Inversion where necessary. There are too many concrete tech elements in your code to follow “minimum amount of stable abstractions” criteria to keep things maintainable, so design misses its goal here. P.S. It is not a responsibility of the Controller to decide on room/combined room booking priorities – it belongs to the business logic – to the place where you actually implement the logic – repository in your case, as you do not need DDD here at all. I would have the following models in the Core project without dependencies on anything else: 

Generate an array of n percentages. Calculate the average percentage. Subtract the average from each element. Do a for-loop of i from 0 to n-1 and set 

If the number consists solely of n nines, then the next number consists of n+1 ones. Otherwise: a) find the last non-nine digit. b) Add one to this digit. c) Replace the original digit, and all following, with this sum. 

You shouldn't be doing things in a loop that don't depend on things changing in the loop. , , and all depend on n, which is constant throughout your loop. Also, if you store your primes, you just have to loop through the primes until you get to sqrt(n), rather than checking every number. There are further tricks to speed up the algorithm, such as checking n only if n mod 60 is in [7,11,13,17,23,29,31,37,41,43,47,49,53,59]; that reduces the number of n to check by more than 3/4. Is tail recursion an option? How large is your stack size? You can break recursion into subrecursion. For instance, suppose you have a function that recursively finds the nth to n+100th primes. Then you can have a recursive function than, when asked to find k primes, calls itself on k-101, then appends the k-100 to kth primes. You can then add another layer, and have something that does 10 primes at a time. Do this in binary rather than base 10, and you'll need 14 layers to get 10001 primes. 

And all the API with multiple overloads will come as two sets of extension methods – I really like this trick :) 

P.S. Generally speaking, it makes sense to do not hold an intermediate state of you calculations (like trimmed string values) – just an original data + define functions/properties to process them. It makes your design more flexible. P.P.S. It might be useful to have class: 

Trying to figure out how to efficiently cache property calculations with dependency tracking to invalidate the cache. Here is the syntax I have at the moment (one instance supports multiple object properties): 

This type of functionality does not require whole document to be loaded in to the memory. It might be easily done as a set of improvements over which provide better scaling possibilities: 

What do you use for refactoring away from exceptions while programming functional in C#? I defined this class to hold function outcome: 

What do you think about names chosen for the following library code identifiers? Would you name them differently? 

I would define API a little bit different. Let’s go with couple types: SizeUnit and DataSize, so they can be used as: 

OK, it is going to be a long answer :) UPDATE Actually, marking for deletion is not necessary, see Little-known gems: Atomic conditional removals from ConcurrentDictionary. I would still consider the rest of the answer as an approach to structure the task. END OF UPDATE - when you about to remove from it - first to get rid of racing conditions. I defined this helper class to assist with this task: