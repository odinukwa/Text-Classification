Both books will teach you Game Maker's drag and drop, neither will teach you C++. Im not sure if the cookbook teaches you GML, though i know the companion does. Both books have their own style of teaching. So on that matter, purely subjective. The Cookbook is slightly cheaper (thought not much) The Companion is out already. The companion might (i'm not positive) require you to get the game makers apprentice as well. Overall i would say companion. The sooner the better, and it will teach everything you need to get started. The Game Makers apprentice might be needed first though. And regarding C++... Well thats a totally different area. If you want to jump straight into it, neither of these books will help. However if you want to learn the basics of using logic to do things before delving into the details of the language, well it might help to learn GML first. 

which disables a second shot from firing, as your game so far only works with one bullet (without this code, the 'old' bullet would disappear and the 'new' bullet would appear). Instead, try implementing an array to hold new bullets, instead of limiting yourself to only one. (Though you may want to implement a cooldown on firing, otherwise space could be held for an extremely rapid fire) EDIT: Quite a few changes to the code had to be made... As i havn't used javascript or HTML5 before, i couldn't really test all of this, though it should be fine. I commented out lines of code instead of deleting them, and tried to point out where i modified stuff. 

Basically i am trying to render a model yet it seems to draw polygons that should be behind something, in front of it. So i end up seeing some faces that should be behind something, totally covering it. Bah, i suck at explaining so here's the pic: 

For a section of my game, instead of having a perspective projection, i would like to display an isometric view of an object. So i don't want things to appear smaller if in a distance, etc. Basically a proper isometric image. Is there any way to do this in XNA? 

Is there any way to have the texture of a model loaded from a Png ? I have a simple prism to test it on, but i just want to be able to edit an image and have the model's texture change. Thanks! 

i want to be able to loop through a hole bunch of textures, and render them on an object. I then want the rendered image to be placed onto a texture2D. The point? well hopefully i will end up with an array of Texture2D's containing a model with multiple skins. Here's my code: 

Ended up using the example on the site. Realized i was using it wrong and should have used it more like a library. 

First of all, I find merely impossible to learn a programming language without a clear project in mind. So you should first try to define more precisely what in computer animation you like. This is a vast domain containing (but not limited to): 

You can add colliders to your objects. Then, each time the mouse "enters" the collider, it calls . When the mouse exits, it calls . So just create a script like: 

Your problem being in the "simple category", IK based techniques could work. Finally, note that existing middleware could help. In particular, HumanIK from Autodesk is great for that (and much more). 

You do not HAVE to use the right side of the left side. You actually choose around which axis you want your EP curve to revolve: 

The basic idea is that for two identical skeletons with different animation clips, for each joint rotation, you compute in-between values. Animation clips are represented with rotations. So linear interpolation is not what you should use if you want accurate results (even if you are using Euler angles). You can use slerp for example but more complex solutions exist. This is a complex problem with complex solutions. Basically, if you have two animations clips A and B: 

This is not trivial to do actually and it needs some careful thinking beforehand. I suggest your read this paper which is a good explanation of the problem with different possible solutions: Comparing Constraint-Based Motion Editing Methods, Michael Gleicher, Graphical Models, Volume 63, Number 2, page 107--134 - mar 2001 

Take an initial motion close to what you want but not perfect. Here, it is the motion in your first video; Determine the constraints you need to apply. Here, most probably the hand should stay on the handlebar; Then compute, at key frames (or similarly at every frame), the displacement you need to add to your animation to satisfy your constraints. This can be done with Inverse Kinematics for example; Finally, smoothly interpolate your initial animation with the final required results by smoothly "adding" the computed joint displacements. 

What you need to find is a technique that, given some constraint C (the left hand on the handlebar), applies some displacement to your joints so that the final animation respects those constraints while staying as close as possible to the initial animation. This could be done with constraint-baseds motion editing techniques and in particular, Per-Frame Inverse Kinematics. The idea is: 

If you are interested, I suggest you start by reading this article so that you can better understand what the difficulties are: $URL$ It is not the most up to date one, but it is easy to read. I hope this helps. Best regards. 

It is most probably a driver issue... I often have the same artifacts. If you switch to 4 viewports mode then back to 1 viewport mode, it should disappear. Sometimes rotating the camera is also enough if the viewport is a persp. camera. You could also have created a layer containing a duplicate of your initial mesh. Original mesh: 

Don't know python, but here is a basic arbitrary-language example. You should only have one game loop that updates all other entities. You can determine how much time has passed between each running of the loop and pass that information on to the entities who can use this information. For Example: 

You don't need to create a symbolic Java File to pass to the ParticleIO method, you can just provide the relative String reference to the path of the XML. ParticleIO is a class used for Serializing and Deserializing ConfigurableEmitters through XML. So if you are trying to "load" an XML using ParticleIO, then you are trying to deserialize that XML into a ConfigurableEmitter. For this to work properly it must have been serialized to that XML file first. If loadEmitter() is returning null and your path is 100% correct, then you are trying to deserialize an incorrect XML file. 

Very simply Files are a collection of bytes that can be interpreted anyway you choose (but will only be interpreted correctly following the proper steps for each individual file). The extension is used as a tip for how you should go about interpreting this file. When a developer makes a file-type you've never heard of it's because it's his/her own custom file-type that suits his/her own purposes, or he/she just doesn't want you to know what file-type it is at all by making a random extension. You can do something like this by reading the byte data of files, and writing it back into a larger one. Nothing is stopping you from writing the file data of several files into one larger one as long as you know how to read the individual file data back to suit your own needs. This is how compression works. It takes the original file data and runs algorithms to create new condensed file data that can be reworked using similar techniques into the original file. For example a .zip extension just tells you that the file data is compressed data using the zip format, and will be pretty useless to you interpreted in any other way. Read up on basic file input/output in your language of choice for the actual HOWTO of working with file data. 

Check out XStream, I found it to be extremely easy to use for serializing/de-serializing Java Objects. For working with files such as checking if they exist, use the Java API: java.io.File is a simple way to check such a thing. I think you should familiarize yourself with basic Java input/output before chasing goals such as serialization with XML. 

I don't know python or pygame, but assuming you're using a game library there should be a way to poll the state of the key, such as if it's currently down or not instead of if it was pressed since last update. Use that for checking and updating movement. The next problem you will run into is it will update movement as fast as your logic update interval is as long as the key is held down. To fix this you need a variable to act as a cooldown so when you poll the state of the key and use it to move, the variable is set to the cooldown amount, and you can't move again until that cooldown reaches zero. So for an example of basic movement code assuming an arbitrary library and language: