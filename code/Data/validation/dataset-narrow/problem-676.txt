Where you implement a suitable Comparator. This means that your data will have a much better cache coherency as the data you will be using will fit on the same cache line. 

The likelihood of generating two keys that are duplicates is \$\frac{1}{36^{16}} \approx 8\cdot 10^{-24}\$. So if you generate 10000 (ten thousand) bulk keys, the likelyhood of not having any duplicates is: $$(1-\frac{1}{36^{16}})^{10000}=99.99999999999999999987\%$$. In other words, you are not very likely to get duplicates as long as your random function is good (hence the use of instead of . To be certain you have to always check against your database anyway as a last step so I would just not bother with duplicate checking on the client side as the likelihood of finding duplicates is so very low. 

The result must be calculated as if optimized to the result will differ. And in your case you actually want as the correct answer. In your case you should do: 

for maximal performance (note the swapped order of x and y). Improved Algorithm The key idea to note for improving the algorithm is that each of the spots has the same influence on it's neighbourhood. I.e. all the distance calculations for each dot are the same, just with a different offset. This means that we can pre-calculate the results once and just blit. Define as the radius in pixels from a spot where you cut off it's influence on the image. Below is pseudocode to show the idea. It may contain bugs, and there is definitely some assembly required. Like checking image bounds and using a 1D dense array instead of a 2D nested array (which is done for clarity): 

Use of white space You have a lot of randomly added line breaks, this makes your code difficult to read because I have to scroll a lot. Please keep your code tidy. Don't do unnecessary work For example in your destructor you do this: 

You need to do it in \$O(n)\$ time and to do that you need to figure out a way of doing it without actually removing the characters from the strings. As you didn't link the original question I cannot help you as your description is a bit ambiguous as to how it should work. 

(Note: the iterator itself never becomes invalidated even after C++17) However (Since C++11) may or may not invalidate the iterators depending on if a rehashing occurred or not. So if stable iterators are important for you then you should not use it. As for your question it is hard for us to help you because you have not clearly specified the requirements on the container you're trying to design. Depending on how you want to use it (we don't know) you may or may not be better of just using . But my gut feeling here is that requiring stable iterators indicates that you have a problem elsewhere in your code and that your efforts are better spent rethinking your design to get rid of that requirement. 

For the love of don't use . You're teaching the students bad habits! If you want to show your students the awesome power of parallel computing, pick an inherently parallel problem. Like computing a Mandelbrot image, or compute pair wise edit distance of a large dataset of strings or compute character frequencies of a large codebase. Or brute force a password or something, there are endless embarrassingly parallel problems. Pick a real workload, and show them a real use case instead of a contrived example. Edit: Why is use of bad? First of all we should carefully read the the documentation on where it clearly says that: 

For this reason you should make be the minimum number of bits the array is guaranteed to hold. And figure out how many s you need internally in the class. Missing methods You really should provide a method as well as a . It would also be a good idea to provide overloaded where is implicitly convertible to bool and has assignment operator that writes back into the array. This means that will set the fourth bit to true. Off the top of my head (this probably doesn't compile but it shows the idea): 

Your algorithm does 5 passes over the input string with several instructions per character. If you instead just iterate over input string once and keep track of what characters occur in the string (assuming ASCII here) then you can check if all vowels occurred easily, and without any branches. 

Summary: With a sieve based method, you need to spend so much time at generating the primes that it actually is slower than the original. If you need to test many numbers, then the sieve is going to overtake trial division as you only pay the setup once. The optimized trial division is the fastest of them all by almost a factor 10. 

Sort the numbers and keep at most 3 zeros and two of any other value. Let the numbers be called \$a_i\$ so that \$a_i \le a_{i+1}\$. Construct a of all \$a_i\$ with their multiplicity. Set \$k=0\$ If \$a_k > 0\$ you're done. For each \$i\gt k\$ construct the pair: \$(a_k, a_i)\$. 

should be . You're implementing the hash chaining as a linked list which has poor cache locality. You might just be better of having: 

Just as an aside to the good answers you have already been given: Consider handling leap years During a leap year the dates for the different zodiacs change. 

In the end your algorithm is \$\mathcal{O}(n\log n)\$ although there is a lot of iteration going on and I would say it's on the slow side of the spectrum. A better solution A faster way of doing this would be: 

Again YMMV the compiler may have been able to do the above transform for you, or it may not be any faster at all. It is only my gut feeling telling me that the above might be slightly better. I have not profiled and you should test to see if it gives any improvement at all. Better formulation for Lerp The current code is: 

It encapsulates the shorthand with the context in which it is used. As an added benefit you can now change the implementation from to if need be, without affecting the rest of the application. The C++11 keyword will save your clients typing . Also is shorter to type than ;) I agree with RubberDuck on the naming. Prefer as class name. Also I'm leaving the indepth review for some one with more time on their hands. 

Forgetting to inject the CRTP parameter into a class that requires it will not give a compile error. It may not even give a run-time error. In this example it will just silently give you a memory leak that is a royal pain in the rear end to debug. This will happily compile and give you a memory leak, even if C inherits properly from B with the CRTP parameters passed around: 

Your A* is incorrectly implemented You are using the total number of moves explored as the priority for each search node. See here: 

Algorithm What you have implemented is called (linear) insertion sort. It is very old, sorry your method is not new or novel ;) It has average case O(n^2) time complexity which is basically unusable for anything with more than a few thousand/tens of thousands elements. I recommend that you study the classic algorithms: Bubble Sort, (Cocktail) Shaker Sort, Insertion Sort, Shell Sort, Merge Sort, Heap Sort, Radix Sort and Quick Sort. There is a classic video from 1981 that is part of many CS curriculums called Sorting out Sorting which is very illustrative and a recommended watch. Code You never use remove it. Once the unused type is removed you can change your template parameter to the iterator type directly and get rid of a lot of typing. This also allows template parameter deduction so that you don't have to explicitly state the container type as a template parameter. Please don't reuse the argument as a variable. It is hard to read when your iteration variable is named begin with another being original begin. Simply make a copy of begin, call it for iterator or . Typically when two iterators are used to represent a range we use the names: and . To not confuse with and and avoid a name collision when some one uses (which you shouldn't!). In general I'm not fond of your naming. For example could simply be . You don't need the inline specifier. You need a better algorithm. The compiler will automatically inline if it makes sense. Bug In the code here: 

are using r-value references (NOTE: They are not universal references). Note that const r-value reference doesn't make any sense. Anyway, I assume that this is because you only want to allow usage on the form: 

(sorry for the brevity and typos, writing on a phone) Assuming that you are only using ASCII characters you can simply keep a boolean array and keep track of characters seen like so: 

Order of , , This is a personal preference but one that I find makes code easier to read. I always order my fields as: then then with the motivation that the person using the class is interested in seeing the API and this should thus be the first thing you see so that you don't have to search for it. Misuse of C++ (and C) has a thing called the "as-if rule". Which in essence says: 

You're using a brute force approach with a linear time complexity in the range and linear in the number of factors i.e. \$\mathcal{O}(nk)\$ where \$n\$ is the range of numbers (1000) and \$k\$ is the number of factors to check for (2 in this problem). Consider the sum of all numbers that are a multiples of \$k_i\$ and less than \$n\$ and let \$c_i=\lfloor\frac{n-1}{k_i}\rfloor\$ then: \$S_i=\sum_{m=1}^{c_i}{m\cdot k_i} = k_i\cdot c_i\frac{c_i+1}{2}\$ Now the first step to the solution to the problem is: \$\sum_{\forall i} S_i =\sum_{\forall i}{k_i\cdot c_i\frac{c_i+1}{2}} \$ But this counts numbers divisible by both \$k_i\$ and \$k_j\$ twice so we need to subtract the double counted numbers. Let \$K_\ell\$ be all pairwise products of \$k_i\$ and \$k_j\$ (in other words, \$K_\ell=k_j\cdot k_i\$) for \$i\ne j\$, then the solution is: \$S=\sum_{\forall i}{k_i\cdot c_i\frac{c_i+1}{2}} - \sum_{\forall \ell}{K_\ell\cdot C_\ell\frac{C_\ell+1}{2}} \$ where \$C_\ell=\lfloor\frac{n-1}{K_\ell}\rfloor\$. The time complexity is \$\mathcal{O}(k^2)\$ and as \$k\ll n\$ it is significantly faster. As for your implementation I would use an array for all the numbers to sum the multiples of and then iterate over that in the inner loop as that avoids an explosion of the expression in the if statement. Other than that I think it looks good. (note: Euler problem 1 is easily solvable with pen and paper) 

Again, I have not tested this. You may have to fiddle around or use other properties of the glyph to get the wanted result. But the data you need is all in there, you just have to pry it out. The LibGDX documentation (and source code) is your friend. 

The reason is that . As numbers in javascript are doubles with 52 bit mantissa and the largest number smaller than 1.0 that can be represented is somewhere around . The expression is not representable and will truncate to exactly . The addition of to the random value will also truncate for large parts of the number range, skewing your distribution. The correct (and fastest) way to do this is by using the original code in OP's question (as also pointed out by @200_success's answer). Addendum: Even if we let: be the largest value smaller than 1.0 and then did: 

the inner most 3 lines of this code may be executed at most times. Provided that the inner loop will complete in say 10 instructions and you have 3GHz CPU with 5 IPC, the loop will take about: to complete so I'm guessing the statement reduces that by about 40-ish%, give or take. I don't believe that you can make this code faster by optimizing, and there is nothing that's inefficient in your C code. You have to approach this by changing to a better algorithm. I unfortunately don't have time to help you with that right now but I hope that I have at least pointed you in the right direction. 

Naming Manifest constants typically use for space in Java. So for example should be . Also I believe that the name is quite misleading as a name because the class isn't actually your main loop but rather a timing helper. Avoid unnecessary conversions You don't need the double precision here: 

Performance (Without any profiling data, I'm guessing blindly here) You have a linked data structure (a tree), traversing the tree has poor cache locality and this is where your performance will likely suffer. Because every node could be a cache miss at worst. But please do measure this first, if you see that most of your time is spent getting the next node or close to a line of code that does, you're having cache issues. One thing you can do to try to improve your cache performance is to encode your tree into a linear sequence ( preferrably). And then measure to see if it actually is faster. As for the encoding, we'll refer to a level of the tree as and the root has . This means that the level has at most nodes. If we refer to each node in a level by it's grid coordinate then the node (at level and position ) will have it's child nodes on: 

Not mentioned elsewhere: Dial back on the excessive use of new lines. Readability is important but remember that scrolling impairs readability as well so try to keep your code a bit tighter (but not too tight!). Why are and public functions? You're not testing them in the unit tests and they make no sense to be public to me. I believe that you should extract the node finding in the method to functions. 

At this point I feel that further review of the code is pointless from my part as the above already highlights problems that would mandate a rewrite that would make further review obsolete. 

Remember that on Windows the scheduling time slice is on the order of 10 ms (see here where a Vista system has 15ms). So this means that your calling accuracy on the animation is about the same order of magnitude as your time step, this is bad news! Your animation will either be jittery or time slide. This is not Windows specific, all OSes have some manner of time slice, some may have dynamic ones. They all just differ in how long these slices are but in general they are on the milli second scale. Even if the OS sleep was accurate, your way of doing it with a fixed sleep would break down if the CPU was busy and couldn't keep up with your paint in a fast enough manner causing a time dilation in your animation. What you really should do is to for each call to your painting algorithm figure out the time since the last call and multiply this by the speed you want your figure to move/rotate whatever. Pseudocode: 

Consider expressing your if zodiac in day of year You are currently testing each of the zodiac signs for month and then day, giving you a total of 12*2 = 24 if statements. If you instead convert (month + day) into (day of year) you only need 12 statements. You can do something like: 

Please excuse my brevity, I'm typing on a phone. Naming The rules regarding use of leading underscore in identifiers are a bit complex ($URL$ Although you do not have undefined behavior, I do generally recommend that one avoids leading underscore on identifiers as not everyone knows the rules that well. Consider using While your code can be used with any freestanding function without arguments and no return type, by using packaged task you can use any function with bind and you can get a for the return value or synchronisation of the result. It would make your code more generally usable. Synchronisation The value is never used outside of a mutex look and does thus not have to be atomic, in fact you do not need it at all as you can just use the method on the queue. Edit: I see now that it counts the number of tasks including the ones "in flight", I don't really see how this is useful if you don't provide a method for separately querying the number in flight and the number queued. Effectivity Note that you do call in your thread loop, this doesn't make the thread wait, it only informs the OS that some other thread can run in its place. If there is no other thread to run, it will run again at the top of your loop essentially pegging all of your CPUs at 100% even without any tasks in the queue. You need to use a to block your worker threads when there is no work to do, and wake them when work arrives. Desired methods You're missing don't methods that are typically desirable, like for example the ability to terminate the thread pool with and without waiting for all jobs to complete. Finally as a reference I offer up my pool in a previous question: Thread pool worker implementation