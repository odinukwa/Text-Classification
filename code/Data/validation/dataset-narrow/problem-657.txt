This is not a lock-free queue, but a locking-agnostic queue. That means, it is not safe to use on multiple threads. The reason this works in your implementation is because the push calls alter the end of the queue and the pop calls alter the beginning (so conflicts are more or less, avoided). If you tried adding elements from multiple threads at the same time (for example), you would leak elements. Since is never changed in the destructor, if it is initialized, you will always get to throw the exception. Consider splitting into a and a ; This would allow for an exception-safe implementation of the operations. 

You are falling into a trap with this. Instead of attempting to create a String class for generic use that is "very optimized", set concrete requirements for it beforehand (e.g. "should be able to perform X instantiations in 10 seconds"; measure these on the machine you need it to work on, and optimize only when the implementation doesn't match your target; most other approaches to optimization are forms of premature optimization). 

The second function should have similar changes. Final code for first function you wrote (with no dependence to unicode and all my suggested changes): 

You should not give access to the current buffer. You should instead expose an API that allows client code to add data to the terminal. If client code needs to know there are buffers, client code should choose the buffer in the write operation. Old code: 

Some observations: Your data should (probably) be private. Otherwise, an enterprising developer will do this: 

This code contains no macros. The passing of runtime args. to the test suite allows for: selection of output format, filtering of executed tests based on args and (probably in the future) more runtime arguments (parallel execution, etc). 

I took the same way with my unit testing (for personal projects I develop at home) but for production code, this is a bad decision to make. I stated my unit testing lib roughly two years ago, and every two or three weeks, I keep adding features to it (and it is still not complete). Here are some things I would not do (and why): 

What you don't know looking at this code: should you delete after the ThreadPool completes running? Will delete the task itself? If it does, will point to deleted memory after finishes. If it doesn't, you will have to remember to check when runner has finished, and call delete explicitly, every single time you use the thread pool. You could implement the ThreadPool to all tasks after execution, but then, an enterprising programmer (maybe yourself) could write: 

This potentially causes your code to exhibit UB because leading underscore followed by capital letter is reserved for standard library impleemnters (I think). You also used the same coding convention for code and macros (please don't). The way you use macros ensures client code cannot avoid using them to write tests. If you redesign your API to not rely on macros, you can then add the macros later with minimal effort). This will make your code maintainable (it's easier to maintain C++ functions than macros) and will not impose macros on the client code. Some features you may wish to add (complementing the list provided by Loki): 

If you do assume there can be lines with multiple spaces (or if it makes no difference), you can write this: 

If you approach performance problems like this you will be unable to implement any effective optimizations. There are two ways to tackle optimizing code: 

Until you do this, it may be that optimization is unnecessary and a waste of time. As a side note (and not related to your question - just a pet-peeve): please stop putting in the global scope. At the very least (if you do use it) use it in function scope, not in file scope - it's bad practice). 

You use ushort for the size of the string. This will allow a size of max 65535 bytes in your string; Is this by design? Consider using standard algorithms: 

I use a different approach: I have created a class similar to std::ostream_iterator (see the utility functions at the end of the code for example use): 

It should populate a result and return by value. Other issues: class interface is ambiguous (actually, you have no public interface). What can you do with a server? Does it always start listening? constructor does too many things. If it fails to run all operations, the object is not fully constructed and you have resource leaks. A constructor, ideally, should only receive fully constructed values and set them as field members. Aditionally, a constructor should (ideally) perform no computations and be as close as possible to code that doesn't fail. If you have computations to perform for initializing the values to be passed in an object instance, these computations should be performed in a factory function. Start using RAII (for example, the call to should be placed in an object's destructor). Note: this list is by no means complete. 

This is incorrect. is "a type guaranteed to represent correctly the size/indexing of a ". is the same, for a native array. In practice, the two are the same (or compatible) ont the same platform. That means, you can definitely write: 

... and defining your allocation list using std::forward_list; This way you will make your code smaller and more idiomatic, increase code reuse and use an already tested implementation of a list. 

Don't do that! It simply increases the WTFPLOC ("what the fuck!"s per lines of code) ratio of your code and even if it seems like a nice idea now, you will (most probably) not consider it a good idea one year from now, looking at the code. 

Because you are allocating arrays, you should use variable instead of variable. Otherwise, the results are undefined. You should also place all arrays inside RAII wrappers. Then, you can get rid of all the deletes. Edit: A few notes about the performance: The performance of this function can be split in two parts: time taken by the allocations, and time taken by the computations. For the allocations, if you can, consider using static allocation (where possible), extracting the data into common types where you can optimize the allocation separately (see my tables example above), and allocating the buffers separately, as members of (I assume here that CAlgo is a class, not a namespace). For the computations, I am not familiar with the API itself. You will have to measure each, pick the worst offender, and post the code, asking people for concrete advice on making it faster. 

establish speed requirement for the code (i.e. "how optimized do you need it to be") measure the current efficiency of the code. 

(bno is probably the only one that should be commented; the other two are obvious) use dependency injection for and . Example old code: 

good naming is hard :) I usually choose this by writing a line of client code, then rephrasing it to read like prose. 

Naming things The names you give your classes and variables could be improved. Consider telling a colleague that you "have a linked" in your code (will they understand that?) I would simply call it "list", "linked_list", or "forward_list" (but not "linked"). Same goes for: 

Don't do this. It greatly restricts what client code (whoever includes your class) can write, and the errors generated in client code are almost always obscure. You're better off repeating that in local scopes (if you must) or (better still) not using it (consider writing and similar, in the scopes you use the type, or simply declaring ). Edit: If never returns false, why does it return bool? Shouldn't it be ? Second Edit: Consder using an unsigned int for the number of threads (). Third edit ( Hi Loki :) ) Regarding ownership of the threads and object lifetime management (how to implement safely and indicate it in the public interface of the class). Consider this client code: 

The way you arrange the code by columns makes it (marginally) easier to read, but over the lifetime of a project, you will either get some tokens out of sync with each other, or have to realign entire lists of functions when you change the length of an identifier; it is debatable if the extra ease in reading the code is worth it - because once you get used to reading untabulated code, the extra alignment adds nothing but extra maintenance effort). 

Do not report errors to the console: it may be that you want (in some cases) to ignore (or silence) errors. This can only be decided from client code. In other words, in the place where the error occurs you do not have enough information to fix it. You should throw an exception here, and in client code (when you catch it) decide how to handle it. NEVER EVER EVER use in library code (unless you have a scenario that really requires it). In this case, if you get an error, it doesn't matter the state of client code, the application will exit (no resources released, no stack unwinding, no ... anything). 

This would ensure consistence in client code and improved semantical information. Consider implementing iteration access, compatible with the STL. This would enable you to use the class in a lot of idiomatic ways (like performing an iteration operation for stream input and output and std algorithms: e.g. find and sort). Consider using full names for classes ( makes me think of a "download list" for some reason). Also consider calling the class bidi_list instead (or something similar): the fact it provides fast access for iteration and insertion is important in client code; the fact it is implemented as a linked list is just an implementation detail. 

In client code (i.e. where you need to know this) you have no ovbvious way to know that means tailwise, without looking at the class declaration. You could define an enumeration so you'd have: 

No. This is an implementation detail and you (probably) don't want to impose this decision on client code; That is, client code should be able to decide at any point if application needs a global, a temporary or multiple instances used for various situations. Other remarks: 

I am not sure this is a good idea (nor do I think the cpplinq in @MichaelUrman's post is a good idea - though it's definitely workable). Basically you are writing a fully templated hierarchy of classes, to replace (existing, stable and presumably tested) functionality in std algorithm: Your code: 

is an implementation detail of the list. It makes no sense to define it outside the class. That means, the code should look like this: 

Otherwise you will have a class that (instead of reporting an error to client code) stops your application with assertion failed. Consider that, as it is right now, you will be unable to write a unit test for (such a unit test would not pass with a "failed allocations" message, but stop your unit testing suite execution). 

End second edit. You are writing client code assuming that your Figure class hierarchy supports polymorphic behavior (i.e. assumes that the return type of will support a function). This implies you should write the base class to support invalid operations on compilation: 

Don't! The only scenario when you should expose the private data of a class is when the class stays valid no matter what client code does with the data (in other words, if I cannot 2 Gb of random data (for example) into the public member of Terminal::Buffer, it should not be public. You should instead add an API to write to the buffer (and this API should check boundaries, validate contents and so on). 

I would have placed this as a comment, but it's too long. Here are some observations to make the code shorter and manageable: 

You are looking at a problem with a "yes/no" answer (i.e. you need to check that the data is the same, not use decrpyted data in more complex computations), you should consider a one-way hash. The idea is to construct an ireversible function, (irreversible = "given x, f(x) is easy to compute, but given f(x) it is difficult/impossible to compute x"). Using a one-way function in your case: To encode the password, you apply the function. To check the password, you ask for user input, you apply the function on the input, then compare the result with the already computed value (the one you need to verify). This will (theoretically) allow you to make an algorithm that is not required to be reversible for checking the data. As a rule of thumb though, security code is notoriously hard to get right. Consider: 

This answer is late to the party, but I thought this needed to be said: In most cases when you think static is a good idea for shared state, you should at least consider dependency injection instead. In other words: 

Regarding the first way (generic optimizations in written code), your code could use the following improvements: 

If you remove the calls to (it's not standard anyway), you can also remove the calls to (because their purpose is to keep the data visible before the next clrscr call). consider having at most one instruction per line. For example, this code is difficult to read: 

This provides a better abstraction level separation and better primitives in your client code. If you hide the existence of in a separate compilation unit or protected/private area of a class, you create a situation where the original bug can no longer be replicated (anywhere) because you only allow for the safe alternative. 

Writing code using macros is usually a brittle solution (that is, "it works and it's fine" - as long as the code needs no maintenance). The original code (the examples you give of symptomatic errors) should be fixed (in my opinion) according to SRP. Your example (with my comments documenting my assumptions): 

If it is a link, you are better off naming it based on what it points to, not what it is (i.e. call it "next", "next_node", etc). Also, your traverse function should be called print, dump, display, show or something similar. Encapsulation Your data is erratically set as public or private; This seems (to me) to follow no rules. Instead of creating a as a public class (although you will not use it outside of the class) and making a friend, consider making it a private structure of the class: the friend declaration dissapears, everything will be public to list, and private to the outside world. Similarly, the data in the class should be private. List Operations Your public interface for the list is inadequate for any purpose except printing the elements to the output stream. Common scenarios for a list are: 

Although your client code has no memory leaks, there are a few design problems with your class. As other answers mention, the interface of the class allows you to use it incorrectly and create memory leaks. Code: 

I assume you use this to stop, not to signal an error state. This may not look like a big thing, but a runtime_error (or specialization) should actually signal an error during the runtime of your applicaition). For example, the Visual Studio debugger can be set to break automatically when a runtime_error is thrown in the application. Using this implementation would screw up debugging without you meaning to. Consider either using a second condition variable (or similar) instead of throwing an exception, or adding docs to the source saying "Terminate is a runtime_error specialization because having no jobs to run is an error in this and this case". 

It's a monolythic monster. It works, but if you have the time, you could benefit from re-writing it (using c++ alternatives). 

This will make your destructor trivial, and after this, your destructor should be removed (the code that is easiest to maintain is the one you don't have to write at all). 

The code is incomplete (you'd need a specialization of sync for const access and so on) but it should be enough to give you a picture. Advantages: 

Yes. You can use a solution based on passing a std::shared_ptr or std::unique_ptr (unique_ptr should be prefered if you are passing ownership, like in your example). Second edit: Alternately, you could try implementing this: 

Other stuff: Use instead of zero. Either make the class final and the destructor non-virtual, or leave the destructor virtual and remove the assignment operators. Having an assignment operator in a base class leads to getting your objects sliced. 

Edit: The correct solution (since we are all creative people, "correct" is actually debatable) would be to avoid call chains for constructing your objects completely: old code: 

In some contexts, it probably does (though I can't think of any). It does look (to me) like a case of the "I will write C in any language" syndrome. I would find this implementation cumbersome and obscure, especially since the equivalent canonical code is much simpler: 

The code is a bit bigger, and some syntactic sugar is missing (stuff that you added in your example, like chaining calls and multiple keys per entry) but the code is semantically the same. My point to adding this code: your class only makes sense if you use lots of switches (on strings) in your code, and usually in OOP, if you do have big switches in your code, you should extract them as a hierarchy of classes (or a table of functions) anyway. 

This API returns a , which is among the worst possible ways of returning data in C++ (you are removing type information from the result). In order for client code to know what is actually returned here, you have to look at the implementation (a big no-no), and the runtime configuration on the system (this is even worse). Consider returning a custom structure that holds the information (preferably as a string, or something that does it's own memory management). Stop using C-style casts. They introduce points that are inflexible to change and difficult to find (a nightmare for maintenance and extension of the functionality).