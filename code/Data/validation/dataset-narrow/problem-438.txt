This is because there's no tracking of which thread opened the gate. Not checking the thread has the potential to cause another issue (which you might not care about, because it's pretty common with spinlocks) whereby if you have a bug in your code, it is possible for a thread that doesn't own the lock to unlock it (anybody can call and it will unlock, even if they didn't call first). 

If it is only concerned by the clicks, then great, you only need to worry about clicking the mouse. If the program does care about the movement then you might want to think about using the function, which supports an additional parameter . The default speed is 20, with larger numbers being faster so increasing the number should either make the function return faster, or allow you to wait for less time before clicking. Depending on whether the movement is async, you may also find that you need to wait less time for shorter movements (i.e. the mouse will get from 8 to 7 faster than it will get from 8 to 1). Clicking the mouse After you click the mouse, you wait before doing the next thing. You may be able to make it so that you don't need to wait as long by using playing with and passing in different values for which is how long the mouse button is held down for. Alternately, depending on how your application works you may be able to detect that the mouse click has been recognised (because some pixels have changes from red to green for example). The library appears to have a few functions that might support this or would appear to be good starting points. You could then loop until the click has been recognised, rather than waiting. 

My initial impression is that this is a really bad way to have threads interacting. There's no real reason why either thread can't print out the next number. Assuming this is some kind of learning exercise and putting this issue to the side, I'd introduce a new mutex. At the moment, both of your threads share a single mutex which means that when one is done processing it unlocks the mutex which results in a thread being released. The thread released may be the second thread which is already waiting on the mutex, or it could be that the current thread manages to process the rest of the while loop and reacquire the lock. If you change it so that you have two mutexes, you can have the following pattern: 

You shouldn't be doing things in a loop that don't depend on things changing in the loop. , , and all depend on n, which is constant throughout your loop. Also, if you store your primes, you just have to loop through the primes until you get to sqrt(n), rather than checking every number. There are further tricks to speed up the algorithm, such as checking n only if n mod 60 is in [7,11,13,17,23,29,31,37,41,43,47,49,53,59]; that reduces the number of n to check by more than 3/4. Is tail recursion an option? How large is your stack size? You can break recursion into subrecursion. For instance, suppose you have a function that recursively finds the nth to n+100th primes. Then you can have a recursive function than, when asked to find k primes, calls itself on k-101, then appends the k-100 to kth primes. You can then add another layer, and have something that does 10 primes at a time. Do this in binary rather than base 10, and you'll need 14 layers to get 10001 primes. 

Generate an array of n percentages. Calculate the average percentage. Subtract the average from each element. Do a for-loop of i from 0 to n-1 and set 

If something is called "RiemannSum", then it should return a sum. If you want summation to be a separate method, a better term would be "partition"; you could do RiemannPartition.sum(), for instance. Several other variable names are bit unintuitive to me (e.g. rectangles, index). You can eliminate several lines by doing: 

One strategy: Do binary split of , and for each split, keep track of the smallest number of that is greater than or equal to the largest element of each branch and the largest number of smaller than the smallest element of the branch. Once those two numbers are adjacent, don't split that branch any more. So, taking your example . I'll split , with scores in brackets surrounding each branch in bold. At iteration 0, I have {[120]( 100 100 50 40 40 20 10 )[5]} That is, I haven't done any splits, so everything is in the same branch. The largest number of the branch is 100, and the smallest number of larger than that is 120, so 120 goes on the left of the branch. The smallest number of the branch is 10, and the largest number smaller than that is 5, so 5 goes on the right. In iteration 1, I have: {[120](100 100 50 40)[25]} {[50](40 20 10)[5]} iteration 2: {[120](100 100)[50]}{[50](50 40)[25]} {[50](40 20 10)[5]} Since there are no numbers in between 120 and 50, the first branch is done splitting. Since there are no numbers between 50 and 25, the second branch is also done. So the next iteration moves on to the third branch: {[120](100 100)[50]}{[50](50 40)[25]} {[50](40 20)[5]} {[25](10)[5]} Iteration 4: {[120](100 100)[50]}{[50](50 40)[25]} ]} {[50](40)[25]}{[25](20)[5]} {[25](10)[5]} At this point, Iâ€™ve done all the splits I can, and I can just read off the ranks; each rank of a number from is the count of distinct members from to the left of the first instance of it, plus one. 120 is all the way to the left, so its rank is 1. The first instance of 50 has one distinct element of to the left of it, so its score is 2. And so on. The dense ranking requirement means that you'll have to get rid of duplicate members, but other than that this algorithm should be logarithmic time, rather than linear time for your algorithm. 

Duplication There's a lot of duplication between your spells. You basically have two types of spells, those that change Visibility and those that change Size. If you created two base classes that allowed the target size/visiblity to be passed in, then your Normal/Small/Enlarge spells become simple wrappers that only have to pass the target size down to the base class. Spell Construction Consider passing the Goblin into the constructor for your spells (as a target parameter). If you throw an exception if this parameter is null, then you can assume that the goblin exists in your other methods which removes their null checks. Spell Stack Whilst the way you've modelled the code makes sense, I'm not entirely convinced by the non-additive nature of your spells. If I started off with a 'Small' goblin, I'd expect Englarge to make it 'Normal', then Enlarge again to make it 'Large'. 

Player.java A wrapper for the player. Notice that interactions through the console are isolated to two functions ( and ) so that the interface can be easily refactored to alternate sources/destinations (such as a socket interface). 

How likely are you to use it? What's going to have constructed the / chain that you're assigning into your list. If it's not needed get rid of it. If it is needed, then consider if you really want the to be shared between the list and it's caller. oldfirst / bug This is a very odd variable name at a class level. It sounds like something you might use as a temporary variable in a method, for example when removing/replacing the head of the list. It's usage is also rather odd. For example in you do: 

On the whole your code seems pretty concise and clean. I've just got a couple of side points. Scope creep This is a real problem in production code, where developers implement stuff that isn't really needed. Your specification you've posted says 'take an exact string and an exact filename'. You've allowed a regular expression to be passed. The original requirements could have been met by just using which would have made the code quite a bit smaller. You've used extra time and added extra complexity, is there a real benefit? The scope creep also means that I can't pass the basic string "\n" into your parser and have it find it as the '\n' is interpretted by the regex parser. So, with grep I can do: 

You don't really need a method. You can simply have a object with a method that randomly picks a card from the deck. Whenever you need a card, a card from the , and part of the method is removing the appropriate card from the . If you have eight players, you'll need to draw 21 cards. I suppose conceptually it's nice to "shuffle" the 21 cards you need before dealing any out, and to include the other 31 cards in the "shuffle", but I personally don't see much value in doing all that work just to imitate more closely how "real world" poker is implemented. You seem to be using for both the position and the value. You should distinguish between the two, e.g. versus . The line is really weird. Apparently you're initializing the pot with the blinds, but are you removing the blinds from anyone's chip stack? You should have a bet method, and "force" the two blind players to call that method. Also, having a method named "Shuffle" that does a bunch of stuff other than shuffling, such as initializing the pot, is bad naming. I think that betting order should be an attribute of the table rather than the players. There's no need for a player object to know what its betting order is; if a player wants that sort of information, you can just pass them the entire table configuration (that is, I can see a player asking "What's the betting order", but I can't see a player asking just "What's my betting order?"). The table should have a blind method that adjusts chip totals for bb and sb, and it should have a method that asks the current player to act. Both of those methods should know what the betting order is, and be telling players when it's their turn to act. If the player objects know who is sitting to their left and right, then you can just have the table ask for a player to act, and then ask for the next player to act, etc. Instead of doing , you can do , and then you don't have to do . Under the hood, this is more complicated, but conceptually it's simpler; the button just moves to the left. Other things such as the betting action can move similarly. Adding 2*cnt to a number and then taking the result mod cnt is a bit odd; should give x for every k. 

Casting Generally speaking, you don't want to put explicit casts into your code unless they are actually needed. They usually just add noise to the code / make it harder to change the implementation in the future. Since returns a void, you don't need to cast it for example. So, this: 

A few things stand out... Function declarations I'm not a huge fan of specify return type on previous line style: 

At first glance, the final closing brace belongs to the loop, not the statement. This is unnecessarily confusing. Don't be afraid of using an extra line Consider the following line or two: 

My gut instinct is to agree with @Olzhas Zhumabek, that you should be using a std::string for your . With it a lot of the issues go away and you've already deviated from the original spec by not using a . Looking at your code, your choice of has created a discrepancy in the interface for your class. You construct the object and set the value of name using , however you only return the name as a . This feels odd. Your copy constructors use the public interface to perform the copy semantics. Again, this feels odd. Part of the benefit of writing the copy constructor as a member of the class is that it can directly access the private class members of both sides of the assignment and avoid the overhead of the public interface. 

Hard coded paths Try to avoid putting hard coded paths into your source code. It means that if you want to change your source or destination paths you have to recompile your application. Unless you really want this level of commitment to the paths, then a better approach is either to take the paths as command line arguments, or to put them into the app.config file. For example Config: 

The workbook then has another worksheet for each tutor. The tutor worksheets are almost the same as the master sheet, however they have an additional column which is the total number of hours used by that tutor. 

Also note that if none of the words are "long", then the loop method will go into an infinite loop, while the other methods will return an error. 

Since each element can be put in p1 or p2, there are two options for each element, giving a total of 2n different options. Since you are avoiding the cases where p1 or p2 are empty, it's 2n-2, which is twice the Stirling Number of the Second Kind (you're double counting since the Sterling number is based on p1 and p2 being indistinguishable). Since Big O ignores adding or subtracting constants, it's simpler to just give the complexity in terms of 2n rather than putting it in term of Sterling Numbers. And as @Peter Taylor points out, you are looking only at the number of iterations, and ignoring the complexity within an iteration. You can avoid most of the double-counting by taking combinations up to n//2. Anything past that will be just a partition you've already gotten with p1 and p2 swapped. At i == n//2, you will be double-counting, so you can use @Peter Taylor's suggestion and set aside one element and then add it back in to a fixed partition. 

Your variable names should be more explicit. Most of them are a single character, and even the multicharacter names are rather opaque. , for instace, would be more clear if named something else, such as . You're using integers for values, but it's not really being used as an integer. Your code would be more readable if you assigned it strings describing what each state consists of, such as . You're using conditionals where a case statement would be more appropriate. Your last case sets to 2, but I don't see how you get to that unless is already 2. However, since you're progressing through each of the values of , the whole structure of the while loop is inappropriate. You have three things you want to do, and the second always happens after the first, and the third after the first and second. The natural things to do is: 

Terminal Size / Wall collision detection Collision detection didn't work as expected when I ran your program, currently you can run straight off the right side of the screen, turn around by going down and left and come back onto the screen. It turns out this is because although my terminal is only 80 characters, horizontal is set to 200, so it keeps going off the side. The terminal is capping the right hand printing, so the walls are printed correctly. Ideally you would either detect, or ask the user for their terminal size. You don't often see two breaks in the same case statement, maybe it should be: 

It's unclear where 15 and 10 come from. If 15 means something, it should be a named constant. If not, then remove the unnecessary clutter and just have: 

you declare a variable , which you use to try and connect to if fails. The variable you're declaring has the same name as an existing variable declared at a higher scope, however the one you're creating is scoped to within the block. This means that when you access the variable later in main to read from the socket: 

On a modern cpu, you can gain some benefit from parallel execution. Since the number of executions required is quite small, you need to avoid starting/ending threads however as this can have quite an overhead so you want to use threads from the thread pool. You also want to minimise contention between the threads, so you don't want them all updating the same Max variable. A basic strategy is to split the processing into a number of sections (where the number of sections is the number of CPUs). Each window, calculates the max for that window, then compares it with the max for the other windows. The calculation stage can then but opitimised using the various other techniques suggested. This results in code something like the following (I haven't really validated the upper bounds checking however it does result in the correct answer so I've assumed it is close enough).