Where to start? I would start by opening the file, reading it, and then blink out the individual bits of the bytes read to a pin. You might want to add timing, checking bits and other kinds of protocol details later, but start by blinking it. Also, if speed is a crucial requirement, you don't want to do this over one pin only. If you do, it won't matter if you use C, java or python - the limits won't be in the language. Get it working before you optimize. Python is probably your best choice and on the net there is a ton of tutorials on how to do it. Have a look at $URL$ 

Create a global (research ) shell variable or a file (for example in /var) that holds the number of times the script tried to restart wifi. Increment on every try. Add a check to see if it has reached a preset number. If it has, call . On a successful connection, reset the value of the variable (or file). Good luck! 

to output the end of, and ollow new writes to, a text file. You probably want to follow (but the location may vary, check $URL$ So, 

Your Pi won't start because the boot sequence is unable to mount your root file system. This might be due to a misconfiguration or possibly a corrupt SD-card. 

If you really want to make the computers listen for specific sounds, pick them out from ambient noise, and recognize them, you are probably in for quite a task. I would recommend to start looking at audacity and nyquist and go from there. Once you have done that, you could just add light beacons to the Pis and have them flash in unison on detection. The easiest way to do that would probably be to have one of them acting like a server, and the other ones as slaves. You could hook this up via a web server. 

This is a common automation problem with a range of solutions from the last century or so - essentially, what you are working with is the inverted pendulum. What you probably want to do to make this project a lot easier is to transform your axis so that you try to solve this problem instead: 

I don't think ext2 would be better than fat32 in this particular case - not in saving the same information in considerably smaller space. 

Yes, there are many ways to get a switch interacting with your pi. Have a look here, for example: $URL$ 

You will need peripheral hardware to turn the pi on and off, since it does not have a power button. The good news is that it is fairly simple to build one, and not very expensive. Have a look at: $URL$ 

Well, this is quite a hard question to answer in a way that will be acceptable to security buffs, but I'll go ahead and try anyway: As long as you don't have any port forwards and your router remains secure, I'd say you are pretty safe, however it seems that anyone connected to your net will be able to access and change the content of your share. Note that this is not limited to WiFi - anyone that can get physical access to a connection on your routers wired interfaces will also have access. Also, you seem to have no access control on the samba service itself. Have a look at this documentation on how to set up user and access control levels on your samba. 

Python 3 is not backward compatible. Code written in one version will have to be ported to the other. You can not expect that code developed in Python 2 to be runnable in Python 3, or the other way around. See to that your development environment and your production environment run the same version on Python, down to the last decimal. 

No, there is no such hardware for the raspberry pi. The Pi is simply too slow to handle that kind of speeds, and while it would be possible to offload the pi with a specific chip set, as you yourself point out, that would make the pi superfluous in the device and there would be no point in having it at all. 

This is due to the fact the 3g networks typically don't assign a single IP to every terminal device. Effectively, you are behind Orange´s "NAT". To be able to access it, you need some kind of VPN solution. 

The raspberry pi is a computer. Equipped with an operating system it can do whatever computers do, including what you are suggesting and an infinity of other tasks. 

Put this in your under the directive , and you should be fine. You edit your crontab with the command . Even better would be to run the script to copy the credentials every time you mount a USB. You can create a -rule for this. Check this question over at AskUbuntu for examples. 

This is almost impossible to answer as it depends on a lot of factors, but generally - yes, the pi and tornado will probably be able to have enough throughput for some of the resolutions. You can definitely import many libraries into the same program. Good luck with your project! 

With some reservations, the answer is probably "No". That is not to say that you can't make a cluster of raspberry pis (because you can), and not to say that you can't run minecraft on such a cluster (because you can), but rather that currently there is no implementation of a minecraft server that would actually benefit from such a setup. That is - the performance wouldn't increase. What minecraft needs is relatively few cores that run on very high speed and a lot of common memory. I run a minecraft server on hardware built for an htpc. Such a setup can probably be comparable in pricing to an 8 node raspberry pi-cluster, and work a lot better for this usecase. 

LASER! Beam the data down! It would be (kind of) easy to connect a laser pointer to the TX pin of your Pi, and then just feed the blinking into the RX pin of another Pi, on the ground. Keep watching the skies! 

If you want to start a service automatically you probably want to use the framework. In you will find a number of directories named 

No. It is certainly possible to create a cluster of several Pis. (Whether such a cluster could be considered some kind of super computer is a matter of semantics.) Such a cluster would need specialized software to operate. Have a look at Map-Reduce or Spark for example. Retropi and console emulators are typically not programmed in such a way that they run on cluster hardware. 

You can definelty control LEDS with the Pi - no need for an additional Arduino. Research GPIO tutorials for ideas about how to control LEDs, for example at the pi hut. 

Yes, you can compile java code to native for example using and run it on Raspberry Pi. But you can also run a complete java stack on the pi, no problem. 

I don't think they will allow outside access to your computer like that. A better option would probably be to have your pi fetch content from a remote site periodically. That way you could publish your videos somewhere, and have the pi automatically download the new content. This could be done with a small script similar to 

If it has to do with wifi, then kismet is your very bestest friend indeed. You will be able to see the devices, when they connect, what they connect to, regardless of whether it is your own device or your neighbour's or your neighbour's cat's uncle's wireless necklace. 

is a part of the Advanced Packaging Tool which is the Debian implementation of package handling. It is inherited to a lot of other Linux systems, including the well known Ubuntu, and the familiar Raspbian. APT handles repositories - that is, lists of from where software can be downloaded - and sorts out dependencies. APT front ends , that handles the actual package installation. The most common case for software installation on Linux is that the software you are requiring is already in a repository. The installation is as simple as 

First you need to understand that the solutions you have researched are not the same thing! is, as it says on top 

The key component in this equation is probably not any of the ones you are mentioning, but rather the power supply. Using the devices you are talking about is probably no problem, but might not work, depending on the devices, and the network adapter, you are using. A keyboard and a mouse usually uses about 100 mA each, but that may vary wildly depending on model. The easiest way, of course, is to try. If you get spurious reboots, then try using a network adapter that can provide more power. 

It doesn't seem like there is a prebuilt package for arm, at least not according to the packages site: $URL$ What could do is try to download an build the source package. If the dependencies are met, it should be as easy as 

Send 32 bytes at a time, in sequence. Have a look at the TLV format for an easy way to make a custom protocol. There are several python packages to help you set up an encoder and a parser, for example construct or Simple TLV Parser, but if you want to keep it simple, you can probably build your own in a few lines of code. 

Edit Oh! Before anything else, just to complete the answer - there is a problem in your assignment. will give you a with the actual value . What you want is the result of the command. You get that by , as pointed out by @joan in another answer. Original answer Well, bash doesn't handle floating point arithmetic on its own all that well. There are two ways to handle this - the easiest way is to change your to , thereby stripping the decimals, and get integer number. After that the (as mentioned in the comments above) will work. If you desperately need the decimals, you can keep the as it is (but have a look at the edit above), but you need to use an external program to do the calculation for you. If you change your if-clause to 

The USB standard dictates that all USB 1.x and 2.0 shall be able to deliver 500 mA, so you should be fine - as long as you input enough power into the pi, of course. The b+ uses 600 mA, so you power supply should be able to feed at least 500+600=1100 mA, and some for extra for good measure. But if you need a portable low power solution, maybe you want to have a look at the Model A+. 

I want to determine the MAC-address of my Wi-Fi interface on a Raspberry Pi Z W running Raspbian Lite. Is there a command that I can run to tell me this? Is there a device in the tree that will disclose it? 

Yes. You can connect them. I don't see why you would like to, though - the FX7400 has ethernet, and if you have a server grade machine somewhere in the network, it's probably better to let that machine do the job. Otherwise a pi could probably do it, but pis are not manufactured to be part of critical infrastructure. 

The 3.5 mm audio jack in the Pi is sound output, and not for input. If you need audio input, you need to acquire some kind of sound card. There are a lot to choose from, using GPIO, I2S or USB to communicate with the Pi. As for directional recording, as far as I can tell, the beam forming microphone is basically two omni-directional microphones next to each other. That is not dissimilar to a stereo microphone, and I expect you will find that one is in the left, and the other is in the right channel. $URL$ 

If you need to run a script on your machine as a part of a web transaction to that machine, the easiest way to achieve that is probably to set up a web server, and use a technique called CGI, which makes the web server execute a script (or a binary) and send the resulting output to the client, rather than serving the content of the script itself. Have a look at or for commonly used web servers that you can run on your pi. 

simulate this circuit – Schematic created using CircuitLab This will save you the trouble of operating high-voltage circuits as well. 

What you want can probably not be easily achieved from bash, as such. You probably want to operate on the driver. One idea would be to unload the input driver all together. You will have to identify it, using , and then remove it with . You can reinsert it with if needed. 

You need to set up port forwarding on your router. Then you can use your (router's) public IP to access your raspberry pi from outside. 

Other times, like in this case, you really need software that the manufacturer has not packaged, for some reason. Then you might choose to download a source package, that will contain build instructions, or, as in this case, a custom installer, that you can execute. All this being said, venturing out of the topic of the original question and on a more personal note, I, for one, would not trust security software that asks me to execute a binary for which I cannot see the source. I would rather use for example with or . 

(I haven't tried, and the file name might be different. You should find a deb package to install after you completed the first step, though.) 

Please do note, however, that you will probably need to configure the minecraft server to hold a limited world and turn down the visibility range slightly to allow the pi to keep up. 

What you are doing is adding a line at the end of the file . That is what the shell operator does. If you have run this several times, your will probably look strange. Open it in an editor hand have a look. You do not want duplicated, unnecessary or erroneous lines in this file! The reason this doesn't work as you expect is, as has been pointed out, that a space character is interpreted as the start of one argument and the beginning of the next. That means that rather than mounting to , this line tries to mount to (with the fstype ), which, of course, fails. There are several ways to tell the system that the space is a part of the name, rather than the end of an argument. This is referred to as "escaping" the space. One way is using single or double quotes, like so: 

Download the ready-to-go image from here $URL$ , flash it on a card, boot it up, and you should be ... ready-to go. 

What you need to do if you want to learn about USB on a low level is read up on USB drivers in LDD3 and carefully study in the Linux repository. You should also have a good idea about how the USB protocol is specified. USB in a Nutshell is a good place to start. You can use to see the specifics of the USB controller from the kernel's perspective. You can then modify the to handle that specific device. From there you will need to probe the endpoints of the device, and initially preferably map them to nodes in the -system. Once that is done, you can use a user land program to read and write to the endpoints, trying to figure out exactly what they do. From that information you can then write a HID driver that interfaces your USB device. 

There are several ways to try to fix this: 1) If the pins are bent out of position you can use a needle to carefully bend them back. 2) You can stack the card with something. Thin plastic cut from a plastic folder is probably better than paper. 3) If nothing else works, you have to replace the slot. If you suspect this is a result of tear because you insert and remove the SD-card a lot, I would suggest getting micro SD-cards and micro SD-card adapters. This would allow you to replace the (micro) SD-card without causing tear on your SD-card slot. 

Yes, it's normal. One electrode (the anode) will oxidise. That said, it shouldn't happen so quickly. I guess you have the sensor powered constantly. That means you always enable corrosion. What you can do it so make sure there is current running to the sensor only when you take a reading from it. This will pause corrosion in between the measurements, and make your sensors last longer. 

I definitely think this has to do with your PATH. An easy way to check this is to compare the output of with the output of . If the node.js directory is present in the first but not in the second, there is something going on with your PATH setup. The reason for this is that does not actually load the root profile. Rather, it tries to create a "safe" profile for one command only. If you cat the /etc/sudoers-file () you will see the "secure_path" being used in a sudo context. You can edit this - BUT ... This brings me to another question: Why on earth would you like to run node.js with root privileges? JavaScript is - arguably and due to many cool features - the most insecure language that is in wide spread use. It is generally very easy to inject hostile code and trick the JavaScript engine into running it. This is why we most often sandbox our JavaScript engines very carefully. So - I would basically do anything to avoid running node.js as root. And you probably should, too.