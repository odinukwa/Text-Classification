And finally, I think it's also worth briefly mentioning changes that do not appear to be a part of Java 9 and 10. From what I can tell, value generics (e.g. ), value types, and reified generics appears to be have been deferred to Java 10. These proposed changes to how Java's generics function, had they been included in Java 9, would have required some changes to a Java-based curriculum, but alas, not yet, it seems. I believe there were also some plans for adding new APIs for JSON manipulation, and money/currency stuff, but those also seem to have been deferred. It's unclear if these proposed changes will land by Java 11, but if so, that version of Java would be the one to keep an eye on. 

This isn't a particularly in-depth answer, but the course I'm currently TA-ing ultimately requires our students to build a regular expression engine (basically, a simplified grep clone). Basically, they need to: 

One idea is to take your students on a field trip to a "computer museum" of some sort, if your local area has one. Being able to physically look at and maybe even interact with machines can maybe help give your students a more "visceral" feel for how computing has advanced in general. (One of my professors actually did this and took us all to the Living Computer Museum in Seattle, and made us write a program of some kind on a retro computer of our choice. It took me a while to figure out how to even use one of the computers -- it certainly gave me a deeper appreciation for how dramatically HCI has advanced over just a few decades!) You could also perhaps contrast this by following this up with a field-trip to a local datacenter (if you have one). If you don't have a museums/datacenters like this in your area, you could maybe bring in props of some kind -- maybe bring in an old tape drive of some sort along with a USB and contrast how much data each of them can store. You could also perhaps try showing them clips of seminal tech demos. I personally like Steve Job's original iPhone demo (YouTube link warning) -- I stumbled across this recently, and it was so incredibly bizarre and surreal to me to watch people go crazy over features I take for granted. Engelbart's "Mother of all Demos" (also YouTube) might be another good one, though it always felt a bit dry to me, so maybe not. 

If it's the former (your students are capable but simply aren't motivated), then here are some thoughts: 

If you have control over how students learn to code, a broader (and probably more effective) strategies would be to teach students how to use your MyBlocks/functions first and foremost, almost before anything else. That is, teach them the absolute bare minimum functionality to make something happen, then teach them how to decompose a large problem into smaller subtasks, and have them create a MyBlock for each subtask. I would do this first, before teaching them things like control flow, variables, etc... Basically, make the idea of "refactoring" and "identifying subproblems" one of your first lessons. The hope is that if you make using functions/MyBlocks one of your very first lessons, they're less likely to pick up the bad habit of writing redundant code. 

Start by writing the code to do the user input/output stuff so I can get commands from the user. This code would likely be extremely minimal/something you'd write in a CS1 class. Next implement some basic shell navigation functionality like and directly within the shell. Now, my shell is a little more complicated: I need to remember things like where I'm located in the file system; I'd probably have to do some research on how you'd implement things like within C... Next, try I'd try and implement the ability to have my shell call other programs. Since I'm a beginner, I have no idea how to do this, so I'd pretty much immediately just google "C run another program". This will immediately bring up results that mention the "fork" and "exec" keywords. I might not know what those mean, but it gives me just enough context that I can form more specific google queries. ("C exec example", "C exec vs excv", etc...) Now, depending on how I previously wrote my shell, I might immediately be able to adapt these examples to my own code, or I might need to rewrite and rearrange things significantly. This is mildly painful, but such is the life of a beginner -- no biggie, I do what I need to. 

Beyond that, I suggest telling the students about the "growth mindset vs fixed mindset" thing, as ctrl-alt-delor expects. A somewhat more blunt tactic would be to modify each assignment (apart from the first one) and ask students to answer a question about their feedback -- something like "Summarize the feedback you were given on the last assignment. How did you apply what you learned while reading that feedback on this current assignment?". Basically, force them to at least think about their feedback, instead of avoiding it. 

I'm currently helping teach a unit about languages as a part of a discrete math course -- we're currently focusing on regular expressions, NFAs, DFAs, CFGs, grammars, and the like. One of the skills we'd like students to be able to acquire is the ability to translate English into equivalent regular expressions -- e.g. translate phrases like "match all strings containing an even number of the character 'a'" or "match all binary strings that do not contain the string '1001'". Some students seem to easily pick up the "knack" of performing these sorts of translations, but many more of them seem to struggle. Unfortunately, I'm not sure how to best help these students. Constructing regular expressions isn't usually something I find particularly difficult, so I've been finding it difficult to "get into the mindset" of the students who find writing regular expressions to be less obvious. I've spent some time introspecting and trying to pick apart what strategies I subconsciously tend to use when faced with a new problem, but that's mostly yielded a list of ad-hoc strategies rather then anything fundamental. 

Based on my past experience working on a FRC team, my main advice would be to be very cautious about pushing students to use more advanced abstractions, design patterns, and whatnot. The issue is that if you spend a lot of up-front effort designing interfaces and abstraction layers, you can end up painting yourself into a corner, especially if you're new to programming and don't have a good sense of how to anticipate these sorts of things. For example, take the forklift example you mentioned -- what happens if the students decide half-way through the design season that they don't want to use the forklift design after all, and want to create some sort of arm? Or what if they want to create some kind of kicker thing to try punt a ball of some sort? Or even with the forklift example -- what if the team switches from using some sort of conveyor-belt design (where the user can control the height of the lift) to some sort of pneumatic based system, where the height ends up being basically binary (low or high)? How do you design an interface that can accommodate both (without stuffing the interface full of different methods that are inconsistently implemented across different subclasses)? And for all of these, how do you map of these to the user interface, which again the team might want to wildly change over time? None of these issues are insurmountable of course -- you can work around it by having a clever and flexible set of abstractions, or by having a more solid design phase (and pruning down deviations from the initial plan). That said, no plan is perfect and the danger is that too-brittle and overly restrictive abstractions can potentially end up crippling the team down the line. This means you should be careful when pushing for more abstraction -- the danger is that if the abstractions you propose end up hampering the team down the line, they might end up resenting the idea of them and take away entirely the wrong lesson: abstractions are bad, and are not worth the trouble. 

I think placing some emphasis on style and conventions is important, yes -- learning how to follow style guides is a skill worth training and learning to be detail-oriented is an important meta-skill. That said, I think it's fine to introduce some leniency by allowing students to use whatever convention they want as long as they're consistent, especially for things like curly brace placement or tabs vs spaces. If the goal is to train students to acquire a sense of craftmanship, having them demonstrate they know how to be consistent is enough, I think. Some formatting rules do seem to be more universal though (across languages and style guides), such as adding spaces around binary operators. It's probably worth enforcing rules like those, to make sure students acquire correct "muscle memory". I think the answer to your question might also vary depending on age -- the older students are, the more we should expect from them. In particular, once students are at the undergrad level, they're basically adults and expecting them to be detail-oriented seems pretty reasonable to me, especially if they plan on doing CS as a career. After all, sloppiness in the small often tends to translate into sloppiness in the large, and churning out students who think it's ok to cut corners seems somewhat irresponsible to me. One middle ground between enforcing and ignoring convention would be to provide students with a linter (which they can perhaps tune with your permission?). If you make students responsible for turning in code that perfectly passes the linter as a binary pass/fail sort of thing, you'll make sure standards are maintained without putting too much pressure on the students. This also has the added benefit of being more representative of how development is actually done in industry. I would probably introduce these tools only after your students have had a chance to develop a sense of consistency and craftsmanship, though. 

A common problem I've noticed many beginners (especially self-taught ones) run into is figuring out how to transition from working through tutorials and exercises to working on full-fledged projects. There seems to be almost a "cliff" of sorts that many find challenging to scale for a variety of reasons (that are probably not worth enumerating here?). One way to make it over this "cliff" is to find a teacher that can help guide you through progressively more challenging projects. Of course, this isn't a path available to self-learners by definition. The next best alternative is probably to find a tutorial or online course that does something similar. Unfortunately, these resources either appear to be hard to find or simply inadequate (?), based on my (anecdotal) experiences answering beginner questions on another forum. Taking all this into mind: What concrete advice would you give to self-learners who are struggling to transition to working on larger projects? Edit: To answer @BlackJack's question: by "larger project", I mean a project that: 

Something I feel I should note is that I don't think unfamiliarity with syntax is likely to be the culprit. We're starting by studying specifically regular expressions (not regex) and have restricted ourselves to using a very minimal toolset: union, concatenation, the Kleene star, and epsilons -- so, no backreferences, no captures, nothing like that. Rather, it seems what students find most difficult is the inherent act of interpreting and translating an English sentence and formalizing it into some logical form. I've seen this same sort difficulty of manifest appear in other scenarios: for example, earlier this quarter, we asked students to translate English into propositional or predicate logic: I also found it difficult to teach students how to do this in any kind of systematic way. As another example, in other courses, I've observed many students find it challenging to translate English into SQL queries (and here I have some more sympathy, since I also find constructing certain kinds of SQL queries to be challenging). The best I've been able to do so far is just have students do a bunch of practice/walk through a bunch of examples, but that doesn't strike me as being a particularly efficient strategy (though I don't dispute that practice is essential). 

Bootcamps may be suitable for some, but not all: for example, professionals with an unrelated degree trying to transition to tech vs high school graduates trying to enter tech. The quality of individual bootcamps can vary wildly (but then again, I suspect, though cannot confirm, the quality of university CS degrees can also vary just as wildly). Bootcamps are incentivized to report skewed data. Even something as simple as "% of people who graduate with a job" can be complicated. (If the bootcamp hires you back as a TA, does that count? What if you get a job in a non-tech field? What if you get a job after a year of additional self-study?). 

Conduct periodic code reviews where you point out style issues like these. If you make code reviews a regular thing, the repetition should hopefully help students eventually start using functions independently. Since your students are in elementary school, this should obviously be a very lightweight and informal code review. Develop an automatic style checker for whatever language you're using to perform these sorts of style checks for them. (Hopefully, whatever language you're using is exportable into a text-based or otherwise structured format that actually does permit this sort of analysis.) Heavily emphasize that if the students are at any point copying-and-pasting, they're doing something wrong. Make it clear that copying-and-pasting is a sin. (This is assuming whatever language you're using is actually usable enough to make this a truth rather then a lie.) Give them a short style guide to follow; include a note about eliminating redundancy using functions/myblocks in the style guide. This will probably be more effective with older students. 

Process the user input to get the variable name and the value somehow? Store the variables in a map of some sort? 

If you're instead interested in giving students a solid foundation in Git, and preparing them for how Git is often used in industry, I think you should heavily emphasize the underlying model behind git (the DAG). The hope is by doing this, you can train your students to NOT try and memorize every single Git command. (Trying to do that is an exercise in futility: there are many Git commands, and many of them are overloaded and poorly named). Instead, try and train your students to think in terms of DAG manipulations: if you can manipulate a DAG in a particular way, you can certainly make Git do the same (though you might need to google a little to find the exact command). If you're going to do this, you should also probably cover rebasing. You can maybe introduce this as a sort of exercise (e.g. something like "we said Git was a DAG, so does that mean it's possible to arbitrarily rearrange nodes? Yes! Meet ..."). It also turns out many people in industry prefer rebasing over merging since it lets them maintain a cleaner git history, so it's useful to know how to do both. The other advantage of focusing on the DAG (besides setting up a solid foundation) is that it lets you connect Git back to what your students already know: data structures and algorithms. That gives them a nice "hook" to hang their new knowledge on.