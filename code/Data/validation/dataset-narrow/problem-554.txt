Once you've gotten your code into a you can just call property (which in C# is called with ) to get all values with a given key. So the can be entirely replaced by using the like this: 

However, it's not clear that you need to be creating the in the first place. You can just use Linq to generate your from scratch: 

The one thing that really stands out to me: you don't need to convert the boolean result of to a human-readable string, then test the string. Just test the result directly, then convert it to a human-readable string. 

For something this simple, I think using the is fine, however, if you need to use the list of acceptable integers more generally or avoid hard-coding the set in a single expression1, you can use something like this: 

Well there's not much code to review here, but for what's here, I'd say it looks okay. I would only make one suggestion. If all you're going to do in your controller action is return single string wrapped up in a JSON object, why not dispose of the JSON and just return the HTML as content? Ajax call: 

NOTE: as far as I can tell, there's nothing limiting (or ) to be the same in all grouped dramas; each drama could have a different . Here's an alternative that includes the teacher in the grouping: 

Can write functions that only accept instantiation of a node template. This is enabled by and traits in the library. 

I want to make factories that can chained together to create a pile of layers. One of the advantage of chained factories is that later factories can pass specifications to earlier factories. For example, if I want to make a tree on top of an array, I wouldn't know the correct size of the array until I know the size of the tree. In the code I posted for review, the bottom layer of any pile must be an (or any other class of memory layer in the actual library). can only be the lowest layer in a pile. Here is an example of chaining the factories. 

Overview The following is a type system of layers (, , , ) and nodes for a library. A version that prints colored text for debugging is on github. Thanks in advance for reviewing this. 

This is a random access iterator that stores an index and a reference to a container. It iterates over any container with indexing operation. It does not have copy assignment / move assignment operations. This is because I cannot re-assign the reference to a container to reference to another container. The iterator stores a reference instead of a pointer to the original container. If the iterator stores a pointer instead of reference to the container, will that affect performance? The inherits from the because I want implicit conversion from the non-const to const iterator even during template instantiation. The code and google tests are also at: $URL$ Thanks for reviewing this. Code: 

You can use or to exclude the empty string in the results. If you write your own function using 's, like this: 

You really need to use arrays for this. and are identical so I don't see any need for the condition. Use methods instead of , as they've been deprecated. Use prepared statements to guard against sql injection. 

If you want to reduce the lines of code (with a slight negative impact to performance if this function gets called a lot), you could do this: 

Any other exceptions it throws indicate a invalid parameter or bad program state. You probably don't want to just ignore these errors and move on as though nothing has happened. I recommend you just do this: 

How can I clean up the process for formatting the arguments string? It seems pretty ugly at the moment, and if I have to add any more parameters, it's just going to get uglier. Is there an easy way to convert a list of parameters to a string that's suitable for invoking another function? Note: Simply passing in the parameters as a single string (e.g. ) doesn't really solve my issue, it just moves it back one step. I'd like to create the string within itself. 

But this just looks ugly. Is there a more standard method for getting just in this situation? To clarify what's going on inside this method, this is part of a unit test for an XML serialization class. will load an XML file, wrap it in a little more XML to create an 'envelope', attempt to parse it, and return the result if it succeeds. The problem is that the 'envelope' that the XML serialization class expects the XML to specify the type name in a particular format. For example: 

It's a good idea to profile your code (which is easy if you use – instead of , just type , and run your program with the options ) to find out exactly where the bottle-necks are. See the GHC profiling guide for more information. If you do that, you'll find that a significant amount of your program's time is spent splitting up strings into words, and parsing them into s. Remember that a Haskell string is a linked list of characters, and thus not particularly efficient – I found that using the type from the package results in the revised program taking only 40% of the time of your version. (Contrary to the other comment here, the binary search you've implemented seems fairly efficient, that's not where the slow-down is.) Instead of from the standard Prelude, use the version of from ; instead of parsing a line of text using , I'd suggest something like the following: 

This may not be as concise as your code, but should be much easier to follow and to modify - and importantly, for your purposes, it runs in less than half the time. Other notes - the versions of will normally be faster than the boxed versions, if you can use them; if you're submitting code for review, then I'd think a few more comments in your code wouldn't go astray. I hope that helps. 

This is exactly how I would write it if I had to use C# (with the exception of the in-line if / else), but after I wrote it F#, it seems clumsy and a little messy. I suspect there is a much more elegant, idiomatic way of writing this in F#. Perhaps using a match expression? 

You can also use a binary search (since this data is sorted) to speed up the search. My PHP is a bit rusty, so some one else might be able to improve this further, but I think it would look like this: 

Use 's rather than fiddling with individual date parts. Use an array to store the edges between each Chinese year. Search through the array until you find a match then return the index of that element mod 12. (plus 1 since you want values ranging from 1 - 12). 

My PowerShell scripting skills are pretty poor, but I've managed to hobble together got this script: 

If you want to verify that either value is in the , may not be the best option. It will continue to test for collisions even after it finds a match. For two search strings you can just do: 

If you've setup a proper navigation property you could write your query a bit more cleanly, although I doubt this would run any faster, since this will still translate to an in SQL: 

I'm modelling two processes which have been put into a cyclic pipeline - the output of each feeds into the input of the other - so as to work out when they've deadlocked (i.e., neither can progress since they're each waiting on output from the other). I've used the conduit package for this, as I couldn't see an easy way to do it using pipes, and streaming doesn't really look suited to this sort of task. It looks like monad-coroutine would be another possibility for this, but I didn't investigate it further. Define the problem as follows: 

I think this problem is of interest because pre-emptive concurrency doesn't seem like a good way of solving it -- most concurrency libraries do their best to help you avoid deadlock, not model processes that have got into deadlock. (But perhaps I'm wrong, and this is easily modelled with a standard concurrency library - I'd be keen to hear.) Also it gave me a good reason to look at some of the streaming data packages (conduit, pipes and streaming), all of which I believe are modelled around the idea of processes that can "yield" data "downstream", or "await" it from "upstream", which is exactly what this problem requires. Here's my code: (NB: contains possible spoilers for the Advent of Code 2017, day 18 problem, Part 2 - but this is not relevant to my question, which is about modelling deadlock with coroutines.) 

Each node is a location within a layer. A may be a pointer or an index. A is a container. There are 4 types of node per and types: 

and both have move constructors. I try to avoid writing each factory from scratch with CRTP. The code is also at github. Thanks. Result: 

Is the design ok? How to make the api more convenient? The the google tests and the code are at $URL$ demo_complete_tree_traversal: 

I implement a complete tree as a layer for adding a hash, heap, and other things on top of it. The Complete_tree_node templates can be reused regardless of the number of layers added to the tree. This tree layer helps to hide the memory organization of the nodes from the algorithms. Currently, the uses an array to hold the content of the nodes. Constructing the tree is kind of tedious because the tree does not own the data. I want to offer the option of the tree owning or not owning the data later... Currently, the operations do not accept rvalue. So things like doesn't work. The template parameter is log2(). Currently c++11 can build this but I don't mind using c++14. The next step is to write: 

a heap layer with a template parameter for selecting key from the content A hash layer for keeping track of items inserted into the tree.