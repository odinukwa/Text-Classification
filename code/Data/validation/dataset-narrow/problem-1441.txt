You seem to be trying to implement the Painters Algorithm. I'm guessing you're trying to write a rasteriser from scratch as a learning exercise, as most modern 3D hardware uses what Bart has mentioned (the Z/Depth buffer). For the painters algorithm to work in all cases, you'd need to be prepared to subdivide the surfaces as they're rendered to solve possible scenarios (such as the overlapping polygon problem shown on the Wikipedia page). By rendering from furthest to closest you're also spending time rendering pixels which will possibly later be occluded by other polygons, which when you start putting textures and complex shaders on the polygons wastes precious cycles. This is the reason modern hardware would prefer you to render from front to back, using the depth buffer to determine if the pixel to be rendered is further away than the one on the screen (and can therefore be discarded). Even with most modern acceleration hardware you'll still need to sort and render from back to front any semi-transparent polygons, rendering this only once all the opaque polygons have been rendered. 

You're going to want to double/triple buffer any data necessary for rendering that gets altered in the update pass. That way you won't be rendering with something that's been partially changed. The reason you'll probably need to triple buffer is needing 1) the copy you're updating, 2) the last copy you updated fully, and 3) the copy that is currently being used for rendering that you don't want to change. The hardest part is probably working out the best way to organise your data for this. 

There are lots of factors to take into account, type of game, speed of connection, number of peers, how much data you want to send, if people have limited bandwidth allowances you don't want to over use, is this over a LAN or internet, etc. Lets say for example, you have a 64kbs (64 kilobits per second or 8 kilobytes per second) connection (which is slow by modern standards for average home internet but not necessarily slow for phones), with 8 players and you want to update as often as possible for a real-time game, you'll need to send to 7 people at most 9kbs each (64/7). Assuming your update packet size was 1kb (1024 bits or 128 bytes) for each update, you'd only want to send an update roughly 8 times per second, or put another way for a game running at 60fps, every 7 or so frames. You'll need to do your own calculations based on what your target bandwidth is, packet size, etc. There's nothing standard that will scale this for you, however it's fairly easy to keep track of when the last update was done and not send another for X frames or X milliseconds, etc. When calculating the size of your packets, you'll also need to take into account packet header sizes which will potentially vary by the platform you use and apply and a specific overhead to sending anything (which for UDP over IPv4 seems to be 20 bytes). UPDATED due to extra info (and switching TCP reference above for what it should have been, UDP): You'll want to be using UDP instead of TCP as the overall overhead of TCP is more than you want in a real-time game. You don't need/want the guaranteed delivery of packets as it'll require each packet to return a successfully delivered reply (plus by the time it's then re-sent the data is out of date anyway). For the internet you'll need to assume at least a certain level of packet loss and how you cope with this (you can even simulate this in your code by randomly not sending or not sending every Xth packet). You'd also using UDP need to take into account that packets can arrive in a different order to that being sent, so you'd also probably want to send some sort of number (be it time, or some incrementing value) to indicate that if you receive packet 200 first, then that's the current good state and then receiving packet 199 it should be ignored. You could also potentially do other network optimisations, such as sending a less frequent "big" update (say position, orientation, velocity, etc) with more information, then send more "smaller" partial updates (such as controller input, or delta's). Smaller packets allow more to be sent for the same bandwidth (again you need to take into account packet header overhead, you want to have a good ratio of actual data sent to header size). This mostly applies to peer-2-peer over the internet. If this is just for a local area network (unclear from the question), then it probably isn't a concern on how often you send the data unless the actual sending or receiving the data is somehow computationally expensive (not usually). You'd most likely want to send it as fast as you can in a LAN environment for responsiveness. 

No. Without official support they won't let you release it. The problem would be if they changed the way something worked (behind the scenes in their libraries) and you weren't going through official channels to access the Kinect, then it could break your Kinect support and it would make both of you look bad. Full blown (paid up development kit) game developers aren't allowed to access hardware by hacking around the official libraries for the same reasons. Hardware changes over time for cost-reduction and other reasons. Have you managed to find hacks to get it working with XNA for the 360? I thought most of them were PC specific and non-portable. I can't imagine it'll be that long before they release an official SDK, they've already said the PC is getting one very soon, hopefully XNA support will follow closely. 

PIX isn't going to work with non-desktop apps. The new way to debug these is the graphical debugger built into Visual Studio 2012. I'm also not sure PIX works properly on Win 8 for desktop apps either. 

You'll usually find the graphics card manufacturers provide decent tools for compression textures, such as Nvidia here. These seem to be supported on multiple platforms. For hardware accelerated rendering you'll not find any lossless formats supported that offer any compression. The most popular current formats supported for example by graphics cards under DirectX are DXT1/3/5 for images, DXTN for normal maps. I don't use OpenGL but I'd expect these to be supported even if called something slightly different. I've typically seen DXT textures zip to about half their original size, so it's possible just using zlib will get you the same end result (then decompress before uploading to the gfx hardware). 

I'd recommend a good clear separation of input and the rest of your game. I'd also recommend a layer that allows you to map different inputs onto different results (i.e. press key A maps to Left, S to Right). If you tightly couple the game with the input you won't easily be able to handle people remapping keys to suit their tastes, you also would have trouble adapting to maybe using a controller (i.e. 360 pad) instead of the keyboard later, or even being able to use something like Kinect to control input with enough abstraction. In a driving game for example, I would have something that parses the current input state from the device currently in use (i.e. keyboard, pad, wheel, etc) and use the values I retrieve to build up a structure more suitable to my specific need, i.e. turn the values I parse into a steering value, an accelerator pedal, a brake pedal, etc. This structure could then be passed around to systems without having to worry about what input method had generated these values or whether they used analogue sticks, d-pad or keyboard. 

and then look for the move that will lead to the maximum score N turns in the future. You may also want to avoid moves that lead to any score below X (say, the cost of dying) N turns into the future. Once you've scored all the possible moves, added bonuses for how well it might turn out in the future and deducted for how poorly it might turn out in the future, then you just sort the array and take the best move. Let us know how it turns out! 

Minecraft is pretty quick, even on my 2-core. Java does not seem to be a limiting factor, here, although there is a bit of server lag. Local games seem to do better, so I'm going to assume some inefficiencies, there. As to your question, Notch (Minecraft author) has blogged at some length about the technology. In particular, the world is stored in "chunks" (you sometimes see these, especially when one is missing as the world hasn't filled in, yet.), so the first optimization is to decide if a chunk can be seen or not. Within a chunk, as you have guessed, the app has to decide if a block can be seen or not, based on whether or not is is obscured by other blocks. Note, too, that there are block FACES, which can be assumed not-seen, by virtue of either being obscured (i.e., another block covers the face) or by which direction the camera is pointing (if the camera faces North, you can't see the North face of ANY blocks!) Common techniques would also include not keeping separate block objects but, rather, a "chunk" of block types, with a single prototype block for each one, along with some minimal set of data to describe how this block may be custom. For example, there aren't any custom granite blocks (that I know), but water has data to tell how deep it is along each side-face, from which one can calculate its direction of flow. Your question isn't clear if you're looking to optimize render speed, data size or what. Clarification there would be helpful. 

Also, you need to be passionate, but without too much ego. That is, you have to care enough to want to make things better, but ok with frequent shooting-down of your ideas for improvement, and not let it drive you bonkers. Back to your original question: what makes being software-QA (games or otherwise) an easy entry-level position is that the skill-set is something that anyone can develop, and doesn't require a lot of schooling. As above, tenacity, attention to detail and reliability are more important than many technical skills. It's also a good growth position. It's easy for a motivated person to go from "entry level QA" to "lead tester" in just a couple of years, and promotion opportunities are many. While it CAN lead to a development position, typically QA and developer skill sets are very different. It's also a lot of hard, frustrating work. It is NOT "playing games all day long"! Some folks love it, some folks leave to do something more enjoyable, like flipping burgers. The difference lies with the individual more than with the job. Btw, if you want to beef up your resume for an entry-level game-tester position, volunteer to do some beta-testing for games online, and learn how to write a decent bug report. (You can Google this. A good report is not "paladins suck" or "the space orb needs nerfed." Find out what it means to write a good bug report and then go out and write some. When you go to a job interview, take along 2-3 of your best to show, and explain that you have no professional training, but that this is what you were able to learn on your own. That's valuable skills, right there. Good luck! 

There are myriad other details but those were the two that hung me up the most. Once I broke that simple barrier, everything else flowed together very quickly. 

Tandem's idea of hill-climbing algorithm is good. Another is: some variation on A* to see how far you can go to see how you can get the highest score over the next N turns, where N is tuned to give the desire result. The scoring values you give can be thought of as "cost to move" -- you're basically on the right track, but you'll have to tweak the values until you get the result you want. In general (not PacMan specific) terms, you need to allocate appropriate values for 

The part that wasn't clicking for me -- and, as I suspected, was very very simple -- was that it's just a matter of implementing the doPost() (or doGet(), but I use POST) routine, and write back to the responder. There were also some bits that I didn't follow quite correctly the first time about setting-up the responder class-names and URLs, in the web.xml file (in the war folder.) Once I got that (web.xml) set up correctly, then the doPost() routine was simply something along the lines of: 

In addition to Iain's and Ben's very good answers, an important concept is the differentiation between "what is legal" and "what is enforceable." Just because no one has a particular interest in enforcing their Intellectual Property rights doesn't mean they don't own them and couldn't suddenly change their mind about where to put their legal focus. It's safest (and most ethical) to make an honest attempt to seek permission from the rightful owner. This may involve cost to you, as to hire someone to find the rightful owner. Of course, you can choose to "live life on the edge" and just go for it, but the legal/right thing to do is to put in the effort. Btw, I have some experience with asking for permission to clone what you might think of as abandonware, and the rightful owner telling me "no problem, we're totally done with that IP, now", so don't think it can't happen. 

This is subjective, of course, but I think that consistency is much more important to game play than speed. Basically, players will put up with a slower frame-rate if the game is consistent, fun to play and not jarring. However, even if the game totally rocks, if it gives people headaches to look at because it bursts, and/or they can't control things, they will become annoyed & stop playing. So... Focus on consistent FPS throughout design & development. Focus on faster (but still consistent) FPS when the game is nearly done, and you have time to improve performance without worrying about bug fixes, etc. One way to get better performance is to use callbacks/delegates/interrupts (depending on your language/platform) rather than polling. 

I've been in development for 30+ years, and was QA for about 15 of that (also QA manager, and director of engineering, hiring both QA and developers.) If you can get a QA job -- if you have tenacity, attention to detail, and can reliably show up for work -- then, yes, it's a fairly "easy" way to get a foot in the door. However, do NOT fall for the romantic notion that game-tester means you "play games all day long." In fact, many people who become game-testers find that they come to really hate playing games in their spare time, as it "feels too much like work." In game testing, you may be asked to do things like