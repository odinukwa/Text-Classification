Instead of that I decided to use a more dynamic, queue-based allocation technique. The 0th element of the array is reserved for a virtual index-pointer to the next available memory slot. Next to any stack will result in data insertion to the pointed virtual index. The next elements of the array are reserved for a virtual index-pointer per stack. These are basically saying where the certain stack's head is. The rest () array indices are used as a virtual space. The very first index of this section will have a "physical" value of , and a "virtual" value of . The next virtual index () has a physical value of , and so forth. This is because a single virtual index consists of two physical indices. The first value is dedicated to a value hold by the stack entry; and the second value is a virtual index-pointer to the next element in the stack. The illustration below should help understand what I am trying to say (in case the description is too vague): 

I may be very wrong, but maybe, just maybe, materializing the into a and dealing with current and possible next character via indices is a faster solution. I really doubt that using the string's or is slow, but what if it is? With char array we know for sure that element-by-index access costs \$O(1)\$. Same is true with reach-line-end check -- \$O(1)\$ if implemented based on a known current index and total string length. If your real code works with a , I don't see how would be a bad thing to do if it improves the performance. However, if the code is indeed a template for working with real -producing streams/IEnumerables, it may lead to memory consumption problems. Not an answer, really The reason, I think this "optimization" will not work, is because we're talking about and . I don't believe we can possibly beat the implementation(s) of these fundamental pieces of .NET platform. P.S. As mentioned, the code looks pretty good to me. No obvious flaws are seen. But this is a highly algorithmic code in nature so to speak. Only an excessive set of unit- and integration tests will help getting more confidence with correctness of the solution. I'll just assume that the tests are in place and all green. Hopefully, other reviewers will be able to provide more valuable feedback. 

Design decisions and improvements (as in "better approach(es) performance- and memory-wise"). Code readability. JavaScript (ES6) language idioms. Whatever you find important to say that does not fall into three categories mentioned above. 

False alarm! No callback hell here. While this code can certainly be refactored a bit, I fail to see callback hell anywhere around. Callback hell is normally a term applied to the code that is executed asynchronously and with multiple nested callback functions. The nested structure is what causes a few issues: 

As you can see, as long as you know the , you control the sequence of randoms. And if you know both the and , you can easily get the specific value of random for this combination. In other words, your Game should pick a new on every new map it's trying to generate. The value of will let you "teleport" anywhere within this particular map. Update 4 - To Address Concerns About Randomness Here's the exact code I used to generate some consistent but random number sequence. The resulting sequence can be downloaded from here. 

Guess, I must start with a disclaimer again -- after multiple rereadings, still unsure what exactly the code tries to achieve. The big confusion (of mine) There's one thing I really don't like about , namely the ad hoc-ish mapping to collection entries by index. The consumer of the class will have to know that implementation detail, right? Don't have a C# compiler in front of me at the moment so I could play with things. Is there a way to keep and the as close together as possible (meaning, in the same class)? Not sure if it is achievable. On naming the lambda parameters As a minor thing, I'd note that is a bit confusing. Bet, you know we can write . Readability I know that fluent syntax is very well known, I haven't really seen that working with a collection (non-scalar) object, though. In other words, while you're not inventing anything new with this idiom, it's still a bit unintuitive to me. Please disregard this comment if you find it a subjective thing. :) P.S. Good question, just like many others that you post on CR! 

On TypeScript , , and are pretty bad names because they don't describe the entities they hold. I recommend changing them. At the bare minimum, specify the type of the input parameter in your arrow function to make the code more readable: or better . 

Since the context of the question is not really known, I hesitate to go beyond this explanation and recommend a particular one. In my practice have always been "handier", more refactorable, and easier to deal with. I do pick them as defaults today and rarely go to classes. This, however, is mostly true to DTO-alike classes ("dummy" classes with little to no behavior whatsoever). I find it helpful to separate the data transfer entities from the data processing entities, but it (again) could be due to the client-server-comm saturated nature of my applications. Use your own judgement! :) 

Here's a single-pass example. Very similar to @janos' code (which has a good complexity analysis). The only difference is in how various cases with are treated. 

Caching Pattern I commonly see the following pattern for "caching" observables in various code bases: 

A related question on StackOverflow might be helpful (just don't focus on RxJs part of the answer there). Your code does actively use arrow functions, but it is not equivalent to callback hell. The number one reason is because everything in is executed synchronously. Refactoring Nitpicking 

Specify types explicitly whenever it's possible (including for methods and for instead of ). Use instead of -- it will help detecting unintended assignments. Try not to move things around when it's not necessary. E.g. the following section is pushing one array's items into another. 

Step 1: method extractions At the very minimum, you can always extract the reusable(repeated) part of the code into an independent method and give it a proper self-explanatory name. This will not necessarily reduce the number of lines of resulting code, however, it will isolate (encapsulate) the specific logic in a single place which is a good achievement on its own 

Know your tool/language In typeScript you can initialize class' properties inline (this is the same as setting the values in constructor). You can also omit the type of the variable it is inferred. Similarly, if your constructor does not do any work, it can be got rid of. 

I really hate comments in code big time, but this is the case I totally agree that your confusion is an indicator of code readability issue. Comments would help (at cost of maintenance burden). Long lines are not a big problem on large monitors, but it is indeed possible to soften the issue at least by using proper line return positions. I don't like unnecessary and as well as and ... Thanks for pointing out the style issues.