Suppose $L$ is an $NP$-Complete language which requires $O(2^{n})$ time to solve. Then let $K$ be $$K=\{1^nx\ |\ \|x\|=n \text{ and }x\in L\}$$ Then $K$ is solved as follows: a linear-time algorithm checks whether an input string has an even number of characters of which the first $n$ are $1^n$. If not, it rejects; otherwise it solves $x\overset{?}{\in}L$. If $y\in_R \{0,1\}^{2n}$ is drawn uniformly at random, the expected time to solve $y\overset{?}{\in}K$ is $$\frac{1}{2^{2n}}\big(2^n\cdot 2^n+(2^{2n}-2^n)O(n)\big) = 1+(1-\frac{1}{2^n})O(n)\in O(n).$$ $K$ is $NP$-Complete. A reduction from $L$ is: $$x\in \{0,1\}^n \mapsto 1^nx$$ 

Suppose $NP=PP$. Then a simple argument shows that $PH^{PP}=NP$. Can we go one step further and get $PP^{PP}=NP$? The simple argument is Theorem If $NP=PP$ then $PH^{PP}=NP$. Proof $PP$ is closed under complement (due to Gill), so $NP=coNP=PH$. Take any level of $PH^{PP}$: then $\Sigma_i^{P^{PP}}=\Sigma_i^{P^{NP}}=\Sigma_{i+1}^{P}=NP$. $\square$ One plausible-looking way to get to the desired consequence is by observing that in this world, the interactive proof protocol for the $\textsf{Permanent}$ has been derandomized and de-Merlinized to the point where one message to Arthur has perfect completeness and soundness (as $NP=P^{\#P}$ under the hypothesis). If you can exploit this fact and compute the Permanent in some class that's low for $PP$, such as $UP$ or $BQP$ or $SPP$, we're done. That would give us $NP=PP\implies PP=UP$ (for example), which would immediately give $PP^{PP}=PP^{UP}=PP=NP$. (This came up in my thesis, where I investigate the hypothesis $QMA=PP$, and it also came up when trying to fix Scott Aaronson's broken theorem $PP\subset BQP_{/qpoly}\implies CH=PP=QMA$, Theorem 5 in Oracles are Subtle but not Malicious). 

I was quite surprised as well to not find this hierarchy in the literature, so I wrote my graduate thesis about it. It will be available online soon, at which point I will update this answer with a link to it. I was able to prove some interesting theorems about it. Theorem For every $i$, $\Sigma_i^{\mathsf{BQP}}\subseteq C_i^\mathsf{P}$, where $C_i^\mathsf{P}$ is the $i$-th level of the counting hierarchy. So the whole hierarchy is contained in the counting hierarchy. Proof Trivially from $QMA\subseteq PP$. $\square$ Theorem If $\Delta_i^{BQP}=\Sigma_i^{BQP}$ then $BQPH=\Delta_i^{BQP}$. Proof Excercise for the reader. Theorem If $QMA=PP$ then $PH\subseteq QMA$ and indeed $PH^{PP}=QMA$. The first part of this theorem was originally by Vyalyi [4], but his proof is six pages of algebra, whereas new ideas that originated from thinking about your hierarchy allow me to get there in just a few lines: Proof I prove a new theorem: $QMA\cap coQMA=P^{QMA\cap coQMA}$. This gives us $QMA=P^{QMA}=P^{PP}\supseteq PH$ by Toda. $\square$ For the new part, $PH^{PP}=QMA$, you will have to read my thesis. There's no obvious analogue of Toda's theorem. The reason is that the critical ingredient $QMA\subseteq BPP^{\oplus P}$ seems hard in the quantum case, whereas classically $NP\subseteq BPP^{\oplus P}$ follows trivially from Valiant-Vazirani, because here we don't have a way to "count" solutions. Even if you take $QCMA$ instead of $QMA$, there's the inconvenience that a QCMA protocol can behave arbitrarily on bad certificates to yes-instances. To see what I mean, start with [1]. There's also no obvious analogue of a Karp-Lipton collapse, or Kannan-type circuit lower bounds. Recall that in the classical case, we have Theorem [3] For every $k\in\mathbb{N}$, there is a language in $\Sigma_4^{P}$ that requires circuits of size $\Omega(n^k)$. The reason there's no(t yet) a theorem replacing every $P$ in this theorem with $BQP$ is that a critical ingredient in his proof is that he is able to (non-deterministically) guess a circuit and then evaluate that circuit, i.e. compute the circuit's output on an input. Sure, we can guess a (description of a) quantum circuit, but we can only say that we evaluate it if it is a bounded-error circuit, and verifying this is a $\# P$-Hard problem. Scott Aaronson and Andy Drucker prove something along the lines of a "quantum PH", going only to the second level: Theorem [2] If $NP\subset BQP_{/qpoly}$ then $\Pi_2^P\subseteq QMA^{PromiseQMA}$. When I asked Scott Aaronson, he said that people had been thinking about this hierarchy for 15+ years, but nobody had published it because nobody had proved anything non-trivial about it. Here's to hoping you or I change that. Bonus Theorem! If $QMA=coQMA$ then $PH\subseteq QMA$. Just for you, because you made it all the way to the end of a long answer. [1] Aharonov, Dorit, et al. "The pursuit for uniqueness: Extending Valiant-Vazirani theorem to the probabilistic and quantum settings." arXiv preprint arXiv:0810.4840 (2008). [2] Aaronson, Scott, and Andrew Drucker. "A full characterization of quantum advice." Proceedings of the forty-second ACM symposium on Theory of computing. ACM, 2010. [3] Kannan, Ravi. "Circuit-size lower bounds and non-reducibility to sparse sets." Information and Control 55.1-3 (1982): 40-56. [4] Vyalyi, Mikhail N. "Qma= pp implies that pp contains ph." In ECCCTR: Electronic Colloquium on Computational Complexity, technical reports. 2003. 

The central insight is that you can use two $2$-variable clauses to make sure two variables have the same value. Let me abbreviate $(x \vee \neg y) \wedge (y \vee \neg x)$ with $x=y$. This allows the following reduction from 3SAT. Given a 3SAT formula, copy the clauses to your reduction one by one. If you encounter a clause with a variable $x$ you've already seen twice, write the clause with a new variable $y$ instead of $x$ and add two $2$-variable clauses for $x=y$. Call the resulting formula $\phi$. Formula $\phi$ satisfies requirements 1) and 2). Next, employ the same technique to ensure requirement 3). Walk through each pair of $3$-variable clauses of $\phi$ and for each pair which shares two variables $x$ and $y$, keep $x$ in one clause and in the other clause, change $x$ to $z$, and add $x=z$. An example: $(x\vee y\vee h) \wedge (\neg x \vee \neg y \vee h) \mapsto (x\vee y\vee h) \wedge (\neg x \vee \neg z \vee h) \wedge (y=z)$ The resulting formula has as many $3$-variable clauses as the original and two $2$-variable clauses for each third or later repetition of a variable and then some more to satisfy requirement 3). Because the $2$-variable clauses ensure that $x=y$ so that your substitutions work, the resulting formula is satisfiable exactly when the original 3SAT formula was satisfiable. Its length is at most quadratic in the number of clauses of the original formula, so your problem is NP-Complete. EDIT: I notice I interpreted your question to mean, a variable cannot appear in more than two $3$-variable clauses. The way it is formulated now, requirements 2) and 3) are equivalent. I hope you're not mad. 

Virginia Vassilevska Williams lectured at a bootcamp (link to outline) at the Simons Institute, and presents what may be your memory in the introductory video. The whole workshop is worthwhile; the outline and links to videos of all talks can be found here. She explains (starting at 42:30 in the video) that if there is a $O\left(n^{2-\varepsilon}\right)$ algorithm for some $\varepsilon>0$ for the Orthogonal Vectors problem, then the Strong Exponential Time Hypothesis (SETH) is false. This would not immediately imply $P=NP$, but it would show an $O\left(2^{n-\epsilon}\right)$ algorithm for every $k$-SAT, which would be better than what we have right now; right now we have algorithms which solve $k$-SAT in $2^{n-O\left(\frac{1}{k}\right)}$, so these algorithms tend to $2^{n}$ for large $k$. The proof is originally by Ryan Williams, and is quite elegant; I do recommend the lecture. 

Let $L$ be a language and $f\colon {\Sigma^\star}\times\Sigma^\star\to\Sigma^\star$ a function on two parameters with the property that for all $x$ and $y$, $f$ returns an element of $L$ if and only if both $x$ and $y$ are elements of $L$: $$f(x,y)\in L \iff x\in L\wedge y\in L .$$ Question Do such functions have a name in the literature? Following are some amusing observations. These functions, which I will call "conjunctive reductions", can be constructed for the complete problems of a variety of complexity classes. For example, for $L=SAT$, take the function $f(\psi, \phi)=\psi\wedge\phi$. Analogously, we may consider "disjunctive reductions", so that $g(\psi,\phi)=\psi\vee\phi$ is a disjunctive reduction over $SAT$. These two reductions work fine over quantified boolean formulas too, so they also work for all levels of the polynomial hierarchy and for PSPACE. It is easy to construct both conjunctive and disjunctive reductions for the L and NL-Complete languages DSTCON and USTCON: Given two graphs, $G, H$ and two pairs of vertices, $(u,v), (x,y)$, construct a new graph by taking the disjoint union $G\cup H$, add two nodes $s,t$ and add edges $(s,u),(v,x),(y,t)$. A disjunctive reduction puts these two graphs in parallel, rather than in series. A conjunctive reduction exists for Graph Isomorphism, but no disjunctive reduction obviously exists. Conversely, a disjunctive reduction exists for the Nontrivial Graph Automorphism problem, but I could not find a conjunctive reduction. This surprised me, because I thought these problems were on some level the same, and then I had learned something new about graph isomorphism! As an obvious last step, one may consider "conjugate reductions", functions such that $f(x)\in L \iff x \not\in L$. Finding such a reduction for Graph Isomorphism would show that it is in coNP. I could find neither a conjunctive, nor a disjunctive, nor a conjugate reduction for the decision version of Factoring. 

Because if you define Zero-error time as running in strictly $O(T(n))$, then you would just get deterministic $O(T(n))$-time. (Why? Because then every choice of random bits suffices, so just pick the string $0^{T(n)}$ and simulate the machine to get the right answer). In particular, if you define $ZPP$ as zero-error with running time strictly bounded by a polynomial you just get your good old class $ZPP=P$. Simply put, if you have randomness but zero error, then you have to allow for some leeway in computation time, or you won't get an interesting computational class. By contrast, you are free to define $RP$ as operating in expected polynomial time instead of strictly bounded time, but it won't change anything; you just get the normal class $RP$ (Why? Excercise!) Hence $ZPP$ is to $RP$ a bit like $P$ is to $NP$ because if you take $P$ and $NP$ and say 

Yes, the counting hierarchy collapses in this case: Suppose that $P^{\#P}\subseteq BPP$. We know that $P^{\#P}=P^{PP}$, so $P^{PP}\subseteq BPP$. Consider the second level of the counting hierarchy, $C_2^P=PP^{PP}$. By hypothesis, we have $$C_2^P=PP^{PP}\subseteq PP^{P^{PP}}\subseteq PP^{BPP}\subseteq PP\subseteq P^{PP}\subseteq BPP $$ So the counting hierarchy collapses to $BPP$. As for your second question, I don't know any implications that would follow from a weaker collapse of the counting hierarchy, i.e. $CH=PP$ or something weaker. That question has been asked before, here, without answers. This question asks whether $PH\subseteq PP$; but nothing more would necessarily follow if $CH$ collapses, even under that hypothesis. According to this answer, it is an open problem whether $PH^{\#P}$ collapses (note that $PH^{\#P}$ does not trivially collapse as a result of Toda's theorem). There are at present, according to the Zoology active inclusion diagram, no oracles relative to which the counting hierarchy collapses to any level other than $CH=P^{\#P}$; that is, it is an open problem to find an oracle relative to which $P^{\#P}\subsetneq CH$ or indeed $P^{\#P}\subsetneq PSPACE$. Hence there are no oracles, therefore, supporting any argument relating non-trivial collapses of the counting hierarchy to the polynomial hierarchy.