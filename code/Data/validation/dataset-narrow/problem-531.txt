Parts of this answer were written before Martin York posted his answer. Thus, there may be some points which overlap. If you find any of those points appealing, please give the credit to Martin York as he was faster than me. 

While this is not a thorough code review, here are some things you could improve or should pay attention to: 

which is much clearer. Declaring Variables Assuming that you are using a reasonably modern version of c (e.g. , , ...), you do not need to declare all your variables up front. Instead, declare them when you actually use them the first time. This will add readability to your code, because the reader doesn't have to juggle all those variables in his head that are not going to be used until tenths of lines later. Check The Return Value Of Every time you call , you make sure that the call actually succeeded, which is the right thing to do. However, you do not do the same with calls to , which can also fail if, for example, no more memory is available. 

Use or include guards, not both. They serve the same purpose. If you really care about being standard conforming, stick with the include guards. In most other cases, is also fine. Do not write out default constructors if they don't do anything special, or anything at all. The compiler is nice enough to generate them automatically for you when your don't define any other constructors, which you currently don't. is a big class, in terms of object size. One reason for this is that all those s you define there are part of every object you create and are carried around everywhere your object goes, which is totally unnecessary since those are all constants. You would likely want to make those at the very least, or, since they are private and inaccessible anyway, even remove them from the class and put them solely into the implementation file as constants. The other reason is that you carry an around when you don't need to. In fact, you treat almost like a local variable: In every method you open the underlying file anew, just to close it before returning. Well, if you do that already, then you don't need to have it as a member variable because there is nothing to preserve here. Just create a new every time, which, as an added benefit, will also allow you to get rid of those ugly and calls and rely on RAII instead. Your longest line is currently 422 characters long. That is way, way too much. There is no safe and steady rule to what people consider appropriate line lengths, but most programmers agree that lines longer than 100 and a few characters are too long (I personally am a disciple of the traditional 80 columns doctrine). Overly long lines are usually really awkward to work with (just look at the code boxes in your question!), can mess up your terminal, and are generally bothersome when performing actions such as looking at code diffs or merging commits. Pay attention to correctness. should be (assuming that you also implement the hint about I gave in point 3). should be , or even . Looking at point 3 and point 5, you can do away with as a class altogether. You don't need to preserve any state, so your class is effectively empty. Putting and as standalone functions would do the job just fine. If you would still like to keep this "these functions belong together"-relation, you could put them in their own namespace. I don't know whether you care about this or not, but your code is doing no error checking whatsoever. In my opinion, you should at least verify that the file you are reading from or writing to is open and otherwise O.K. Turn the order of your header includes around. Always include headers from the project you are working on first, then all other headers, including those part of the standard library. This serves the purpose of header verification: If any of your headers are missing an include, your compiler will tell you. If you happen to include any of those missing headers before, however, the code will compile just fine, hiding a bug. 

You are performing some super tricky logic involving string manipulation, list slicing and split. I realised that the whole thing does the same thing as . Comparison of and You are handling the three different cases here. Funny thing is that you have a case where you do nothing () and one where you do something which looks like nothing to me (). At the end of the day, I have the feeling that this could be written : . Hard coded strings You have in multiple places. If you ever want to change this, this will be pretty akward. You could store this in a variable on its own. Even better, you could make this a parameter with a default value. You have the benefit of making things easier for you as a developer of the function but also as a user of the function because it is easier to change its behavior if needed. At this point, the code looks like: 

Couldn't send this answer yesterday because the site was down for some reason. First thing you can fix is to add a guard before calling . This is the usual way to do things in Python so that you can import you files without running the code corresponding to : 

is a bug. This should read (and if you had done more testing, your compiler likely should have told you). You are missing an include () for . Depending on how you intend to use these classes, you should add a virtual destructor to . The reason is that, if you do fancy polymorphism and try to delete an instance of through a pointer to , you get undefined behavior. If you don't care about the possible polymorphism, you should be fine as-is. I share your worry about implicit conversions. I would consider making your constructors . Keep your formatting consistent. Although your formatting is almost always the same, there is one place where you diverge from it, namely in the first two constructors of . Why do you have a space between and ? (I suppose it's just some oversight of yours). Why is the default value to two of the constructors of for the parameter , but the last constructor has instead? This is very likely to cause confusion. 

This, on one hand, serves the purposes of checking whether each header file actually contains all required includes (say, for example, your header actually used something from ; with your current include order, your compiler would not complain because you include in before , thus hiding the missing include), on the other hand helps readers of you source code to verify includes quickly. Quite frankly, I don't see the reason you do this here. Why not just use ? Anyhow, if you really want to have this (and also have a good reason to), I would expect a similar for here because of consistency. Alternatively, one could argue that you should be taking an and a as template parameters, especially since the s and thus the seed types of random number generators in the standard library are different for different generators (for example, uses whereas uses ). Instead of , you should write to prevent subtle bugs when changing the type of The name is not very clear. Although the abbreviation "rng" is quite common, what "bp" means will not be clear to most people on first sight. Since your header is named , I would expect your class to have the same name. currently takes a as argument by value, but you only ever output it to , so you should take it by const reference instead. Don't write where would suffice. For example, when writing to , the former implies a call to and an additional indirection while the latter just passes the value directly. is not really a fitting name for the second parameter you pass to . I was confused the first time I glossed over that function because, for me at least, almost exclusively stands for . I would have grasped that parameter's meaning much more quickly if you had actually named it or anything along that line. 

Now, let's try to improve . Useless variable and seem redundant. Simplify logic You generate a list of results sorted by score, take the score of the first element, get the list of results with that score and eventually get the first of that list. You could get this directly at first step. This: 

Also please note that may not be the best name as I may lead to confusion with factorial often being called . 

In , the class should be responsible for updating its own score. You could define an method taking the same parameter as the one (and calling it). Also, shouldn't be responsible for the conversion to ? I find it a bit awkward to have the and the base their logic on completely different fields. In a : as a general rule, you do not iterate that way over object in Python. The pythonic way to write 

Warning for other reviewers : input and input are different depending on the version of Python you are using. This is about Python 3. 

You can avoid a few cache lookups. Indeed, at the moment, you consider all pairs (a, b) with a != b and add a whenever you find one. You could limit yourself to pairs (a, b) with a < b and add a+b when you find it. Also, by doing so, you know for sure that the value you are looking for will be in the cache. 

Do not try to do too much on one line. Constructs such as are difficult to read, difficult to parse and prone to errors. Instead, let each control statement have its own block, and do not abuse the comma operator to do completely unrelated things. For example, the line I mentioned should rather be something like 

This answer is by far not comprehensive, but I suggest you go and rework your code, then come back for another review. I am not going to sugarcoat it for you: Your code is horrible by C++ standards. You freely mix C legacy functions with code bearing only the slightest resemblance with what is called modern C++. There is a middle ground between C and C++ which is called "C with classes" by most people. If you want to write code that's closer to C, you could consider sticking with that. Otherwise, I strongly recommend you to pick up a good book and learn how to write reasonably good C++ first. 

which features a simpler for-loop body in exchange for some code duplication (which could be reduced by a -function if desired). Gain some, lose some. I personally prefer the latter version, but ultimately this is just a personal preference. You should refactor and . Currently, both methods have 44 lines (counting empty lines), of which 37 are the same. This makes my DRY alarm bell go wild. Although the situation is somewhat difficult, the most concise way to join these methods into one generic implementation would be to either use a macro to determine whether you want to move in clockwise (i.e. have all relevant lines be of the form ) or counter-clockwise (i.e. have all relevant lines be of the form ) direction. There are also other alternatives: For example, you could pass the nodes through a callback instead to determine which direction the rotation should move in, or you could join the two functions into one by adding an additional parameter which tells the direction and just have an on it. 

Why reinvent the wheel and not build upon the Traversable, ArrayAccess and Serializable SPL interfaces, or more realistically upon one of their concrete children? On similar requirements I would have possibly build my upon an ArrayObject. 

The code is equivalent, and will work (?) if you replace it in your script. Hope it clarifies things a bit. The overall quality of the code is bad, there are some hints of an amateur developer there, and you shouldn't really worry that you didn't grasp what the code does, since you are unfamiliar with the language. It's an incomplete and mostly poorly written piece of code, good luck with it ;) 

This way a function to get cabin information is available to all your controllers, you don't have to rewrite it every time you need it. Don't repeat yourself. If there's any HTML / CSS or any other presentation logic in your Controller, and of course any persistent data logic, you are doing it wrong (in MVC terms). But MVC for small sites may be an overkill. It's a correct approach conceptually, but you will have to decide for yourself if it's the right one for your application. But if you decide it is, you should follow it as is. A very easy approach to separate presentation from logic would be to use a template engine. There are quite a few of them out there, and there isn't one that's better than the others. Using one is more important than which one. And of course it wouldn't hurt if you didn't try to reinvent the wheel and started using an MVC framework. Or if that feels too much, a micro framework. There's is an often quoted article by Rasmus Lerdorf that some people perceive as advocating against template engines and frameworks. It's not, the only point of the article is that you don't have to use them. In the article there's a very nice and tidy approach on how to get an MVC kind of structure out of the box, without the added complexity of any third library. If you really don't want to use any third library, you should copy Rasmus' style. 

As part of a project where I will be rewriting the most common GNU coreutils for practice purposes, I wrote a simple command line option parser in C. The parser works by categorizing entries into either flag or argument by comparing them to a list of possible flags specified by the user and grouping them together in pairs where applicable. Currently, only the standard encoding is supported (i.e. ASCII in most moderncases, no UTF-8 or other extended charsets). Nearly all of the work is done in a function named . The Files: options.h 

Yes, no, maybe. Some people do it one way, some the other. Personally, I prefer splitting declarations and definitions up so that I have an overview of what my class offers at the top. Some people argue, however, that this method tends to be very verbose (and it can be, especially with multi-layer templates), so either way is fine. Yes, there is at least one memory leak in . This is evident by the fact that you're allocating memory there, but not freeing the old memory. After the method returns, the internal pointer points to the newly allocated array while the old one is left abandoned and unreachable in the depths of the heap. To correct this, just the old array before you assign . Probably, but I don't want to go into those here as 

Another more simple solution Your solution involves both recursion and mutations of data. This can make things very hard to understand. A more simple idea could be to say that from the rank, it is easy to know which element will be the first of the permatation. Indeed, if your list has elements, you know that there are permations of length and so the permutation will have for its first element the -th elements. You can repeat the same thinking for a smaller list consistent of the remaining elements with the remaining part of the rank. This can be written: 

Using tuple unpacking As already said, you could use to call only once. At this stage, the code looks like: 

Making things simpler Declaring the variable is not needed. Similarly, the variable does not need to be defined before the loop and cleared at the end of each iteration : just define it as empty at each iteration. 

Your code looks good and is properly tested but you can easily make it better. Also, your trick about sums of numbers is a really nice touch. Separation of concerns and reusable functions You should try to make your code as easy as possible to re-use. For instance, having a is cool but if you had defined a function yielding divisors then you'd just have to call .