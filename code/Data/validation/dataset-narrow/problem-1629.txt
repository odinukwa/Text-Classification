Motion detection works by seeing changes in pixels. You have to provide a stable background that contrasts strongly with the subject. Cockroaches are dark, so your detection will improve with a white background. Constant illumination is also good. High contrast helps detection. Also, the illumination has to be compatible with the camera. If you have an IR camera, you can illuminate with IR. iF you have a normal camera, continuous visible illumination works but may prevent cockroaches from entering the field of view. The subject has to consume a significant portion of the field of view. A cockroach from 6ft away won't be noticed. A cockroach at 12 inches will change more pixels and trigger capture. Lastly, your fake cockroach test must be preceded by a long period of non-activity where nothing happens in the field of view. 

Given the lack of answers at this stage, my hypothesis is that your MicroSD card has shot itself in the head and is now a zombie. Think WestWorld and try again with a new MicroSD, perhaps not 149 times. 

The problem lies in a lack of diagnosis tools. Relays require current and voltage. Arduino relays switch on 5V. Raspberry Pi relays switch on 3V. Use a multimeter to measure current and voltage at the TRG input. Compare your successful measurements with the code-driven measurements. Even if your circuit is nominally producing the right voltage, it could be requiring more current than your setup can supply. For example, if your Raspberry Pi is powered by a USB cable at 500mA, that may not enough to trigger all that circuitry. The fix in that case would be to use a powered USB hub or dedicated power supply for the Pi. If the blue relays are not switching, then the fix is to replace them with a Raspberry Pi relay such as AdaFruit FeatherWing non-latching relay or Pimoroni Automation Hat. In general, Arduino relays don't work well with Raspberry Pi. When my code doesn't work, I double check with a multimeter. 

This guide here provides very clear instructions on how to generate numbers with the RNG. In terms of the tests you have proposed I have not found any source which gives the information you are after. I would imagine it is possible to write some code that would perform such tests, or there may be code out there you can use as a starting point. Although, the link earlier in my answer suggests the RNG is cytopgraphic-grade. Surely that should certify it? 

A popular IDE is Geany which is fairly small and lightweight. Its supports Python as well as C, Java, PHP and HTML. It only requires the GTK2 runtime libraries to be installed. You can install it from the terminal by running: 

You are certainly not the first person to have asked about using a cooling fan with the Pi. I can understand why people think they need to actively cool their Pi. From a desktop PC user's perspective the idea of running a CPU without any cooling seems bonkers. I have extensively used various models of Pi over the past couple of years and not once I have been concerned about the Pi overheating. Firstly, the SoC which is the main chip on the board, where things like the CPU are located has a thermal limit of 85°C. This means if the Pi approaches this temperature it reduces the performance and the temperature decreases. Having used a Pi 3 in applications such as a media center, not even watching a film at 1080p could get the CPU temperature anywhere near that. Also a cooling fan is rather redundant anyway unless you plan to use heat sinks. Heat sinks allow the thermal energy to be stored up over a large surface area. This makes dissipating the heat energy far more effective than just blowing some air on the SoC. I've had a look at the case you are referring to and I'm struggling to imagine fitting even a tiny cooling fan in it. Yes you could solder it to the GPIO pads on the underside of the Pi, do I recommend it, well... It's one of those were if you have to ask it might not be a good idea. You do risk bricking your Pi in the process and I imagine you are going to void any warranties in the process. I'm also not sure if the GPIO is going to be to handle both the requirements of the case and the fan simultaneously. I suggest if you are concerned about temperatures to keep an eye on them, if they are not going anywhere near 85°C then the cooling fan is really superfluous. 

It explains that whilst the Managed mode just allows for connection to single configured WiFi network, the Roaming mode allows for connection to multiple WiFi networks with potentially different network configurations which may be controlled by adding the special option which is then matched against corresponding entries in the network config file - specified in the file. e.g: 

So the "uni" network will use DHCP whilst the "home_static" network will use the static IP address 192.168.0.20. Though one doesn't have to use the option and the device will just use the defaults (see the doc file). 

With the latest versions of OpenWRT the default queue is now the fq_codel which has been designed to alleviate the problems of "Bufferbloat". 

As mentioned on the Pi NoIR specifications webpage it is only missing an InfraRed filter. So you can just buy a separate "IR-cut filter" (search on eBay or elsewhere) and use the Pi NoIR in daylight with such a filter as people have shown (e.g. here). There are also IR filter switches so one can switch the IR filter in for daytime use and out at night night time so it can see Infra Red (e.g. here and here). There's even commercial offerings (e.g. from modmypi) that provide this all built into one module. 

To get the WiFi working on a Pi Zero W only requires minimal config for Raspbian Stretch. The only file you need to modify is and this file needs to contain your WiFi network's SSID and password - which you add after the initial lines (the first 3 lines) that are already there so the file should look like something like this ( might be different for you): 

looking at the product pictures for the touchscreen it needs to be plugged into the display port on the Pi with a ribbon cable as shown. You then need to connect the appropriate GPIO cables. Next enter these commands into the LXTerminal: 

It installs a GUI interface among other things which allows you to control the Bluetooth module. The software is located under menu, preferences then Bluetooth adapter. If you still can't get it to work I suggest returning it and looking through the list of compatible Bluetooth adapters. 

To enable the server to handle files greater than 2MB a couple of tweaks need to be made. Go to and open the file . Change the value of and to something like . Which changes the maximum file size to 2GB. As an extra you can install APC PHP accelerator which might make ownCloud more responsive for larger installations. To do this run: 

For future reference if you are not using a NOOBs install: Open a terminal window and run the following command: 

Modify the file by running . Change to in the first line, so it reads Modify the file by running . change to in the first line and add to the end of that line. The line should read Create the directory by running in the terminal. (Note the in front of .) Run in the terminal to update the index files. Run to start the upgrade process. This will take a couple of hours. Whenever prompted to update a file during this process, choose the option to accept the new file; if you don't want to be bothered with these prompts, then call with the option using . 

OpenWRT/LEDE is now supported on most of the Raspberry Pis. It has a range of features and is designed around deployment to embedded systems. For example it uses the Linux OverlayFS in conjunction with a read-only root filesystem image to provide for robust operation in the face of Flash memory corruption and arbitrary power cycling. Whilst a number of features may also be achieved using a conventional Linux distribution on a Pi OpenWRT does provide a packaged reliable solution ready to go with a web interface. For general info in QoS on Linux see LARTC and for OpenWRT. To control queuing on Linux you'll need to use the command. E.g to show detailed info and stats on the current queue configuration for the eth0 interface: 

FYI the Raspberry Pi 3B+ does support 5GHz - you can see the available Frequencies using this command: 

One can also find a full explanation of the two modes of operation (Managed and Roaming) for wpa_supplicant in it's locally installed documentation file - which can be viewed (an [older?] online version is here): 

Whilst you can't directly monitor the power consumption you can obtain information about the operating voltage of the: (default), , , and (see here for more details). 

You don't need the file at all - The default setup in Raspbian Stretch does not contain an interfaces file. So just delete/move/edit the /etc/network/interfaces file if you have created one. This just works as the wpa_supplicant service will just start up automatically if it finds its config file () and connect the WiFi interface () to the network. The default DHCP client dhcpcd attaches to all interfaces so it will then obtain an address. If you want to assign static IP addresses or do other fancier network config you may then need to create an file or modify the file. And if you want the device to be accessible via ssh then you can create a file in the directory (remembering that if you're doing this to the micro SDcard on another machine - the boot dir is mounted on the first partition e.g. /dev/sdb1, and root would be on /dev/sdb2): 

When implementing projects that affect the public, be very careful about protecting privacy. For example, the problem statement requires "photo sent back to her phone", which implies that she divulge her phone number to your project. Ick. Stalker cam. But there's another way that might help you interact with the public. A less invasive way of providing "you are here" feedback would be to use the Pi to take a picture and upload that to a website that they can view on their phone. You can show your website right next to the camera and print the URL for all to see. This protects the privacy of their phone while engaging them to interact with your camera. 

Powering the Raspberry Pi can be challenging for high current draws: 1) use a powered USB hub (but do you really need all those USB ports?) 2) use a wall wart that provides the current you need (but why are these so expensive and hard to find in the current you need?) 3) use a DC-DC buck converter to convert a higher voltage (e.g., 12V) to 5.2V and feed that in thru GPIO 5V/GND. (lots of these cheap on Amazon). I've done all three and settled on #3 because it lets you do things like hook your Pi up to a car battery and solar. 

MOSFETs trigger voltage is 2V-5V. GPIO voltage is 3.3V. You could call your design a bug or a feature. It's actually a very cool way to mess with your friends. 

Using something like this it would be possible to split the 1 HDMI port on the Pi into 2. An alternative is to use this board from Gert, which adds a second HDMI port using the GPIO pins. However this is going to just duplicate them, to get the screens to extend is going to be much more difficult. As a side note, the more you split the signal the more desegregated it is going to get. So this is something to consider Also be aware of the potential stress you could be putting on your Pi through connecting lots of displays to it. 

You can check out a non-exhaustive list on the Pi's Wiki Page here. As stated above this list does not include every single Wi-Fi adapter that will work with the Pi. But, all of the adapters on the list should work with the Pi. other notable features of the list is showing whether a particular adapter works with certain operating systems and if the adapter has an AP or ad hoc mode for example. Even better at the bottom of the page it lists all of the adapaters which have been reported to not work with the Pi. So if you are struggling to get an adapter working, you can see if it features on that list. 

The easiest thing is to image the OS onto a SD card. Then using MiniTool Partition Wizard you can very easily change the size of partitions on the SD card. There is also an option in raspi-config that will set the OS to use the whole of the SD card, if that's what your after 

Steppers are typically driven by stepper driver boards such as the TMC2208. Microcontrollers such as Arduino or Raspberry Pi send pulses to the stepper driver boards to turn the stepper motor. I assume you have already acquired a motor hat or such. For smoothness, it is ideal to have well behaved acceleration curves for the pulse train sent to a robotic arm so that it doesn't spaz itself to death. However, for peristaltic pumps, you would not need to worry about such curves since you can spread the motion out over time to reduce jerkiness. In fact, lowering the frequency of pulses will give you better torque (stepper torque disappears with speed). Therefore, all you would need is to send the computed number of pulses in a steady slow stream, where "slow" is a compromise between what works and your patience. If there is a need to send a pulse train instead of a single pulse for each 1.8 degrees of motion, reconfigure your stepper board for microstepping (e.g., 256 microsteps). Then send K*256 pulses for each K*1.8 degrees of motion (provided 256 is your microstep factor). 

This is a great question because the actual relay state may differ from its nominal state. Feedback is critical, since actuators are physical objects that die over time. It is well worth the effort to add a way to sense the actual actuator state. For example, if the relay engages a pump, add a vibration sensor or sound sensor to determine if "everything is working as expected." Such a sensor will detect pump failure as well as relay failure. For robust system design, add a sensor for each actuator. Open loop systems (i.e., blind actuators) do work but are maddening when they fail (e.g., "We lost the entire crop because we thought the relay was on"). Simple actuators (e.g. light switch) can be exceptions because the operator can usually deduce their non-operation and repair as necessary.