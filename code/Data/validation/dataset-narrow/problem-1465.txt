If you make it useful to them, they'll appreciate it more and use it more. I wrote a few blog posts over the years with examples including: 

In addition to Racket, check out drjava for Java and drpython for Python. For Python you can also check out Thonny. All have a repl section and a code section. Write your definitions in the code section and interact in the repl section. Emacs can also be configured this way for a whole host of languages. 

I wrote a series of posts on how I use raw GitHub with my classes: Part 1 - Introducing your students to GitHub by using it as a method for distributing code to your class. Part 2 - Having students submit homework and small assignments using GitHub - this has them adding content to GitHub and sets the stage to teach them about "playing well with others." Part 3 - Taking the kids from working on solo projects to collaborating with classmates and leveraging things like version history Part 4 - Talks about some of the pedagogical benefits I've discovered while working with Git and GitHub with my classes. 

Other answers have already talked about the expressive power of a programming language over a markup language. I want to add the following as to help the kids understand the limitations of a markup language. They all know Google Docs or Word or some other word processor, I tell them that these are basically the same as HTML. If you have bold in a document, somewhere internally, there's a marker to start and stop the bold. When you type C-b it inserts that invisible marker and then C-b again turns it off. I also show them this by loading a simple web page and then showing its source (and sometimes editing it in the developer tools). Most kids know that a word document is not a program and showing the analogy this way helps make the connection. 

I like all the suggestions about visuals but it can sometimes be very hard to really connect an old storage device and a new one since the data stored is hidden in bits. It's easy to show that punchards used to be used and required and lend themselves to a nice visual. Punchards are 1 line of code per card. The Linux Kernel is 15,000,000 lines long. A ream of paper has 500 sheets in it with a sheet being thicker than a punchcard. That means the Linux kernel would be a stack of 30,000 reams of paper. You can grab some reams of paper from the copy room and start stacking. Maybe not the Linux kernel but other examples -- the kids final projects. Contrast that with the fact that these programs take no space and no time to load and run now. I'm thinking that there's probably something that can be shown with emulators - spin up tons of old computer emulators on a modern PC or something like that. 

Students latch on to the familiar which is usually what they're introduced to first. So... teach objects first and unless you work hard at it, the kids will tend to use an OOP hammer on every problem regardlessof appropriateness. Teach procedural / language constructs first and the kids will tend to write HUGE main functions and static methods if left to their own devices (assuming Java). The truth is that you can do it either way. When I've done objects first, start with a simple object - maybe a "greeter" that returns as string that says hello: 

Take everything with a grain of salt - if they like you they'll tend to be kind in their evaluations. It's also really easy to have anonymous surveys that yield ridiculously positive results (see the "analytics" used by just about any after school, drop in, or summer CS program for examples - using questions like "are you more or less likely to take another CS course"). Whenever I do an anonymous eval I do a few things: 

I would take Cort Ammon's suggestion a step further. Cover the ideas behind testing - I show both TDD and what I actually do which is constantly test my code as I develop. Then give a two part project. Part 1 - the students implement some library of functions/objects etc. Part 2 - each kid builds something using another kids library. Kids are graded on how well and well documented their code is for the next person. This encourages thorough testing as well as well written clear code. 

I don't know the answer to this but I do think there are a number of things to consider. First, understand that education research - not CS specific - has an abysmal reputation. As far as I can tell, it's rarely reproduced or replicated while frequently being presented as the magic bullet and being as strong as having proven a math theorem. Most of the best teachers I know hold Ed research in very low regards. Some of them have told me things like "I tried what the experts and researchers said and it doesn't work for my students nearly as well as when I ______ so I just do my thing." So, I don't think research is the answer. CS Ed research will eventually catch up to Ed research in general and I doubt, overall, it will be any better. In terms of policy - just as in other ed, the connected and anointed will have the real say. Does it matter? Probably not. Do your thing. Find your network. Share what you do. I've created courses, worked with younger teachers, blog, and hopefully inspired and taught hundreds (thousands?) of kids. I haven't advanced CS Education as a whole but I've done a whole lot of good in my little corner of the world. As Pete Seeger would often say quotinng Rene Dubos - "Think global, act local." 

I personally don't like BlueJ because while it's really nice for showing object relations the tool doesn't travel with them as they go beyond APCS-A and as I'm not a big OOP guy, I think it might push kids into thinking that every problem should be looked at an OO nail even more than APCS-A does regularly. Another advantage about using the command line and less specific tools is that you can teach the kids more of what's really going on rather than having the IDE abstract it. 

I've hated the term flipped classroom since I first heard it. It was as if those young kid teachers invented a new way of teaching that us old folks could never have done. We had flipped classrooms back in the day - it was called homework. When the history teacher said "watch the debate" - flipped classroom. Reach Act IV of the play? - flipped classroom. Reach Chapter 5 and try to do exercises 1-3? - flipped classroom. So, you'll have similar issues with the MOOC but your homework are the videos and related content. Some thoughts: 

Start with a super simple IDE like Dr.Java Possibly transition them to an editor which will serve them well no matter what language they develop in. If you're going to use an IDE look at something reasonably lightweight like the JetBrains free stuff. 

Then you can add an instance variable, constructor, setters etc. to build up the tools. You can then add language constructs in your classes. 

Personally, I'm a believer in a project based capstone and a group one at that. The project should involve going from generating (and pitching) an idea through design, development and ultimately delivery and should require integrating multiple tools. Since many kids would want to use such a course as preparation for internships and jobs, I'd say it's more appropriate to take in the junior rather than senior year. That's ok though since you're done with most if not all core major requirements by then and are taking electives. I know taking a capstone prior to the senior year sounds wrong to some but it should show mastery of many if not all of the core concepts in a typical CS major and fill a big hole in a students development. 

Not strictly block based, but I like Codesters as a nice midway point. It has a DnD interface but the blocks you drop become Python code. 

Cost can be a HUGE burden on a student or school with textbook prices being absolutely ridiculous. I think one has to consider how the student will actually be using the book(s). How many times does a textbook go unopened for an entire semester or only brought out due to a required reading. Do you actually use a textbook lock step with the instruction, is it a reference to be used by the student as needed or is it an alternate source that might present the material in a manner that differs from the instructor so as to provide another option if the student is having trouble? At the end of the day, I try to use either freely available books or resources. Does a kid really need an algorithms book or would a combination of web sites with descriptions, pseudocode and animations be preferable? I personally like print books but find myself going less and less to them and more and more to finding my own resources via web search. I don't expect my students to possess the same level of search-fu but given how my students work, I think the free online resource is a much better course to take for my situation. Of course other situations can merit other approaches. 

If your kids can do web development - particularly programatic web development (say using something like flask, ruby on rails etc.) then an easy entry point is with history or social studies or even English - instead of having the kid do a 10 page paper on blah blah blah, have them make a web presence on blah blah blah. This can be a richer more interesting and in fact interactive experience rather than a paper and it's easier to share with the world. If the web site is programatically generated, the student can also do analytics, stats, etc as part of the project. 

I think it's important that over time, students develop an understanding of how their choices as well as langauge (and library) implementation choices can affect run time. I think this basic understanding is much more important than memorizing a bunch of run times. I take my students through some problems that lead to them "discovering" hidden complexities. I'm linking to two blog posts I wrote about the subject: Who won the election - quadratic to linear time and Hidden Complexity 

Figure out a way to make it anonymous but to also make sure everyone submits one. Once I wrote a system that they could audit that collected responses and emails then scrambled the answers and sent it to me with a list of who responded separately another time I had the students send the results to a trusted third party. Ask the kids for the good and the bad. I tell them that even the worst teacher does some good and even the best does some things wrong. I tell them that it's also nice to see some positive and if I only asked and got the negative it would be just to depressing :-) The bad is important so I know what to change but the good is also important so I know what to keep. I tell the kids that saying something is bad is ok. Better is why it's bad but even better is a suggestion as to how to change it. If possible you want to follow up with the kids a semester or year later (if not longer). The perspective of time can really change opinions.