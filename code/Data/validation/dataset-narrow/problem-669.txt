This is pretty slick. You might want to add definitions and exports for and for convenience. The parentheses around in the local definition of for the instance are unnecessary. You could also implement or replace with . Why pattern match when you've got a handy higher order function? Definitely add a comment to explain , it took me a moment to realize what it's doing (it's certainly very clever!). Cleaning up is a very interesting problem. The easiest portion is realizing that the back diagonals can be found by the same exact process as the forward diagonals if you just transform your matrix with . The next key step is realizing that if we can generate the full length (as opposed to k-length) diagonals, we can use again. 

Associate words with the line number they first appear on. Remove words from one group using entries from another. 

This isn't mergesort! is a different sorting algorithm entirely, so you end up only performing one merge step before kicking it over to (I believe) selection sort. First let's address the easy stylistic issues so we have a good base to work from. The primary issue is that the argument passed to is a tuple, which is unnecessary, uncurried, and not very Haskell-y. I'll also drop the extra apostrophes where there isn't an actual naming conflict with the Prelude. We use as-patterns to avoid reconstructing patterns we just deconstructed. And let's just toss and , they're not part of the solution! 

Now we need , which we could also search for. But this is of course list concatenation. There's one more trick you might not find by searching though, so here is when it comes in handy to have read through the documentation for . handles mapping and list concatenation in one go. 

I'd also be sure to strap a comment to the top with the pseudo-code or algorithm you're trying to implement. It aids understanding and error recognition far easier. 

This is still doing more work than it needs though! Once you've made the first recursive call, the tail passed to will always already be sorted, and doesn't need to be resorted with each recursive step. One way to handle this would be to pull the main functionality of into an inner function named something like and change the body of to just be . Now the list is only sorted once. I think it makes more sense though to separate the two functions entirely. There is in fact no requirement that the list being grouped is sorted, so let's relax that constraint. 

Sorry to say this is not good practice. Exactly why is a bit more technical of an explanation than I like to give off the cuff, Google for "Haskell typeclass interface" and you'll find a bunch of threads comparing and contrasting and recommending you use an ADT. Here's one from Reddit with a game programming example that I think is particularly practical. In your case, I imagine you intend to provide different configuration methods (XML, command line flags, &c) which would also be instances of . You've already realized that you want to work with some abstract thing elsewhere in your program and not a , because whatever is using a configuration value doesn't care where that value came from. The next logical step is that by making a class, you actually are still passing a around everywhere, you're just relying on callers to never look more closely at it than as a generic instance. You've got implementation leaking all over the place. Instead, making a datatype. 

By using higher order functions to handle the iterative and recursive aspects of the problem, we end up with a solution that almost reads like prose. Appendix: Edge Cases & Errors There's a lot that could go in this section, so I'll just point out a few things so this doesn't get tedious. should be avoided, it isn't total and if we did call it on a value we'd get a big fat . Consider changing the signature of the function to return a . This could happen if we changed our code to not produce an infinite list of guesses (). What if was changed to by another programmer (or future you) or floating point math throws you a curveball? Appendix: Two-liner After writing your function in terms of higher order functions it's usually trivial to then turn it into a one-liner, just inline all of the function calls. In this particular case we've got a two-liner unless your terminal happens to be very wide. 

Common Haskell style is to use camelCase instead of snake_case, so instead of . Wherever possible, Haskellers usually prefer case analysis to equality testing. If you rewrite to exclude testing (which is a tautological case anyway, why bother evaluating it?) you can check if the list returned by is null with , which enables more function composition goodness. 

Due to the use of for indexing, if the we're passed is out of bounds an exception will be thrown. Better filter the whole list of elements beforehand. uses , , and of course , all of which are O(n) operations on Haskell lists. That's three traversals of the index-encoded list for each element, consider the worst case performer of . This would have to be cleaned up through use of . Using in will walk the left portion of the accumulator list again, consider again that worst case performer. 

Performing math on indices definitely implies an imperative-programmer mindset to me. Instead of indices, use the value you really care about! In this case, pair each value with a that indicates whether it should be included in the output. This is easy to do because the pattern of inclusions are a simply repeating cycle. 

In this case we have repetitions of the string , joined by newlines, and printed to . All top-level function definitions should include type annotations as well. It's a good source of documentation, it serves as a good check that you and the type checker agree on what your function is supposed to be doing, and it often gives the type checker enough information that you don't need to use type annotations inside the body of a function. In this case, by giving a type to you don't need to say what the return value of is, because it can be seen that the in must be an since it's the argument to . 

When in doubt, parameterize. You tripped yourself up by defining directly on instead of just accepting any value you're passed. 

We fold over the finite timeline from the left, applying each growth function to the accumulator (starting with the height of the tree at year 0). 

Note that I moved the logic for including the end bound into this function. This makes more sense to me with a new name like , as it's sort of a utility function on lists. I wouldn't bother with all of the error checking you were doing either, the Constraints section is sufficient to guarantee you'll only receive valid bounds. You can clean up a bit too, it's odd to mix both and literal lists () in a single pattern match.