The fact that you are making a alternative does not mean that you shouldn't implement your logic using stl containers. Expressing your code using the STL containers is going to give you safety, move semantics, and all that good stuff while maintaining your lazyness! On top of that, if you use actual indices instead of double pointers for the index table, you can greatly simplify the resizing process, and maintain sane invariants with a lot less pain. 

Do your pointer arithmetic on pointer types Working with pointer offsets is best done using instead of . This way, you know that the size of the pointer will be set to whatever architecture you are compiling against, instead of assuming that you will always be dealing with the lower 4Gb of memory. Do as little work as possible in you inner loop Why are you calling every single time the hack is triggered? You should resolve the address once, and then just reuse the same pointer over and over again. Just use typed constants Instead of using defines, just use const variables, it's basically the same thing, but you can put move them inside of a namespace if/when you want. 

C-Style casts are easy to abuse, and prevent the compiler from doing a number of important checks. For example, in your case, you accidentally casted away the constness of msg. Use the appropriate cast for the situation, if you had forgotten the const here, the compiler would have complained: 

I've been diving a bit into JavaScript for the first time in forever, generally trying things out, and getting acquainted. I gave my toy project the following requirements: 

My impression was "Oh! can be possibly in certain cases", which led me to search for the scenario where that might be the case. It's misleading to the reader. Defensive programming can be useful at times, but this is just excessive. 

Now, if I had a function that converts a substring into "some" representation that's common between annagrammic pairs, but only between annagrammic pairs, I could simply generate that representation for each substring and work off that datastructure instead (probably by using it as a key to a map of number of instances seen). Since we only have 26 possible letters, a simple , where each cell represents the number of times a given letter appears in the substring, has all the properties we need. Just to make sure I'm not spouting nonsense, I gave it a try, and my solution using these principles solves all the hackerrank test cases in under 10ms. I encourage you to give it a try by yourself, but if you request it, I'll be glad to post the code for my solution here. 

edit: This last approach also makes the trie operate on raw data instead of characters, which makes it encoding-agnostic (which gives you your unicode support) Avoid using shared_ptr unless absolutely necessary shared pointers are clunky and heavy affairs. On top of this, using them sends a message to people reading the code: Ownership of the object is potentially shared between multiple owners, which is simply not the case here. in your case, a is absolutely fine. Your root does not need to be dynamically allocated It's created at construction unconditionally, and destroyed at destruction unconditionally. On top of that, it does not make use of type erasure (polymorphism). As such, there's no reason for it not to be a normal member of trie. 

Comment non-trivial algorithms: is funky enough that I had to squint a bit and take a quick minute to run the code in my head to even have an idea of what it's trying to do. An explanation of what each line is "supposed" to be doing would have been helpful here. Either name the struct type or the field name, not both 

It serves no purpose, and just makes your code harder to read. Personally, I'd recommend using a different naming convention for member variables instead. and are two popular conventions that everyone will recognize. Use RAII to release resources 

To supplement @user1118321's answer: Do not throw anything that does not inherit from std::exception As a matter of convention, all exceptions should inherit from . is generally what you would want to use instead of just throwing a string. Do not use mutable references for read-only code 

Why take ownership of the graph? Since this is an operation on a graph, it seems to me it would be better suited to operating on a const reference of a graph, rather than taking ownership of the graph or a copy of it. Why is this a class? I see no reason why this couldn't be a free-floating function. Memoizer does not memoize Your memoizer does not perform memoization, it's a visitation cache. You should name that type appropriately. Memoizer is not optional Since you are using a stack for the operations, you could very easily end up in an infinite loop when using the . This wouldn't be an issue when traversing a tree, but a visitation cache is useless when visiting a tree in the first place sooo... Memoizer lifetime I'm having trouble wrapping my head around the setup for the memoizer. You are accepting a memoizer instance as parameter, which would imply that you want to be able to reuse the memoizer in subsequent calls. However the data inside the memoizer only makes sense for a single given start->end pair, which you wouldn't ever lookup twice in a row since you have the result after the first call. What I'm getting at is that the memoizer feels like it should be a local variable inside , not something that is passed to it. Memoizer interface enforcement. What if the memoizer types returned bool instances instead of references? Your code would still compile, but not function as expected. Duck typing is great for this type of dependency injection, but this is walking a very fine line, and you would really need some form of compile-time sanity check. Too trigger happy on forwarding Forwarding is used when you don't know how you'll be using the objects. However, you do, so your interface should reflect that in order to help the compiler. 

Use range-based for unless you have a reason not to It's a lot cleaner and, more importantly, less error-prone. 

make_tuple() should decay the type of its arguments. Specifically, you should apply on a per-arg basis so that returns a . No EBO Since you seem to care about packing, you should really be performing empty base class optimisation to get the maximum oomph out of your tuple class. This does make the code a lot more complicated though, so if you know for a fact that you'll never pack 0-sized types in a tuple, then I wouldn't bother. A note on : Making this a compile-time switch like this is pretty dicey, as you can eventually run into some nasty binary incompatibilities in the future. I would rather make a complete separate class called , and use the compile-time switch in higher-level code so that symbols related to and remain consistent between binaries. It also allows you to mix packed and unpacked tuples in the same binary which is potentially convenient, since can have a substantial hit on performance. 

STL containers already store objects in the heap, and do a good job at managing them unless they have a that's ridiculusly massive (which would be super suspicious in the first place). You are wasting a lot more performance on hitting the memory system like a madman and inferior cache performance than you are gaining from marginally faster container resizing. Speaking of resizing... Deque is for fast front insertion, not fast resizing. you do not on , so you shouldn't be using a deque here. Once again, the marginal increase in container resizing is almost certainly not worth the decreased cache performance. has an amortized time of O(1), it'll be fine. InputSource design is dodgy It's hard to tell because seems to be designed to accomodate code that is not being shown here, but in general any "inherit to extend" design is suspect. Really, as far as I can tell from here, your lexer should probably just operate on a , and let the calling code handle concatenating token streams from different files. This would lessen the responsability on the lexer, and let it do just on thing: Lex. Big ugly if else if block: 

HashMap is overkill here. Depending on the constraints of the problem (mainly the minimum and maximum allowable years), you could simply use an array instead of a HashMap. Sure HashMaps have a O(1) complexity, but nothing is going to beat just indexing an array. Better algorithm Coming up with a better algorithm is very tricky. Your solution is where is the number of people and is the average lifetime. But keep in mind that is practically a constant, so it does not really matter that much. You could most certainly come up with a solution, based on creating a sorted list of relevant dates. This would outperform your current solution for small values of , but better performance at the low end is rarely useful (it can be, but that's the exception, not the rule). Edit Thinking about this, I suspect that's the "trick" part of that interview question. Overlapping intervals is a classic interview problem. However, making the intervals happen on a fully discretized space makes the hashmap solution viable, whereas it can't be used when dealing with "traditional" float-bound intervals. 

Your problem is not in the code, but in your algorithm. Brute-forcing the solution as you are doing is fundamentally slow, and you need to tackle the problem from a different angle if you want to make a substantial dent in your runtime. The problem is constrained in two specific ways we can exploit: 

Inconsistent constructor parameter: Your template's constructor's first argument is by reference, whereas your root template takes it by value. Be consistent, pick one. (the one by value with a move is the correct choice here) This is not actually forwarding: 

Avoid using magic values Most of your constants should de defined as global variables or defines. What would happen if you wanted to change the x and o to the upper-case letters? That refactor would require multiple changes around the code, and be error-prone. Always use braces with your if/while/for I find it just too easy to accidentally make a mistake when refactoring code that does not use braces for single-statement ifs. That's one of the main reason I personally really like the "opening brace on the if line" coding convention. It makes adding the braces have very little influence on code length. 

To fix these issues, I would instead add a static member function, and get rid of the constructor entirely: 

Since I needed to do a query-response handshake over the websocket, I decided that I might as well generalize that, since I need to do it a lot more further down the line. client-side : 

Good job in general! Avoid using goto unless absolutely necessary Gotos make code really hard to follow, and difficult to refactor. You should really consider changing that whole approach. A simple "enum and switch"-based state machine would work just as well, and be a lot more straightforward. Edit Example: 

I actually take issue with functions written like this in general. It screams "I am smarter than a compiler", and flies in the face of most of what C++ is about at a philosophical level. It's not portable, it's not future-proof, it's severely hamstringing the compiler, so optimizations implemented in future versions of the compiler will likely not be able to be applied. All this to say: for me, there needs to be a crazy strong rationale to motivate the existence of something written like this in a non-toy codebase. The biggest culprit of this in your code is the "writing more data than the size returned" part of it. The chances of this eventually stomping out-of-bounds memory is simply not worth the marginal performance difference. Considering the places in code where such encodings tend to be used, I find it highly unlikely that it has any measurable performance impact in anything that benchmarks this in context with some other code around it. So, now that that's out of the way, here's my feedback of the function as written: Don't use builtins where you don't have to. I get using , but there is no valid reason to use over . Don't use magic values where unnecessary That 64 coould easily be . Same goes for the 9, it could be . I know you only care about X86_64, and is always 8 bytes on that platform, but if being safe does not cost you anything (which is the case here), then there is no excuse not to be. Alternatively, if you really want 64 bits exactly, just use instead. Separation of concerns The main issue I see with your function is that it conflates the encoding and the storage. You would be better off separating them, and letting the compiler reconciliate. In the following, compiles to effectively the same thing as your . On top of that, since is now a pure function, and does not involve any side effect anymore, the compiler is a lot more free to mix and merge it with the calling context, so odds are it'll end up being faster in actual use. 

Review of : Prefer char* to void* when dealing with pointers to bytes refers to "literally anything" and is normally used when using dynamic typing. Since you are always passing an array of bytes, there is no dynamic typing involved, so you should use the proper static type: . It will also remove a few ugly casts from your code. Speaking of casts... Avoid using C-style casts 

I think should be a free-floating function, since you already have the accessors. I would definitely try to format that fold expression in a more readable manner. See my version of it above for an example. 

I had a bunch of sections detailing the various aspects of your design that could be improved, but I ended up scrapping most of it, because at the end of the day, it can be resumed in two specific things: But first: The idea of forcing RValues here is severely misguided. Forcing RValue usage should be limited to cases where things would break otherwise, not to enforce coding practices. What if someone wants to create a complex sub-expression and reuse it a few times? Tough luck! 1. Expression as a wrapper is misguided. I do not like wrappers that exist just for the sake of giving value semantics to something. Value vs reference semantics should be delegated to the user as much as humanly possible as long as type erasure is not invovled. Specifically, someone will inevitably write at some point in the future. 2. This is unjustifiably complicated. You can obtain the same functionallity with bog-standard code, no need to get fancy. The trick is to separate the function in the API from the type in the implementation. 

Edit: I understand this fold expression might look like voodoo to people who are not used to that type of code, so I'll elaborate on what's going on here for those of you who are curious: The fold expression looks like this: , which will expand to , where the "binary" operator used is actually the comma operator, which effectively just sequences the expressions while leaving them unrelated. After that, all I do is make be , so the whole thing expands as: 

Good work in general! There are, however, two very large problems: I really do not like SPAN_NDEBUG Having different exception behaviors between debug and release is super bad. Exceptions exist to be handled. In your case, handling that exception sanely in debug but crashing in release would be catastrophic. use instead, that's what it's there for. Inherit to expand is a massive code smell. The whole point of span is for it to be a value type: