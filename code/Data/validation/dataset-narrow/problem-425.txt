It's been a while since I used SQL directly in anger, so any feedback's welcome. I particularly don't like the way is repeated in both the and the clauses, so I'd like some way of aliasing the check if possible. 

It feels a bit like you might be looking for how to start a parameterised thread. In the code below, I've adapted your code slightly so that is aware of what type to expect. This is initialized when the thread is created, which means that the parameters can't pass the thread object as part of , however this isn't being used currently anyway and could be retrieved through if required. 

As has been said, you're not removing items from your . As a result of this, your locking mechanism as it stands looks like it will work. Don't do this: 

You also don't seem to be using tmp.txt, so I'd tend to just pipe the output from the first sed call into the second: 

A few thoughts... Unreachable Code When you an exception, execution jumps to the associated block (if one exists, or the program crashes). Where you've introduced your throws in your Point class to replace logging you've left subsequent lines intact: 

This will help you to at least consider these things. You can then talk about them if appropriate, even if you choose not to write them up on the board. So "I'd check 'k' to ensure it's a positive integer at the start of this method and throw IllegalArgumentException if it wasn't, however I'm not going to write it on the board so that I can concentrate on the main algorithm". As far as your actual code you've posted goes, the spec isn't entirely clear (as demonstrated by some of questions above). You're missing error checking on your method. For example you don't check if , what's going to happen if this is passed? Try to be more expressive with variable names. It's tempting when you have to write them down to shortcut names (heap,tempK,k,tempList etc), however if you do this in much the same way it causes problems for future maintainers, it makes it harder for you to remember what the variables represent and for the interviewers to follow your algorithm. This line also looks a bit odd to me: 

At the moment, you're checking every character for every condition. If it's a lower case character, it's not going to be any of the rest of them, so you can simply abort that iteration of the loop and move onto the next character. Something like: 

my my my This is obviously subjective, however I'm not a huge fan of prefixing member variables with . It makes the code read like it's been knocked up to try an idea (I'm not suggesting this is what you have done, simply that the variable naming gives that impression). This may be because I'd tend to use fields in things like , so would end up with: 

You set up an unbraced statement and then leave a blank line between the if and the code that belongs to it. This is an invitation to be misinterpreted. I feel much the same about the else condition at the end of the function: 

Does this make sense? Maybe, it depends what you're expecting to happen in the exception callback. I can see a potential usage where the client might want to attempt to reconnect in an the event of an exception. With your current handler the socket would be immediately shutdown when the exception handler completed. Other work would need to be done to support this kind of callback however, since there's a chance that would be being called on the worker thread (so you couldn't shutdown / restart the thread). Logging Logging strategies are often viewed more at an application level than at an individual class level. So, for example you might have a global logger that exposed log methods. If you don't want to go down that route, then since you're already providing callbacks for events, you could allow clients to register a logging callback as well. They can always register if they aren't interested in logging. Redundant code 

Again it might be worth writing a utility method something like this (I'm not sure of the type for pinState), where direction is either 1 (incrementing range) or -1 (decrementing range): 

Class Naming is a terrible name for a class. The class name should express what it is you expect the class to be responsible for. suggests a class that has no actual responsibility but is simply a bucket for functionality. User Input You have several places where you're getting input from the user, with y/n questions. If you encapsulate this in a single method you'll be able to reuse the functionality whenever you need it. So for example, you might end up with a class like this (based on your Functions class): 

Look like they should have been declared as class members (which now that you have added the header I can see that they are in there as well), rather than globals. The globals should be removed, they're just going to cause confusion. What's in a deck When you're dealing cards, you're deciding what card to add using a random generator. 

From your comments, it seems that draws Pacman. If this is the case, then I'd still say that you don't want to be calling it from within your method. You want to try to decouple your game mechanics + movement/collision logic from your drawing/rendering logic, they are different concerns and may well move at different speeds. One of the things you've said that you are looking for is to improve the speed that your code runs at. If you think about running games on different hardware, one of the things to consider is that you need to start thinking about using that hardware effectively. To give a concrete example, if your current computer processes your method 10 times a second, that's going to move your Pacman 50 units. Another computer may only run it 5 (moving 25 units) or may run it 50 (moving 250 units) that's a lot of variability that's usually ironed by linking the distance moved to the amount of elapsed time, which may be detached from the render time. I haven't read the whole thing (and it seems to be aimed at the mobile market), but this seems like a fairly good introduction to game loop mechanics. 

What you've done is create a dependency going the other direction. So you have a view, creating a viewmodel, which in turn creates other views. This seems like it could easily turn into a circular dependency, which is bad. I haven't yet found a solution I'm particularly happy with. One approach seems to be to use PRISM, but I haven't dived into that yet. At the moment, I'm imposing a project structure on myself which will force the issue. Essentially I'm creating a project for each element of the model (WPF project for Views, which references a class library for ViewModels, which in turn references a class library for Models). This prevents introducing unwanted dependencies going in the wrong direction. 

User B initiates the long running process coping files from FolderB to Sub2. To do that, they for FolderA? (or FolderB and Sub2). User A comes along and tries to rename FolderA to FolderC. To do that, they either lock or more specifically they try to lock FolderA. For the lock to be valid, none of the subfolders can have a lock on them? The code that checks this doesn't appear to be in the code you've posted. Assuming I'm correct about the expected behaviour, and that the code does exist somewhere else, it would raise a concern about the way works. AddEntry essentially does this processing: 

You're correct that your program could make use of arrays to simplify it. Something like this achieves the same result: 

You can then open/read and close the file as appropriate (again, and property isn't required so would be removed). Either approach can work successfully, really it comes down to how the rest of your application hangs together and your philosophy of testing (which is quite subjective). 

Bug You've got a bug in your dequeue function. It doesn't update tail, which means that if you empty the queue, then start adding to it again you get errors. 

You have a similar issue at the end of your code where you're not cleaning up after the tree you've constructed. You're missing this call at the end of main: 

This seems error prone. It also flags up a possible design error. Does it make sense for a to exist without an engine / without a team? If not, then I would expect it to be passed into the constructor, rather than passed in immediately after every construction. It seems like you've done it this way because of the interfaces you've declared which specify class dependencies rather than what a class can do... Public fields You're passing an instance of into every class it has public pointers to other engine classes that have public fields. This feels like way too much exposure of your engines implementation. I would hide this information behind getter methods. Then either pass the intial values into the constructor or provide setter methods. Whilst they may be simple pass throughs initially it will easier in the future if you want to make changes such as supporting different gravity zones Does it really make sense that at the moment any can change the gravity in the game? 

All of which would test that the expected value is returned. You might also consider adding negative tests, although they're not covered by your requirements to demonstrate you thought about them and what to do in those situations: 

Surely the path is the important bit of the check. It should be saying don't create an entry if there is already one for that path, not 'for that path with a given user at a specific time`. The time aspect in particular seems like it will result in the match never being made. Maybe you're handling all of this in the higher level code and filtering log entries based on the time they were created to decide if the application holds a lock or not, however it then relies on all your clocks being in sync which can be an issue. 

I had a few thoughts whilst reading through your code: Naming I don't mind the prefix for interfaces, I've never really liked as a prefix for classes although I can live with it. Having another prefix of for engine specific classes feels wrong/confusing. is a concrete class, that does stuff, why isn't it / for example? Interfaces Some of your interfaces don't really feel like interfaces. For example, has one method . This isn't what I think of when I think of an Engine interface. It could be an interface but it still feels a bit wrong. I'd expect to define operations that were then implemented in . Initialisation You're declaring variables and calling methods on them at the same time: 

I'd consider minimising the contents of your spin section. Some of the operations only need to be performed once (loading eax, checking pass). I'm not sure you're really getting much benefit from the unlocked gate check, but without running tests I don't know either way: 

Given that 'x' actually has some meaning in your game, I'd consider using a different name, even if it was just 'i'. 

As an aside, usually you would simply expect the combined full name, rather than it being explicitly stated which is which, so you would have: 

You're not accounting for variations on centuries. Years divisible by 100 aren't leap, unless they're also divisible by 400. 

However, if you're going to use it, be consistent (your main is defined differently). should work in all cases You're assuming that the file you're reading does't contain any nulls. This may be OK, as you're not opening the file in binary mode, however if you decide to reuse the code for binary files, returning a null terminated buffer without a size field is going to cause issues. Main is leaking I know your main is just a test harness to demonstrate the code, however it's best to always use appropriate memory management. Your function is allocating a buffer using , you should be ing it in your main. By including this in your example it demonstrates that you recognise responsibility for the returned buffer is sitting with the caller. 

Until you call , is null, so is going to crash... Naming Think about what variables you're declaring at a class level and what their purpose is, then give them names that reflect that. It will be a lot easier to follow your code and identify bugs. In this instance, it seems like perhaps is actually supposed to pointing at the tail/end of the list, rather than the head. Consider what you're supposed to do to any class variables (such as ) when you delete items from the list. 

A couple of things stand out... Initialise your pointers You don't initialise your thread pointers, which means there's no way for you to tell if they're pointing at valid objects or not: 

Once logged on, interactions will take on a more fluid approach. Approach 1 My first draft split the processing up between two session classes. One for managing the logon transitions () and one for post logon (): LogonSession 

Typically you'd also want to try to avoid catching base exception. It suggests that you don't really know what exceptions can be thrown. Sometimes it's the right thing to do, but more often than not you should be catching more specific exceptions so that you can take more appropriate action. When you're done, you're done Your thread function in your server contains an endless loop. This works whilst the client is behaving, but falls apart once you encounter an error. Within the loop, you're catching all exceptions and responding by closing the socket: 

As has been said by @domi1819, hashing by individual characters would be better than your current approach. As the test suite seems to have been written as part of the exercise you're limited in how you can change the class and still have the tests run in their current form, which is a pity because the suite is forcing you to construct a class that feels wrong. If your goal is simply to implement the code required to pass the suite however, I'd remove the member variable of the class. Other than in the initial calculation of the score this isn't used. Instead, change the signature of the method to accept the phrase as an argument instead. Similarly, the method could simply update the member of the class, rather than returning an integer. 

Method Naming Consider giving your functions more meaningful names that describe what they do. Using the example above, . Unless you already have the menu in your head the name is meaningless. A better name might be . Magic Numbers Vs Defines Replacing magic numbers with meaningful constants is a good thing, however simply replacing a magic number with it's word value adds little value. Consider: 

At which point you might want to start thinking about using a define for buffer size, rather than having the 1024 magic number everywhere... 

Exceptions from privates This is probably subjective, but I don't like the way your private method is throwing an exception: private static int median(int[] sample, int start, int end) { if(sample.length < 3) { throw new IllegalArgumentException("arrays of length three or greater"); } If your private throws that exception, it's because something under your classes control (one of it's public methods) has failed to supply the right data. Validation should be performed at the public interface to the class, you shouldn't need to perform it again in your privates. 

It may be that you're doing it as part of setting the environment, or it may that you've simply made typos (I automatically type 'byte' whenever I try to type 'bye' then have to correct it). Either way, the more text you embed in your program, the more likely it is that you're going to encounter errors. If you push a lot of the text out of the application into a text file, it can be easier to validate the text using something like a word processor. The process of moving the descriptive text to an external resource can also help to identify what is common and what is different between your different interactions. This can help to direct your file format & your code structure. So, for example you might have a file structure something like: