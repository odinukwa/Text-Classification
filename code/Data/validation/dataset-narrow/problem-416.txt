I will suggest using on the instance to handle its underlying I/O resources efficiently. Instead of a 'plain' loop, I opted to showcase how a similar loop can be done using the -loop construct: it is somewhat more expressive, and the slight benefit is that it nicely scopes the variable within itself. The implementation for and shall be left for the reader... What I can further advise for the latter is that it should safely handle invalid inputs internally and only returns an value for comparison. Oh, and one more thing... you current implementation for the random number does not generate it in the range \$[1 ... 1000]\$, assuming that you really intend the range to be bound-inclusive: 

You have just defeated your purpose of making a constructor... and not only that, it makes it possible to create an instance with fields. Even if this should be possible in your codebase (as used in ), then I will suggest simply sticking to two constructors - one with the arguments, and one without. The then becomes unnecessary. I am also unsure about the viability of ... unit testing should be asserting the behavior of your class's features, not the visibility of its constructors and methods. 

If a is lurking in your object, this will fail. Debugging and variable naming If possible, use a logging framework like SLF4J so that you can configure when you want to see the debug statements, instead of simply printing via . Also: 

These can otherwise be represented as properties or fields of a Java class, if you choose to model each strain as an object. If you ever decide to add new effects/medicinal properties/negatives in the future, you'll have to keep updating these s. If you choose to model them as classes and s, it makes it easier to add or remove these properties for each strain. 

E.g. with the method name . Use interfaces such as instead of the implementation () so that your code is not too restrictive. Your method can then be (using so that you are not limited to just two arguments) : 

vs This may be down to a 'personal preference' thing, but using primitive wrappers in an array instead of a seems a little odd. This is because it lets values sneak into the array compared to a 'plain' , and speaking of which... Boundary cases 

Picking out only the values 1 and 4 () is understandable, how can one check that we have both 1 and 4 in the end? I went with a operation and then counting that we do not have both values... 

Enhancing use of loop Multiple local variables can be declared in the loop, so you can include your variable as such: 

In turn, you can then create a method for that can iterate through its (assuming it's one of the Collection classes, like a ) to generate the desired output: 

Deduplicating code blocks, part 3 Finally, the / discussion. You pointed out that an check is one way. Another alternative is to be inspired by Guava's Functions and Java 8's to have your bespoke implementation of a two-tuple 'processor'-like : 

You may also want to look into standardizing your braces approach for all code blocks, including one-liners. This will make the scoping more apparent. 

That will create , duplicate it once, and add the character at both ends. The ternary operator below looks like a good candidate for adding a helper method into the : 

Specify some test input. Process the input to some output to be recorded. Assert that the recorded output matches an expected result. 

Building upon @unholysampler's excellent feedback, if the matching condition between a disease and speciality is as straightforward as your current example, and the hospital will also only have one doctor per speciality, you can make use of two Maps in (renamed) to make the assignment simpler. I think it's realistic to make these two assumptions given the simplistic requirements. Besides, your code seems to suggest that one patient can be added to multiple doctors. Is that desired? Even if the assumptions are not true, you can tweak it slightly to have the value as a for example, and then build some logic to pick out which doctor do you want to add the patient with the disease to. Also, in my code below, I did not check if a is added multiple times to a 's list, maybe you want to implement that as well. Let's start off with @unholysampler's recommendation for first, I am providing and as an interface here only to illustrate that and the recommended change in method names: The interface: 

I don't have much experience with Hibernate, and I'm rusty at JMS, so I'll review the other parts of your code... You have two inconsistent braces usage for your block: 

Input validation Your current method accepts a string like to represent , which may not be desirable. You may want to validate whether the first or second token can be combined with another, e.g. rejecting because cannot be a second token, and accepting . For example, you can have a class: 

Since the use of and are just opposites of each other, you may want to consider having just a single field, to keep the implementation simpler. 

I suppose you have this line/chunk of code because you're still on Java 6, since Java 7 can do on literals. Therefore, at the very least, you can consider putting this inside a method e.g. so that the refactoring can be easily done in the future, when you migrate to newer Java versions. In fact, you should go further by having a separate class that can 'map' a into your object, and the logic to convert e.g. into a of will belong there too. Don't store password in plain-text :p Can't help but notice this in your method: . I hope this is only for an academic exercise, not something to be implemented in a public-facing Fortune-500 company's web portal. :p User types in another table? (database design) (suggested by @Vogel612) This is not about your code, but the database design. Perhaps the reason you are storing user types as a column in the table is because it works well for your existing use cases. Still, you may want to re-evaluate your database design to see if it can/should be in its own table, so that you can use foreign-key relationships in your favorite Relational Database Management System to represent their associations with users as such. 

Mathematical approach You may want to consider using a faster mathematical approach to test if the number is a positive power of two or not... 

Standardize your comparisons You have two similar comparisons here (I'm assuming they are - or gasp, primitive - values for to work correctly): 

The return type of the method - a here - is useful to also indicate whether the move was valid or not, and to keep re-prompting the player: 

Hypothetically, if you really need a marginally higher-performance method call on the basis of number of steps involved... 

You can create a object from another object, i.e. effectively cloning and doubling accounts' numbers. 

That can be read as "get the character at , and append the reverse of the from the start to just before ". This literally chains my train of thought on as the anchor point of doing the reversal. Given the left-to-right reading style for English, this 'shifting right' idea is intuitive. Compare this with the suggest answer, which I will attempt to read as "get the reverse of the from the second character onwards, and append the first character at the end". The idea of doing the reversal by 'shifting left' is not well-contained as a form of mental evaluation (for English). If one is splitting hairs though, the suggested answer can be faster, but at this point we're really talking about micro-optimizations here (e.g. performing the reversal 10000 times on 1000-character s). It doesn't require the computation of , and the implementation of is slightly simpler compared to . Unless there is a real performance concern for what you say are only recursion exercises, I'll say this is not something to be overly concerned about, and your own solution is good enough. 

TestNG Eclipse's TestNG plug-in has an even better display of test parameters and results. The implementation is simpler too using method annotations, and you can specify multiple providers for multiple methods. Note: is the same as the snippet for JUnit example above. 

There is a bug here as the whole condition will never be due to the usage of . What you are looking for here is , i.e. if character == '0' character == '1' character == '2'. Program flow 

If that is the case, and without delving too much into further refactoring the logic for this step, it may be more convenient, or easier, to pass as an argument to a generic method: 

Your simplified logic doesn't appear to handle sentence structures accurately, but since you seem to be more concerned with the formatting (capitalization), then I guess it's ok. 

For starters, getters and setters are often used to provide some kind of field validation, or to return read-only views on the underlying field. More importantly, you will totally lose the ability to make thread-safe immutable classes instances using this approach. Sure, if you realized all you are dealing with are nothing more than a skeleton of getters and setters, this proxy-based approach might seem plausible, but you will be trading flexibility for functionality... Code-wise, may I suggest that you flip the constructor-chaining of so that the one will the least arguments 'pass-through' to the next? 

Since Java 7, you should use on your for safe and efficient handling of the underlying I/O resource: 

From an API perspective, you may want to consider if it's suitable to 'default' as for all the results of these operations. In other words, when the user is adding 2 meters to 2 meters, is the result better represented as 4 meters, or 4000 millimeters? How about adding 50 centimeters to 2 meters? Should it default to 2.5 meters, or 250 centimeters? What's nice about your code is that your classes are properly modeled as immutable ones - to nitpick, should be made too if you do not wish to extend it. Just remember that the comparison in must check for the same type as well, i.e. catch these as assertions instead of having the JVM throw a . 

Longer answer... It is not known how these lines are being run, but you can also consider writing event listeners, which is the typical implementation for checking if buttons have selected. For example, to use an : 

The main advantage of using is so that the textual representation is available for use by users of your class easily. Getting to the crux of your question (which I have also somewhat answered above): 

First, I use @Shree's advice to rename the method, so that it is known that the comparison is done in an ascending order. Second, the initial statement takes care of a argument or single-element array to return a result immediately. Third, at the final statement, we take care to compare the last element with the second-last element in case that was skipped during the -loop, else we know that we have compared all elements and can . Based on my simple microbenchmarks, halving the number of iterations at the expense of two comparisons in the statement pays off once you have more than 15 elements thereabouts... 

Over here, we map our conditions using the as the key, so that it can read something like: 'with the key to , given the condition '. 

I suppose by advocating an OOP approach, you'll want your classes and methods to encapsulate your -based inner workings so that it's possible to swap them out for a 'real-world' solution, this will likely require the use of interfaces in addition. 

My take on this is that there's really no issues with using Lombok's builder pattern, but at the same time don't be too limited by what you can do through a framework. :) I think can be made redundant if you were to work with an / directly, instead of a . Even if you will like to stick to this current approach, this method can be rewritten as such to leverage on the return value from , which is only if the addition modifies the : 

Is there any reason why you are using as the generic type for the ? Maybe you need a domain class for it as well? 

Interfaces over implementations and type inference As illustrated above, can be declared as a instead of , and at least you are not making the same mistake in the method return type declaration. Also, since Java 7, you can rely on type inference to eliminate mentioning the generic type a second time, by using the 'diamond operator' . Java 8 stream-based processing Since you are on Java 8, you can look towards its stream-based processing capabilities as the appropriate way of solving your problem. It's relatively simple to adapt your solution to reduce an integer stream to a , or more specifically to create a out of your solution: 

Create VisualProcessStepConnection instances between the current step and its next steps In your current code, you are iterating through the next steps of the current and then constructing a new object for each of them. To simplify the creation of the object, you can either give it a constructor that takes in two instances, or use a method to do so. The suggestion below combines both approaches: