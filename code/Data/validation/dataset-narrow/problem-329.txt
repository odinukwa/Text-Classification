You shouldn't try to do too many things with one data store. If you have a table for transactions, then just keep transactions in that table. Don't mix in scheduled future transactions with current transactions. Actual (historical) transactions will have different attributes (columns) than future, scheduled transactions. Keep the recurring/scheduled transactions (like rent) in a separate table. When the rent is paid, create a new record in the (actual) transaction table. The scheduled transaction table could have a totally different structure. Instead of keeping a record for each expected transaction, you could keep one record with a date range and recurrence fields. This would save having to update multiple records when the rent price changes, for example. Consider something like this for your scheduled/recurring transaction table: Scheduled_Transaction:= 

Use them to send mail or packages to that location. Use them to do geospatial analysis on that location. 

One of the assumptions that I would ask you to reconsider is whether you really want to have different tables for each event type, or if rather these event types are rows in a table instead of distinct tables. If you had an table containing your list of event types (about 100 of these) you could take the columns from your current various event tables and make them rows in an table. This type of design would turn your schema changes into data changes when you add new event types. That would save you code maintenance issues and also avoid making your queries more complex and potentially slower. The instances of events would similarly be kept in two tables, for example a table and a table. would be an intersection between user and event type. would be an intersection between log and event parameter. Your data model might look something like this: Note that one objection some people may have to this approach is that you end up saving the log parameter values in a string format, rather than in a native format. This is clearly a trade-off. You have to ask yourself is it a good trade-off for your situation. 

There are a few things you want to factor into your design: 1. Measurements Need a Timestamp Make sure all of your measurements have an indication of: 

You should organize the data according to its cardinality. If you have one header and one footer per client, then these columns can be part of your client table. Since there are clearly multiple body records per client, these should be kept in another table. If you can have multiple records per client, then your "with hierarchy" model is not bad, although it could be simplified to collapse the and into since there is only one header and one footer per record. Your "without hierarchy" model is less desirable. If you have multiple records per client it won't tell you which headers/bodies/footers go together. If you have only one record per client, then having separate tables for header and footer is overkill for the same reason as I noted above for the "with hierarchy" model. This is what I would recommend, depending on how many records each customer can have: 

Segregate your retailer addresses (including lat/lon). This could be in a RetailerAddress table or it could be columns on the RetailOutlet table, whichever makes the most sense to you. Create two indexes: (lat), (lon) on whichever table contains your retail outlet addresses. If you have a separate table for retail outlet addresses, be sure to include the FK to the retail outlet in these indexes (i.e. (lat, OutletID), (lon, OutletID)). 

Track your achievements in parts. Right now you have some indicative (i.e. descriptive) information and one "business rule" column (). You actually need more than one business rule column. Depending on what you foresee being your needs and how much work you want to put into now, this might be either one or two more business rule columns, or possibly even an extra table or two. In addition to "how many are needed?" (i.e. ) you also want a column that describes how many of what? You have two descriptive columns for this now, but these are human readable. You also want a machine readable column. In terms of nomenclature, I would actually use for the what, and something else, say for the how many. With a column and a column you can then write program logic that knows how to measure each type of achievement. This way you don't need custom logic for different levels. You could take this a step further and normalize this somewhat so that the descriptive information is part of a separate table. This would allow you to have groups of achievements that share certain types of information and logic. This distinction would help you with handling user-specific and user generic logic in a nice, managed, organized way. 

You should use one table per object of interest. That means one table for users, one table for pages, one table for posts, etc. Use a normalized database (See database normalization) for transactional data. This is precisely what relational database management systems are built to do. Don't presume you are going to have performance problems because you have many rows. Most systems perform better with many rows than with just a few. 

Regarding IDs for your tables: Never use anything external as the ID for something, unless you are totally positive that it will never change. A vehicle VIN is OK as an identifier. Nothing causes a VIN to change and it is guaranteed to be unique. A passport number is a terrible ID because (a) it will definitely change as time goes on and (b) you can't be sure that it will be unique. When primary keys change it causes all kinds of headaches. This is why a lot of people assign internal, meaningless surrogate keys to their tables. 

At the end of the day, you are going to make a practical decision based on what is most important to you. Whatever you decide will have pros and cons - but they will be your pros and cons. 

In a datamart you need to denormalize time variant attributes to your fact table. Your transactional source database will have the flyer's club level on the flyer table, or possibly in a dated history table related to flyer as suggested by JNK. In your datamart, you need to apply the current club level of each particular flyer to the fact record that brings together flyer, flight, date, (etc) In your case, club is a time variant property of flyer, but the fact you are interested in is the combination of a flyer and a flight. Therefore you need to record the FlyerClub on the flight transaction (fact table). This will work as long as you don't let flyers change clubs in mid-flight. 

There are two principals that should govern your thinking about you data modeling options for this application: 1. Never Throw Away Important Information Discarding data that you might need is a terrible idea. It's up to you to decide whether a failed registration is something you might need. I would think it probably is. What would you do if someone showed up for a class saying "hey I registered!"? Wouldn't you want to be able to say "oh, I see your cheque bounced so your registration failed."? 2. Model Close to Reality If you try to abstract your entity types too much, you will find your model gets brittle and hard to adapt to changing business rules. Your system is tracking a couple of kinds of events. In particular, the act of someone registering for a class and the act of someone paying for a registration. You should have a table for each of these events, along with tables for the people and classes. Keeping separate tables for registration (which you already have) and for payment (which you don't really have in any of your options) allows you to handle situations like payment by multiple methods, e.g. some cash, some credit card, some promotional coupon, etc. It also lets you deal with the situation of failed payments, credit notes processed, and other real-world exceptions that are probably important to know about. Instead of keeping columns for registration status, which is ultimately a calculated value, you should be keeping columns (and records) for the various components of the registration status calculation. If your system turns out to have peculiar performance demands during real runtime testing, then consider using denormalization of the calculated registration status value, but beware of all of the potential issues that will raise for data integrity and plan to deal with those issues. Bonus: If you keep a table and a table, as I suggest, and treat registration status as a calculated value, then you can add a column to that allows you to bend the payment time limit rule. You can do this different ways. For example you could have a flag or code that means "consider this registration valid, even without payment". Alternatively, you could have a numeric or date column that gives a payment extension allowance in number of days or by a different, arbitrary deadline. 

You want to convert the pivot table into a normalized table. Store each cell in your chart as a row in a table. The business key of this table is + and the non-key columns are and . 

How do you know how long a room is booked for? Your model indicates when a booking starts, but when does it end? Also, your ERD shows foreign keys from to and but these columns aren't acknowledged in your table. Some other answers have interpreted that as the columns being missing. You should be explicit in your diagram to avoid confusion (or add the FK columns if you missed them!) 

Note that for OP's scenario where determination of the seller may be delayed, the agency would need to have some kind of escrow account. This would be an additional party, such as "Outstanding Order Payments". In such a case the agency could take their fee right away and the balance would be placed in the escrow account. When the sellers are determined later on, they would be paid out of the escrow account, rather than out of the buyer's account, as is shown in the example, above. Also note that while each transaction is shown with two details above, it is also legitimate to have three or more details for one transaction if you happen to want to record it that way. For example, all of the details in 8001, 8002 and 8003 could have been represented as a single transaction if you prefer.