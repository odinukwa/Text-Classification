It would be nice to have a code review to show me where I can improve on readability (along with other things you may find!). I've been trying to clean it up and refactor a bit, but a fresh set of eyes would be nice. I went a bit crazy on comments because I wanted to make sure I would be able to look at this in a few months and not forget why I did something the way I did. But perhaps putting some of that info in a github wiki would have been better. 

Drop the and inheritance of command objects and instead create an that creates a POGO and stores it in the scope. Then in the controller, I pass both the object and the to the layer. Just pass the 3 fields through the scope and don't worry about creating the or an . Instead, every method in the would have an additional 3 arguments for these fields. 

I've implemented the coin change algorithm using Dynamic Programming and Greedy Algorithm w/ backtracking. The description is as follows: 

There is one catch to this idea. The and are mutable (which I believe immutability is strongly suggested by Spring). It's possible that the and/or fields are supplied by the client/UI, or they might not be (orgId will always be supplied from the UI form). If they are not supplied, we query our database for them. If they do not exist in our database, then we throw an error. They almost always will NOT be supplied. To do that, I change the to override the methods and look up the or if they are not provided 

Style Comments Methods which take functions as parameters ( and in this case) should be invoked using infix notation. That is, if there were a god of Idiomatic Scala Style he would prefer to Defined functions should use camel case, e.g. over . In general, and you will get a feel for this the more you use Scala, pattern matching is preferred over if-statements. You will notice that in your function I've swapped your if-else statement for a pattern match on the value . The last style tip I have for you is to break a chain of higher order functions over several lines. This last one can be fudged in some cases, but in general I find that it improves readability. Efficiency Comment The one change that I made in the name of efficiency was to change the container type of from to . The reason I made this change is that accessing an item in a takes linear time on the length of the list, whereas accessing an item in a is almost constant. And as you know, you are accessing elements of by index is in the last line of . 

My current assumption is that the string returned by is going to look something like If this is the case then you can try the following function: 

I have similar to the above in several classes, passing on an android activity and/or a textview into model and controller objects. Will this be a problem and is it possible to solve? 

IIUC I should decouple UI logic from the model and controller in my project. I didn't succeed and had to resort to etc in my game logic: 

When testing your solution compared to a regex, the result looks like the regex is slightly faster in this test. 

I wrote a build file for a mini Android game. I use this buildfile whereupon travis reports success. But I'm not always sure of what I'm doing. 

I have written a "better" program that does the same(?) output in safe ways. You don't have to see the original code because it isn't mine. The following is my code to solve the assignment in a neat way. Figure.java 

I needed quickly to represent a list in json format. I wrote the following front-end in jinja2 with google appengine. 

There are several unclean errors with wrong variable names because I copied the code from an example but the output is good: 

It was somewhat more problematic to create the layout in XML compared to the small game engine and controls. Maybe we can rewrite the code more object-oriented because it is rather procedural at this time. The game is open for testing in an open alpha and the source is available at my github. Main activity 

Pattern Matching Within the helper function each layer of the recursion checks the value of against some constant value using an if statement. The more idiomatic way to do this in Scala is to use pattern matching. For example: 

Lists vs. Arrays The Scala version of your code ran surprisingly slower because you used a . In Scala you can think of a as a traditional linked-list. s don't provide random access to their contents. That is, accessing an object at index n requires O(n) time. This really slowed down your code because you index into in both your inner and outer for-loop. To fix this problem you can simply use a different data structure like an . 

Below I've written up an implementation of a recursive bubble sort that addresses the main concerns you mentioned. The areas your code can be improved matches what you instinctively pointed out in your bullet points. Whenever you use a or in Scala remember that it is in fact a linked list and so accessing an element takes linear time. This could add a significant number of operations to an implementation of bubble sort that utilizes a . As a substitute I used an which offers constant time access to elements. It is also worth mentioning that the container is mutable in Scala even if it is declared as a . We can kill two birds with one stone by rewriting the while loop as a recursive procedure. The two birds are and and our trusty stone is . 

My Question: Do you think this is an appropriate design? I believe the biggest drawback to this is that the is mutable. Brainstorming a few other ways: 

I'm integrating with a 3rd party vendor that has and in it. My tool is a user administration tool that allows us to store information in our local database about the and that we manage in the 3rd party vendor. So the and are stored in the 3rd party vendor as well as our database (we act as the middle man sort of). I'm at a crossroads with some ideas and would like to hear what others thought of the following problem and my solution. Before I dive in, we're using Grails 2.4.4 One use case for the tool is creating a . We create the user in the 3rd party vendor via an API call, and then we store information about that user in our database. There are many uses cases like this and there are 3 fields that are always in common between them, an a and an . These 3 fields are required for just about every API call we make to our 3rd party vendor and most of the result in an API call being made. For this reason, I had the idea to make a "Common" with these 3 fields on it that can be extended by another Command Object. 

CASE CLASS I would change to a . One reason for this change is more concise object declaration, e.g: 

Overall I'd say your off to a great start. Here are some of the changes I would consider making to your code: Formating Output When printing strings that encapsulate values/variables you have two (idiomatic) choices in Scala. Option one is to use string interpolation: 

Below are some of the changes I would make to your code. In my opinion one of the nice aspects of Scala is that it gives you all sorts of ways to reduce the amount of work your mind has to do in order to decipher code. As an example, one of the first things I did was declare a type that is equivalent to . I then just substitued where necessary and the code (to my mind) became more readable. The choice of was arbitrary on my part, you could if you wanted use instead. Along these lines I shortened all of you variable and value names. As the program is set up right now you don't need to pass in a array, but I left it in anyway. As you mentioned this is a homework assignment so I'll leave a bit of mystery as to why this is. And really you don't need the and the . Next note that is equivalent to . And finally (for now) checkout how I initialized and . If you still would like to use your function you should look into the method called . Cheers. 

The above sets a pager and greps the environment variables for a variable. I run the script from my shell after I start it: 

I was given a program that generates XML, filters and sorts the elements. The program was rather terrible on purpose because it is an assignment. The original output looked like the following: 

I have some code where the purpose is the decide if a char is between quotes in an expression. For example, has a between quotes. The function that I want to test is 

My allocation and deallocation functions look like the following but I didn't do it yet for a `struct only for arrays and matrices but I think that I can have an array of structs with one struct and use these functions for the struct. 

I have created a mini Android game. The aim is to catch aliens in space. You score points for each aliens, there is a pause function and you can change the level of difficulty and change spaceships. 

I make a mini adventure game demo for Android where the player can move between places and NPC characters can enter and exit the places and perform random actions. The "dirty" code is the UI for Android while the game engine is very good and clean. I have this class which is quite unclean but it works and therefore I want a review.