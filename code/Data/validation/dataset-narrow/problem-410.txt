Unfortunately, you didn't specify your Python version. In 3.X there is the flag. Hence you could refactor this to You could also get access to (there are implementations for 2.7 on pip). This would allow dealing with paths in a pythonic way, because you can now do things like: rather then and have python deal with the os specific bits (symlinks, correct slashes, ...) 

Here is a faster version (around per batch). Its essentially refactored for readability and often in vectorized code, more readability / code beauty makes code run faster: 

Assuming is an okay thing to do you don't want to check after ing an element but rather before you insert it. It saves you the overhead of appending and popping visited nodes which can be quite substantial. Further, should be a (as stated in @Alex 's comment). It could also be a good idea to use an actual queue object, be that (for FIFO / LIFO) or a . The latter will slightly reduce performance (insert from O(1) to O(log(queue_size))), but offers a lot of added flexibility and easy scalability to graph search. Setting the priority to: is DFS, is BFS, (or ) is Dijkstra's search, is greedy search, is A*. I think that's a really cool property. 

further we can replace the strings and with a Boolean and stay in numpy for longer (down to 1.633 seconds): 

Note how this function returns the last result from . In main, you can use it to simplify your code like this: 

Singletons There are several ways to make something a singleton. You are doing it by removing the public constructor, and forcing users to get an instance through a static member function. That works, but there are alternatives. You can create a regular class, and provide a global instance of that class. Just like so: 

Flushing Whether or not to flush depends on what you want to log. If you log a lot of information, flushing adds considerable overhead. However, if you want to be sure that any errors that are logged are not lost when your program terminates abnormally, then it might be prudent to flush the output stream after every write to the log. Other suggestions Do you really want to use the operator? If you rather like to use the style, then consider making use of fmtlib, which provides a type-safe way to format strings the or Python way. Your logging class could look like: 

Be aware though that on some systems (notably 64-bits Windows), can be smaller than , and if you would ever have a string longer than can be represented in a , the output will be incorrect. 

First, it seems like the brand and the category checks are more or less separate from each other. It's confusing reading that statement to work out that you're churning through every valid combination. So separate them out into their own methods: 

In C#, in general you should use these kinds of enumerable-manipulating methods (found in the namespace) instead of loops as your first port of call. They usually lead to terser, easier to read code. Only occasionally are loops easier to read. 

That's not a full example, but it'll be refined later. Hopefully you can see how this has now separated out different responsibilities into their own classes. From your mention of in a comment, I assume you're using Entity Framework. EF actually already provides you with a class that will serve the purpose here, which is . You should be able to get that from your . That class will handle operations like Delete for you. So in fact the only class from the above example that you actually need is the class. (As a side note, this is an implementation of what's called the 'repository pattern'. If you look this up, you'll see it's often recommended that even when using Entity Framework, you add your own repository class on top- in the above example. I wouldn't worry about that at the moment, it adds another layer of abstraction which can be valuable in some cases, but don't do it without understanding why. It's more important to get the basics in place.) So finally coming to whether and are redundant. Yes, they are. Once you remove the persistence logic from both of them as described above, you're left with nothing but a property bag which is identical for both of them. You should delete , and push down into your data layer. In fact, in large solution you could push futher- have a "Core" project referenced by both the UI and Data projects which contains your domain objects like User. Data would then reference Core, and UI would reference both Data and Core. In your case, actually structuring your solution like this is likely to be unnecessary, but it's a good way to think about it conceptually. So, finally, with all of the above applied your code might look something like this (again this is omitting some details like construction, just leaving you with the key bits): 

Clearly define the use case When I think of "message systems", it's either message passing between different computers, processes, or threads. However, it seems that your message system only works within a single thread of code. Also, it doesn't really store and forward messages, it merely registers and calls callback functions. This is fine, and may be exactly what you want, but make this absolutely clear for potential users of your message system. Handles versus names Your message system identifies message types by name. However, you have to programmatically register message types. Instead of using an unordered map to associate message types with names, why not have return a reference to the object? This way, you can pass that reference to and , instead of a name, and avoid doing map lookups every time. Avoid global state Your is a global variable. What happens if you have a program that links with multiple libraries, each of which uses your message system? They will all use the same . This might result in conflicts. You already have made it so that you have to declare variables before you can listen to and send s. Why not make a non-static member variable of ? Check for multiple registrations of the same name Your code currently does not check if a program tries to call twice with the same name. It will just overwrite the entry in the with the second instance. Either avoid using names at all, or check that you don't add the same name twice (or alternatively, allow double registrations, but only as long as they all register the exact same message type). is not guaranteed to be unique You are using to check whether the type of a parameter pack is the same as that of a . However, while guarantees that identical types get the same hash value, there is no guarantee that two different types get a different hash value. If you avoid using message names, but rather have a reference to an actual object, then you could move functions like , to the class. Then the compiler would exactly know the type of the parameter pack, without having to rely on run-time checks. Use for callbacks Instead of forcing callbacks to be pointers to member functions, and requiring the user to specify both the member function and the object individually, use to represent a callback function. The advantage is that it will accept any type of function as a callback, whether a named function, a lambda, or a member function (using ). Make it like so: 

A) This is not very useful output. I would rather return how many lines have been inserted into the database or nothing at all. The fact that something happened somewhere while this code executed is implied by the user calling the script. B) If the script fails, you should inform the user; however, it is probably better to not catch any exception and then continue. The block will be executed regardless of what happens in . You can omit the entire block. A setup is thought of as a "cleanup block" which will make sure that the finally is executed before any exception is escalated. 

I can also limit the amount of elements processed. That way I can visualize the first 10 million elements of . I find this visualization to be of limited use, but I guess it makes more sense to you? 

Doing all these things will reduce worst case performance to and should make it substantially faster. You could think of ways to reduce the number of computations needed for and potentially reducing the overall complexity, but I didn't think into this further. 

There are a lot of debug prints in your code snippet. I will mark them with a if I can't see any use for the end user. I would opt for removing them. 

The name doesn't make any reference to the fact that it's specifically for a time interval within a day. Why not ? 

As Phil Sandler said, the code here is so thin that it's possibly questionable how much value unit tests actually add. However, I would say that their two main benefits are both still relevant: 

We can take the same approach with the other input/output sections, to now get a clearer version of your algorithm: 

The first simplification is for the check. All you need to do here is check that the value is not null, you don't care about the type. Then you can do the type-specific check later. So remove the outermost and simply have: 

A note on OO One last thing, since I noticed a few other answers mentioning taking a more OO approach, I'm going to disagree. In my opinion one of the best ways to make sure you misunderstand OO is to apply it where it's not appropriate. Here your entire application is concerned with input/output to the console, the only real behaviour it has other than UI concerns is a single very simple calculation and a greater than check. Trying to "object-orient" that is much more likely to baffle than teach. Understanding OO is a very important part in becoming a proficient Java programmer, but I'd say that you definitely took the right approach keeping this particular program procedural. 

Use better names Variables and structs should have names that are clear and to the point. Naming something is not to the point, it sounds vague and handwavy. Choose something better. The same goes for . Use for lengths and sizes The proper type to store the length of a buffer or a string is . If you read the manual page of , you will also notice that it returns a value of type . Use the correct format specifier for Use instead of when you are printing a variable of type . If is not supported by your compiler, then cast the variable to the right type when printing it; for example with , cast it to : 

As you can see, does not have any possible subsets. Or put otherwise, is too large a number at to give any solutions. Instead of trying all numbers from to , try to find out what the actual maximum is that will still give solutions. 

Use const function arguments where possible You have a lot of functions that take an rvalue reference instead of a const reference. If you don't intend to change the argument (like the arguments for the member functions in ), it is better to explicitly make them const references. There are two main advantages: you will get a compiler error when you accidentily do change an argument, and if the compiler knows you will not change the argument, it can make better optimizations of your code. 

Maybe If you're writing a maybe monad, it's very informative to think about . Maybe can be thought of as a special type of enumerable, which instead of having 0, 1 or many items, can only have 0 or 1 items. Thought of that way, you can transform any to a simply by calling . So to start off, we can create a wrapped enumerable: 

Comments Comments should be there to explain something that the code itself can't. Many of your comments just repeat information already expressed just as well by the code you're commenting. For example: 

Let's address these one by one. Seconds As you can see from the description above. Seconds are really simple. We really only need to decide whether they're greater than or equal to 30, then we can forget about them. But look at how much complexity they have in the code: 

This is a bit better for readability, and shouldn't have any cost in efficiency as LINQ short-circuits with All. I also switched your for , just to save an unnecessary call if you end up with some other kind of collection. You should also check if you really need that . If not, you can further simplify to 

What you could get is multiple threads calling , waiting on that lock, then one at a time they run the code inside the lock. That's inefficient but shouldn't lead to any actual bugs. If you want to avoid this, you could put a lock on the expiration check. However, I'd suggest profiling this, because this will potentially be hit many times more than , and potentially may have a greater performance cost. Another alternative might be to have the an initial expiration check as it is, then a second, identical one inside the lock, returning immediately if it hasn't expired. This will mean most calls will be able to go through without ever hitting the lock, and if multiple threads do end up entering one after the other, only one will actually do the expensive value calculation. Again, you should choose between this and one of the other two based on profiling with what you think are reasonable expiration intervals.