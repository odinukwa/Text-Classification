Or maybe you'd just pass them around as integers. Likewise whether was a public method somewhere or a private method, or even in-lined in another method, is really just a choice about how to organize things to read most clearly, rather than about design. 

Usability None of your requirements actually say anything about looping until the user enters some special quit code. Is this really what you want? Have you considered just running through the process once? Or looping forever, forcing the user to quit out by using whatever means the console provides for doing so, rather than providing your own mechanism? This is somewhat a judgement call, but having to enter a specially defined magic number in a particular place isn't a very user-friendly way to quit a program, so either of the above might be a better user experience. They also mean you now have a simpler program- you want to guard against adding extra code or features that don't actually match any of your requirements. Similarly, do you actually need this question/answer style? Would receiving the information from command line arguments be acceptable? If so, you could cut your entire program down to a few lines. 

Integer parsing It's generally considered bad to use exceptions in normal control flow. That's what you're doing here when you try to check whether the text in is a valid integer or not. An alternative, which you may not have known about, is . This method is designed for this exact situation- where you want to check whether a string represents an integer, but don't want to throw an exception if it isn't. This allows you to get rid of that and clean that bit of code up a bit. Simplifying statements If you ever have an statement which reads: 

There we go, that's all we need for seconds! Minutes Now we get a bit more complex. We have two questions to ask here: Will rounding up minutes put us into the next hour? What will the minutes value be after we've done any necessary rounding of seconds? In your code you've handled this with a bunch of special cases sprayed all over the place of minutes being 59. But again, there's no need for that! Let's start with the first, again as its own method: 

I agree that having to throw that exception to appease the compiler is ugly. There's also another bit of unpleasantness which isn't quite so egregious, but helps point to what's actually wrong here: Your while loop condition is 

For an example of how you might use some validation with this class, consider adding the rule that the salary must be non-negative. You can do this by altering the property like so: 

So, can we avoid it? Well, when you call the method, you already know what your two types are. Code with that knowledge should also know how convert between the two. So why not delete all that code and just write: 

So if we removed this class, how would printing and searching be handled? Or is having them where they are valuable enough to justify the class's existence? Removing 

Finally in addition to that we need a way to indicate when we're done, which is when while bouncing, instead of ascending to another invocation, we get a return value from our invocation. Limitations While this was a fun experiment, it has significant enough limitations that I doubt there will be many applications where it's really appropriate, especially since the alternative always exists of simply converting any tail recursive method into a loop. I'll list the main limitations here mainly so they don't get repeated in answers, but also in case anybody has any suggestions in alleviating any of them (which fit within the scope of a code review, anyway) 

Unfortunately as you can see, this is pretty quickly going to end up with a load of really similar methods, all of which are frustratingly large. The solution to this is two-fold. First, because the only difference between the methods is which function we call, the use of can cut it down to just one method: 

Also, this may have just been because it was an example, but is a bad name for a class. A is a , it shouldn't be a . That violates the Single Responsibility Principle, as it now has to take responsibility not only for what it's actually supposed to do- represent a user- but also do at least some management of its own persistence. You also have a similar problem with your actual class, though it's not reflected in the name. By putting the method on the user, it now has to be concerned not only with what it actually is, but with how to persist itself This is related to the actual meat of the question. Your first step should be to separate your class out into and like so: 

Altough there was a very simple answer in this particular case, in general, if you look at a method like the one you wrote, the very repetitive code should stand out, and you should think "loop". In fact, a good starting point is to just say, in plain English, what you're doing with what you've written. Something like: 

For more general comments, there isn't much I can find to fault. There's a couple of times you declare a variable, then only use it once in the next line. Not doing that means you can get rid of the cumbersome name . Also, you should probably trim out some unnecessary comments. If you're just learning F#, the idea that the last expression of a function is what gets returned might cause enough cognitive friction for you that you want to leave yourself a comment, but those shouldn't be in part of a finished piece of code. Generally, though, stylistically the code is good, including both naming and organization. 

If the answer to question 1 is no, then you're done. A nice simple design along the lines of the previous outline will be fine, and anything much more will be needless complexity. If the answer is yes, then the second question becomes relevant. So a focus for the rest of the review will be ensuring the answer to that second question is no. Adding a success threshold and subsequent refactoring One difference between this implementation and the description in the article is that in this version, the circuit breaker can only ever stay in the half-open state for one execution. If that execution is successful, it moves to closed, otherwise it moves to open. In the article, the transition from half-open to closed has a success threshold just like the transition from closed to open has a failure threshold. This is something that really should be in the design, in addition to being an illustrative driving example for refactoring. So how would this be done with the current design? We'd have to add three members to the interface: , , . Then we'd have to update the circuit breaker concrete classes- or potentially a base class if we had one- to implement them, as well as the private backing field. And the only class that will actually want to use this isn't the circuit breaker itself but the . This smells of feature envy. A good option is the usual one for feature envy: move the members that only particular states care about out of the interface to the state class. So let's go through the interface members one by one and see what can be done with them: 

Simple as your algorithm is, you're already running into limitations by coupling these two pieces of functionality together (which, by the way, makes this an excellent object lesson in the importance of the Single Responsibility Principle!) Namely, in your question, all the colors are red, and in your answer, you're still getting colors following a completely deterministic numeric pattern. Depending on your offset, this pattern will be more or less obvious (it's not just low vs. high- I'm pretty sure there's an offset which would give you the first image with red turned to blue, for example). So, let's see what we can do about this unwanted coupling. 

It's less code, just as readable, and no less flexible or extensible than what you have. If you imagine some possible extensions to this class- maybe pass a second string into the constructor which would get added onto the end of your "Hello World!" message, or a public , you'll quickly realise it either makes sense for all of it to be static or none of it. If there were going to be multiple instances, there's no reason they'd all want to be looking at the same string. 

For , you're again increasing the complexity by completely changing your data type, from a list of factors, to a map of factors to the count of those factors. This isn't actually that hard. For a single number n it might look like: 

There's likely still scope for improvement- e.g. adding a better way of doing exception/error handling and logging, dependency injection. But those would be beyond the scope of this question. 

Naming By convention, variables local to a method should be camelCased. You seem to have a mixture of PascalCased and alllowercase, making it hard to see at a glance what a variable is. All lower case has the additional disadvantage of being hard to read. Your boolean check variables also seem to be named in the form 'VerbNoun'. This is rather confusing because it's usually how methods are named. It sounds like they're supposed to do something. for example sounds like something that validates a port. A name like or perhaps more clearly states what the variables are. Extracting methods Looking at both of your methods, they have the same structure: Check if something is valid, if it is then change the state of the form one way, if it isn't then change the state of the form a different way. Each of those are basically completely separate pieces of functionality, so I'd suggest separating them out. This would turn , for example, into: 

For added support, you might consider implementing the interface. This is relatively straightforward and probably best demonstrated in the linked article. For specific types such as , and you might want to implement your own conversion, but otherwise, the simplest approach is to convert first to a common numeric type (probably ) then call the corresponding method on the result. 

The second point is rather more difficult to deal with. While it would be possible to move the logic for matching against an individual username or email to a class, it would be hard to do that in a way which EF would still be able to translate to SQL. To avoid adding a lot of complexity, it's probably best not to try to do this. Do make sure your validation won't allow for usernames and email addresses which could match, though! 

Note that labels are now appended before calling into the method recursively, rather than at the beginning. This is so that we can do: 

Is the comment because it's not clear what "balance" alone means? Then change the variable name to and lose the comment. State consistency The problem description requires being able to do things with both the monthly and annual interest rate. However, that does NOT mean you necessarily need a field for both of them. As it stands, now has a requirement for being in a valid state: It much be the case that = . It's not inherently a problem that your class has a requirement like this. They are referred to as invariants, and as long as you don't publicly expose anything that allows any calling code to break it, it's fine for a class to protect its own invariant. In this specific case, though, it's not just an invariant but also a DRY violation- you're representing the same knowledge in two different places. It would be easier to just store a single version of the interest rate, and have a private method to translate it into the other version when needed. This reduces the potential for bugs, since you aren't always having to update two values when you really only want to change one thing. Note that you do already have bugs of this form: the constructor only sets the annual interest rate, and only sets the monthly rate. Naming Your naming is generally good, but you switch between and arbitrarily. You should drop the underscores. Also don't automatically add "set" when it's not needed to a name. is a strange phrase, and would be more natural as or . I'd also consider renaming . implies it's going to give me back the answer to some question, but actually it's changing the underlying state. Something like or even might be more expressive. Separation of Concerns You generally do a really good job of separating out concerns, the only place this falls down is in the method. This should return a string rather than printing to screen. That way your doesn't care about what kind of IO you're using, and you could just as easily use the same class save that information in a file, send it through a webservice, email it to someone, show it in a GUI, etc. Misc 

And here's the initial shift in perspective: don't call that a partially-implemented . Call it a fully implemented . So what does that achieve? Well, it means the class you just wrote is definitely going to adhere to the OCP- you can be as confident as it's ever reasonable to expect to be that you're not going to have to go in and change- or even decorate- that class. Fine. But it also seems like an exercise in rug-sweeping: what happens when you need some code somewhere to handle additional responsibilities relating to reading code files? Well, here's where the second perspective shift comes in. You should not be trying to create a high-level design in advance to meet all possible future requirements. As an example, let's take the again. Now imagine I gave you the following new requirement: 

Realistically, it's unlikely that you're ever going to write anything that consumes directly. Instead you're probably going to have .NET library methods do it for you. For this reason, consider using explicit interface implementation so that doesn't clutter up your class's public interface (e.g. in IntelliSense) unnecessarily. If you do want to be able to compare versions individually rather than as a sort operation (e.g. "Is the current version installed less than the latest version?"), you can implement the comparison operators as RobH suggests 

Both are s, and in neither case is that really very helpful. But the first provides useful information: that a record was not found, and the id of this record. That immediately means that a person debugging could look at the state of the database, or try to understand why an incorrect id was passed to this method. While somebody could work out that no record was found from the stack trace alone, there's no possible way they'd be able to get to the id, so really the message is just a human-readable way of presenting that potentially vital piece of information. The second, on the other hand, provides nothing useful. "An error occurred", well, we already knew that. "While processing the record"- that's just a much more vague restatement of what we'd get from the stack trace. Handled Here's where it gets more interesting. When we throw an exception that might be handled, there's a new, very important, concern: abstraction level. And this is what the MSDN quote is getting at. As an example, let's take the good old "repository" abstraction, where we have an which hides the consumer from having to worry about how data is persisted. Yes, in reality it's more often than not unrealistic that we'd write an application where we needed to swap in and out totally different types of persistence, but it makes for a nice example. So take two concrete repository classes: and . The former stores a as a row in a table in the database, keyed by the id. The second stores the as serialized text in a text file in a particular directory, named {id}.txt. Now let's look at our method. What happens if I pass an invalid to either of these? Well, they both throw exceptions, but they both throw completely different types of exception. One throws perhaps an (if using like in the example) or , the other throws a . That makes perfect sense, but the problem is they now get thrown up the call stack, through that abstraction layer, and suddenly our abstraction is leaky. No caller could hope to handle these sensibly without also knowing what all the possible implementations of are. In fact, they not only need to know the broad classes, but very specific implementation details. Does a SQL-based repository throw or ? Does a file-based repository throw or ? So in order to maintain their abstraction, the repositories should all throw exceptions that can be understood by the calling code. If they need to signal a particular problem with a particular type of exception, this should be a common exception, which describes the problem at an abstraction level understood by the catcher ("Record not found") rather than a level understood by the thrower ("File not found", "Sql record not found"). Going back to the examples in your question, neither of them do this well. Useful information is only provided in a message. Assuming we're not going to try to parse that message to get useful information out of it (which would be a dreadfully complicated and error-prone way of going about things), no caller can do anything useful with these exceptions. does not specify anything about what went wrong. On the other hand, YAGNI is very relevant here. If you control the code which calls this method, and you know that this kind of exception isn't going to be handled, then going out of your way to define custom exception types to then ignore would be pointless. But the key point is that when writing code which throws exceptions that may be handled by its consumers, ensuring that it throws exceptions at the correct abstraction level is a very good reason for wrapping. Conclusion That was longer than I anticipated, so just to re-iterate the good reasons: