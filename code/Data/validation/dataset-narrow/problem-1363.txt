I have recently implemented a similar scenario in my game. I have the same principles (e.g. no friendly fire etc.), and this is how I've done it: 1 . All objects (even Environment) have a PlayerID property. In your game, for example: Environment.PlayerID = 0, Player.PlayerID = 1, Enemy.PlayerID = 2 etc. If a bullet is fired by the player: Bullet.PlayerID = 1, and so on. 2 . The first step in my collision detection is to check if the two objects I test for collision are actually the same. The second step is to see if their PlayerID's are the same: 

Things like the \data folder are included with the folders from \source, even though they are in different directories and levels. What I also want to know is how to go about including folders and files from different locations and treat them all like they are all in the same place. But most of all, I would like to figure out how they made all source files act like they were all in the base folder, instead of the separate physical folder that they are, as shown by the s in the files: 

Take a snapshot with the method. Load the resulting data into a with the method. Render the Texture2D. 

The PlayerSkill's constructor should create a reference to the relevant SkillInfo instance based on the SkillInfoId property. This way, if you serialize the player (when you save the game), only the SkillInfoId will be stored. Consider the scenario, when you want to create a patch for the game, that changes the Weapon skill's description. This way, you only have to upgrade it in one place (weaponskill.xml). And as Sean said, you (or your artists) won't have to recompile the game exe. 5 . The basic principle you should follow: The source code mustn't have any "content". Content here refers to descriptions of skills, skill names, NPC names, experience level values, sprites, 3d models, animation durations etc. Keep the logic and the structure in the code, and the content in external resources. 

...and debug printing to the console CONFIRMS that the OpenGL context was created before the texture loading was attempted. So my question is if anyone is familiar with this specific error, or knows if there is a specific instance as to why SOIL would think OpenGL isn't initialized yet. 

Since it points to the line where SOIL tries to access the OpenGL extensions, I think that for some reason SOIL is trying to load the texture before an OpenGL context is created. The problem is, I've gone through the entire solution, and there is only one place where SOIL has to load a texture, and it happens long after the OpenGL context is created. This is the part where it loads the texture... 

When you start the game, create a new instance of by deserializing an XML that defines the assigned keyboard controls (let's call this instance ). Then in your game code: 

The reason I'm using CardId's instead of CardName's, is that your card names might change with localization, or patches (typo fixes etc.). If you associate an Id with each card, then you won't have to worry about those changes. 

The third parameter specifies which parts of the sprite you wish to draw. From MSDN: sourceRectangleType: Rectangle? A rectangle that specifies (in texels) the source texels from a texture. Use null to draw the entire texture. You should change your code to something like this: 

Sorry for the long post, and any help would be greatly appreciated. You can find my entire solution on Github here. 

This seems a little too circular for me, and the main problem that I'm not sure will work or not happens if is called. If this method is called, it is placed on the stack and then calls , but this method deletes the calling object. I know objects can "commit suicide" but I dont know if that makes it so the calling object can be deleted before returns. Anybody who could confirm if this method works, or even give a more efficient solution (as I'm sure there is) would be greatly appreciated. 

You should google for the keywords 'database normalization'. A good practice is to normalize to 3NF (third normal form). 

How close is your release date? (You have one, right?) How much faster would you be able to finish your game with this newly discovered method? How much extra value would the new graphics add to your game? Would it look better? How much existing content will you have to remake if you decide to go with the 3D models? Do you have the right tools (licensed or free) to create 3D models with animations? Do you have the skills to make the new graphics look at least as good as the current one? 

I am making a voxel game (a bit like Minecraft) in C++(11), and I've come across an issue with creating a world efficiently. In my program, I have a World class, which holds a 3D array of Region class pointers. When I initialize the world, I give it a width, height, and depth so it knows how large of a world to create. Each Region is split up into a 32x32x32 area of blocks, so as you may guess, it takes a while to initialize the world once the world gets to be above 8x4x8 Regions. In order to alleviate this issue, I thought that using threads to generate different levels of the world concurrently would make it go faster. Having not used threads much before this, and being still relatively new to C++, I'm not entirely sure how to go about implementing one thread per level (level being a xz plane with a height of 1), when there is a variable number of levels. I tried this: 

This already narrows down the cases, but I added some further optimizations: 3 . I have a Collision class: 

You will probably find what you're looking for here: Steering Behaviors For Autonomous Characters Maybe in this article: Steering behaviors (full article) 

The most important thing to notice here, is that each tile has an ID. The basic info (coordinates, sector ID etc.) are stored in the 'tile' table. A 'player' will just reference a tile by its ID. This way, I don't have to store duplicates of coordinates, tile type etc. When I want to know where a certain player is, I do a query like this: 

I'm trying to implement zooming on my 2D game. Since it's using orthographic projection, I thought it would be easy to implement zooming. After looking around the internet, I found a bunch of explanations and samples on how to do this if (0,0) is the center of the screen with the orthographic projection. The problem is, my ortho projection has (0,0) at the top-left (similar to XNA/Monogame, and a couple others). I could not find any examples about how to implement zooming to the center of the screen when the center is not (0,0). And help/links/code examples would be greatly appreciated.