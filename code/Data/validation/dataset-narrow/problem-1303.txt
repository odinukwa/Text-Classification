Doing the slots with such flags makes it rather easy to define new slots, create special items that can fit either slot (e.g. multiple ring slots or the ability to wear a ring around the neck, etc.). 

For a very minimalistic car you won't need anything other than two values: and . Both values can be just a floating point number. When steering left/right, adjust the , which could be as simple as being the angle the car is facing. Accelerating or breaking will modify the . 

Your problem is most likely the fact that you create copies of your blocks when adding them to your vector. That way once the original copy/block is destroyed, the texture won't be valid anymore (since there's a shallow copy happening, so even the new copies still point to the old texture, despite having their own copy). As a potential fix, change your vector to and only store pointers in there (don't forget to free the memory later on) or use smart pointers straight away. 

Once this is done, you can simply compare the x and y coordinates to determine in which direction the collision happens. You can also calculate how far these overlap by doing some more math with coordinates, e.g. using something like this: 

First of all: Don't just block user input as done by some games. It creates bad user experiences. One popular example: "What a horrible night to have a curse." (Castlevania II - Simon's Quest if you didn't know it. Lookup the Angry Video Game Nerd's review on YouTube. You'll get what I'm talking about.) For dialog/story elements or tutorials the user should be able to read without having to worry about the actual game (i.e. longer texts): Stop the game, then show the dialog using some kind of animation (even if it's just some kind of typewriter effect revealing letter by letter). Assign some "advance" key, usually what you'd use to shoot or jump. If the user presses this key, the animation is speed up and once it's complete, another button press (holding down the button shouldn't work so people can just skip the animation if they want to) will hide/advance the text. For short messages: Consider showing popups without backgrounds. Again, animations (e.g. floating in/out) can help to blend these without surprising users ("uh, was there some text for a moment?"). The user shouldn't have any influence over these messages, but they shouldn't halt gameplay either. 

As an alternative, you can of course compare the different values on their own using some loop and multiple comparisons or create one string with positions and one with rotations, etc. 

If you're using fixed time steps in your logic, you can just assume being , which makes the whole calculation even easier to be done. The velocities become simple deltas and your acceleration essentially becomes a constant velocity: 

Blame me for never having played any of these games, so I can just assume you want your character to turn around while walking rather than turning instantly (e.g. like in The Legend of Zelda games or most JRPGs). If so, I'd simplify the whole thing using "steering": 

Have some kind of bitmask/array to mark boxes as "done". From left to right top to bottom, pick the first box not marked as done. From there on walk to the right as long as the boxes are filled and not yet "done". Once you hit the end of the map or some not occupied box, go down as long as these rows are identical (i.e. same boxes filled). Mark all boxes selected that way as "done" and store the rectangle. Repeat starting with the step 2 till all boxes are "done". 

Depending on your actual number of frames/updates this might be neglectable though. (And there isn't really anything you can do about this, other than trying to pick sane numbers/scaling that will work for you.) 

As a suggestion, start easy. Write a simple pass through bridge that works with any simple protocol. For example, IRC or HTTP. Read the incoming data on one end, send it out on the other end, and possibly print it to a console window. Once your "http proxy" works, you should be able to use it for Starbound or any other game with some minor modifications. 

Disclaimer: The following might be a bit biased, since I'm both a native German player as well as (professional) video game translator. So, sorry for that. But I think I might be able to provide you some insights. I'm not trying to sell you anything. :) Want to know what got me into this business? Being annoyed by bad translations in my favorite game(s) and complaining continuously about them. After all the years I'm still doing this mostly due to me hating bad game translations. You don't get rich in that business (unfortunately). ;) 

I'd just say memory restrictions: It's far easier to use a relatively small texture (either due to hardware restrictions or for performance reasons) and just repeat it over and over again instead of mapping the whole sky "as is" as long as it's no core gameplay element (and just decoration). This has been even more noticeable in old games, e.g. on consoles from the 80's or 90's where you usually had a very simple pattern (if any at all; i.e. 1-2 stars per tile only). From time to time devs still tend to include some well known constellations just for people to notice them. Two examples coming to my mind, first one being Illusion of Gaia (known as Illusion of Time in Europe), where the Cygnus constellation played a major role in the plot (the red "star" is meant to be a new star that appeared heralding things to come): 

This is a bit complicated, so here's the simplified variation assuming your value's range is always from 0 to 1: 

Now that you've determined that the space is not empty, you're able to do the next step, the technology level/anomaly type you've described: 

This is really hard to pull off, because real concurrent editing (on the same files) can be rather tricky. I'd focus on some source code versioning system like SVN, Mercurial, or Git. If you're using Visual Studio, the best option would be using their Team Foundation Server or - with the addon being in beta right now - Git. Setting up a Git repository isn't that hard (you can also use third party hosting like the on provided by GitHub and others). You'll then just have to install the Visual Studio Tools for Git to interact with your repository, sync code, etc. This will require some setup and getting used to, but it should help you a lot merging changes and conflicts (i.e. when someone is editing the same files at the same time). If you want fully automated syncing, you should try Dropbox, Cubby, or BitTorrent's Sync. These work more automated, but will give you trouble if both of you edit something at the same time. 

If a member is marked as , you'll always call the most derived being available. Using an abstract base class is similar, but compared to interfaces this allows you to already implement parts, while leaving others unimplemented (they'll have to be implemented in derived classes). 

As you can see, I've added a new armor type: cloth. Let's ignore that for now. While this looks similar to the tables the others have provided, I still think it's the best and most realistic of them all. Of course some choices are up for debate, e.g. blunt vs. plate (are you breaking the plates rather than poking around them?), but it works pretty well overall. As for the other armor types vs. damage types you can clearly see that each and every weapon and armor has one strength (), one weakness (), and one neutral () counter-part. This ensures that there's never any significant (dis)advantage. What do those modifiers mean? If some weapon is effective, it will deal 50% extra damage, while being ineffective will deal 25% less damage (50% sounds a bit extreme here). To spice things up, armor items in DAoC give you a specific amount of armor rating per level. Leather and mail armor both grant you 100% of that value, plate provides 125%, and cloth only 50%. (Spellcasters have their own spells to double their armor rating, which makes cloth unattractive for others, while countering this disadvantage.) But does this make plate armor the best choice again? Not necessarily. This really depends on many other factors. In DAoC you were simply forced to wear some specific armor type at most, based on your class. For example, a sorcerer could only wear cloth, while a paladin could wear any armor. More recent games, like The Elder Scrolls Online, allow the player far more flexibility. To balance things out, they tie specific passive bonuses to armor pieces, based on their classification. So rather than using the armor modifiers (50%/100%/125%) above, in your own game you could grant cloth a bonus to mana and/or spellcasting, or just magic defense. Leather could gain benefits when using endurance focused things (archery or stealth), and plate would still retain better defenses or simply more health. Chain armor could remain as a neutral choice in the middle. Of course you could mix and match all of them, but this is really just a question of your actual game mechanic design. 

Yes, that's how simplified gravity (or acceleration in general) works. You might want to limit your velocity (and gravity) to something (in reality: terminal velocity), e.g. 

What you're looking for is framerate independent movement. There are basically two different approaches available: 

Of course it is. I've only seen very few games implementing their own limited input buttons, but never a full keyboard. Based on the framework you're using this might be tricky to get it working, but overall, it shouldn't be a problem. 

How about implementing a stack of states rather than a single state machine? Events and callbacks (updating, input, drawing, etc.) are sent to the topmost state. If they're unhandled, they're passed to the next state, etc. For example, your character only has the on its stack. This handles movement as well. So if the player hits a directional key, this adds another state, e.g. . This state will handle the transition/animation and remove itself once done. Let's assume there's a toggle to make your character take flight. So once you hit the hotkey, the state is added. won't handle movement, so input events related to movement are passed down the stack to , which will once again add a state, e.g. . If your notices the hotkey for state change to be hit, it will remove itself from the stack and pass control back to the state below (typically ). Of course this has other potential problems, like trying to modify some state in the middle. You'll have to come up with proper states and flags/status fields. Don't create a state for every tiny bit, just because you're able to. 

The source engine doesn't clear the back buffer simply due to the way levels are setup (i.e. it's not needed). Source engine levels are built from brushes (i.e. volumes are either added as solid/liquid or subtracted from other brushes) and the player (or more specific, the camera) is always in an enclosed space, even if the level is supposed to be outdoors. Areas where you see the skybox are actually the surfaces of brushes marked as "sky". I've had a random look at YouTube and the first hit I've found explains level building pretty well. Watch it from about 1:45 to 2:15 to see the "sky" being set, then at the end of the video you'll see it in action. So why not clear the back buffer? Performance. Clearing the backbuffer would solve glitches you can see when the camera gets "outside" due to a bug, but in standard gameplay you wouldn't notice this anyway. So if it doesn't make any difference, you can just skip it alltogether. Clearing the back buffer has a complexity of O(n) depending on the number of pixels on screen, doing nothing at all would simply be O(0) (well, that isn't defined, but I think it pretty much shows the idea). 

When I read your question I immediately had to think of the GameBoy game Mario's Picross. It's essentially a Nonogram game: You're supposed to find the right tiles in a grid identified by numbers (similar to how Minesweeper works, but with different mechanics). By default, you've got 15 minutes to solve a puzzle, which is plenty of time. However, whenever you make mistakes, your time remaining is reduced (the more time you have left, the more you're losing). This adds an interesting tension to the game: You'll want to solve it fast. You can take your time, think 5 minutes about the problem, and then start solving it. Or you can risk it and start straight away. If you make a mistake, you won't be faster or better compared to the slower approach, but you've still got the option to do so. Depending on your game, I could imagine that some similar mechanic would fit rather well into it. It should fit the whole timed approach and the actual theme as well, without having to explain anything special: If there's some intruder, if he's doin mistakes, he might be a lot easier to spot.