At the bottom of every app's page in the app store on the phone is a "Report a problem" button you could try, but I suspect the best way is to have your friend's lawyer handle it (and if your friend does not have a lawyer, he or she may want to consider finding and talking with one). 

I suggest you use "Exit Game" on the main menu to mean returning to the desktop or to the dashboard. It's nice and brief, and my unscientific survey of screenshots/videos of some Xbox game title screens all seem to use it. Within the game, use one of: 

Unity supports several renderers for its various platforms, Direct3D and OpenGL among them. You can find references to this fact in the release notes, for example, and in this documentation explaining some differences between renderer implementations that users should be aware of. It appears that by default, Unity will use D3D on Windows. You can force it to use an OpenGL rendering path, apparently, via a command-line argument (although that thread is quite old). Configuring the rendering path in your game settings appears to be more about deferred versus forward renderers, and not the underlying API used. 

Much like any of the other designers in Visual Studio, you actually have to have a file of the appropriate type in your solution, and then the designer will launch every time you double-click on the file (or until you change the designer association for that file type). For the shader designer, the file type is . Simply add an existing file or add a new one (the template should be under the "Graphics" sidebar heading in the Add New Item dialog), and open it and the designer will fill the main view. More information can be found on MSDN here. 

Position and color are each given their own vertex element, and (importantly) the color element specifies an offset of since the position element consists of three floats. Second, you need to make sure your actual vertex data (and thus the vertex structure) matches this declaration. Your current structure has three floats for the X, Y and Z component of position... but only a single float for color. Color is generally a three or four component float (or a 32-bit integer). In the above example, I changed your declaration use , which is the 32-bit integer version where each RGBA color component is packed into a particular byte of the integer. Thus, your vertex structure should become: 

If you have a matrix that transforms from object to world space, the inverse of that matrix will transform a world space value to object space. 

Your code only ever instructs the boss character to move in one direction, forever. You set the X component of the motion vector to 1 when the score is greater than 200, and then increment the boss's position by that value. You never attempt to check if the boss's position after incrementing is within an appropriate threshold of the world boundaries and, if so, set some state to move him the opposite direction. A simple way to do this would be to check if and if so, set to be -1. Do the same for the opposite edge of the screen. 

"Casual games" are targeted at a wider audience than other (often considered more "hardcore") games are. Typically this is accomplished by having simpler game mechanics and controls that are easier to pick up and understand for people who might otherwise not play very many games, and by being much easier to pick up and play for brief periods of time (such as while travelling on a bus). Early casual games were primarily played through web browsers (via Flash portals). While such games are still around, the rise of the smartphone platform has allowed many casual games to migrate to those devices. 

If your sprites are high-fidelity (for example, 3D models rendered into a 2D sprite sheet), than you probably want to encode the rotations into the spritesheet. Not for reasons of performance, but because the sprite probably will not look as good if you rotate it at runtime. If your sprites are such than they can survive such a runtime rotation acceptably, then that is going to be the more efficient solution in most cases. This is because: 

The vertex buffer object APIs were added to OpenGL's core API in version 1.5. At some point, they were available as extensions, such as . Wikipedia has a good overview of the version history of OpenGL. 

Have your people call their people. You need to find contact information for the appropriate business/legal department (or person) within the organization that holds the intellectual property rights that you want to license. This can be a single person, in a smaller studio, to an entire department (at a large publisher for example). This may be difficult to do because that information isn't always readily made available on a company's website: you may need to resort to calling reception and asking to be put in contact with the appropriate person, or mining some industry contacts you may have to arrange a meeting. Note that you can expect a prolonged series of discussions and meetings, during which you will likely need to discussion with the IP holder many of the details of your project, your financials (current and future projections based on your use of the IP) and many other business tidbits. This is a business deal, after all. If you don't have your own business/legal representative, consider retaining the services of some kind of lawyer for the purposes of brokering the deal. They are likely to be far more knowledgeable than you in the details of IP law and the associated licensing agreements: you are extremely unlikely to get a blanket, informal "sure use our characters" grant of permission from a savvy IP holder. You're more likely to end up negotiating some kind of contract, where they grant you some limited use of their IP in exchange for some combination of money, share, control over your project, et cetera. 

Parallax scrolling could be seen as a kind of differential scrolling. Differential scrolling is simply an effect whereby two (or more) pieces of content scroll at different rates proportional to the differences in some property shared between the pieces of content. For example, as in the demos linked in your second example. The three vertical columns of text in this example scroll at different rates (based on their length), but they aren't three distinct nested scrollable areas of content. The entire page still scrolls as one unit, but the shorter columns of text move less per unit of scroll because there is less content overall for them to scroll through. Parallax scrolling is a kind of differential scrolling trying to achieve a certain effect, specifically a parallax effect: 

In practice, lots of factors will be altered by a change in resolution (so all things are not equal). For example, it takes more processing power to render more pixels, and this can result in a decreased responsiveness to user input, conveying an advantage to the player with a lower resolution (and thus a higher responsiveness). The factors so impacted will vary depending on the specifics of the implementation of the game in question, and are far too broad to enumerate completely here. Beyond anything else, though, I suspect players who opt to run at lower resolutions or with lower graphical settings to convey an advantage to themselves do it either because it does give them a clear boost to their FPS or because they feel like it does. It's important not to overlook the placebo effect, the fact that if a player thinks they have an advantage they may play better regardless of whether or not they actually have one (the opposite is also true). Perhaps to reinforce this point, most players don't seem to really understand what "FPS" is measuring (and specifically, how it's a non-linear measurement) and will bend over backwards to push 5 FPS on to a game running at 500, not realizing how small of fraction of time that is. They nonetheless may assert that they perform much better at 505 FPS than 500, which is almost certainly attributed to the placebo effect. 

Update: It's worth noting, as discussed in the comments, that modern C++ compilers can perform a copy elision optimization that would allow them to eliminate the performance overhead of (1) entirely. This optimization was prevalent even back in 2011 when I originally answered this, so I should have pointed it out then. I can only speculate as to why the designers of the API in question chose to implement it in this fashion; perhaps they were being conservative or had reason to expect that RVO wouldn't or couldn't be performed in some important use cases (by contrast, you can see some API's like Apple's GLKit aggressive expect these sorts of optimizations, even in C, because they return entire objects like matrices on the stack; this may also be informed by knowledge of the underlying platforms calling convention, as well, however). 

There's a third option, one between "constants in the program" and "data in a database," and that's data in regular old files on the disk (for example, JSON files). If the primary operations you are going to be doing here are (1) editing the data files and (2) loading all the data into memory, you don't really need to employ the additional complexity of a database; you don't need the additional complicated query functionality and that way you won't have to manage the additional overhead of the table schema or deployment problems (for non-trivial games). If your searches are simple enough (it sounds like they are primarily compatibility-matching searches), you can do them easily enough without a SQL query. Although SQLite specifically is a compact exception, many database solutions are overkill for this kind of simple data-driven game data problem. Even if you opt to put the data into SQLite or some other database eventually, moving to a file-based approached first might be a good stepping stone as it will allow you to reduce the scope of the overall change slightly, letting you get your work done in smaller chunks. As for knowing when to put things in data versus code... it's almost always better to put them in data, unless you have a really trivial project. What kind of data format you use depends heavily on the kind of project, and often a really good data-driven architecture (that supports awesome things like live-edit loops and cascading hot-reloads) can be more work up front, but in the long it's usually far more efficient. The value of searching and sorting depends, again, on the way your game will use that data. It's really rare, in my experience, that you'll want the user to be given an interface (of any kind) to a search that is complex enough to warrant SQL. However, if the data you are tracking is analytical in nature, for example, if you are tracking events users perform in an online game and you'll need to query that data after-the-fact to discover user trends and help tune your design decisions... in that case complex queries are a good thing and you can justify the extra complexity of a database backing store. But then again, that's not constant data we're talking about. 

I don't have examples readily available, but obfuscating your code will not really provide any significant advantage in preventing piracy of your application. Piracy is typically accomplished through hacks that bypass copy protection or DRM checks, which can be done at the machine code or VM opcode level. No amount of obfuscation of the higher level code prior to letting it get compiled to machine code or the intermediate representation used by a VM will help you at that point. I would not bother. 

The EULA states that you need to pay Epic 5% of the gross revenue attributable to your game. However you are exempt from this for the first $3,000.00 in gross revenue for each game per calendar quarter. Note that gross revenue is not your profit. It is the amount of money generated by your game; if, for example, you sell your game on the iOS app store for $0.99, and you sell 4000 copies, that is a gross revenue of $3960.00 even though you actually see less than that due to Apple's cut. Epic's example is as follows: 

I am not a lawyer, and you should consult one for legal advice, particularly given that you intend to be doing something with Nintendo's intellectual property (they are particularly litigious). That said, modding a game is generally legal if: 

Probably, the terms "model-view-projection" matrix and "world-view-project" matrix refer to the same conceptual transform. The two terms can be used interchangeably, and the difference in terminology could stem from one source being more familiar with OpenGL (which uses the term "modelview") or D3D (which splits the concept into "world" and "view" transforms). The "modelview" transform bring an object from model space to view space (conceptually passing through world space on the way). The "world" transform would bring an object from model space to world space, and the "view" transform" from world to view space. Thus, the combined "world-view" transform is equivalent to the GL-style "modelview." Obviously, then, when you tack on the projection transformation at the end, you get the same logical origin (model space) and destination (clip space) spaces. All of which is a roundabout way of saying that the problem you're seeing in your code is likely due to the values you're assigning to these matrices before you present the scene. Unless you're using some seriously non-standard terminology, there's no way to convert between a "modelview-projection" matrix and a "world-view-projection" matrix because they are the same thing; there isn't even a need. I'll point out that your shaders aren't exactly identical except for variable renames. There's also some input layout differences, it seems. But the actual problem appears to be in the C++ code that causes these shaders to run, not the shaders themselves. 

The left image is a single 64x64 tile, and the right is two tiles stacked on top of each other to allow for a different stripe angle. Similarly, you could use three tiles, or four, and so on. You will need a set of tiles for each edge angle. You will be able to mirror the tiles horizontally around the center stripe, and rotate them to handle both borders of an edge. Finally, you may need a single solid dark grass tile as well. This approach is fairly limiting, however, because the size of the tiles will determine how many angles you have available to you, and how wide your stripes must be (which may result in non-uniform stripe widths). You can alleviate the problems somewhat if you build your game so that you don't have to actually align tiles to a fixed grid, because you can tile the stripes "off the grid" and use only one tile per edge angle. At that point, however, you are already well on your way to my (and everybody else's) suggestion of not bothering to constrain yourself to a tile set anyway, and so you might as well go all out. 

The WebGL wiki contained a section in its FAQ hierarchy for "WebGL and OpenGL Differences" which seems to focus on differences in WebGL from "desktop" OpenGL implementations and, alas, isn't very detailed (mostly it's about behavior, not the API). If that does not go into enough detail for you, you may need to compare the latest WebGL draft with the OpenGL ES or OpenGL specifications manually. 

You can and should re-use vertex buffers when possible. It's a particularly bad idea to create and destroy vertex buffers for each object per frame, because the process of doing so takes a toll on both CPU and GPU resources. You should strive to have one vertex buffer per model under normal circumstances. That means if you have a goblin character in your game, you have one goblin vertex buffer. Even if you render fifty goblins, you reuse the same vertex buffer, chaining only the world transformation every time you render with that buffer. For some classes of object (such as purely static geometry) you can in fact pack multiple objects into one buffer, further reducing resource load. You should create your buffers as early as you can and release them as late as is practical; for simple games, you can create them all on startup and only release them on shutdown (in practice, for larger projects, resource constraints and optimizations may make it worth your while to initialize later or release earlier, but you certainly want to be far, far away from creating/destroying buffers every frame). You can update vertex buffers every frame, but make sure that when you do so you have created the buffer with the appropriate API hints that tell the GPU you're planning on doing so. This will allow it to prioritize the resource in memory appropriately.