Since these are constants, a common standard is to name the variables with all capital letters; you can do that if you find it helpful, but the important thing is to be internally consistent. I would take this concept (of capturing reusable strings in variables) a step farther for the element IDs of your daily deals, and throw them into an array of objects. 

Right now is a string that seems to be put together solely for searching through it. That has the potential to be a big performance bottleneck. If you change it to an array, you can squeeze a bit more efficiency into your code by sorting the array and then using a binary search method to detect whether it contains the desired value. Here's an example of a binary search method. 

Welcome to Code Review! There are a lot of things we can focus on here, so let's start with your request for suggestions around optimization. Native JavaScript will outperform JQuery Equivalents jQuery makes it easy to write working code quickly, but this is often at the expense of code performance. Converting jQuery methods to their native JavaScript equivalents can increase perfomance. 

I think one of the most common errors in today times, is for example handling potential errors, as you try to do here: 

True, the code is longer, however, it's commented, there is a clear definition of what the function will do, and what the user of the function can expect. Splitting up single parts of your code into there own functions is a good way of structuring your code, and promote re-usability. Now, another instant observation I might have is your interesting mix of different for statements. Especially seen that they are so close together, I really wonder if there was a reason for you to mix it up, or again, you felt like experimenting different forms of iterating an array 

Suggested rewrite ES6 If your code base is not to large, or if you are willing to put the time in for refactoring, I would suggest you wrap fetch with your own function, like in the following code sample. You know that will return a , so create your own version of , which you could then export if necessary, and redirect your files that point to the functionality to your own implementation. 

I have a fiddle demonstrating how the technique works, but it's polluted with logging and metrics, and doesn't have all the logic encapsulated into functions; I'd rather any critiques be directed to the above code rather than the code in the fiddle: $URL$ 

The performance benefits vary depending on the browser's implementation of ECMAScript, but you can usually get a modest performance improvement by selecting the parent element first, then selecting only child elements of that parent element. This jsPerf test somewhat demonstrates the difference. In native JavaScript, this is done by selecting the parent element with , , or . You can then call a similar selector method on that element instead of on to limit your search to only child elements. Native 

Sure, you can use event delegation for this. For the uninitiated, event delegation in JavaScript means attaching the event listener to a container element and using the property of the event to identify which sub-element was acted upon. You'll still need to crawl your way up the DOM tree to get to the root element, which can be done without knowing the DOM structure as long as you have a sentinel you can check, such as the root element's class name, to determine whether you've reached the root. Once you've made it to the top, so to speak, you can use query selectors to find your way back down to specific child nodes within the root element, again allowing you to grab or modify specific elements without knowing the HTML structure--all you'll need to know is a reliably query-selectable combination of attributes (such as an element class). Here's a working example with comments: 

This only gives you an idea from how you could reformat your code using this pattern. The last piece of code can then also be rewritten like: 

It returns it's own promise, and uses the . In case the result is returned (or another error is thrown), the is called and the promise gets handled by either resolve or reject. In case the interval occurs, the promise gets rejected, and the is also called. Note that if you run the test (at least the es6 one), you can see the time it took before the timeout occured, and it will not run longer. Neither does the then method of the fetch still execute. It is true however that your httprequest will still be open, but I don't think that should be such a huge problem, as it will not interact with your own code anymore. It is still important though to handle the catch of the fetch and pipe it through, so that the interval gets cleared, but that you also get notified of the other errors that might have occured during the request. 

Here are a few suggestions to start off: Understanding the Base Number conversions The base number system should be irrelevant by the time you have a number as a primitive type. It only matters when you're converting strings to numbers and vice versa. JavaScript can't tell the difference between and ; in both cases the underlying number is the binary ... the other formats are just to make it human-readable. So is functionally equivalent to ... in both cases, you're saying here's the number 30 (or if you like), please give it to me in decimal format; thus the output is always the number . The same is true when you reverse it with : both and will evaluate to . The question to ask yourself is: "Under what circumstances would an octal primitive be passed to my function?" Since JavaScript itself doesn't distinguish between octal, decimal, and binary numbers when it handles them in code, the question doesn't make sense except insofar as someone's JavaScript code could explicitly pass as a parameter. In such a case, the error would not be in your function but in the logic of the author who types and expects it to be parsed as a decimal instead of the octal number that it is. Determining the Class of an Object It's tempting to use to determine the type underlying a variable (that's what you'd expect the operator to do, after all), but its output is not always consistent. For example, will return when the underlying class is actually . On top of this, the return values of the operation are not defined in the ECMAScript specification, and could thus be different in different JavaScript implementations. Yikes! The only thing for which you should use is checking for an undefined variable, using the syntax Instead of using to determine the class of an object use . Here's the syntax for that: where is your variable. The reason we call at the end is because the function call would otherwise return when all we care about is . Semicolon Best Practices While JavaScript requires semicolons, the JavaScript parser is pretty forgiving about them: if semicolons are missing, it'll try to extrapolate the correct semicolon placement and insert them as needed. However, it's a best practice to explicitly identify the ends of lines. This not only saves the parser some work, but prevents it from making mistakes that can change the behavior of your code. Since you already have your code in jsfiddle, go ahead and click the "JSHint" button in the nav bar. It will identify lines where you excluded semicolons (such as at the end of a variable assignment) or added unnecessary ones (such as at the end of a function declaration). 

Ofcourse, as Vogel612 metnioned in the comments, this is not the most optimized way. I just presented it as a way that it contains less code, and that it is separated in single utility functions. The code from coderodde is ofcourse lots better. Instead of deleting my answer, I will simply add 1 more version how you could do it by using ES6 and classes 

I guess if you just want to validate, you could write something like the following, though i'm not sure if that really answers your question. 

This would now be an abstract class (ie: a class that cannot be instantiated), from which the method has to be implemented still. Also note, that this change means that all methods now changed from modifier to the modifier In the implementing classes you can then implement something like: 

Here you really have to be consistent with your choice. There is no reason why a statement brings benefit to your code, as you are iterating arrays and not an object. It makes the code less readable if such unexpected twists are added. Subtopic variable scoping The use of the keyword in JavaScript and it's scope has been confusing since the dawn of JavaScript. It is important to know that in JavaScript, defined variables are not block scoped, but they are function scoped variables, as this small snippet demonstrates 

createForm() I don't think you need the array or its named elements at all; you're not using it for anything. To build the form controls, you can loop through the array instead of the array. 

Caching references to DOM objects One simple way to optimize is to identify places where you're querying the DOM for a specific element multiple times, and replace those with variable references. 

EDIT: Efficiency Suggestion(s) Caching DOM Queries You can make the code in more efficient by getting all the necessary DOM operations out of the way beforehand. If you want to reduce the number of DOM queries (which are typically expensive operations) you can cache an array of references to all the relevant elements and then reference that array in the function. I know you're hoping for the "shortest and most efficient way", but this would be for efficiency at the expense of brevity, since you'd need to set up an extra variable to track the index of the active image. Using this index would save your code from having to read the current classLists of the images, requery the container element to get the active image, and traverse the DOM for the next sibling or first child. 

This you could extract to an own function if you like (I don't think I would need it when I check if I know understood your code correctly at the end of the response) 

for both if blocks. But that should not be the end, you might as well extract the code that checks if the keyword exists in the array, and the extraction of the keyword. In the end, the statement that you wrote can be reduced to this (now I think I understood your code while refactoring it) 

You also define some variables only inside the for loops and although in most languages that would be fine, in JavaScript 5 they don't belong inside the for loops. ES6 really made huge improvements by adding the block scoped keywords and , so if you would have the chance to use them now, I would really suggest you do so. So as a rule of thumb, keep all definitions on the top of your function, or where you define the first variable. Extract similar code to functions Code duplication is one of the most annoying things in a code base that you could have. Even if you know your code perfectly, still changes to certain parts of your algorithm could be forgotten if you copied the code to other parts. One piece of code that could definitely be extracted into a function, would be this beautiful block of duplication 

This creates a function scope around your code (function scope is the only type of scope in JavaScript), limiting those variables to use within that scope. Another related pitfall to watch out for is implicitly declaring variables by assigning them values without using the keyword to explicitly define their scope. There are a few variable assignments in your code where variables are unnecesarily scoped to global namespace, though defined and used only within functions. Textbox event choice For user-friendliness, I recommend attaching your event listener to the "keyup" event instead of the "change" event; that way the floor textboxes will update immediately as the user types a number instead of waiting for the input textbox to lose focus. Working example of some modifications Here's an example of your first linked jsfiddle modified to use native JavaScript and the other recommendations I provided above: 

Preferably though, the method shouldn't return anything that can be modified. I wish I could create it as an instead, however, that would not work with your method. As I do not know how you intend to filter, I chose to keep the . The filter also doesn't seem to filter, but rather seems to remove items from that list, so without knowing how you are using it, I chose to stick with . 

I personally prefer something like a generic class that allows me the re-usability of a single data structure for handling responses that might fail. The class would look something similar like: 

From the demo page, I have to say, it looks very nice. I am very curious why you do not use the constructor to call that seems a bit verbose for any user, neither does it look very good to use as it is not a constructor in the strict sense, you don't even need it. For a detailed description, please find it on MDN, where this explanation is of importance to you. If you return anything else but undefined, you will not receive a new Slider object, but just the returned object. 

For some browsers, the performance impact is significant. For reference, here's a relevant JS perf test: $URL$ Avoiding Unnecessary DOM Queries You did a good job by caching (that is, saving to variables) most your query selections up front. This is much better than querying the DOM on the fly every time you want to access those elements. There's only one spot where it looks like you're querying the DOM unnecessarily, inside your function: 

At the time of this post, arrow functions in JavaScript () are an experimental/proposed technology supported only by Firefox, with no stable specification. If you need to support IE9, IE10, IE11, Chrome, Opera, or Safari, you'll want to use the more verbose function expressions that they replace. As 200_Success noted, you'll want to encode the values returned, and also decode them when translating the encoded query string back into the original string. You can use and for this.