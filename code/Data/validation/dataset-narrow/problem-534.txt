This could be even a little shorter if you use list comprehension, yields and iteration to avoid all the if-tests (and, btw, use named variables instead of indices for clarity!) 

I don't think is a standard python construction - does it even execute? In that sense this does not look 'well formed'. Does this execute? It does not work when copy pasted but I think that's just formatting issues. It's hard to write this without some try's, since the standard string > float conversion method is 

Allows you to flexibly specify values while providing class level defaults that vary on application. Super (as mentioned in other answers) is great for avoiding repetition here. For example 

I'd start with the caveat that you're buying some syntax sugar at the cost of possible bugs - the need to do the attribute resolution, and as you point out the possibility of name clashes, makes it seem like it may not be worth the effort unless you need to access these class properties in lots of places in your code. That said you can simplify this by converting your sections - which are dictionaries -- to namedtuples: from collections import namedtuple 

function components If a lot of reasoning goes into the choice or relationship of the functions, you could just put them all into an object and work with those objects instead of loose funcs: 

Here's a couple of ways to shorten the code, which may or may not involve perf gains but may make it easier to work with. I tested this with plain lists-of-lists instead of numpy.arrays but I think it should work the same way. I used itertools.product to get rid of the nested loops and used sum() to avoid another loop. get neighbors will be called for every cell, and it's going to loop and iterate mamy times. You can get the same result by summing the rows of a subset: 

DarthGizka gave 2 good answers, and I agree totally with him (and you too) that your code shows too much overthinking. Your code has convoluted thinking and unnecessary variables like , , and . Note in my code examples, I will be using . For admitted beginners, I recommend they don't start out using , which you don't so I do credit you for that. See Language Guidelines - Implicitly Typed Local Variables for more. If you tried to be more DRY (Don't Repeat Yourself), you will probably discover your code is more readable and more maintainable. Your variable names are overall well chosen, except that underscores are frowned upon in variable names. See General Naming Conventions - Word Choice for more. I'd suggest you keep more simplified and put your code into its own class. And for your own interest you may want to time what's happening. I will do this using a but keep in mind the stopwatch will also be timing the jitter time too. And since you are new to C#, and possibly .NET, you should be aware that code running in Debug mode will be slower than in Release mode. Thus I encourage you not to use and instead use . One thing to be aware of with the console is that it may vanish upon completion of the exe, so you may want to request a or to view your output. Let's look at my : 

It appears to me that you may be a student or beginner with C#, so I will try to help to some degree. It was really hard for me to read through , so let's focus on cleaning that up while also improving performance. First and foremost, or in general is very sluggish, particular when comparing equality of objects. The smarter and cleaner way is just to compare the objects directly, especially integers. Before I get to that, I am going to mention some other things about your code for you to consider in the future. 

Another piece of python wisdom to consider is 'if you can do it with the standard library, do!' Field and record based storage is really easy to do with the csv module, which reads and writes comma-separated spreadsheet style files. A file formatted like this: 

When you're composing, think about how you want to access the components you're putting together. In this example, you are asking the window to include a DrawRect that always draws to a 50 x 50 pixsel square. Does the window really need to include that rect? The DrawRect has all the info it needs -- you add the window reference in the constructor -- so what's the rationale for including it in the window? In the example code you create a DrawRect outside the window, and another inside the Window - and then never update the independent DrawRect so it never shows up. This seems less like composition and more like gluing things together which don't need to be connected. Consider the alternative: 

From a style perspective I like the first option; if you're treating this as a property its clear what you intend For implementation, I'd try a class level default with an instance override to provide the right words to allow for specialization or extension (for other languages than English, say, or use at Oberlin College). Whatever your gender politics this implementation is extensible to new cases and one offs. 

This has a couple of advantages 1) not hitting the disk for every query will be much faster 2) the dictionary lookup faction is much faster than straight for loop comparison, since the dictionary uses hashed values instead of more expensive string compares. As an aside, you should look into readlines, which the usual pythonic way of reading text files with info on lines. For the longer term this is a great application for Python's built in database functionality (with the sqllite module). You could convert your existing text files into a sqllite database and then your lookups can be much more flexible and precise ('find spectrum and power for stars with id > X and < Y' sort of thing). You probably also want to set this file up so you could call it from the command line, which would involve using the argparse module to grab command line arguments and out them into known_stars, master_list and output_file 

I'd advise that if you're looking for 100% compatibility with here, you'll probably want some extensive unit tests. Here's what I came up with that handles the edge-cases I threw at it, but I don't expect it's bullet proof either. Main changes are using the format specifier, and using to get the number of digits before the decimal place instead of . 

That should clean up the code some. As I started typing that, I figured I'd check for edge cases too - since is filled with them (eg., it includes the negative sign in the length, returns if it overflows, etc.). You're handling the case, but a couple of edge-case values fail: 

Once you have the of the integer portion, you can use the format specifier to get the correct number of decimals, which would clean up the string building part. 

Well, you can certainly make it easier to read by cleaning it up a little bit and getting rid of the extra () loop, and substituting a and for the inner () loop's concatenation: 

This is basically a pipe and filter pattern - where you construct some number of filters into a chain and just pass the outputs to the next filter. If you control all instances, then the simple thing is to abstract out to an interface: 

Couple of quick comments, since you don't really specify what you were looking for. Seems like everything other than should be ; I probably wouldn't make them extension methods either. I think the whole thing would be better suited to a rather than 3 or 4 coupled methods. Your recursive is an odd implementation that I haven't seen before. It looks like it'd work OK, but doesn't seem standard. Your method seems broken; it never adds the ; I'd probably just replace that class with a or something since it doesn't seem to add much value but could be a breeding ground for bugs. No reason to on ; just return the generic . What happens if or is ? Looks like a , when I'd expect a list of all the added or deleted instead.