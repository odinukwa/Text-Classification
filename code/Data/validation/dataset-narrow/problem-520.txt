Your logger configuration doesn't seem bad. It's a little verbose, but it is open to further extensions if those ever come along. I don't know your requirements, but if you're only ever going to have one file logger and optionally a console logger, you could change your list into an object like so: 

Honestly, your loop doesn't seem that complex. I would probably ignore this warning in your case, at least until it grew in complexity or the surrounding function grew in size. In any case, here are some things you could change: a. Add a variable to replace the five instances of . b. Off the top of my head, I'm pretty sure an EC2 instance is only going to have one "Name" tag. You can extract this loop into a separate function if you feel comfortable with this assumption. c. If your lint rules / personal style allows for multiple returns, you can reduce the depth by returning from the error. 

The path is one of these two options. In the first path, done is clicked first. In the other, want is clicked first. 

But having a list is just fine. Not knowing anything else about your requirements, I would leave it the way it is. The thing that really sticks out to me in your code is the use of a callback as a parameter in . Since this function is not asyncronous, I would ditch the callback and either log the error directly to the console or just throw the error and let it break the build. If you really want to provide a mechanism for reporting configuration errors to the user, then rename "callback" to something akin to "errorHandler". The use of the name "callback" usually signifies a function that will be executed once and only once, will be executed when the function has completed, and will not return a completed value but instead pass the value as an argument to the function. Also, I find it surprising that you do not log the time to the output of the file or console logger. Not a big deal of cource, it just stuck out. 

[ln 215] ? Seems like one list to me. Rename it; again, consider the point above that it should be . 

[ln 30-31] Style choice: I recommend using around conditionals, even if they're only one line - because if you update them and make them more than one line and forget to add the brackets... exceptions. Also, your indents are off here. Indent the first line of the snippet above by one more space. 

What is this verb "Enqueue"? Method names of this format should be verb-object, as in "do this to this thing". If simply adds the passed object to a queue, the correct name is . 

is technically safe, and is fine for your current script, but if you want to adapt it for another script, it'll break. A more general, equivalent one-liner is: 

I've created a voting system that's similar to Stack Exchange's in a Ruby on Rails web app. It's working great - as far as I can tell, all the edge cases are caught. This is the action to cast a vote. There are some conditions I've had to satisfy: 

ServerManager.cs This class is generally good, apart from naming. Rename your variables here and you're OK on this class. 

Why is this here? If it's because you're waiting for the client to connect, this is a bad idea because you don't know if the client might actually take longer than 1 second to connect. Instead, you should execute the next line inside the event handler: 

Finally, and this is more of a personal preference, but I find that code is easier to read and follow when reading functions and not event handlers. By that I mean this: instead of calling , why not move that code to a function and call ? Here is the final result: 

Variables and parameters should not be capitalized unless they represent a class. As such, the parameter in should be . 

Everything looks good. That said, wasn't supported in Internet Explorer until version 9. If you need that support, the Mozilla Developer Network has a handy function you can include in your code to provide support for those browsers: 

I have a couple of issues with the main function. First, may work for windows but won't elsewhere. You should dump it. Second, Too many returns at the end. Third, The hardcoded input makes it kinda hard to test (and doesn't look good). Just read the first parameter from the command line or read in from standard in. Here is an easy way to do so: 

First off, refers to the element you clicked on, so we can simplify your code a bit my replacing your second like so: 

If looks like you may have a bug with . If the form input is a checkbox and is unchecked it will return even if it passes the validator function. Since this will cause the function to fail, lets return as an invalid state. 

[ln 60] Single responsibility: if 's purpose is to get news, it shouldn't also be dealing with notifying the user if there is none. Make this method return if there is no news to be had because of the , and do the check in the UI code [ln 55]: 

[ln 179] Folder !== Directory. Be consistent throughout: if this is a setting that a user needs to understand (hence why you used Folder instead of Directory), convert it to Directory code-side. 

Did you just... catch a generic exception? And ignore it? You need to work out what exceptions to catch and what to do with them. In this case, you're most likely to get a or , assuming your arguments are constructed properly so you don't get an or . So instead of catching a generic exception, catch both of those and tell someone about them. Something's gone wrong and this program doesn't work, I want to know why. 

Don't prefix your names like that. If you're adding a prefix, it should still follow all the rules of variable naming for C#. For private fields, variables are named in , with the underscore before it. Public properties are named in . So, you can rename a number of variables, for example should be . Server.cs I do believe I've found an error here. 

Comments The last thing is about comments. Inline comments can get really long. Some (me included) like them in this way: 

Another way to go at it (which I personally like the most) would be by using the and operators and not managing s and s. In this case, the would become something like the following (still not tested): 

The first thing that pops in my mind is the naming you used. For example, from a method called I'd expect to receive a and not a string. The same from . In the method the variable should be renamed IMO as the name is not so meaningful. The same regarding . Also, commented code is only confusing. I'd remove it. In addition: 

Let's take an example. If we have that and we'd need the numbers from to . We just parse to , multiply it by 10 for 3 times (length of is 2 and is 5) and return the numbers from 15000 to 15999 ( is set to 16000 which is the first value that is not allowed). In addition, if you just need an the previous method would be something like the following: 

This seems like a method suitable for the dynamic programming method. As 200_success said in his answer, the use of memoization can greatly improve performance. What I want to add to the answer are two ways to go with solving the problem. In-time processing This is the way suggested in 200_success' answer (if I understood it correctly). Let's go at it one step at a time. We have that \$G(0) = 0\$, \$G(1) = 1\$, and \$G(n) = [G(n-1) + G(n-2)]^2\$. By caching the result of \$G(n-2)\$ and \$G(n-1)\$ we can easily calculate \$G(n)\$, so, for \$n >= 2\$ we can use the following algorithm (in pseudo-code): 

You are caching , but really, it's not complex enough to warrant caching. I did some quick and dirty testing and found that you save about 10ms per 1,000 executions. That is not worth anything here. So, to reduce code size and bug potential, I suggest removing all caching. 

"want" / "did" "want again" / "did" (active) "want" (active) / "done" "want again" / "done" (active) "want again" (active) / "done again" "want again" / "done again" (active) 

Finally, we have to consider when to make each button active. If we clicked the done button first, then done will be active when the done count is greater than the want count. The opposite is true if the want button was clicked first. As a special case, no button is active if the want count and done count are zero. 

The only part missing from that match is the end, the last . I would use another regex match to grab that portion: 

Furthermore, It segfaults on me when I give it lines longer than 119 characters. (But this is probably system dependent). 

To guard agains the previously mentioned bug, we need to check if not null. I'm including only the function. 

Speaking of, is defined as , which only works for elements with an ID. A broader solution would be to set target using '$(this)': 

At the moment, I'm updating the record if there's already a vote by this user on this post, but I wonder if that's the most efficient strategy. Would destroying the old row and creating a new record be faster? I'd particularly appreciate efficiency comments - at the moment, this is a very server heavy action, which I'd like to minimise. 

(A quick note on vote types: the column has type , and the possible values are 0 (upvote) or 1 (downvote)). 

String replacement If you've got a lot of replacements, or you plan on adding more, try an extensible solution instead of all the calls: 

Running Code Analysis in Visual Studio on this code throws up a few issues, with which I shall combine some of my own remarks. Program.cs 

I've written a userscript that pops up a dialog before you take a moderation action (closing, deleting) with some pro-forma comments, so that you can add one of those before you cast your vote. I'm pretty happy with how I wrote it, but what's clear to me is unlikely to be so to others. Is there anything in this that I could have "phrased" better, or that could be optimized more? Comments on style (or, for that matter, anything else) are also welcome. It also occurs to me that this isn't as extensible as it could be: it's not easy to add new comments. Is there anything I could do to facilitate this? I've also put this code in a gist, if you want to see it there. 

Moving on to the "did"/"done"/"done again" button is a little trickier. "I already did it" will be visible so long as the want count is 0, and "Done it again!" will be visible after the want count is 2 or greater, but "Done it!" is more complex since it only shows up on one of the state machine paths (step 3/4). It turns out it is visible when the want count is 1 and we did not click the done button first and the done count is 0 or 1. This all leads to this block of code: 

Regular expressions are tough to read (human wise). As such, if you have a gnarly reg-ex in your code (), you should comment what it does. Furthermore, using regular expressions to check the total length of the string is inefficient and not necessary here, since you already have to check the length to report an accurate error message. As such, consider validating the username and password like this: 

I have little experience with python, so I can't offer critique on the finer points of your code, just the big picture. That said, several things stick out to me. First, you have some large chunks which are duplicated two, three, or even four times (see lines 198-215). Scour through the code and extract these into their own functions. Second, several of your functions are massively too long: (161 lines), (97 lines), (228 lines). , once you get rid of the previously mentioned duplication, could easily be broken into two functions: the finding and the scoring. is too long simply because it contains all of the input handling. The section within the block starting at line 435 absolutely should be its own function, if not more since it clocks in at 144 lines. Finally, and this is more observation than critique, your classes do nothing but operate as organized data structures. This isn't necessarily a wrong approach, but it would look good if you were to refactor your code to be a bit more object oriented, especially since this is intended as a code sample.