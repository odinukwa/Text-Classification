Must the partition column be part of the primary? Is it recommended one way or the other? Do I have to create an index for the partition key, or does the DBMS do it automatically on its own? 

It states Table Scan (HEAP). Not quite sure what it means in the context of a partitioned table. I also don't see that it uses any kind of index. And yet, it must, because the query comes back fairly fast (e.g. the table has 6 million rows). So, my questions are: 

What does Table Scan (HEAP) mean for a partitioned table? Does it indeed use an index, perhaps behind the scenes? Is there anything I need to do to improve efficiency? 

Questions: what is the methodology (the process) we could follow to conclude which one of the queries above is better for this particular situation? Considering the first query needs less physical reads, but uses more CPU. what are the things to consider in order of relevance? physical reads or CPU? what else? 

Actually the procedure is my favourite in this regard. Now I would like to email the backup history for the day before (only full and differential backups) and I need to find out the profile name for each of those servers. I would like to get this done by saving the contents of the above procedure into a temp table or table variable and just query the info from it by the time that I have all the data I need and I am about to email them. How can I do that for those procedures, specially the sysmail_help_account_sp? I specifically need to find out the . I have used for the script below. this is the script I am using to generate the contents of my email: 

With SQL Server 2005, you could look at the Task Manager and, at least, get a cursory look at how much memory is allocated to SQL Server. With SQL Server 2008, the Working Set or Commit Size never really goes above 500 MB, even though the SQLServer:Memory Manager/Total Server Memory (KB) perf counter states 16,732,760. Is there a setting where it will actually show the server memory in the Task Manager? Or is it a result of them changing how memory is used in SQL Server 

I run on box box and get multiple rows per single SPID. For example, see below. Does this mean that SQL Server has broken the query into 23 parallel sub-queries? If that's the case, why is it ignoring MaxDegreeOfParallelism setting of 8? Or is this something else? 

Basically I have my data inside a temp table, it could be in fact a table variable. If I do without the OPEQUERY: 

It says the database already exist, but I have detached it from the engine, as you can see on the picture below. 

I have seen many articles regarding OPENROWSET using integrated security (Windows Authentication), but I could not make it work for me. It is working fine using SQL Server authentication: 

I have changed the relevant columns in the table, from VARCHAR to NVARCHAR, in order to eliminate the need of conversion. the Table became like this: 

I've setup a test SQL Server 2016 server. I've installed 2 instances, restored a backup on the primary. Then restored a backup on the secondary with , then restored the transactional log on the secondary, also with . I then followed the prompts in the Mirroring Wizard off the Database Properties page and ended up getting an error: . What am I missing? 

I have a situation where multiple client apps send messages via the Service Broker (utilizing stored procs). These messages are picked up by yet another client app and then processed. The way the messages are picked up is that the app issues the following SQL statement (pseudo code): 

Do you have any replications setup? Maybe you also want to include a step to remove those incoming or outgoing replications after your step 2? It should be fine even if you omit this step, but it might generate unnecessary alerts (if you have set monitoring for replication) to the oncall. 

How about your memory and tempDB allocation on the 2016 instance? Both are the same as well? Also, did you change your DB compatibility to 130? 

Look at the parameter "clr enabled", and under the 'Run Value' if it showed '0', it means that it has not been enabled. To enable the paramater "clr enabled": 

Here you can see how to save the contents of the default trace into a table. I have been saving the contents of the default trance into a table in my database. The table is called . when I query the trace table to find out about the user , some his queries seem to be running slow. 

I have been working on a solution to synchronise logins (using T-SQL) between 2 servers, or between AlwaysOn nodes, inspired by sqlsoldier. It requires a linked Server. When run, this procedure outputs the following set of scripts that need to be applied in the current server for synchronising the logins (example): 

We had a plan to capture table changes with CDC until we realized that it doesn't support In Memory tables. Is there another way (preferably as straightforward as CDC) to capture data changes (from in memory tables) in SQL Server 2016? 

I am partitioning a table based on a column that is not a primary key? I've read some conflicting information today on whether the partition column must be a part of the primary key. My gut says no, but I am not 100% sure. So questions... 

I've inherited a very volatile table which is a map of who holds what resource in the system. At any given moment, there could be a dozen inserts/deletes/reads going against that table. However, there are never any more than 30-40 rows in the system. The system was written in the SQL 2000 era and the access to the table is serialized via sp_getapplock/sp_releaseapplock system sprocs, so that only 1 request is modifying the table. In addition, the INSERT & DELETE statements execute . Reading the notes from a decade ago, it states that without these restrictions, the system would experience non-stop deadlocks. I've ported the database to SQL Server 2016 Enterprise Edition. Now that the throughput of the system has increased 10 fold, this table is easily the biggest bottleneck. What are my options for a table as volatile as this with SQL 2016? I am looking for fast (hopefully concurrent) access and no deadlocks. 

Is this a new instance setup? Have you previously enabled CLR on the instance? You can check by running the following commands: 

May I know how do you resolve the issue when seeing the DBs in the "Not Synchronizing" status? And you were saying only some random DBs in that state, while some other DBs are in a healthy state on the same instance? I could only think of some possible causes: 

Did you also check on the SQL errors? What does it says...? One thing you can try is to restart your endpoint mirroring on both the primary and secondary instance to see if it helps. (Stop the endpoint mirroring first) ALTER ENDPOINT STATE=STOPPED (Then start it back up) ALTER ENDPOINT STATE=STARTED 

I have created 2 table variables in an attempt to match your environment. I have added an UNION ALL to your original query, one query selects all other months but december, and the second selects only december. there are other ways to do this, but in any way, it looks like an expensive query. here we go: 

I use sql server 2005 enterprise edition and have a subscriber DB - part of a transactional replication - that is used for Business Intelligence purposes - they run reports out of it, and SSIS packages read from it and import data into SSAS. This DB has over 800 GB, some tables have hundreds of millions of records. All these reports and packages need to read data using READ COMMITTED isolation level. As this DB is a subscriber DB and the publisher is very busy, replication keeps updating it all the time - whenever the publisher DB is updated. Sometimes the replication procedures require exclusive locks on tables (or pages or records), and it might be that the reports or packages are running from those tables (or pages or records) and as a result DEADLOCKS are more frequent than what I would like to admit. Example of a replication procedure involved in a deadlock today: