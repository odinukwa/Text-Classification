This is one of those occasions where a 'sparse' dataset may be very helpful. But, first some nit-picks: 

Your use of a is smart, but I would consider it to be overkill in this case. How about a simpler implementation: 

That is an amazing amount of work to do in 600 instruction cycles.I would expect the various object creates (three BigIntegers, two arrays, and a Buffer) are the most expensive things to do as they require multiple instructions, allocations/reservations, and registrations in the object creation, including CPU/cache management, etc. Frankly, what you have is pretty good. You could reduce the amount of work you are doing by completely removing the ByteBuffer from the last section. This code: 

The is a bad name for a List. The fact that it is a list is obvious... but, what is the list...? I prefer to . and are not bad, but they are not good either. They are just 'OK'. Algorithm I have worked the code through, and figure there is a plane-jane O(n) solution to the problem. Your algorithm is something larger than O(n), It is closer to O(n * m) where is the longest jump. The alternate algorithm I cam up with sets up a 'range' for the next jump.... It seaches all the values from the current cursor to the current range, and it looks for the jump within that range that would extend the range the furthest. The method looks like: 

You are doing twice as much work as you need to.... you fell in to 'the trap' of making the code follow the instructions, without thinking about the implications of the instructions. In the grid: 

That code would make your methods block in other threads... I have no volatiles or atomics... only synchronized. I use primitives, and arrays to store the data. This is fast, and reduces memory usage. I don't do any math in the time-sensitive methods. All I do is store away the . The math is all done in the get methods, and outside of the synchronized blocks. 

In your first elements you have space surrounding the text. In your later there is no space. Is the space important? If it is, you should either use attributes, or set on your XML. Update FYI, I ran your XML through xmllint and it output your XML as: 

Now you have a small table with just a few years in it, instead of 3,000,000 records. You have scanned the table just once to do that too. Now use that table to build your SQL select clauses.... 

Perhaps collaborate with the actual host-side of the system and extend the functionality of the web side of the equation is extended and covers the features you need. Special bonuses here are: 

Those variable names.... ouch. and make it hard to separate from the and too.... and they mean nothing otherwise. Why not use meaningful names like and ? Then, when I ran the code, I got a lot of funny results.... like: 

For the most part, this appears to be neat, and well structured. There is a significant bug, though: 

General Your methods all use a C-like system for the tree Nodes. In Java, the tree should be an Object, and the Node class should not be publicly visible. In other words, you should have something like: 

Right, talk about confusing. This code is written about 'suffix search', but all it does is prefix-search. Suffix happens at the end of the word, prefix happens at the beginning. 

Note that only the stderr needs to be handled by the anonymous fifo. The redirect back to stderr keeps it out of the way of the rest of the stdout. Also, note the use of the flag for . 

Update: I just went through and verified your calculations, and you were off by a factor of 100 in the number of passwords that you will generate. The combinatronics is that you are performing permutations. There's 26 characters, and you can choose them 8 times, so you have \$26^8\$ possibile permutations, which is: 208827064576. Now, if you have 8 bytes plus a newline in the output file, that's 9 bytes per value, which is: 1879443581184 bytes, or.... 1.7TiB of data. I hope you have enough free disk space. Assuming IO will end up being your bottleneck, a decent disk can write 100MB/second, and that works out at almost exactly 5 hours... so, there's not much point in going faster than the Java version I presented unless you have a decent IO subsystem (I presume you don't have 1.7TB of SSD, do you?) 

I am not suggesting that this is a good solution, just a better/faster solution. The best/fastest solution would not create two string values for comparison, but would leave the values in their native integer format. Secondly, why do you have 4 diagonals? You should be able to get by with just 2 (since there are only two of them). I have not been able to get my head around this problem quickly enough to understand whether there is a particular use-case requiring the 4, but at face value, this means that you are double-checking your diagonals. While I understand that you are trying to get a handle on generators and comprehensions, a more simplistic approach to this problem would be more efficient, and probably more readable. The standard HPC (high-performance-computing) method for this type of problem is to create a logical box that spans the problems space. In this case, the box would be 4 by 4. You then create a cursor that traverses the problem space, where the bottom-right member of the box is on the cursor. You then test that box for a vertical line above, the cursor (if there is space), a horizontal-line to the left, and the two diagonals in the box. This type of approach is easy to multi-thread or distribute. There are ways to make the memory access more efficient as well by splitting the problem on clever boundaries when parallelizing. But, what you want to avoid is generating values for each movement of the box.... 

Finally, about the algorithm. I am not convinced that it works... I have not run it, but I am pretty sure that the compareTo methods are the wrong way around... they should be and not )....