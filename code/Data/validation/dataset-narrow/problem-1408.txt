Having such restrictions on your players would get extremely annoying for them very quickly. You're effectively forcing them to be online and playing your game nearly 24/7. What will happen when a user can't log on for a few days because they're on a vacation? All their animals and plants would die, there might be other disasters. Not very userfriendly. Better to stop the timer when the user logs off, and start it again when he next logs on. Effectively their farm only exists when they're on the server (except of course that noone can buy land on its area, if you're working with such a system). 

why have such items in the first place? Rethink your system to where you don't have to choose between things that last forever and things that can be used only once. Have things wear down over time, at which point they either have to be repaired or replaced. More powerful items can be made to wear down faster, and/or be more expensive to repair and create (if you have a crafting system). Ryzom did this very well, having a highly involved crafting system where the best items in the game would require rare resources that could only be harvested at specific times in seriously high risk locations, often requiring teams of people just to protect the harvesters against the local mobs. It could take weeks to gather the resources to craft one of the best weapons or armour pieces in the game (over time of course people started hoarding the raw materials, some guilds even going so far as to harvest things they didn't need in order to deny them to others). Combined with storage options that allow enough inventory to keep items for special occasions, this created both a lively trade between players (it took a lot of effort to learn to craft those items too, so the number of people capable of doing it was low and not always the same as those who could harvest the raw materials) and provided an option for people to have different equipment sets for different occasions (which was essential, as different mobs required different armour and weapons to combat, and for pvp different gear was required again, harvesters needing different gear again for that). The game may still be up, haven't played it in a few years though, might go and take a look again. Good memories. 

If someone knows how to achieve this behaviour, it would be very appreciated if you would let me know how to do it. Thanks. 

SUMMARY I need help to create a weld joint that fixes the two bodies together in a way as illustrated in the first image. ISSUE I am having an issue where I cannot find out how to weld vertices of two polygonial bodies together while also snapping the edges between each object's vertices together resulting in something like this: 

Now, I have no real idea how to even get the vertice positions of an active body, so I've tried doing this using one weld joint and creating an anchor at the position of one of the bodies (The one that is being controlled, which is the triangle). I have also not been able to snap the edges together using this method: 

After some research and testing, I've now managed to resolve my own issue. The problem lied within memory management. I followed this tutorial Stiegert and got inspiration from his SoundManager class to create a new SoundManager of my own that uses LRU Caching. Thanks Alexandre Vaillancourt for the assistance 

SOLUTION I have somewhat solved my problem, even if it is not the best solution. I present to you an illustration of my solution followed by an explanation of each step: 

Rather you should make your levels hard enough that they can be completed by a player with a decent but not stellar level of skill, and have them develop that skill by making levels progressively harder as they travel through your game. First levels should thus effectively be a tutorial. 

What's happened to your custom binary data format? If you are afraid of raw serialisation, write your own system that writes fields as needed, and reads them back. No need for xml, which is indeed overly bulky and complex for situations where you don't need the transparency the format provides. Just define a well-specified file format and stick to it, leaving maybe some room for expansion of your data set in each record by padding them with null values (say you have a 100 byte record now, pad that to 150 for future use. Add a version number and maybe a checksum so you can know what fields should be filled and have a sanity check for validity, and you're good to go. 

What would you want the players to do with the items they create? Will they be purely cosmetic, or actually have function to interact with (other) players, npcs, or the environment? 

why would anyone pay to remove an ad they see for only a few seconds during startup of the application? Or are you planning to have the browse through 10 minutes of advertising before they're able to start playing unless they pay up? Because in that case you won't get many users at all, they'll just uninstall and try something else. 

At the merging event of two sensors (see step 2), I access the parental fixture of the controlled sensor by calling . When I have grabbed my parental fixture, I can access each of it's world transformed vertices by calling (PolygonShape). At the creation of a body (or attached fixture, see step 3), I create one CircleShape fixture as sensor for each of the edges of the parental fixture. I also give each sensor it's own side ID to know which side of the parental fixture it is on. By doing this, I can now check for a collision with another sensor belonging to another body and initiate a merge event. When the merge event is run, the body collided with gets removed and a fixture on the controlled body is created with the same shape as it's ancestor. The newly created fixture is then rotated so that the two vertices on each side of each fixture is colliding (Polygon makes it easy to rotate vertices). New sensors for the newly created fixture is created and all actions described in step 2 is made. At creation of the fixture described in step 3, it's origin of rotation is set to one of the vertices of the edge of the controlled fixture so that rotation will be easier. 

There's no magic number, depending on the size and complexity of your system, the number could be anywhere from two or three people (you do want some duplication of effort, to cut chances that someone misses something) working for a few hours over a weekend to dozens of of people working full time for months. And with consumer products there's the added factor of disparate hardware/software combinations it will run on. It wouldn't do to test a graphics heavy game for example on only 2 computers, both with the exact same videocard, operating system, and drivers. It will need to be tested on a broad range of hardware/software combinations to determine if it works properly on all of them (or at the very least to be able to mention in your documentation what the hardware/software requirements are to run it). 

Whichever you do, it doesn't matter. If you rely on clientside calculation of anything you will get hacked. All the "anti-hacker" tooling has AFAIK been thoroughly penetrated, new versions often themselves being hacked in a matter of hours after release. Given that, browser games are a major PITA IMO (poor usability) though they do offer ease of installation. So push as much as you can to the server, validate and counter validate everything sent by the clients to the server, and aggressively detect and ban any violators. Of course you do have to account for lag which can cause weird results being sent (or received), which is another reason you don't want to rely on clientside anything. So the client tells the server he's moving in direction alpha, let the server decide the next position, not the client. Client tells the server he's pulling the trigger, let the server decide whether there's bullets left, where they're going, and whether anything is hit (and what damage they do). Done like that, the client becomes little more than a tool for rendering the world and allowing the user to request things (data, movement, etc.) from the server with the server deciding whether those requests should be honoured based on what it knows about the real abilities of the client (this also makes it impossible to render walls invisible for example, unless the client avatar is known to the server to have X-ray vision, a decision made based on gameplay and resources the server assigned to the avatar, not the client software). 

I am pretty novice when it comes to game sound management, so excuse my ignorance. I am having an issue when playing too many sounds at the same time where some sounds stop playing, or doesn't play at all, almost like some sounds overlap others. I've read some about the sounds using individual buffers and that there should be no problem playing these at the same time at runtime. When I only had a small ammount of sounds in the game, it all worked flawlessly. My SoundManager had no problem playing multiple sounds at the same time ( I loaded the sound to memory when I was going to play it and disposed it when it was done playing, approx. 5 seconds). My SoundManager Class I've recorded a video to better illustrate what this sound problem is. As you can hear in the video below, the attacking sounds can only be heard at some points, as for some enemy sounds. The idling sounds of the enemies (breathing and bat sounds) seem to work without issues, though. Video Thank you for helping, because I have no clue how to fix this issue. Is there something that I've left out in my SoundManager? 

Note that no WeldJoints were used in this solution. Hope my solution helps some people that has the same issue as I had when I wrote this question. 

Of course this places a major burden on the servers, your server hardware is going to have to be rather more serious than that of old fashioned gaming servers which were little more than portals to transmit data between clients, but that's what it takes to deflect hacking/cheating attempts. 

You do realise that when you're in game development you won't be playing many games? That most likely you'll quickly come to loath playing games because you have to test little bits of them over and over again to analyse errors? You seem under the impression that working at a game development shop means you're just going to be paid to do what you like to do now, play a certain genre of game when and how you like to do it. Nothing could be further from the truth. You're going to be spending a lot of time not playing games but in exhaustive meetings about minute details about them. The rest of the time will be spent working on implementing or testing those minute details, and if that includes any playing it'll be playing the same little bit of the game over and over again to test that little detail you happen to have been assigned to working on. It's a job no different from any other, and any job can quickly destroy what enjoyment you have in the thing you're doing. Which is why I always advise people to NOT try to turn their hobbies into their jobs.