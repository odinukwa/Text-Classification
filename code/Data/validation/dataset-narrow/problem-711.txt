Scoping In Emacs Lisp a nesting a inside another does not create a lexically scoped function. The symbol for the 'nested' function is still interned at in the current . The behavior is unlike that of Scheme. In Emacs Lisp is the general structure for a 'local' function. Formatting The formatting of the code within the call to is difficult to read. When the condition and consequent cannot be listed on the same line, it is probably more common to place the consequent below the conditional. Suggested Alternative Format 

Disclaimer I'm less concerned about how Pythonic the code is than how understandable it is. A Few Observations 

is the sort of code that is hard to understand and hard to maintain. Perhaps to the point where it is better to forgo the user friendly approach? Nay! A thesaurus is a good place to look for synonyms. Although, Python lacks Thesauri, a dictionary will probably do. Now the game can be sold at Ye Local Renaissance Faire as Stone, Vellum, Shears! Indeed, a dictionary is a good way to map each possible game state to the next state. The code does in lieu of directly implementing the logic the specification uses to describe the final states. The reason is maintainability. The mobile version of the game will offer an upgrade to Rock, Paper, Scissors, Spock, Lizard currently in development. Once we get around to updating the dictionaries and the game will be done, profits will role in, and we will never have to work again unless sleeping on a stack of money counts as work. But Really, Why All the Ceremony? One of the real values that comes from using dictionaries is that a dictionary can be used to dispatch functions. 

Using an internal function, recursion, and a trampoline is a good way to structure recursive procedures on a lists. The code fragment is the same as . The name suggests an accumulator, however, the value it stores is the maximum, so might be better. Because of the letter can be confused with , can be read as slang for 'first'. I prefer as the name for a list of 's. The nomenclature has become more common in Lisps over the past few decades due to the influence of other functional languages. No matter how it is dressed up, there's a procedure in the code somewhere. And it has to be written. It is better to be explicit about it than to try to hide by embedding it in some other function. 

I also voluntarily removed the log statement. I'm not sure it really add any value when only logging "Create File". Either add more information such as where the file was created, with which name, etc. or get rid of it. In the end you could use these methods like this: 

Update: taking into account This is how I would fully replace a boolean into a business class. It looks like overkill but in reality it's not. Each class has a single responsibility, is testable and maintainable. is now abstract because the "blocking" behaviour can't be defined here but only in suclasses. 

At the moment there is an method. However since you should add cans and not set cans, you should rather take as an argument the number of cans you should add: 

Exceptions are (badly) swallowed is closed but not opened in this method. This could be a major flaw because it induces a nasty side-effect. It is a general idiom that the one who opens a resource is the one who closes it. is declared in the , no need to close it manually ! (it will be done automatically) 

The hardcoded string for the path The fact that you directly depends on , making the method hard to test 

Final solution All these remarks put together, I came up with the following solution. Note that is an inner class because it doesn't have to be known in the outside world. 

Class is open to modification should be closed for modification, this is the OCP principle. If it's not, its behaviour can be altered (by inheritance for example) and can lead to an unpredictable behaviour which make it rather difficult to test and maintain. How to achieve that ? Mark . Executor never shutdowned Once started, the executor can never get shutdown, which causes the task to be run indefinitly. How to achieve that ? Create a method: 

Bill What does a need in order to compute a price ? A base charge and a distance. These two values must be provided in the bill constructor. The bill doesn't have to know about the . Then, the implementation becomes (note that I have made this class immutable): 

and the specification suggests that the method use an existing implementation of a binary tree. Remarks on Code details 

The queue is dependent on the subscribers; throws errors based on subscriber state. And in order to be useful the subscribers must depend on it. There's significant afferent and efferent coupling in the implementation. Perhaps not a good thing. An alternative would be to write to a stream or bus or log and let clients read from the stream according to their needs. Adding a reader interface would let the subscribers know what the queue is committed to doing...and what it is not committed to (e.g. how does it flush? when full does it drop oldest events or refuse new ones? what does it do when it is empty? etc.). 

The point of showing this as JSON is not love of JSON. It's that the MVC architecture should define the Model-Controller and Controller-View interfaces so that the layers on each side can be written in different languages, e.g. SQL->Java->JavaScript. Each interface should be designed to explicitly serialize and deserialize data in both directions to prevent leaky abstractions. 

Efficiency Correct code is the first order objective. Writing clear code facilitates that because it makes debugging and testing and maintenance easier. Speed of execution matters only when it matters. That is always after the code is correct and after there is an objective performance issue, not just a theoretical one. Getting a wrong answer fast may be worse than no answer at all if we mistakenly believe the wrong answer is correct. 

Is "tree recursive" and therefore does a lot of extra work. Tree Recursion is described in The Structure and Interpretation of Computer Programs. Section 1.2.2 has a very helpful illustration that shows how tree recursive algorithms wind up performing substantially more work than is necessary. Alternative Functional Approach Recursive Design: Structurally recursive algorithms have two part: a base case and an inductive step. The naive approach to Fibonacci treats as the base case and as the induction. The alternative code treats as the base case and as the induction. This means has always been computed previously. 

The method could event be marked so anyone reading this code knows that this method doesn't have a side-effect on an object attribute. 

Update Following your comment, this is how I would implement the file creation based only on a date + a counter (if needed) 

There's still a bit of duplication between the but I think you get the idea. The goal is to avoid duplication in order to have tests that are easy to understand and maintain (clean tests are as important as clean production code). 

contains only notion of blocking until the value is not computed. How the value is computed is totally abstracted here. 

Using LocalDateTime Since Java 8, there's a new API to use when you are using dates. I refactored the code to use this new API instead of the old one. 

The is really nasty here ! One expect to only return a value but before it does some unexpected computation ! You should write it in the form of a simple getter. 

I see at least one big problem in your method: there is no separation of concerns. Everything is mixed into this method: common rule for password double-checking, business rules for password validation and UI calls for user response. Extracting the business logic The business logic in your case if the password validation specific rules, as you named them rule1, rule2a, rule2b, rule2c and rule2d. Everytime you will need a password validation, you will need these rules to validate a password, therefore I would extract these rules into a BO. 

is fine. The resulting string in is misleading. The is the amount of cans the vending machine currently holds and the is the number of coins that have been inserted. You should also directly return the string instead of creating an empty variable 

Extracting UI calls Finally the UI calls must stay in the UI-part, namely into the JavaFX controller. Typically it could looks like this (simplified): 

TaxiMeterApp This class also doesn't need to depend on , the only useful information is the amount of the base charge. One now takes as a parameter since the distance is obviously not known when starting the taxi meter (the base charge is, however). I also removed the App from the class name because I think it has no value and only bring visual noise. 

method review is imo complete (worth implementing @mjolka suggestion about using stack: open brace => add to stack|close brace => take from stack and compare match...). contains some redundant & duplicated code. If you have repeating operations performed in the tree of conditions that usually means that these conditions might be connected not by its structure but with logical operators. Lowercasing exception arguments shouldn't be neccessary. You won't pass exceptions arguments like you didn't know what it's for. These are predetermined. I'd rather check if is actually a string because it might be user supplied argument, but that's validator's job so after all it's good you didn't do that. My suggestion: 

A row with column names is what using MYSQLI_ASSOC already returns - no need to use separate query for these names. Also note notation inside while loop - equivalent for array_push() function - adding new rows will result in 2D array you need. Try this: 

but it's problematic with large result sets (like dumping entire table) and further processing it would require a loop anyway. 

I'm blindfolded by spanish names a bit. I understood that you're trying to... set with newest and specified DATETIME of into if it's value is If I got it right, then this single query should work: 

Maybe it's a matter of preference, but IMO Exceptions shouldn't be used for validation errors (see:Don't Use Exceptions For Flow Control). First, it's not that exceptional and second, you should still handle user friendly response: re-display form with error messages (or error list only in case of ajax request). Insetad exception one-liner you should build (View)Model that gets messages from validator and (invalid) data. Other Exceptions (league/country/insert) are ok. They're thrown when user have done something illegal (bypassed GUI). On the other hand it doesn't deserve any specified message then (serve debugging purpose only). The thing that looks smelly is collaborating with league and country mappers. I wouldn't use them at all in this context. I would either handle it with db constraints (foreign keys) that would throw me db exception* or (if I wanted to decide details later) handle it within method. If you intend to use ORM there are propably some sophisticated methods for such constraints too, but can't tell for sure - got allergy to ORM. *) The downside of using key constraints only is relying on something that is hidden outside the sourcecode. Db schema might be messed up (during migration for example) and vulnerability might pass unnoticed. Unless you have full controll over your code it's better to make checks anyway (preferably using transactions).