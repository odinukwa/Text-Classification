There's an easy way to teach them to do code review without thinking that you're ditching work: ask them to review some code which you wrote for the express purpose (or, if you have some suitable code from the previous year's homework, use that). This can be set as homework. For what it's worth, I have had to identify errors in code printouts both in exams and in job interviews, so this isn't an original idea. 

These are very different situations. As you observe, the use of in C# is controversial, but using as the type of all variables (and then needing to cast any time you want to actually use the variable) is not controversial: it's just wrong. The first page of answers on the linked SO question about in C# is incomplete. It doesn't mention that using can avoid bugs due to typing in one edge case: vs . For legacy reasons, if is a but not a the latter is equivalent to , which is not especially obvious. (In fact I misremembered and was corrected in comments, which reinforces the advantage of using here). TL;DR: blanket prohibitions on are almost certainly going too far. 

First please be very cognizant of the term "hacking" Some of what you are describing is "cracking" not "hacking" The techniques may be the same but the intent is different. I think you are having problems with this because you yourself aren't comfortable with making this distinction. You cannot prevent someone who is rotten to the core from taking your class and abusing what they learned so don't beat yourself up trying to head that off. If they are rotten they will make you think they are an angel with a halo. Instead why don't you assign them as the very first assignment, to write a short 1-2 page paper on "what does the difference between cracking and hacking mean to me" Then take the best 5 responses that have the most clearly thought out positive morals, and distribute them to the class. That would likely get the point across better then you saying "cracking is bad, don't do it" when they see their peers don't think it's acceptable. And you might even get a few pearls in, like someone writing about how an identity thief stole money from them and how violated they felt. Behind every successful crack there is a victim and if you can get them to empathize with the victim rather than the cracker, you have done the best you can do. 

Most of the maths in undergraduate CS is proof by structural induction (and we do at least in part deserve the reputation we have among mathematicians of not knowing that there are other proof techniques). That technique apart, the "non-CS" maths can be more than covered by chapters 2 and 4 of Concrete Mathematics, Graham, Knuth, and Patashnik, ISBN: 0-201-55802-5. This book contains many exercises and solutions thereof, or hints in the case of unsolved problems. There are PDFs available online, but I'm not sure whether they're authorised so I won't link to any. 

There's no "may" about it. With brief training they will be able to offer positive comments as well as negative ones, but to give constructive advice they need to know what they're talking about. For example, anyone can tell you "I couldn't follow the thread", but to suggest specific structural changes you need to know the broad types of structure which could have been used. There are various organisations which are dedicated to training in public speaking: Dale Carnegie and Toastmasters being perhaps the best known. (Disclaimer: I'm a member of Toastmasters and have previously held various offices in my local club, so I'm not unbiased). You could look at their approaches, and if you have a branch of such an organisation in your city (or even in your school/university) you could see whether they'd be interested in helping out. Speaking from the Toastmasters perspective, there are one or two projects which people on the leadership track can complete by running a training session with a recruitment plug: you may or may not consider that appropriate for your setting. In addition, particularly if there's a club in your school/university, you might be able to get a couple of members to come along to a lesson on the basis that one of them gives a speech for evaluation, your students offer their feedback, and then the other gives an evaluation which confirms or corrects the students' feedback. (If necessary, explain that the rules allow one project in five to be done outside club meetings provided that another member is present and gives a written evaluation. I haven't seen this option used much, so the members of your local club might not be aware of it). The good thing about this is that someone who's done a few projects in Toastmasters will be used to being evaluated by people with differing levels of experience, and being a volunteer will find it less stressful than your students. That way they can learn to give feedback without destroying their peers' confidence. The second visitor will also (I hope!) demonstrate how to give suggestions for improvement sandwiched between affirmation of positive observations in order to (quoting the title of the manual) "evaluate to motivate". Since you probably won't have volunteers to come to every lesson for several weeks in a row, this might be best saved as a final practice before getting into real peer evaluation. You could build up to it with a series of lessons in which you teach a specific skill (speech structure, body language, word choice and sentence structure, visual aids, ...), watch a video (maybe a talk from TED, Ignite, or something similar), and then ask the class to give feedback. 

I'd start with something useful that takes yards of code in Java and only a few lines in Scala (assuming there are such things). After two or three examples like this, you'll have hooked your audience. Move into a compare/contrast of language features. Talk about what's easier in Scala. For fairness, talk about what's easier in Java. Then move to how/whether you might adopt Scala in your workplace - or why it wouldn't be practical now but under what circumstances it might be. 

With my informal Coding for Teens group, I like to start each session with a puzzle that we do as a group. My reasoning is that programming is not primarily about semicolons and syntax, but about logical thinking. And logical thinking can be demonstrated and honed with puzzles. So far I've used grid puzzles (Alice, Betty, Carol, and Dawn have dates with Roger, Steve, Tim, and Ulmer...), and I'm thinking about using the Towers of Hanoi (obviously that's a one-session puzzle), but I'm wondering if there are other formats that are good for this type of group activity. Edit To be clear, I'm not asking for a list of specific puzzles / links. I'm asking for puzzle types. For instance, if I were asking for puzzle types that hone language and / or lateral thinking, "crossword puzzle" might be a good answer. 

One which most of your students are likely to have seen, and some of them may have participated in: production of an order in a fast food restaurant. 

is far from the only controversial subject in programming praxis. The solution in industry is the style guide: whether as a formal written document or as an informal internalised set of opinions which are imparted to new team members by word of mouth when they submit changes which violate the house style. If you're explicitly preparing your students for industry, it is perfectly reasonable to dedicate a bit of time to explaining the concept of the house style, and then when you introduce new material to explain the house style you will enforce for that feature. The really heavy-duty approach would be to prepare a full industry-style style guide and then to produce a series of increasingly large subsets so that every couple of weeks you can give them a link to an updated style document which specifies how to use the new features you just introduced, or the new features you're about to introduce, and highlights the additions from the previous one. 

Does a good car mechanic have the ability and talent to forge a good wrench? Does a good doctor have the ability to build an X-ray machine? Computer coding is like any other discipline. There are objects you are going to need for a project that make use of an advanced theory (such as sorting theory) and you are going to know right off that you could spend 3 years creating just that module, or spend a little money and buy a module already made by someone who's got multiple doctorates in the field and did it better than you ever could. If your students are just shrugging when presented with the theory it is most likely because they intrinsically understand that their skill level is not anywhere near high enough to be any good at writing something that would address that theory, let alone understanding it. So they have no interest in it. Giving them an assignment designed to make them fall on their face in my experience is going to do either 1 of 2 things. First they will give up and fail and be even more convinced that they shouldn't be interested in theory. Second, they will figure out you are trying to out-fox them and do what I did when I got those kinds of assignments - read the textbooks that were like 3 levels higher than the class which contained the answers, then come back with an answer that not only answered the original question but then proceeded to dissect it and explain why it was a terribly poor question to begin with because it did a lot of hand-waving and made a lot of assumptions that might not hold true in any situation. Then be reinforced that they don't need to bother with the theory since they made the teacher look bad. What you might try is appealing to their competitive instincts. Divide them into 2 teams with the top coders split up on different teams mixed in with the slower and worse coders who might be better at the theory and setup a contest to see who could write a better app. Once the top coders see that their teammates who are actually paying attention to learning the theory have something to contribute, they might start to feel differently. You can pick an app that is sufficiently broad that it encompasses all the theories you want them to learn.