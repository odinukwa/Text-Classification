When a post production studio edits a film's soundtrack, they don't place little "SOUND EFFECT INSTANCE" cues all over the timeline. They take a few different sounds and balance them together, triggered at different sequence points in order to make the soundtrack as organic as possible. It's really hard (and sometimes not desirable, as your game's aesthetic dictates) to do this in games. The systems you can build (or use) for getting the most flexibility out of your engines vary. One way you can get familiar with this is to download both FMOD and Wwise and start reading their documentation and trying to use the tools (Wwise's installer contains a document describing of the interaction between programmer and sound designer that is especially good). 

Look at these bullet points and think about them long enough and you'll realize they can't really be classified in the same way. Object-oriented programming can be helpful in implementing a component system, but is not strictly required. And except for prototype-based languages like Lua and Javascript (where it's rarely useful to think on this kind of scale, and are often thinking of code as data), component systems are generally not baked into a language and are more of a architecture pattern. You could just as well implement a component system in idiomatic C and have it serve you as well as something similar in C++ or C# (Type-safety problems and less syntax sugar not withstanding). People interfacing with your C component system wouldn't care that it's C because they're typically just manipulating data to produce complex behavior. As for object oriented design and where it fits into this spectrum, I think that it doesn't. In my arrogant, young opinion, SOLID is essentially a list of platitudes that, while useful in a broad, rule-of-thumb kind of way, ultimately don't provide us with that much useful information beyond achieving a good sense of general organization and structure. And that's certainly not OOP-specific. Much more useful are design patterns and principles in specific languages. I just find it weird that OOP gets its own qualifier to stick in front of the word "design." When's the last time you saw a Teach Yourself Imperative Design in 24 Hours or Functional Programming Architecture for Dummies book? Having been raised on OOP, many of us generally find it easier to implement component systems in an object-oriented language because we're familiar with the design patterns and best practices of this paradigm. Haskell nerds, Lisp hackers and C gurus will have a completely different opinion on how one would approach to implementing (or possibly refusing to implement, because their languages offer superior idioms that accomplish similar goals in ways more appealing to their programming palette) this pattern. To understand the benefit and principles of component systems in game programming, try this: Imagine constantly for every second that you're building out your game's systems, that as soon as it's built you won't ever be able to actually build content for it. Another person who has no coding skill must work with it and you can only affect the outcome of their work orthogonally by updating the tools. Components are a pattern for maximimizing flexibility of creating a variety of different behaviors at runtime and enabling this behavior to be determined by non-code data. OOP can help, or it can not. 

There are actually some fairly standard approaches for designing music playback in a game. When designing a music playback system, problems you face involve creating smooth transitions, ensuring there is enough variety, and creating a sense of interactivity with the music. Your question title, "changing background music smoothly" tells me your main concern is transitions so that's what I'll primarily be addressing for each method. Method 1: Layers and Stems One approach for creating smooth music playback systems in games, what Patrick Hughes called the "AAA way", is to build your music up in layers (also sometimes called stems) such that there's no single definitive version of the track. Instead, you might have a single base track running consistently, with melodic, rhythmic, harmonic variations that get played over it. You usually (credit again to Patrick Hughes) build these around common motif that runs through each element layer in a piece of music, or even througout all music in the game. A good example of a non-melodic motif is Martin O'Donnell's use of the Phrygian scale in Halo games ($URL$ Normally, each of these component music tracks are aligned to be playing in sync on a timeline with each other. Although it is possible to create music layers that do not necessarily depend on a consistent tempo and synchronized timeline, or can work well in multiple tempo and timeline contexts. Because each layer is designed to work together, it's entirely possible to have a single layered music track that just plays throughout the entire game, making slight transitions between layers within itself to signify game state changes. Method 2: Branching You say you have music tracks already produced, so this implies you've already got a specific direction in mind: branching music. With branching music, your primary concern is the transition between music tracks that have been specified to play at particular sections of the game. You can achieve variety by breaking your individual music segments down into loops that have a couple of different versions, so that the same version never plays twice in two iterations and doesn't always start out the same way. One way to handle transitions in simple branching music is to write more music that purely acts as a transition from these existing music tracks to others. Even if it's not feasible to cover every possible music transition, you can also use the "connector tracks" to make a music track end early in the case where you're trying to avoid simple fade-in, fade-out music changes. Method 3: CCC-Combo It's also important to note that the two major approaches discussed here (layers and branching are what they're typically called) can coexist conceptually. "Branching" is such a simple term and description of what's happening that you could very well be branching between layered music systems. This often requires a semi sophisticated playback system, so you have to balance what's worth your time to implement. Method 4: Pragmatism and Simpler Music Playback And, of course, you could always just fade-in and fade-out your music as needed. No shame if that's what feels right, or it's not feasible to write connector tracks. Better this than hard cuts to completely unrelated piece of music--that would sound pretty awful. I'd also like to address your "silent songs" idea. It's not bad, but what happens when you start playing one 300-second track for 5 seconds, then you get immediately into a state where you need to transition to another track? Waiting for the remaining 295 seconds to go by seems impractical if you really care about making that music transition. However, if the music is purely background music, and its fundamental purpose is to provide to simply set an overall mood, then "simple background music list" is a perfectly legitimate way to think about it. At this point you are talking about a music playlist like you'd build in iTunes or Windows Media Player (is that still at thing?) so you should implement it with that in mind. Further reading To learn more about standard approaches for designing music playback in games, you should take a look at learning materials for two of the largest interactive audio middleware tools that see common use in the industry, FMOD and Wwise. Wwise has good reference material on this page. The "Making Interactive Music for Games" article is especially good as it goes into further depth about the information I've written here. The FMODTV Youtube Channel has videos with Stephan Schutze that cover FMOD Studio as a whole--including the parts of it that can be used to design music playback systems. Learning how these tools approach this problem can help you think about how to address your own game's needs. 

Also (added because of Panda Pajama's comment), take history and art and music and literature classes. Foreword to a lengthy answer The honest truth is that no CS curriculum can prepare you for game development, but every single course in a respectable CS curriculum will benefit you in some way if you are interested in contributing to the process of game development as a game programmer. That's what my answer caters to. How useful my answer is to you will change as you go through school and work on more of your own game projects and understand better what roles you want to fill. You will probably leave school as a fairly different person from the one you entered as. Your desire to work on games may not change, but how you see yourself going about doing that likely will. A lengthy answer I'm going to have to disagree with Josiah Hester and recommend that you not take a C++ course, because it is very likely that the course will be either too out-of-date (using bad inheritance) or too up-to-date (too much standard library), and almost certainly inadequate for working with C++ on the level that you'd be expected to at a game company. You can only get to that level by working with the language on your own time with your own projects, which is time you'd have to spend on top of a C++ class anyway. Save your classroom time for concepts that aren't as easily (or in this case, optimally) self-taught. Take instead a class that requires that you use C (not C++) to implement low level OS features like a shell, a memory allocator, or a scheduler. "Operating Systems" is the typical name for the upper level version of this course (intro courses may be called Systems or Architecture or something similar). In fact, don't take any classes named after a specific language. And avoid colleges that have a list of programming languages as their course sequence. If you happen to learn a language while learning about some other topic (hard to learn systems/architecture without learning assembly and C), that's great. But a class about language syntax is a gigantic waste of your time and tuition. Don't take any class called "Web Programming" unless it's a fun elective type thing and you're looking to fill credits with something that is new material but isn't essential to get into your brain. Same goes for anything about trendy platforms, like "iPhone Programming." Just go watch the Stanford videos on iTunes and make an app on your own. It'll look more impressive if you're applying to be an iOS game programmer somewhere. University classes can't possibly keep up with what's current in industry, so you have to use them for what they're good for: foundational knowledge not easily self-taught. If at all possible, your best source of information on the usefulness of any given course will be current students and recent alumni. Sampling of standard courses you should expect to take 

Useful higher-level elective classes (Note, don't take all of these, you might go crazy. Let your developing interests guide you.) 

First things first: do not use . Use , for it will make your life simpler and nimbler. How you keep track of these s depends on what you want to do with them. Hashtables and Dictionaries are a great way to associate objects with other data. (See the .Net documentation for the generic dictionary, nearby you'll also find 's docs). But, if you want to get a reference to the all subclasses (including , and any ) all have a reference to the GameObject they're attached to by calling . This is probably what you want to store.