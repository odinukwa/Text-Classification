The C64 only supports 8 sprites per horizontal scan line, so I don't think that everything in the middle of the screen can be a sprite? I would assume that anything requiring a collision would be a sprite (since I can get hardware collision detection with sprites), but even then I quickly hit the limit of 8 sprites. Also, my weapons can fire much more than one projectile - my ship, the satellite and 6 bullets would already be 8 sprites on a row (look at about 50 seconds into the video). Also, which graphics mode would a game like this use? The Programming Handbook lists Bit Map Mode which essentially modifies screen memory directly. Is this the mode I should usually be working in? How would I compose all the non-sprite elements together to get them on screen? A lot of the stuff in the score and status bar is static ("Area: 01" or the "frame"), so I guess I'll just populate them once when the level starts. Things that need updating - the score, the charge bars at the bottom - would be updated by filling the screen memory with black and then drawing the new score every frame? Or do I have to draw the entire screen on every frame? 

I've been looking up the definition of radians and found out that mathematicians prefer them because they are derived from pi instead of being completely arbitrary like degrees. However, I have not found a compelling reason to use them in game development, possibly due to my complete lack of related mathematical understanding. I know that most sin/cos/tan functions in languages what radians, but someone could just as well create library functions in degrees (and avoid the inherent rounding errors when using pi). I don't want this to be an opinionated poll, I would just like to hear from people that have done game development (and the associated math research) where radians offer a superior experience over degrees, as opposed to "We're using radians because we always used them", just for the sake of helping me (and possibly others) to understand what they are good for. 

The only reason that I can see for including a compiler in an application is that you wish users to be able to write their own code in C++ which is compiled, linked, and executed at runtime. This isn't a brilliant idea, and in fact there is a common game engine technique called scripting that allows users to do write their own code and have it executed. A short extract from Jason Gregory's Game Engine Architecture (third edition) from page 794 can be found below: 

Image + author source: here The green is set as the transparent colour of the image so that you don't have any unwanted areas of colour. You will need to know the coordinates of each animation in the animation sequence in the spritesheet in order to play them. For Android, we can take a look at an open source game engine by Chris Pruett (formerly of Google) called Replica Island. The source code is available, and we can look at his SpriteAnimation.java and SpriteComponent.java. A is simply created with a frame count and a unique ID and each actor in the game can have multiple animations. The can be given a number of s, each with a duration in milliseconds. This means that different animations can be swapped in and out depending on if the character moves or attacks etc (see in ). Each iteration of the game loop, the 's is called, and it checks how much time has passed since the last main loop iteration and decides which frame to play next, then returns the frame to get sent off to the rendering system. This allows it to skip animation frames if the animation is going too slowly. I hope this example works, and you can see it being used in the actual game on the Android Marketplace here. 

id Tech 3 isn't really free - it's GPL, so your entire Game has to be GPL. You used to be able to license a non-GPL Version for $10,000 but that options seems to have disappeared after the Bethesda-acquisition. Apart from it's age, id Tech 3 doesn't have much in the realm of Single-Player AI. So if you want to make a "traditional" shooter, you have a lot of AI work to do yourself. Another problem is the tooling. There are a lot of Map Tools, but that's about it. There is very little assistance in the Asset Pipeline or Shader creation. On the upside, the Team Arena source contains an early version of MegaTexture and supports relatively large outdoor environments. 

Nowadays, most music seems to be prerecorded, but that means they are rather static and take up a lot of space. I wonder if MIDI is still a viable option (especially considering consoles or iOS) and if I can expect General Midi 1 to be available everywhere? (Note: Referring to the software instruments for sound generation from notes) Alternatively, are there vendors of embeddable software instruments that can generate the desired sound at runtime? The whole point is to re-create a dynamic soundscape in which instruments can change their volume, speed or pitch - this can be partially simulated with individual tracks, but it doesn't offer the same flexibility. 

Your language looks like CSS, but it isn't. It's your own Domain Specific Language. Ask yourself this: Do you really want to create your own file format, for which you need to write a parser. This parser needs to be fast and robust. You also need to document your file format and teach people how it works - after all, it's a customized language. You then need to be aware that you may run into issues you never thought of - maybe someone thought it's a great idea to create a 50 MB file and your parser crashes, corrupting a savegame or so. Or you decide you need to add a feature that can only be implemented with a breaking syntax change, thus breaking all the existing files. The reason why formats like XML are so popular is because XML has these problems solved. You can find many great XML parsers that are proven to be robust, fast and leak-free. Also, many people know XML files and how to edit them, and because it's such a generic but well defined syntax you can be sure that you can extend later. Your motivation seems to be easy editing by hand, which is common in community SDKs. Now, the reason people edit those files by hand is that they don't have the tools the Game Devs use. You can assume that a company developing a game for several years has some graphical tools for editing such files - they may not be great and bugfree, but they edit the files for you and developers only rarely edit them by hand in order to tweak something. Those tools are rarely released in 'Modding SDKs', so most modders edit by hand. So my initial reaction would be: Instead of spending time developing a new, unproven format that is easy to edit by hand, I'd rather use a battle-proven format and spend the time writing tools that make editing easy. But blanket statements don't work like that. It always depends. If you spend 3 or more years writing a big game with a sizable dev team, then you can spend a lot of time developing, testing and finetuning your system. If you have 15000 files to parse, then finding ways to reduce memory usage becomes important. But for small/medium/indie games, I'd go with a known and well-supported format like XML and a nice tool to edit it. 

If you're considering 2D animation, rendering one sprite and then another will not be a problem for the device (unless your sprites are huge). Below is a typical animation sprite that is the first one I found with a little searching. This is a commonly used technique and there are lots of websites that offer free (and otherwise, always check the license) spritesheets. 

For reading data on the other side, there's some nice libraries such as PySerial which allow you to read serial data in Python, or you can do it directly from C/C++ on Linux as there's usually a serial port defined as ( in the case of Arduino's virtual serial ports). The GNU screen program allows two way communication with any device as well, and in Windows MATLAB also has the ability to read in serial data, and I'm sure it's possible in other languages - I've just never tried it. If you're not too experienced with the systems I'd recommend the Arduino. It has many more uses than the fairly simple circuit you're after and might be a little overkill, but you can do a lot of awesome things with it and it's an all in one solution that doesn't require any extras. Edit: The serial port options I described all allow data to be sent both ways very easily, you should note that you'll need to add some extra circuitry to your dice circuit in order to use this with a parallel port. 

I would suggest you look into adding scripting functionality as this would be a better solution to your problem. There are many scripting related questions on gamedev.stackexchange to get you started!