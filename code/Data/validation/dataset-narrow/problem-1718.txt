Currently RPi.GPIO has to be run with root priviliges to allow GPIOs access. There are changes in the pipeline which will remove that need, but those changes might be several weeks away. 

It is a Linux executable built for the Pi's CPU. You have the source code and it is compatible with Linux. 

Perhaps try different software? I've used (my) Python rotary encoder software to read multiple encoders. If that doesn't work you will probably have to code your application in C. If all you want to do is count pulses then just use a simple callback. The following code will set up a default callback on GPIO 2 and GPIO 19. The count (tally) of pulses is checked every second. 

It is always best to give the full path to commands and data files when not running programs as your user. In this case rc.local is running as the root user. The Python version you expect to use may or may not be in the root users path. The operator will refer to root's home directory () which probably is not where the Documents directory resides. Replace python with the full root to the Python version you want to use (enter the command to check). Replace with (I guess) . 

A digital POT is similar to a digital DAC. You can change the output voltage by setting the input value. As long as your motor controller just needs to sense voltage it should be fine. The digital POT will not supply much current at that voltage though, perhaps just a few milliamps. 

The Python spidev module has been broken (I think) since Linux kernel 3.15.x. Its maintenance has recently been augmented with more support so I expect a new version shortly. See Read this if you use Python Spidev. 

The L9110S can't supply a great deal of current (less than an amp per channel). I assume you have checked it can drive your stepper. Use any GPIO you want for the L9110S inputs. You will need to connect a Pi ground to the power supply you will use for the stepper driver. If you will be using the Pi 5V supply then just connect a 5V pin to Vcc of the L9110S. Which Python stepper library are you planning to use? 

To test without a working switch enter the following commands at the command line (a different shell to that running the script). 

wiringPi uses the Linux sysfs interface to the GPIO for interrupts. I.e. it will not select synchronous or asynchronous, it will use whatever Linux does. I don't know what Linux does. I do not think wiringPi touches the hysteresis setting so it will be whatever was previously set (the default at power up in on). 

All the Pi's gpios are digital, they read as 0 or 1 depending on whether they are connected to a low or high voltage. To read an analogue (continuously varying) value such as a voltage you need an ADC (Analogoue to Digital Converter). You connect the varying voltage to the ADC and the ADC to the Pi. The connection to the Pi is typically made using the Pi's in-built SPI or I2C link. That will allow you to read the analogue value on the Pi. Look at ADCs such as the MCP3008. 

Yes, feeding any voltage over 3.3V or less than 0V into a Pi GPIO can destroy the GPIO and/or the Pi. The UART RX/TX pins are GPIO. 

You need to power your servos and DC motors externally to the Pi. There is no reason they can't be controlled from the Pi. The pi is just as capable of sending control signals to the servos and motor driver boards as an Arduino. 

Yes, the Pi3B can supply 1 amp at 5V with the following proviso:- The current consumed by the Pi itself and other peripherals connected is less than the polyfuse rating (2.2amp?) less 1 amp. 

You can count multiple pulses per second on the Pi without issue. If you are getting false edges I would suspect dodgy wiring. Here is a webm video of the Pi capturing pulses from 28 gpios and passing the edge information to piscope for display. Here is a webm video of 800 Hz PWM being generated on one gpio and magnet sensors on a shaft being read from others. The above examples are using my pigpio library. With the pulse rates you are talking about any gpio library will do, you could probably use bash! 

Dodgy software. Obviously no attempt has been made in the software to check the data for integrity. Find some different software, there are plenty of Pi alternatives. Here is one of my offerings (requires the pigpio daemon to be running). $URL$ 

Each device will be connected to a random selection of NTP servers to automatically load-balance the overall system. Otherwise the temptation would be for everyone to connect to the same tier 1 servers. 

You need the while loop to do something. You could use pass instead of the sleep but that would consume 100% of the CPU in a busy spin. The sleep consumes hardly any CPU resources. You could just as well sleep 60 seconds rather than 1 second. If the while loop is absent the main thread will finish and force the other threads to finish as well. The callbacks have their own thread of execution, so yes, they are triggered independently of the main thread. 

This is a fairly standard practice, long used in software development to test software before hardware is available. By the way my pigpio Python module runs on Windows/Mac/Linux PCs. 

Leave one end of the jumper wire connected to the GPIO. Connect the other end of the jumper to 3V3 and check it reads back as high (1). Then connect the other end of the jumper to ground and check the GPIO reads back as low (0). Using my pigs utility the procedure would be (assuming GPIO4). 

If I understand correctly you want to control a brushless motor which is being driven by an ESC (Kontronik CYBEC 40-6-12). ESCs are controlled in a very similar way to servos. However they often require a particular start sequence for safety reasons (you don't want your model plane to fly off when the ESC is energised). I suggest you try something like one second at 1000 µs pulse width followed by one second at 2000 µs pulse width That may initialise the ESC. You can then send pulse widths in the range 1000 (stop) to 2000 (full throttle) to control the speed. If you are planning to do this seriously you'll need to use something like my pigpio or servoblaster to send the pulses, or buy external PWM hardware, 

The wiring appears to be wrong. The MCP3008 SCLK appears to be connected to ground. I haven't looked any further. 

One method would be to create a RAM disk. I use one simply to save wear and tear on the SD card. Create a mount point on the SD card, e.g. /ram 

No, the system does not impose a limit (not quite true but the limits are well beyond what you would sensibly do in practice). In practice the number of users logged in will be limited by how many you can find a reason to simultaenously use. If I was carrying out a test I might log in as the same user a dozen times, with each window showing a different view of the test, e.g. one might be generating output, a couple might be listening for inputs, a couple might display error message, one might be running top to monitor CPU usage, etc. etc. 

When you see no DISPLAY it generally means the program (or part of it) wants to run under the X Windows GUI. Try startx to run the graphical X environment. 

Personally I'd use one of the many libraries and/or daemons available to you to do the PWM. Have a look at servoblaster and its clones which provide daemons to provide dedicated PWM. Or perhaps have a look at the PWM features provided by wiringPi with the bundled gpio utility. Another alternative is my pigpio daemon and the pigs utility which provides multiple ways of generating PWM. All of these can be called by a bash script. 

SD cards contain a chip which handles communication, data reads/writes, CRCs, wear levelling etc. This chip will be active whenever power is applied to the SD card. If it decides to do do wear levelling or another internal operation at the time that power is pulled that may cause a problem. However anecdotal evidence suggests that some people seem to be immune whereas others suffer all the time from corrupted SD cards. Perhaps those who don't suffer have been lucky enough to buy original unfaked SD cards. 

I'm not aware of any ready built solution for your needs. However you could write your own with not very much effort. How many different calls do you make to the gpio functions? You might find you use less than 10. Just create your own local Python module named the same as your target module and produce stubs for the functions you use. E.g. if you use function gpio_write() which takes a gpio and a level your stub could just be 

If I understand correctly you want to adjust the backlight according to the inverse of the lux reading. I.e. the darker the environment, the brighter the backlight. Firstly the Pi has no way of reading a voltage so you need an ADC (Analogue Digital Converter) to convert the varying voltage into a number to be passed to the Pi. Look for something like the MCP3008 which allows for up to 8 inputs and provides a 10 bit resolution. The received number will be 1023 for 5V (min lux) and 0 for 0V (max lux). As the MCP3008 will need to be powered from 5V its output line (DO) will need a voltage divider attached to drop the voltage to a Pi safe 3V3. A web search will find hundreds of examples for the Pi. You would then map those readings onto a PWM dutycycle setting. So that min lux becomes max dutycycle, and max lux becomes min dutycycle.