The reason I like option #2 is because it is more concise. It lets you get rid of the class all together and keeps your success or failure logic based on whether an OrderID has successfully been assigned, period. It doesn't rely on a LINQ statement that checks for the existence of a message type flag in a collection. I think that the code behind saving an order should be as atomic and clear as possible. I'm not sure I agree with the Guid thing, but that isn't really the question. Come to think of it, if your alerts are really being used as progress indicators and not just errors, I would think about using instead of to pass it throught the rest of your processes. But again, that doesn't really change the design pattern. In C++ returning a or a numeric value while also passing in pointer(s) to class instance(s) as function arguments is an EXTREMELY common pattern. My guess is, that is why they put out and ref parameters into the .NET framework. It certainly wasn't for speed. I hope this is the kind of critiquing you were looking for. Take care! Update from discussion This is an example pattern that you could use if you implement . I created a fictitious scenario for a complex ordering process. This was written straight into the text window without any real functional analysis. So, please think of it as a rough pseudo-code design with lots of room for changes. But, it does accommodate atomicity and heavily exploits the encapsulation features provided by the language. Update #2 - notice that now you can create as many different types of models as you want without ever having to create new AlertCollection instances by hand. They are already there. 

okay so now we have 3 subclasses and can get their priority, so all we have to do now is sort our list, and then remove all the ones that aren't free. Then, at position 0 we will always have the at highest priority! 

so all I know here, is that it's a list of Strings that represents the ships that player A has. But to find out how it does that, I need to go look at where and how it's used. So I search through the code and find this line 

So no the class is your "Runner" and is used in your main method, it contains an instance of a and a . Hopefully you found this review helpful, keep up the good work! 

Give one line per import. Your code lacks a main guard. If I was to import any functions or classes from your current code, your slot machine game would start! Generally you just want to wrap your code in a conditional check that looks like 

This would make your NbaDraft object more robust, could provide it with any number of team names to deal with. You could also easily then keep a file full of all of these names so as not to clutter the code itself. You have a printDraft method, it would be more flexible if this method simply returned a String instead, and then you can just print it, or use it for any other purpose. Eg. in a JPane/JPanel or a JavaFX window. at the moment you're constricting yourself to ONLY printing to the console. 

It seems using a generic class might be a good choice for this. See if this code fits what you're doing. Off the top of my head, I can't see where using against a is going to work except for the built-in primitive types or types that implicitly implement a string cast. But I guess if you're just parsing generic data though, that should be good enough. The first method just shows implementations for a primitive, an enum, an array, and a generic IEnumerable. I'm not clear about what you mean regarding it being used in a for loop. If your only using the function to recast your input, then a static method works fine here. Meaning that you don't have any other reason to store the property string for later use. If you do need to store it, then the static methods in the code below would need to be changed back to instance methods. BTW. For the life of me I couldn't get the 

I can't think of a more appropriate place to have a discussion like this. Here are my thoughts. I prefer Option #2 with a subtle change in the calling convention, like so. 

line to work against arrays or generic lists so I changed that in my example as well. Anyhow, I hope this helps. Good luck. 

Now, you have an Order class that is a Model and also consumes IOrderServiceProvider classes that do order-specific functions. Encapsulation, Inheritance, Polymorphism ... that's all I'm sayin' here. 

here, you're using the random module to generate a random index and access it. There's a much easier and more readable way to access a random element from a list. 

Thanks for sharing your code, it's looking good but I think we can make some improvements. Currently, the method doesn't actually make use of ! We can just remove that, so we end up with . And then when we call it later, we don't need to pass in a object. you say that returning null is a bad idea. I agree with you, and would suggestion you use an instead. This was introduced in Java 8. It's intended purpose is to act as a value to return when the actual return value might not be there. To me, your example looks like a good use case! Let's see what your method looks like if we use an Optional. 

So I think we could break this up into 3 different classes. Let's talk about what our view can look like 

Hi thanks for sharing your code! My answer isn't going to touch on the algorithm itself, but I wanted to talk about a way that you could make your insertion sorter more flexible. At the moment, your sorting only handles integers, if you were to use generics that implement Comparable your insertion sort anything that implements that interface. Consider the following classes ( your algorithm remains unchanged) Sorter interface 

Now they can do whatever they want with the list they passed in, and it won't effect your object at all! Efficiency at the moment your selectSong method has O(n) time complexity, because you need to (worst case) iterate through the entire list to find your song. A better data structure to use here would be a Map. This allows you for O(1) or constant time access. Instead of your JukeBox being backed by a list, you could have it backed by a HashMap. So you could have O(1) access to any song given its name. Or maybe a Map, or even both. your selectSong method could look something like this 

In order to have a "unified" (I realize how ambitious this actually is) syntax when working on dataframes, I wrote the following functions that is a general purpose dataframe set of tools in R. 

My knowledge in graph theory is very limited. I have to look for elements in an (undirected) graph who are in the same connected component. The idea is simple. First, build the graph. Then, allocate a "color" to a point and spread it to its neighbours recursively. Once there are no neighbours to color any more, pick a point without any color and repeat the same process. This ends when all the points have a color. I wrote the following class : 

Comments I don't really see the point in on top of your methods. You can just type which automatically propose a neat documentation, per example, in the MatrixCreate function : 

I wrote a simple online logistic regression, calibrated using gradient descent to compare the speed of an OCaml implementation vs the same Python script, executed with Pypy. It turned out that the OCaml implementation was slightly faster than the one run with Pypy (by about 10%). Now I would like to optimize my code even further. The assumption about the data is that the values of each rows are sparse (can be considered as factors), they are encoded as integers (collisions are allowed) and stored in a large array. maths.ml 

Note : I am using OCaml 4.02, but I could upgrade it to 4.03, especially for the Array.map2 methods. 

First off, I really like this Juke Box idea as an OO design project, and it's looking quite good. Write immutable classes when you can 

This way you don't need to worry about either, not that that would really be a problem here anyway. This while loop could be a lot simpler. Try breaking it down into multiple well named boolean values instead. 

thanks for sharing your code I know that this isn't a huge amount of code, but I'm going to look at it assuming that we will want to be able to add additional features and expand upon the code that's already here. Redundant Comments comments should say why you're doing something, not what you're doing. This line 

But then , and are not great variable names. They do have a small scope and are used immediately after, but there's no reason to not give them a better name. Why not just call them then in the next loop you can just use 

And again, no need for a comment. Following this, I would say that "r" is not a good name. I would prefer roll as a name instead of "r" and maybe "rolls" as the name of your list instead of roll. If a variable is called "roll" I would expect a single value, not a collection like a list. Misc. Comments 

This Sorter interface at the moment has just one implementation, but if you decided to work on other sorting algorithms, you could make a MergeSorter, QuickSorter, TimSorter etc. I've changed from a static method to an object that you instantiate. Insertion Sorter Class