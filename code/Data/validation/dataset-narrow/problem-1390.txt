Q: How does the graphics device know that I want to draw using a specific effect when trying to draw instanced geometry? A: By biding the effect to the device, setting up shared parameters before the draw call and passing per-instance effect parameters in the instance data stream. Q: Exactly what should I be removing from my 'VertexElements' variable - what happens to each element? Are they being passed to a shader? Am I right to assume I dont need the 5th element? A: Let's have a look how you would go about rendering the same mesh twice without instancing: 

If you wanted to draw 100 instances of the same mesh at different world transforms, you would thus have to repeat steps 4 and 5 for each instance. What's so bad about that? Well, you have to issue at least one shader constant switch and a draw call per model and minimizing these numbers usually helps improving performance. Now, wouldn't it be nice if we could just fill some buffer with the 100 world space matrices we'd like our meshes to be rendered to and just pass that buffer to a single draw call? Instancing does just that. It allows you to issue a single draw call that will repeat the rendered primitives a given number of times while advancing and addional vertex stream only every Nth primitive (once after each mesh). In our sample case the code would go like this: 

Q: How are my transforms ( in InstanceBuffer ) being passed to the shader? A: By binding an additional instance stream. In the example you referred to it's these lines: 

Bind the vertex and index buffers to the device, containing the mesh geomtry Bind the effect (shader) to the device Bind an additional vertex buffer to the device, containing 100 world space matrices Draw the mesh 100 times with instancing 

I've noticed quite a few mobile games on the Android platform recently that prompt you to download their assets package when you first run the game. As an example, The Sims 3 is available for iOS and Android devices (Android Marketplace, Apple App Store) but the iOS version seems to be much larger in size and as such probably doesn't use this system. I can think of several advantages and disadvantages to doing this: Advantages (to developer): 

While I understand that direct comparisons of the two methods are difficult, I'm looking for statistics/reports preferably of the same app with control and sample groups. If that's not available, can anybody with experience with this method indicate whether users preferred not bundling assets? Does user opinion on this vary based on platform? Does the value to users outweigh the extra effort for the developer? 

The only reason that I can see for including a compiler in an application is that you wish users to be able to write their own code in C++ which is compiled, linked, and executed at runtime. This isn't a brilliant idea, and in fact there is a common game engine technique called scripting that allows users to do write their own code and have it executed. A short extract from Jason Gregory's Game Engine Architecture (third edition) from page 794 can be found below: 

Also, assuming these libraries have been tested for mathematical accuracy, are there factors other than ease of use (documentation, mailing list/developer access), speed (vectorisation, SIMD), and memory usage to consider? 

I would suggest you look into adding scripting functionality as this would be a better solution to your problem. There are many scripting related questions on gamedev.stackexchange to get you started! 

You're getting the banding because of a bad setting for colour bit depth on your surface. Romain Guy and Chet Haase (both Google employees who work on graphics in Android gave a presentation that covers these issues at the San Francisco Android User Group in 2010. The video is available on YouTube here and I've actually made some notes on the stuff they cover (shameless plug) here. Specifically the section that you want starts at about 25 minutes in and lasts for 10 minutes. Relevant section from my notes: 

You might want to read Christer Ericson's excellent blog post on draw call bucketing: $URL$ Alpha blended objects will have to be draw back to front to avoid artifacts. State batching will not help with reducing the amount of alpha blended objects being rendered. If you're looking for a way to discard objects that do not visually contribute to the scene, then what you're looking for is culling. What state batching will help with is to ensure that your alpha blended objects are actually drawn last and in reverse depth-order. It will also ensure that within both your alpha and non-alpha buckets all objects are sorted so as to keep expensive state changes to a minimum (primitive, shader, texture, shader constant, etc.). As for rendering opaque objects front-to-back (with depth testing enabled): If your pixels are expensive to compute (read: complex pixel shaders), then not having to compute the same pixel multiple times can be an enourmous gain - which gives rise to the idea of an early depth-only rendering pass (Z-Pre-Pass). 

In the shader you then receive the geometry data (the mesh vertex in its local space) and the instance data (the world space matrix) and can use both to render the instance. This means we can now render 100 identical meshes at different world positions in one go. What if you'd like the models to use different textures? We can do that as well by filling our additional (per-instance) vertex buffer with structs where the world space matrix is just one field and some other field might indicate which texture to use. In the sample you refered to that's called InstanceInfo. 

You basically time your function calls and then store those timings in some kind of database. You can then add a debug overlay mode to your game and display those timing values. Niklas Fryholm's wrote a post on the bitsquid engine's development blog which I used as a starting point: $URL$ When you have the basics working most of the further work is identifying what data you want to collect and how you want to display it. I found looking at screenshots from RAD's Telemetry quite helpful in this regard: $URL$