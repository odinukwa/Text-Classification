What I came up with is a variation of a "multiton"; a class that cannot be instantiated in code, but has a finite number of static instances each representing a valid value of the type. They are implicitly convertible to strings and so the static members just drop in wherever a string is needed. 

You can do this with vanilla Linq. The question is whether you want all keys on the left plus new keys from the right (a "full join") or common keys between left and right plus all keys on the right (a "right join"): 

I'm going to assume that the != in the main pivoting loop is a typo, because combined with the lack of checking that the positions don't cross, the positions would be incremented beyond the ends of the array and the whole thing would error out. and should NEVER cross. In addition, even if they don't and you miraculously end up with both leftpos and rightpos on the same element (which would have to be the pivot), you swap that element with itself unnecessarily; don't do that. Finally, in your code the "left half" call always starts at index zero; that means that the left-half call that branches from all right-half calls will scan through the entire left-hand side of the array, not just of the half it should have been given. Because the left half is sorted first, there should be no swaps, but it still has to scan through all those elements, which makes the right-hand half of the algorithm approach O(N2) complexity. Try this: 

As far as the general strategy, it doesn't look too bad. Getting a "return status code" from a method is more than a little outdated (try-throw-catch was designed to replace this style of method return), but there's a lot of "legacy code" out there, and some built-in methods still return values that indicate failure. The return value of DoOperation(), if any, should be its conceptual "product"; data produced by DoOperation as the result of a computation. If DoOperation, conceptually, doesn't make any such calculation, it would be better conceptually (and thus from an understandability standpoint) to return void and instead throw exceptions on errors. However, you'd have to throw and catch multiple types of exceptions, or keep track of multiple states instead of just "logging". Also, I don't know if you simply omitted it for the operation, but I would think that knowledge of exactly what went wrong might be good to know, and so any general catch should be or similar to allow use of exception data when handling the error. 

So I had this idea; what if I could decorate my Enum values with an attribute that cross-references a "default" value of another Enum that should be used when a variable of the current Enum type has this value? The desired usage would look like: 

The basic idea of all Project Euler problems is to find an efficient solution to the problem, by knowing enough math to simplify the computation your program must do. You can brute-force all of these with enough computing power, but there is a way to reduce the complexity such that a program that solves the problem will give you an answer in under one minute with a 5-year-old computer. The brute-force answer would be to start at 21 and try every number in order until we found our answer. That's not a great idea, as the answer is quite large, and while, with a powerful computer, you might arrive at the answer in good time, brute force simply won't work in other Project Euler problems (you'll exceed hardware/firmware limitations, or end up with an exponential algorithm taking longer than the estimated heat-death of the universe to compute). In this case, with a few smarts, we can break down the problem and work with smaller numbers, thus taking fewer steps. You want to know the smallest number divisible by every number from 1 to 20. Well, for one number to be divisible by another, all of the prime factors of the divisor must be present in the prime factorization of the dividend. For instance, 20 is divisible by 10 because 10's factors, 5 and 2, are both present in 20's factorization of 22*5. The quotient is the product of the remaining prime factors; in this case there's only one, 2. Now, the solution of the problem becomes more apparent; the smallest number divisible by every number from 1 to 20 is the smallest number that contains all the prime factors of every number from 1 to 20. So, the solution is to find the prime factorization of every number from 1 to 20 and keep a count of how many of each prime factor is necessary. Prime factorization is technically an inefficient process (you have to start with the number and divide by every known prime number until you get a whole-number quotient, then repeat from the beginning with that quotient until you're left with 1) but the numbers are so small it doesn't matter. The solution is the smallest number for which the prime factorization of every number from 1 to 20 is a subset of its own prime factorization. At the least, you'll need one of every prime number from 1 to 20. You will also discover that in order to be divisible by 16, the number must have 4 2s in its prime factorization, and to be divisible by 9 and 18, the number must have 2 3s. The smallest such number is the number that has ONLY the needed factors, so the answer is 

The calls to CheckForDuplicate(...) seems to be on the same level of concern so maybe make a combined handler for that: 

To avoid the overhead of cutting of the length you could use an enumerator instead like this in order to handle the first group separately: 

Nice and clear code - a couple of things though: The total number of occurences (the sample size) is constant per input string: 

I think your solution is quite OK, it is doing what you want it to do. You can sharpen the if-statements a little by using for all but the first, because an animal can only be one kind. Alternatively you can experiment with a -statement instead which will make the code more clear. By the way: you don't need the flag for cats () because it's the 'lowest' level of animal type. You solution with a switch statement instead of if's: 

which is a misunderstanding of the concept in that an method (unless it is a UI-event handler) should return . In the new implementation is removed. This has the positive effect that when is called by and the parameter to has more meaning. In the first version that call returned immediately after starting which in turn in fact was the long running thread. It is in fact possible to await a call to like this: 

If their role is more advanced than that with methods and state, it IMO calls for at class hierarchy in some way like: 

For some kind of fun I've replaced your byte array with the buildin BitArray (as mentioned by Dmitry) in you class just to see the effect (it seems to be slightly faster). Further I've tried to implement the sieve algorithm as linq based. It all goes like this: 

As others have pointed out you only have to check the number of distinct characters in the sentence. A one liner doing that using linq could be: 

In this way the first permutation is returned as soon as it has been computed and everything is running more smoothly. 

Your code does not read numbers from the "console until input isn't a number", but reads 100 inputs strings from the console and returns those that can be converted to integers. If you want to read numbers from the console "until input isn't a number", you could do something like this: 

A more 'advanced' approach could be the following, where I use a little Linq and an enum of Animals: 

Because of the flag-behavior of ConsoleModifiers.Control it will be true if any combination of Modifiers are pressed that involve . It would maybe be more useful to make it more distinct like: 

I think you show a good understanding of F# as a language and functional programming in general as far as I can see. A couple of things though: You use as variable name on multiple levels of function definitions. It makes it hard to read. IMO is a very readable construct for more than two matches. But for only two I prefer if-statements. The function/sequence is a kind of double sequence. I would do it this way: 

The properties of the Book class should be read only (or private setable) as the title etc. of a book will and should never change. I think Remove is a better word than Delete. I don't like the way the ExitCommand terminates the program, because the application has no way to do clean up. You do not check for a negative input value in the command selection loop. You should be more careful and distinct about how you name your variables etc. Stick to one convention for cases etc. 

2.2. function_traits.h These are simple template class specializations that provide the required function traits for the implementation of . I realize that specializations for and functions are required. 

3. Sample usage Here's some sample usage to show how a user can get the return values. Basically, the user would send in their function/functor to the dispatcher and would take care of the rest; the dispatcher would return the from its submit-a-function function. 3.1. Example 1 This example is pretty much just a test of the template deduction rules and shows how you can use a collection to erase types. The main feature is that you can have a collection of functions that all have different signatures and return types. 

Basic algorithm Since you have very large files, you should consider streaming the file one line at a time instead of loading them all once; your program would use a lot less memory. You would also not have to copy your , which is very large! In order to know which files you've already processed, you could create a new file that holds a list of all the files you've processed and write to it as you stream from the original file. This is of course, assuming you want to keep the original file intact. I will continue under this assumption as the other case (simply delete from the list as items are processed) is simpler. Check the Notes section for a better idea that you can implement with inspiration from the following section. Implementation The following is a sample implementation for the algorithm I described in the previous section. For brevity's sake, I did not include the items mentioned under the Form section, nor did I include exception checking; I will leave those things for you to figure out. It is also most likely not as optimal as it should be, but it's merely meant to show you streaming. Sample 

Consider what happens if returns value A, but before the expression is evaluated, is changed to some other value B. This could cause to say that the queue is empty when it isn't or that it isn't when it actually is. Conclusion These are two of many issues that are currently in your code. I've decided to stop here since that's a pretty bad problem. This current implementation if not safe at all. I recommend you do some more reading and learning about thread interaction. Good luck. 

I've actually implemented the same functionality in the past, so here are my comments. Wrong behaviour? It depends on what you can consider wrong. Consider running your own example and inputting . The 2nd will be left in the stream buffer and will be automatically assigned to your 2nd variable. This clearly causes weird behaviour, but it is the same behaviour that occurs when normally using . Suggestions The following are what I consider to be useful features for such an utility function. Better interface In order to provide a nicer interface, you could instead read a single value from your stream and then discard anything else that's been left in the stream buffer; calls to will always return one single value and successive calls won't be forced to take what's left in the stream buffer. Example 

Notes A faster way to check if a file has been processed would be to add a character indicating that it has been processed, for example: 

Beside that I would change the flag to an too, because you can then distinguish between more levels like: 

Sometimes extra parenthesis can make an expression clearer for the human eye, but here the computation is more or less incomprehensible for non-experts, so they really make no sense. Whether or not you should have spaces between operands and operators is a matter of taste - I prefer the spaces. 

Overall your code does what you intend and that's a good start: to print a diamond with numbers. The first improvement could be to handle an "arbitrary" sized diamond: 

If the operation is user-interactive, then it would maybe probably be better with a dialog or wizard where they could select the valid columns. 

But this will halt the calling thread while HSecondCounter ticking every second infinitely with no way to stop it. So this is not useful. 

I would let PDF.WrongPasswordException (because you don't have a choise) be the only exception to catch in this method, because all other exceptions have nothing to do with its Purpose (to check for password). If the file it self is missing or invalid, then you really can't tell if the file has a password or not and therefore returning false doesn't give the client valid information. If the IO exception instead is left to the client to respond to, he can react appropriately. 

It is IMO easier to understand because the index is incremented in a more "natural" place, and the Write...() functions knows where they are. If you insists on _index as a class field, you could do it like this: 

With only a couple of hours ahead of you in my experience with F#, I find the essence of your code fairly functional, although the graphic output is hard to grasp as it has a lot of flicker. Below find a gentle review of your code with improvements (or at least another way to do the things) and inline comments. I've tried to improve the graphic output by using colors and a distinct update of the cells only when they change. 

is IMO not an appropriate type in this domain. I would use or maybe If you for instance run the following test, both and runs out of range: 

From this mathematical model and analysis it is very simple to calculate the result. Some comments on the code: 

2) When checks the input list it does not find changes to items in the list, if they are of reference types. In your test environment it find changes to the string items, because a string behaves like a value type in this case and the changes made to the string actually make a new string - not a change to the existing string object. So your method actually finds a new string not a changed string. If your list was a list of a class like: 

I largely agree with JanDotNet. I'm not sure if it's a good idea, but maybe should clean up after it self as a IDisposable? 

It looks alright to me, although it seems odd having a young man of age 20 to equal an "elderly" man of age 30 :-). I have 3 minor things: 1) One MemoryStream can be used to serialize all expressions: 

which of cause requires a lot more work. Update If you want to filter a list of skills by SkillLevel, it can be done like this: