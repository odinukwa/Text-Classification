Note: No inheritance is necessary here. The same effect is achieved through closure of the method. Sample calls 

I'm not sure about my caching strategy. From what you say in comments above, you may need to revert to what you had originally. script.js : "script.js" doesn't really need to be touched. The messaging protocol is unchanged. I've just made a few tweeks. 

Alternatively, assuming to be the sum of all the other values, then it can be accumulated on the fly : 

Separation of concerns: Better separate display/styling/HTML issues from the high-level application code (the questions posed and the responses provided). Object-oriented approach: Consider for example constructors; Survey(), Section(), Slide(), Radio_group(), Radio_button(). Question types: The survey is currently limited to a hard-coded "VERY DISSATISFIED" ... "VERY SATISFIED" scale. Other semantic scales could be offered, as could "Yes/No" booleans. Branching: It's not atypical for surveys to branch - ie to be responsive to the answers provided. Branching would probably require a change of approach, by which slides are built on-the-fly rather than building everything at the start. Colors: As it stands colors are limited to those specified in the CSS style sheet. You might consider a more flexible, data-driven approach, implemented wholly in javascript. Summarizing results: There are issues around the summarization of Likert scale questionnaire results that you need to be aware of. I'm sure the web includes many other good articles/discussions on the subject. 

To perform exactly the same manipulation on every member of a jQuery selection, jQuery will perform all looping internally. is only necessary when each member of a collection needs to be manipulated in some specific, individual manner. 

This will be slightly less efficient than finding elements within tbody containers but still better than finding by ID - and Tablesorter will still work. 

Two observations : 1. Transactions Calling a function from within a callback does not in itself cause that function to be part of the transaction. It seems likely that everything in and its sub-functions should be subject to the transaction defined in . If that's what you want (and you probably do), then you need to pass and use it in called functions rather that defining separate transactions. 2. Asynchronous flow control There's little asynchronous flow control in the code. Much of it is written as if it was synchronous. For example, both and perform asycn operations but neither informs its caller of completion. Therefore there's no hope in the caller (or the caller's caller, etc) to schedule things to happen when those async activities have comepleted. If sequencing matters (and it probably does) then you need to be working with promises. 

Thus modelled, the basic timer paradigm is . Only simple manipulation of value is necessary to provide count-up and count-down variants, and is a view consideration, not model. We should see : 

Searching a whole, large DOM for elements is a real performance killer. When possible, always try to search a fragment, or traverse the DOM relative to a known element. With a little rearrangement of the HTML, "network", "boot" and "check_in" elements can be found within the corresponding "selector" element, similar to the way "util" and "workgroup" elements are currently found. This alone should give a significant performance boost. HTML 

Some of the code looks to be as little dodgy. For example, means that any added class that is not will never be removed (unless by some other code). Contrast with , which is guaranteed to add/remove the same class. Aside: With the tbodys in place, you could consider styling them with eg a border that will expand/contract as the details are shown/hidden. If performance is still poor, you'll need to investigate deeper to discover what's taking time. Though I'm not an expert driver, Chrome debug tools are very good for diagnosis. Edit Back to a single but with , , , in place, try selecting as follows : 

The d3.js code is very similar for the two plots. You could save some 150 lines of d3.js code by writing a generalized function and passing in a few parameters. Other than that, I wouldn't agonize over the number of lines. Graphics code is often bulky. 

Code doesn't look too bad for a first attempt at using promises. Here are a few observations. General 

You could probably contrive a way to handle the reversal and push objects onto in the second inner loop but at the cost of readability. Overall, the above changes are mainly cosmetic. You almost certainly won't notice any performance improvements unless the data arrays are huge. For small data arrays, I would be quite happy with the original code - maybe just do the (if it's correct) instead of . 

The worst feature of "webworker.js" as it stands, is the need to pass to almost every function, so (and its properties) can be operated on. This can be avoided by factoring the code into Constructors (classes if you like), each with a bunch of methods. I found that the code fell very naturally into three Constructors : 

It's hard to comment when the original question was very vague, the Original-OP (O-OP) failed to answer questions, different interpretations were made by the various respondants, and there's (currently) no accepted answer. Even worse, someone saw fit to remove the tag, implying that only a CSS solution would suffice - a view that did not come from the O-OP. None of that was your fault. The worst feature of this answer (and possibly others) is that the paradigm is reliant on a particular font size - change it and the step-formation falls apart. You might consider something like the version below, which goes a long was to fixing that particular issue, and tidies up the code considerably : 

Possibly also the 27 jQuery collections, though the prefix already identifies them pretty well. Then do a lengthy, careful trawl to pick up on the new structures. 

Reusability issues As it stands, is a strange thing that hovers somewhere between reusable and not reusable. 

... which is functionally identical but easier on the eye because it allows the first to be coded the same as all the others; it does not appear to be a special case. 

no ids and no rediscovery of freshly appended DOM elements. no need for the function - instead, positioned clones of the prototype are appended. all steps are absolutely positioned on the same bases using and ; the vagaries of mixed natural flow and relative positioning are avoided. the number of assignments is greatly reduced. consistent indentation!! 

I think you need the three inner loops but can get away with just two outer loops by moving the third inner loop into the second outer. In addition, I would choose to do as follows : 

(Obvious) ... when doing simplifications, test at each stage and don't move on until it's working again. 

Edit: After reading the answers by @cFreed and @Sumurai8, I can see that my answer can be improved quite a bit - a solution of just 9 lines. I don't want to overtly steal from the other guys but will post my revised answer if asked by the OP. 

I'm not really an FRP expert so can't really comment on that aspect per se, however, I can show you how to better organise your code. 

Note: doesn't have any methods and isn't really necessary. It avoids a lot of bulk in . webworker.js : The result is highly readable, object-oriented code (untested) : 

Here's the kind or code you might end up with, meeting all the above objectives (except generalizing the d3.js code, which remains very bulky). 

Yes indeed. Object-oriented filters will help considerably. Then you need a mechanism for defining filters in your "user-code". In re-factoring the code to provide a constructor, you might also consider : 

Also, I think the sort can be avoided. It seems that after the second loop, the values within each of the "data" arrays are cumulative, therefore already sorted ascending. If I'm right then all you need to do in the third loop for a descending sort order is 

All of which is interesting and potentially useful, but rather odd in some regards. [1]: is successfully and concisely coded. [2]: could be regarded as subverting jQuery. As it stands, the plugin leverages jQuery to provide an alternative way to bind methods to DOM elements, whereas we would normally expect a jQuery plugin to expose public methods via the jQuery interface and/or have private functions for internal use. [3]: could be inconsequential, useful, or a total annoyance, depending on the role of the plugin in the context of a wider application. [4]: you could consider a mechanism for user code to override the default selection of , eg by passing a selector in the hash. Out of interest, a more conventional jQuery plugin to achieve the same ends (with some extra features) might look something like this : 

tested only for js parsing So that's your BODEPLOT "library". To use it, you would write something like this : 

The routes take no account of failure of . In fixing (1), you can (probably) execute once and deliver via a promise in those routes that use it. In routes that use , you can start with to ensure that nothing is executed if or failed. In , doesn't wait for . The test is a bit odd when is guaranteed to be undefined. 

The need for timeouts is worrying. Definitely needs investigating. Possibly due to async loading of SO content? 

If it is intended that there should only ever be one instance of , then factor it as a module, not a constructor. If is to be reused, then : 

If I was to make any changes to the code at all, the first thing would be to give the overloaded Controller (instance) namespace some internal structure. To make it clearer what's what in the rest of the code-base, you could put : 

The code looks to be pretty sound. Here are a few things to consider ... The need for the function (in the global namespace?) can be avoided by moving the contents of into the existing . Some DOM elements need to be rediscovered on each of several user interactions. This is trivial in a small development document but could be slow in a large, real-world DOM. You can cache more jQuery objects in the same way is already cached. This is a trade-off of UI responsiveness against memory. Fixed CSS maps can also be cached. Again a trade-off. Here it is complete with a few other improvements such as method chaining : 

Surely is already defined as a attribute so why not read it from the DOM in the same way as ? Alternatively, simplify the HTML down to the wrapper and generate its content dynamically. The legend doesn't appear in either Opera or Chrome. 

Please note, from ECMAScript 2015 (ECMA-262, 6th Edition or ES6), some of the following advice will change. In particular, ES6 offers Classes and Arrow functions. At the time of writing, ES6 is only sporadically supported in browsers On a general point, unlike PHP/Java, JavaScript has classless constructors. What looks like a "class" is actually a constructor, therefore you can do more in than just declare its members. You can execute any statement you like including calls to methods established on the . Regarding : 

Demo With some extra thought, you could maybe code a couple of built-in, named sorts in the plugin, or pass a callback for full flexibility. Demo 

A wholly synchronous step in a promise chain doesn't need its own and can be merged downwards with following synchronous step(s) up to and including the next asynchronous step. Completely flat promise chains are not always the best. Nesting is perfectly acceptable and often offers big benefits in terms of closure and flow control. You can avoid clumsy outer vars when it's possible to pass them down a promise chain or keep them in a closure. Arrow functions would help make the code more concise (and arguably more readable). 

will simplify considerably by taking an object-oriented approach to defining the filters and providing each filter with its own method. 

In practice, you may define both plot-functions and filters either internally or externally. It's very easy to make mistakes when re-factoring to this extent, so I doubt that my code will work first time. Typical errors will be out-of-scope vars, and referring to the wrong object. Happy debugging. 

A separate reuse issue concerns everything in the vex dialog (, , etc), which is created afresh every time is called. Much can be created once per element (or maybe once in total) and reused by rolling some of into the constructor or the outer scope. Leave the resizing and part behind (and all the stuff I think). Also, the object is static. It need not be defined/redefined in the constructor. Global namespace There's no apparant reason for using the global namespace? If you really want (or an instance) to be globally available, then it could be assigned as a jQuery static method or refactored as a jQuery plugin? Use of jQuery Why not exploit the power of jQuery? Coding in POJS is very noble, but bulky and generally less readable. It's not clear why you might need polyfills for some portions of jQuery when you are already reliant on jQuery for Vex, which is a jQuery plugin. Others According to the documentation, accepts a DOM element, not an id. If the documentation is correct, the element doesn't need an id. Accessing and immediately after has been set might work in some browsers when an image drawn from cache, but generally not. Best to attach an handler and move much of the code inside it. is created conditionally therefore is not guaranteed to exist in the line where it is used. , and are confusing. Why make an alias for , then use ? What is ?