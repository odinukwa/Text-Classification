You're not even using the coordinate when you're storing your tiles. You're just using and some random value: `( Sprite.dirtTile,x,RandomHeight)'. Which likely means you'll have tiles stacked on top of each other, meaning your list is going to contain some tiles that are occupying the same position. However, the naive approach to finding the tile at a specific , given how you're storing your tiles, is to iterate through the list until you find a tile matching those coordinates. 

You'll want to get a vector based on your current velocity and heading. Then use that vector to increment your position. 

They work just like day/night cycles in real life. It's daylight for a specific amount of time, then it's dark for a specific amount of time. Basically you have an elapsed time counter. You decide how much real world time converts to your game time day. This is typically displayed through the skybox and lighting. Display a sun and blue sky during the day, show starts and the moon at night. 

Most of these things you can start small with and develop solo. They may not have fancy graphics or spectacular effects, but they'll demonstrate your potential and develop your skills. You do it gradually like any other task you're learning in life. Start very simple, create something small that can be improved over time with more and more complexities. 

The majesty of these animals is unparalleled, so I'm not sure why they're not allowed citizenship rights everywhere, but there you have it. tl;dr As long as you're operating in Scotland or Internetland you can accept Unicoins. 

Then, to save those settings so you don't have to reset to the defaults every time you start Blender. Go to File->Save User Settings. Or press Ctrl+U. This should save the factory default settings over your settings that went awry. 

When you instantiate using the default constructor for , the position is set to (0,0,0). You can use the alternative constructor for , and supply a position and rotation. If you want the child object to be position at zero relative to the parent, you can supply the parent position as the position to instantiate to. 

That's because every object has a script attached that's listening for a mouse down event. Each one checks to see if the mouse is down, and if it is, destroys itself. It's not clear how you want to select which object to destroy, but there are a few options: 

There's actually a pretty nice article about this at Gamasutra (7 pages!). While Beizer curves will smooth a path, it won't cut across grid spaces like in your video example. For example (from the article): 

It's a simple change to logic really, simply use a test instead. If is greater than or equal to your trigger amount, you should fire the trigger. Then you use the to increment it. Additionally, you can create a more generic object to hold information for a single event. 

Looks like it's using a sine wave to change the scale of an object. Sine ranges from -1 to +1, so adding one to the variable puts the range at to . Then adding 1 to Puts the range at 1 to 1.10. As the name implies, this would likely give the appearance of pulsating. Multiplying the time by 6 compresses the sine wave on the x-axis. Making the pulsing happen faster. If you were to multiply it by a smaller number (or not multiply it by anything) you could slow the pulsing. 

You can use the steering to create loops. Simply have two targets for your missile. The player is one, and a loop target is the second. Every N seconds, set the loop target to the missiles current position (plus a small random amount to either side of the missile's heading), and set the missile to steer towards that target. Since it's already in flight, it'll have to pull a u-turn to make it back to the loop target. Once it's either touched the loop target, or come "close enough" to the loop target, switch its target back to the player. I imagine this will produce loops and probably even figure 8s (dual loops). The small random amount to either side means the turn direction for loops will change, you can set it to the same side each time if you want loops in the same direction. Alternatively, you can have the rocket steering be normal, but have an additional force on the rocket. This force would be perpendicular to the direction of travel and the strength would vary over time (perhaps with a sine wave). You'd have to test it out, but I think that would give you bigger loops, without changing the turning radius of your rockets. Perhaps something like the rockets in The Clone Wars (the only clip I could find showing this, rockets just past the 56 second mark). 

The algorithm defined in the document you linked is for generating terrain on the GPU. The data isn't stored in an array that can be easily modified and re-rendered. Without access to raw data you can manipulate, you're not going to be able to modify the terrain at run time. It's certainly possible to modify the code that generates the terrain, thus changing the terrain. However, it's far more difficult to see the relation between what's being generated on screen and lines of code, than it is to see a tool like a 3D paint brush modifying the terrain directly. You could heavily modify this code to accept additional parameters that would allow you to create areas of modified density. However, if you're going to be storing data on the CPU side you may as well store everything there, and send the raw data to the GPU to be rendered. Either way, modifying this existing code to allow for dynamic generation will be a fairly significant undertaking, and you might be better off pursuing alternative methods for procedural generation that don't rely so heavily on the GPU. 

You can find information about implementing both in this GDC paper from '99. Start with implementing both independently. Then apply both at the same time, with a blending factor. You'll have to modify the blending value depending on how much you want to wander vs how direct you want the steering to be. If you want the regular pauses, you can add a random duration for the path following to run and another random duration for it to pause. 

Monogame's documenation can be found on their site: $URL$ They also have tutorials on their github page: $URL$ If you're looking for detailed documentation like Microsoft has, you're out of luck. Monogame is an opensource engine. Not a well funded company like Microsoft. Documentation is the last thing developers usually want to work on, so when they aren't being paid for it, it's the last thing (if ever) to get done. 

Obviously you'll also want to keep track of the state of the users progress, so you don't keep showing the same messages over and over. But, the method is the place for those types of things. 

There's a list of different collision types (ray-plane included) that can be found here. One of the better sources of ray-plane intersection can be found here. 

If it's worth it or not depends entirely on your needs, the goal of the project and the resources available for the project vs what resources it will take to upgrade. However, simply based on what you've described, I would see no reason to upgrade. You've said the game you wrote still runs fine, so it sounds like there's nothing to fix. If there's no problems that will be overcome by switching to 2.0, it's not worth it. You'd just be generating work for yourself at that point. If you were to start a new project, you might as well use 2.0, if that project also doesn't have the requirement of supporting older devices. 

Additionally, any top down perspective where the camera is at the center of the screen. This gives the kind of view you showed in your comment: 

You can still use Perlin noise. You simply need to constrain the random value to three values. Depending on how you're generating the noise, you'll get a value between -1 and 1, or 0 and 1. Whatever you have, just divide it by three, and place your tiles based on that. 

It's a simple answer! is a four component vector, using half precision floating point coordinates. The extensions you've shown are quick ways to create new vectors using the values from . is a four component vector with the values: is a four component vector with the values: is a two component vector with the values: . 

Now when I cast a ray out to the black dot, to do so correctly in perspective projection, I have to cast from where my camera is (which is the sharp point on the left) out to the dot. That's what the extra math does when creating the vector for the ray. 

You can implement your own version of the below. Create a static bool in whatever GUI class you have available to all your scripts. Now, whenever you start a click operation with NGUI, you can set that bool to true. Then simply check to see if the bool is true before doing operations in other scripts. Ideally, if you have access to the NGUI source, this is a change you'd want to implement there, so it's all in one spot. Remember to set it to false at the beginning of each frame. 

Your camera movement is jerky, not the movement of your object. When updating the camera position it's best to use , this ensures that the update takes place after all of the other calls. This means the position of the camera will be accurately positioned for the same frame you're updating. As stated in the documentation: