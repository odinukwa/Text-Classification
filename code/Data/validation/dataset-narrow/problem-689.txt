What is done in : 1) we filter the connections to work on with the refactored ; 2) we use the standard function to calculate the sum. It takes the initial value and performs the calculation using the current value in , tupled with each of the filtered s. function can also be simplified using our refactored and : 

Since and are pre-validated constants, I suppose that they cannot represent a cause for a . But from the original code, it is not clear whether is validated as part of URL pattern or not. If so, an would be appropriate here. Otherwise the catch block should log the exception message and return an instead (also change the return type to and the return statement respectively). I'd also suggest to rename this method to . 

The builder instance can be extracted into a dedicated reference and you'll be able to apply the common instructions on it only once, for example: 

You correctly identified the part that differs among these methods, so next step is to exclude this part. Its role is to initialize the instance to be set on . This instance can just be passed as argument to the extracted method: 

are simply awful and indicate that there is a deep design issue with the definition of the entities used throughout the code. The worst case is when such calls modify the state of the deeply dependent objects, e.g. or . It may be a real hell for debugging. Encapsulation , and should not be directly exposed and should be accessed/modified with getters/setters. Missing Abstractions There are many class casts like or and checks with . It looks like the hierarchy of objects that may be returned by is chaotic or there are some abstractions missing. I cannot say more about it, because the example is not enough to conclude about. 

Misc There should be a general check for input data that the args contain numbers. I've tried to pass "test" string to and it returned , which is not explicit from the user's point of view. type does not seem to be used elsewhere except in the optional return type declaration in function. The type and the declaration can be removed without any harm. In functions, and should be renamed according to their meaning, something like and . I'd also suggest to extract clipboard operations into dedicated functions, for example: 

It looks very ugly and should be extracted. It will be a bit difficult to implement it by using a hierarchy similar to the Panes, because of chained method calls. But this can also be done by implementing a single builder for all your Panes, where there will be a way to set the type of the pane to build. After all these refactorings, you'll see that the total number of lines of code will be reduced at least by half. 

Do you find this pollution with generics, spread everywhere in the code, useful, readable and aesthetically pleasant? I guess that what you are trying to do here is to anticipate a probable future replacement of s with s and so on. Update. To reduce this overflow of generics, that may be useful to transform into an abstract class and add a short one that inherits from it with the right numeric type. But I doubt that this is necessary at all. Your virtual space is better defined using integers. Why not just have a class with ? That will avoid boxing/unboxing with in many cases. Similar changes may be done with the other generics used... Genericity is good, of course, but it should be pondered if it's really necessary here. Consider Using Existing API The class seems to have a number of features similar to or . They may be considered for reuse here. p.s. Please change package names to something that respects Java naming conventions. 

This class contains two blocks. is too generic. Dedicated per type catch blocks or a multi-catch block for expected exceptions, like , should be used. Since JDBC4, there is no more need to call in order to load the driver. should be able to cope with it. 

I don't like that you use to set the function. suggests that I can append a bunch of functions and they all get called when the event happens, which is not the case. would be better. It would make sense to take advantage of move semantics. The lambda that gets passed into is moved into and then copied into , when 2 moves would have been enough: 

Don't put into a header, because everyone using your tree now also has the whole standard library in their namespace. Put the public parts above the private parts. People are only interested in what they can actually use, not the implementation details. should be since it cannot be used in a meaningful way anyways. Don't use , use instead. is just a macro for (in theory it could be something else, but in practice it never is). Nonsensical things like and compile even though they are clearly errors. doesn't have that issue. Prefer initializing in the class directly instead of writing a constructor. 

If your constructor initializes members the class initialization is treated as not existing (so no loss in performance for double-initializing), but if you forget or leave it out you get sane defaults. I would like to see and in the part of for encapsulation. If you let users access those types they will use them which I think is not intended. 

Was it a requirement to not use the standard library? It saves you from some of the pain of implementing boring, difficult and error-prone things such as sorting-algorithms. My solution The problem with squaring the array is that negative numbers become positive, making the array not sorted anymore. My idea is to find the index of the first non-negative number and then squaring the whole array. The partial list is sorted in reverse order and the partial list is already correctly sorted. Two sorted lists can be efficiently d into a sorted list. The reverse ordering of the first list can be compensated by using a . 

To print a matrix we would simply do this: . What you did is combine a container (holding multiple objects) together with input/output and the actual functionality of matrix operations. You should try to make each class only have a single purpose. The only purpose that should have is to do matrix operations. Instead of writing an example by hand I'll refer you to eigen where they did all of this plus some other neat tricks. Now imagine I did and my output said "The sum of 1 and 2 is 3". That would suck. Your shouldn't do that either. 

Now you get more type checking and have less repetitive typing to do ( instead of ). I did not capitalize because it is not a macro-ish constant anymore. A side effect of this is that you cannot do anymore because does not decay into an like does. Instead you can define addition and subtraction operations such as this: 

Some of your member functions should not exist. You don't want algorithms and containers to result in implementations, because that number becomes rather big. Also people tend to forget to add all algorithms to their containers, especially when new ones appear. Instead you are supposed to implement algorithms and containers separately to only need implementations. This applies does not apply to , and that have a non-member function , and because the member functions are more efficient than the free standing functions. Also only moves elements while actually erases them. Unfortunately it doesn't apply to because requires random access iterators which you don't have. Your implementation seems to make a lot of copies. If you can't find a clever efficient way you can just create a and that and then apply the positioning to your list. I would expect a linked list to work with move-only types such as , but it doesn't because you copy s in various functions. I am getting compilation errors with both gcc and clang. It looks like you only tested with VS's compiler which tends to be a bit lenient. Avoid functions. That is what the destructor is for. Also you already have . Your does bad things when . For example you can do 

The variadic template is not a pack forwarding references, it is an rvalue reference pack. For it to be a forwarding reference variadic template, the variadic template must be a function template parameter: 

Demo Note: The public interface should be based on as defined in the C++ standard. This implementation is purely for demonstrative purposes. 

I don't know Python, so this is a purely C++ review. 1 PYObjectBase 1.1 What is a const rvalue? Move operations ownership of some resource generally, so how can a move operation's parameter be ? It logically does not make sense. Your function... 

Inside , we find the function which returns both the remainder as well as the division result. This function internally is likely to use processor specific instructions so that only one operation (division) is required to get both the remainder and quotient. Your compiler might perform this optimization, but let's not leave it to chance. Note that per Tamoghna Chowdhury's suggestion, we use and for clarity. 

Unaligned memory Your storage is aligned for , which will lead to performance issues in most architectures and in others it just won't work (crash). Replace: 

Mark non-modifying functions as . functions of yours include , and a few more. Member functions that don't modify any of the class data members should be marked as so that they can be used in the appropriate scenario (accessed through a ). 

Additional usage/test This simple example shows how one would create the symmetric difference operation of two integer packs using the already existing operations: The symmetric difference of two sets A and B is the set of elements comprised of: 

We need to test whether a certain door is openable by a certain key. Using the previous building blocks, that's easy to implement: 

Do we really need and ? No. Here is an alternative solution: You currently allocate bytes. This is wasteful. You can use exactly as much space as you need by declaring your storage any of these two ways: 

Now that you are using static memory, you can provide two private functions to avoid having to use ugly casts everywhere: 

Refresher on the simple selection sort This is a simple implementation of a selection sort on which the template-meta-programming version is based: 

We can see that this is much more concise and easy to read. I believe that it is worth the extra layer because it automatises the pattern and conforms to DRY; it is used in the remaining types. 

Performs the set intersection of two integer packs. The output set is sorted. The output set will have the same integer type as the integer pack specified as the left template argument. Tests 

Provide a constructor that directly initializes the matrix Currently, you have to call , which simply allocates and default constructs the number of specified elements. This is inefficient unless you want a default-initialized matrix. Provide a constructor that allows you initialize the matrix directly: 

This change requires that we also perfect-forward these universal references wherever they may be used: 

Review goals The full implementation (with iterators and a -like interface is omitted because of the amount of boilerplate code involved. This question is already long. A sample toy implementation is provided in the demo below to demonstrate minimal usage. I would like a review that focuses on: 

Although C11 introduced , there is no support for aligned reallocation (AFAIK). The structure that follows and its related functions provide such functionality. I wanted to provide something with as little overhead as possible, which is why there's close to no error checking done. I envisioned this structure being wrapped in another structure that does do safety checks if that is required. Is this reasonable design? features: 

Replace long conditions with type traits. In order to promote from a smaller type to a larger type, you currently enable certain conversion operators based on on your type . These quickly become hard to maintain and are error-prone: you might forget to add a type, you might forget to update something, etc. In order to solve this problem, you can take a type traits approach. It will require some boiler-plate, but not much more than what you've already got with those long enable-if conditions. Traits based approach: