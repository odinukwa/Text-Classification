You should just be able to plug in the card. If for some reason that doesn't work, according to this post, you should be able to copy from one OpenELEC SD card to another. It looks like that may be Linux formatted though, so you'd need access to a Linux system to do that. (You could use another SD card to boot the Pi in Rasbpian, and a USB SD card adapter.) If you've made changes to config.txt, you can simply copy that file across to the new card once OpenELEC is installed as well. 

You should still be able to setup your Wi-fi from the command line. If you use CTRL-ALT-F1 will switch you to a console terminal. You can then edit /etc/wpa_supplicant/wpa_supplicant.conf to add your network: 

Of course, if you actually wanted them to be two separate networks, that's no good. What you want then is to do Network Address Translation (NAT), like your router does to the internet. In which case it's time to enter the land of iptables. 

Note that not all Wi-fi devices will support this though as it requires the ability to spoof MAC addresses, which not all devices support. If your card is of reasonable quality it should work though. (If it supports hostapd you're probably fine.) 

You can connect it directly. It will just be very quiet (think headphone noise range). You can compensate some by turning up the volume. A louder sound would require an amplifier, or a lower resistance speaker. 

There's a standard linux utility called iperf which does a pure network speed test. You'll need a second system to run the test with as it's over the network. Identifying the bottleneck is tricky. With Wi-fi it's as likely to be signal strength as anything else. However, assuming that it isn't, Wi-fi will suffer the same fundamental problems that wired Ethernet on the Pi will because they're both over USB. And the USB on the Pi just isn't that great. It was really designed as a client not a host chip. The foundation has made great strides on the software side improving this but it's still not perfect. What this translates to is an effectively top speed of the wired Ethernet of 80 mbit. Which is really effective USB top speed on the Pi, as everything hangs off the single port on the Broadcom chip through hubs. So if you're writing to an external hard disk and using the Ethernet at the same time, you'll probably get 40 mbit download and 5 MB/s read/write. Part of the slow speeds on the USB is due to CPU overhead, but not all of it. Mostly it's just a poor USB implementation I think. 

On the C# side it's a little bit more complex, but there's an example here, which I'll reproduce modified below: 

Finally, you need to configure devilspie2 so that it knows what to do about matchbox-keyboard. You need to edit : 

Yes. The easiest way to transfer files is with an SFTP client like FileZilla. Install that on the computer you want to transfer the files to. Start the software, then put in the IP address of your pi, your username, and enter the account password when prompted. You should see a list of files in the home directory (e.g. /home/pi) which you can then navigate and download/upload to, just like FTP. 

You may also need to edit /boot/config.txt so that hdmi_drive=0 to ensure audio comes out the 3.5 mm jack. This assumes that your network is configured correctly, of course. 

You can use UDP fairly easily in both languages. Something like this on the Pi sets up sending packets: 

These go in the script from that page. I'd suggest setting the latter two options to have, so 8 and 32 respectively and see if that improves performance. Edit, if sound starts to stutter, increase them until it stops and latency is acceptable. You can change them independently as well. 

Based on what @joan has said, consider maybe using the Python SPI library, seen here. You can also open as a file and read/write bytes to it. See here for an example. 

It's not really a solution, but I had a similar problem with my Pi that it couldn't be reached until it initiated a connection. I simply made it do so at boot, problem solved. Edit the file to add in a command like so: 

In situations where the configuration is perfect, often times on the Pi you're let down by your power supply not providing enough current to power the device. This is particularly true if you have a Rev 1 Pi (with only 256 MB of RAM). In this case it looks like there's almost enough current for the Wi-fi adapter, but not quite. So the connection fails when it starts drawing current to decrypt the signal from the access point. Try another power supply, at least 1 A. 

Normally you would connect both sensors directly to SDA and SCL. However, it looks like the am2315 uses a fixed address so that won't work. I suppose you could route SDA through a transistor or relay for each sensor to switch between them. (A GPIO pin would then select which sensor you want to read.) 

Upstart replaces the traditionally init system, which means that the file is now effectively ignored, ignoring your change. All is not lost. Upstart also allows automatic logins. It's simply a matter of working out which configuration file. Information on this seems to be a bit sketchy (and I don't have an Upstart enabled system to test with), but it looks like you can edit the file to add the bit, so you end up with something like this in the file: 

After you add this simply plug in your wireless adapter and it should work. More directions here. CTRL-ALT-F7 or F8 should take you back to LXDE. 

Ctrl-Alt key combos won't work on Raspbmc because XBMC running on the Pi runs under OpenGL directly on the framebuffer, and not under X11 like it would on a regular Linux desktop. In order to get a terminal in Raspbmc you need to quite out of XBMC without powering off. This should be possible by going to the little power icon and selecting "Exit". 

If it's not showing up in dmesg or lsusb, it's a hardware problem rather than a linux driver problem. (Even if there's no Kerenl module for a device the physical connection should be made.) Is there any place on the PIC32 you can check the voltage? I suspect it's not getting enough current to power up correctly. Maybe try running it through a USB hub? 

I think that this compiling under x86 is a fluke. According to the read manpage, it's part of unistd.h. Same for close() and write(). Only open is declared in fcntl.h. I think you'll need to include both: 

Battery packs are good, but when they're dead they don't let the Pi know. So the Pi dies and you risk SD card corruption. Anyone else remember SCANDISK or NTFSCHK? That, but worse. The MoPi board takes pretty much any battery and powers the Pi with it, without the risk of sudden cut-off. They get 8 to 10 hours on 8 Ni-Mh 2600 mAh AA rechargeable batteries. 

The autostart file is called only when Openbox starts. If it fails to start for some reason, then anything in that file won't be running. As danielbathke mentioned, /etc/rc.local is a more appropriate place for background programs. Anything there will be run at boot regardless. However, since that's run before X11 starts, anything like xset which requires X won't execute correctly, and so the proper location for these things is in the autostart file. Fundamentally, the difference is things in /etc/rc.local will start regardless of whether or not OpenBox or LXDE is started, while anything in the autostart file will only started when the GUI does. I'd put and in /etc/rc.local; and , , and in autostart. 

I'm not sure that the GPIO SYSFS export actually supports PWM. Servoblaster provides a SYSFS like interface through /dev/servoblaster for controlling PWM, e.g.: 

(This means there should be no # in front of it.) After that hopefully make will run correctly. If it doesn't it seems there's a larger problem with FreeSWITCH. 

To take a screenshot remotely with scrot as suggested in comments over SSH you'll need to specify the display: 

And then from your remote system use a VNC client (what one you needs depends on your other system) to access and monitor the application. You can use SSH forwarding of port 5901 to access it over SSH without adjusting the firewall or router further, e.g.: 

The compiler is looking for external files (I'm guessing includes amd libraries) to verify the function calls you make to them are valid. The former are essential. The latter is part of the compiler doing all it can to make sure the program will work so that if it fails, it's the user's fault. You can copy all of the files necessary across in one go, and then manually specify with gcc (and ld) -I and -L search directories for the files. As for which directories to copy, I'd suggest at least /usr/include, /lib, and /usr/lib. There may be others but those contain most of the stuff. Keep in mind that you need to have -dev packages installed for linking to most libraries because these contain the .a files necessary. 

If it supports Wheezy it should work fine on Rasbian, as Rasbian is based on Wheezy. Looking through the script briefly I don't see any reason why it wouldn't work. 

I think the simplest approach from your point of view would be to ditch CherryPy and work in PHP under Apache2. It should make it clearer how you can connect things together if you're working in one environment. For example, you get database access through mysql_connect(), and you can access the GPIO using the exec() function to run shell scripts. Unfortunately I think this starting point is the best I can do. Without knowing how your code is currently constructed and how you want everything to ultimately interact, it's impossible to give you step by step directions. This sort of a project sounds like a really good opportunity to learn so continue to Google and ask questions!