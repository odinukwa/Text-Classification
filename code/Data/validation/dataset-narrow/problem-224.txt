David Hay's Enterprise Model Patterns. This book lays out the basic patterns found in most enterprises and provides wonderful instruction on clear thinking about how to model the world. It focuses primarily on discovering entity types and relationships. Fabian Pascal's paper Business Modeling For Database Design. This paper is the first in Fabian's Practical Database Foundation Series and is the perfect companion to David's book as it focuses primarily on the discovery and classification of all the various business rules and how they will map to constraints in a logical database design. 

The key to the solution is to decompose the ternary relationship into the binary relationships supported by the business rules. Those were the many to many relationships between employees and departments, and between departments and locations. Then, implement the one to many relationship between location and employees that shows that, while an employee may be assigned to many departments, they can be found at only one of that department's many locations. Note that it is not possible to depict the portion of rule 5 above that states "...which is by definition a location that is an address of a department the employee is assigned to." This is a good example of the limitations of ERDs. Their strength is the ability to visually depict entities and their relationships, and their weakness is they cannot depict more complex business rules beyond relationships. This is why it is vital to investigate and discover all the business rules and not just the referential rules governing associations. Fabian Pascal's paper Business Modeling for Database Design provides excellent detail on all the necessary rules to explore. Ronald Ross has generated a large body of work on this topic as well. Chris Date also wrote a short book on business rules. 

Have unique unordered rows Have uniquely labeled unordered columns Have a single value of whatever domain the column is defined upon in cell 

and so on. Thus we know that for every value of x, there is value of y that will always be that value of y for that x. Codd adapted this to data management with respect to determining if one data element's value always results in a known value of a second data element as if it were the input and output of a function. So for example, if we find that each employee of a small company is given an employee number, and we create a simple list of employee numbers and names, we find that the name is functionally dependent on that employee number. Every time we see the employee number 7 for example, we see the name "Jim Brown." This represents in the database the proposition that is true in the real world - namely that employee number 7 is the person named "Jim Brown" that we can point to and say "that's him." Functional dependency can be implemented as a unique constraint because there is a one to one relationship between the input to the function and the expected output. In the algebra example, when we plug 2 into the equation 2x + 1 we will always get 5. Applying that example to data management in the example above, each time we have the employee number 7 we need to have one and only one name and other characteristics that goes with it. We can't have employee number 7 associated with "Jim Brown" and "Bob Jones" anymore than we could say that plugging 7 into 2x + 1 can yield 15 and 25. This application of simple math to data management is the fundamental underpinning that allows the DBMS to be told how to protect data integrity without having to understand the semantics of the data. Functional dependencies are by definition implemented when a unique constraint is placed on each table identifying each set of data elements that have a one to one relationship with another set of data elements and whose values always vary with that first set. The notation is typically: 

The oracle tool places an X over the crows foot on the many side to show that the delete rule is CASCADE. It also shows the keys, which show the foreign key constraint with person_id on the Account table, and the primary key constraint with person_id on the Person table. 

Logical Level The relational model is distinguished from all other data models in that it is a logical model which describes a logical structure with which to present data (the relation), a set of operators to manipulate that logical structure (the relational algebra), and a set of data integrity rules to ensure the data stored in a DBMS is as faithful a representation of the real world as possible. Three excellent resources to learn about logical database design are: 

The basic operators of the relational algebra are indeed closed and thus when applied on relations always yield relations. Keys are irrelevant as by definition each relation has no duplicate tuples. Any operation that would result in duplicate tuples (for example the projection of a single attribute over the relation) by definition eliminate those duplicate tuples when providing the result. As you know SQL does not properly implement this. Long Answer In order to really understand the short answer, and to understand the addtional nuances that "outer join" throws into the equation, we need to delve into the foundations of relational algebra in number algebra. Number Algebra Algebra is "the part of mathematics in which letters and other general symbols are used to represent numbers and quantities in formulae and equations" as defined by google. One algebraic property is operation, meaning there are actions that work to change numbers. For numbers these are addition, subtraction, multiplication, division, raising to a power, and taking of a root. There are many other algebraic properties as well such as the associative property which states that you can group numbers in any way without changing the result of the operations. These properties give algebra its unique power, in that with these properties we can use letters to represent numbers, manipulate them via the defined operators in equations, and know the transformation will be absolutely correct regardless of what actual number is eventually substituted for the letters. Closure is another of the algebraic properties which states that if an operator which works on numbers always produces numbers then numbers are closed under that operation. Real numbers we know are closed under addition for example. Add any two real numbers and the result will always be a real number. Real numbers are not closed under the square root operation as the square root of -1 is not a real number. All of this comes straight out of the property glossary of the Math Forum @ Drexel. Relational Algebra Chris Date says that Ted Codd was a genius. Codd's unique genius was the realization that mathematical relations, combined with set theory and logic, would be very practical when applied to data management. Fabian Pascal's Practical Database Foundation Series provides an excellent explanation of why this is so, and I'll briefly review a few of his insights. One of the primary database problem of the 1960's was one where a program had to be written for each "question" you would want to ask of the DBMS managing the data. Codd showed that by taking the concept of a relation and adapting it for databases a logical model of data input and output could be developed completely distinct from how data is physically stored. Part of that logical model was the set of operators that would apply to relations - the relational algebra. Just like number algebra allows us to exploit the algebraic properties to manipulate massively complex equations where letters stand for any potential number and guarantee correct results, the relational algebra can do the same for relations. Why is this important? Because with algebra, operations and their results do not depend of what the relations and their attributes actually mean. Then, by adapting logic, which like algebra proscribes valid forms which can be used to evaluate an argument to be true or false regardless of what the propositions mean, a generalized query language can be implemented that enables a user of the DBMS to ask a true question of the data - one of arbitrary complexity - and the DBMS can be programmed using the rules of relational algebra to give a provably correct answer! Now just like with number algebra, closure is the essential property that gives the algebra its power. Relations are closed under the basic operators and as such you can arbitrarily nest these operations at will, in any order, to declare practically any "question" you could ever think of. Once the DBMS is created that implements the relational algebra, unique programs no longer have to be written to find the answer to each question. The DBMS user simply declares the question using the relational algebra. Outer Join Thus far I have been saying basic operators. That is because the theory does not account for missing data. Each relation by definition contains tuples with a value for every attribute. But to adapt the mathematics to the practical realities of missing data some solution has to be developed for when an attribute value is unknown. SQL implemented the NULL and 3VL. Codd later proposed marks and 4VL. The join operator had to be extended to preserve un-matched tuples, and SQL implemented the extension by producing NULLs instead of values for the attributes of un-matched tuples. Date shows that by doing this outer join is: