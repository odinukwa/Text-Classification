The ScrollPos is the "fraction" of a tile. The viewOffset is the current screen/view position in the tilemap (left side of screen) Array/tilemap is needed pr. "row" of background. You could do this in multiple levels too, to produce a "parallax" depth - and with 3D this might look even more cool. 

You can tell Unity3D to use isometric rendering in the camera settings. Secondly, you dont use isometrical graphics on a plane, you just build the world in 2D/3D and let the camera make it isometric. I know this isnt a direct answer about rotation, but if you use my approach, your problem is solved. :-) I quickly did a Google search on the topic and found this tutorial on YouTube: $URL$ I also got some articles/tutorials on it, I think this one could be of usage for you too: $URL$ Remember, most of the time, someone else has had the exact same problem as you, so Google first. :-) 

Some people tells me I misunderstood the question, but others tell me that its a nice answer, so I will let it stay, eventhough its not providing an answer for an alternative Flash editor - sorry about that I'm currently moving FROM Flash and Actionscript 3.0 to Unity3D Framework. Its a GAME-ENGINE made for GAMES and there is a free "Indie" license where you get 95% of the engine features for free forever. You can later on, upgrade your license to PRO (1500$ or something) and then you will be able to use the latest game technologies for bloom-effects, realtime shadows etc. With Flash I had to develop everything from scratch and spend a lot of time preventing people from decompiling my sourcecode so they could cheat. Dont take me wrong, I like Flash, but it wasnt made for Game-development, eventhough its possible. Unity3D has never been made to make "banners" or "movies", but is a pure crossplatform real-time game engine. You can choose from webplayer (small plugin around 2 mb install) that works on both MacOSX and Windows. Or you can choose installer (real Windows EXE or similar MacOS bin) and if you buy the license, you can also transfer the games/applications to mobile devices, consoles like Xbox, Playstation and Wii. So, if you want to make sure that you develop on a gameplatform that also is "allowed" on Steve Jobbs iParanoid system, you should consider switching to Unity3D platform as I currently am. www.unity3D.com for more info. 

The reflection itself is just the specular reflection that you get as an output of the functions of your specific illumination model. There are many different illumination models of varying levels of complexity that will produce a reflection shape similar to this, but a similar look to this can already be achieved with a simple bare bones blinn-phong lighting model, which is (now) probably the most basic lighting model used by graphics engines, and most likely also used by World of Warcraft. It will not be physically correct and completely equal to your images, but it will look very similar. Concept3D's example of the Ward model is more physically correct and works for more complex surface types (namely, materials where the microscopic bumps in their surfaces are not uniformly distributed, but have different probability distributions), but I don't know of any concrete examples of real time renderers that use it, due to poor gains in terms of quality/performance. In practice, such types of reflections on surfaces are supplemented by additional specular/gloss and normal textures, that modify the shininess/roughness of a surface, and the direction of the normals of the surface, respectively, which are both inputs to the lighting equations of typical lighting models. This is done because in the real world, the physical properties of surface most often (except for maybe something like plastic, or a mirror) don't stay the same all over the surface, but can vary wildly from pixel to pixel. 

Keep rewarding me I like being rewarded for my actions. So loads of small bonus items, small upgrades, gold/points something that immidiately gives me pleasure so I want to continue grabbing more and more. Dont punish me with time-limits What I dont like in a game is when the developers finds it too easy and uses TIME as the only thing keeping me from completing a level. That is bad level design. You could use time as a "bonus", but never as a punishment. Sometimes the phone rings, the dinner is ready or even a toilet has to be visited. A pause is not enough here. If I am close to the goal and the level ends just because I was 5 seconds short, there is not much reason for me to try once more for 7 minutes. My approach is to keep the player happy and occupied even in stressed situations. So, none or a minimum of "Whoops dead, replay the last 5 minutes to get right back here"... instead, make it attractice to try again, not a punishment. 

The scripting language that you use now enables you to expose this function to the scripting parser that is running. This effectively means that you can open a text file, write "SpawnZombie(200,300,1337)" and once your engine executes the code, a Zombie will spawn at that location. The other answers already list a couple of good examples of how this is typicaly used, but they leave out one point which I find very important: These kinds of scripts make it very easy to debug or test gameplay during runtime. Let's say you want to figure out the perfect way to place a zombie in the map so it has the maximum scare effect on the player once they discover it. Without scripting support, you'd have to exit the application, change some magic numbers in the code, recompile and test it. With scripting support (providing you already have some method of entering text during runtime, for example a debug console), you just type in "SpawnZombie(333,444,555)" and see how it looks. In the same manner it could be possible for you to spawn weapons, vehicles, load different maps, change the values of some things in the game etc, instakill enemies because you don't want to waste time getting to the part that needs to be tested etc. This will save you tons of times in more complex games. 

A scroller is quite simple a "virtual viewport" that pushes new tiles/objects in from direction you are scrolling. Simple example to see this, is to build a simple 1 line marquee(textscroller). Lets for example purpose say we have a line with 20 characters/letters/chars. We place them in an string/array like: 

First of all there are a bunch of tutorials on Google regarding building Pac-man clones in eg. Flash. Some of these explain the idea pretty well. There is also a site telling the story and ruleset of the original Pacman ghosts AI. Will see if I can find that link again someday. But regarding your question. First of all you need to know your "maximum size" of your levels. In PacMan (from now on "PM" only) the maze is of a certain size, but this wouldnt be too hard to change later though - its only for the principles. A 2D maze can be implemented with ARRAY's 2 dimensional arrays are just large strings of data. I will try to show it with characters here: 

Now thats not a pretty reprecentation of the actual PM, but enough for my point. What I can do now is to store these within a simple array/list of strings. As you havent told us what programming language you will be using, I will just try to use some "pseudo kinda description" (javascript/actionscript/C# kinda ) 

On the programming side, I can only speak for Germany, but everyone that I asked in game development, as well as what I generally read online tells me the same thing (And I don't know why it would be any different anywhere else): Study computer science. And it's not really that hard to imagine why. Programming games (and aspects related to it) requires almost everything you learn in your typical computer science major - on the math side a decent knowledge of linear algebra, calculus, statistics and the stuff related to theoretical computer science (number theory, graph theory, computational geometry, algorithms and data structures... the list goes on and on and on) will help you a ton. Also, most computer science majors will lead you through a ton of topics that are directly related to game development - besides the usual programming courses, there's also courses for things like artificial intelligence, software engineering, project management, distributed computation etc. In addition to all of that, many universities now also offer optional side courses like "Computer Graphics", "Game Development", etc. So if you want to the way of the programmer (instead of becoming a level designer or something), I tell you: Go for computer science. There are of course a lot of things that a strict classical computer science master doesn't cover when it comes to game development - but that's also the case for almost anything that you'll program out in the real world. The "real" experience is mostly gathered by actually programming games as a hobby at home. But that is just the programmers side of course - I can't really tell you where all the other artists come from (Graphics artists, sound engineers etc). Still, I hope my answer helps you. 

From this I can find out where the walls are. I can use this for collision detection, I can use it for pathfinding and I can use it to draw the actual map. You just make a function that will return what kinda "tile" is on a certain coordinate. 

Depending on what sort of game you are trying to make, you will need some place to put the actual game. A Facebook App points to external websites for the canvas part of the application. This is your own webserver/webhotel and what ever language your webserver uses ought to provide you with some database connectivity. So if you eg. use PHP on the server, MySQL might be the datasstorage. If you have a IIS/ASP/ASP.net server available, SQL-Express could be your answer. But with most server-side languages you can also remotely connect through IP to another database server somewhere else. You can also use API's to connect to webservices that allows you to put/get data from their storage. Some are SQL, some are Table and some are XML based, but if you have basic CRUDL functionality at them, you dont have to care about how they do it. Amazon AWS has something called SimpleDB which is a XML kinda storage. It has a great API too, but again, it all depends on your needs, economics and technical skills for implementing this. If you use Flash for a client, then you have the issue of how to communicate with a server to get the data in and out from the client. For this you also need the server-side "something" that can serve your data as needed and receive "POST" data from the Flash-client. So once you have a server, you know where you can put your data. To my knowledge, Facebook does currently NOT support native data-storage, but perhaps others can elaborate on this subject.