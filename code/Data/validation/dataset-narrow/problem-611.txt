edit3 The fact that my little changes do not have the problem of endless recursion in kept me thinking about it and I've been running the code with the debugger to see why I didn't have the problem as well. And now I understand why my code does not have that problem, and your's shouldn't have that as well. In fact, I realized that there is a way of freeing the memory correctly without have a separate member like . Let me explain: In you do: 

I told you that you would be leaking memory because you lose the original pointer that returns. And that is true, however I failed to realize that you have in fact a pointer pointing to the original address that returns: the member of the struct. In you do 

so now the destroy method can do to free the memory of the base object. edit An alternative is that you create a init function for objects that gets an object as an argument and does not allocate memory by itself. I'd do: 

you are indeed setting a new value to , but because is just a copy, the original does not change and with you get the orginal object. That's why 

you are dereferencing the pointer returned by and making a copy of the object into another object. But I failed to realize is that points to the original location returned by . So when you do 

you are leaking memory because you lose the reference of the pointer returned by and you cannot free it when you destroy the object. And you are not checking if is returning 0. So I'd change it to: 

There is one thing I don't line about : you are leaking memory. should be a pointer, not the object. You are creating the object with , by doing 

and in you just do and . I've checked the code above (I've updated with the destroy functions) with valgrind and it told me that everything was freed correctly. 

and this solves the problem with the overloading and the freeing, even though we both didn't realize it at the time. So again, when you do 

Sorry, it seem to me you don't have a real understanding of memory managment and what the dereferencing operator does. First of all, you have no guarantee that after you can access the contents of . After the , points to an invalid location and accessing/dereferencing it is undefined behaviour. Secondly 

is dereferencing , the type is not . In C when you do an assigment with struct objects (not pointers) you are copying bit by bit the bit pattern into a new object. That means that the bit pattern of is the same as the bit pattern of , but they are not the sam object, the reside at different places in memory. You can only call when stores the address returned by either or . If you do you are passing a completely different address to that one that returned in , this is undefined behaviour, you cannot do that. There is no other way for you, you have to store the original pointer in the struct, that's the reason why I added the in the struct, so that the original pointer is not lost. 

shouldn't do end in a recursion, because points to , but is still unchanged and points to . And now you can use the same behaviour for destroying the Employee object. Let's say you have function pointer in which points to the destroy function: 

Usually I see tuples in js implemented with arrays though of course an object - while annoying to write would be just as valid: . So for this sort of use-case (creation and light usage of a bunch of temporary objects) I'm curious if there's a significant performance difference so I set up this jsperf. Object tuple test: 

This is of course fairly advanced coding but it is possible and probably only about 10 lines of code. Like I said you can look at Automapper for some of this functionality out of the box (though I don't know how well it would do with windows/web forms). I will say that what you're looking for is similar to the functionality provided by the MVVM pattern so if you're doing windows forms you can look at Truss. If you're doing web forms...well I wouldn't do web forms, this functionality is already in ASP MVC and silverlight which are both like a million times easier to work with but I remember there being some buzz about the ASP MVP project that would help with those issues. 

A direct answer to your question: Just remember what dropdown controls have been initialized and hide those. 

I'm getting more and more into programming js in a functional manner which makes heavy use of multiple returns via tuples (especially useful with recursion). Also, a pattern that I use often is creating simple temporary values for projections 

It's not really a problem, and I like to gently prod newcomers into learning features like lambdas. That being said, I don't think that your url duplication int the first case is anti-dry, its a perfectly acceptable method extraction and it's private. Within the scope of private methods you can do pretty much whatever you like and it's not going to offend anyone too much. Another possibility that you might consider (though it would be a greater scope) would be to extension method the url so you can do url.ConfigureUriVariable("foo", "bar"). The above would be a bit clearer if instead of a string you used a dedicated Url class. I recommend the built in Uri or make your own. But really, I think you're all good. BTW - the lambda is still compiled to a delegate so the generated CL is pretty similar using either of your techniques. 

In other words, this methodology is good for idempotent, non-mandatory tasks such as "clean up the temp directory" or "remove any unused profile images from the file system" 

Ok, so I just recently arrived at a way of doing this sort of thing that I actually like so let me share. In my opinion, the if statements aren't really the problem, its more that they are not really pertinent to controller code. Actions should strive to contain code only about major decisions of what code path will be executed. Solution: You take advantage of the fact that a Linq query returns an IQueryable to store the query logic along with the model and an extension method to give it a nice DSL like interface. Similar to the pipes and filters pattern. This is what the action is going to look like: 

This is honestly pretty good. I usually use to set the paths and configurations on require (it's going to grow a lot as you add things like shims, urlArgs, etc). You will also probably want to reuse it in several places. See my blog article on how I recommend doing this. The general idea is that you don't use to bootstrap things, you instead have a request for the configuration file and another to actually bootstrap the specific page of your application. Next, I'll ask why bother injecting and manually into ? Injecting dependencies is what RequireJs already does. app.js 

Create additional identical list during cloning ('hinging' the cloned one off of the original list) and through clever pointer massaging, split the two and return one of these as the cloned list (O(n) in time, O(1) in space) Use a HashMap and two passes over the list during cloning to first clone the list and then assign the random pointers using the (O(n) in time and space). 

Is there a lingering quadratic behavior in my implementation? Is there a better way to test the than relying on String comparison as I have done? I could compute a hash and compare that but that is just a variation on the same theme. I am trying to hide as much implementation details as possible - so any Node leaking, I would dislike. Is such a data structure ever useful? Save for perhaps cryptography, I can't imagine a use case for it - but surely, there are far better crypto-algorithms available. 

I am doing interview studying and would like to have another look at my implementation of Floyd's cycle detection algorithm. I've implemented a simple linked list which can be fluently configured and works generally for any type on stack. The cycle detection method serves: 

I found both approaches a bit confusing - it feels like is too involved, and especially in 1), prone to nasty pointer-related bugs. On the other hand, I've strived for clean, compact, fast and easy-to-read and operations without pointer mess or two passes over the same data structure - at the expense of extra memory and sacrificing concurrency (I am maintaining a static ). More precisely, is O(1) and shoud be exactly O(n). Discussion While the implementation runs correctly for lists of about <= 100 elements and while I am reasonably confident the clone operation is indeed linear time, cloning scales really poorly (and varies wildly in execution time) and I am not sure why that is so. After running dozens of experiments and tests, empirical evidence suggests after 115 elements or so, cloning takes upward of 30 seconds (when I usually stop the test). For comparison, cloning 10 elements takes the order of 10-100 ms and cloning 100 elements anywhere from 500-4000 ms. Unless I am not seeing a glaring super-quadratic algorithm, the only explanation I can think of is that larger element sets tend to form cycles more quickly and randomly, so the recursive gets stuck in loop - but this is just a conjecture which I am not sure how to prove (except brute force). There are ways to detect cycles in linked lists (e.g. Floyd's algorithm variations) but the assignment doesn't even mention these and I certainly don't think implementing such cycle detection would be in the spirit of this exercise. I am also aware that my recursive would fail with SOE for large collections with languages without tail-recursion optimisations (i.e. Java) but rewriting the method to iterative approach doesn't seem difficult. Questions 

I've just finished implementing a doubly-linked structure with random pointer and I am trying to see can we do better and would also like to address some lingering questions that I have. Assignment 

A cycle should be found in worst-case O(n) time complexity and O(1) space consumption. The same applies for retrieving the cycle start node. Apart from correctness, I've strived for client simplicity, null-safety and clarity - would like to hear thoughts on how to improve this code and/or add more test cases. Here is the data structure: 

Yes this doesn't do all the type checks that you do above but why do you need them? Now let me be clear It is possible to expose an XSS vulnerability for your users here Specifically if you allow users to enter values which are posted back, persisted on the server, downloaded by other users, and then used with this function on their computers. Suppose you are doing binding to objects which users can customize. These can be arbitrarily nested so you use this pattern. You also have summary screens in which users can view other users' customizations. All an attacker has to do is create a property named and it will be eval'ed and run on the machines of other users of the system. That's the danger. If you're aware of it and make sure that condition never happens, feel free to use the with-eval. 

A few limitations that I've discovered since then. This will work. However, it is subject to all the Asp.Net (currently 4.5) limitations. 

Javascript Javascript naming convention are to use with no underscores. It's not a big deal but it's pretty standard. The only exception is to use for variables that are intended to be used with the keyword (which you don't have here). To a lesser extent than php, but with the javascript community where it is, its probably time to start considering choosing a javascript framework (like angular, backbone, knockout, or the like rather than using jquery directly. In my opinion you are over-specifying your selectors, no need to do when id is already specified as unique, no need to when holds no semantic nor structural meaning. Consider that all this stuff is indexed in the browser so by adding more selectors you might actually be slowing things down however slightly. You don't need to use to select, you can just say Your scope management looks pretty good, I'm happy to see you using - another syntax which achieves the same purpose and you might find flows better (or not) is . You've got inline styling and html. Why? Just put the element on your html page and show or hide it from javascript. Finally, just about everything you're doing in js is handled in a very elegant manner by the jquery.form plugin. Just use that. 

Since this is a public method I added some checks and downcast List to IEnumerable, which is a looser contract and all you really need here. By the way, .Net naming conventions are pascalCase for private and local variables CamelCase for public and protected. It's rare to use underscores. 

For the above reasons I would recommend against using this as a general utility function. However, if this is going to be a specific utility (for example you're trying to create a simple data-binding framework where you know you won't have to worry about the above) this might be the rare legitimate use of the controversial with statement. 

While this is the simplest and is certainly acceptable architecture it is always a good idea to also consider Composition over Inheritance So instead you might do something like 

I realize that a service and some sort of inter-process communication (whether windows inter-process communication, HTTP, or something else) is more standard and reliable but I have a frequently changing team and don't want to add another step that is necessary to run the app. This seems to work but I've only launched it in a dev scenario. Am I missing anything that would cause problems in production? That's a System.Threading.Timer by the way.