I think the main problem is that everything is . So client code can do anything anywhere at any time - a free-for-all of code calls. 

Make Cohesive Classes OO programming is an exercise in self-reliance, for the classes. A class should know how to do things that is should be doing itself. The client should only have to tell to do it. 

System.Data.SqlClient objects are composites. Instantiate the parts at the top and then compose them as needed 

*Show me your data structures, and I won't usually need your code; it'll be obvious." - Fred Brooks, The Mythical Man Month 

I see lack of experience. Poor to bad variable names, lack of code structure, magic numbers, non-idiomatic constructs ( instead of ). The code in general is confusing. I really wonder why there is so much digit/number manipulation involving an array. I think it is because the code tries to do everything all at once, but it ends up obscuring everything it does. I'm not saying the algorithm must be changed. Rather, things discussed below can go a long way toward mitigating difficult code. 

because as soon as you read records into memory the data is stale - some other query could have added or deleted a row w/ that key an instant after you looked. So to read from the DB then test for existence in memory then attempt a DB insert is problematic. SO... do the checking in the database. Just send the record without checking first but do something like this in the database: 

Obviously the clients will want all the s (OMG, I just used a name in a proper sentence. The power of Self Documentation!). Sticking with the OO way, we make a strongly typed collection. Think Single Responsibility, encapsulation, domain centric (my words) design. 

It's my understanding that .NET handles connection pooling automatically and I've never worried about it in my experience. My spidey sense tells me that with proper refactoring, all your exception handling will be right here. Follow-on Refactoring - getting business logic out of DataBaseHelper With the above in place, I can see the query string in , and similar methods you must have in pulled out. Now is free of all "business context". If the SqlCommand setup is very customized for each query, then perhaps becomes a whole new class; very possibly derived from an abstract class with standard/common setup. Oh, you can use the same object with different parameter settings; Remember that parameters is a collection on and so you can have have custom methods to set up s and pass that into a object used over and over, living in that abstract class I mentioned. 

I will address the "big picture" algorithm of this program, not the prime number bit. Ideally, have the upper most method(s) read like a summary. This structured programming approach may seem like overkill for such a small program but even the smallest programs benefit from good structure. 

[Above are not syntactically complete statements. Just getting the idea across.] Yes, declares a public property. But a well written class exposes behavior and hides state. 

Talk yourself through your "problem domain" and write it as you go. Say a little, write a little. The details will come along. Don't worry about them all at once. Make sure the little you write each time compiles. For example Well, there's a Person 

I want to emphasize that you should not dump raw XML into your constructors and parse that out - I mean for example a single team's XML into the constructor. Instead your "DAL/Factory" should parse it all and: 

MVC parts are intended to be coherent, complete, objects necessarily differentiated by clear separation of concerns. This is the intent of the MVC pattern. For the model this means that it could be driven by a graphical or a console interface. However the OP code does not have these qualities. The model objects must have both state and functionality. 

Proposed Experiment The code structure is lousy. There is testing for and all over the place, and even repeated in a nested loop. I have to read and study a lot to figure out how the query is being built differently based on these conditionals. Re-write the code to examine the conditionals up front and separate code for each path. This will result in some redundancy I guess but the point is to see how the code becomes clean and understandable. Personally I'd go for clarity over some minor duplication in this case. But you should be able to DRY that up. Broader scoped common variables or via method parameters. 

Create Custom Collections This hits lots of OO principles like encapsulation and Law of Demeter, but mostly the single responsibility principle. The custom collections will have the responsibility for things like: 

I would add some structure. As a general statement I'd say that good structure(s) helps reduce code. Make collections (list, array, whatever) for each of Smokers and Threads. I would also look into string formatting so you can loop through the Smoker collection and do your output. You do not want to hard code "Pat", "Mat", "Tom". The Smoker class has a Name property, use it! 

Ask not what you can do for your base class, Ask what your base class can do for you We just did that by inheriting . There are some cool overloads. And every class inherits , and we have some great power just waiting to be unleashed. Fetching a specific CharacterCount Let's say our clients want to be able to find a specific character count object. 

This looks like the exception is essentially doing flow control. This is a bad use of exceptions. Exceptions are for unexpected, usually unrecoverable errors. The way exception handling works is intended for exiting gracefully from such an error without having the application just blow up. Exceptions are also computationally expensive. 

Single Responsibility - Should calcualte it's own total. Client code should only ask for the total, not calculate it. Taxes calculation may or may not be in here. Depends on how the design and requirements evolve. Don't expose the cart items list to clients; at least I don't think you need too given the code so far. Consider override for a nicely formatted "reciept". 

The Rules list should not be public. Hide state and expose functionality. If you need to add rules for example, make an Add method. 

There's no point in an abstract class with nothing in it. I assume a product has name, description, price, a SKU (product id) at least. 

Yeah, I know that writing short, so called Data Transfer Objects (DTO) is a thing. But inappropriate here. If you want to ".. use dependency injection next step", start here. Use a constructor to inject the values. Thus YOU, not the client code, guarantee complete, valid, immuteable objects. Simple immuteability is its own virtue. The very worst of our code base is due in very large part to changing object properties willy-nilly. You really, really, really need to develop a defensive mindset, generally. Write code that can't be FUBARed. By hiding state and exposing appropriate functionality you force the coder to do the right thing. And at the same time communicate design, the domain, and behavior. Think "Application Public Interface." 

Is an array appropriate for your needs? I wonder about converting smack in the middle of processing. Your data should be in an usable structure from the start and the rest of the code should not have to worry about it. 

OK, You get the idea. Displaying Your basic idea of making strings of "label: value" is the right idea, but implemented wrong. And once implemented - use it!! All objects have a method. Override it. Then all you have to "say" to use it is BAM! object oriented programming. Also, DO NOT use println in your toString(). toString() should build all the object information into a single formatted string and pass that. Then you use it as shown. 

// STOP. Don't spew out price calc code here. We need to deal with "we have 3-fer Coupon and we bought 5 of them". But that too will be encapsulated... somewhere; in Openy-Closey think we might consider extending . // I can imagine it's use thus: 

The mass of arrays is essentially capturing the information, or context if you will, that will instead be defined as appropriate properties in the appropriate classes. 

Code file organization Putting the code under a "testing" namespace is misleading, the seed for bad solution organization, and just lazy. The convention I've learned is that test code is not only in separate files but also in its own project(s), generally with file and project naming that "pairs" it with the particular target code. As your applications grow and you implement continuous integration you'll be glad you took the time. 

Data Structure Simplifies Everything By data structure I mean a class design making the hangman data accessible. You almost got this with the class. But we need instances. The big insight to all of this is that there are not "easy difficulty", "medium difficulty", etc. There is just a "difficulty". Likewise with categories. And the s say as much. 

end EDIT 2 EDIT 3 @PeterKiss answer makes us realize that we should add "character category", our clients would like to know that. Add the category property 

Single Responsibility - Custom collections For me has become a no-brainer for good SRP application and enhanced functionality. The .NET framework collections take advantage of "equals", "IComparable", and "IEquateable" (more?). All of a sudden "Find", "Sort", "Contains" collection methods work like magic (from the client code perspective). 

Memory Leaks As gets used it will have empty and occupied elements scattered throughout the . You will end up writing code to scan the array for every . Otherwise you'll be adding new elements when there are empty elements available. It looks like we leave objects in unused array elements. This is the case at instantiation, clearly. Also removing things involves but not ing the reference there. I guarantee you'll be spending lots of extra code and lots of debugging time trying to keep the in synch with the actual active objects. We don't know what an empty element is The is being incremented/decremented but we're leaving objects in place. I'm assuming that at some point we're done with a given object, in which case it should be disposed of. Besides the memory issue, how do we know what elements are in use and which ones we can over-write? 

The Big Picture We made a data structure for the more abstract ideas of "difficulty" and "category" (vice "easy capitals" for example). This very dramatically reduced code volume and simplified client code. 

Request triggered only in the constructor Both answers require that every request must be a new object creation. If that is intentional make sure it's documented. Otherwise I'd say it is a single responsibility violation in the constructor method. 

The game driving the tournament The Tournament driving the pairing of combatants The Combatants doing the fighting. Better separation of concerns We coded at appropriate levels of abstraction w/in each class. A.K.A. we pushed details down. [edit] One more thing.... the may now seen superfluous, but it got me to thinking that can now be passed as a parameter and now we can have game variations. Holy Inversion of Control, Batman. 

You're right that having MainApp having to know/control the sql connection is bad design. We're going to get rid of the and calls by being "connection oriented" instead of "sql command oriented". Keep reading for clarification... Then should set up the as it does now, but not execute the query. Instead pass that into some other method and ... use "using" to get rid of Open / Close code 

Be precise: don't say "blank string" when you mean (a.k.a. "empty string"). This: not: Eliminates uncertainty due to eyesight, font style and size, accidental spacebar, etc. Strings are reference types and may be null. Always use - preferred over . Either one definitely preferred over Test string parameters for null. Calling a method on a null string reference throws an exception of course. And to simplify downstream code I like to set null strings to 

Admin class When you go to McDonalds, do you ask for a hamburger or do you go to the kitchen and cook it yourself? should ask for the floors, it should not do it. Many methods in this class make this mistake. override toString is meaningless as a name, first. Second it's returning a formatted string which is better put into . Printing a ticket will essentially be a chain of calls. You do not need - override . Miscellaneous , not . , not . try block makes no sense. Java is compiled, if a class file was missing the compiler will tell you. - add as a parameter. Not all cars are created equal. There is no point having because all you do is pass it to . As an integral part of creating a vehicle this should be where you create vehicles. 

This encapsulates everything that new object can do, now and in the future. I'm assuming it will need and/or 

Single Responsibility - An items collection This is a really excellent exercise for understanding SRP. Make a class. Put the enumerator in here. Have simple properties like "total price", "total quantity" and any others appropriate for lists of things. Override for a nice listing. Refactor to use that. And generally fine tune the item list and shopping cart classes for SRP-ness. will still have a total method; which will call the collection total method. This is one example of how a shopping cart client will talk to the shopping cart and be ignorant of shopping cart implementation. It is also an example of "Maximize cohesion and minimize coupling" (I love that phrase!). As for general implementation I prefer to "have a" generic List (or other appripriate NET-supplied collection class) instead of inheriting from List or implementing ICollection, etc. Why? Because it hides all the .NET-supplied pubilc properties and methods and I expose precisely and only the functionality I want. It goes to design intent, SRP, defensive coding, user requirements, domain specific language, etc. 

A calendar, dropDown, and textBox. - parts of a single class From the given information both start and stop have these. And the only difference is the labels. So you can have one class, instantiating 2 objects, one for "stopping" and one for "starting". 

@t3chb0t answer, all good. I suggest yet a 4th class - . Why? First it supports the idea of a DSL - Domain Specific Language. Meaning, write code in terms of your problem domain. You want to express "People" not "List". Second we take advantage of .net collection functionality but expose that functionality in people (DSL) terms. Third we can limit client access to the so we allow only those things we want for People. And finally it is a good application of the single responsibility principle. To limit client access I show wrapping a rather than inheriting from it or another .net class. Note that MS recommends inheriting from : 

communicates overall function much better. is understood in 1/10th the time as the original. Each method, including , is focused on one thing. 

Now the view or controller only has to tell, don't ask the dice to roll. ("tell, don't ask" is confusing! I say "tell, don't do") 

I'm going to borrow @CodingYoshi's idea of an class. However transform the OP's parameters so as to make a consistant class so every can be instantiated, and subsequently called, the same. We have all needed parameters already at the point the is called, so let's use them. This helps future-proofing too. 

I expect lots of code will simplify and be less error prone. I love enum type safety and visual studio intellisense. Further, "undefined" is great for default values. It forces explicit setting in code - If it defaults to "A", for example, how can you tell that's wrong? Define CabinClass and Deck relationship