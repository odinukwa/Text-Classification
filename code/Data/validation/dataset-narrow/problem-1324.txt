Wouldn't it be simpler to just use some integer state logic to drive the match comparisons? For example you could just keep track of each Tile's state and colour and do numerical comparisons instead of interrogating the actual texture of each gameObject? This has the added value of using a single Texture Atlas to store your tile textures and then just map to that Atlas as per the norm if a tile needs to change via a user mouse click. A quick comparison example for you to Ctrl-F5 (if you run it a few times you'll get a match) : 

I know some people frown on link dumping, however I found this to be a very enlightening paper, and it obviously conveys way more than I could elaborate on : $URL$ 

When I implemented something similar I used a messaging system exclusively to handle the necessary communication between different entities in various systems. That way the messenger can perform the relevant required component checks while marshalling the your messages between the entities. You can think of the Events as mini SubSystems if you like. It also cleans up your systems quite a bit as well as providing a great deal of de-coupled logic, and hence less dependency chains overall etc. (contrived and untested psuedo-code disclaimer) example : 

According to the way the documentation lays out the single alpha channel for both specular and transparency you are correct in your assumption. If you want full control over the textures my solution would be to separate your tire and rim-hubcap models so you can texture each individually. This would allow you to create a Transparent Bumped Specular on the rims for the cutout and shine control but also allow you to use a Bumped Specular on the tire wheel so you can get a more rubbery look without the transparency. 

Your assumption isn't necessarily to find the cells but the lines it cross on this grid. For example taking your image we can highlight not the cells, but lines of the grid it crosses: 

There is nothing stopping you from using 2D sprites in a 3D world. Unity has support for 2D, 2.5D and 3D in all combinations of the set together. "I want 3D models in a 2D game." - Fix the camera to a pan only system and use 3D models. "I want 2D models in a 3D game." - Fix the camera to follow a 2D sprite but use the 3D character controller. Try it. If it doesn't work or you have issues along the way, come back and we can help! 

You've already got most of the setup. What you could do is just control the Campfire from the other collider inside the Collision method [untested code] : 

Once thats set up you can then interrogate a tile in your move path to see if its walkable based on the terrain type, or if it's blocked by an child obstacle etc. 

When importing the animation there is a 'mirror animation' checkbox under the Animations Tab in the Inspector for that asset. If you check that box and rename the animation to "myanimation_mirror" or whatever then you should have 2 mirrored animations. 

I found it a little bit difficult to follow the entire thread of your question. However at the most basic level, in a simple FSM you could either just query the current state of your StateMachine (i.e. assuming its a singleton manager class etc : StateMachine.Instance.GetState ) and then do the necessary long-winded if or switch statement logic depending on which state is returned. Alternatively, for something a bit more loosely coupled and dynamic you could just have each relevant Class subscribe to a OnStateChanged event equivalent and react to specific states with callbacks. There isn't a right way to implement a FSM, however you can take a steer from one of the many online resources eg: $URL$ $URL$ ------ EDIT UPDATE ------ The idea is that if you're going to roll your own GameStateManager in the Unity engine, then each state would essentially have it's own methods such as Update etc. These methods would execute sequentially as per the norm. You could manage your state transitions with a State stack container. This way multiple states could be queued up and pushed into the stack, and then executed in order i.e. GameState-->MenuState-->ControlsMenuSubState etc. At the end of each frame you could then do some bookkeeping and check if it's OK to roll onto the next state i.e. pop the current state and then execute the next state object on the GameState stack. It does sound like you're overcomplicating things by coupling each class to each State of the game. The classes generally shouldn't know or care which state they're in as it's the State's job to call into other classes, not the other way around. Unity's normal Scene methodology is also suitable. You could just use Scenes to transition between major games states, and then use the Unity GUI for Overlay states such as Inventory or Menu states which need to run in the current state. All you would need is at least 1 object to maintain your meta game state between scene transitions. 

You really should tell us how this is being constructed as different technologies can have different advantages to your situation. Is it in Flash? PHP? HTML5? JavaSript? Java? The "web" tag doesn't give us much to go off. That being said: One of the most secure ways to transmit points score is to not let the client side decide what those points are. What you want is to create points based events: 

Please excuse the roughness but I hope this gives you a decent idea for structure. Formatting your XML a little better you can then create a parser to create the scenes and the requirements in them, here is an example of both the scenes above in one: 

To approach the clusters of unbroken shapes you can simply iterate through each tile and check if it is connected to any of the previously iterated tiles: 

Firstly, you need to use a switch case statement and decide which direction overrides the others, for example, if they press all four buttons, which button should be listened to for input? This gets put in order within the switch statements. Edit: For clarity about the above statement. You do need to use a switch case statement (or similar structural logic) to stop the following from happening. 

This is brilliant! Our controller square input allows us to do this and more importantly should Bobs hat magically only have one thruster that can go a maximum of 100 units a second well that's okay. We can then give him a direction using inverse tan: 

Using a 2D tile array for your world/level generation and representation will definitely simplify things. For example you could internally represent your world in a grid of tiles and take it from there : 

$URL$ If you're using Aron Granberg's pathfinder, then are you perhaps using one of the smoothing modifiers? This would result in the unit trying to optimize the path which would probably prevent the unit from hitting each node as it steps through the path. Or is the problem that you have a consistent offset when the unit paths from node to node? 

A quick test, just grab the logo image from the SFML site and paste it into the working directory of your project (or just somewhere simple and explicitly state that in code i.e. "C:\test\img.png") 

From my experience recently in doing a few 3D animations, I found it very simple to just split up the animation into 3 separate clips. That way I felt that it was quite intuitive and easy when creating transitions between each animation clip in each stage of the overall animation. You also have a great deal more control over the animation transitions using this method. If you split the animation up then just ensure that when you import the animations that you check the Loop animation check box in the Animations tab for the middle climbing animation clip and you should be good to go. You can then also use State Machine Behaviours to drive any additional actions like playing sounds or effects etc during each clip. I'm sure you could also perform some complex looping logic as you allude to, however that seems unnecessarily complicated and error prone in my opinion.