Because after first call to Move function, posy is decreased by 8.0 => posy = -8. When you draw your rectangle, you put some coordinates, which also become negative and ywhole polygon is out of window. BTW: And I totally don't understand your Move function: 

Maybe I just don't understand your question, but if you want to draw text, you can use function glutBitmapCharacter. 

Blue vector can be calculated easily: red - black (the sign between vectors is minus). But if you want just to interpolate between black and red vector, you don't have to calculate it. Linear interpolation is just linear combination. So you can just take: alpha * black + (1 - alpha) * red, where alpha has to be from interval <0,1>. If alpha will be 1, then you will get black vector, when alpha is 0, you will get red vector. And if I understood it right, you will interpolate between these vectors in time. So just choose right increment of alpha in time. Did I understand you right? Or did you meant something completelly diffent? 

The easiest way I see is to store velocity, when user clicks on screen. This velocity will define, which direction sprite should move and by what speed (so for example direction * spriteSpeed). Direction can be obtained by simple vector math: And then you will update sprites position each frame. So just add to while loop: . ElapsedTimeSinceLastFrame is just for sure - if you don't use time and run this application on faster machine (while loop will be executed faster), your sprite will move of course faster. And finally - you should control, if sprite is at the end of its journey. So control, if is not more than . If it is, move sprite to target position and set velocity to zero (or set some flag not to update sprite position till next mouse click). 

I'm going to start off by being That Guy and noting that this site is the wrong place for this question. It's a potentially non-trivial legal issue whose precise answer, under various circumstances, will likely depend on details of local law and legal precedent, as well as on the relative abilities of the lawyers on each side to twist said law and precedents to their advantage and the attitude and preconceptions of whoever happens to be chosen to adjudicate the case. In short, if you want a real answer, ask a lawyer. That said, out of the cases mentioned in your question before it was shortened, the M = P case is the easy one if that fact can be proven. Note that, again depending on jurisdiction, even just reasonable cause for suspicion might be enough to obtain a subpoena or a search warrant to acquire confirming evidence, e.g. from ISP logs (as noted in another answer) or even directly from P's computers, which might contain revealing traces of their activities as M. The case where M's identity is known (and M ≠ P) is also usually simple for P, since any plaintiff's attention will probably be mostly focused on M, and since P typically has a fairly good defense against any accusations by pointing to M and saying "he did it, I had nothing to do with it!" That said, as I'll note below, that defense isn't necessarily ironclad, if the plaintiff does decide that they want to go after P as well (e.g. because M is out of their reach, or too poor to pay for any damages even if found guilty, or just because they can). Now, on to the meat of the answer: If P does get sued, either alongside M or because M could not be identified, it will likely be for contributory infringement. Basically, the claim would be that P knowingly aided and encouraged M's infringement, and materially benefited from it, by making the game moddable in the first place and continuing to sell it after becoming aware of M's mod's popularity. It should be noted that, under most circumstances, that would be a rather tenuous claim. Making games moddable is standard industry practice, and, indeed, it shouldn't be hard to find expert witnesses to testify that making a game unmoddable is often difficult or impossible. As long as P's original product was a playable and salable game in itself (and did not, for instance, feature blank sprites and textures with "PLACEHOLDER" written on them) it would typically also be hard to argue deliberate intent to encourage infringement. As for profiting from the sales driven by M's mod, that might depend on just how popular the mod actually became, but in most jurisdictions there should be either case or statute law — such as, notably, the "Betamax case" (Sony v. Universal) in the U.S. — exempting makers of products used by individuals to infringe copyright from contributory liability, as long as the product also has "substantial non-infringing uses" (to quote the Betamax decision). Indeed, if such an exemption did not exist, what would prevent the plaintiffs from just going directly after, say, Intel and Microsoft for making computers that could run the game that could host the infringing mod? Of course, the situation could be different if it really could be demonstrated that an overwhelming fraction of all sales of P's game were driven by M's mod, and that P should have been aware of this. At least, someone could then argue that P should have patched the game (or at least any subsequently sold copies of it) to not run M's infringing mod (and to communicate this to prospective buyers). Of course, such efforts would likely be ultimately futile (as M could just patch the mod to compensate), but it could be argued that, if P hadn't even made any such effort after explicitly being made aware of M's mod and its popularity (and illegality), that could constitute evidence of willful encouragement. For an example of similar arguments, see e.g. the recent Megaupload case (which, of course, has not actually proceeded to trial, but at least illustrates the kind of arguments that could be made). 

If you know starting block (you know point X and you dind't include block [0,1] in block list, so I suppose you know also the starting block), I think you should surely use Bresenham's algorithm. You wrote, you looked at it. It's suitable algorithm for this problem. It can be also written in a way, it computes only with integers. You can find a lot of implementations out there on the web. EDIT: I'm sorry, I haven't realized that Bresenham won't find all blocks. So I found better solution. There is also code written in C++, but I think it shouldn't be hard to understand :) 

Determinant is: xA*yB + xB*yC + xC*yA - yB*xC - yC*xA - yA*xB. Then you can compare it with zero. If it's > 0, return points A, B, C, if it isn't, return A, C, B. If you have set of points and know, they make convex polygon (all are part of convex hull), and want to get their order, you can use Graham Scan or Jarvis's March (these are algorithms to find convex hull from many points, but it should also work here :) ) 

A long time ago, when I was programming similar water simulation, I used this as a source. It's written in C++/OpenGL. You can find there PDF with description and also source codes. You can see, there are faked waves - if you don't want them there, you just don't have to use "noise" textures. 

You can find a lot of information here: OpenGL registry. There is a lot of extensions. Each section (ARB, EXT, ...) are ordered according to adding date. New extensions are written against newer versions of OpenGL. For example - if I look at ARB section, almost every extension under ARB_timer_query (including) is written against OpenGL 3.2 or newer. You also mentioned buffers, so you can try extension GL_NV_vertex_buffer_unified_memory. Some info can be found here (there is also link to presentation). Also shader_buffer_load should be usefull, if you are using shaders, but I haven't read the specification yet. 

(Ps. I used instead of just to make sure that and end up in the valid range even in the unlikely case that the background movement speed exceeds one tile width/height per frame. It probably won't make any practical difference, but it's generally better to play it safe anyway. Of course, if you really were expecting such high movement speeds, you should rewrite this to use the operator instead.) 

Assuming realistic Newtonian gravity (i.e. that the gravitational force between two bodies is inversely proportional to the square of their distance), and that the planets don't interact gravitationally with each other, but only with the sun, then the planets will always follow Kepler orbits (which, if closed, will always be elliptical). Conversely, if the planets do affect each other via gravity, then you're dealing with the full n-body problem, which can have all sorts of crazy solutions like figure of 8 orbits or even planets accelerating to infinite velocities. Admittedly, those particular examples are mainly mathematical curiosities that you're unlikely to see in your game, but still, you should not expect there to be a single, unambiguous definition of an orbit for general n-body dynamics. The best you can do is probably to just pick some arbitrary, pragmatic definition and stick to it. For example, in two dimensions, you could simply declare that a planet has completed a full orbit when its angle, as seen from the sun, equals the angle of its starting position (after actually looping around the sun). You could simply track this angle for each planet, adjusting it incrementally as the planet moves, and declaring a complete orbit when it hits &pm;360°; this way, you won't end up with false positives for planets that e.g. loop around each other and reverse direction without actually going around the sun. If the above seems too easy, you could also require that the planet must return to approximately the same position and velocity as it had before. (Again, you'll probably want to also track the sun angle, to make sure that the planet has actually gone around the sun and not just, say, around another planet.) This probably requires you to track the trajectory of each planet (which, of course, you may want to do anyway for visualization purposes) and to come up with some fairly efficient scheme for finding near matches (e.g. using spatial binning). 

I think that the easiest solution is to load all images you need (and store it for example in an array) - I except you have animation stored as a lot of images. All time (while it's not colliding) you are drawing first image. When it collides, you just start to use other sprites (you can draw for example one new sprite each frame). When you reach end of array, explosion (animation) is finished and you will stop drawing this rock. 

First optimization - If your buildings are the same color (as on the picture), can't you use just colors instead of textures? Second optimization - if you are looking from far away, you can render less layers. Third optimization - render your buildings from up to bottom. Not one building from up to bottom and then other one, but take highest layer from all building and render this one, then second layer etc. Fourth: If you are rendering big building (with a lot of layers, so many vertices), wouldn't it be better to render just one cube (8 vertices) instead? //EDIT: Calsbeek was quicker. 

Few years ago I have been solving the same problem - I wanted to use Half Float extension in OpenGL, so I needed to convert Float32 to Float16. I have found somewhere this code, so I hope it will help you too: 

First of all: You misunderstood glDrawElements. This function takes as its last parameter indices to array of vertices/normals/texture_coordinates (not array with vertices / normals.....) - this can be used for indexed geometry. Second of all: You misunderstood glNormalPointer / glVertexPointer / glTexCoordPointer. Its 3rd parameter is stride, which means stride in the whole array of vertices / normals / tex_coordinates. So its always 8*sizeof(float). And also its lasta parameter is pointer to first elements (vertex coordinate, texture coordinate, normal coordinate). So it should be for normals really indices, for textures &(indices[3]) (I think also indices + 3 should work) and for vertices &(indices[5]). And for your first problem - you should use glDrawArrays, if you don't want to use indexed geometry. And you should use it in this way: glDrawArrays(GL_TRIANGLES, 0, totalVertices/8) - here "totalVertices/8" is your real count of vertices - each vertex has 8 parts - 3 normal coordinates + 2 texture coordinates + 3 vertex coordinates. But I really don't understand how your Unhandled exception... can occur, when you use the same mechanism in first case and there it's working properly. BTW: And this is not VBO. These are called vertex arrays - geometry data is transfered from CPU side to GPU side each time you call glDrawArrays. If you want to use VBOs (geometry is stored in GPU memory), you can try this tutorial. But what I have understood, you are doing some animation or interpolation (?) - you are using frame1 and frame2 and frac variable. So you can use vertex arrays of VBOs with some "streamed" flag - this means the data will be changed every frame (specified once and used once). – 

Note that this will mess up the acceleration vector (by multiplying it with 0.5 * timestep²), so you shouldn't use it for anything after this. 

I second ollipekka's suggestion: what you want to do is subtract a suitable bias function from your heightmap, so that the edges are guaranteed to be underwater. There are plenty of suitable bias functions, but one fairly simple one is: 

Here's a quick example based on this image from Wikimedia Commons (by Phasmatinox / Allefant, used under the CC-By-SA 3.0 license):         

A* will work, but for a Tower Defense game that has lots of enemies with the same goal and a relatively static geometry, it may actually be cheaper to just run Dijkstra's algorithm backwards from the goal, to find the shortest path tree from anywhere on the map to the goal, and cache the result until the geometry changes (i.e. a tower is built or destroyed). Basically, this means that, for each grid point on the map, you store the direction that leads most directly to the goal from that point. Then you just have each enemy move in the direction given by the nearest (If there are n groups of enemies with different goals, or different terrain crossing abilities, you need to store up to n directions per node. Obviously, flying enemies don't normally need directions.) Conveniently, if you save the distance from each point to the goal too, you can do incremental updates to the map when obstacles are added or removed: when an obstacle is added, you only need to update points in the branch of the tree cut off by the obstacle, whereas when an obstacle is removed, you only need to update any points from which the goal can now be reached more directly than before. 

If you want to move on lines (not curves), your implementation is almost good enough. I would edit your code this way: 

IMHO: If you are programming some real-time application, you should avoid recursion if it's possible. Recursion has to push and pull curent context and it's slowing down your app. It's also more memory complex. Of course if you have just few objects, it's not so dramatic. But when you will add more and more objects in future, it will be slower and slower. You can read something about it in this article on wikipedia. 

You can easily generate numbers from range <0,1> with uniform distribution and then project them to range <0,2X> with function like in the graph: $URL$ It's up to you to choose function (it can be for example some trigonometric function or some more sofisticated function which generates normal distribution - like Gaussian function). If you have generator with normal distribution, just just multiply generated number with 2X. 

I think you should change your for loop to something like this (you should take current pixel and few pixels around it, not only one way from current pixel): 

I unfortunatelly now don't have time to read about that SAP algorithm, but what I have read few months ago (but I don't know, if it's suitable for your problem, it's much more suitable for points - not objects): You can use some special case of kd-Tree - for example octree - which uses half partitioning in each axis (in article I have read, they were using quarter partitioning - each axis is split to 4 peaces). You use dynamic version of it. First you build your structure at the beginning. This means, you split space into kd-Tree. Leaf of tree should have some limited number of objects (for our example let's take 64). Each node knows of course how many objects is in it. When you update positions of objects, you transfer them also in structures nodes. After that, you update whole structure according to these rules: 1) When inner node has less then limited number of points (sum of its leafs is less then 64), then you merge leafs and inner node becomes leaf. 2) When some leaf has more then 64 objects, you split this node. If you want, I can try to find that article - when I will have some time. 

For non-interactive battles taken to the extreme, I can't help but mention the original 1970s RobotWar and its numerous successors such as Robocode. They're not RPGs, and you probably don't want to go quite that far if you want your game to appeal to a broader audience than just hard-core programmers, but at least they show what's possible. 

In general, the thing to realize about security is that it's a mindset. It's not about knowing the latest security buzzwords, or about how the latest attacks work or about trying to anticipate what hackers will do before they do it (although all of those things may be of some use). Actual secure programming is about learning how to use the tools you have the way they were meant to be used, about dividing your code into pieces small enough that you can understand what each of them does (and making sure they do it right, even if other parts are compromised), and about writing your code to expect the unexpected. If you do all that, you won't need to know what hackers might try, because you'll be prepared for anything. 

To minimize the additional latency when communicating over TCP, it may be useful to disable Nagle's algorithm using the flag. Instead, you may want to implement your own transmission buffering, collecting several small messages into one packet whenever possible (which is a good idea with UDP too). Edit: Rewrote the second paragraph per comments below. 

Here, denotes the set containing the elements , and (with being the empty set), and denotes the size of the set . In the recursive function, the set contains the shapes available for the remaining solution, contains the shapes in the current solution candidate, and is the maximal solution so far (which you may want to store as a global variable instead of returning it back up the call chain). The important optimization is on the line marked with , which prunes branches of the search tree that cannot possibly return a better solution than . (Actually, since we know that each T-shape contains exactly four sites, a much better upper bound could be obtained by replacing with the number of distinct sites covered by the shapes in , divided by four and rounded down (and similarly for on the line marked with ). The algorithm as given above, however, works for arbitrary collections of shapes.) A possible additional optimization, which I haven't implemented above, would be to check at the beginning of the recursive function whether divides into multiple subsets that are independent, in the sense that no shapes in different subsets overlap, and if so, apply the algorithm to each of the subsets separately. (In any case, you'll definitely want to do this at least once at the top level before calling the recursive algorithm.) Sorting the shapes in appropriately before looping over them, e.g. in increasing order by number of overlapping shapes, could also help.