The only part missing from that match is the end, the last . I would use another regex match to grab that portion: 

"want" / "did" "want again" / "did" (active) "want" (active) / "done" "want again" / "done" (active) "want again" (active) / "done again" "want again" / "done again" (active) 

Acknowledging the state machine, look at the "want"/"want again" button. The text will always say "I want to do it again" after the done button has clicked. Essentially we can boil it down to this: 

It's not so horrible. You managed to cache your jQuery selectors, which is more than a lot of people can say. Good job there. 

If we consider these two buttons a state machine, we see that there are six simple states (not including hover). 

I have a couple of issues with the main function. First, may work for windows but won't elsewhere. You should dump it. Second, Too many returns at the end. Third, The hardcoded input makes it kinda hard to test (and doesn't look good). Just read the first parameter from the command line or read in from standard in. Here is an easy way to do so: 

Honestly, your loop doesn't seem that complex. I would probably ignore this warning in your case, at least until it grew in complexity or the surrounding function grew in size. In any case, here are some things you could change: a. Add a variable to replace the five instances of . b. Off the top of my head, I'm pretty sure an EC2 instance is only going to have one "Name" tag. You can extract this loop into a separate function if you feel comfortable with this assumption. c. If your lint rules / personal style allows for multiple returns, you can reduce the depth by returning from the error. 

To sum up, the difference in complexity is because you seek different interfaces. Both interfaces are valid and work. Which one is more natural depends on the application. Edit: Here is a code sample of your version. Note that I just use auto return type deduction (as you suggested yourself in the code comment). 

rlc has covered all the important parts in his answer. I merely want to mention since you specifically asked for performance improvements. Memory-mapping files can give you great speed boosts. Note that unlike , the file must exist before being opened. Also, the memory-mapped file is opened in binary mode so you must alter you code accordingly. Memory-mapped files are much more low-level than your current approach. Only pursue this option if you have profiled your current code and found it to be I/O bound. 

Note the proposed alternative implementation using a reversion adaptor. That would be a nice C++ exercise. I wonder how that would compare complexity-wise. The linked article's implementation supports arguments such as . Yours don't. Of course, this adds extra complexity to their implementation compared to yours. There's not much more to say on this point. 

Like Kumar have already mentioned, just keep it simple and use . It is a very efficient data structure since every element is stored next to each other in contiguous memory. This gives you great cache utilization for sequential access (which is what you do in the loop). As for the ordering, right now you are doing 

Note that I've changed your to an InputIterator since I think this is a better choice. Any indirection should instead be handled with iterator transformation. I.e., an adapter which wraps the raw and overrides to either return the key or the value. Boost has the which does exactly that. Even more concretely, there is also the which is very similar to your class. Again, the motivation is to divide up the responsibility into separate classes so that each such class is as simple as possible. Complex tasks are then accomplished by combining these separate classes. 

Finally, you have several magic numbers. To make code maitenance easier, define variables for constants like colors, strings, and timeouts. 

Next, you can extract that click handler into it's own function, allowing the index to be passed in as a parameter. 

I have little experience with python, so I can't offer critique on the finer points of your code, just the big picture. That said, several things stick out to me. First, you have some large chunks which are duplicated two, three, or even four times (see lines 198-215). Scour through the code and extract these into their own functions. Second, several of your functions are massively too long: (161 lines), (97 lines), (228 lines). , once you get rid of the previously mentioned duplication, could easily be broken into two functions: the finding and the scoring. is too long simply because it contains all of the input handling. The section within the block starting at line 435 absolutely should be its own function, if not more since it clocks in at 144 lines. Finally, and this is more observation than critique, your classes do nothing but operate as organized data structures. This isn't necessarily a wrong approach, but it would look good if you were to refactor your code to be a bit more object oriented, especially since this is intended as a code sample. 

You are caching , but really, it's not complex enough to warrant caching. I did some quick and dirty testing and found that you save about 10ms per 1,000 executions. That is not worth anything here. So, to reduce code size and bug potential, I suggest removing all caching. 

Einstein was awesome Considering the solution to any problem, Einstein said: As easy as possible, but not easier. And to be honest, that's what your solution lacks the most. Here a general (and of course debatable) idea of how it could be implemented much easier: 

I think it's too much to ask, to point everything out or give more or less exact statements about what you may need to refactor to what and why, since with some reading about the presentation patterns, you should come up with your own pattern decisions which you then will implement. I think that needs a few iterations ;-) (Check Passive View, MVP, MVVM/Presentation Model, that's the most common used, imo, or check for open source projects). Comments 99% percent of your comments are obsolete. First, they explain what the code is doing - don't comment what you are doing. They will lie one day, for instances the comment. One day it will be 30, or dynamic, or whatever. If you comment, comment why you are doing something. But in general, even that is often not necessary. In enterprise applications, it's usual because of "business illogic" / absurd requirements. Naming Try to be as clear as possible when it comes to naming. For instance, in , you declare g, d and dt, I see from the constructor, what those are. But when I have for instance a bug to fix and I know it's in , I read the following line: . I have only a clue about what dt, g and d would be. If you'd name it better, it could read which is much more clear. Also be consistent. In the name of the parameter is , which will be assigned to . So you have three different names for the same thing which makes it much harder to read. double precision I recommend to use instead of doubles, because of the preciscion problem, I think that could be a problem in the future. See wiki's "Floating Point" page, why I mention that. direction / position You might want to wrap direction and position into vectors. The main benefit would be, that you have a lot less parameters to pass and set, and it's usually quite clear, what a Vector is. Also not really sure if the calculation of the positions should be within the Projectile, since those are very common calculations - you might want to calculate those in a separate "MyMaths" type, or even in a Vector itself, maybe. The "maybe 3d in the future" problem should then be easier to implement (I have to admit, I suck at maths, so not quite sure if that would really help) Other 

Once we have all of that, we can rip out the entirety of the click functions, replacing them a simple function (containing the previous code blocks). Since we are now concerned about clicking the done button first, a little code is needed to set that variable. One final note: the object was not needed, so I removed it and renamed the / variables. Working Fiddle: $URL$ 

Moving on to the "did"/"done"/"done again" button is a little trickier. "I already did it" will be visible so long as the want count is 0, and "Done it again!" will be visible after the want count is 2 or greater, but "Done it!" is more complex since it only shows up on one of the state machine paths (step 3/4). It turns out it is visible when the want count is 1 and we did not click the done button first and the done count is 0 or 1. This all leads to this block of code: 

Furthermore, It segfaults on me when I give it lines longer than 119 characters. (But this is probably system dependent). 

Finally, and this is more of a personal preference, but I find that code is easier to read and follow when reading functions and not event handlers. By that I mean this: instead of calling , why not move that code to a function and call ? Here is the final result: 

Regular expressions are tough to read (human wise). As such, if you have a gnarly reg-ex in your code (), you should comment what it does. Furthermore, using regular expressions to check the total length of the string is inefficient and not necessary here, since you already have to check the length to report an accurate error message. As such, consider validating the username and password like this: 

My point of view (which certainly overlaps with timothy's explanations): Abstraction I really dislike abstraction, I'd treat it - as it is said in german - "step-motherly". You have an abstract type , an abstract type which extends and overwrites and , a class which extends and provides additional methods. And several other types which override and extend behaviour. And this is, to put it mildly, a bit of a mess. Beside the mess, you can't test logic in your abstract type without an actual implementation, nor can you test your implementation without abstraction, except you're very strict about decoupling abstraction and implementation. And the could also violate Liskov's substitution principle, more about this later: Coupling of Question and GUI Your Question types have a direct dependency to swing classes. If you would want to change the gui, or use another technology, maybe an app, or a web page, you have to change the business logic. The GUI is usually the top part of a multi tier architecture, and calls the layer below it, and the layer below must not know about the GUI. Liksov's substitution principle Now, this is especially important, if you implement the 'coupling' part above. The principle is the following: You have a routine A. A performs something with the 'supertype' S. You have a class X and Y, which are a sub type of S. If you have to change the routine A, when you introduce a new sub type of S, then you violate Liskov's substitution principle. In your example it's for instance the type . A type, which is programmed to work with your type , won't work with , because you need for instance to work correctly. So what you then have to do is for example to the type and cast it. There's ways to work around it in a "oo way", but I think that's very important when one is working with subtyping. Smaller things 

The path is one of these two options. In the first path, done is clicked first. In the other, want is clicked first. 

If looks like you may have a bug with . If the form input is a checkbox and is unchecked it will return even if it passes the validator function. Since this will cause the function to fail, lets return as an invalid state. 

is always one less than size, so you don't need that variable. Just replace all instances with . Similarly, could be replaced with . 

Everything looks good. That said, wasn't supported in Internet Explorer until version 9. If you need that support, the Mozilla Developer Network has a handy function you can include in your code to provide support for those browsers: 

But having a list is just fine. Not knowing anything else about your requirements, I would leave it the way it is. The thing that really sticks out to me in your code is the use of a callback as a parameter in . Since this function is not asyncronous, I would ditch the callback and either log the error directly to the console or just throw the error and let it break the build. If you really want to provide a mechanism for reporting configuration errors to the user, then rename "callback" to something akin to "errorHandler". The use of the name "callback" usually signifies a function that will be executed once and only once, will be executed when the function has completed, and will not return a completed value but instead pass the value as an argument to the function. Also, I find it surprising that you do not log the time to the output of the file or console logger. Not a big deal of cource, it just stuck out. 

which is in reverse order since what you want is {Filter1, Filter2, Filter3}. You have to reverse the calls to get the correct behaviour. Also, you are overriding in every iteration 

Besides that, the code looks fine to me. Good job! Please also consider the alternative I wrote in the first part of this post. 

The definition of function composition. A call to your is semantically equivalent to . Calling the linked article's is semantically equivalent to . Which definition is more natural is completely up to the reader. Both are perfectly valid. Your has the nice property that it is very easy to implement with variadic templates (since the recursion uses "pop front" logic). This is actually mentioned as an alternative in the linked article. Furthermore, they argue for their definition of function composition because it follows the reading direction. E.g., is semantically equivalent to which follows the expected behaviour of first receiving data, then decoding it, and finally storing it. To get the same semantics with your definition, we would have to write . Again, this does the same thing but is arguably harder to decipher during a cursory read-through. Alas, the linked article goes through a world of trouble to get that "pop back" recursion logic to work (using Boost.Fusion). So they do as they do not because they are oblivious of variadic templates but because variadic recursion simply doesn't cut it. Here's a quote from the article: 

A very interesting question. I can identify two main differences between your implementation (using variadic templates) and the linked article's implementation (using Boost.Fusion): 

instead? I don't have the signature of an so it is hard to know. Beside those semantic issues, the code has good overall structure. Good job! I only have comments on the details. I'm going to assume that you use C++03 in the following: