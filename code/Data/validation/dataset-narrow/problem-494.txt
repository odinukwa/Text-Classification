Correct use of each of these 'systems' will allow safe operation. Problems start to happen when things get non-standard, and flow against the standard usage patterns. When people cannot 'see' the concurrency-controls, that's when bugs happen. Your class imposes coding practices that are unexpected: 

There is once very significant issue, one significant, and a few run-of-the-mill issues that concern me. The most significant is the use of . interrupts on threads are not used by anyone, willingly. They are a PITA that few people understand, and everyone hates. First, though, let me talk about the poison pill. This is a good idea. It is well used. There's an implementation problem though.... Poisong pills are normally one specific instance of an object, and it is shared, typically through a public static field. I would do the pill as: 

Using that logic, the basic math for one array can be simplified.... for example, you can take the second array, sum up the values, and call that sum . Now you just need to take all the values in the first array, and multiply them by the sum of the second array, instead of summing the individual products. As it happens, you can take the same logic, and apply it the other way as well. Bottom line, is that the solution is simply the product of the sums of the arrays: 

If you are going to be unconventional, then you at least need to be consistently unconventional. should probably be an so you can deal with some concurrency in the clicked event - or, rather, so you can read it from a different thread later. Lambdas with side-effects should be avoided. Having said all of that, you really should use a style that is more conventional just so others can read your code better. The indentation levels on their own are a distraction with the addition of the anonymous blocks. Oh, there's one other item that needs to be said, with all the anonymous classes there, your stack traces for any exceptions are going to be much harder to read without the code in hand too. You lose all the benefits of named classes. This will hamper your debug time. 

find a 'pivot value'. move all values less than (or equal to) the pivot value to 'the left'. move all values larger than the pivot to 'the right'. quick-sort the values less than(or equal) quick-sort the values larger than. 

Your GCF function is also an area of improvement. The Euclidian algorithm is really easy to apply in go (it's recursive, but that's OK): 

Your self-review is about the same as what I would say .... and the issue is that you are using on the public side of the API. The people calling your and methods should have no idea that is a concept. You want to have just a string value to give/take from the shelter. This also fixes the broken generics on the Enq method. Something like: 

Part-way through an answer, and another answer pops up. My answer is slightly different to Prizoff's, so I'll keep it. In an interview, the trick is to take a moment to think about the problem, and what the requirements are. In this case, it feels like you have taken the wrong path to getting the results. The simplest solution is to keep a running tally in two loops 

Although your question indicates that you are using a functional paradigm, you are not. You are using a procedural paradigm. Functional programming is about declaring functions, and then passing those functions in to other places to be used as modifiers and manipulators for other processes. Terms like 'lambdas', and 'closures', 'optionals' or 'monads' are required. Procedural programming is the act of defining a process to follow, sometimes returning a value, but "I take this data and process it following this defined routine, and I get the results I want." Procedural programming often has functions declared, but the functions are not used as parameters to other functions. You do not pass any functions in as parameters, you are not using a "functional paradigm". You are using a "procedural paradigm". See Wikipedia's comparison between Functional and Procedural programming. Your code is a very poor implementation of a Functional paradigm. On the other hand, as a Procedural implementation, it is actually quite good, except for the method, which is implemented on a single line which is too long, and makes it hard to read with all the nested braces on one line. 

Functions You need more functions... still. I would create a function to control the file creation process (note the use of instead of ...): 

What this means, is that by shifting with relatively large primes, it takes a while for the same bit-pattern to repeat, and also, the coverage of the entire bit range is comprehensive. This is like the Cicada 17-year cycles and 13-year cycles, etc. making sure that no two species of cicada are (often) emerging in the same years. It means that the each bit in each input hash is used to affect every other bit in subsequent hash values as much as possible (and it affects itself as little as possible because an XOR with yourself is always 0). 

Optimizing this query can only properly be done on a system where the data exists, and you can 'play' a little bit. There are four things I recommend that you improve: 

Your code looks fairly effective, but it could be a bunch more efficient if you rearrange the code a bit, do some pre-processing, and reduce your run-time checks. Let's go through that in order.... I recommend a 'set up' stage to your code. Consider an ideal situation at runtime, the code would look something like: 

and that atomic may not get the value that was previously set. So, you have a potential race condition in your atomics. That's why atomics are not the best choice here. Now, you have a second bug in here. If your computer has 2 CPU's, the threads doing the work may be running on different cores, and have different memory caches. Consider the one thread does the add at position 4, and the other thread does it at position 3. Since the add to position 4 is in one thread, and that access and assignment to the array is not in a memory-controlled block, there is no reason for anything happening on the other CPU to get the updated 'copy' of that array, and you may lose that setting at position 4. Any access to a variable/array that happens in one thread may not get the same value as what's in another thread unless the accesses are all done via the same memory control/lock/monitor. In your 'read' side () you synchronize on the array, but, since the writes were not synchronized, there's no reason to expect the reads to get the written values. In other words, what you put in to the messages array may not be there when you read from the messages array. Other Issues 

Finally, does the control loops. I have added some validation, and other controls. Note, it is now only a single main method. 

It is very, very unlikely that running multiple files in parallel will go any faster than running them all sequentially (your bottleneck will be 'internet' bandwidth regardless). Is there something wrong with doing something like: 

long vs. int In your map you are keyed off the long value of the index. The long is simply related to the size of the map as you accumulate things. A Map can never have more than Integer.MAX_INT members, thus you can never accumulate more than that number of key values.... thus, why are you using a Long when an Integer will suffice? Simplification Consider this simplification, where the distinct phase is done in the intermediate Collector: 

There are a few reasons why double-checked locking does not always work in Java. There are a number of blogs with more detail, but I quite like this one and this one. Now, your code contains a volatile declaration for which, in certain conditions can mitigate the problem, but it is not a complete solution. You can still have cases where the variable is set in one thread, but another thread reads it before it is completely initialized. Since the values in the are not volatile, you will have problems still. Also, they depend on which is not volatile either... With Java5's changes to the memory model, you can probably use a 'helper' variable to initialize the data... something like: 

Your code appears to be inconsistent with respect to UTF-8 characters. Two significant issues I can see are: 

Also, what if the invoked method throws an exception... do you propagate that? Why do you feel it is necessary to have . The reflection you are doing should not be exposed.... 

i.e. if we multiply the and , and the result is negative, then we have a peak, or trough (an inflection). If is positive, then the inflection is a low-point. If current is negative, then the inflection is a high point. Using them all together, the code: 

The value of the node should be final (not just private). The Node class itself should be private, and should not be passed in to the method (it should be accessed as the private field it is) the return value of the should be the node's value, not the node itself. 

SortedStack This class has some simpler problems - naming, and style. It also has some algorithmic problems that may be improved. and are horrible, horrible names. and would be better. But, really, there's no reason to have at all, you can create it for the duration of the push method only - it does not need to hang around when empty. You also have the following, very baffling method. This is a "WTF" thing: 

This pattern starts with . This pattern says 'match any characters that end in a '.', but, the means that if nothing matches, then that's OK..... so, what the really means is "Match something with a dot at the end, or match nothing". This is apparently sensible, but, because the entire URL is not anchored to the start of the line (there is no ) it really means "match anything". For example, all of these URL's will successfully match: 

A listener and callback mechanism is a common pattern in many places in Java. The logical place to look for examples is in the Swing API. Will get back to that in a second, but, there are two items that are useful first: 

Use your tools properly ;-) You are missing a bunch of functionality that is available on your class that would help you a lot. First up, you have the following: 

(Filesystems with > 80% usage). Youa re aware that the df command will go a long way to solving the whole thing for your, right? grep/awk/sed 

Now, I know this is a style thing, but this line is unconventional for almost all style guides I am aware of: 

I can't help but think that your solution suffers because of the malloc you do in the middle of the operation (mergeList), and the fact that your malloc's are never freed. You call the mergeList from the recursive part of your algorithm, so, in effect, you create \$log(n)\$ copies of unfreed memory each time you sort. (for 1024 members to be sorted, you will create an additional 10 copies of the data that you do not free) Your leakage must be huge, and this is definitely bad practice. I have not worked it out, yet, but I believe there must be a way to do the recursion in a way that does not require any copies/mallocs at all. The overall sort is an in-place sort, so there should be no need for the wastage. Changing that in your algorithm would essentially be a rewrite though, and since this is such a large problem, there would be little value in small improvements in other places. When returning up the stack in the recursion, consider returning the 'right' pointer to the next node in the list after the nodes that have just been merged. This will help you to do the merge sort without having to scan it first for a mid point too. 

So, working off this, and using beginner-level C++ (I am a Java person), I put together the following functions: 

Your code is pretty good. It has elements in it which are relatively sophisticated too. For example, the recursion is clear, and the midpoint function is "right" (that needs an explanation - there's a 'well known' midpoint bug that many midpoint calculations have, but yours does not). I prefer 1-liner code to be braced, and yours is not. That's disappointing, because I don't like reviews that focus on that only.... but that's really all I can find wrong with your code style. There are a number of technical problems though.