Glad you took my suggestion and posted over here. I'm going to start from the most important (but also high-level) bits, and work my way towards specifics and code here. DESIGN ISSUES The main issue is that you're using lots of inheritance, which is a BadThing(tm). See below: There are a few things about your design that could be greatly improved, before we go into code. First off are some basic principles of OOP, called SOLID for short. I'm listing all of them for completeness, but your posted code is falling foul of the O and L bits: Single Object Responsibility: Each class should have one thing that it does (you are doing this). Open/Closed: A component should be open for extension, but closed for modification - you're falling down here because you're using very deep inheritance trees. This means that, if you need a specific ability to do something new, you will either have to cast that ability to the specific type or add a virtual method in the base class (thus needing to modify the base class design). This process eventually leads to an anti-pattern where the base class accumulates more and more virtual methods. $URL$ Liskov Substitution Principle: This is perhaps the most important, and the one that your design fails quite badly on. Basically, this says that if you have a base class, instances of that base class should all adhere to the same contract, regardless of the types derived from it. Roughly speaking, this equates to "don't specialise by inheritance". As in, inherit from a type ONLY to extend its capabilities, not to restrict them. Clearly almost any deep inheritance hierarchy is going to violate this principle. The alternative is to "own" a capability rather than "being" a capability. $URL$ (a little abstract) and also $URL$ (which is basically a design philosophy that arises from Liskov substitution). Interface Segregation - interfaces should represent indivisible capabilities. You aren't using interfaces here, but you should be (see below). Dependency Inversion - your Ability class depends on your Entity class. Assuming that your Entity class also depends on your ability class, you're falling foul of this. The best way to avoid it is to have the Ability class depend on a minimal interface, which has just the properties and methods that you need. CONFUSION BETWEEN TYPE AND INSTANCE There is a key issue with this design, beyond OOP principles, which is that you appear to be confusing type and instance - there isn't a distinction between the ability to pray, and the ability of a particular character to pray, for instance. Essentially, you're missing an entire set of classes that actually cast these abilities. For instance, suppose you wanted to introduce an ability that could be re-cast a limited number of times while it was already in progress. You would have a problem, because the class hierarchy that captures the ability to pray is the same one that's responsible for tracking the execution of a particular prayer. I would do the following: 

It is then clear that the action is the same. Always try to do as much as possible in the common code, and not duplicate code between branches. 

Not necessarily shorter, but you could create an object that takes the two arrays and does the merge for you, possibly using something like array_walk or array_map. 

Your first loop is unnecessary, you add more code, and more complexity, by making it a loop, and remove nothing. A loop where the loop control variable is unused should be suspect. You are repeating yourself, and in the process making your code harder to read. 

What kind of performance are you getting? Is it acceptable. If it's not, then I'd look for changing your algorithm, and not minor tweaks. In particular, I'd look into NOT splitting the string and recalclating each time. Instead keep track of the state (what line and the number of characters on that line, whether it's a paste or a delete), and do the right thing based upon that. Adding an additional character at the end of a 5k block of text, adds one more line at most, if the last line was 1 character long, then unless the key being pressed is the enter key, it doesn't even do that. But before doing anything, sit down and see how well your existing function works, for your typcial data, and then for some extreme data. 

You basically repeat the same 7 lines 4 times. And what's worse is that, as written, half the time the full block isn't possible. 

This change requires that we also perfect-forward these universal references wherever they may be used: 

Performs the set intersection of two integer packs. The output set is sorted. The output set will have the same integer type as the integer pack specified as the left template argument. Tests 

Provide a constructor that directly initializes the matrix Currently, you have to call , which simply allocates and default constructs the number of specified elements. This is inefficient unless you want a default-initialized matrix. Provide a constructor that allows you initialize the matrix directly: 

Replace long conditions with type traits. In order to promote from a smaller type to a larger type, you currently enable certain conversion operators based on on your type . These quickly become hard to maintain and are error-prone: you might forget to add a type, you might forget to update something, etc. In order to solve this problem, you can take a type traits approach. It will require some boiler-plate, but not much more than what you've already got with those long enable-if conditions. Traits based approach: 

Performs the set union of two integer packs. The output set is sorted. The output set will have the integer type returned by applying to the integer types of the left and right integer packs. 

Review goals The full implementation (with iterators and a -like interface is omitted because of the amount of boilerplate code involved. This question is already long. A sample toy implementation is provided in the demo below to demonstrate minimal usage. I would like a review that focuses on: 

While Corbin's answer is great (and I'd cetainly recommend accepting it over this), it buries the key point: your method does two things. This makes testing, understanding, and maintaince harder. You are supposed to a) generate a licence number, and b) filter out unacceptable ones. This should properly be split into at least 3 function, 1 to generate, 1 to reject, and 1 that calls the other 2 and only returns the result of the first if not rejected. At that point you should see what needs testing, what can be tested, and how to do your test. As for your final question: you fiddle with the process to make the error both frequent and repeatable. 

That isn't OOP, that's procedural, with a thin wrapping that looks like OOP. OOP will require that your validation be done on objects that share data and behavior. Depending upon your file, this may or may not make sense. OTOH, good procedural code is definitely better than the common PHP "just run it all together inside a single page" that frequently gets used. EDIT: Expanding my answer after a comment. First off, I should be clear that I wasn't criticizing your existing code, just saying they don't make it OOP. OOP is about data and behavior not just having things called classes and constructors. Secondly, EDI probably means transactions of different types with well definined behavior for the various types -- that would be an opportunity to use/benefit from OOP. I would try to design a base class or interface that can be applied to all lines/transactions and then have derived classes for the header/footer and body lines. You need to focus on the similaririty of your data and your process for handling/validating it, your OOP implemention will come out of that. It's a little to early to be asking about OOP. 

The variadic template is not a pack forwarding references, it is an rvalue reference pack. For it to be a forwarding reference variadic template, the variadic template must be a function template parameter: 

We need to test whether a certain door is openable by a certain key. Using the previous building blocks, that's easy to implement: 

Makes an type where is the values in the range \$[ 0, n - 1 )\$ when \$n >= 0\$. The template performs \$log(n)\$ recursions to generate the sequence. 

Unaligned memory Your storage is aligned for , which will lead to performance issues in most architectures and in others it just won't work (crash). Replace: 

Refresher on the simple selection sort This is a simple implementation of a selection sort on which the template-meta-programming version is based: 

Mark non-modifying functions as . functions of yours include , and a few more. Member functions that don't modify any of the class data members should be marked as so that they can be used in the appropriate scenario (accessed through a ). 

Now that you are using static memory, you can provide two private functions to avoid having to use ugly casts everywhere: 

I don't know Python, so this is a purely C++ review. 1 PYObjectBase 1.1 What is a const rvalue? Move operations ownership of some resource generally, so how can a move operation's parameter be ? It logically does not make sense. Your function... 

I like icemanind's answer, but to give an alternate point of view -- sometimes you just need to get it done. 

Whether you should use inheritance (either of a concrete base class, or an abstract class) or not or even whether you need two classes, depends upon a lot of factors, and there's not enough details here to say. But there is an alternative...extension methods on an Interface. They would allow you to have just one concrete implementation, that acted upon both. 

I assume that the part that you want to improve is the key.StartsWith.... I would replace the anonymous function with an Extension method String.StartsWith(IEnumerable<string>) -- then create a list of special keys (perhaps even load them from persisted storage, depending upon your usage), to be used in the extension method. Basically you add the over head of list creation, but your code now more precisely reflects the INTENT, making it easier to understand and modify. As middle ground between using persisted storage and creating the list in the middle of the your function, you could create a static function that returns your specialKeysList. As for performance, you should always keep performance in mind, but don't worry about it unless you have to -- you should only worry about performance when you have to ask "how can I improve the performance when doing this". At that point you have an identified problem, and you need a solution. If you don't have a problem, then don't do things that you know will cause a problem, but don't spend time trying to make it faster, that time is better spent either writing more code or making it more readable. 

Inside , we find the function which returns both the remainder as well as the division result. This function internally is likely to use processor specific instructions so that only one operation (division) is required to get both the remainder and quotient. Your compiler might perform this optimization, but let's not leave it to chance. Note that per Tamoghna Chowdhury's suggestion, we use and for clarity. 

Additional usage/test This simple example shows how one would create the symmetric difference operation of two integer packs using the already existing operations: The symmetric difference of two sets A and B is the set of elements comprised of: 

Do we really need and ? No. Here is an alternative solution: You currently allocate bytes. This is wasteful. You can use exactly as much space as you need by declaring your storage any of these two ways: 

Use when you're finished with rvalue arguments. In , argument is actually used as an (which calls the copy constructor) because you forget to call . The fix is simple: 

Although C11 introduced , there is no support for aligned reallocation (AFAIK). The structure that follows and its related functions provide such functionality. I wanted to provide something with as little overhead as possible, which is why there's close to no error checking done. I envisioned this structure being wrapped in another structure that does do safety checks if that is required. Is this reasonable design? features: