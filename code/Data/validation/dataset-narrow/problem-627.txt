(You would have to split up the ascending and descending sort options like that) One issue with that approach, though, is that in your original statement, I count four places where the statement occurs. That would mean repeating the long statement a lot. I think we can fix that, though. First off, sorting in a subquery usually doesn't make much sense. I don't see any reason to have and sorted, so let's remove those statements. Now we're left with two s: the one used in the function and the final sort. No matter what, you need to include the in the function to make sure your paging works correctly, but here's the thing: now you can use that row number to sort the final result (i.e., change the final to ). Now there's only one place where you need the dynamic clause, which is a lot better than four! Disclaimer: I haven't tested these ideas; just brainstorming. 

Write a query which calculates the distance by team. The only output columns should be and . Write a query which calculates the total Member bonus by team. The only output columns should be and . Write a query which calculates the total team bonus by team. The only output columns should be and . Join the first three queries on , along with any other information tables like and . Note that all the aggregation was done in the subqueries, so this final query should not need a clause. 

I am not understanding your game id naming approach here. Why not just use integer game id value? What value does having both and formats serve? Why would you be switching logic on "name" text string value versus a (typically) more authoritative id. Use of integer value here seems programmatically vague and potentially problematic. Why not just ? What happens when there are 1000+ games? 

Note that you can build upon the filter shown here by adding things like verifying file is readable/writable, get file modification timestamps, or other such functionality exposed by , which could include ability to easily create for working with file contents. 

I have comment below about alternate an alternate approach you might want to consider for form validation. Even if you don't want to make that change, consider generalizing your validation function so that it is re-usable across different forms. You could then pass form-specific configuration to that function and have it execute validation on what type of data you are validating. This could be as simple as an array you pass into the function containing validation and sanitization filters you want to apply to the passed parameters. Perhaps something like this: 

You might consider iterating the map in the second part of your code vs. iterating the string again. Why? Depending on the expected alphabet of characters and the expected length of the input string, it might be faster to iterate the map than the input string. For example, if you know you are dealing with an alphabet of 256 characters but you might have input strings lengths into the thousands or tens of thousands of characters, it would be quicker to iterate the map. This would require a change to your map so as to store the first index where a character is encountered in the string, so you might build a data structure like: 

I would just factor out the flash error into a constant. Also, I believe the trailing period in your regex should be escaped, as you don't want to match any character. 

My other suggestion is that you might want to monkey patch String as follows, to follow the pattern of other Rails Inflectors (note that including is unnecessary): 

This doesn't directly answer your question, but I also recommend switching from integer actions to enums: $URL$ Interestingly, this should not require any changes to your database at all, but will provide a lot of convenience methods and make your intent more clear. I do recommend hard coding a hash of the integer to the symbol in your enum definition to avoid any ambiguity: $URL$ 

I found a solution I like better, which replaces the loop with a . Sequences work but look funny as fake data. 

[Rewritten] You want to avoid inject, as is O(n) and clearer. Monkey patching array makes the code clearer and is idiomatic Ruby. Methods that return a boolean should end in . Method names should be snake_case. Here you go: 

Ruby uses SCREAMING_SNAKE_CASE for constants, which is what you are setting up, so I would call the variable . If you have a super long constant, and it's not created programmatically, then listing it a line at a time is clearest. Ruby will coerce into unless you treat it as a string. You can use the shorthand for arrays. So, the first couple lines should be: 

In the function, the only difference between "left" and "right" is the number that gets added to the current page. You can reduce duplication by pulling that out into a variable: 

If you follow this outline, you shouldn't need to calculate a to sort the results. Just . The advantage of this approach is that you can test each individual query separately to ensure that you are getting correct results at each step. It also should result in a shorter, easier-to-follow query. 

In the function, don't use in your call to . You've already 'd the string, so you're just wasting cycles by doing a text comparison. 

You really should be more consistent with your choice of line breaks and indentation, especially in a query as large as this. Improving the readability should also make it easier to spot areas for improvement. You didn't indicate which DBMS you're using, but if it's supported, the clause ("common table expressions" or "subquery factoring clause") can help reduce the number of indentation levels you have to deal with. 

A big problem I see is that you join some tables and subqueries too early. For example, and appear to be necessary only for information and don't actually affect any calculations. Furthermore, and only depend on the . Since that's the case, instead of joining them in the inner-most subquery, join them as part of the outer query. This will shorten up the clauses. The steps I would take to write this query: 

I have similar concern for namespacing between and . You are doing nothing to prevent namespace collision. Should own providing namespace to ? Should actually contain an array of that it owns similar to the relationship between and so that it can truly own/manage/instantiate within it's top level domain space? 

The class seems to have a poor data structure to store your countries. You should not need to iterate the entire array (which is what happens when you use ) just to do a lookup. An associative array (hash map) might be more appropriate here. So something like: 

Let's talk about the session file save path. I know there was some back and forth on this in the comments, with me suggesting that putting these files in a web directory is a bad security practice. You are right that one could limit access to this directory in other ways, but why would you want to introduce a security vulnerability that you need an additional security measure to mitigate? You are making your application security more complex and more fragile to someone not setting things up properly than it has to be. Additionally, it just makes no practical sense to be putting this data into your application web directory anyway, just from a straight separation of concerns/access standpoint. One doesn't typically configure database files, application logging, or other similar functionality that might read-write system files to do so into the application space, so why would you do this with session data? Ideally, you write session data into a directory only available to the root user or user under which your application is running under to access and you don't let administrators working with the production system have root/sudo access in production unless absolutely necessary. 

I moved the test into its own method to separate the logic. This still shows a Rubocop error of which you could fix by moving the nested iteration into its own method, but that struck me as more confusing than helpful. Note that creating the method allows us to use both and to break out of the loop at different levels. Also note the use of a guard clause. 

First, kudos on including specs to show what you're trying to achieve. Titleize already does most of what you want (and I presume you are running within Rails or otherwise using ActiveSupport since it's not in core Ruby). You just want to add downcasing of little_words that are not at the beginning of a sentence. A few notes: Variables should use an underscore to separate words and you want to use two space indents and single quotes. You should call your method something different than the built-in . I recommend running Rubocop to help learn Ruby style idioms. 

ActiveRecord enums "are exposed through a class method with the pluralized attribute name", so I recommend the following code. However, I would highly recommend making the enums symbols instead of strings for compatibility. Also, enrollment is spelled with two l's. Note that you can control the capitalization of DPR using inflections. 

Why is this necessary? If you validate properly you get away form this conditional. If there any reason to expect that the error messaging, which this applicaiotn controls would ever have extra whitespace anyway? 

Was your interviewer perhaps botherer by the fact that you did not handle type conversion? When mapping those values to an object, you make and implicit cast of the numeric value to a string, so if you are later asked to output the original values with tally for each, you might have needed to convert back to numeric. 

This sort of approach is very common when you need to read a "flattened" database result set into a multidimensional array or other hierarchical data structure. Note that this approach would require that your result set be sorted by the restaurant id (as is shown in your example). I would also suggest that if memory usage is a concern for you (i.e. at some point you are going to be dealing with a large number of rows), that you may not want to read out the entire DB result set into an array before passing it to your function. You are, in essence, having to store all the relevant data in memory twice with this approach. Of course, this means you would need to restructure your function call a bit to take a single row at a time and return an appropriate outlet object/array. I won't digress any more into this approach here, but it is something to think about. A few other code comments: 

This should work, but I don't recommend it unless you have a lot more identical examples. You could move both the hash and the into helpers, but I think that amount of indirection doesn't make things any clearer. 

Sorry I don't have time to review the full program, but here's a much simpler replacement for the method. Note is a redundant if you're then going to be splitting on white space: 

There's nothing magic about Rubocop, but it does encourage you think about what makes readable (as opposed to just correct) code. In this case, I think it is clearer to make the conditions explicit in the rating method as you've done rather than break them up into separate methods to pass Rubocop. Specifically, I would suggest this: 

I generally like to be Rubocop-clean, but it seems like breaking up the first case statement will only make things harder to read. Any suggestions? 

Your second method is closer to idiomatic Ruby. In general, you should never need to initialize an array. is a nice alternative to . And, you can open String and add a new method. I would do: 

In Ruby, it is almost never necessary to set a temporary variable to empty and iterate over an object, given the power of methods like map, reduce, find, all?, etc. I don't see the need to use since it doesn't change whether index will be present or not. It's unclear why you're checking for nil on the first sheet_activities (since you can't guarantee what will be first without sorting), but if you just want to return false when sheet_activities are nil, the above will already do so. Also note that Rubocop likes single quotes when you're not interpolating. 

I don't see need for checks in instance methods. You do a good job of throwing exceptions in constructor such that a concrete cannot be instantiated unless this is true, so this code is just redundant. Another related note is that, although you do a relatively good job of exiting early from your functions in exceptional cases (a very good practice), there are cases like in your method where you have pretty much all the method code nested in an conditional when early exit from function would eliminate the need for the conditional altogether. If you decide to keep the check this check, a failed check should throw an exception. Try to be consistent on how you approach this in your code. 

Since your code is incomplete for this class, it is hard to say if there is something else this class should be doing. To me at this point it is not really clear what this controller really does other than hold a DB connection. Perhaps you might consider implementing abstract methods here if the intent is to have inheriting classes provide implementation, though I see no signs of this from your code. 

I am not seeing great utility in separate map and reduce steps. This causes you to iterate your input options an extra time that could be considered removed if you wanted to simply consolidate all this logic into the reduce step. If the use cases are for small lists, maybe this performance isn't important and the added "clarity" of having two separate steps is acceptable.