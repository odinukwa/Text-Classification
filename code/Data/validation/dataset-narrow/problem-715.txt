from (minus the case sensitivity discrepancy). Unless there are some good reasons not to do so, I'd stick to only one implementation and reuse it in both methods. 

What's the point of catching a ? When do you expect it to happen? I don't really like that this method mutates the list passed in as a parameter - and then also returns it, even though the returned value is actually redundant as the calling code already has a hold of the now modified list. You're kind of sharing the result of the operation in two ways at once, which feels redundant. And I know it's often done that way, but I think it's bad practice nevertheless, and can lead to confusion. Personally I'd prefer to be more explicit about what's going on, and either a) make a deep copy of the original list, and return an independent version of it (with entries removed), without affecting the original one - or b) make this method , like Collections.sort(). See command-query separation principle. Making a method look like a query can lead me to believe it's a pure function, with no side effects, whereas it actually does cause side effects, mutating the input data. The name is very vague - "remove", remove what? Is the blacklisted data ("FIRST", "SECOND", "THIRD") likely to ever change? In the spirit of making this code more modular I would consider extracting that list to a separate parameter. Single responsibility principle indicates that a method should have one clear responsibility, and one could argue that filtering out certain entries and knowing the blacklist are two responsibilities. Your mileage may vary though, depending on the cnotext - which I don't know. Not a biggie, but whitespace is out of control (, ), not to mention it's , not . Depending on how class is implemented, which I can't see - if it's a light-weight object and if its method would compare instances by their value ()... then we could leverage Collections.removeAll and save ourselves writing the iterative removal by hand. 

Other than that, it might not be a good idea to send the user's email in plain text. You can have an AJAX request use the method as well as , which would improve (slightly) the security of personal information. 

The reason this works is is a shortcut for . With JavaScript, it is usually recommended that you keep from cluttering the global namespace. You currently have everything contained in , which is good. But since you're using jQuery, you might as well use a jQuery plugin, which would allow you to do something like this: 

This way, you aren't introducing another variable into the global namespace. Plus, the jQuery plugin architecture affords you some additional benefits, like syntax, etc. 

In the Main method of the Program class (my composition root), I read the file and hand it off to the Input class: 

You could hide the errors to begin with (just put on them), then you don't have to hide them in your script. Also you can group your variable declarations: 

We're kind of emulating Java's enums here (one of few features where Java actually happens to be superior to C#). And a little bit of help (so that we don't use reflection etc.): 

without the constants and the converting them to their respective classes? What value do you feel this additional abstraction layer adds to the code? (If you got rid of it, you'd only need implemented as follows: 

There, I'll say it: it can't be done. C# doesn't allow identifiers to start with digits. All workarounds either won't meet all your requirements (eg. @radarbob's answer, while clever, doesn't let you narrow down numeric values to a predefined set of legal ones, which I understand to be your main goal) - or will get you on a ride that ends up back on square one (if you use a dictionary as @Malachi suggests, then the name of this dictionary will go upfront, and it still doesn't start with a digit). Underscore prefixes are as close as you can get. Abusing Unicode a bit might work to a degree: 

When MyGame is constructed, it calls the Setup method of the Input class, which creates a dictionary using reflection: 

I've come up with two ways to do sprite movement with CreateJS, and I'm wondering if one is better than the other as far as performance and maintainability. The player data is saved in a json file and looks like this: 

If you know how reflection works in .Net, then you know it's looking for the methods by name in the MyGame class. The Exit method is actually defined in the Game base class, which I don't control. What does everyone think of this? I am considering moving the MoveDown, MoveLeft, etc. methods into another class, like IPhysics or something, where I would also do the collision detection. Since I haven't gotten that far yet, these methods live in MyGame for now. EDIT: Initially I tried to focus this question as much as possible on the Input class, but I would be grateful for any advice. 

My game uses configuration files in JSON format. One of them is used for setting up control bindings, and it looks like this: 

It's not bad already (save for the weird formatting of parameters, what's with commas at the beginning of the line? : ) But that's a matter of taste, and beyond the point). You could return to the trick you used in your previous implementation to avoid breaking the chain and get rid of value reassignments by pushing into the predicate, like so: 

Apart from using upper case for method names (as pointed out by @paritosh), I think it's a reasonable convention to use prefix for methods returning a boolean representing some state that may or may not be. Case in point: $URL$ Note this is a property, meaning you could indeed replace with a read-only property. Not that there's anything bad with leaving it like it is - properties are just more idiomatic in C#. Using a property kind of puts more emphasis on the fact that we're only checking on some state, and there's no side effects to that. (You can still implement a property in such a way that it causes side effects, it's just blatantly against the semantics of it). Last but not least, variables should be named with lower case in C#: 

I'm no PHP expert, and this might be personal preference, but I like to initialize variables at the top of the function to make it clear that their scope is not limited to the constructs in which they're defined. 

If you don't have a strong reason for using the attribute on your element, I would suggest attaching the submit action to the form without it. This would work: 

I tried whipping up my own extension method but, as I'm not really familiar with enums or arrays in C#, I'm afraid it's a little sloppy: 

In my game, I need to detect whether any buttons/keys are pressed at all before I try to process any input. This is easy enough for keys since the XNA library provides a method on the class: 

Both share the following code used for loading and instantiating the player object: (Don't get too hung up on the loading stuff. It's fairly complex and might take a while to step through. I just included it in case someone wanted to see.) 

and are . Did you test what happens for very large numbers? All your tests use trivially small values, certainly not the ones that would warrant the use of . Lagging constructors are a big no-no. I would aim for lazy evaluation here, or at least replace the constructor with a static method, with a name indicating it's triggering a process (create, evaluate, convert?). Constructors should be fast as lightning. 

These switches are identical. It bloats the codebase and hurts readability and maintanability. Aim for code reuse instead. In this particular case, you could create a method converting factors (expressed as 1, 2, 3 etc.) into actual values (0.001m, etc.) and call it twice in your code, cutting down on needless repetition. Nesting constructs isn't good practice, either - it's not very readable. Try to refactor your code into methods. Having the entirety of your program in is not recommended. Also, as @Michael has already pointed out, you're not validating user input at all. One typo and your app will crash, or fail to work as expected. 

The second implementation has this instead. is called on every tick regardless. When the mouse is clicked anywhere on the stage, is called once: 

If this is a web application, you can use an HttpModule to do your session management. Begin every web request by opening a session and beginning a transaction. At the end of every web request, commit the transaction and close the session. As long as you're wrapping all the hits to the database in a single transaction, you don't need to worry about efficiency too much. 

I'm writing a program to help with remembering complex bash commands. On invoking the program, it asks for a description of the desired operation, e.g., "increase volume" or "find orphaned packages", and displays the commands matching the input ordered by closest match. Matching is determined by splitting the command text into a string vector, then the description, and combining these with a list of additional keywords to compare with the input via . This is currently case sensitive, which I plan to change. This is my first C++ program so I've probably made plenty of mistakes. A couple things I'm still unclear on: when to pass arguments by reference, when to use and , and when to use pointers. 

Thanks to this pattern any new formats can be added as separate classes (supporting the interface), so the system is open for extension, and they can be registered within the factory. The base routine () is closed, which is what we want. The factory only carries one responsibility, which is to match any given file type to respective behavior, or file processing strategy. This means there is only one ever one reason to modify the factory: when this logic needs to be enhanced, or modified. 

be it a constant, or a collection computed in run-time, doesn't really matter. And then it gets as simple as that: 

Because the last two lines of code are the same for both cases. Then there's the loop iterating over the nodes sort of repeats in and . It's a bit of an awkward construct... which you already implemented once as . Why not reuse it? The class can just iterate over itself: . The clunkiness of traversing the list node by node gets abstracted away. The main takeaway in my opinion is that you should start writing unit tests for your code. It not only helps to catch out bugs, but also implementation inconsistencies, as it forces you to think about the contract and all the edge cases. I'd also put more emphasis on making code documentation actually useful for a hypothetical developer who'd want to use your code. Try to put yourself in their shoes: would you be happy having these comments to figure out how to use the class?