Since Logo was intended for this age group you might explore something there. My quick idea would require two or three screens with some sophisticated and time consuming simulation running on one and the kids/adults exploring simpler exercises that might (or not) build up to the one running. You can run, for example, a space filler (Sierpinski) program and have the students explore turning, etc. With lots of trial and mostly error. In Karel J Robot, the recursive graphical solution to the Eight Queens problem takes a bit of time and is built up from only a few primitives that can be combined and extended. So that would do for the running demo and the students can explore simpler aspects, such as a robot backing up, for example. The advantage of Eight Queens is that it is easy to explain, unlike, say, sorting. You can do this sort of thing in most languages - a complex graphic simulation built up from simple parts. The students explore only a bit of it. They can even modify some of the code of the running sim and run it to see what happens. It can lead to a lot of laughter, and some insight. If you sit with them you can suggest things that do something fun/weird/good/bad and ask why that happened. Lots of possibilities. But the running sim gives an unattainable target in the time frame. Like playing on the beach after professional teams of sand-castle builders have shown their skill. 

Students will act according to the habits they have built up. The one they have isn't terrible, but you can work to improve it. This answer won't save you much time, initially, but if you can change the habit then everyone wins. When asked a question you need to find a way to get them to respond first, somehow. There are various possibilities. The classic way is mentioned elsewhere here - ask them what the tried already. Their response needs to come before yours. If they have nothing to say, just tell them to think about it until they have a failed solution they can discuss, preferably along with the reason it doesn't work, as they view it. But a simpler and more devious solution is just to turn it around. When asked "How can I do wxyz?", respond as follows: "If I just asked you the same question, how would you begin your answer?" They don't need to say much, just the beginning. It may be enough to trigger their own knowledge, but it may also help you see their block and give them a minimal hint to continue. The keys here are "you (i.e. student) first" and "minimal hint". If they know that you won't save them a lot of thought and work that they can do themselves, maybe they will be more proactive about their own solutions, but the habit needs to be built. Work on that part. 

There are at least two parts to teaching naming. The first is to have a good standard that the students know and understand. This can be provided in a checklist. But the more important aspect is to always demonstrate good naming in all examples that you use and in all quizzes and exams that you give them; even for very simple exercises. The Naming Standard The goal of a naming standard is to make programs easy to understand and to reason about. There are a number of possibilities here and you can and should develop your own. Here is one I use: 

Note that I've said similar things about teaching and reaching your students in answer to other questions on this site. 

I'd like to summarize a few of the answers already given by suggesting a general framework for such "chicken and egg" problems. You have two things to teach that are closely related but different. You can't really learn one without the other. The solution to such kinds of problems is to use a spiral approach. This is already used to take students through a set of topics deepening their understanding on each loop, rather than trying to teach everything about one topic before moving on to the next. If I do only the back end development for a long while I'm going to get bored since nothing exciting seems to happen. If I do only front end development for a long while I'm going to get frustrated since there is no support for the things I'm building. So, teach a little of this and a little of that and then cycle around. Teach enough backend, say, to support something, and then enough frontend to make use of that, then go back for more - again and again. In fact, some sophisticated sites get built in just exactly this way. Make your teaching as agile as your development process. And note that this process isn't limited to just the current question. Spiral teaching is a big idea. There is even a Pedagogical Pattern by that name. 

For those who haven't heard it before, there is an old puzzle: Which came first, the chicken or the egg. 

I'll also note that learning new languages is actually harder than it is often represented to be. If two languages are within one paradigm and have similar concepts then it may seem to be merely a question of new syntax applied to old ideas. Java and Python have similar ideas but quite different syntax. But learning the syntax of Python as an experienced Java programmer won't make you pythonic. But changing paradigms is much, much harder, even when the syntax is nearly the same. I'll note that C++ was derived from Dijkstra's ideas primarily (via Simula), whereas Java's core concepts come from Alan Kay. If you don't understand that then you can wind up programming badly in both languages. 

This thread is so long that I'm not sure that I picked up every point made, but I want to add an orthogonal thought that I missed if it is present. Any timed exam, whatever the technology, old or new, will advantage some students and disadvantage others. Time itself can be the mind killer. I don't have a real answer for how to overcome it, other than to be constantly aware of it, and compromise when needed. Your students are not like you. They are nothing like you. They are very little like one another, actually, with different learning modalities. However, toward the end of my career I deemphasized formal exams (even finals when possible) in favor of papers and projects. Yes, I know that there are dangers with that as well, especially plagiarism. 

If you teach center dot as and, then + for or should be pretty natural. Tell them that or is logical addition and and is logical multiplication. Likewise, + can be used for set addition (everything in A "plus" everything in B). Likewise "or" means that something is in A or it is in B (maybe both). So, +, or, and Union are all alike. Naive Set Theory and Simple Logic. So it isn't just that the same symbol is used, the ideas are actually related. If you teach them the distributive laws for these it will seem even more natural. What will be less natural is that or and and distribute over each other, while in arithmetic you only get one distributive law. P or (Q and R) has the same truth table as (P or Q) and (P or R). Etc. Similarly for the other law and for set union and intersection. "Arithmetic is the anomaly, not logic." And if you put it like that, they may be more likely to remember. 

I used only the simplest case of a functional interface here. You can use Consumers, etc just as well with only a bit more complexity. 

The main advantage I see in using Cumulative Grading is that the student is always sure exactly where they are and what they need to do to obtain a grade that they will find satisfactory. An additional advantage for the individual student is that they can pace their efforts out over a wide range of courses and activities without undue stress. Not all students feel that the course I'm teaching is the most important thing in their lives, so it gives them a bit of freedom to pursue a variety of goals. Of course, in some students this means that they don't maximize their efforts for my course. I can counsel them to higher and higher goals, of course, but I found that the superstars will still superstar. I also permitted re-work on projects of all sorts, large and small. A student could improve their grade, but not up to the maximum for the exercise. The standard was that you could get back 90% of whatever you lost on the first trial. So if you got 70 on a project worth 100 you could get back about 27 points by redoing the assignment one or more times. For some students this rework, and the repetition-reinforcement it enables, is especially valuable. Point grading seems to encourage the re-work a bit more than percentage grading. The possible down side of this, for a few students, is that they would re-do an assignment many times but spend less time on newer assignments, possibly reducing their effort there. I had to caution a few students on this and very occasionally had to tell a student that I'd accept no further re-work so they would focus on other things. Overall, however, the combination of Cumulative Grading and re-work seemed to be liked/loved by my students. It also let me focus my office hours on the students who needed help the most. 

A student studying Computer Science requires some knowledge of finite mathematics, including logic, probability, counting, etc. In the use-case at hand, a HS or University course in finite math is not an option as the student is self studying. What are good resources by which a student can learn the necessary material to support a CS degree? These could be books or online resources or perhaps other things not yet considered. However, one essential aspect is that the student needs access to materials by which the topics can be practiced, not just read about. Resources with lots of exercises at different levels with a way to obtain feedback (answer key or other) would be essential. 

A great resource for the instructor to learn the max about invariants is to go to the master. David Gries, The Science of Programming It isn't a book for novice learners, though. But understanding what is in this book will help you a lot in teaching programming via invariants. He reveals all. He and his son have an undergrad text book also, that might not be quite as deep as this. In particular, David shows how to develop good invariants from postconditions. 

Your list is a bit narrow in one sense. I assume it is well matched to your specific course, but probably doesn't represent "best practice" in general. For example, valgrind is limited to linux, which suits you better than me. But the idea of including memory testing, for example, is a good idea no matter the specific tool. Similarly for git. There are alternatives, but code management and version control is the big idea. But one item I find missing here, but also essential is some sort of tool for unit testing. There are many available and building good clean code requires pre testing everything to arrive at a good result painlessly. Another suggestion I'd make, though this may be your intent already, is that you show many of your ideas in the context of a large and complicated program. You state that dealing with such projects/programs is an issue in the course at the beginning of your post and that may actually be the biggest issue. So don't present your tool set using only "toy" programs. If the projects are done in teams you may also want to include something specific about how to be successful in a team environment. Many of your students may not have experienced that. There is a book, in fact, named Teamwork is an Individual Skill that has valuable hints for any professional. 

I note that the comment of user ctrl-alt-delor given to your question (testing language usage vs content) is also an important consideration. You can work around it on an individual basis in some situations as long as you are sensitive to it. But if your overall environment doesn't permit individual adjustments or mooting a question, you have to be more careful, likely avoiding the subtleties. 

Actually, there are two questions here. I'll answer the obvious one first. You can fairly easily solve the perverse incentive problem by having two due dates: one for the first 89% and a later one for the rest. If you have ideas about what they should do for the second part, don't reveal them until they turn in the first part. You needn't necessarily even mark the work after the first deadline, but you can, if desired. After the first deadline you have a version of the project. You can compare it with the second version to see what changes/enhancements have been made. In situations like this, I usually have students turn in work on paper and in the second version, mark changes (highlight markers) so that those changes are obvious. The second question is how much you want to encourage student "creativity" anyway. It isn't always good to let students loose without specific direction. There are two kinds of creativity: the what and the how. In the real world, it isn't normally the programmer who is responsible for the what. That is up to the Customer/Client/Boss/Organization. The creativity on what belongs to them. On the other hand, creativity (i.e. excellence) on the how is the key attribute of a good developer. For most assignments that is what you should be looking for. Do they understand the algorithms? Can they implement them efficiently? Is the code clear and maintainable? Is it tested and correct? So, I worry that if you just give an incomplete specification of the work and expect them to use their own creativity around what should be done, that they will get the wrong ideas about building things. As others have said in answer to other questions here, going outside your charter can be seen as a problem, not a blessing. See this, for example: $URL$ On the other hand, teaching creativity is also a goal of education and there should probably be one or more courses, or at least projects, where students do get to conceptualize, design, and build something interesting. But don't let them get confused. 

The kinds of things suggested in your question and many similar things won't help them. Learning some other "tool" or "language" or "technique" at a beginners level will still leave them with just a bunch of tools they don't really know how to use. Instead give them a project - preferably a hard project - in which they can use what they have learned, but which also likely forces them to learn at least one new thing. Moreover, if their goal is employment, make it a team project so that they get the experience of working closely with others. If you can make it a real project, not just an academic exercise, all the better. Also, make them use some proven methodology, not just hack together a solution. My suggestion would be Extreme Programming, since it is completely defined and has good personal practices within it. It would give them good guidance for a first such project. Scrum, being a bit more general might leave them without the guidance they need, hour to hour. 

tl;dr/ Students tend to do what they have the most practice doing. But timed contests can advantage/disadvantage some students independent of skill and background. I have to admit I'm not a big fan of timed contests for programming. I don't know if that is the situation here, of course. The problem is that they favor quick thinking over deep thinking. If you don't have time to get something for every question your score likely suffers even if your solutions to the ones you work on are brilliant. My advice to a student taking such a challenge would be to get something for every question. That said, I would expect that students who have seen a lot of OO, and, in particular, have written a lot of classes themselves would naturally (and quickly) put down a class framework and then write methods. Less likely (given time constraints) would they do a problem decomposition into appropriate helper objects and composition of objects to solve any problem. It just takes too long, unless they have an IDE that will produce class/method templates at a click, or use JUnit or similar to build the application scaffolding for a given test. Likewise, I'd expect that a student with little experience in creating classes would be more likely to just write functions, even if they had seen objects/classes. In a way, assuming that the test judging criteria allow either approach, these students may have a bit of a time advantage since there is less to type. The psychological effect here is that you tend to do what you have the most practice doing. So Object-Early students automatically start by writing class ..... and Object-Late students may not. But there is little time for reflection on the quality of your overall structure in any case. And likely none for refactoring. A possible countering psychological effect, since the competitions/challenges take place during the school year is that there is a tendency to repeat what you have most recently been focused on, being fresh in your mind, though less settled. My bottom line, however is that programming isn't best tested in a timed environment, especially when the questions can be tricky in some sense, where you get an advantage, perhaps serendipitously, if you just think of the trick involved or have seen it before. Some students (my history says I'm one of them) is disadvantaged in this situation. On the other hand, I can write code very quickly (hundreds of correct lines of code per day) with good tools and practices, including test-driven development with a good IDE (Eclipse). But if you give me a variation of NIM or some other mathematical puzzle, I'll stare at it for too long.