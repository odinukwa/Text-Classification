I have drawed this to explain the behaviour when a collision with AABB boxes is present. When you have choosen what dimension has to be fixed, you can change the position of the object that was moved accordingly. Here is some code to accomplish the task, (it's not tested and will require tuning for sure) 

This is a similar way of doing that, but next time your sprite sheets shoud follow the ascii layout to make it easier... :) 

I think you are not initalizing the shader right. I don't see projection matrix initialization. Here you can find how custom shaders work in xna 4.0 $URL$ 

"dot" is a cosin not an angle, can not be compared to "fovRad" that is an angle You can get angle of "dot" with an arccosine function, or get the cosine of "fovRad" to compare them. 

Seems that adding or substracting 0.5f to your calcs would do the trick... you only should be careful with negative tile coords, then should negate the sign of 0.5f Here you a are a video where I show how it's done (code included) though I'm working in 3D projecting to isometric 2D, the facts are the same. 

EDIT: If you want to zoom about a certain point (target) and translate camera to the meet center of viewport... your code should similar to this: 

Should work.. I thing your over complicating things a bit... Is easier using a rectangle for this without using rays and boundingboxes: 

Try to render the first batch with SpriteSortMode.FrontToBack and DepthStencilState.Default Then render the particles with SpriteSortMode.Deferred, BlendState.Additive and DepthStencilState.DepthRead... I think it should works... 

This should move the object to the last touch location, you can change ratio to adapt the speed. (I have developed never for wp7 but I think it should do the job) EDIT: I didn't know TouchLocation was a struct. So I've changed the code. 

MeasureString() returns to you a Vector2 where the X is the width and Y is the height of the text. Also the SpriteFont class has a LineSpacing member that gives you the height of a line, including text and blank space. $URL$ 

it remember me to magnifying effect i'm used to do long time ago in vga 13h mode... using the bresenham circle algorithm to get the lines that draw a circle and applying a function to the distance from the pixel to the circle center to peek the color based in the new distance from a backbuffer where the original image was. Now it can be accomplished with an hlsl postprocess shader easier.... you can google for radiul blur... or pinch effects and it will give you something near to what you are looking for... Here you have a sample where you can test this kind of effects: $URL$ 

1) Figuring out mouse position: I think is easier using a Ray/Plane intersection. Seems that your plane is Y=0, then the code is: 

The X position of the background have to be calculated with the X position of the player and a speed factor. 

for moving other meshes... you have to change the bone... but it maybe quite hardcore... is better to use an animation tool Keep in mind that the Bone transform is relative to its parent bone transform and play with it... You can do something like this: 

If you can play your levels, you can make the editor ingame... it is not too difficult.. these are two samples one of my tiled games and its ingame editor 1st version ... $URL$ 3trd version playable... $URL$ other editor for non tiled game but ingame too... $URL$ 

I have the same concern, and I have been thinking about it long time... I'm going to expose my thoughs though maybe not a good approach... 

if you see the draw, I think is easier to understand. You should have a ship position that is the same for the blast, and you have two sprites with different sizes. You should realize the rotation is related to the origin, so you have to pair the rotation origins. The yellow circles are the origins for each sprite: 

If you can see all, them you have a problem with the alpha channel of your textures. Sometimes the alpha channel is stored as a key color. You can enable an option in the texture processor of the image to manage this situation. Going to Texture/Properties/ContentProcessor/Color Key Enabled And related to order, if you use a SortedList to store sprites, it will be orderer by the key, your key is the name of the file, so it's ordered alphabetically by texture name, if you want other order, change your key or the file names. You can use a file name format like "Continent\00-Europe.jpg" to give the desired order. 

Create a new texture. The polygon have to fit inside. Fill the texture with Color.TransparentBlack Draw the polygon's edges with lines. You can use the bresenham algoritm Do a flood fill with your texture. Then you save this new texture. Later inside the game you can draw with this new texture as a rectangle 

Second... I would render the axis base to see if itÂ´s moving right.. because of your parent rotation or your camera view the behaviuor described maybe is right... 

You should not use loops... Have you consider using a palette, and use one color channel of the primary texture as index? You can use the red channel as index, and sample to a Texture1D where you store your palette colors 

Fixed Point Math: I think is a must to keep sync the simulation for every player. When there is an input at tick 1000, you should estimate the effective tick for that action... if you consider a ping of 200 ms and your tick duration is 30ms, the tick could be (2 + (200ms x 2) / 30) = 15. You send a message to every player proposing that input for the estimated tick at 1015 Every player has to validate that action sending an acknoledgement message back. When the 1015 tick is reached, if any of the players has not been validated... stop the simulation... you have two options: try to validate again or Kick him. 

you call to base.LoadContent() inside LoadContent and the method is not overrided. Maybe adding the override tag and removing the content manager parameter will do the trick ... 

In this sample you can find an algorithm to pack small textures into a big texture, that is quite similar to your matter... and maybe a good start to solve it. $URL$ EDIT: You can use a tree, where the leafs have empty regions, and the rest of nodes have the rectangles. You can iterate deeply to get a solution. Algoritm At first pass, the node contains the empty region. There are four combinations for adding the rectangle, by the orientation ( Vertical, Horizontal) and the way that region will be divided. Add the four combinations. Choose the first child, Try to add next rectangle, adding every combination as before If there are no room for the rectangle go back, and test next child of this parent. Repeat that until there is no more rectangles to add. 

You should separate logic space coordinates from rendering space coordinates. Usually at logic space coordinates (world coordinates), your tiles will be size(1,1), your calculations will be easier and simpler. and when you draw the tiles you will apply a camera transform that depending on scale will let you draw tiles with the size that you need, without affect your logic calculations. Using a camera transform lets you perform screen oeprations as scrolls, zooms and rotations in an easy way, and is easy to determine the visible tiles too. it has a lots of benefits... so NO.. is a bad idea at logic stage to calculate the screen position and size of a tile... is much better to use a camera to transform from world coordinates to screen coordinates. 

The easier is to test it... :) but yes... you can... the texture maximum size is 2048x2048 or 4096x4096 depends on the profile, you can use a array in CPU memory to fill it, 

I have done several editors... and the easier is using c# winform... it provides you with buttons, panels, listbox... Of course, you can integrate it in a panel, like proposes @milkboat, but I think that winform series is not a good example.. because the xna code part is not driven as usual, there is no game class, and the code becomes ugly... I prefer use this code, $URL$ is not mine, but I've modified it to add the interface and the CreateAndShow method. This way your game will not suffer many modifications among using the editor or not using it. You only have to inherit your game class from XnaControlGame, and the editor form that will host the xna control should implement IXnaFormContainer. I think is easy and more elegant than other approachs.... because let you difference xna part from the winform part An editor with this approach: $URL$ An editor with a simple form approach, when the form is visible is editor mode, when dissapears is game mode. $URL$ 

This is equivalent to your players class skill definition area... I think that is not your final code, but it you need load skill definitions from xml is easier now to adapt the code, and create them programatically. 

You can add a flag for the citizen to know if it's leader or not. And you can separate the Logic/IA and made Behaviours, this way units can behave in different ways easily. There is technique called Behaviour Trees, but maybe it will be enough for you encapsulating the state machines. 

I think you have a garbage problem... maybe you are creating/destroying to many objects and that spikes are the garbage collector routine working... be sure to reuse all your memory structures... and don't use 'new' too often 

Model and texturize your scenario with a 3d modeler like blender or 3ds max, export it to fbx, and load it as a 3d model in xna. 

The graphics device manager is created in the game class constructor... You should use the reference that provides the game instance to access to the GraphicsDevice if you are inheriting from Game class... in your main class code you can use 

You should calculate the target position with the previous zoom, and calculate it again with the new zoom, and then add the difference to the camera position. Should be something similar to this (not tested): 

if you don't want to stop simulation at first waiting for every ack, you have to be able to rewind and sync simulation to an older tick. This can be acomplished in several ways, but I think the easier can be keep a copy of each object state for each tick in the last 2 seconds. 

You can use a GameScene approach too, where you have scenes that inherit from a base class, and a Stack to store them. I think is a good solution that lets you encapsulate different situations in the game in different modules. 

Solve the two equations and you get IP (X,Y). Maybe you'd need to check that IP is between A and B... before continue... Then you build a new line with this equation: 

When you change the size of the xna control... the viewport is changed... so you have to recreate your camera projection matrix.. if you are using spritebatch you should recreate it to initialize the projection matrix that it uses internally. 

it can be done modifying the bone transform of your model. You don't need submeshes, each vertex in a model should have a bone weight property that quantify how that vertex is affected by the bone transform. In this image each color defines the bone that is applied to each vertex. 

One option may be defining a new BlendState...and choose the right BlendFunction and Factors to get the xor operation. I'm not sure it can be done, but it is the easier way and should be your first option. $URL$ The second option is using a HLSL shader and rendertargets. 

If you scale the parent bone by factor A, scale the child by 1/A and it will keep the size. Ej. if parent scale is multiplied by 2 you should mulptiply child scale by 1/2 = 0.5f 

I think you should use a binary format to avoid a wastw of space. Shanw Hargreaves proposes the use a PackedVectors: $URL$ In the Networking Section you have other post: $URL$ 

Don't use DrawUserIndexedPrimitive... create an individual vertexbuffer for your moving objects.. or group all your moving objects in a vertex buffer to share it... in your object draw call, you can set an individual indexbuffer and transform the position passing the world matrix to the effect 

You only need to multiply your velocity vector by the time to know the offset, this way if time is smaller, then the offset applied to the position will be smaller too: 

The world Translation affect object in your world, so usually it will be a simple Translation. But if you want scale, rotation, ... is done this way; 

if other components need the model, they should get it throught the content manager... in case a component need to know what model has other compnent, maybe you need a post initialization method where it succeed 

This can be done easier if you always turn to right and/or the relation between angle and direction is fixed, then you only should use Directions and an array to convert directions to angles. 

Realize that this kind of algorithm lets a simple solution to the model size problem too, because you can consider that the portals are smaller by the 2xradius of your model. 

You can use TreeSharp and behaviour trees to model a dialogue system. TreeSharp is a library that provides a simple behaviour tree implementation. IA bots for wow are done with this, so it's mature... :) My implementation has nodes that let choose between answers, and each answer can be joined to othe dialogue or an action, or a sequence of actions, or a node that lets going to another dialog... or what yo want... I have used brainiac editor to make it visually... but at the end it produces c# code based on treesharp... $URL$ 

Rendering it as a quad (two triangles) and passing the heights as an 1D texture, like a heithmap texture, can do the trick. 

Many times I choose a constant ratio, and work over current value, this way I have not to consider time duration and time elapsed, and results are fine. 

where forward is the vector you want to face... $URL$ I think you don't need it, but if you want to get the yaw from that matrix... you can use the matrix method 

You may have several problems: A) Using string for directions is not a good idea... because the string comparation is slow and case insensitive... is much better using an enumeration or integers.... I prefer enums... 

Note that if your color change affects every vertex with one unique color, you may consider to pass to a shader a single color as a parameter, and do not modify vertex. 

Store the user data in a different place like you want... You can save a copy of the loaded data or only the modifications made... When the user get into the game next time check if exist that copy or modification, use it else load the default raw data through content load. 

You need SAT Collision Detection Basically you need to look for the minimum displacement vector that substracted to one of the objects let them to no intersect. In your image the minimum displacement is the orange segment. 

where the Vector3.UnitY is fixed, and the face normal are rotated, so calculation is now in world space. EDIT: If you want to use vertices... calculate the center of each face, if the face has two triangles correlated: