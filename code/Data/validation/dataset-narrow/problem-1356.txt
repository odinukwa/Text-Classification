Many of the answers at the linked question may help. Here are some other ideas off the top of my head. Lots of what I remember about FZero was the ground and barrier textures that were very obviously striped/tiled in ways that they weren't very "long" in the "forward" direction. As you pass by these elements, they seemed to whiz by at very high speed. Very commonly, the ground textures would change to a different pattern, further enhancing that feel of speed. Very responsive, almost jumpy/jittery, controls give a feel of speed as well. In FZero, very slight shifts left and right are actually rather noticeable. Speed lines (wind-like particles) may or may not work for your environment. They're probably at least worth an iteration or two. Banked turns. Play off the knowledge players may have that banked turns are related to high-speed driving. I like the idea of the lower camera angle. Staying tight(-ish) on the vehicle will certainly make the environment local to the camera pass by more quickly. The closer the camera is to the vehicle will increase this effect but, of course, be wary of making the game unplayable through being unable to see enough. 

Note: I'm rusty on my XNA so the specific functions you may need to call may be a little off, but the concept should work. Post-clarification Edit: 

I don't always play RTSs, but, when I do, I fail miserably. As such, I can offer general implementation ideas based on my understanding of RTS camera movement/mechanics. The isometric perspective could be fairly easily achieved by setting your camera to orthographic and finding a rotation that looks down at an angle that "feels right" for your game. Scrolling around the world in this style is just movement on the world's XZ plane; you would not change its height at all. 

The function (link) is called every frame for every collider that is touching another collider there are also (link) and (link) for similar behavior at the start and end of contact. If you want to do something while your object is being collided with, put that function in a script on that object and put your code in there. A Collider is the object that does the colliding. The Collision is the event/data that tells you about the collision. Some explanation can be found here and other places in the Unity docs. 

Unless you're going to have so much going on that the speed of trig functions is going to be a concern, I think focusing on a Polar system will be sufficient. Storing the angle and distance-from-center for your sprite ( and , respectively) will make the logic for moving based on Left, Right, Up, and Down understandable: Moving Left and Right would change your angle while Up and Down change the distance. To draw the sprite, converting to Cartesian coordinates is pretty straight forward: and (plus some offset to rotate around the center of the screen/playing area/whatever). Rotation of the sprite would simply be based on the you're already storing. Either exactly equal to or plus a constant, depending on the initial orientation of the sprite. 

A problem you'll run into with Android is that every different device has its own screen size, resolution, and pixel density. If you want your game to look identical on all devices, you're in for a lot of work and will probably never be pleased with the results. Either the game will appear stretched on widescreen displays or compressed on non-widescreen ones. I suggest you decide what's truly important and let anything else slide a little. Without any screenshots or knowledge of what your game is and what it looks like, we can all speculate solutions but we don't have specific direction to give you specific counsel. In Unity, you can access the dimensions of the current screen with the Screen class: and (among other properties). You could then change the Camera's aspect ratio to change what is visible on your different sized screens based on the screen dimensions and your personal expectation of what should be visible. If you need to ensure any HUD displays are scaled properly, you can do that by changing the GUI transform matrix based on the screen's dimensions in every function. I've done it before by making this simple script and attaching it to anything that rendered GUI elements I wanted scaled: 

In short (and as has been mentioned by others), 2D Vectors are functionally just wrappers around a pair of values representing position, motion, or whatever in 2D space. It sounds like you're just looking for resources to better understand them. It's hard to know what your expertise level is, so here's a link dump based on things that, from a quick glance or my past experience, I'm guessing may be useful for you: 

Having happened across your cross posting of this question on Reddit, it looks like you're just interested in determining the movement for the whip in "dangle" (and possibly also "flail" mode). The term you want to hunt for is Forward Kinematics (Complimentary links: Wikipedia, Some less complex math site). Essentially, each section of the whip has a length and an rotation. For any link, , after the first, its position is determined as being 's length away in the direction of the 's rotation. Start at the handle of the whip and determine locations of each section in turn down to the end of the whip. Setting how much a link can rotate each tick is up to you and your desired physics outcome. 

For at least one object in your scene, the variable isn't assigned. The error "Input Key named: is unknown" shows that it's not displaying a key's name (otherwise the error would be more like "Input Key named: up is unknown"). For every instance of whatever object has that script on it, you need to ensure it has a legitimate value in the inspector. The value additionally must match the name of a key as expected by the Input Manager (see Input.GetKey()'s documentation for further details) or you'll just get different errors. If you have instances that don't need to check that button, either remove that script from the object or check that has a value before checking . 

I assume you're using that code in the picture and it's giving you the incorrect box shown on the right? The algorithm looks sound enough to find the minimum and maximum and values in your list so are you sure your vertex list is properly representing the triangle you're trying to determine a box for? It looks like your bounding box is the right size, just shifted in the direction. Are you sure that the vertex locations you're sending are accurate for that triangle? Have you tried shifting it in different directions to make sure the disparity is consistent? What have you tried? Additionally, I notice you aren't setting your rectangle to an initial value, that's going to potentially cause a problem when setting it for some objects. Whether that's the problem here or not, I'm not sure. I'd recommend setting initially to represent the first vertex you send in--so you know it starts with valid data, then iterating through the rest of the list: (or, if Flash is different, however you'd do it there). 

If you still get false positives, consider using a numbers closer to zero than 1.0 and -1.0 (like 0.9 and -0.9) for a little less precision in determining a collision with a non-wall. 

I hope I understand what you're looking for now. It sounds like gizmos is probably what you want to be using. Though, since your description isn't very specific, it's hard to know for sure. It would also be a bit tough to offer specific suggestions on how to use them. You can do things like use the function (link) in your scripts to add extra visual representation in the scene editor of various object properties. It automagically updates gizmos in real time based on changes you make to the object's properties in the inspector. It's also handy to use since the visual effects are not included in a build of the game so you don't have to worry about cleaning up superfluous objects by hand before build-time or by ad hoc script at run-time. For example, in a racing game I worked on a while ago, I used spheres (with ) and lines (with ) to draw the size of and connections between AI trucks' navigation points. It made it much easier to lay out and connect the waypoints and ensure they were properly sized to get the effect we wanted. I also drew lines from the AI trucks to their destinations to make sure they were behaving properly during the game. 

If you have the funds for it, the Asset server with the pro version of Unity is pretty decent. I have used it on a large, multi-person project in the past and it did the job. For vanilla version control, it did what we expected it to do. I've tried using an SVN repository with a Unity project and it was a bit of a hassle. We ended up scrapping the idea before getting it to work, however. Unity keeps a lot of backup files that I didn't want to take the time to find out what would happen if they weren't synced to the server. I think, with a little finesse, it could be doable but I haven't had experience with it working well. I have done a small project using the free features of DropBox. It made me nervous but we never had any issues. And, I don't think we ended up needing any real version control stuff for that project so I can't speak much to how reverting or merging files would have gone.