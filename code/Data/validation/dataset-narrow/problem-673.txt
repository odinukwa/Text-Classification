Your code assumes the above will just work, but that is a bad assumption. I recommend you change your code to work on the actual implementation provided in the concurrent package. It does support these things. Also, the following code in your downgrade method is unnecessary: 

Sorting Your algorithm looks sane, but the interface is ... cumbersome. You have a , and declared as members of the class. Now, the rules of object orientation indicate that the data should be encapsulated. There are two logical ways to implement the sort that I can see. The one is to have a static method that takes a Stack as input, and sorts it in place (creating a temporary, and method-private auxStack to sort with). The other solution adds the sort method to the Stack class itself (and also has an internal auxStack). The second route is the better one. 

Loop/range on a channel (assume returns a channel of Frame instances), and then send each Frame down the websocket. This sets the channel as an "api" to the camera, and the logic is encapsulated in there. Now, the challenge is to set up a source for that frame channel.... A separate goroutine that polls the camera for new frames, listens to a stream and breaks on each frame, or loops on a timer (like you have now), or whatever mechanism best suits managing your camera, would feed Frames in to the channel, and you've thus separated the two concerns. You can also now have different mechanisms for sourcing frames, and still feed them in to the same method for delivering them to the websocket. 

You have an issue if you live/deploy in an area that has daylight saving times. The way you set it up is to happen every 24 hours, rather than at a particular time each day. When a time shift happens, your event will happen at 5am, or 7am depending. In the past I have set up a time-of-day schedule for jobs, and I found the best way to do that was to set up a self-repeating wrapper for a task. When the task runs, it reschedules itself for the next iteration. So, the way I did it was to create a Runnable that self-replicates each time it runs. The concept ends up being somewhat simple (somewhat...). So, consider the following code that will reschedule itself after running: 

I am not convinced that your general structure is useful as it should be. I have been trying to untangle how your code us used, and what sequence of events happen in order for the code to run the way it should.... I have run in to a number of issues in that process, and they all add up to a suggestion that you are using the wrong approach. Even with your current code, there are the following items to add (in addition to what other reviewers have pointed out)... Generics The class should be generified: 

Note that this, on my machine, produces at peak (after JIT warmup, etc.), about 30,000 results per millisecond, or 30million per second.... (and suggests days, even months worth of processing): 

For a novice, your code is good. The variable names are good (though should be , if I was pedantic....), and the code is logical, and well structured. There are ways to improve the performance a bit. I suspect that looping through the text 10 times (once for the , once for the , and repeated for each vowel...) is excessive. In fact, you could reduce this to just one loop through the text, but the overall saving will be quite small (for small text sizes). My real concern is if there are no vowels, then your program produces no output. I would print the count of the vowels even if the count is 0. This shows that the code is working, and checking things. This would remove the need for the inner if-conditions too: 

It is recommended practice to have a default-DROP policy for OUTPUT, but, in practice, I have seen very few servers that actually do that.... it is hard to live with. 

That's Java 8 streams, but the logic should be relatively clear. Loop from 1 to factorsOf, keep those values which are actual factors, and convert the factors to an array of . That is a single-purpose function, which makes it clear, and reusable. Now, create a function that converts an integer array to an "and" separated string... something like: 

Variable naming is very important for readability. Now, as some background, when I first saw your question, it had the title: 

create an array of size populate it with consecutive numbers shuffle it using a Fisher-Yates shuffle. return the first elements from the shuffled array. 

(but then continues to use your version in his subsequent code) This is a good suggestion, but, more than that, you have to do that (or something similar) because your version of the dice-throw does not work. 

I'm sorry, but the best solution to this problem has to be a logic solution, not a code solution. There are only 2 digits that, when multiplied by 3, have the same last digit... 0, and 5. So, 0+0+0 is 0, and 5+5+5 is 15. Since C cannot be 0, it means that C can only be 5. Now, if C is 5, and we know that there is a 'carry' of 1 in to the tens column, it means we need to find a number other than 5 that when added together 3 times ends in a 4. There is only one value that does that, 8. 8 + 8 + 8 is 24, and with the carry of 1, we have 25 (and a carry of 2 in to the 100's column). So, now we need a digit that sums three times to 3, and that's 1. There is only one possible solution where ABC + ABC + ABC is CCC, and that's 185. It can be deduced using logic alone, and brute-forcing it is overkill. 

Try-Catch There's no code in your function that throws an explicit exception - why do you have a try/catch? All integer parsing comes from digits in a , so there can be no illegal characters, etc. Character-to-digit-value Your code has a lot of this type of logic: 

All things considered this looks like a really good beginner's attempt at the problem. The really good things I can see are: 

If you choose a fixed row size that is also a power of 2, then you can accomplish the same with bitwise operations. A row size of 256 elements, is implemented as: 

You have tagged this question with algorithm, and I like algorithm problems. In the spirit of the original question, the solution should not be using any additional space, which means your char vector suggestion at the end is not really relevant. I would agree with your analysis, that the problem is reduced to \$O(n)\$ by storing the vowels and consonants in different vectors, and then merging them again... but that relies on an \$O(n)\$ space complexity too. I think the solution that the original problem (with no additional storage) is looking for, is a three-pointer option.... a 3-point turn, to make a bad pun. Consider the following algorithm, which contains three pointers. Each pointer advances sequentially from the beginning to the end of the char array. There is a 'rotate' operation that makes a temp copy of the last char in an array slice, it then shifts all previous chars forward one, and then inserts what was the last char, at the front. The three pointers consitute an \$O(n)\$ sequence through the data, and the rotate is another \$O(n)\$ operation, but worst-case is n/2, and the worst case will reduce significantly as the pointers advance, and the gap tightens up.... Technically, though, the time complexity combined worst case is \$O(n^2)\$ though. So, in pseudocode: