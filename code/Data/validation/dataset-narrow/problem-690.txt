We've already used datetime.now(), it's both simpler than timestamp.strftime and it's nice to not have to introduce new functions unless necessary. There's an even shorter alternative you could use, which trades off a little readability for space: 

This uses the modulo function to convert 24h to 12 h clock. Also, it's better to use docstring in for your code documentation. Something like "Convert our timestamp to 12h format, split it, select first element(hours) and cast to int to remove leading 0 (e.g. 09.00 will give us 9)" is closer to being documentation for yourself/others. It should be a docstring. You should also think about removing the implementation specific elements -- those are more appropriate to use a comment. I would rewrite the comment as: 

At the end of the file. This allows the file to either run as a script or to be imported into other modules. For example, if you wanted to reuse your function in a different project, you could then do . 

This looks pretty good -- views should generally be pretty minimal. These seem pretty short, and most of what you've done so far seems appropriate. One pattern you might think about is using a mixin to dry things out a touch more. Eg, you have all your methods decorated . If you created a LoginMixin, with and just decorated the method there, you could loose a few repetitions. Mixins are also nice to have, as you can stash other repetitive elements in them as needed. 

I think a big first improvement for you will be to start DRYing out your code. You should create a function which returns the ratio of two sides -- there is much too much repetition in your code. Something like: 

That decouples the interface of the function from its implementation. One nitpick about your above code, which I only noticed noodling around with it now in a shell session: That's a very long function name. It's generally good to be longer than shorter and more explicit than less, but also consider it can be tiring and people have to remember the names of your functions. Try to find the shortest name that accurately and specifically describes what the logic does. I would probably name that logic something like . 

I would expect using to be faster than using the shell loop, but it might be worthwhile to run a timing test. 

where represents a separate script that does the stuff found inside your current loop. Of course you can also add to the command: 

statement. However, your code repeatedly reallocates , so never has more than one element set in it. Allocate the array earlier in your program, perhaps after you know the sizes match. 

• Your script runs four new processes while setting , and . To avoid all those separate processes, use various shell parameter expansions as below. (Eg, when f=/home/tx.7/xyz.axi.pan, these produce , , , and , respectively. Note, these expansions should work for all the files in your directories as listed by , but if used in other scripts will stumble when given names like or or some other edge cases.) 

The important element of a shorter program is using a direction-array to set the step directions in your matrix; whether the matrix is represented via a 1D vector or a 2D matrix is less important. In a vector, the same-column cell in the next row is n elements away from the current cell. 

• The structure is likely to produce a large list of file names and then process it. That list need not be stored if you instead use (eg) 

The previous answers addressed some alternative ways of accomplishing the backup and versioning goals; in this answer I'll comment on three or four possible improvements to your script. • For clarity, I prefer at the start of a script like this to copy all of the parameters to named variables, as you did for the first of them. • The lists all the files and directories in $2 and below, but presumably the bulk of those files will have been treated already in previous runs. For example, to avoid processing files older than second-previous run, in each run write a time-marker file and use : 

I think there's serious readability issues with this, and I also can't think of any time I've ever seen a function/method being called inside another function's signature. I'm going to go out on a limb and say this is a Bad Idea -- for one thing, I suspect that automated code documentation tools might have trouble parsing this. More fundamentally, a function/method's signature is its interface with the rest of the world. It just seems like a very bad trade off to muddy the readability of a signature in exchange for saving a couple of times of code. I would refactor to something like: 

I assume you intend to be using integer division here? Ie, ? Also.. why are you repeatedly declaring different variables with the same values? 

If you actually need to parse strings such as '46732 1.1' into dictionary key/value pairs, a regex would be a good fit for solving that problem. A little quick fiddling suggests that something like would capture what you're looking for. This RE matches: one or more digits, zero or more whitespaces and one or more digits followed by zero or one decimal points followed by zero or more digits. You can use this pattern by compiling it, folloed by python's method. 

Also, it's generally considered bad practice to use : if new fields are added to the model they will be rendered for the client by default. It's much safer to use explicitly whitelist fields using the attribute of the meta class. 

Comparing different data types in Javascript involves the type coercion system, which in javascript is a Bad Thing -- you're basically putting yourself at the mercy of an extremely unpredictable system. But, beyond that, it's not even clear what your intention with this line is -- how does it make sense to compare a float to an array? 

If I understand what you're looking for correctly, it's the cheapest rate for a particular phone number. If you already have the rates of each operator as a dictionary of key/value pairs, then you don't need a regex at all. The following code finds the cheapest rate in a set of dictionaries: