This has a somewhat complex answer - a key question you need to answer is "what kind of work are you asking the machine to do?" The instruction sets across different machines (ARM vs Intel vs whoever else) as well as the quality of the compilers make a big difference in actual performance. If the work you're asking to do has hardware acceleration on one machine but not another, that factor alone is going to make more difference than a significant change in the clock rate. In the most general terms, I think the biggest bang-for-the-buck in terms of price/performance will come from a moderately-clocked multicore general CPU from AMD or Intel. If you're in a controlled environment where the ambient temperatures are low, you can likely overclock these chips a bit to get more performance. The rasPi is definitely NOT designed for this sort of stuff, which should not take away from it's high value in learning how things work, and even building a truly "distributed" system at a very affordable price. But if serious data and/or number crunching is what you need to do, the rasPi isn't likely to be the right choice. 

Where is the username of the account you want to use for automatic log in. Note that this bypasses security, allowing access to your PI without the password of the user. 

It compiled, was able to execute it (as root of course) and it ran and completed without throwing any exceptions. It did not however output anything, not even the text "START". But if I remove the line it does output "START". I can't explain it and I'm not a C guy so I started looking at Python. Using py-spidev, which is 'somewhat' documented here, I started porting the code from the Arduino samples: 

There's no problem putting both of these devices on the same voltage rail, PROVIDED that you have enough power to keep them within spec. Most hard drives spike their power on spin up, but anything modern should also have a limiter that keeps that constrained. The hard drive you choose will matter a good bit, but just as a reference point I have a 1TB "standard" WD 3.5" HDD here in my desk that is labelled at 0.66A @5V and 0.55A @12V. There are definitely other drives that use more power, but I think you'll find that these values are pretty common for most "general purpose" drives that are out there today. If we add up the power rails assuming 0.5A for the Pi itself, we get: 5V rail: 0.5amp for the Pi + 0.55amp for the HDD -> 1.05amp 12V rail: 0.0 for the Pi + .66amp for the HDD -> 0.66amp My personal experience is that most things like hard drives are conservatively labelled, because manufacturers want to re-use the same motors and other equipment and it's perfectly fine if they over-state the power on the label (whereas under-stating it gets you in trouble)... so given that you're only at 50% load on the 5V and barely over 50% on the 12V rail, I'm pretty comfortable saying you're OK with this. 

You question does not specify whether by 'terminal' you mean the classic terminal or a graphical session with XTerm opening up automatically. I'm going to assume the first. If you're using you can log in automatically by editing Search for the line: 

The project on Google code defined multiple requests for each piece of information, but the idea is basically the same, for example getting the manufacturer id: 

I'm trying to interface with a Winbond W25Q64BV flash chip via SPI. I started off by testing it on Arduino (target is a Raspberry) as I found a few implementations before I got started. Most notably this instructable and this project on Google code. The instructable gets the 'jedec' information like this: Looking at the code from the instructable, the implementation to get the jedec information 

how can I distinguish between different Raspberry PI during passing command via Cloud ? (if i use Cloud). How should I authenticate my incoming command(data) on Raspberry PI for security purpose ? (Is it coming from my Application only). 

Actually I have many Raspberry PI 3 Model B and I am able to find Serial Number of my Raspberry PI using Python script. But I can't able to send data from Cloud to specific Raspberry PI using it's Serial Number. Is there any way to send data from another device to Raspberry PI using Raspberry PI's Serial Number ? Any Suggestions/Links would be Thankful. 

With the function I'm trying to simulate the calls to in the original code, but I honestly do not know if it's the same, although if I don't call I always get 0x00 data. The problem is, that I receive 0xFF for all 3 values when the flash chip is connected to the SPI bus (whereas I receive 0x00, 0x00, 0x00 if it is not connected or I don't toggle). So I'm wondering why the code using the BCM2835 library doesn't work (but doesn't throw errors either) And what I might be doing wrong in the Python version. Or basically, how I can interface the Raspberry with the flash chip successfully. 

I want to Remote access my Raspberry Pi 3 Model B from my Mobile Application(that i have created). Actually I have many Devices at home that based on Raspberry PI (many Raspberry PI) and want to control from one Mobile application without Port forwarding. I also referred Dataplicity Documenation, but it's give different command for different Raspberry PI, so i can't bind those in one mobile application. 

I want to access my Rpi3 from anywhere. For that i have created an Free account on noip.com. I have a my Hostname too. I am using O2 Router at home, and also setup for DynDNS as well as Port Forwarding. But once I configure my Hostname with port, that i open in Router, noip.com says Port is not open, we can't connect. I tried with different port and finally i got one open port(port 22). With port 22 i can successfully configure my hostname. So now my Problem is : 

After confirming this worked with the Arduino I wanted to port it to run on a Raspberry. I enabled the SPI and confirmed the interface was available (method described here). I installed the BCM2835 C library on the Raspberry (wheezy) as described here Which is basically: 

This works great in the sense that it starts X (with ratpoison) and my application, and it also restarts the application unless that .keepalive file is missing (which is something defined by the application). The problem however, is that on the Raspberry version of Debian Wheezy, there is no file in the /tmp/ directory to indicate X has started so the check in will always return false and an attempt will be made to start X every time. How can I check if X has already been started on the Raspberry?