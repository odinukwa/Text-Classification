I'm not as familiar with Python as I am with other languages, but I'm sure your students have played Minecraft. If you haven't, I suggest taking a few minutes to find some introductory "Lets Play" videos on YouTube first. Let's talk Blocks. Minecraft has dozens of blocks. Dirt, some, water, colored wool... All blocks can be broken, picked up, placed, stacked, stored in chests, and crafted together. But not all blocks do just those things. The chest let's the player store items in it. The furnace smelts some blocks into other blocks. Grass, when broken, drops a completely different block. Stone doesn't drop anything at all unless dug out with a pickaxe. Minecraft can do this because of all of those basic methods that subclasses inherit and override. Take this method (not pulled from source, just based on): 

Websites such as $URL$ and $URL$ are great for students to practise this type of competitive programming activity. In order to prepare them for that type of competitive challenge it can be good fun to create opportunities for competition and collaboration early on when you're introducing new programming concepts. For example: 

Once they've been through that process in a safe and controlled environment they'll be much more confident joining in with an open source project. It can be intimidating jumping in for the first time, no matter how friendly and supportive the contributors are. You might also want to look at GitHub Classroom which automates the process of creating, sharing and collecting programming assignments from students. 

Ultimately, I don't think it's a question of choosing a particular type of student to pitch the level of difficulty to. As teachers we have to be deliberate in our planning and delivery so that there's something even the least confident student can leave having achieved but also some bait dangled tantalisingly just out of reach for those who want to discover for themselves. All that, whilst not neglecting the majority of students who find themselves in the middle of the two extremes. Realistically, my answer to your question is that we can't guarantee every condition will be reached continuously in every class period for every student. I can't anyway. But it's worth giving it a try - it makes teaching more fun as well as more productive. 

Providing the class with pre-chosen code, for the specific purpose of teaching quality control skills and methods (of which review is a component) will help to ensure the code is suitable for teaching the points required, and does actually contain review points where you can provide notes and grades fairly. Asking students to peer review may mean some get easier or harder code to review than others, and some get code poorly suited to review lessons. Teaching the class the importance and focus on QC and quality production methods, puts review in a context - they will need this knowledge professionally as almost all software businesses do operate some form of QC and/or review. Simple as that. By giving them code you have chosen, you can be sure that whether individually or in groups, they have a target number of important and secondary review points to identify, which may motivate them to look harder. The rationale is, if you have to find and review 10 major points in a block of code, as part of a review, you might spent extra time taxing yourself to find the last 3 items, compared to an open-ended count. You'll probably remember them better as well. 

Ask them to switch their screens off. They don't like it if you do it too often or for too long but it's surprisingly effective, saves you having to repeat yourself unnecessarily and forces you to try to make your instructions clear and concise. If you can't see their screens you can always tell by the glare from their screens on their faces who hasn't followed instructions. 

The Russell Group of Universities has published a useful list of recommended A level subjects for different degree options which suggests that other than a CS degree, CS A level is recommended for: 

I tend to avoid multiple students working on the same code simultaneously (Google Docs style) because it's really difficult to assess what has been done by each student or to stop one student dominating whilst the other doesn't understand what's happening. Either that or students tend to get distracted by what the other is writing. Having said that, you could try: 

I would generalise this, because other symbols and terminology are also affected (">" or textual statements such as commands). Start by explaining that symbols and terms in each language have meanings specific to that language. They may overlap or have similarities, but never assume that just because a symbol or word has some meaning in one language or scenario, that it has the same meaning in another. Then use "=" as an example of this general rule. This changes "=" from "a problem affecting one situation" into "a classic example of a really important rule that applies to all of computer science" and into a memorable learning point. You can then pick a few other examples if the students need it. This will prepare them for the idea that different languages often also have different philosophies, approaches to, and ways of representing even superficially similar programming structures. 

After reading the answers here I'm left thinking... What about doing classroom code review? That is, have the students take the assignment they've completed, print it out, hand it to someone else, then have the students review the code they now have in front of them. When everything thinks they're done, have them switch papers yet again, getting a third set of eyes on things (one coder, two reviewers). Each reviewer would write their name on it as having reviewed it as well. I hear tales of how marvelous code review is, but I've never had to participate on it in any sort of official setting (i.e. for a job, as a classroom assignment...) but I think this would be a good way to introduce the concept. It's often hard to spot mistakes in one's own code, so having to look for errors in someone else's tends to be easier, as well as letting people see alternative approaches to problems ("What's this syntax here, ? I've never seen this before"). 

Problem solving and computational thinking is a hugely transferable skill in itself. Almost any science / engineering route through academia into the workplace is greatly benefited by the ability to write / modify some code that will process data efficiently and generate exactly the sort of analysis / evidence that you require. For example, a substantive part of a Psychology degree involves collecting and processing statistical data. Even without the logical and analytical benefits of CS, the ability to write code to automate the analysis of that data immediately gives you huge advantage over peers without any CS skills. 

Write some code that is unfinished with some deliberate mistakes and share it with your students on GitHub Get your students to clone / download your code, find and fix the bugs then talk about the problems with having so many different versions of the same code in the classroom. Get your students to fork your code into their own repositories and commit their own changes. Discuss code and commenting conventions and why they're necessary (e.g. PEP8) Get your students to go back and recommit their code in line with the conventions discussed Ask your students to issue a pull request on your code so that their changes can be contributed to the original resource. 

There is a really good teaching point here. Ideas often arise repeatedly in different contexts. That includes the ideas behind Functional Programming. We also all know how fast computing changes. Your job is to teach them computing, and its up to them to choose how to use it and the specialist areas they need most, which they probably don't yet know as 90% of what they will each specifically use, and several key paradigms they will come to rely on in their future careers spanning maybe 40+ years, hasn't yet been invented or become the main paradigm. Given that you are preparing them for many years ahead, and a broad topic, it is reasonable to include FP and expect it to be taken as serious and useful. Like machine code, firmware, and logic gates, few of your students will directly use it, but many will indirectly use it and all will use tools and techniques which began in it. As even the protesting students can't tell whether they'll find it useful in future, its got a strong ground for being taught, so they understand the concepts and history behind it, and behind what they now do. Also so its there if they do come in contact with FP work in future.