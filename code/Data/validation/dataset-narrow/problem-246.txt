I'm using PostgreSQL 8.4 and I have a table that is cleared out and refilled with new data every so often. I want to be able to store the date that the table was last filled, but I'm not sure where to put it. I'm really a novice at database design, and the only two things I can think of are: 

There's about 1000 to 2000 rows normally. It's just for a hobby project. Any help will be greatly appreciated. 

First off, I'm not a DBA at all, I'm more of a front-end guy, but I'm currently hitting a brick wall and can't figure out how to tackle it. A database I am working on has a table with several columns. The table represents completed tasks, the columns are: 

A task can only belong to one category, so if a task for company THR was "return-to-base", it must only be under category 2.1.1, not 2.2. I realise these categories seem very arbitrary but this structure represents the most useful break-down of almost any selection of tasks from the table. My question is, is it possible to create a view that contains the TaskID and its category? Or should I just implement this logic in the front-end after selecting every TaskID, Type and Reference? 

Since you left join through to get to when there are no rows all values in are null and this condition is removing all of the rows. I'm not 100% on your schema as it has not been provided but the following should have the result you are after: 

Is there a way to prevent a non-persistent computed column from updating within a transaction? I have thrown together an example which shows that these columns can update when using non-deterministic functions (in this instance ). Does this not break the consistency requirements of a transaction? I have tried using transaction levels to prevent this (serializable and snapshot) which has not helped. Query: 

I am not entirely sure what you are trying to achieve by joining on and as they are different data types, and . When this join is being completed it is trying to implicitly convert into an and it contains data that cannot be converted as the error message shows. If you are trying to get the employment status of the user with of I would do something similar to: 

First off, I'm using SQL Server 2008 R2. When I set up my maintenance plan and got to the "Select Report Options" step, I selected to email the report to the Operator I already have set up. This does not allow me to alter the subject, which I believe Gmail uses when it collapses emails into conversations. Is there a way to trick Gmail to separating them out based on the database? Or is there a better way from within SQL Server Management Studio to email the reports out? I have multiple instances, with their own Operator, each Operator is using the same email address (no_reply@noneofyourbusiness.com), but the name is different....but since the subject is the same, Gmail still collapses them into one big conversation. Does anyone else have to deal with this issue? 

Even though you are using SYS (which you really shouldn't be), the view is stored in a SCHEMA1, as I will refer to it. SCHEMA1 is trying to select from a table, via the view, in SCHEMA2. Therefore, you need to grant SELECT access to SCHEMA2.TABLE to SCHEMA1. And don't run things as SYS. :) 

So basically, three staff all start out with a target of 6.0, but on March, staff with ID 1 has a new target of 7.0. I want to maintain historical targets because it is relevant to other data in other tables. I would like to have a user-defined function that takes a date as a parameter, and this function needs to join the above table with another table based on the date. Say the function is called with 1st of February as the date, I would like the result of the join to include the target column showing 6.0 for all staff. Something like this (I think this won't work because there could be multiple rows before ): 

Create a table with the sole purpose of storing the date Timestamp every row in the table with the same timestamp 

I'm not sure if I've completely fudged the design of my small hobby database (I'm not a DBA by any means), but I have a table like this (primary key is ): 

I don't believe so. Because it's free, Oracle seems to have limited it to 32 bit to prevent it from being used for business purposes. 

Does anyone know what triggers the USER_ID field in the log.xml to be populated? The value also exists in the V$DIAG_ALERT_EXT view. I've found by observing the logs that if a temp tablespace fills up, it will log the USER_ID of the problematic SQL statement causing the issue. But other than that, it appears that value is always NULL. 

If you need to run this as schema1, you could just write into your script to temporarily log in as schema2, use the USER_SOURCE solution, generate your script, log in as schema3, then run the script. 

IMO, an external table is much easier to manage and flexible than a SQLLoader script. So if you're already doing a recurring SQLLoader load, I see no possibilities of evil in switching to external tables. By doing the external table, even though the base of the table resides in a text file outside the database, the data can be accessed from within the database, no need for a separate SQLLoader tool/scripts. So you can write procedures/packages to manipulate the data straight from the external table. No need to load it anywhere...as long as it's in the directory you have set, it's already "loaded". As a DBA, I'd much prefer managing a DML script using an external table than having to manage a SQLLoader script. But SQLLoader has been around a while....if your DBA has too, it may be a tough sell. :) 

Looking at the schema provided, what is the purpose of the link between and ? If this is to determine if a player is participating in that league you would need to duplicate each record for every player in that league which would break your primary key. In order to determine if a player is part of a League you would need to join from through and to . I believe this link can be removed and the column in dropped. This will resolve any many-to-many relationship issues that I can see. Also you are storing the players name in both and , is this required for history or can this be normalised and use the data in the table throughout the implementation? 

is a deterministic function, meaning that duplicates will be labelled with the same rank value. The outputs of your queries suggests to me that there are multiple records with the same and that also have the same value. These records will all return with the same value. If you run your inner query, you will see these duplicates where all three attributes are the same. If the is also the largest value for that combination of and they will all have the value of 1. To get your desired output, you should instead be using . This is a non deterministic function when the parameters in the clause do not uniquely determine the rows, which is true in this case. This will assign a unique result to every row, but as your query provided duplicates it will assign each of these rows a unique value at random. Your second query using :