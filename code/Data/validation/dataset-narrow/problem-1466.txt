If you can live with students always working in pairs at the machines, then you have cut the interpretation problem roughly in half, maybe more. Only half as many machines need to be set up and there are two minds working on each machine. (Of course they could disagree making the problem harder, but usually this helps.) If you can manage to have an assistant wander around the room helping the students with the most trouble it can help, though pairing is better. (Paired programming has been shown to be more efficient and require less intervention by the teacher, but that is not quite the same problem you pose here. Students working alone get stuck and wait unproductively for assistance. Pairs work it out.) 

The Basement is the lowest level, most concrete layer and the Attic is the highest layer. The Attic might represent a true API intended for others to use (such as the Map interface) and the Basement is a low-level, even physical layer, perhaps. In practice, The Basement provides services to the layer above through a set of public methods. The Main Floor is written in terms of services provided by the Basement and itself provides services to the layer above via its own public methods. You can work either top-down or bottom-up. However, before you can take advantage of this teaching strategy you need to build some scaffolding for the students to use. How much you have to do depends on whether you work top-down or bottom-up. Advantages and Disadvantages of Top-Down To work top-down, students build first the Attic with the Basement coming last. If your students work from the top down it will be easier for them to understand the reasons for doing all this work, since the services that they are building are at a level that they might find useful in their work. The lower levels, though in reality more concrete, are more opaque since they aren't normally visible to the programmer directly. On the other hand you actually need to do more work yourself for this as the normal Java tools don't give you as much support. I'll explain below. Advantages and Disadvantages of Bottom-Up To work bottom-up the students will build the Basement layer first and the Attic last. The advantage of this is that normal unit testing tools (JUnit) make it easy for you to provide the required scaffolding. However, the students may find this less satisfying as the things they will build at the beginning may not be as obviously useful. This is mitigated by showing them how the parts will eventually fit together before they start. They need some overview information. Building Bottom-Up To have the students build the Basement layer, simply decide on the interface between that layer and the Main Floor. These are the services that the Basement layer must implement. Use JUnit to write tests against this interface, simulating the Main Floor, sending known values to the Basement Services and making assertions about the values returned. Students then build the Basement and make those tests pass. Make the test suite public so that they can write their own tests, however. Everything is open and available for inspection. The Basement Layer may consist of several classes, some, perhaps, unrelated to others at the same level. For example, in a hash map, the actual Hasher might be at this level but the storage mechanism might be independent. You will need tests for each of the services, perhaps distributed over the classes. Once the Basement is built, do the same for the next level up. Create the interface between the Attic and the Main Floor in JUnit and then have the students implement the Main Floor, providing those services, but using services of the Basement layer they already built. To build the Attic, just repeat. The public API of the whole system is given a test suite and the students build the Attic using services of the Main Floor. Building Top-Down Building Top-Down requires more work since JUnit isn't available, though you may be able to find some Stub Testing tools. The basic idea is that you first define the interface between one layer and the one below and then provide a Stub (set of) class(es) that implement that interface but accept known values and return known values when services are required of it. To build the Attic, then, when the Main Floor doesn't yet exist, first develop the interface between the two. You then give them a Stub that they can use in writing the Attic. They will need to use the services of the Main Floor, but instead will be writing against the Stub's services with well known behavior. When they are ready to write the Main Floor, give students a Basement Stub to that provides the services that the Main floor needs but using well determined "test" values. Finally the Basement layer is written without additional stubbing. However to avoid chaos when a stub is replaced by the actual layer code it will be essential that you also have a sufficient test suite in JUnit so that you know that what arrives at the outermost level actually makes sense. Note that some development environments, such as Eclipse, will create a stub class for a given interface (or set of interfaces). The stub will have methods that ignore arguments and produce default values. You can tailor these, of course. Caveats and Advice Note that in both of these methods as described above, the instructor is the one who defines the interface between layers. This lessens the work of the student, of course, but is in some ways less satisfying. One can, instead, have group discussions in which the instructor leads the class to the development of the interfaces (actual Java interfaces) that form the boundaries between the layers. If you use this method, you will need to build your infrastructure after this discussion, but it may be little more than renaming things you built earlier in preparation. However, these class discussions also give you a way to talk about the layer separation. And note that large software systems with such an architecture are often built this way with different teams working on the different layers, with someone like an architect defining the boundary APIs. And not again, that in some such situations, with many layers, efficiency dictates at some point that intermediate layers might be combined or eliminated. But, for teaching this initially don't permit that or your students may wind up building a Big Ball of Mud CF: Test Stub Mock Object 

Of course it depends on your overall goals. For me, however, the answer is clear: Use the most powerful IDE that I can find (Eclipse or NetBeans fit my def). I started programming on primitive equipment (card punch) and came up through every level since. I don't romanticize the old way of work and I wouldn't go back. I wouldn't try to impose primitive tools on newcomers. But then, in CS1 my goal is to teach them how to program effectively. I think that is a hard enough job that I want to ease the path in every way possible - remove all obstacles to thinking about the problem and creating a solution. In Eclipse, I can integrate testing. I don't need to type every character of the program. I can leave pretty-printing to the system. I can integrate useful program metrics. I can have compilation done automatically. I can search by structure, not just text. And on and on. Emacs is quite wonderful, but it has about 200 textual commands to learn. Life is short. I wouldn't try to impose any less-than-the-most-powerful tool on a pro. I wouldn't on a novice either. However, if someone comes to me already a vim (say) expert, I'd let them use it, and might not even notice. But if they hand me unreadable code, I'll notice pretty quick. But as I said at the top, it depends on your overall goal. For me, the overriding goal is to ease the process so that students can focus on the programming itself and the mind-expansion that comes from that. If a better tool comes along, I'll work to use that. Key punching was abominable. So was the teletype, ... 

Yes, definitely. There is a need, while developing an algorithm, for a language (or diagramming technique) that is less precise and requires less detail than a formal programming language. This is to let the developer expand his/her thoughts from an overall view to one that is more and more refined. This is true even for high-level languages, though the language itself may be useful for that given a test-first design methodology and good tools. A pseudo-code is also useful for presenting algorithms in a language neutral way so that implementers may build to suit a need in the language of their choice. I note, especially, that The Science of Programming by David Gries uses such a pseudo code throughout. The code is defined in the book and fairly precise, though leaves out many details needed for implementation. It is the same language, in fact, that Edsger Dijkstra used in his papers. I used several variations on it as the basis of a compiler course for many years. The Gries book should be on the bookshelf (and in the mind) of every serious computer scientist, and most programmers.