In the screenshot you can see a possible setup. I'm using a node as the input for the materials color. I set the base color-value of the node to (cyan blue), as this seems to produce correct output colors then (eg. a hue of 0.0 or 1.0 is red). 

You can have a look at the file that is being loaded by the game here: $URL$ To substitute parts of the text with variables (eg. transforms to ), I suggest you use the excellent Polygonal Datastructures Library. It contains a AS3 implementation of Sprintf. Instead of having all translations in one file, you could also easily have one single file per language. For the sake of completeness, here are some code listings: 

Maybe your graphics-card isn't supported by the new Flash player? There's some more information about graphics-card compatibility over in this thread in the Adobe forums. 

And there's a possible landscape. The "granularity" of the noise is going to determine how small the details in your world are going to be. So it's probably best to experiment with these values. Also where and with what probabilities your "selecting-lines" are positioned, the result is going to be vastly different. If you have a line near the top of the image with high probability to "select" an island, then you can build some sort of cave-landscape, etc. 

You could create a Bézier curve that matches a sine (read this article for an example). Creating a Bézier curve from a sine, just to feed into seems like a very counter-intuitive way of doing things though. I would skip entirely and update the position of your sprite yourself. You could do so in your update method or implement a yourself. The easiest form of movement would be to increase constantly (or with a decaying value to simulate some sort of drag) and use the sine function to calculate . 

You can use the atan2 function to get the rotation for your sprite. Just plug in the and offsets of your joystick (from the center of the joystick) and you'll get the angle in radians. The rotation will start at the 3 o'clock position, so if your sprite is normally pointing upwards (12 o'clock), you'll have to subtract 90 degree (or radians). 

Just putting all the files into a .zip file isn't a viable solution because most web-applications need a web-server so that they can access resources via HTTP-requests. On some systems you can access files via the URI-scheme, but that's not guaranteed to work everywhere because of security-reasons and will fail for things such as AJAX requests. It might work for a very simple app where you have most resources inline but this really isn't the approach I'd recommend to anybody. There are alternatives though, such as: Build a native application You can package your web-application as a native app using Node-Webkit. You can even use this to add native desktop features (such as local save-games) to your game. This isn't a "package and done" approach though.. you'll probably have to rewrite portions of your application and write different loaders (eg. with a desktop app you'll rather load the files via filesystem, whereas you use HTTP-Requests in a browser/online-game). Use HTML5 features to allow offline access of your app If your primary goal is to allow the player to play your game offline, then you can also use application-cache to allow offline access of your app. This is a feature that works in most modern browsers. The added benefit is that the user doesn't have to download anything and can just use a bookmark to play your game even when offline. For resources that are being loaded asynchronously (AJAX) you'll also have to implement separate loading mechanisms. You could make use of local-storage to save these resources for offline use. 

I don't think icons for games are that much different from any other icon. You want it to be clearly recognizable and well.. iconic. Integrating an icon into the games art-style is basically the same as creating an icon for any existing platform. You'll have to respect the art-style that has been established for that platform (example: have a look at the Windows guidelines or Mac OS X Guidelines). For your game you can come up with your own set of guidelines though. It can be as simple as: Icon must have the shape of a circle and must be provided in two sizes, a big and a small version. I'm afraid there's no guide to the best game icon though. Creating good icons requires a lot of talent, because you'll have to be able to reduce stuff to the max, while still keeping it recognizable and maintain a consistent style. So definitely not something that should be done by a programmer (no offense). Maybe these tutorials are of some help to you. 

I would use world-positions for your entities. That will work just fine as long as the world doesn't become really huge (where world positions become impractical due to precision, so that you'll have to divide the world into chunks). You can easily calculate the current tile from your x and y coordinates. Also having world coordinates makes comparing entities much easier (eg. is entity X in the range of tower Y?). Using the other approach works too, but you'll have to deal with 2 sets of coordinates all the time (tile index(es) and position within said tile). So in conclusion: Both approaches work, but using world coordinates seems much more practical (less coordinates to deal with, fewer calculations necessary). For your convenience, your entities could even have a getter method for their x and y tile index which will calculate the current tile position on the fly. 

You know where the ball will hit the goal, and you know when this will happen. So you could set up some basic variables such as "reaction speed", "movement speed" and/or "jumping force". A goal-keeper with a high reaction- and movement-speed will be able to catch most shots, while a goal-keeper with worse stats won't be able to do so. If you have the ball-travel time , and the player reaction time , then the effective time for the player to react will be . This is the time he has to move from his position to the position where the ball will hit the goal. So if , then the ball can be saved. Of course it should become gradually more difficult to catch a ball that's further away from the keeper. Also you might want to introduce some kind of randomness... so the rule could be: 

I'm sure this has nothing to do with the Tweening library you're using (as indicated in the comments) but rather with how you reference your enemy in the . Depending on how your code is structured, might not be set in that scope or be set to something you're not expecting. I suggest you try this: 

I just opened Tiled and saw that there's support for multiple layers. So you could even build multiple ground-levels inside Tiled. For different height-levels, you probably won't need the multiple layers at all. You could build that just by using special tiles, something like shown here or here. The type of tile would also denote the height. If you have special areas like a ramp that maybe spans across several tiles, you can use the "objects" in Tiled to add such metadata to your map. It's basically the same approach as you would add walls in an isometric game. 

About your code: I think it's funny that you use anonymous functions for event listeners, it's something I don't see that often in ActionScript (it is more common with JavaScript). You should be aware that you can run into some garbage-collection issues if you add event listeners like that (because you're no longer able to remove them later on). As long as your event listeners stay up during the whole execution time of your app, it isn't an issue though. Regarding your questions: 

Then you interpolate the weight given the current round. So with the above definition, enemyA has a weight of at round 5. Given the amount of enemies to spawn per round (you might want to ramp this up for later rounds) you can determine the unit mix by the given weights. As you can see, you can also make enemies appear only in one round (as shown with enemyB). If you design this carefully, you should be able to control the distribution of enemies nicely (and with good variations) without having to hard-code each round.