This code is way more readable. You have the static constructor block, where you register the factory methods according to the keys. And the -Method shrinks to 3 lines, of which one is a purely guarding clause. Edit: modified after Mat's Mug's hint. P.S: Oh, I forgot to mention, that you really never should return . Better a) throw an Exception or b) use a . 

I do not get the reason for having two functions for asc and desc ordering. In principle, if asc is a call to a function , then desc is nothing more than calling the same function with reverse order of parameters . No need for code duplication. As far as I can see, the only difference beside calling your sort function with different parameters is, that you in the asc-Version have lines, which contain and the desc-Version calles . You could refactor this out into a call resp. . Besides that this code has to be broken down into smaller easier to understand sections - I really do not want to get my head around this - you have to avoid code duplication by all means, since it is the N°1 source of errors: if you change a statement in one place, you have to make sure, it is changed in every further place. 

The same as above: Don't throw exceptions in a constructor! Additionally: If you do not allow blank books, why check for blank books in the ? Are you afraid of malicious subclasses of books, which allow blank books? 

Will anybody know? Okay, I admit, at least you know. But think of a freshman, new to your code: it will take (too much) time, to get his head around the code. 4) Shorten your methods. 

First: I have to admit, I do not know a single line Elixir. But on the other hand, I think I get, what the code does. I can not give you advice, how to implement the improvements, but I hope to help you anyway. In the description you have the following definition: single minutes: When it is 1 minute past the hour, YOOO is returned. When it is 2 minutes past the hour, YYOO is returned. When it is 5 minutes past the hour, OOOO is returned. single hours: When it is 1 hour past, ROOO is returned. When it is 2 hours past, RROO is returned. When it is 5 hours past, OOOO is returned. What both have in common is the pattern and the result . That should result in one function, which takes the following parameters: number,Symbol and produces the according output. Your code has: 

Second: Technically, it would have the same effect, to declare an array step by step or in a row. And no: there is no real way to convert your code automatically from the former to the latter. But perhaps, your question goes in another direction. Perhaps you want a solution to easily build combined arrays. For that task I suggest to take a look at underscore's zip function: 

Models have events to which you could subscribe. Most used is the "change" event. So you could bind a function to a general change by just declaring 

Edit: It prevents you from precalculating your values for each if-clause. It's easily extensible: Just add another unit, wherever you want. And for the rest: it does its job in an easy understandable way. No rocket science. 

so you could pass your orderDetails easily from your success handler to the function. No reference to a global object needed - or better: no need for a global object at all. 

Your code has two major flaws: 1) It has bad runtime behaviour: First looking up the special cases, treat them remove them. treat the rest. This are too many iterations over the source material 2) It is unneccessary complex: From (1) Alternatively: It depends on how much effort you want to put in, otherwise, this will do (for your simple case): JAVA 8: 

Of course, the implementation is according to the specification correct. But that doesn't make really sense. I would prefer two alternatives: 

That is a real code smell and should be refactored. How should any mortal soul unterstand, what this code does? Why not using a simple object? 

Even better: you have microtemplating on board, which means: You could define HTML including placeholders within a script-tag 

Besides: Your code looks a little bit messy. It's really hard, to get ones head around what you wrote. If you come again in 3 months i doubt, you understand anything you did above. Your naming of variables is not only poor (,,) but terribly misleading: 

This code needs some refactoring. Here are my suggestions: 1) since you have some kinds of reports, which seem to share some common behaviour, you could use a base class and some classical inheritance. So you have to write the execution logic once for all cases, where no change is needed and override in your subclass, where changes are needed. And your interface would be obsolete. "startDate", "endDate" and "reportType" would be member variables of the class. And at best start/endDate of some date-type and reportType as an enum. 2) it is bad to gereate new objects in objects. That leads to code, that is hard to test. Instead of 

is. Okay: A mapping of integer values to a treemap, which maps one string to another. Let's have a look deeper in the code: 

I do not like the fact of killing objects in the constructor. The job of a constructor is: to initialize the object in a sane state - not killing it for user's faults. There are two ways to prevent this: 1) Use a or a method, which refuse to initialize the Library with 2) Gracefully ignore the attempt to initialize with and initialize with an empty Besides: Throwing a in the constructor leads to ugly code, since you have to wrap the construction in an unnecessary --block. Don't do this - please! 2) Naming You could improve your naming a little bit: * should be renamed to just , since the contains all books. is a tautology. 

If you take a look at both blocks, they are the same, aren't they? But for further improvement, I would suggest working with a where you have usernames as the key and the according List of Names as the result. Second: I would reccomend you to take a look at Google's Guava Library esp. the section about predicates . Third: I am wondering, how you could retrieve any correct item. As far as I can see your names have to be unique to resolve the correct items. The collision rate for (nick-)names is generally high. So it would be better to switch to some ID-mechanism. Fourth: The task is in itself nested; you need to iterate over a list of items and over a list of users. So you couldn't "avoid" a nested loop. Okay: If you let a database do the magic, you didn't loop at all - the database does. But I think, that is not the answer you wanted. 

That are values. Up to this point, one has no idea, what this code is about. If you are dealing with books, you have a book, which consists of pages, which have lines, which have characters. So that would be the way to go. 7) What does the following code do? 

I wouldn't say, mine is better, but I prefer it this way: 1) One entry, one exit 2) One variable changed if needed. 3) Easy to follow. 

Why are you repeating the same task? You could refactor the into a constant: . Everytime you need a separator, you could use , which is more meaningful. 3) You should separate concerns 

The advantage: 1) your parameter shrunk to just one 2) if you name the properties (better than above) anybody else knows, what options were chosen. 

It reads wrong: »Check, whether the book is an empty string!« That doesn't make any sense at all. And honestly: At first, I didn't get it, unless I saw, the . A better way of expressing this would be, adding a method to : 

a) CRUD and ajax There is no clear answer to that: it depends. If you are working with browsers as clients of your interface/API, there are only two of the many implemented, namely and . This is, what we all know from our standard specified under . These were the genuine methods available (rooted in historical decisions, but I see no reason to stick with that; browser developer should change this constraint). In order to use a restish API, which has e.g. also support of , , there is a way to circumvent this constraint. Many frameworks provide parsing a hidden -field where the "rest-method" is defined and map to the according controller. As you can see, it is not always necessary to do it asynchronous or with javascript. So ajax is only one - but a nice one - option to play with. Unless not otherwise restricted (managers, users etc.) I would always go for ajax. b) Is ajax safe It is as safe as you make it. There are possibilities for securing your endpoints. But as I said, I am not quite up to date, what Microsoft offers, there are possibilities for sure. c) Is it fast It is as fast as your hardware (connection, server etc.) allow. There is no difference in terms of performance doing something like a or a . The main difference is, that a traditional is a) not asynchronous and b) you are loosing the current context. d) Form of CRUD requests You form your actions via and : 1) Get a list of all Users: api/users 2) Get information about user 1: api/users/1 3) Get all users, which are from Seattle api/users?location=Seattle 4) Get all male users, which are form Seattle api/users?location=Seatte&gender=male 5) Create a user api/users/ sending a JSON representation of the created user {"name":"Doe", "firstname":"John","city":"Seattle" ...} 6) Update user 1 / api/users/1 sending JSON of the changes {"city":"Miami"} (if he moved to Miami} 7) Delete user 1 api/users/1 If you want to specify the output data from the server, you could set the field in the header e.g. to or . As you see, there is a big advantage in using a RESTish API: you have a set of universal verbs, which each service speaks, which is easy to learn and to adapt. These are the basics of the REST-philosophy. There is more to say, but not in this post ;) 

Of course you could choose another strategy to get a suitable transport. For the sake of the example I chose the strategy to get the first one able to do the job. Since you asked for constructor injection, I implemented it this way, taking a collection of transports. I would prefer setter injection. If there is the need to travel on a (different) ground, the human asks its collection of transports, whether one of it is capable of doing the job - so the human too has not to have any knowledge at all what is good for what job. If you ever come up with a car, you add it to your factory and ask your factory for that. And the car knows best, for what grounds it is made for. 

In a more general case, I would implement a Push Down Automaton using a Stack and open parentheses on the stack and performing a for closing ones - Assuring, that the stack isn't empty. So every occuring closing parentheses has to match the last pushed open one. For simple cases, a counter is sufficient enough. 

Why only compare the title? There are at least two books calledFrench Kitchen, but they are not the same, since the authors differ. 

Looping over your array and sorting out, which ones you don't like. You could play with this Fiddle 2) The "functional" approach 

Sorry, the specification makes me cry. How does this make sense in any way? Imagine someone going to a library, with a wizards hat on and a big staff: »Sort you, I, as your master, command you!«. 

So, I would prefer this approach as a first shot. And if you have to later add more complexity: refactor it! But perhaps YAGNI comes, and you have never to revisit this "ugly" code. There is no overcomplex Abstraction or Overengineering invested. Of course, if you are dealing with instead of you have to take care, that they are comparable to each other. 

So there is nerver an inconsistent object created and no objects were harmed ;) Another solution would be to allow the creation of an empty commentary, but check later, if comentari.getTexto() is empty and handle that fact later. So the try/catch looks like: 

For a beginner you have a really good starting point; better than most I've seen. In principle you are following sort of revealing module pattern; not quite right, but it points in the right direction. Some comments on your code: 1) if you are the only developer responsible for your JS -or as in my case: make up an example- you are free to name your variables. But if you don't, please choose meaningful names (e.g. , `netflixPlayer etc) 2) You've chosen to encapsulate functionality in a single object. That is good! But I would prefer to make the object's interna less accessible: There is the IIFE-Pattern, which does exactly that. As you know, functions have their own scope. The trick is to immediatey invoke a function (hence the name) - notice the second parens after the definition of the anonymous function. If your function returns an object (like your code did), you have the exact same functionality as in your code above, but made the interna not accessible from extern; you only reveal a well defined API (hence the name . As with ordinary functions, you are able to pass parameters (which could in turn be other objects). This allows for a really modular code: 

Done. Even if it is not the fastest solution, it should not be too bad for only 5k objects. It is simple, readable and not errorprone. 

In order to understand single line of code, I have to go through lines of commenting junk, 1 line boilerplate Java and at least a closing bracket. This is useless. Anybody with little experience knows what this one line does, so why spend time on commenting it? Without the comments it is much better to read. 

This is nothing more, than: returning a list of the digits in descending order. A Java8 Solution would be: 

Define your omitting filter and apply it to your array. For read the according MDN-article. 3) Doing it with a RegEx: 

I'm learning go. I wrote a simple logparser for SLF4J in Python some time ago and tried to port it to go as an exercise. The algorithm is identical, but the go-solution isn't quite as fast (the Python solution is about 1.5 times faster for large enough logfiles). Is there any way to get more speed out of it? It do not care, which one is the fastest, but I wanted to know if I could do better with go. Any inspiration is welcome. A typical logline looks like 

So I could use directly a , read a line, and if necessary parse a line to an Integer. What is the advantage of a ? I could not think of one. In this case, I think, the whole idea is overengineered. It seems abstraction for the abstraction's sake. Besides: Reading the Documentation at Oracle, it says »StringTokenizer is a legacy class that is retained for compatibility reasons although its use is discouraged in new code. It is recommended that anyone seeking this functionality use the split method of String or the java.util.regex package instead.« 

But while skimming through the code, two questions come to my mind: 1) Why is this called a - besides the case, Chris mentioned, what makes it really fast? I am seeing the usage of a . Hopefully it is fast. I see nothing special in your code, that makes it fast. 2) I do not see a single usecase for this. At best, you have some kind of which describes your Inputfile. Why waste time and put a wrapper around concrete data. 

I think this is a hard one. First I tend towards Barry's point of view: You are really doing "two things" in your class. So, if you take the dictum of "reasons" to change to the letter, you are violating the . But on the other hand: I think breaking this up into a fibonacci-series-producing class and another summing-class is nonsensical. My personal interpretation of the is: "dealing with one topic". And when objects tend to grow too much, I have to decide, which functions are off-topic and need to be refactored in some way. If you want: I am advocating a more pragmatically - perhaps not really orthodox position. In your case that means, if I say "dealing with fibonacci numbers" is our topic and the resulting class results in two "subtopics" generating and summing that is a possible code smell, but more in the future than now. Don't forget: Those principles weren't developed for their own sake, they were developed with some purposes. And one of those purposes is maintainability. And as far as you code goes, I tend to say, it is still maintainable. One last word: If you really want to improve your code - get rid of the class at all. I see no reason, why one should write for such a job a class at all - except, perhaps, you are on the one hand obsessed with classes or on the other hand, for educational purposes. Two simple functions were sufficient. Python is a decent objectoriented language though, but sometimes it is overhead to write a class for everything. Python is not Java, where it is necessary to write explicit classes for everything. Python is not forcing you to do that. First take care of writing clean code. Later take care of your overall design. Start with naming. Barry pointed out, that you should name your functions more pythonic. Another point worth mentioning is your function naming in general. Function names should reveal their intention. So what is the intention of ? Reading this, withouht investigating your code, my answer is: I don't have any clue. I know there are fibonacci numbers involved and somehow there is a . How it is claculated: the heck, I do not know. On the other hand: clearly says, what it does: it sums up the fibonacci evens up to a paramter given.