A fragment shader is executed for each fragment once.One fragment is one pixel. so it depends on what are you rendering: For example if it takes up the whole screen( like a post-process effect ) it is executed as many times as many pixels are there on your screen.( Resolution.x * Resolution.y ). So basically it is called once for each pixel. If you are interested for more exact numbers, you could use shader atomics to test specific cases. Here are some links about the usage of shader atomic counters. They are basically counters that are consistent across shaders, their usage is more performance expensive tough. link1, link2 

Two things others didn't mention: The ripples in the water surface are made by Bump-mapping, where you use a texture to add fake depth to your objects(a.k.a. Normal mapping). You could even animate this with noise, so you don't need a texture, just GLSL noise generation.(Quite simple and awesome effect) The very subtle "fog" around the planet might be a camera-facing billboard with a very low alpha and some foggy texture. And the annoying bands that it creates are probably because they didn't use HDR. 

Efficiency and ease of use are my main priorities.(I dont care if the implementation is complex) TL;DR: How to efficiently store arbitrary data that is defined by lua scripts and stored on the c++ side? 

This forces fully opaque alpha, and keeps the color the same. This might not be enough, based on the setting of , as it might blend based on the background alpha or something else. See the reference for details. Another problem is that you are rendering your terrain using blending. Generally it is better to turn blending off when it is not needed, this might improve performance as well. You can do this by , and when you need it again turn it on by The resulting image vary on different graphics cards because of the different driver implementations. The default value of might be different, hence the difference in the pictures. 

For a very simple effect just load an alpha image with a white circle in the center and otherwise all black into an and render it centered to your character. Anything inside the white circle will stay visible while the rest will become black. You could also make the texture animated creating a "candlelight" effect. You could also scale the texture for stronger/weaker lighting. You can create a smooth transition with making the alpha in the image be a radial gradient. You don't even have to make it an image file, it could be generated on init into a then converted to an . just make sure you use the alpha value correctly. 

In the end the last hitpoint's coordinates give where you paddle should be. This should be quite straightforward if you have a physics engine, also reliable and flexible(until you start to add moving objects, then you'll probably need a faster simulation as you said) 

Please note that you might want to use your own vec2 class directly, and might need to supply your own hash function for to be able to use it as key. Also if you want 3D infinity, then you should use a vec3 not a vec2 obviously, and supply a hash function for that. (A hash function takes a coordinate and creates an unique ID from it.) 

Aside from the other answers, you could use a Perlin noise with a round falloff, if you tweak the settings a little, you could easily create some nice varying shapes. If you want your code to be fast, you could just use a noise-generation library like libnoise(Assuming you are using c++), which is a noise-generation library, that makes similar tasks very simple, as it provides you with a node-based approach on noise-based procedural generation. It has bindings to other languages too. 

If you were using assimp's implementation (AssimpViewer source) as reference, then you probably too missed the fact that Assimp's and glm use reverse matrix multiplication order. To clarify, we are talking about matrix-matrix multiplication, and the order is reverse relative to each other And we know that matrix multiplication is not commutative. So the line 

Apart from these errors, your code looks like a mess. You should make the animation routine as part of the model you are animating. Maybe with a function like this where time is the animation time you want to load. Also a map lookup at each access to an object will be a great performance hit later, even with unordered_map, so if you have long-term plans, I suggest you look for a better solution. 

Tough many processes can't be parallelized well, and the performance increase is less than 50% when adding a second core, and gets less and less effective with more cores. A thread is a separate thing than a core. A core is a physical entity, while a thread is a path of execution. Tough if you have an threaded program, you can't use more than cores to do that. Also please note that this doesn't take into account hyperthreading(mainly found in Intel CPUs) where one physical core runs 2 threads, effectively acting as 2 separate cores. As for what performance is needed for a specific algorithm, it depends on waaay too many factors to be determined. Just because a hardware has a high FLOP value, it doesn't mean it will be able to use it, if its bottlenecked by Memory bandwidth, or the CPU. Also the algorithm may be optimized poorly or well, also it may be optimized specifically for this hardware or another, and again the hardware may be optimized for this process or another, and the process may be parallelizeable or not(in which case you won't benefit from additional cores) so as you can see its not a question easily answered. 

The way you are rendering voxels is extremely ineffective. For each cube you have to do calculations, set uniforms, and worst of all bind textures(This is usually a very expensive operation) Typically effective voxel rendering involves multiple techniques to speed up rendering: 

You could create breakout and make the camera follow the ball for larger levels (only vertically) and maybe the pad horizontally making for a larger play area. The idea of moving the camera is probably necessary for anything on such a small screen. 

The question is, what pattern you want to achieve, and how to randomize the given pattern. You could place fix walls in a grid shape, then fill the rest with walls, and when you place the players, clear enough space for them to start. Then you could start randomizing things: 

First thing I see is that you shouldn't read the quaternion in reverse order. Also you shouldn't use , use instead. And here is how I construct the bone transform: 

Also, if you are writing your game's code, or if the engine supports it, consider loading the image directly to the game and using it there. If there is a specific function like that, it usually should be much faster than simple model files, due to 2 reasons: 

You really shouldn't use pixel coordinates for game logic. Just use coordinates that are independent of screen size, and make rendering code account for different screen sizes, this way you get much more flexible and maintainable code. So for example assume you are using 1 meter as one unit. Your screen is 2 meters high and 1 meter wide(on every device). So the resulting pixel position can be calculated like: 

Another solution, tough much more memory demanding is to simply use matrices. A 4x4 matrix can hold both a position and an orientation, its directly used by the rendering system(usually) so you can just simply read its last row to get position you want. I think the memory demand is still manageable because even with 10000 objects you use only 10000 * 16 * 4 = 625 KB of memory. 

Note: While FPS can be safely used to compare values, for measuring differences(for optimizations) you should measure frame times. There are programs that help you tell whether your application is cpu or gpu limited. One of them is AMD GPU PerfStudio, which as the name suggests is vendor-specific. I am sure NVidia has a similar program too, but I don't know its name. EDIT: I just remembered a basic GPU utilization meter is usually included in overclocking tools and and in the driver settings. Also you should make sure that the cards are doing the same thing, there are often vendor-specific optimizations or effects that are tuned in relation to the GPU you have, these are usually set in the GPUs control panel. And make sure that the resolutions are the same too as laptops usually have lower resolution and this may strongly affect performance. The true performance of a high-end GPU may only be visible on higher resolutions. Also bear in mind that the additional speed of a more advanced GPU may only kick in when you are doing more stuff, using more memory, and using more advanced features, which you said you aren't. GPU benchmarks are usually built to attempt to use all features and evenly distribute the work between all GPU blocks. We have no way to know if the benchmarks points scale linearly with performance. The benchmarks may also be tuned to use tessellation and other new features which only recently been optimized in hardware, which will bring new-gen GPUs up-front, while in a simpler setting their power may be almost the same. 

I don't exactly understand how would ray-tracing change anything, here is how it usually goes: You can have a texture for any parameter you like, but the most common is a diffuse(color) map, so you just sample this based on the texture coordinates and use the texture in place of the single-color diffuse. You could also combine the texture with an arbitrary color, tinting the given element. Other common textures include normal maps, reflection maps, which replace their respective counterparts. Normal maps can be a bit tricky, because they specify the rotation relative to the surface, so you need to construct a Tangent Bitangent Normal matrix, which will do the transformation for you. 

GreenHeart games was also hit by piracy quite hard, even tough they managed to punch back in a very unique manner. They uploaded the game themselves to the torrent scene, but it was a modified version. Their game, GameDev tycoon, was modified for this release, so that your virtual game development company would go bankrupt sooner or later because of piracy. They even had pirates posting at their forums about "piracy ruining them". Original article In this article you can also see statistics of genuine vs cracked versions. While they didn't go bankrupt, I read another article, that I can't find, that stated the game didn't bring any profit, this also had a negative psychological effect on game developers not wanting to continue, in the end they did, and since it seems their game has taken off.