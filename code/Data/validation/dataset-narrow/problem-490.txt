Also I add my usual rant about getters/setters breaking encapsulation by exposing internal implementation details. Code Review Make sure this is noted as a non-owning pointer. 

One of those branches must be true (unless you were comparing floats). So the code will never go past these set of tests. So there are some massive bugs in the function . You definitely need to fix these. I am not going to fix them because I think it would do you good to try and work out what the correct solution is. But as it stands this would fail any unit tests you should have written. This is C code. 

An iterator has a couple of properties. It can be incremented/decremented (you have that covered). But an iterator can be dereferenced with to get the value. It looks very much like a pointer. This is an index (nothing wrong with that. indexing into text is just fine just use the correct terminology please). Declare variables close to the point of usage. 

Your quick sort seems to work but is slightly non traditional in a couple of features. The pivot point . Values that are equal seem to go into both sub buckets. Traditionally they would go into a specific bucket. You always use the first element as the pivot point. This case leads to worst case behavior of quicksort when the list is already sorted. Either choose a random element or the one in the middle of the partition. Currently your code works with pointers to integers. But really you are using pointers as iterators. So you should templatize it so the inputs are not pointers but are generic iterators this then allows you to use the algorithm on any container type (with the side affect that it works with any type that implements the <= operator. 

This is usually an anti-pattern. What happens if the readLine() fails? You should check for that. The normal pattern would be: 

An example of sending extra bytes with ping (I put your script in the file test.php on myhost (not real name). $URL$ Generates: 

Protected provides no protection (it does but it is an illusion that is easily pierced). Prefer to use private (especially in this case). By using public/protected you are including all these members in the public interface (this is an OO concept not a C++ concept) of the object. Anything in the public interface must be maintained in the future thus tightly binding you to this implementation. 

You are constructing a temporary object that is returned. Accessing beyond the end is an error you should treat it as such. Now you can treat this in several ways. The easiest way is to to throw an exception. This is the way I would recomend for you at the moment: 

I would also note that you missed the move operators. Move semantics can improve the performance a bit as they avoid copying in a couple of situations). 

Using a test to decide which of true or false to return is a waste. Just return the result of the test: 

Prefer to std::endl; The only difference is that performs an extra flush. Forcing a manual flush is usually never the correct solution as the libraries will do this for you when required. Main and return The function is special. If the compiler detects there is no return it will plant one for you. 

Use std::unique_ptr to encapsulate the pointer object so that it does correct memory management. If you are doing things correctly the resulting code optimizes to a no-op and if you don't do things correctly it saves your ass. In fact I would just throw away your string classes and use std::string. The copy construction from a return is nearly always elided by NRVO and thus is much more efficient than you seem to think. Same Again 

But why have the loop. Why not generate a random one smaller than the max than add one. Also why are you creating a new random number generator on each iteration . You just create than once (in the entire life cycle of the program) then use the instance every time. 

Yes BUT. The std::array itself is not moveable. But it is still optized for move semantics when its content type is moveable. So it will move each of its internal elements rather than copy them. But your function limits the type of to which is only defined for built-in integers and floats. Moving integers and floats is the same as copying them. So you get no real benefit. But lets take this a step further. If you remove the so it can be used by any type that supports the etc.. then you have a usability issue. When you do a multiplication like this you destroy the original array (Its content has been moved so there is no way to know what the elements are or if they are usable. About the only thing you can do is reset them to a specific state). 

CURL will abort the transfer if you do not return . So you need to take care to make sure that you actually write all the data provided. Also this is the action of the default so there is no need to write your own version. You don't check if the File pointer is NULL 

I did not review the but most comments that apply to the also apply to the server socket. Self Plug / Further reading I started writing a series of blogs about Socket programming; Still not complete. But as part of that series you will find a simple socket wrapper class. 

Asserts are the worst type of control and they are really only good for debugging; not for error handling. Remember compiles to the when in release mode so there is no checks. 

I am not sure I agree with some of the decisions about making methods public. I think very few objects should get to interact with these systems sometimes friendship can help in limitting access. (Now friendship increases coupling with the friend, but if it decreases the external public interface it will decrease coupling with objects that have no rights to modify the object). Anyway I would expect to see a justification as to why methods are public. If anybody should be able to call them fine. If nobody but another object should call them you need to make a better case. Design Looking at it from a design perspective. Not sure I see the distinction between an elevator/liftbox In big buildings some lifts do not go to all floors. One of the things about elevators is that they usually come in banks and do not operate independently. For really big building multiple banks will be combined but will work independently (unless there is some major emergency). How are you going to organize your code so that multiple lifts(sorry elevators) can work together. Also I want to see how you can decouple the elevator object from bank control logic. (ie I don't expect to see all the control logic in the bank, I would like to see control logic in the elevator but decision logic in bank). But if their are multiple banks to coordinate I want the logic for a higher level control. The real meat of this problem is how to de-couple the objects from each other. What patterns do you think are being used here. Updated Code: Not sure you understand a bank of elevators work (based on the code). 

Types have to be known at compile time. Unfortunately to be flexable you need to look up arbitory types at runtime for a DB. So either you need to use some form of template-meta programming or you can use a variant type. I would go for something like boost Any object or boost variant this will allow you to return arbitrary types. I don't think you want to return the result from the DB after creating the Query. You want to return a query object that will allow you to bind things and execute the query at a latter stage. This is because in most DB systems creating the query is relatively expensive. And when you do execute the query you want to use the concept of the cursor (iterator) to move over the result set rather than generating the full result in one go (as this could potentially be huge). 

I see nothing wrong with the concept. Code looks reasonable to me. Iterator You implementation of does not meet the requirements for a standard iterator so you may have issues using it with some of the standard algorithms. See: $URL$ You are missing some standard types in the iterator: 

It is not only a waste of time, but probably much less efficient than std::list (it uses pool allocations to prevent repeated requests to the runtime memory management system). Also did you really want a review on that? 

Ring Buffer has no resource management. So remove its destructor. It does nothing useful anyway. Don't use inline were not needed 

If returns then we add 1 to it and now it is no longer and your next test will always work. Even if it is not supposed too. Are you sure the second test id correct? 

OK. Good start. Rule of three/Five Definition But you have not considered the rule of three/five. When you define a class (or struct) there are three (potentially 5 in C++11) member functions that the compiler will generate for you. These work well under normal situations but when you start working with RAW pointers and memory management the semantics do not mash well (know as the shallow copy problem). The automatically generated methods are: 

Remember you are trying to write code that is readable. Putting this on one line makes it less readable in general. Const correctness. 

When you increment the reverse iterator it should head in the reverse direction to the normal iterator (so it needs some wrapper to do that). Luckily there is such a wrapper in the standard library At first glance a lot of your manual movement/copying of stuff around are covered by standard algorithms. Though the standard algorithms don't use run time checks they do it at compile time so would be much more efficient to use the standard algorithms. 

The main comment I have is that I think that C# is the wrong language to pick for tokenizing a language. Its perfectly good for the main bulk of the lisp interpretor but one of the major skills of software engineer is picking the correct language for the job. Not just of ease of writing but ease of maintainability and future work. Now I personally like LEX but there are other lexical generators out there. But I just want to show you how simple the LEX file is. Even if you don't know the exact syntax of LEX it is simple enough that most people will immediately be able to read (assuming a CS background) and even the most complex modification can be done within an hour given an appropriate book. OK I am not 100% sure of the exact rules for tokenizing Lisp.