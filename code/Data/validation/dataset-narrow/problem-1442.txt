To make sure you know how Manhattan Distance works Manhattan distance is the sum of the total difference along each axis. In regular geometry you use Pythagoras' theorem: 

Your bounding box isn't bigger. It's exactly the right size to encompass those meshes, except it's offset by a certain amount along two axes. In fact, it's drawing from the exact centre of that cylinder. This very unlikely to be a coincidence, and in fact it's probably telling you exactly what the problem is. It's not necessarily the bounding box code that's doing something wrong. The meshes or bounding box could be using the wrong coordinates, or either one could be drawn incorrectly. You made no mention of walking through what your code does in the debugger. This will tell you where the problem is. 

Code quality first and foremost That's a lot of duplicated code you've got going on there. If you've got duplicated code, you need to do it differently - duplicated code is dangerous (you'll change one side but forget to change the other and get logic errors). 

Flow is one part of it, as notabene mentioned. However behind the effects is a whole host of psychological effects that combine to make games fun or addictive. MMORPGs, especially WoW, thrive off of such tools, to make themselves addictive at the very least. Behavioural Game Design is a good, short introduction to the psychological toolset that tackles some key concepts. Psychology Is Fun is a good follow-up, as it goes into more depth, especially on generating a sense of Flow. If you're after more, it's no understatement that the professionals who blog for Gamasutra seem to have turned it into a treasure trove for this sort of thing. They're how I found out about these concepts myself. Googling "psychology site:gamasutra.com" turns up results such as: 

Lots of wasted space in the array, right? Only a fraction of coordinates are used. At this point, you're only wasting, maybe, a few kilobytes of data on unused coordinates. At this scale you shouldn't even be remotely concerned. If, however, the space wastage somehow becomes an issue, you can potentially trim a tremendous amount of fat by splitting your world into regions: 

If you suck at maths you don't want to be starting at the game development level because game maths generally uses some advanced concepts, e.g. matrices and some calculus. Other things like vectors, trigonometry (or anything to do with angles) aren't so complex but they aren't beginner-level either. Try Khan Academy. Learn the basics first, then worry about learning stuff specific to game development. Their courses cover most of the American high school curriculum, and there is a significant amount of maths education available on the site. They're also free-as-in-Wikipedia because the guy who runs the site can afford to do that. Once you've learned the basics you can also learn stuff specific to game development from Khan Academy, because they teach Linear Algebra and Geometry and other game development topics too. So: No. Don't use Game Institute. First because you suck at maths, second because even if you didn't you can learn the maths for free. 

Let's say you need 125 mass this step to produce at full capacity, but only have 100 mass this step. This equation provides you with a production speed of 0.8 (the decimal representation of 80%). When you tell your factories to actually perform their building, you hand them this value to tell them what speed they're building at: and now your production is slowed down across the board. Alternatives You could also begin shutting down factories temporarily until production capacity frees up, and it could be very interesting to see that happening to factories farther away from generators when at extremely low capacity. Multiple resources? Up to you how you handle this; there are a lot of options. The simplest one is probably to calculate a production capacity for each resource and then pick the lowest one, such that your weakest resource becomes a bottleneck for all the rest. 

Yes, you can just use Vector3's where the z-value is 0. In geometry, any 2D point also exists in the 3rd dimension. In a 2D game, everything could be represented with Vector3s where the z-values are all identical. Often in a 2D game, you use the Z value as the depth, to draw a tree in the background (low Z value) or the main character in the foreground (higher Z value). 

Where is a completely different variable to . I'm not even sure why you're setting it, but if is false, you're constantly setting to false, either in the very frame following you pressing Q, or before that frame is even over. 

When the script gets executed, it creates its own instance of a PyComponent. Of course you'll need to reference the IronPython library and the Microsoft Dynamic runtime. I've found I only need these four DLLs from the root folder of the IronPython download: 

XNA only gives you just enough to build your own input classes - and you should do so considering the utility they offer. I would recommend the mouse input class described in this blog post (source code). It detects a button being pressed, held or released, and lets you get that information either via polling or events. On a related note, the same blog post also provides keyboard and gamepad input device classes. 

What you need to do is actually start writing your game! You don't need more resources. It's time to start producing - learn by getting your hands dirty. Write the lightest-weight engine you can. If you follow this tutorial series until #9 (and since it's written for XNA 2 or 3, translate it in a couple of places to XNA 4.0 using this cheat sheet) you'll have a fully working component framework that gets out of your way. What I just described took me a few hours a day for a week and a half on my own. Then you can get on with your game. You'll have an engine that takes care of rendering and updating for you so long as you provide an update/draw method on each component you write, so just focus on making your game's content. As you require, go back and hack the engine to bits and make it your own. Among the improvements, I'd recommend replacing its JigLibX physics with Farseer Physics since JigLibX is a dead project. Reading stuff and writing your game design doc are both helpful but what you need to know is if your game is fun and if it works and a hacky prototype built in a week with a minimal feature-set and rectangles for graphics will tell you more about that than even the nicest game design doc. Ever played Super Meat boy? It never even had a design doc! To quote the Super Meat Boy postmortem from Gamasutra: 

Both FF6 and RPG maker do exactly that. FF6 however picked more states and more animation than RPG maker did, probably because they were actually going to make some money for it. Every other game has done the same thing, choosing exactly the states that suit them and exactly the frames of animation they want. They're all just companies fulfilling their unique requirements using the same technique: sprite sheets. It's not like there's a third party offering an engine which features certain states and offers Y frames of animation for each. Each developer just developed their own system. So here's your generic solution: Start wondering about your requirements! What states do you want? How do you want each of them animated? Then use the same basic technique as anyone else: draw them, arrange them in regions and animate them. 

So 3 ahead is the minimum, and it's clear you can barely calculate farther than that before you reach insane wait times between turns, thanks to the exponential nature of the calculations. You need to optimise. Alpha-beta pruning works to reduce the amount of possible paths you evaluate in a min-max tree. It cuts out paths that lose in the long term and identifies paths where wins are possible so you don't waste time on fruitless searches. Even with AB pruning your AI will never be able to evaluate all possible games in a timely manner for any significant number of moves. You need to set it a time limit - say 5-10 seconds, maybe more in situations where the computer is really having trouble finding a good move. Once the time limit is up (if not sooner) your computer must stop and make the most appropriate choice based on what it worked out. Note that the most appropriate choice isn't necessarily the best one (for its winning), since sometimes you might want your AI to stuff up a bit. Note also that in its limited available time, your computer may not actually find an optimum move, or even necessarily a very good one. 

Warning: I have never tried this myself, but I fail to see how a series of joined rectangles can fail when the video you posted displays practically the same thing in disguise. Edit: I just saw PaulZ and I realised the same thing. Go read his comment on the question as well. 

Build a game and not an engine. You're getting caught up in what you inevitably get caught up in when you're making an engine: you have no specific requirements and you have no idea what will be most useful or pleasant, or how it will impact using your engine or your game's performance. You also have no way to know. Build a game, and the game will tell you what matters, it will tell you what your game engine requires and you will be able to see the performance impacts of what you're doing. You'll actually have a game to play for it, too. 

Neither one is legally acceptable. In short: a person's name and likeness is their own property and they have a right to decide how it's used, and the same goes for a sport team's emblem (but under separate laws). Using someone's name and likeness without permission Wikipedia has this to say: 

The video for Overgrowth Alpha 132 shows how they implemented ledge climbing: $URL$ Their method should work in any engine, even 2D engines where you'd use a rectangle and circle instead of a cylinder and sphere. 

Emphasis added. There are some exceptional circumstances (which you are almost certainly not covered by) and if you want to go into those I recommend you research the topic further yourself, or consult an actual lawyer. Usage of a sports emblem without permission Sports emblems are a trademark of the sporting body and the emblem is their intellectual property, covered by copyright. For instance, the Blazers logo usage page expresses their position on the matter (emphasis added): 

Their ledge detection involves two parts: Wall detection (using the sphere) The game checks if the player's currently colliding with a wall. If there's a wall, there might be ledges the player can grab onto. The second part takes over to analyse the ledges. Ledge detection (using the cylinder) If the player's contacting a wall, a cylinder is swept downwards from a certain distance above the player's position until it touches a ledge. This can determine three things: 

The problem you're facing is that your AI never stops to make an intelligent decision about where it should place its next bomb, which leaves it just dropping bombs whenever it can and then working out "shit, shit, what do I do now!?" Pausing to think Right now, your AI just wanders to nowhere in particular. Sometimes, however, it should actually be moving to a target. For instance, if it sees a powerup and thinks it can reach it before the player, perhaps it ought to find a safe path to that tile and move there, keeping an eye out for bombs and avoiding them along the way. The same moving-to-target behaviour can be used when it thinks about where to place its next bomb. When your AI can place a bomb, instead of just doing so immediately, it should briefly use a search algorithm to choose from the available bomb placement spots based on criteria such as: 

Use World Coordinates (Or as you put it, float everything.) World coordinates are what you generally work with, and there's plenty of reasons for that. They're the most simple and intuitive way of representing your position in the world, and the only way of really comparing the positions of any two entities in the same world. You gain nothing but work by having him be tracked within individual blocks. Well, one advantage is you get to determine which block he's in, but you can already calculate that with world coordinates. 

When you place content in your XNA project, in the Properties window you can pick the Build Action as well as how the file should be handled (Content Importer and Content Processor). In your case, I expect those three properties were changed, but the defaults clearly work for you. The default for the Build Action is Compile, and the defaults for the Content Importer and Processor depend on the file format. 

Big text: Don't do this. Stat systems, like the one D&D has, are designed to be a specialisation system: pick a couple of stats out of those available, and excel at them. Strength was created for physical characters to specialise in, and to appeal to only them. Intelligence, on the other hand, was created pretty specifically for intelligent characters and casters to specialise in. It is problematic to use a system designed for specialisation, offer a caster stat that all casters would rightly want to specialise in, and then also try to make it a generalised system where all other stats benefit them. It's problematic because it's going against what this sort of specialisation system was made for: specialising. There is no reason to make Strength beneficial to Wizards as well. They don't need to find it useful. You do not need to make it useful to them. Instead of putting useful effects on Strength to make it appealing where it would otherwise not be, place those useful effects on a stat that is already helpful to a caster, and let them specialise. Learn from where this goes wrong: D&D's Monk, and M.A.D. Editions of D&D from the start up to and including 3.5e included a Monk class which suffered from a huge problem: every single stat, for them, was highly desirable in one way or another. Every stat influenced a significant part of things they would be doing regularly. This is called M.A.D.: Multiple Attribute Dependency. M.A.D. is very bad news for every class that suffers from it, because of one reason: it was impossible to be good at all of those attributes. The Monk had to spread its resources thin and be mediocre or bad at all of them, just to not be absolutely terrible at any of them - or else let a huge part of their class suffer. In a game where virtually every other class could happily specialise, put everything into 2-3 stats, and become extremely good at particular things, the Monk suffered. In 4e, they finally fixed the Monk: by making him rely on only 2-3 stats, like every other class. Don't make your Wizards spread their resources thin. If Strength is a crap attribute, nobody will invest in it. If it's half-decent, everyone will wish you'd put its positive features on something they actually wanted, like Constitution or an equivalent.