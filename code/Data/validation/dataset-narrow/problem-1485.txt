It doesn't take a rocket scientist to figure out that poor indentation is the one and only reason that this code is so difficult to read and understand. In case they miss it, I also reinforce this point verbally every time I give examples like this. Fourth, the group work that I give requires them to have to provide code to each other, and make sense of what their peers have done. Over time, they start enforcing norms on each other. 1 Vertical space, you ask? Two reasons: first, because vertical space is used to separate ideas, like paragraphs, and second, because the very mention of this problem in their code shocks students immediately into thinking about how everything that they write helps to serve clarity. 

I would encourage a different way of thinking about this. For context, I teach in a place where I instruct many different courses at the same time (currently 7), but I have the benefit of being able to teach the same course for multiple years. This situation has created a need to prepare my courses so thoroughly that, in future years, large chunks of material can simply be run with very little prep time. I sometimes call this hyper-development. It is absolutely worth my while to spend 20 hours to develop 2 hours of class time if I end up with materials strong enough that I can use them for many years. Of course, I do see things from time to time that I wish to change, but these are often relatively small adjustments. This situation has forced me to think about lesson prep somewhat differently than I used to, as I no longer feel like I am preparing for the next day's lesson. Instead, I feel like I am preparing a lesson for multiple generations of students for I have not even met yet. And if something doesn't work well, I can adjust it immediately after the lesson so that it goes better the next time. I don't assume that I will have prep time next year to change the lesson; I just do it right away, while it is still fresh in my mind. This is a form of capital investment that has served me very well. If I am busy, then my worst case scenario is that I get to run a lesson that worked well last year, and was already improved at that time. If I have some extra time on my hands, I can further tinker to my heart's delight. This has resulted in pretty steady improvement to my instruction. Just as we need to encourage a growth mindset in our students, we should embrace the same in ourselves. When you describe a pace of adaptation so fast that you can see the results of the change across the span of a single week, that's a remarkable thing, and it should be celebrated. Remember that the work you do fixing his lessons improves not only the educational outcomes for your current students, but for students you'll have in the future as well. The only way to reduce the inequality that you describe is to stop improving your lessons, which only serves to hurt the later students and our educational mission. This is the natural result of you learning to teach a lesson better. I do have one small practical tip: give your improved worksheets to the early students during the following week so that they also receive the benefits of this labor, and point out to the early sections that, even though they aren't getting the cleanest version at the start, in some ways they are still getting the better end of the deal, because the later versions are really tailored to their needs. Things that work well for them tend to stick around, and things that don't get changed. 

I agree very much with ctrl-alt-delor that the level of "total novice" might be rather early to introduce larger-scale meta-design techniques into coursework. The work being done at that level simply does not require (at a cognitive level) such deep planning to execute properly. Since the need is not self-apparent, efforts to bring it into their work will typically feel like extra, needless work. If you would like to help them understand how to use plans (and how to utilize good, structural thinking), here is a way you might go about it. Provide a diagram in class, and talk through it as a group. Next, ask the students to work with a buddy to make a series of modifications for different purposes. At the end of this exercise, they will have several different diagrams. Ask them to choose one of their diagrams, and imagine that some other coder will have provided some source code that attempts to follow their specification. However, it is their job to verify that the code that they receive truly will work as specified. They should now work with their buddy to design the trickiest test cases that they can think of! You can encourage this by enthusiastically placing great examples of test cases on the board as students come up with them. "Look, how wonderful! Testing for the empty string!" Or "Using a negative number is a great way to try to trip things up! Great thinking!" Finally, whichever project they chose for their test code, they should actually program as a lab. (This could be done as paired programming or as solo work.) When they submit their lab, they will provide a UML diagram, thoughtful test cases, and their coded solution. Congratulations! You've now integrated student choice, prior design, unit-testing (well, the core of it anyway), pair programming, and created an assignment that is harder to cheat on than the standard mainstays (like sorting algorithms) in a way that feels natural and un-forced. 

I integrate many, many simple TMs into both my lecture and as homework. I also force them to use descriptors such as $\vdash$ and $\vdash^*$ on their machines. I've found that it takes a long time for students to get used to basic operations. They have no problem converting a given TM to its tuple members ($\delta$, $\Gamma$, $\Sigma$, etc.), but have surprising trouble seeing the performance implications of transitions on machines that I provide to them. With practice, they get much better at this, but it takes (in my experience) a surprising amount of practice, both in encoding and decoding simple Turing Machines. Some particular traps for my students have been: 

I love thesecretmaster's answer of showing the mapping between the two loops (and I will almost certainly do that in the future). However, as an AP Computer Science A teacher, I teach in Java, and there is a subtle trap in saying that 

Is there something about the course structure that you should change? (It's okay to change aspects of an entire course for just one student. If one is falling apart due to some course issue, it is probably bothering other students as well, even if they cope with it better.) Is there some way that you can help the student by checking in frequently? (Hello, repeating calendar events!) Is the issue entirely unrelated to the course? (Depending on the issue, I would implore my colleagues to be open-minded about extensions, or even flatly modified requirements. Sometimes people encounter difficult times in their life, and a little flexibility from you can make all the difference in the world to the student.) 

If self-learning is a goal, you don't need to necessarily choose between resources at all. I had to self-teach a tremendous amount of material this year, and to do so, I roughly borrowed the methodology from Barry Farber's incredible How To Learn Any Language. The basic idea is to grab multiple (quality) resources of different kinds, and begin to work through all of them. Do a little bit of each one every day, and make all of these activities as active as possible. (For instance, create flashcards of concepts you want to review. While reading physical books, don't be afraid to underline things you don't understand and revisit older underlines.) Every content creator attempts to get at the material in a way that they feel emphasizes what is most important. This means that you end up learning multiple central conceits, and you develop a deep and capable understanding relatively quickly. If you find yourself getting stuck on one source, do your underlining, and move on to the next one. The next day, you can revisit the first source with the new understandings that you have gained from the other resources, and thereby continue to progress. 

There are two audiences for code, machines and people. We need to create code that is good for both. Compiler errors are better than runtime errors. (This is hard for kids to understand at first, but I return to this idea repeatedly until it is thoroughly drilled into their heads.) All code must be written with the Four 's in mind: , , , and . 

As for the classroom context, I believe that the two most important things have already been said by Peter and Buffy: keep the focus on the code, not on the student, and make sure that you have a warm relationship with your students. What little piece I would add would be that, given the above, if the things you are asking your students to do have self-apparent value, then the resistance never appears in the first place. If they don't have self-apparent value, then asking the question "how can I make sure my students are receptive to what I have to say" is the wrong question, something more fundamental is missing in the presentation. My biggest victory in this regard was when I figured out how to teach about coding style. I could not for the life of me figure out how to present it as something with intrinsic value. The code that we worked on was all short enough that it hardly mattered, the kids were perfectly able to understand their own code, and my protestations aside, the kids couldn't see any good reason to put thought and effort into indentation, variable names, function names, clean organization, etc. I outlined how I eventually solved that problem here. By the time I finally had it sorted out, the kids started to see intrinsic value to clarity in their code, so the suggestions I gave to help them achieve that end were no longer met with resistance. 

I'm not sure that AP CS Principles has a lot of direct relation to Conway's Game of Life, but nevertheless there is real value in introducing it, and it ultimately features pretty prominently in my program. First off, as you pointed out, it is plenty of fun to watch, so you can spend some time creating glider guns and exploders. You can ask the students to see if they can think up patterns that stay completely still (such as the 2x2 box), or patterns that flip back and forth (such as the line of 3). But, of course, the system's really interesting properties are at higher levels. It serves as a good introduction to the mathematicians Conway (who simplified it to its current state) and Von Neumann (who originally designed the concept), both luminaries of our field. And most importantly, Conway's Game of Life is a great illustration of emergent complexity, and is also provably Turing Complete. Here is a video of a Turing Machine being run in GoL, and here is a video of GoL simulating logic gates. So, in my own classes, I use it in AP Computer Science. It's a great lab for arrays of arrays in APCS (not sure about Principles), and if you are to continue on into computability theory in a later course, letting kids play with it in the earlier class sets up this totally beautiful hook for a really big, "oh, cool!" moment later on when you show them that GoL is Turing Complete. 

What you are trying to do is entirely laudable; helping your students to not only be better engineers, but also better hires, could help them in tremendous ways in the long run. However, since you are in a situation where your rating numbers matter very much to you, be careful that you always attend to your own professional needs as well. You would be in no position to help others if you simply lost your job. Usually, people are okay with instruction that meets their expectations. Therefore, I agree with G. Ann that telling the students that this will be a part of the course is an important first step. However, students signing up for a specific technical course might already have fairly fixed expectations before they enter your classroom, and, as what you are doing may differ from these expectations, you may find that your review marks still take a hit. Thus, I might recommend two alternatives as well: 

When the last one turns out to be impossible, we discuss the limits imposed by not having a sentinel value. Part 2 We revisit loops later in the year when we deal with multi-dimensional arrays. Towards the end of that lesson, they are given this task: