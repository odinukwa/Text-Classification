The BME280 looks like a viable option, and it can connect directly to Pi's GPIO, which gives you lots of opportunity. However I have not found much info on the BMA180 sensor. If your after a 3 axis accelerometer may I suggest the ADXL345 available here. There is also instructions on the same page for setting it up. I'm not sure what you mean by "How can I accommodate between the difference in voltage and current levels with a single power source". But if your worried about connecting multiple sensors to the GPIO, there are plenty of guides out there easy to find. 

I have successfully installed YouTube from the official Kodi repository. However when I try to play a video I get an error. 

The preset settings should work just fine, but feel free to change any of them to suit your needs. If you would like to know more about using BitTorrent this page will be useful to you. Once the torrent is set running the .zip file for the Raspbian installation will start downloading: 

The bit you are interested in is the Revision. However the fact it says , does not actually mean its a Pi 2 Model B revision 2 board. To break it down for you: 

On your computer download a program named PuTTy and put the IP address of you Raspberry Pi into it and select the connection type as SSH. This will open a window, you will be prompted to enter your login and password for your Raspberry Pi. If you want to run fully headless, I recommend using a program called VNC viewer, which allows you to view the Raspberry Pi desktop from your computer wirelessly. 

Once the download has completed you will need to unzip the 2017-14-10-raspbian-jessie.zip folder. Inside the unzipped folder you will find a Disc Image File called 2017-14-10-raspbian-jessie. This file is what gets written to your SD card. to write the Disc Image File to your SD card is going to require a program like Win32 Disk Imager. Once you have it installed, open it and you will see a window like this: 

To enable the server to handle files greater than 2MB a couple of tweaks need to be made. Go to and open the file . Change the value of and to something like . Which changes the maximum file size to 2GB. As an extra you can install APC PHP accelerator which might make ownCloud more responsive for larger installations. To do this run: 

If one wants to purchase a Raspberry Pi, there are a number of different manufacturers from whom to buy. These include element14 and RS Electronics. Are there any significant differences between Pi's made by these manufacturers? 

The presentation timestamp is the time according to the camera's clock. While that will be by far the most accurate measure of the frame's capture time you may not find it that much use as the camera's clock is not synced to the Pi's clock and has no idea what the "real" time is. In other words, it's just a count of microseconds since the camera was initialized. I think about the closest you can easily get to the precise frame capture time (at least according to the Pi's internal clock) will be the time that the first packet of the frame's data gets written to the requested output. You could capture this pretty easily with a custom output. For example, the following little script enhances the PiYUVArray class to include a timestamp set on the first write to the stream (it also resets it on truncate in case you want to reuse the stream for multiple captures): 

In other words, it's not impossible but my understanding is that the probability is so remote (lots of work for no obvious commercial gain) there's no point holding out for such an eventuality. Finally, I should add, for anyone reading this and getting the wrong end of the stick (as this topic comes up from time to time on the Pi forums, and is usually a source of some consternation): the Pi Foundation has no control over this, they merely license the firmware from Broadcom. 

As you've also noted in your comments, you can also tweak the pygame mixer defaults, so the complete script would look like this with your fix in it: 

You might want to have a look at the compoundpi project (full disclosure: I'm the author). It's intended for triggering captures from numerous Pi's with camera modules and uses UDP broadcast packets to get them all triggering as close together as possible. A daemon runs on each Pi which fires up the camera and triggers captures upon receipt of a UDP packet containing the CAPTURE command (other commands are available to configure the camera; the protocol is fairly well documented). A setup using Ethernet is ideal, but wifi will work as well, although you may have to use the time-delay functionality to get decent synchronization in that case (due to packet loss / variable latency). I can't say it's been tested with 100 Pi's - at the moment the biggest setup using it involves 20, but I'd be interested to hear of any issues involving larger scales. The project includes a command line client, a GUI client (written in Qt so it should work on Linux/Mac/Windows but it's only been tested on Ubuntu at this point, and it's still undocumented), and a Python-based client library for writing batch jobs.