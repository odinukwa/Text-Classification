Edit: As suggested by Joe Wallis, I've changed the into a set to speed lookups. Do note, that this (as the rest) is still untested, but Joe Wallis should be correct that this specific lookup should then go a lot faster. And Joe Wallis is also correct in his answer that printing does take time, so you need to consider whether it is worthwhile to actually print inbetween each operation. I think I would keep it for a little while as it clearly indicates where you spend your time, and compared to read/writing files the time to print should be neglible. 

Firstly, related to the mathematical aspect I see how the bias could be leaning towards \$[0, 5]\$, but I don't quite get the connection why you are using 256 afterwards. You could possibly get even better distribution by changing form bytes to the next storage level available. Depending on your range, the distribution could be affected severly if the \$modulo\$ gets close to 256, if I've understood your algorithm correctly. I've sadly not gotten a C# compiler available, so the following points are made untested: 

Note that in the following code the stack is actually a native list with the top of stack being the end of the list. When looping and changing this list it is vital not to disturb the looping indexes whilst modifying the list. I've therefore opted to use an index variable, and looping from the end to start, and this turns out rather neat, it seems. So here is an alternative solution to the challenge: 

The %timeit call will then automatically decide how many rounds it will run with a few repetitions, and present the lowest execution time of all these executions. Using in a loop A natural extension for me was then to do all of my variations in one go, and therefore I started doing stuff like this: 

Since your first attempt, you are indeed showing progress, and it's kind of fun to watch. When entering into the realm of using functions the ball game changes a little, and you need to start thinking of segregation of duties and possible whether you can reuse one or more of the functions. Some more or less general cases, addressed toward your code: 

Then you can replace the cryptic with a more meaningful variable. Similar can of course also be done instead of using and friends... This alternate approach in addition to some of the other comments related to only read what you need, and avoid the when you actually mean , and prebuilding regexps, and other suggestions in other answers should make your code a lot faster, and easier to maintain and understand. 

Notice there is an extraneous output within the version. using div and mod I then ventured on to test how the integer version could be implemented using div and mod, and ended up with the following version: 

The advantage of this method is that you now get all of your data from one single query, and one roundtrip from your code base to the database engine. Using subqueries like this shouldn't be to expensive, and at least when comparing to making several roundtrips it is a way better solution. PS! You could consider using heredocs or other variations to get the multiline string in your query. But do try to break it over multiple lines to enhance the readability of the SQL query. See PHP string doc for various option on how to use strings in PHP. 

I've also changed the logic into some more parts, so that there is one part, , which handle the overall logic, and a dedicated read for each test cases, , and a dedicated sorter for each case, . This separations allows for a lower memory footprint, and in my point of view easier read of what happens in the different parts of the program. Hopefully, this gives you some guidelines on how to improve your code in your future, and hopefully it solves the challenge within the time limits (and correctly :-) ). 

As you can see there is a lot more empty space, bigger markers, and even easier to see that in my slightly changed base data the x-ranges are not totally separable. 

Code review of So far, it's been mainly style reviews and questions related to your choice of names. Lets review some actual code, and lets focus on the method: 

There you have an automated creation of the GUI with predefined counters, and if you would like to add another counter, you simply add another element to the dictionary, and rerun your program. Another benefit of this kind of automated generation, is that if you want to change the element buildup, you change it once within the method, and all the corresponding GUI elements are changed. No more copy-pasted code which is error prone. 

Two focus areas for this review, first some style and code comments, and then a little discussion on a more optimal solution. Code and Style Comments 

But then we see that we can't append everything into or , which already in the names are indicating with the addition of and that they should really be an array already. So lets do that: 

In this answer I'm going to review a single part, and that is the repeated code for generating the various GUI elements related to the counters, and the repeated counter code. Please do read the other answers, and implement the good suggestions from these such as using for the file reading, and so on. Now let us stretch your imagination a bit, and aim to make it more general. This is based upon the fact that whenever I see variables named with numbers, it triggers some automation mechanism in me. Any numbered variables could be replaced with an array or list of some sort. In your case you want to test various character characteristics of all text in a file. What if you could add those test methods into a dictionary, and do stuff related to this dictionary? Luckily, you can actually do that in Python, and you can use your own functions as well: 

You could do similar refactoring to the , but you should really replace that function with something more effective. Time and space complexity Your code is not plain \$O(n)\$. At least not \$n\$ as the n'th humble number. This comes from the simple fact that you loop all numbers, , until you find your n'th humble numbers, and the 1689th humble number is 330674. Clearly you've checked 330674 numbers to get the 1689th humble numbers, and that is not \$O(n)\$. In addition your method uses a dict to store previously calculated humble numbers, so it has a memory complexity of \$\theta (n)\$. A better approach would be to use generators to calculate the next humble number, using the information that the next number has to be next multiple of 2, 3, 5, or 7 compared to a previous humble number. Various approaches exists to do this, amongst them the one in Barrys answer (which got written while I write this answer), or the one suggested by Martin R from Rosetta code related to Hamming numbers. If you incorporate the Rosetta Code's "Cyclic generator method #2" from link above, and replace the function with the the following you'll get a quite fast version: 

I left in the option to allow for negative palindromes in this version, which could be removed if one is so inclined. Devised a little test scheme where I called the integer version with the numbers , and in a loop with 100 000 repeats. It turns out that on my computer this runs in less than half the time of versions using conversion to string. (In my test the iterative and recursive version had almost identical timings!) Conclusion Your version does solve the task, albeit it has some minor style issues. An iterative version can be used, and has it benefits like it's easier to extend into various version which all ends up in the same code. And finally, a solution using div and mod is in preliminary tests almost twice as fast when it comes to deciding if an integer is a palindrome or not! PS! Thanks to Bob for pointing out that I'd forgotten to include the last code segment!