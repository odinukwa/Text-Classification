One analogy I use in my intro class is transportation. The Internet is the roads, bridges, and highways. The World Wide Web is the cars and trucks that travel along these routes, carrying cargo to/from different places. 

Tracing helps students really understand what's happening in the recursive calls. It's also an important tool for when they develop their own recursive functions. If it helps to trace regular function calls, then it helps to trace recursive ones too. 

It depends on the programming level of the students. In my case, students are just starting out with Java. I tell them to ignore the quirks and multiple ways of doing things (e.g., adding 1 to an int var). Find a way the works and go with it. Then discover the different ways as you progress with the language. These students are new to basic programming concepts and problem solving. Language syntax shouldn't stand in their way. 

This sounds like a question of vetting. Here are some things I do when evaluating Node.js libraries: 

If the system is object-oriented, you can use UML class diagrams to document the design. Eclipse has a plugin called ObjectAid that generates these diagrams from the source code (no additional work required). Students can generate professional documentation from their source code. There is jsdoc for JavaScript and javadoc for Java. These require specific comments and tags, but it's well worth it. Source code documentation is important for future development. For all types of diagrams, there's draw.io, Balsamiq, PowerPoint, Visio, and many more. A picture is worth a thousand words. 

I believe something is lost when you simply copy and paste code. They say that to learn a definition of a word, you read it, say it, and write it. So I think typing code definitely adds value, especially when IDEs like Eclipse have autocomplete and syntax checking. Typing is a learning experience. Unless you are copying from a raw format, copy and paste could bring in invalid characters. For example, try copy and pasting "hello world" from Microsoft Word to your favorite code editor. You'll see invalid double-quote characters pasted. 

My biggest challenge each semester is keeping students engaged in class. It's obvious that most of them would rather be somewhere else. I don't know if it's the students, my lecture, or both. I wish I had the resources to present a lecture this way. I believe that generating interest is just as important as the content itself, because this builds a passion for CS that will fuel future learning. How do you make your CS lectures more interesting? 

I once wrote a course to introduce Java. My order of topics was as follows: (Note: Those are not lessons, just the order I've written the topics down). 

This is just the process of making a program. The combined instructions that eventually make up your program are often called "code" by developers, so they use the verb "(to) code" to describe the process of writing down instructions to solve a particular task. 1 As Brian H. pointed out in his comment, a more precise definition of a programming language would be "a set of syntactical and grammatical rules bundeled with a standard library that provides instructions to tell the computer what to do". However, as you asked for an explanation in layman's terms, I wouldn't recommend this definition to explain what a programming language is. 

As with the human languages, there are multiple programming languages. To develop in a certain language you usually write (text) files containing the instructions (you could now mention how this looks in a programming language you like). These text files are read and executed by the computer. Depending on whether the language is low- or high-level, the computer might need additional software (the interpreter) to understand the language. Often, developers use so called IDEs which make development easier as they offer hepful features (for example, automatically creating instruction(s) you normally use a lot or immediately pointing out errors). 

I would therefore recommend GitHub Desktop to Windows users that want an easy and intuitive way to manage Git (e.g. because they have to use it inside their company) without having to deal much with the sometimes counter-intuitive (looking) concepts of Git. 

Why should you try to teach every interested student and assist them in reaching their different personal goals? I think you've already given the answer in your question: Because each of them is genuinely interested in learning something. In my opinion, one of the wonderful things about schools is that they are designed to be places where knowledge is spread. People who already know something about a topic (often these people are the teachers, but even this doesn't have to be the case every time) share their knowledge with people who want to gain knowledge about this topic (usually the students). In reality, this principle is sometimes hard to encounter: As there are usually a lot of required courses in most school systems, you'll always have students who aren't interested in learning something, but are just forced to attend. Still, as I want to focus on the idealism here, I think the reason why teachers should try to teach everyone who is interested is because teaching every interested person is the primary objective of a school. When discussing this question with some others, it might be good to reach a consensus on the level of the discussion: I could imagine that somebody argues with you about this question assuming you are talking about a given, realistic situation and wants to convince you that in certain situations it's (as you also already stated) just not possible or incredibly difficult to teach everybody. 

Find the package in npmjs.com and view the stats (e.g., daily/weekly/monthly downloads). You can sort of gauge its popularity that way. Look for similar libraries and compare their stats. Look at the package in GitHub. View those stats (e.g., # of contributors, # of releases, # of stars). View the GitHub documentation (README.md). Is it helpful, mature, professional? Look at the GitHub commits. Are they recent? Is the repo actively maintained? Finally, just try it out. Sometimes you need to test a few libraries to see which one is better for your application. 

I briefly discuss spacing, braces, and general readability. Then I open Eclipse and demonstrate [Ctrl]+a, [Ctrl]+i. This instantly indents your code according to a default standard (which is configurable). Since there are so many concepts to cover in class and limited time, this is one shortcut we take. 

I think it depends on the goals of the course. Does your course have specific objectives for working in a team? Is the primary goal to learn some aspect of programming? I teach a software practicum course where students must collaborate like a real software engineering team using an Agile Development Methodology. All the work they do is shared. Learning to work in a team is an important skill. But if the primary goal of the course is to teach programming fundamentals, web development, game programming, etc., then I would lean toward individual assignments. It's so crucial to practice programming. You can maximize this with individual assignments. 

There are endless examples that illustrate selection. As you know, most useful programs have at least one selection statement. I've found that some students struggle with the concept, so I start small and pick examples that resonate with students, for example: 

In the software practicum that I teach, students develop new software for a real customer. My school has a standard software license agreement that the students, customer, and I must sign at the start of the semester. The agreement basically gives ownership to everyone involved. The software becomes, in a sense, open source. The agreement has two separate clauses. One gives more "ownership" to the customer. There is some flexibility; one past customer worked with the university to modify the agreement. Also, students could hire their own lawyers to represent them. But I have yet to see that happen. 

It probably won't fit particulary good for you, as you want the same GUI on every platform, but I want to suggest GitHub Desktop for future readers, who don't have the platform requirement. GitHub Desktop GitHub Desktop (source code available on GitHub) is a graphical Git client by GitHub, available for Mac and Windows. It's especially designed to integrate with the hoster GitHub, but should also work with other Git hosters. I think it's intuitive to use the version-control features of GitHub Desktop, which could be an advantage in your case, as this helps against forgetting commands. It, however, does not follow the concepts of Git closely - so you will encounter some things that may be intuitive in GitHub Desktop, but appear strange to Git users who know e.g. the command line interface. As Steven Vascellaro points out in his comment, this could be a major downside when wanting to learn Git: 

When comparing it to your curriculum, I think there are many good elements in it. However, here are a few things I noticed: 

To sum up, the curriculum given by you sounds quite good to me. Except for the adjustments proposed above, I don't see much that needs to be changed. 

If you already use an IDE, this could be the right way for you: Git support in your IDE Many IDEs come bundled with Git support. Eclipse, for example, uses EGit for Git integration. The JetBrains IDEs also provide Git support. The text editor Atom can be extended with plugins (e.g. Git+) to provide Git support. All of those IDEs run on most common platforms (e.g. Linux, Mac, Windows) and look more or less the same there. This would mean you can use the Git client you know at home and at work if you use the same IDE at both places. Normally, the Git support integrates quite well with the programming workflow. The Git clients are often quite mighty, but always accessible using a comfortable GUI, which could help as there are no terminal commands to memorize. However, you should keep the Git concepts in mind - depending on the IDE, the built-in Git client will follow those concepts more or less closely. 

1 After reading through your question another time, I guess I've misunderstood the question and you only asked for a solution for the first item in my list. I think I will nevertheless share my thoughts on both - maybe they can be helpful for you or any future visitor. 

I built a light but fun AI project using the Twitter developer API and a simple Python program to bring my dog Maggie to Twitter. If you send a direct message to @maggielistens, you'll see what I mean. This program uses a version of an old program from the 60s called Eliza. It acts like a therapist by responding to your commments and questions. It uses regular expressions and text replacement to appear like a real person. It won't pass the Turing Test, but it's a fun way to get students interested in AI and programming. 

Recursion is sometimes difficult for students to grasp. It's important to understand the concept before implementing it in any programming language. My college professor said that recursion may not make sense today, next week, or next year. But one day it will come to you, maybe when you least expect it. I show this image to help students think recursively. Next, I'll start with a simple recursive program to calculate the factorial of a number. In class, I simulate recursive calls with pieces of paper. I start by writing fact(10) = 10 * fact(9) on a piece of paper. Then I write fact(9) on a new piece of paper and pass it to a student. The student adds to it by writing fact(9) = 9 * fact(8), writes fact(8) on a new piece of paper, and passes it to another student. This process continues until a student must calculate fact(1), which is simply 1. Then all the papers bubble back up to me, and I calculate the final answer. But even with these relatively simple examples, sometimes it takes time to understand recursion. More simple examples help. 

Paired programming is very effective at work too. We use Skype for Business to share screens (i.e., editor/output windows) and communicate in real time. If you don't have Skype, you can use Slack. Add GitHub or Bitbucket to quickly share code, and you have a very collaborative environment. 

It depends on the situation and your school's policy on academic integrity. At my school, it clearly states that authors may not knowingly permit other students to submit their work. You may want to ask your school to update its policy to include a clause like this. You will have to determine if authors know if other students submitted their work. The author could be a student in the current class or another class. The author could be a stranger online. In a previous class, I suspected that one student submitted another student's program. This was confirmed when I saw that the filename included the original student's first and last name. After discussing this with both students, I resolved it. I can't say that I follow a hard and fast rule. I think it depends on the situation (severity of the violation, actions of both parties, etc.). 

I think whether and when the test cases should be released depends on a few factors. Not releasing the test cases You say that the assignments were only partially assessed by the unit tests, so in my understanding this means that there is somebody having a look at the source code. If (and only if) the assessment was fully automated and there were no human beings looking at the source code, you should not release the test cases before the assignment as otherwise it would be possible that somebody just created a program that has the required outputs for the test cases hard-coded and chooses the right one (using some kind of map or dictionary) depending on the input. If you plan to put the same (auto-graded) assignment again on students in e.g. multiple courses, you might also want to avoid releasing the test cases after the assignment - otherwise students that have completed the assignment could be able to hand the required test cases through to the students that haven't yet completed the assignment. If you however change the unit tests for an auto-graded system after releasing them (i.e. each course has it's own set of unit tests for the same task), then you could release them after the assignment. Releasing the test cases before the assignment I can imagine a situation where it's neccessary to release the test cases and to do this before the assignment: If you're doing test-driven development. In this case having all the unit tests available to everybody would be essential as otherwise the whole strategy wouldn't work. Furthermore, the test cases could help students as they are examples of the program's in- and output if they have trouble understanding the specification (as specifications can benefit from examples). I would even go further and would recommend you to release the test cases before the assignment in almost any case unless you have specific reasons against it. Releasing it after the assignment This could be an option if you want the students to figure out the algorithm without having examples (not sure when this is required, but maybe there are some sort of tasks that require that) but you want them to give a chance to review their mistakes after the assignment is done. I would always try to release them at the latest when the assignment is done.