If you don't mind me asking, any reason you want to register the DbContext directly? I know .NET Core seems to want you to do that, but I don't like IoC containers deciding when to leave open or close my DB connections. Insetead, I'd just do IFooDbContextFactory and have that use a "CreateAsync" method. This factory can take your IAppSettings or IDbContextSettings or something to get the connection string. Then you can call the provider async just fine and in your specific code you'd just do: 

I like the Factory. I called it Create() instead of MasterDbContext. :) After that, I'd like to talk about it a bit. I used to try to do things like this too since it felt like that is what I was reading all over the place. However, EF by itself already is a Unit of Work with Repositories (DbSet) built in. Thus, creating another one over the top doesn't add anything at best and takes away features at worst. If you are looking for something a little different, read up on CQS (Command Query Separation). With this style, you can go directly against the DbContext inside a command or query specifically and select back out what you need. Each command/query is specific to the business problem at hand. You could even swap EF out for Dapper if you wanted to for certain queries. If this doesn't really help you out at all, let me know and I can delete this answer. Edit: One thing I would mention is that you create some sort of interface that represents a user. You can use IoC to link that to some class in the UI that pulls it from the User.Identity if you need to. That way, you aren't passing the UserId/UserName into the method declaration but instead are using IoC to get that information. 

This feels like OOP for the sake of OOP. You don't actually manage the lifetime of the window, you don't hold on to a handle of your window, you don't forward the callback to your class' object,... You can use to store a pointer into the handle which can be retrieved using And then cast to so you can forward the call. You aren't actually doing any D3D stuff yet. That part will be using COM. This is somewhat non-standard C++. Do some research on that. There are several ways to interact with that; make sure you pick a sane option and stay consistent with it. 

You can name crutch into something better that describes what it represents. Or keep whether ChangeToSmall or ChangeToBig was called last and replace crutch with that property. 

I would add the (currently global) VM state as a parameter to the function. This will make reentrant and allows multiple VMs working in parallel. I would prefer a switch for dispatch, it reads cleaner, and there is less chance of the jump table being messed up because you miscounted. Just a stack with only a view to the top 2 elements and 3 registers is very likely not enough. It's not Turing complete in its current form. You cannot sort an array with it for example. Add bounds checks for storing and loading the registers. Add bounds checks for stack over/undeflow as well. For a VM to be useful it needs to interact with the outside world, that means opcodes for input and output from peripherals/game engine. Stack implementation is fine (except for the bounds check) though using union to bitcast between types is Undefined Behavior in C++. You will need to use a memcpy to do the bitcast: 

Validation uses ?. here so that the second part isn't run if there is no rule. .NET Core changed the way translations work, so I had to IoC inject a reference to them now, which is why you see that. CreateCommandRepository 

Edit The last point here is that Exceptions actually are pretty slow. When I throw an exception, it ends up taking around 150 ms to get the result back. When I switched to not throwing an exception, it would get around 25ms response for the exact same check/data. That is 6 times slower! Thus, avoiding exceptions seems like a really good thing to do! :) 

ICommandQueryRetry will cause this to retry general exceptions up to 3 times before failing. For caching, you just add a different interfaces (a few different ones for different timeframes) and it takes care of it for you. 

I also work on an e-commerce platform that has tons of data in it. What I've found is that if you have more than a very basic query, write the query yourself. EF speeds up saving records and very basic selects, but as soon as you start doing something a bit complicated, EF will spit out thousands of lines of SQL for something you could have done yourself in 100. You are better off just trying to create the SQL for it and use Dapper or just create an object that you can map directly back to from the query. Use context.Database.SqlQuery(sql, parameters).ToList() and you'll be able to get exactly what you need. Though, naturally, it is going to be way more work on your part since you have to do all the joins manually and type that out, but if you need it to perform, then I would really recommend just typing it out. I've had calls go from 60 seconds down to < 4 by just doing it myself instead of relying on EF. 

Besides that you store a date as a string in the database, let dates be a dates. In fact the function itself is not necessary with how the code is used. Make OOP? well you could create a querryable object that will return the aforementioned array and keeps the object handle private. 

Then when you need to start it you just call . Other than that please keep a consistent format, especially the indentation and brace style. It will vastly increase readability. Compare the listener I provided to your listener. Also the fixed layout of the components will do odd things when the user tries to resize the window, I suggest using a layout manager. 

converting to string just to get the length won't work if there is a decimal or it's large enough that the string conversion uses scientific notation. 

Here means that the value may or may not have a value which you can check with . However the way you use it if by then getting the account immediately if you found it. So why not return the account directly? 

All my queries/commands/command queries end up returning IResult because I found throwing exceptions is really expensive. Thus, this lets me deal with any issues. IResult is returned by Command and doesn't return any info about the actual call, so it doesn't violate CQS. Query returns IResult< T > that stores the data. I'll show an example here of the Create Command through the layers. CommandQuery 

I have the complete opposite view. Every query is specific to its use case. Today it may be true that you can call the other query but if someone changes its output then your query could be impacted. Maybe the other query gets a permission added to it that yours doesn't have. It is far better to simply build and return exactly what you need and no more. You may be thinking that you aren't reusing any code this way and you would be right. If two UI had the same data on it why would you have two? 

Everything there looks right (except for the on the last line, which should be ). It's about as close to a literal translation as you can get. Converting the Delphi code to use dynamic arrays could ease your mind regarding out-of-bounds access, although the initial setup would be more cumbersome. (That might not be a problem if you're ultimately planning on loading the data from a file instead of from constants.) It would look something like this: 

Your first paragraph says "this is the most commonly used method" without saying what "this" is. When writing a FAQ answer, especially one about something as thorny as multithreading, it's important to be precise from the very start. Maybe "this" refers to something from the question, but I don't know because you didn't include the question in what you presented for review. You say accessing the same memory from multiple threads leads to deadlock, which is generally false. Accessing the same memory at the same time is a race condition that might be an issue, but also might be harmless. If it leads to deadlock, you probably have buggy hardware. Furthermore, if you have two threads going back and forth fighting over access, you again don't have deadlock. With deadlock, there's no back-and-forth anymore. If threads are repeatedly going back and forth, that's often an indication of a lock convoy, which is perfectly safe, but doesn't usually provide the desired level of performance. A critical section is just one way of writing thread-safe code, so it's incorrect to say that creating one begins the way of protecting any object. Critical section is not a proper noun; there's no need to capitalize it. Regarding the phone booth, deadlock rarely involves a fight. The CPU doesn't pit two threads against each other and grant memory access to whichever is mightier. It happily grants access to both at the same time. Deadlock would be when someone inside the phone booth calls the home of another person in line for the booth. That person cannot answer his home phone because he's in line outside waiting for the booth, but the caller won't get off the phone until it's answered. This actually illustrates how adding locks can actually lead to deadlock, not prevent it. (When you have no threading protection at all, deadlock is rare.) You characterize the threads waiting to acquire a critical section as a line of people outside the phone booth. MSDN specifically contradicts that analogy: 

That way, the rest of those scenarios are being handled by the other decorators so returning an IResult doesn't become cumbersome. At the UI level, I created a ResponseMediator instead that returned IActionResult items. This will handle the IResult and return the appropriate data/status code. i.e. (ICqsMediator is what IMediator used to be) 

Since we can route the different verbs to different classes, we can focus on only 1 method at a time per class. I'm using Mediators everywhere so the code looks the same across all classes. I thought this was really the Service Locator anti-pattern, but it isn't because you still know the mediator dependency. I also use async through the entire call stack because Task.CompletedTask, if needed, has very little overhead and not blocking threads is the way to go. ResponseMediator 

There are specific scenarios in my logic where I can easily not throw an exception and have the above layers just check those boolean flags to determine what to show the end user. If a real exception occurs, I can put that on the ErrorMessage property and pull it from there. Looking at CQS, I realized that returning an IResult with this for a command is okay because it isn't returning any information about the actual process. Either it succeeded (IsSuccessful = true) or something bad occurred, meaning I need to show something bad happened to the end user and the command never ran, anyway. I created some helper methods for creating results so coder's don't really care. The only thing that gets added to the main implementation is: 

you don't need the memset in the for of you just need to add a to the end when max depth has been reached: 

Your temp array is static, this immediately makes your function not thread-safe and non-reentrant. Instead add it to the parameter list. 

Many gui libraries use a single thread and callbacks to manage events and draws, if you block in one of the callbacks then it can't handle any other event while it is blocking. This was the reason redraw didn't work. is like except that it adds (the time until callback should happen) to the time the current callback (should have) happened instead of . This way the time between getting called and it calling is not a factor. 

I would store the value to write directly in the . That way you don't need the if-else in . Instead it's just an assignment. 

Insertion sort on short arrays is much faster than quick sort, we can use this to make the last recursion steps quicker. The second optimization option is pivot selection. Your first element is the pivot is very slow against already sorted arrays. Something like getting the middle element would then be better. 

If you know the queries you affect, you just have to give it the query type and it'll take care of the rest. I made it async in case it took some IO to figure out all the types. Decorators The most important decorator I wanted to show was the exception handling one that is at the top of the chain: 

If you are still reading and your eyes haven't glazed over yet, what are your thoughts? Is this too much? Thanks! 

My "repository" is a little different. The repository here is above the database technology being used. That way, if you want to change from EF to a webservice or something, you can change that implementation easily without affecting the handler above. Mapper 

I've created a "framework" or more of a library for a CQS implementation with a few decorators. Using ASP.NET Core for the front end, I wanted an opinion about how this looks/feels. I changed the default mvc approach and created a Features folder that stores both the Views and Controllers in the same folder. Then each command/query ends up being in its own folder in the implementation. I have the following decorators: Exception/Logging, Retry, Cache, Cache Invalidation, Validation, and Permission. Any input at all is welcomed! This will be along post, but it'll be an interesting read, in my opinion. :) First, CQS = Command Query Separation. Essentially, queries return data and do not modify state and commands modify state but return no data. There is a gray area here where you need to run a command but then return the data (i.e. Queues, Stacks). Thus, i Created a "CommandQuery" for those scenarios where just a command won't be good enough. CQS normally has ICommandHandler<> and IQueryHandler<> interfaces to support decorators. Decorators are classes that can add functionality to these classes without changing them. i.e. The calls are chained. They implement the same interface, but I use SimpleInjector to make those classes run before/after the actual implementation. All code becomes narrow and easy to maintain. Also, you can add more decorators to all commands/queries with one line of code. I tried to follow SOLID through all the layers here with the intention that every piece of code will be unit testable at a high level. The problems being solved inside may end up more difficult than that, but I digress. :) (My mock implementation deals with Digimon World 2... Don't ask) :) Controller 

Test with that code for a little while to convince yourself that the array accesses are right. If they're not, Delphi's range checking will alert you. Once you're confident, you can disable range checking inside so that it's true to its name: 

Don't forget to mark with . The constructor that takes a metaclass is of limited utility, especially in the case demonstrated here with (also known as ). No matter what class is passed as an argument, the constructor will always call the zero-argument constructor introduced in the base class, and yet inspecting the of the created object, it will appear to be of the correct class. For it to call the proper constructor, the method of the base class would need to be declared virtual. I'd forego the metaclass constructor entirely. Leave the task of constructing objects to some other code; your class is called a , after all, not a . In , you call specific attention to the order of the two instructions. That reveals a misunderstanding on your part because the order of those instructions doesn't make any difference at all. Assigning doesn't grant any access to the object before the lock is acquired. Even if it did, that access would be useless because the thread that access was granted to is the current thread, and that thread can't possibly do anything with the object until returns. There is no apostrophe in freed. It's an ordinary English word. You mention how you "don't define the actual protected object in the class." That doesn't make any sense. I think what you wanted to convey was that you don't expose the protected object except through the method. You want to point out that the field is private intentionally. Ultimately, it's hard to judge how good a FAQ answer this is because the question it's meant to answer is absent. There's systemic confusion over what deadlock is and how it occurs, so I hope the question didn't ask about deadlock. You might just want to skip the introductory motivation and go straight to presenting the locking code.