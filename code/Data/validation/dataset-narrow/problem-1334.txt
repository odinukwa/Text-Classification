If you're talking about the scene hierarchy, it's not a good idea. The scene hierarchy is meant to be designed in such a way that all objects that need to move together/are attached to each other should be placed as children of a parent game object. For example, in a car object, the body and wheels are placed together under a parent "Car" object, since they generally move and rotate together in a real-life car. This set up allows the wheels to move and rotate in the same direction as the body when they aren't steered, but when they are an offset rotation is applied. The wheel still moves and rotates with the body, but it has some offset local rotation/position which is also added to it's world position and rotation. You can also use parent and child Transforms to group objects for easy debugging like @SanSolo said, but only if you are sure that you won't change the Transform of the parent container in any way. 

With this formula, the resulting vector will point in the direction of the normal if the point is above the plane and opposite the normal if the point is below the plane. 

You could create your own waypoint-based graph, update it every frame and perform a Breadth First Search on that, or you could maybe try looking at one of the A* projects (there are free ones) on the Asset Store. To make the waypoint graph, Make the waypoints a child of the platform they represent, so that they move with the platform. You could set a waypoint tag on your waypoints and search for all waypoints in your player script. The waypoint should have a MonoBehaviour which contains the other waypoints it is connected to. Thus you have the nodes and edges of a graph. You can perform a simple Breadth First Search or use your implementation of Dijkstra's or A* for traversing the graph. Then you could check the height difference between this and the next waypoint in your traversal and if it is higher than a certain amount, you won't go there (that is a platform is above the character), a bit like how navmeshes are baked. If you need more help implementing this, feel free to ask. 

I use . $URL$ It was written for XNA 3.1, but I updated it to XNA 4.0. You can find those changes here: $URL$ 

When a block moves, add it to a list that needs checking. When you check a block remove it from the list. First, decide if lines of 4+ count and if not, which set of 3 takes precedence in a row of 4. Have your algorithm check in 4 directions instead of 8. (Horizontal, Vertical, and 2 diagonal) Assuming you first check horizontally and allow matches of 4: 

Number the tiles. You could derive this information by calculating row*8+column or something similar. Take modulus 16 of the grid number. (There are 16 positions before the tiles repeat.) Color the tile based on if it has an even or an odd number. Flip the tile color if the result is greater than 7. 

Ogre Battle (SNES) does this, with the player having the option to cast powerful spells which are of limited quantity. 

No, fetching them from the hard drive is very time-intensive. It is possible that you have so much texture/model/animation data that everything will not fit concurrently on the GPU, especially for someone using an older graphics card or laptop. Main memory is probably the cheapest resource you have to work with on a modern computer. You should leave things like unloading textures from memory for when you are switching maps. 

If you decide to allow diagonal movement someday, you can just change the range variable's calculation. 

Building modular rooms will make it easier for you to replace/cut/rearrange things based on play testing. 

I experienced some problems with in XNA when I tried to mix two different SpriteSort modes. (Begin with deferred, end, begin with BackToFront wasn't sorting properly.) I've settled on just giving everything I draw with SpriteBatch a depth value. To that end, what is the smallest increment I can use on the floating point variable that will be used as the depth parameter without running into rounding problems? The valid values for this float are between 0.0 and 1.0. It is a float, not a double, and the language is C#. UPDATE: My testing has shown that 0.008f is the smallest amount I can change my depth value by and be certain the sorting will work. I'm guessing there is something else at play in BasicEffect or SpriteBatch. What I am trying to use this for is the rendering of my game's map grid. I want to make heavy use of transparency and overlapping to create a specific visual look for the tiles, the doodads, and the characters. Essentially, I am using a painter's algorithm to draw the tiles in order from the back row to the front. I have them numbered so I know the ordering is correct. The doodads I am trying to draw on top of the map are not appearing when my depth decrementor is set to a low enough number to draw everything I will need. It only works properly in a range where I can only access about 100 unique depths. UPDATE about SpriteSortMode problems (as requested): Thus far in my project I have got by just fine using SpriteSortMode.Deferred for everything. I have all of the standard UI components you would expect, windowing, clipping, etc. working. Now I am attempting to draw my map grid. Like windowing/clipping this requires things to be done in a specific order to look right. The grid tiles draw in a certain order. To accommodate overlapping, doodads/characters draw on top of a tile before the next tile is drawn. No matter what I did, my doodads/characters would always be drawn under the tiles. Changing the order of draws had no impact. Even drawing all of the tiles and then drawing the doodads resulted in them showing up underneath the tiles. Especially odd was that my UI elements continued to appear above the problem tiles as I scrolled around the map. I switched to SpriteSortMode.BackToFront and with a high enough depth difference (~0.01) I see things drawing on the grid as expected, but this depth difference is way too high to support every visible tile of the map. I am searching for a better solution than to write code that will End and Begin a new SpriteBatch every time ~100 pieces are drawn. 

2: We first create a vector ( 2D in this case with component x and y ) by taking the difference from both positions ( mouse - player ). 3: We then Normalize it to create a so called " unit vector ". Which means to bring the length of our vector to 1. This is done by dividing both x and y component of the vector by the length/magnitude. We need this because this is our direction vector. It simply tells in which direction we are heading for the x and y axis. 4: Now we have the direction we just need to multiply it by a scalar ( or simply put by your speed). Since the length is 1. Any number we multiply with will result in a new vector with the length equal to your given speed. Just remember that a unit vector represents the direction of your vector. Basically the red dotted lines is how much it moves in the x direction and how much it moves in the y direction per frame. So recap: Unit vector = direction Magnitude/Length/speed = steps to move per frame on x and y axis. (The lengths in the drawing are just for visual aid, they are not meant to be accurate ) Hope this helps. 

We know the amount of new tiles needed to fill the column so we simply generate new values and set the free spots to these values (you can do this from bottom up or the other way around ). You then simply create your visuals and tween them to the right position. The position is calculated by the tile width and height. For example if we take 32x32 and index column(x) = 2 and index roy(y) = 4. The position = 64, 128. When creating tile objects, it's easy to just store their position in them. So when you click on them you can just request their grid position. Don't forget to update this on every move. If you set all these values into variables ( including the size of your 2D array ) you can easily resize your grid, visually and structurally. Keep in mind that I'm trying to keep the actual data separate from my visuals. Eventhough they are in a way linked by their grid position. We simply have the sprites to click on them and request their position. ( you can do this without sprites though, by calculating the mouse position and converting it into a grid position). But the actual logic is done trough the 2D grid. We then simply call functions to move our visuals and set their new grid position. I also have to mention, you need to do bound checking as you traverse trough your grid. You don't want out of bound exceptions ( going below 0, or above the capacity ) Hope this helps. 

Any slowness in this situation would be caused by the switching of texture states, as another poster also mentioned. If you are finding that you have performance problems you can combine all of your small textures into a larger sprite sheet texture to eliminate the switching of which texture is on the GPU. You will just need to use a rect to access the correct portion of the sprite sheet when you make the call to ContentManager.Load(). 

Magic: The Gathering Duels of the Planeswalkers has AI that simulates possible future game states. Different AI difficulties are allowed varying lengths of time to plan advance turns. Additionally, the decks of easier AI opponents are sorted so that rarer cards are more likely to appear near the bottom of the deck. Here is a detailed article with pictures(!): $URL$ 

Most levels in 3D platformer games are built on a 3D grid. The old Tomb Raider games are very obvious about this. (Press forward and the character moves one square every time, you know you can jump 3 squares if you are running but only 2 if you are standing, etc.) Even more recent examples, such as Darksiders 2 follow the same idea. The character has a defined set of abilities with regards to how far they can jump and run. The environment is built out of pieces that are relative to those measurements. Fluid animations will hide them. Another thing to consider is that for the most part, you can simplify the movement paths in your game down to 2D when you are designing it. Consider the ball sections of Metroid Prime, or how most of the time you are moving along a corridor or climbing the side of a wall. You rarely need to turn 90 degrees in the jumping sections of those games. Usually that is reserved for the arena fights. To make it easier to restrict the player from going off the expected path, newer games often severely restrict movement-enhancing items and abilities. Today, a grappling hook is only useful on specific points deliberately placed in the world. Contrast that to the hookshot in Zelda 64, which can be used on any wooden surface in the game. Other examples include only being able to wall-run or place portals on specific wall textures. Some tips for designing a platformer/adventure game that can be applied to 2D or 3D: