Now perform your basic binary search over the list, stopping when the random value is within the range in the internal representation. This works because of the way we add values to the list; the running total is guaranteed to be sorted. Option 2: Multiple Additions Another option is to add each monster to the list multiple times, however, depending on how granular the weights could be you could land up with a rather large list - so this would be a memory-performance trade-off. 

Simplicity and approachability. Most people understand heterogeneous systems with a high school level of education. For example: you would typically spend less time figuring out how to interpolate them the first time you attempt it. They can be visualized. (1, 2) is easer to visualize than (1, 2, 5) - because you first need to eliminate the 5. Furthermore they can be multiplied by a scalar value with a significant effect. Multiplying a homogeneous coordinate by a scalar achieves nothing. In some problems () this is important. If you need to identify infinities they would help there as well. I would basically take every advantage given in the Wikipedia article and invert it. 

Get the items in the bucket that contains the item you are interested in, as well as the buckets surrounding it (in 3D that would mean you would need to get the items in 9 buckets). Eliminate the original item from the set. Loop through those items and find the nearest neighbour. 

You will probably need to micro-manage the 3G modem to ensure that you don't have delays while it switches power modes. Your simple answer is make sure you send at least one packet larger than 128 bytes every 6-8 seconds. If you can guarantee that all your packets are smaller than 128 bytes make sure you send something once every 6-8 seconds. Avoid, at all costs, switching between 3G power states in a game as you will be cut off for 2.5 seconds while the transition occurs. My Packets Are All Smaller Than 128 Bytes Have a timer kick off every 6 seconds or so. If no packet has been sent since the last timer event, send a small heartbeat packet (4 bytes is probably safe). If you sometimes need to send large data you could queue it up for temporary jumps to DCH. Turn OFF Nagling if you are using TCP. My Packets Could be Larger Than 128 Bytes Have a timer kick off every 6 seconds or so. If no packet has been sent since the last timer event, that is at least 128 bytes; send a large heartbeat packet (196 bytes is probably safe). Turn ON Nagling - if acceptable (i.e. your game is not real-time). 2.5s Delay is Acceptable This is probably your case. Do nothing special. Just make sure that your UI is ready for something like this (i.e. ensure it supports background workers/async). More Info Taken from the rather good XMPP mobile recommendations. Keep in mind these are not set in stone, and are up to the network operator - you can get feedback about this from the phone on some platforms: Idle connections but no data, ~8mA This mode is used when connections are not actively sending/receiving data. FACH <= 128 bytes per packet, ~140mA This mode is used when the packet queue remains smaller than 128 bytes for 8s. It takes 2.5s for your cellphone to move from idle to FACH. DCH > 128 bytes per packet, ~380mA This mode is used when one or more connections are sending packets larger than 128 bytes at least once every 8 seconds. It takes 2.5s for your cellphone to move from FACH to DCH. 

On Windows there is actually a way to change the behaviour of the JIT - it's clear that you can't create such an INI on the XBOX: so this is unavailable. Remember that a compiler is not allowed to change the behaviour of a piece of code. You have either found an XBOX runtime bug, or the library you are using is sensitive to delays introduced by debugging (somehow, the antithesis of a heisenbug): and it's very likely the latter. Remember, it's Microsoft's job to ensure that the JITter does not change the behaviour of a piece of code: and they do a very good job at it (if I remember correctly the XBOX interprets MSIL - so the chances of it doing it incorrectly are next-to-none). Expecting DEBUG/RELEASE to change the behaviour of your application is the wrong mindset to begin with: debug your DEBUG build, and test your RELEASE build without the debugger attached. From your comments it sounds like they have heisenbug in BEPU: made apparent by the fact that they are using multi-threading. I would recommend attempting to disable the multi-threading (not sure how, but it's clear that you can) and seeing if the behaviour persists: if it doesn't there is a problem with the threading in BEPU and you should report it to them. 

Therefore you can simply perform a on a and map the indicies within the shader (make sure you use point sampling). If you use all the pixels in a 4096x4096 texture you will effectively have an array that can contain 16777216 values. 

And therefore you get the code that I put in the gist. I am pretty sure this all can be used in the random damage case scenario, but I haven't taken the time to figure that out. Disclaimer: This is all home-grown statistics, I have no education in the field. My unit tests do pass though. 

I can't tell you how the Minecraft one works - although I am sure if you looked at MCP (if you have a legal copy of Minecraft) you could find out. I would implement this as follows: 

The auto-generated files here would be specific to development. If, for example, you chose to use a zip container or such you could possibly use the id as the filename within the zip (e.g. '1.bin') and switch the implementation. Keep in mind that this would eliminate the possibility of modding. 

In order to use this function you must provide it with an initial value (for example, the camera starting position), the change required to get it to the target (where you want it to move to) and how far along that line you want it to be (a value between 0 and 1 - e.g. 0.5 would be half way to the target). The result of a lerp looks like this: 

Store everything as an attribute (or decorator) - with mount points. Let's take a house the player has designed as an example: 

Avoidance This makes an object avoid obstacles that may be hindering it while it navigates to a goal. Perfect avoidance would never allow objects to overlap. Separation This deals with the situation when avoidance fails to keep objects apart. This often occurs 'between frames': an object can move into a new position that overlaps other objects because the precise time of collision happened between the last frame and the current one (or some other condition such as momentum). Separation will seek to move the object so that it no longer collides. Are They The Same Thing? They are not really the same, but they are related - in a system which contains both separation is only there because avoidance would need to multisample (and hence impact performance) to avoid collisions between frames. Thus, we simply allow the overlap to occur from the perspective of avoidance and IMMEDIATELY resolve it using separation. Note that separation can exist alone in a system: for example when the movement of an object is controlled by physics and not by AI. I do not think the inverse (avoidance alone) would be found alone in any serious implementation. 

This way as soon as the user issues the command they see a result - the lerp helps us gradually move to actuality and the smoothing ensure that the unit doesn't jump forwards and backwards due to variance (hopefully just slow down and speed up in a way the user can't notice). Some resources: 

Please, if you are encrypting for cheat prevention abandon it. You are going to come up short - I gave you have the information in the event that you are not. Remember that you can selectively encrypt packets by the first byte in the packet being and indicator of whether the rest is encrypted: although, once again, I would stick to HTTPS if you need to do things like credit card transactions: they are extremely infrequent and HTTPS is designed by experts - unlike something you or me designed. All of that said, Blizzard do actually encrypt their WoW traffic. The main reason this broke is because someone, who is likely a complete amateur, decided that they would try their hand at a home-grown encryption algorithm; this panned out really well. Even if you do use industry standard algorithms there is a good chance that someone will reverse-engineer your code and simulate it - once the client enters their password there is no telling that an unsupported system is connected. 

As suggested by Nathan, to make the code more compact you can use . The equation for is which is identical to the equation you see above. Thus the code would become: 

Thoughts Should your authentication be secure? Absolutely. Make no compromises in terms of security when a password is in question. Thus you should be definitely be considering the first bullet in my answer. Should your data be secure? Only if it is an in-game purchase/micro-transaction - and then why not just use something tried and true like HTTPS. Encrypting your game traffic is not likely a viable solution for the following reasons: 

You could even pre-build a table that contains the resolved file table for all the mods that are loaded - again investigate on how MPQ would make this possible. Some systems let you skip the asset discovery and load an asset directly from a specific mod - this helps when, for example, a mod wants to call a script from the base mod that it has a new implementation/override of. Starcraft overwrites assets when a patch is released. The engine is unaware of previous versions; except a routine which is used to upgrade (or translate-on-the-fly) previous save games and replays. If you remove something from the game you must leave the tombstones in your assets so that you don't get missing textures etc. for replays. Finally remember that, in Starcraft specifically, a map is actually the first mod in the chain; and it is due to this that maps like DoTA were possible in Warcraft 3 (which is the code-base for Starcraft 2). 

Sitting around figuring out which library to use will probably take longer than just rolling your own. You could probably throw together a basic format in less than a few days and improve it (or replace it) at some point in the future - start solving real problems in your game before wasting time with something game format (but remember, architect your system in such a way that it can be replaced at some point in the future). 

I am trying to wrap my head around RK4. I decided to do the most basic 'ball with gravity that bounces' simulation. I have implemented the following integrator given Glenn Fiedler's tutorial: 

So each entity can have one or more mount points - each mount point can accept zero or more other components. This data would be stored with the version that it was saved at, along with the any relevant properties (such as Displacement etc. in my example) - NoSQL would likely make a really nice fit here (Key = Entity ID, Value = Serialized Binary Data). Each component would then need to be able to 'upgrade' old data from a previous version (never remove fields from serialized data - just 'null' them) - this upgrade happens the minute it is loaded (it would then be immediately stored back in the latest version available). Let's say that our house has had it's dimensions changed. The upgrade code would relatively work out the distance between the north and south walls and proportionally alter the displacements of all the contained entities. As another example our meat bowl might have the 'Food' field removed, and instead get a 'Variety' (Meat) and 'Recipe' (Balls). The upgrade script would turn 'Meat Balls' into 'Meat', 'Balls'. Each component should also know how to deal with changes to mount points - e.g. if one is removed you will need a mechanism in place to figure out the position relative to another mount point that is still available. This all leaves exactly one issue open: what happens if two objects clash with each-other (not their container - mount points protect you from that)? After an upgrade you should check for collisions and attempt to resolve them (by moving things apart, a bit like SAT). If you can't figure out how to resolve the collision remove one of the objects and place it in a stash - where they can buy these removed items (for free) or sell them (at full price); and obviously notify the player that the upgrade broke some of their layout - possibly with a 'zoom into' feature so that they can see the problem. Ultimately you should leave complex changes in the players' hands (fail fast) as no algorithm can account for aesthetic - you should merely be able to give the player context as to where the item used to be (so that they can remember, not just land up with all these items in their stash and not know where they were). 

You don't actually need to have an actual content project: all you need to do is copy the effect XNBs to your output directories. However, if you really want to embed them in a DLL first create a .resx in your DLL and add all the compiled effects to it (you can use to make these - which can be found in the DirectX SDK, it's also available in the Content Pipeline API). At runtime use the byte array effect constructor to create effect from the resources. For example: 

The top/left is clearly at 0,0 - however the first item you would typically encounter would be either 0,1 or 1,0 (depending on your loop). However if find the first non-empty column as well as the first non-empty row and combine those co-ordinates you will get 0,0 - the same principal applies to the bottom/right of the bounding box. 

After reading over the tutorial I noticed a few things that just seemed 'out' to me. Notably how the entire simulation revolves around at 0 and at 0 - considering that we are working out a curve over the duration it seems logical that RK4 wouldn't be able to handle this simple scenario. Never-the-less I forged on and wrote a very simple Euler integrator: 

I am looking for any input on simulating water in 2D, against a rather large (call it) blocked/not blocked array (viewed from the side). I have come up with the following ideas: Cell Automata Do a massively parralel simulation on the CPU, using cell automata. With rules as simple as: 

Non-blocking is basically the same thing as asynchronous: if you use the async features of .Net sockets you will get non-blocking code for free. I doubt you are using C# 4.5 so you will need to resort to the 'older' way of doing non-blocking IO. The following is a snippet which deals with how to stream data from a TCP connection (you will likely want to use UDP, but the core principles are the same): 

In DirectX 10 the cards all have the same capabilities: this means that they guarantee that all features are available and implemented. However, they are free to do driver-level optimizations. Take, for example, the major difference in the way that they do anisotropic filtering (this article contains sources). Not only is the output of each vendor different - the user is also able to tweak the enabled optimizations in configuration tools provided by most vendors. If you want guaranteed and perfect results use the reference rasterizer from the DirectX SDK - it's extremely slow; but it is what Microsoft expects vendors to approximate. In regard to output quality guarantees there is no difference between DirectX 9 and DirectX 10: there is absolutely no guarantee (even worse, quite a substantial amount of laptop chipsets advertise support for a feature and do nothing when it is used - leading to severely degraded quality).