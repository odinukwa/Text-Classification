I am designing a planetary system simulator. The coordinates used are standard for JPanel (0,0 in the upper left corner). My model is based on a class Body: 

When the method names you are using are meaningful, there is no need to comment code - it comments itself. If you extract a lot of statements like this, reading the algorithm becomes really easy. It becomes a short list of easy to understand calls, instead of lots of mathematical operations here and there. And if you are unsure about what a certain step does, you can just read one specific method body. A good rule for naming the method could be what I just done - just name the method just like you would phrase the comment. In general, one method should be doing one thing and one thing only. 

You may want to get rid of that :) That's why you interpreter prints the list every time. You told it to... Functionally better But functionally, we can do way better. Ruby's enumerables have a method: 

You move it into , but then you copy it into the constructor anyway! Make sure you delay construction as far as possible. should just take whatever: 

And we no longer have name pollution with cryptic names. is a lot easier to understand than . Goto At a first approximation, never use . It makes it more or less impossible to follow code. Without , you also don't need labels. Instead, just call different functions. Or keep an internal state machine. Or really any possible other solution. Code with like this is incredibly brittle - what if you want to add more states somewhere in between? Good luck keeping track of everything. Use Enumerations Right now, you have ten s for race. But only one of those is ever going to be on, and that might prove difficult to ensure long-term. Prefer to instead use an enumeration: 

If you are not in control of this code, then you have no other choice than to search through the entire list. Marcin Juraszek did propose a pretty good solution for this. Another way to do this search, which would also be a little bit faster would be this: 

Basically, what you are trying to accomplish can easily be done through the use of the Aggregate method but I would stay away from it for performance reasons. You cannot early return from an Aggregate process so you would have to continue looping for all items in the list even though you found a valid result. I would instead use a variant of the TakeWhile method to scan through the list until the interesting element is found. The issue with TakeWhile is that it tests for the predicate before returning the value. This causes the returned index to always be one iteration off. This is where the TakeUntil method comes into play. Basically, where TakeWhile acts like a while loop, TakeUntil acts like a do while loop. This method tracks two values, the final index to return and a score of the best value found so far. 

Your approach on finding the th element relies on being able to construct a with the first types being some predictable thing that you can match against. But the types you chose for were, for index 1, . But we don't actually need to introduce this thing to do this, we can simply turn it into . That way, 's specialization instead of taking a , we can simplify to: 

Don't use non-member / You're using standard containers. They have member /. It's a natural thing to use and long predates the non-member functions. The non-members only make sense to be used in generic code, or on types that don't have the members. As-is, you're neither adding more functionality (w.r.t. generic code) nor adding to readability (it's longer to type, and the important part - the container - now comes last). So this: 

Answering your question - yes, this is a correct solution (the algorithm is pretty simple), and yes, it is not the most efficient one. The efficiency depends on the implementation of the priority queue. In your case, I assume this is provided in . The more efficient way uses what is called a Fibonacci Heap. Unfortunately, there is no implementation available in , but there are plenty of implementations online (like this one). You can test your solution using one of them. 

Swap your template parameter ordering The doesn't really matter - but the does, so I would put it first: 

yield! You're way overthinking the problem. Python has . This is one of the coolest things in Python (IMHO). When you want to iterate over a container like this: 

An alternate implementation, just throwing it out as an idea for thinking about the problem completely differently is this. A BST is valid if it's in-order traversal is actually ordered. An in-order traversal would be: 

And more... In your code, you use twice. Now, what will happen, if something (e.g. another thread) changes the after you added all your nodes, but before you started calculating distances? I suggest that you create a local final variable in your method: 

It's a small thing, but most code formatters will do it this way, and it is easier to read. The same goes for: 

If you are using an IDE like Eclipse or IntelliJ IDEA, there are features that format your code automatically. Comments and methods Comments are good if you are writing complex code that could be hard to understand without them. That's not the case here. Compare: 

The idea around this solution is to make sure that only one pass through the list will ever happen. This is an solution, as opposed to Juraszek's one which is an solution where n is the amount of inputs and m is the amount of matching keys. This solution also adds a safety around keys that does not have at least elements. For now, it simply skips it, but it is trivial to check for the value of SkipCounter before resting it if an exception needs to be thrown. Once we find a match for our first parameter, we set a skip counter based on a distance parameter. We then proceed on decrementing the counter until it reaches zero. If the counter reaches zero, we have a found an item at distance items of the parameter so we save it. If it never reaches zero it means that we are looking for an item further than there is in the list. Providing a negative distance to this algorithm will never yield any results as it is a forward only algorithm. When the final value is returned, we simply trash the counter and only keep the values we saved in our temporary object. EDIT As requested in the comment, the question author is wondering how to trigger updates to a progress bar in a solution like this. Since this code is using LINQ which works wonders with yield return, you can simply call it like this: 

In addition to the double free, you get the other issue in that the user might expect a deep copy but actually is basically just a Java-style reference to . Fixing this is an absolute must. Resizing This is definitely non-functional. You delete your member , then, separately from that, you create a locally scoped array that you write stuff into. At the end of , the object will have a deleted local array! The correct way to is to allocate a new array (only have to do one!) of double the size, to copy/move from your member into the new array, and then simply change your member to point to the new array. This should be one allocation (of the doubled array) and one deletion (of the old array). Off-by-one The first writes into . What goes into ? 

As you expect, the lambda specified in the select block will be called for each element in the list. But because of how LINQ methods are designed (using yield return), this will happen as the aggregate method process them. This is because the list of items that Select returns is built only as new items are requested by the bottom most foreach loop which runs inside the Aggregate method. Basically, you will see this behavior: 

gives us all the pairs of keys that we will need to update - without repeat to ensure that a letter does not co-occur with itself. Of course, if the row is , this won't do us any good - we still make \$N^2\$ passes. But if the row is the first one I suggested, it's a big improvement. Regardless, this: 

Lack of modifiability Your , and return copies. This means that once you construct your , it's permanently const. Also, for some s, this makes these functions unnecessarily expensive. Prefer instead for to return a reference: