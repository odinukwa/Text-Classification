Naming of methods, variables and classes Well, it's sample code and I hope it's because of that, but some of your naming is realy awfull. , and shall never speak to me that I know what kind of service it is. on the other hand is well chosen. The same as for names of the DAO's => cDao ... Use constants for (recurring) "magic" String's. 

I did use the same naming as yo but I advice to take better naming. String string => very bad, for what stands it? Now I don't know if there could be a case that multiple conditions are true and what there must be done when multiple conditions are true. An enum has always the same result in the same order. Use that in your advantage when tackling that problem. 

Public class, private Interface? I'm pretty confused by this setup. The meaning is always trying working towards the most highest object( this case interface) possible. I'm thinking that you created this setup so having the keys as constants. But there is nothing wrong to have those keys as in your class self. Java singleton. I can't repeat it enough but if you want a singleton, please think in stead of private constructor. Your singleton isn't thread safe or in this case, while if you use it is, and it's even easier to created it. Abstract class root of all evil? While I do use abstract classes, I'm always thinking also about putting the abstract methods in an interface and use that interface in the constructor. This has multiple advantages of the abstract class. First of all, you can create the base class final so no unexpected behavior could be implemented later on. Then the interface you can swap at runtime (don't forget a check on ) and your class behave different but still in the correct way. As I don't see the whole picture here I can't say it's good or not in this case. But still, think about it, see the advantages/disadvantages and make your conclusion if it's good in this case or not. 

So I'm really not going to speak that way, you are coding smart with primitives, what's also the reason of the benchmark result explains. There are a few points what could be improved. At first sight, I didn't understand why you create arrays of 256 size. After a better look, I understand it but please use a constant for this and name it like MAX_ASCII_VALUE_CHARACTER. While they do not speak over what characters the could contain, I'm tending more to go to the original ASCII table and not the extended, so I would change it to 123(z) or 128(full). Your naming of variable is pretty good, but sometimes you still name them bad. Example : or . While the min is already slightly better chosen, you could still name it like and the other one, you actually don't need it. You can assign the result directly to , check min for and read and from min pair. The reason is that you don't use further in your code. So final conclusion for me : Pretty good and smart code, with some (very minor) points to improve. 

Welcome to Code Review. You have posted an very good quality post and that's why it takes so long to get an answer. I have 2 minor remarks to make. First : 

Atomic Integer is thread safe. Put private constructor so no instances can be made. Only static methods means helper class => make class final. Edit : While @bowmore is correct you could want more generators for each class, you could do the following : 

You put the space because you know you are doing 2 different things, just do that extra step to refactor to 2 methods. 

and the sample method just return piece. This saves already a lot of lines code and does the same thing as your code. Now there is 1 big issue with your and mine refactored code. An Enum should be a constant, but the sample can change. For example take this code : 

I seen a lot of things what can better so I'm glad you came here to learn. First : Your is a normal class. The extends that class and do just calling the super constructor without anything else. Here is a problem : Or you set your first class abstract if you know you are going to have other implementations (preferable with more code) or your first class should be an interface. Second : 

6.Remove commentlines with code. When you have to give code for an interview, do not let commented code standing. 7.Java Doc Write java doc for each public method. 8.Mine solution I have created 2 classes, where one is just a data class. This will show that you are aware of OO programming and you can use it. 

Watch out: I put it here to point it out. If after init the coordinates will not change anymore make it there unmodifiable. So you won't constantly making a new unmodifiable list when you call the getter. 

The is for a testing purpose and to show your code works. A JUnit should be better but oke I can live with that for an test. You init the object like this : . This is actually a good start, but then you go so off. You need to implement a . The class should return you an array with the maximum sum, and this you could print out in the main. 2.Sum of int's is should never be an int. When you are counting int's together you have to take care with the max and min value of int. If your array has 2 values but both max int value, you will have an overflow. So it's better if you declare as long. 3.Scoping variables 

The else counts on what if? Mine intendation clearly says the first if, will the compiler see that also like this? If I change mine intendation, the compiler shall still give the same result, but I clearly mean something else at that point. Putting braces is a small effort to do, you lose a lot more time searching a fault like that. 

I never like to see this hack. It's a infinitive loop with no possibility to stop it. Why not make it a variable and give the user a possibility to stop loop? UIOperations.java Constants 

Memory building up The method design isn't good Why do you need to hold all those and return it later for saving? What if your holds more then 30k entries? Note : This is real the real situation It's stacking up memory waiting to go out of memory. Change the method to or if you want to return the size for a report and save every x entries. (x could also be 1). You have the in the class who provides the save so use it. 

What the hell? I hope this is old code created by resolving problems because otherwise this is actually your biggest issue (In mine personally insight). For the moment you check if it's equal and then reverse the result. There is nothing wrong with just checking for not equal : 

Helper classes You have a nice helper class, all the public methods are static, what is good. There are 2 things I miss. First of all, your class should be declared as . The reason why is so nobody could extends your class and implement other behaviour. Second one is a private constructor, because no constructor means 1 public constructor with no arguments. You don't want people to make instances of your class and hold them somewhere. You are smart enough not to do so, but is your (future) colleague that also? Private static variable While it's not wrong you declare the variable like ,,... in the methods. Why not make a global Like this it's only instanciated once and you could reuse this value in multiple methods (if your class grows in the future). Summary For the rest I can't see directly any issues, but of course I'm also a human being with faults. I really should ask to that programmer who created me why he added so many faults ;) 

So override the finalize of the class and close the connection there. This is called when the class is destroyd. I prefer the second one cause the finalize has issues that it could be that it is never called. As it seems in the comment a nice discussion on this issue :). Second : Open and close your connection before you do an action to the DB. Do a try-with-resource or close the connection in the finally block of the try-catch. Edit : added sample code. 

Why do you do it right for Connection, Statement an Resultset and don't set a modifier before all the strings? The best practice is make them all private and if you need them outside the class make an getter/setter for it. Third : 

Of course I don't know if there is a setter provided for the char, but it works with every setter. At this moment you change the object in the and next time you ask a sample you get the altered version. If you want to proceed this way I suggest returning a new Piece with could be the best way. The cleanest way is to change the to a more factory based system like who extends a factory that implements method. Like this you don't need to override the sample method in the enum but it can change to this : 

Why don't you put the also in the ? It's the only place where you use this field so it could be easily in the . Comments : While I'm not the first to say you have to document your code, the following case is for me strange :