You should avoid making the entire call dynamic because of the sql injection vulnerability. Your procedure needs to accept the parameter you are specifying on your dynamic sql call as well 

Resolving deadlocks can be tricky because you need to be knowledgable about all of the different types of objects and locks and how they can prevent each other's sessions from making any progress. Your stack trace can be used to indicate what resources your process was using, but not the survivor process. Some deadlocks have more than two sessions involved. You have several options to obtain the facts so that an investigation can be conducted. 

Each Go statement lets SQL Server know that the preceding commands are meant to be a single batch. This works for the create statements, but I suspect that if you try to use the symmetric key in a command after the batch, it will not be open. Remove the Go statements, then try to use the symmetric key after the open statement. 

The key to understanding how to manage moving a TDE encrypted database from one server to another is understanding that the private key of the certificate is the only key needed to decrypt the Database Encryption Key in the TDE enabled database. The encryption heirarchy below the certificate can contain different values for the keys, as long as it is fully functional. When the TDE Certificate and private key is restored, the server will encrypted it using the DMK in the master database. If a DMK does not exist and you create a new one, then it will protect the certificate private key with the new DMK. When you execute a command to create a DMK, the server encrypts it using the password you provide and also encrypts it using the SMK, so you don't need to create it with the same password because the server can decrypt it when needed using the SMK. As long as each keys in the heirarchy can decrypt the subsequent key, the TDE will work. The encryption heirarchy in SQL Server is implemented based on the ansi x.917 standard. While backing up and restoring a DMK may not apply to TDE, it works well when restoring a database with column level encryption. If there were no command for backing up the DMK and SMK, then restoring a database with column encryption would require restoring the master database and implementing the same service account on the destination server to regain control of encrypted column data, which is practically rebuilding the server to restore one database. 

I need to monitor the local admins on my SQL Server systems for auditing. Is there a way to use a stored procedure with powershell to accomplish that? 

If all of this still does not resolve the issue, then locate the job for the distribution agent and add the parameter -ErrorFile (path and filename local to the server). Monitor the growth of this file because it might grow faster than you expect, but it will contain more details about the problem. 

SQL Server column level encryption consists of five types of keys. They are Service Master Key, Database Master Key, Asymmetric key, Certificate and Symmetric key. Whenever you implement column level encryption, a complete hierarchy of keys needs to be created and able to decrypt the other keys along the hierarchy. All keys are encrypted in the system at all times on disk and only decrypted in memory when they are in use. There are many diagrams of the SQL Server key hierarchy, which is based on the ansi X.917 standard. For your specific hierarchy, I'll describe it like this: 

Since the only way to encrypt backups natively in SQL Server 2008 R2 is to use Transparent Data Encryption. You will need to back up the TDE certificate and private key used for TDE in the master database and restore it in the master database of either an Enterprise Edition of SQL Server which is equal to or higher version number or an instance of Developer Edition of equal or higher version. A free option for you is to install SQL Server 2016 Developer Edition and restore to that. If you used third party software, you will need to refer to the documentation for that product. If this were SQL Server 2012 or above, then what matters more is the version, which will be in the format 12.0.4422.0, not the edition and also if you have used Enterprise only features in your database. Use the SQL statement below to check: 

SQL Server SSL encryption that is initiated from the server does not require that the client have a copy of the certificate in advance. The certificate and private key are stored in the certificate store of the service account on the server. If the certificate is selected using SQL Server Configuration Manager and Force Encryption is set to true, then whenever a client requests a session, the server replies with the encryption requirement and sends a copy of the certificate, which contains the public key. To establish an SSL or TLS session, the client randomly selects a symmetric session key and transmits it back to the server encrypted by the public key. This random key is then used as the basis for secure communication. It is recommended to use a domain certificate or CA certificate and not a self signed certificate as a self signed certificate would leave you vulnerable to a man in the middle attack. There is also a way to request from the SQL Server Management Studio client that a session be encrypted. I don't see any certificate configuration, so it may use a self signed certificate generated at the client to initiate a secure connection. Either way, you can see if any connections are encrypted using the sql statement: 

I had a server with a similar problem. What I did was to trace the sa account, use the results to determine the permissions needed, then create a new account named SystemAdministrator with the same password and grant the permissions to the new account. Then I switched the names of the two accounts so that the SA account was a regular user account and removed SA from the sysadmin role and changed the password for SystemAdministrator. I also tracked down all of the applications configured to connect with the SA login, which can be identified using the same trace. Once these applications are located, you can add ";Application Name =app1" to the end of the connection string to separate permissions by application because it will be sent to the server as application name or program name. Sessions with a SPID below 50 are generally sessions needed by the database engine to run the server. After switching the login names, you will see that those run under SystemAdministrator. Database owners and SQL Agent job owners automatically changed since the owner sids are saved in the system tables. Refresh any SSMS Object explorer connection before verifying. First, create the trace by going into Profiler or Extended Events and add a column filter for SA. Under Security Audit, you will want to trace the event Audit Database Object Access Event. Run this as a server side trace and specify that the file go onto a large drive. Even though the SA login bypasses the permission check algorithm, it still saves the permissions necessary to execute the statement under a column named permissions in the trace. The following script will use the profile trace file to generate the sql commands necessary to grant permissions to the SystemAdministrator account: 

For all other column level encryption within a user database, backup the Database Master Key, migrate it to the other environment and restore it after restoring the user database. 

If your system crashes and becomes unusable, then you can build a new system and restore the master database over the existing one to recover the TDE certificate as long as you use the same service account on the new system. You should then restart the system to fix the encryption of the Service Master Key by the local machine key. After that, you should be able to back up the TDE certificate or restore the user database and access the data. The Service Master Key is protected by the Data Protection API of the Windows server in two ways, first using the local machine key which is specific to the system and second using the service account of the database engine. Since you will no longer have the local machine key of the original system due to a system crash, you must use the same service account. The TDE certificate is backed up with the database, but inaccessible until the encryption hierarchy is complete. 

While it's true that anyone with read permissions can browse the database using SQL Server Management Studio, additional permissions need to be granted to use the keys for decrypting the data. The first point to keep in mind is that a certificate is a public object, and it's the related private key that needs protection to ensure that it can't be used by unauthorized users to decrypt the symmetric key and subsequently the data. The private key is encrypted by the Database Master Key and is not visible to any user, even to those in the sysadmin role. Just because a user can see the objects doesn't mean they can use them. The permissions needed to decyrypt data using the encryption hierarchy you described, which is a symmetric key protected by certificate protected by the database master key, are CONTROL on the certificate and REFERENCES on the symmetric key. Without both of those permissions, decryption will not be possible. However, if you grant the CONTROL permission on the certificate directly to the user or the user is in the db_owner, db_ddladmin or db_securityadmin role, then the user can back up the certificate and private key, which is a threat to the security of your encryption. In addition to removing the users from the aforementioned roles, there are several ways to address this issue. One is to use an asymmetric key in your hierarchy instead of a certificate, since there is no backup command for asymmetric and symmetric keys. The other is to use code signing and only grant the permissions to a certificate user. Someone also mentioned that it may be possible to use impersonation , or "execute as" in a procedure, but this may not be the safest choice. If you want to replace the certificate with an asymmetric key in your hierarchy, then you should back up the Database Master Key for the database and backup the database, then restore both in a non production environment so you can create the script and test it completely before attempting this in a production environment. If you really want to hide the names of all of the objects, then you can deny view definition to the users in the database. Again, test in non-production first. 

You can use this stored procedure to collect the local admins on the system as long as it runs under the context of a member of the sysadmin role. 

Without a doubt, a new design is needed for step 2. I would suggest that, instead of passing the Database Master Key password, which typically remains fairly constant and is not changed frequently, step 2 would back up the Database Master Key using a randomly generated password of sufficient length. The password can then be encrypted at the source, passed to the destination server encrypted, then decrypted and used to restore the Database Master Key. For this design, you will need to add a procedure, a certificate and a view to the source server msdb database and a procedure and a certificate to the desitination server msdb database. You will also need to create a share folder on the destination server with write permissions granted to the prod server's SQL Agent service account. The objects involved are: 

There are five types of keys in the heirarchy of any SQL Server column encryption. They are service master key, database master key, asymmetric key, certificate and symmetric key. SQL Server contains commands to back up the service master key, database master key and the certificate with the private key to separate password protected files. If you want to have something to preserve an asymmetric key, you can create one from a strong named key file (.snk) that already contains the key pair and save that. For the symmetric key, you will need to create it from a command, specify the key_source and identity_value and save those two values in your Vault. IF you create symmetric and asymmetric keys without saving the inputs, then you will not be able to export them. If you want to learn more about another method of securing the keys, I suggest reading about Extensible Key Management systems, which is a SQL Server enterprise edition feature. An EKM is a separate piece of hardware designed to hold the keys and perform the encryption and decryption functions. 

Step 2 would consist of calling the prod server procedure, followed by a call to the TargetServer procedure to complete the restore. You can use a linked server, osql call or other method to call the procedure on the target server. For even further security, you can drop the private key on the Production Server after backing it up. That way only the destination server can decrypt the password. The password will also be different and unpredictable every day. The other benefit is that the DMK would be deleted every time and would only exist on the share for the duration of step 2, which should be a matter of seconds. This can be done successfully, however, I would also ask if it should be done. If this data is so sensitive that it needs to be encrypted, then should it be available outside of your production system? If you decide against it, then you could just drop the certificate and symmetric key in the target database and create new ones with the same name to avoid exceptions. Any call using these would return null. I've included the view below: 

If the above SQL returns any rows, then you can't restore on Standard, but there are other options. You can backup databases on Enterprise and restore them to Developer Edition, which supports all Enterprise features, if you want, but you can't restore a backup from a higher version and restore it to a lower version. If the database is less than 10GB, then you can also restore it to an instance of SQL Server Express, which is free and will support restoring encrypted backups but will not support taking encrypting backups. You will also need to backup the certificate and private key from the master database on your Enterprise system and restore it to your target system assuming you are not using an Extensible Key Management system. 

When a database master key is created, it is encrypted using two methods. First, it is encrypted by the password that you provided, which in this case is "StrongPassword". Second, it is automatically encrypted by the service master key, which allows you to use the encryption without putting the password in procedures and other code on the server. When you opened the symmetric key, you specified to decrypt it using the private key of the certificate but did not need to specify that the DMK needed to be open to decrypt the private key needed. The system performed that action using the service master key for you. You can see this in the system tables by using the sql statement below: 

To configure server side SSL for SQL Server, you will need to place the public CA certificate and private key in the certificate store of the service account running the database engine and place the certificate without the private key in the certificate store of the java VM initiating the connection. Then use SQL Server Configuration Manager to open the connection properties and set force encryption to yes and select the certificate to use, which would be the public CA certificate, for encrypting the connection. When an SSL connection is initiated, the SQL Server will present the certificate to the java VM and the java VM will find it in its store of trusted certificates and validate it directly against the CA without the need for walking the chain of trust for intermediate certificates. Since the server is on the Internet, it wouldn't hurt to configure ipsec so all traffic is encrypted. Also, It's good that you have a certificate from a public CA because if no certificate is configured, then SQL Server will used a self signed certificate and that configuration will leave you vulnerable to a man in the middle attack. 

First, examine what the distribution agent saved about the error by executing select * from [dbo].[MSrepl_errors] order by id desc in the distribution database. When it comes to poor performance in the distribution database, I've experienced several problems. Besides excessive blocking, which I'm sure you are watching, there are several maintenance related issues. First, I've had virtual log file issues slow my replication in the past. When this happened, there was a noticable impact on performance. To address this run dbcc loginfo on the distribution database. If you get over 100 records returned, it's a slight concern. If you get thousands of records returned, then it's a real problem. Fixing it includes changing the autogrowth settings for the log file to a reasonable value, shrinking the log file, then re-initializing it back to its original size. Unfortunately, the default autogrowth size for data files is 1MB, which should be increased as well. If you don't have this database included in the index and statistics maintenance, you could experience query timeout issues. I once had a specific table in a user database used by a procedure with a recursive function and if this table got fragmented slightly, the procedure would run very long. It is also possible to use Profiler or Extended Events to trace all of the commands that the problematic distributor executes to determine which command times out. Locate the SQL Agent job that runs the distribution agent with the issue and filter by program name using that job name. I'm also not averse to creating new indexes in the distribution database, if necessary. I use the query below to help with this, but don't just create everything without reviewing them to see if you can consolidate.