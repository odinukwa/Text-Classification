Use to set hours, mins, secs,ms to 0 Calculate the A-F hex value rather than a bunch of statements Returns a string from since that is always what is needed Put the multiplication multiples in an array that you can loop over rather than copying code Calculate the final string directly rather than using the intermediate object with first through sixth properties 

FYI, jQuery will also measure the natural width of any DOM element for you so you could also have a span that is styled with the right font that you insert this text into and then ask jQuery what it's width is. jQuery will temporarily make it position absolute (so it will layout to it's natural width) and then let the browser tell you how wide it is. This would be much, much more accurate than what you are doing. Letting jQuery measure it for you would look like this: 

This mostly seems like a layer of sugar coating that just adds overhead and doesn't add any improved functionality over what a javascript object already has. The only new functionality I see is keeping track of a length, but this is a lot of extra overhead just for that. The length could be calculated at any time on a plain javascript object. Here are the analogs to your methods: 

EDIT: This is a new answer now that we see the HTML and understand what the OP is actually trying to do. There is a much, much simpler way to do this. Conceptually, instead of maintaining manually controlled relative positions of every div, we just make them all absolutely positioned on top of one another with only one div visible at a time. To show a new one, we the current one (which we maintain a reference to with an class and the new one. Since they are all on top of one another, it makes a smooth opacity transition from one to the other. Here's a working demo: $URL$ You can change ALL of your Javascript to this: 

Efficiency Correct code is the first order objective. Writing clear code facilitates that because it makes debugging and testing and maintenance easier. Speed of execution matters only when it matters. That is always after the code is correct and after there is an objective performance issue, not just a theoretical one. Getting a wrong answer fast may be worse than no answer at all if we mistakenly believe the wrong answer is correct. 

and the specification suggests that the method use an existing implementation of a binary tree. Remarks on Code details 

Overall The code achieves the most important goal. It runs and produces the correct answer. Using helper/auxiliary methods is a very useful practice and makes the code clearer. Naming As mentioned in the accepted answer, it is standard practice to use lower case for all names. The reason is that historically, the Lisp pretty printer prints in . Using lower case in the source code allows a running program to determine if a source file or other input is machine generated while running...and sometimes Lisp programmers want to do that. Because Fibonacci is in the realm of mathematics, it might be better to use more mathematical names such as and rather than and . Compound names in Lisp are traditionally formmated using dashes. For example, rather than "FooBar", "fooBar" or foo_bar. The in cannot be mistaken for the arithmetic subtraction operator because operators always come first in Lisp's s-expressions. Structure It is not uncommon for Common-Lisp programs to iterate over loops. On the other hand, another common idiom in Common-Lisp is recursion. Because it is common for contemporary Common-Lisp implementations to optimize tail-calls, it is possible to express loops recursively without danger of running out of stack space. Lexical Scope In Common-Lisp new functions can be introduced within the lexical scope of another function using and . The difference is that allows recursive calls and does not. Given that most computing devices provide vast resources relative to historical platforms, it might make sense to default to and save for highly constrained platforms. Illustrative example 

You MUST use in front of variables that should be local variables. You need to be getting the original opacity as the computedStyle, not just reading opacity directly because you need to include style sheet opacity, if nothing is set directly on the object. If you want to know if an argument is truly undefined, you need to use to test for it so there can be no automatic type conversions. I find it more efficient to define an inner function that is called repeatedly because then all of our argument sanitization and what/not only has to happen once, not on each iteration and we can have state variables in the outer closure. 

This version is coded to return for , but that can easily be modified to return if desired (which seems more logical to me). 

You could also consider making the max length be a non-enumerable property of the array so you don't have to pass it to every time. 

You could also remove some redundancy from the table by making the table only be the steem method name you want to call. 

Correct (produces the desired result) Reliable (always produces the desired result) Robust (handles errors appropriately and is not brittle when things change around it) Readable and Maintainable (try working on someone else's code or even working on your own code 3 years after you wrote it) Appropriate Performance (most code does not need to be optimized for performance) 

You can combine the two identical assignments at the end into the same line rather than recalculating the same value again: 

You can rearrange the if/else to be a little more efficient. You can retrieve the length a little more efficiently. And, use (pre jQuery 1.7) or (jQuery 1.7+) with a selector of a parent object close to the elements. That will perform much better than for large numbers of elements. It could look something like this: 

Getting user input can be dispatched similarly by the dictionary. However, the initial state, threading might be justified so that doesn't block or vice versa...that's IO for 'ya. Recommendations 

In other words, must return something that was pushed onto the stack (or an error, but that's an architectural issue not a principle of computer science). Architecture Strictly speaking could return a void and write a message to the console, but it is conventional for it to return something of the same type as the top element of the stack - in the case of reference types, the question of whether it should be a copy [and what type of copy] or a reference to the object itself muddies the waters. The current implementation of points to a larger architectural issue, a low degree of modularity. Currently, user interface is spread across the code and the stack data structure even writes messages to the console. The effect: 

[Disclaimer] This review does not address algorithmic issues. Indeed it dismisses them as inappropriate. To avoid confusion, it should be considered a partial review. Two Conflicting Goals At the level of abstraction where the choice to use Scala makes sense and discussions about idiomatic Scala make sense, the idea of implementing a bubble sort does not. The decision to use or not use Scala is typically based on programmer efficiency. Decisions over sorting algorithms are typically based on computational resource efficiency and raw execution speed of critical sections. Idiomatic Scala is a State of Mind Trust in the JVM and faith in the sound engineering practice of profiling code before worrying about tuning performance is part and parcel of a wise decision to use Scala or similar languages. We've given up micromanaging memory for a garbage collector and high level abstractions. Despite the Curly Braces Scala is not C. Applying "Fortran in any language" with C in Scala will not produce idiomatic Scala. Applying it with Scheme won't either. Writing Ruby in Scala is closer to the mark. Only Write Code that Matters The idiomatic Scala would look something like: 

In the interest of eliminating all duplicate code, here's a way to make the nested showupN pieces of code all get executed in one function: 

Note also that if you want a rejected promise to just get returned as a rejection, you don't have to it locally in an function. If you one of the promises you are using on rejects, that will just reject the promise that your function returns with that error. If you wanted to catch the error locally and do something about it, then you would use try/catch: 

would be more efficient because it wouldn't continue to evaluate comparisons that you already know won't match. It would also be more efficient to cache some values here so you aren't revaluating the same expression over and over. A switch statement could work fine. I would tend to use a switch or an object table lookup if you had lots of different tag names you were looking for. At just qty 3, I'd probably stick to the . Here's an implementation with and some expression caching: 

And, you'd have appropriate CSS for a testItem span (see the jsFiddle demo for details): jsFiddle demo: $URL$ 

Note: this doesn't populate variables , , etc... Instead, it puts the players into an array where they are likely easier to deal with later. 

The last three steps are pretty much the same for all branches once you have the value and know the style name. So, you can move those three steps to a common place and do them once and just set up the appropriate state in the if/else. Also, this structure: 

is pretty harsh (removing all possible styles). If you're just trying to show the menu again when the width has exceeded a desired value, then you can just do this: 

The key element is the use of the library function in conjuction with . performs the task of dividing the list into the part we want to return and the rest of the list which we want to search. The overall design of the procedure is simplified by a structure based on case analysis and a recursive definition of the inner function. Final Thoughts Finding and working with and is, in my opinion, not something a new racketeer without Lisp experience is likely to do. The only way to see them is to be familiar with Racket's documentation and that takes time. 

Create a higher order function that takes a structure and returns a function that can serve as the argument for . The returned function is also a closure over a particular . 

Disclaimer I'm less concerned about how Pythonic the code is than how understandable it is. A Few Observations 

The problem with Dijkstra’s Algorithm here is that there is no guarantee that the target node is connected to the graph, and the code does not appear to handle unreachable goals in an informative way, e.g. 

Avoiding explicit mutation. Pattern Matching. Folding rather than looping over the string. Lambdas rather than named functions. 

General Design The pattern means that each iteration performs IO. Because IO is slow and blocks writing the results of each multiplication to an output array and then batching the IO by writing the output array all at once is likely to improve performance. Algorithm From a pure algorithmic standpoint, using modular powers may significantly reduce computation. This website provides this example: Let us compute 1143 (mod 13). As we saw before we start with squaring this number: 

Duck Typing QuickSorts Tony Hoare's QuickSort was considered quick in 1962. But it was not because it has 0(n log n) average performance. Merge sorting was already established [Knuth credits Von Neumann in 1945] and has better worst case performance than QuickSort. What made QuickSort a quick sort was it's space efficiency. Hoare's insight was in-place sorting. QuickSort was quicker because in-place sorting meant more blocks could be read from tape into fast memory on each IO cycle [and likewise written]. The speed improvement came from reduced latency. Because IO then as now was so much slower than fast memory, the practical performance improvement on non-trivial data was massive. It's common to illustrate functional programming using a double filter for the pivot and to call it a "quicksort". These necessarily avoid inplace mutations. Consider this page of examples in Python. If you consider the Python examples to be quicksorts, then clearly the code under review is a quicksort. If you don't then... Garbage Out Because the Java manages memory deallocation via garbage collection; because the JVM offers just-in-time compilation that may perform arbitrary optimizations of the bytecode, and different ones at different times based on how much time it has due to what else is running; and because modern CPU's utilize multiple levels of caching, simple definitions of "in place" become increasingly brittle the more absolute our definition of "true quicksort" becomes. Welcome to the effects of post modernism in computing. Practical Improvement Issues of truth aside, the performance of QuickSort degrades toward worst case 0(n^2) if the data is sorted in reverse order. Hoare advised selecting the pivot at random rather than sequentially. That is randomly selecting the pivot from the interval makes worst case performance statistically unlikely for any interestingly sized data. Of course, if the data source is known to be random then it's a waste of time. On the other hand, in the real world many data sources aren't random. Final Remarks There are many sound insights in the other code reviews, and there's no point in chewing the same ground. 

In this case, it makes no difference at all. This IIFE really has no reason for even being there because all it contains is a single function. Your code does use any of the usual benefits of an IIFE (like a local and protected scope) or capturing the arguments in a closure. So the additional code that doesn't have any local variables of its own and doesn't use the passed in argument does not benefit at all from being in the IIFE, but there is no harm in putting it in the IIFE either. 

Item 1: I'd suggest getting rid of all global variables except . They don't look like they are needed and just open you up for a potential conflict with other global variables. Item 2: This line of code: 

Just call initially rather than duplicate its code Generate the 5 items in a loop since they are all the same code except a name which you can generate with code in the loop Store the 5 items in an array rather than named variables so they are easier to iterate over. Use only one timer and process all five items in the array from that one loop. Switched to just using one paper object instead of 6. 

There is no native way to do this so your general logic seems sound. Here's some improvements, you might consider: 

First off, your code really breaks down to this logic and I find it helpful to write it out the longer version to full understand the logic flow before trying to shorten it: 

You don't need to use since the data is already in an array. If you just process each file as it is read, you can avoid the iteration entirely. You can avoid some temporary variables. You should declare all local variables with , or as appropriate.