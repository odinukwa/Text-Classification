Another way is to create NFS shares, these should work well between Pi's if you are on the same network. 

You do . You can just use one bigger power supply and cables out. In general it is a good idea to not overload the Pi. So that means if you can power the LCD using the seperate power cables, and wire it directly to the power supply! You should invest in a a slightly supply. Forgot these cheap USB things. I am talking about power efficient that only use as much power as you need AND provides clean DC power. You do not have to break the bank, you can get these of ebay or dx.com for about a fiver for a 3A and under a tenner for 5A. 

It is not common for flash drives to get warm but it is not uncommon for USB devices to warm up quite a bit. It is possible the MCU on the flash drive makes it get hot while you are doing lots of transferring because it has to deal with even wear leveling and smart sectoring. As long as your device is a legitimate, FCC/ECC/EU approved device then you have nothing to worry about. If you bought it from China of eBay, then it MAY be one of those devices that were not approved, and GREY imported, and those MAY cause serious problems. Some devices I have used can get to 60 degrees celsius . That is hot to handle but still safe. As long as you are not approaching 80 or 100 degrees celsius you are OK 

The same applies in embedded devices like tablets, just the only thing missing, is the standardised link, because there is no point in adding more components for interfaces, since its embedded and not designed to be replaced by a bigger LCD, cause it wont fit, or to be used as a stand alone screen. The LCD is connected to the GPU in whatever way the GPU vendor finds it is best way to do it, and 90% of the time, non standard. The operating system has a graphic layer which needs a driver to communicate with the GPU in a standard way, like DirectX but more like OpenGL. Then DirectX or OpenGL uses the driver for the GPU. The rest, is unknown to the OS. Making things even more complicated is that GPU and CPU are usually embedded into single chip (SoC) with DMA access between these two systems. Meaning that the CPU must be running in order to communicate with the GPU, which requires more drivers, running on an OS, which requires a working tablet. Connecting any kind of LCD directly to a Pi is practically impossible mainly because there are no specifications on what to connect where, but mostly because the GPIO is not even fast enough to deliver such data to the LCD - Since the LCD has a "driver PCB" which, is specific hardware to decode specific data for the LCD to operate. Trying to do that in software would be painful and a waste of time, since even the same tablet models, may use different versions of an LCD, produced in separate parts of the world, with a slightly modified GPU (very common in Apple device) The Raspberry Pi has a CSI port, which is like their kind of standard way to connect an LCD directly to the GPU, but the LCD needs to support CSI (with additional hardware drivers), just like connecting a desktop screen requires and HDMI or DP cable. 

you should get ANY library working on your hardware setup to make sure you have wired your thing the right way. usually libraries include sample code, that could be run with minor modifications only, like changing pin numbers. after you made sure your hardware is setup properly, you may try to convert C code to your C++ project, basically by adding .C files to your makefile and wrapping function declarations in 

your error message clearly says: "* "System not configured - see README", that means you haven't configured your build system, it has no idea what board you need built for, and details about configuration could be found in file -- read it and get enlightened. most likely the following command will do the trick: 

where the password is coming from? since this command is supposed to be issued by daemon, you'd better replace it with (no ): 

programs do not really work well with start/stop/restart logic, you may have more success trying to start your program from , just don't forget to make it an executable file. 

it's not booting because you've cleared up the partitions and messed around with parted. you may fix this by downloading a NOOBS installation image and following the instruction about how to copy it to your SD card. 

1.5MB/s is a bit slow, you should have used in your command. the rest is fine too, my RPi also has 2 partitions: 

hanging wire works as an antenna. it's absolutely correct to read random values from the port connected to the nothing, you should not worry about it much. when you use push button, you'd better use pull-ups or pull-downs to avoid input pin floating in the air: 

you should connect the TV to your RPi to find out what's going on with the network, is it working properly and what is the allocated IP address. after that, you may try to check if is actually started and listening to the port. and please, don't tell us you don't have access to the TV. 

I have several of these modules. The problem with the slow ping is a bit strange? It should be less than 1 second, even more like 100ms. The other problem is this module only supports GPRS (115kbs) if your GSM supports dual band GPRS (or 2.5G). Most networks do not support this any more (or are deliberately switched off because it affects voice) so your speed is only going to be a max of (57.5kbps) and even that is optimistic. I would say you are getting about ~36.6kbs. Ping should be good at these speeds but browsing modern websites is fatal. It doesn't matter if you have 3G/4G or better in the area. The reason is that GPRS extends the GSM Circuit switch and the more people logged on within the area the slower things become. So what is this module for then? Well, at 8 bucks a piece its great for sending compressed JSON to servers for logging data. 

If you just want to read the files, you can install nginx on your Pi and share the directory that has the files you want everybody else to read. This is read only, is pretty simple and very light weight. You then get your files by using anything really. 

Others I searched allot for various products and all the ones mentioned fit my budget of CHEAP AND CHEERFUL! Cisco offer newer SPA's that are faster, have more FXO's and other gadets Other I do not work/am not ascociated with any of those companies. I use the SPA3102 at home and I run a production server using Elastix(not Pi- A proper i5 with 8GB ram). I tried FreePBX distro and clean Asterisk- They are really difficult to customize things if you are a bit of newbie. Elastix is a nice complete package that is easy to use. Be aware that if you are going to use and Cisco products in the UK- Buy a BT to RJ11, and a RJ11 to BT converters(even with the -UK version!). Otherwise you will scratch your head as to why there is no dial tone! Arrrrrr. Caution You cannot jsut connect PSTN to the Raspberry and hope that Asterisk will translate the call. Connecting PSTN to any uncertified device in most countries in the world is ILLEGAL! Tampering with TELCO phone lines can cause injury (because the TELCO line has a different impedance than you ground at home- this can cause you 110/220v shock!) and if you damage their systems because of improper use the fine is in thousands and even jail! Just buy a cheap and cheerful FXO/PSTN gateway and run Asterisk on the Pi (it can handle a few simultaneous calls on 1.8 without transcoding) - Do not try to reinvent the wheel! 

Providing that you've set up your Pi's wifi network (otherwise follow a tutorial on how to use hostapd), you can easily use the DLNA function built right into Windows to send media content from your PC to your Pi. First, you want to be running Kodi on your pi. Then enable the UPnP client and connect to your pi's network from the PC. Then you want to right click media files that will now appear with a cast to option. Make sure you have enable network discovery! For streaming with other programs such as Edge, follow this. 

To enable SSH for headless machines: For headless setup, SSH can be enabled by placing a file named ssh, without any extension, onto the boot partition of the SD card. 

Which Raspberry Pi are you using? Only the RPI 3 has onboard WiFi support. If you're using another model, then you'll have you to get a usb WIFi dongle. If you do have one, make sure it is supported Raspbian. Some dongles are not and that could be a cause. To verify, boot up to the PIXEL desktop and on the top right toolbar, you should see a wifi logo which you can use to connect to hotspots. If that is not present, then your dongle is not connected. If you're desperate to be able to connect to a WiFi network, you'll have to buy a support dongle such as this one 

You could have a node.js application running on your Raspberry Pi that will receive data from a backend database. An example of this is using Google's Firebase solution. Firebase supports Node.JS and Android applications with lots of documentation. Your app would push data to the database and your Node.JS app could listen for updates on the database and will parse it accordingly when it recieves one. This would work on any network that has Internet access. $URL$ 

use another linux box to read and backup your favourite files from SD card, then reimage fresh Raspbian build and put files back again, this might be the easiest and fastest way to recover from broken file system. additional points if you use another, preferably new, SD card for the new image. 

you should set the baud rate in your serial.Serial(...) command, otherwise the camera might not recognize whatever command you're sending there. something along the lines of: 

disable all authentication methods except the password generate RSA keypair and copy the public part to your RPi (preferred) 

you should to your HDD before issuing this command or specify full path along with . You should get something about 20-30 MB/s for your HDD. This would tell you if the bottleneck is the HDD or your network setup. 

cron scripts most likely lack variable, therefore you have to specify the full path to your executables, that you could easily find using: and , and your script might look like this: 

will copy the whole SD card. I'm not sure about the naming system on the computer you use, but most likely you'll be able to find the proper partition name using command : 

the partition contains some stuff that gets the linux running (it's much easier to read FAT than correctly process ext3/ext4 partitions in the boot loader), the rest is ext4 -- that's where your Raspbian and your files live. 

This question does not belong to Raspberry Pi, it's more a common Java programming question. To be able to read large streams, use loop: 

The shift register is such a funny thing, that will push "0" or "1" down the chain until the end, so once you reset Arduino_1, there's nothing you can do to avoid resetting Arduino_2 and the others on the next shift register clock. You definitely need a better HW design.