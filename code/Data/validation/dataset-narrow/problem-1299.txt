Note: I'm no expert on these engine specifics. I'd rather leave these types of details to someone else to provide for me so I can focus on building games instead of implementing an engine that is likely going to be inferior to one that others have already spent a lot of time and effort to get right. I've learned enough to know why and how but explaining it is a little beyond my experience. Hopefully I'm not sharing incorrect information or missing any important details. 

Yes, you can modify the default 3D objects but it's not as simple as you might hope. There are no controls in the editor to modify shapes, if that is what you mean. You can modify the mesh however you want using code though. Although, how to do that is too much to explain here. You will need to investigate the Mesh component and it's functions. Check out some examples of how to build your own mesh and figure out from there how you would modify or create the shape you want. Here is an example that shows how to create a plane (flat square) mesh. 

Blend over some distance. This is usually the best looking but requires that you have tiles that can be blended. This works well for grass, dirt and water terrain textures, for examples. A simpler approach is to use decorations/fringes to hide the seams at the boundaries. Similar to how the wood trim around your door hides the ugly gap between the door frame and the drywall. Example. at it's most basic, you might use randomly strewn rocks, bushes or trees to cover up the seams and break up any obvious straight lines. 

Here is a simpler, more efficient way (and correct way) to write your box intersection test. This is called AABB (axis aligned bounding box) collision detection. You can do it the other way also (by testing for inclusion), but this is cleaner and actually faster since there are less tests that need to be done. 

I've never worked with GTA mods but assuming that if you can't actually get LastVehicle when outside of the car (which seems unintuitive to me, given the name) my guess would be to track the last vehicle yourself. When the player is in the car, store LastVehicle as a variable. Then you can refer to it whenever you want. Update (how to store LastVehicle as a variable): It's been a while since I did any VB coding and as I said, I've never done any GTA modding so this is just a guess but hopefully I'm not too far off... 

If your OnClick handler is in a script attached to your button prefab then you can do something like the following: 

You've covered the basic ideas in your question. Which method you use depends on your requirements. You might use a combination of approaches. 1. Make the image 320x240 and scale it up on the larger resolution (will look pixelated) Do this if you don't need higher detail and just need to show the image larger. Good for low detail images like old-style sprites. 2. Make the image 400x300 and scale it down on the smaller resolution (loss of detail) Even if you were to create a separate image for lower resolutions you will still lose detail, but in many cases it doesn't really matter much. It's a compromise. 3. Create two separate images for each resolution (size bloat) This one is not quite right, but close. I can't think of any game that has different images for each resolution unless it only supports a couple sizes. Once you start dealing with many screen sizes, this is unfeasible. What some games do though is create a high-res and a low-res version of the images and choose the best match depending on the screen resolution. What you are missing however is mipmaps, which is similar to #3 but a mipmap is stored in a single file and follows the mipmap format which is supported on the graphics hardware. Mostly these are just scaled computationally but you can edit them like any other image to fix loss of detail and other oddities that come up because of scaling. The mipmapping also doesn't correspond to screen sizes. Each level of the mipmap is 1/2 the size of the last, so it still uses a best-match approach. This is what most modern games do if they need different image resolutions. 

Basically, you are on the right track but you need to search for the component in the children of the Button object, not the button itself. Key problem is instead of . The NullReference error is because the Text component was not found attached to the Button, so it returns null. 

It is difficult to answer these questions with much clarity because they are conceptual and the concept applied to each of these could be widely different depending on the engine and needs of any particular game. So I'm going to try to be fairly general. 

If your DLL is free-standing. IE. does not need to reference Unity, then you should be fine with either framework as long as it is supported on your target platforms. Otherwise you will need to use one of the Unity frameworks. Unity does not support the NET 4.0+ frameworks though, so you are limited to 3.5 or lower. 

If you use the 64-bit version of the Editor then you need a 64-bit plugin and vice versa. If you are using the 64-bit editor but are also targeting 32-bit platforms you will need two versions of the dll. Here is a related discussion that may be helpful to make it more clear. Here is another discussion, that explains how to import and configure both plugins side-by-side. 

Yes, PS3 controllers are a different configuration than the Xbox controllers. XBox maps to XInput while PS3 is proprietary. If you treat Button 1 on all joysticks as the fire button, then yes it will be inconsistent. The problem gets even worse if you assume the axis's are the same. Fortunately, you can map them however you want in Unity's Input Manager. Just don't rely on the ordering of buttons. Map the controllers to actions and then you don't need to worry about if the controllers match or not. On the downside, if you want to support many different controllers that may have varying configurations, then you may be limited by using the input manager. This isn't a problem though until you have 80 mappings or more than 17 different controller devices to support. Fortunately, most aftermarket controllers are DirectX compatible, meaning they will conform to the xbox configuration. In the unlikely event you need to support lots of different devices, you might want to look at Unity Custom Input Manager. It's free, and even if you don't need to support so many devices, it's worth investigating. It lets you do some things that the builtin Input Manager won't. Like modifying the mappings at runtime (EG, let the player customize the mappings in-game).