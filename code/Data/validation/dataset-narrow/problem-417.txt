The one obvious thing I see is that you are consuming the input. I'd suggest you try using slices instead, so that you don't consume the inputs and you don't have to spend time and memory splitting the vector. 

You can take this farther, but the idea is to produce a single source of truth that you can stare at REALLY HARD to confirm it is correct, and then have everything else look basically the same. This doesn't apply to the pointer scenario, obviously. But in that case you will probably want to define a macro for the loop body, so you can repeat it easily. Assembly Your compiler has a command-line switch that will produce assembly code as output. It might be (gcc) or (msvc), but it's there. Use it! If you're not going to enable optimization, then you are going to have to measure the effects for yourself. One good way to do that is to look at the generated assembly and see what result a particular change produces. Honestly, this is difficult. But if you focus yourself down to a small section of the code - the innermost loop - you can generally figure out what is going on. And for the most part, shorter is better. Optimization You don't say why optimization options are not available to you. Unless this is for some class assignment, I'd encourage you to try enabling optimization anyway. One thing you might do is split your code. Move this one function into a separate source file, and get it to compile and run okay. Then start building your project however you usually do, but configure this one separate file to use a higher optimization level. That might get you around whatever blockage (technical or political) you are encountering. Of course, good unit tests are essential for this. 

Note the changes to , but I kept the subdirectory %d separate to allow Path's operator-/ to do its magic on Windows/Unix paths. 

I would suggest focusing on the nature of the answer. The requirement is to return the highest possible values, which also means the shortest sequence. So I would suggest you start at and work your way down, checking increasingly long sequences until one sums to greater than , in which case you can restart at , etc. 

That code is a mixture of "things to do at the end of the game" and "things to do in a loop." Mixing things like that is a mistake. First, because it requires you to check your conditions over and over (which is inefficient). And second because you are flipping back and forth: he's in! he's out! he's in! he's out! This is unnecessary complexity (violating the KISS principle), and it doesn't keep related things together. Instead of jumbling all these conditions together, ask yourself: what things go inside the loop, and what things go outside the loop? Obviously, winning or losing the game is "outside the loop" because in either case you won't be asking for any more guesses. Similarly, reporting if a single guess was right or wrong is inside the loop, because then you will ask for more guesses. Consider using the or the statement to short-circuit the rest of the loop body. Like this: 

The collectively exhaustive events are not going to change or be updated. So use a tuple instead of a list: 

You can call from inside after you call . You might even put in a loop to play multiple matches. Animate Let's have a look at your in/out functions: 

You can use the method to provide a default value instead of catching an Exception. This makes your computation a single expression, which is good for further inlining: 

You're inside a loop on . There's no reason to check for game-over, because when the game is over the loop will exit and you will fall through to below the loop. Better to simply write: 

Ignoring the lack of a leading capital letter, and no ending punctuation, why is this line where it is? This is clearly the "start of the game." That's fine. But at line #2, you aren't ready to start the game. There's a bunch of variable initialization and other things that need to happen before the game starts. This line should be moved down to where all the rest of the user-facing code is located. Keep related things together. Let your code speak for itself Your comments suck. There are six basic questions you can answer: Who, What, Where, When, Why, and How? Of those, three are only used in intro-to-programming courses: Who, Where, When. If you have to put a big header block at the top of your program with your student id, name, course number, professor's name, etc., that's okay. Just do it once, and we will all skip right over it! The other three- What, Why, and How- should only be used if you can't actually answer the question with the code itself! Specifically, if you can't choose your variable, type, and subroutine names in such a way as to make the answer obvious. If you can make the answer obvious, then don't add a comment. It just wastes my time, and annoys the compiler. To wit: 

These two functions are all but identical. Replace them with a single function taking a character parameter: 

But we can do better! That's just looping over a bunch of things, performing the exact same computation for each: we could use a list comprehension or a generator expression, like so: 

But really, you should not be writing this function at all. The point of your UDF, if I understood correctly, is to evaluate its arguments and return one of them unchanged. So, just do that: 

Here's a link to a useful blog post. So let's see... if the cell state at some location is not the map border, then change the cell state to and print some kind of debug output and . (Seriously? What is ? Did you mean ?) I'm going to ignore the fact that you're skipping over a check for another obstacle, because I can't read your code. It might make sense to do that. But each of those blocks - which are so long, and so "common" that you deliberately folded them up onto a single line - is really the same code over and over again. And in the 1970's they had a mechanism for that: functions. So why not write a function to handle all that code for you? 

Encapsulate! You pass into as a parameter. So why are you calling ? Why don't you encapsulate this in your ? 

My take-away is that your code- as written when you posted this- is close enough to "doing nothing" in performance that tweaking it just produces noise on this benchmark. Sooooo.... you need another benchmark! Possibly several benchmarks. You should save this as the "creating arrays" benchmark, and add it to your perftest directory (which you don't have... yet). Then maybe create some other benchmarks, reflective of actual use cases, which we can use to hammer out the performance of objects when the arrays are actually accessed, instead of just creating them. Edit: Also, if slicing is actually used it probably deserves better treatment. There should be a way of copying the json and actual versions in the initializer. 

You mentioned that you were trying to get this working, so I'll give you a pass on it for now. Problems in I switched to compiling and found one warning: 

This may tend to make your last loop iteration cleaner, and impose fewer constraints on your generator. How Enhanced Generators Work Generators are functions in Python that make use of the or statements. We'll focus on because that's all we need. You can create a generator like this: 

The first unmatched curly is usually the beginning of scope in curly-brace languages (C, C++, D, Java, Perl, etc.). The corresponding closing curly is usually the end of scope. There are special cases in some of these languages. But they're special. You will go far if you just assume that your scope ends when the enclosing curly braces are closed. This means that variables used in the control expressions of loops should be declared (& initialized!) outside the loop body. And it means that any "result" you want to carry out of the loop must also be declared outside the loop body. Structure With that said, let's talk about the structure of your code. I see you have an function defined in class . Have you noticed that it's the wrong place? You have several classes that want to "talk" to the user. That's a problem- it's hard to write a function in several different classes. Instead, let me suggest you create a class that can display messages and present the user with a menu of options and return a valid item from that menu. It may also query the user for non-empty strings, and whatever other things you need it to do. You can pass an instance of this class to your other classes so that they can use it to communicate with the user. But I'd recommend you create separate classes or methods for things like constructing a Character. Define a "createCharacter(textui)" method on Dungeon that talks to the user and then calls with the character-class, name, and whatever user-given inputs you want. Subclass, don't switch When you find yourself writing a statement in an OO program, ask yourself, "Does this indicate a subclass?" In your case: 

You can then define getRow and getColumn as calling the common underlying function and passing a different string: 

Update the pointer to that node. Note: It's important to note that there are two possible structures being pointed to by . In the first case, is initialized to point to , so might be pointing into a . After the first node, you update with which will be a pointer to a . So the double-pointer points into two possible kinds of struct. That's awkward. 

You might find that many dungeon creation tasks are made easier by defining iterators. For example, if you want to randomly generate rooms and hallways you could define and . (Be consistent on how you handle the end position: inclusive or exclusive!) 

I'd suggest that you add one, or maybe better two blank lines above the grid when you draw it. This would provide a better edge to the top of the grid, and (2 lines) suggest that the grid belongs to the text below, rather than the text above. Also, you might consider filling in the grid, or a second copy of the grid, with the available numbers not yet chosen. That would make it easier to play. At the very least, print the grid with available numbers after an invalid selection is made. Next, the code. Globals You rely on global variables too much. I don't know why you have at global scope - it's only used locally in one function. The , , and variables don't need to be global. They can be passed as parameters, or computed, or returned as results into local variables. Packaging You really should package the "game" into one more high-level function. There's a standard Python idiom that applies here: 

You are maintaining as a queue rather than as an unordered collection. All new animals go on the end of the list, and food is assigned from beginning to end. This means that you are disproportionately killing babies. While this might be correct, in a simulation sense, it does not appear to be explicit - that is, I don't see anything that indicates you intended to kill babies first. So I'd suggest that you either (1) make your intentions explicit, or (2) randomize the allocation of food. 

Parameter Order The search function puts the first, then the details of the array to be searched. Why? Because the key isn't related to anything else in the parameter list, and it's the "important" thing in the search expression: Find me a needle! In this haystack, of such and such size. Use this comparator. I'd suggest you reorder your parameters to conform with this. Not only is it a more sensible arrangement, it keeps your search function consistent with the "standard" search function. That means less to learn, and less chance for a silly bug. Parameter Names 

Finally, if you subclass and you can store dedicated offset tables for them, and add support for forward and en passant captures. (Note: I'm waving my hands pretty hard in the en passant section, since I haven't looked at the rest of your code.) 

You have a very non-specific loop, but a highly-detailed set of operations involving your output stream. I'd suggest that you find cases like this - where you are really drilling down to handle some very fiddly detail - and abstract them into a function whose name reflects what you are doing. Like this: 

I looked at this, and had trouble understanding almost all of it. You've really gone out of your way to chose coding a coding style that's opaque. (This is easy to do in embedded programming for some reason - you have to make a deliberate effort to craft your code in an open, approachable fashion. Please do so.) Abstraction For example, your sensors have numbers rather than names. This is just stupid. What are the chances that a robot engineer will add sensors to her robot? 1. A robot engineer is like a teenager with a crappy asian car: they are compelled by some mysterious force to tinker with it! You must assume that your "constants" will change! 

This code loops over the offsets (I copied it from your King method). And it "zooms" in each direction - repeatedly adding the same offset to the 'candidate square'. So instead of writing four different loops for moves in each direction, I can use this same method for any "zoomy" piece, including the Queen. All I need is the right offsets table, which can be a piece of class data. In fact, if you allow the "zoom limit" to be a class constant instead of using you could use the same code for all the pieces, with the "zoom limit" being 1 for kings, knights, and pawns. Going further, kings, rooks and pawns have special movement options (castling, first double-move) that is only available when the piece has never moved. So you could add this: