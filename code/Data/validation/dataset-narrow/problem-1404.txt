What kind of multiplayer server you are going to write? Is this just a lobby server for setting up peer-to-peer games? Is this a full on multiplayer server that is dedicated to hosting the game and communicating with clients (like Counterstrike servers, for example)? Or are you wanting to add multiplayer capability to your game in which a player starts a game that others can join? If the last variant is what you want, XNA/.NET do provide some networking classes. If you want to create a dedicated multiplayer server, you should do as HydroxicAcid says and avoid using the entire XNA framework as you will not need much of what it provides. What you should do is isolate your logic from your rendering code (in separate assemblies!) so that you can reuse these classes in your server application. You'll want to look into serialization over a network of figure out some lightweight message format for transporting gameplay data. There may be some instances where a 1:1 match between how a game object is represented on the server must be very different from how that same object is represented on the client, so be prepared to deal with that. If you want to create a lobby server, you probably don't need to even write it in C# or use the .NET framework or even run it on a Microsoft platform. Its sole purpose is to find other people that want to play the game and tell them about each other, so there will likely be no need to reuse any existing game code for that. Whatever it is you're looking to do, you can find a lot of good resources on AppHub => $URL$ 

You're reloading your images on every frame. Don't do this. Also, you'll be doing yourself and others who read your code a favor if you clean it up. Make sure it's indented properly and don't use raw numbers for image or sprite or whatever other type of object ID. Also, don't use extremely short variable names such as and . I was able to work out what these referred to, but I had to put some time and brain power into it, which is less brain power I can give toward helping you with your collision problem. Improved version of your code, much easier for others to read and help you out with: 

Disclaimer: Purely going off of my systems class knowledge. I originally thought, why not just use a hash function on entity ID for your index? That way you'd get 

Unity's on collision event gives you a Collision object that gives you some information about the collision that happened (including a list of ContactPoints with hit normals). But what you don't get is surface normals for the collider that you hit. Here's a screenshot to illustrate. The red line is from and the blue line is from . 

Yes. Otherwise you get the "machine gun" effect," which sounds like its name. It's especially bad with multiple impact sounds. For quick, repeated sounds, you typically grab a few different-enough samples, and then trigger each of those with their pitch subtly adjusted on each instance of the SFX being triggered. 

How do you pros out there implement footstep sounds in so that they're synced with character animation? I have an idea in mind: an FMOD event that has two footstep playback triggers, and a parameter that controls how fast each plays back in sequence, and the event is triggered as soon as the animation is on a frame (assuming the programmer handling animation will post an event or update a param for this) where you could reasonably assume the character's foot has hit the ground. Is this overkill, or assuming too much accuracy out of an engine? This is not a specific project, but I am working on integrating FMOD Designer support into an existing engine and am thinking of some general effects to implement while the audio spec is being figured out. Also, I mention FMOD since that's what we're using, but if anyone's done similar syncing tasks in Wwise, XACT or anything else (or heck, even if you hand-coded it) and could share their experiences that'd be great to hear as well. 

You always want your client to be requesting things from the server. Speed hacks are normally achieved by setting the movement speed illegally. For instance, if there's a "speed power up", "mounted on horse", "flying", etc...the hacker sets the movement to one of those states to get faster movement. A basic anti-speed hack is checking for a maximum velocity that the character can never go over. Figure out how fast they will ever be moving, if a character is ever over it, disconnect them for speed hack. 

I wasn't sure if calling .Stop() without music playing would throw an error, if it does, that's when you could do 

Which you can probably derive what each state does for the user. You could add in a state of "cinematic" or something of that nature. I've never used libGDX, but essentially you "manage" game states by just not calling certain functions. So to "Pause" a game, you'd set the gamestate to paused, which would not call the function that updates game logic. It just sits there, looping to receive input, so it can to be told it can call the game logic again. 

Can you? Yes. You would need to capture all the packets sent from a client, and the return packets expected from the server. This is a super long and tedious process to decipher packets, if encrypted packets, you need to decrypt. You would then need to write the entire server logic to interface with your newly understood packets. The process usually evolves getting the client to accept a login into your custom server and going from there, step by step, figuring out what packets need to be exchanged to keep the client going barebones. This is how private servers are made for AAA games. Some sample tools might consist of $URL$ to monitor network activity. 

Make sure you right click -> properties on each shader file and set the Shader Type as well. The property right above the shader model in your graphic. 

In a large game this would be unfeasible, however for a small pac man clone it works great. You just detect the pixel color of the collision map they are trying to move onto by its coordinates. You will always get a RGB(0,0,0) or RGB(255,255,255) back. If it's white, don't halt sprite, if its black, stop movement. 

This is the basic idea of what you want to achieve for a seamless world. However, if left at this basic approach you will incur what is known as "image popping". When the player gets to the boundary of that zone, he will see nothing, and then, BAM, the entire zone is pushed into his screen. So, while this is the right step, it has some issues. 

I don't want to recommend this because I hate loading screens, but if it's an issue with graphics lag etc, you might have to throw up a loading screen when gm teleports them. Or, just let the elements pop in. It's fun to watch sometimes. 

You could sum it up like such: Pre-game install: You can't assume they are there. Post-game install: You can assume (hope) that the XNA 4.0 Redistributable installed correctly and the assemblies reside in their respected locations. If the scripting that the user will be doing is tested and run solely in game, then I would think that this is a safe route to go to assume the assemblies are in place or the game wouldn't even be working. If you create some kind of "scripting editor" it's probably not going to require the same assemblies as a game. Like you stated in your question, Vector3, etc are MOST LIKELY not required to build a "text/script editor", and therefore it wouldn't be safe to assume they are. As always with XNA Games, make sure you include the appropriate Redistributable and you will be fine. 

Like Ray Dey said, you need to make the call on quality vs size. Remember the project triangle? The same applies to audio. You can have good quality audio that doesn't take up a lot of space, but you'll have to manage streaming it and you're often limited to a set number of streaming channels on non-PC hardware. You can have good quality without streaming, but it will take up a lot of memory, etc. Something to check out, if you are working with composers who would be comfortable writing the music in trackers, you can use FMOD (iPod/Pad/Phone and PSP license is listed under "Casual" on their Sales Page and is $500 flat) and load .MOD, .XM, and .IT. You can have high quality samples and fine-grain control over the flow of music. 

OpenTK is being used for MonoGame. MonoGame only supports the 2D api of XNA at the moment unfortunately, but you mentioned you had some OpenGL experience so you can use the OpenTK wrapper to do 3d graphics. You could also probably find a few scene graph libraries that are implemented in C# or in C++ with C# wrappers. For audio, OpenTK wraps OpenAL, or if you want something more robust and plan on releasing the game as freeware, then FMOD doesn't cost anything to use. It gets pricy if you want to charge for your game. A cheaper alternative would be BASS. 

You also aren't using that for loop in there, just running your set of if statements twice for no real reason. You need to think more about how to solve this problem. I would avoid using DarkBasic's collision. Keep track of the positions and collision rectangles yourself, you'll learn a lot more. This site does not respond well to posts that are just making us fix your code. The Game Creators' community site has plenty of resources and of plenty good examples on how to implement a pong game. Use it, and do a little more homework instead of just dumping code here. 

The Content Pipeline is not for your game's save data. What the Content Pipeline does is allow you to import assets (whether it be sounds, textures, models, XML files, or whatnot) to your project and compile them into an efficient format for distribution with your game. It may seem like this is somehow limiting, but having this easy-to-use unified framework for handling asset compilation is a huge deal. The way you save game files on XNA is via the storage API in the namepsace. On XBLIG, these classes handle saving data to memory cards or the Xbox hard drive. On Windows, this typically saves to the user's or a similar location (the specifics are in the docs). If you're targeting Windows, you also have the option of using file I/O to save and load data. Look at the namespace, and more specifically, the class within that namespace. 

If your characters' footsteps sound different enough, then yes. It's also common to split it up into small, medium, and large footstep sounds because, for example, are human and elf sounds really going to be that different? Save on the diskspace and memory and reuse some sounds. 

The wording of your question suggests a misunderstanding of how Unity works (please correct me if I'm wrong), so I'm going to recommend you just try out Unity. "Unity3D scripts" are just .NET classes that inherit from or . There's nothing stopping you from writing freestanding C# classes or pulling in .NET libraries (assuming they are compatible with Unity's version of Mono, which seems to cover the important parts of .NET 3.5). Whenever you create a dependency on something not included by default in a Unity release deployment (ie: ) Unity sees your statement, sees what members of that namespace you use and automatically bundles in the correct assemblies from the standard Mono distribution that it includes (you can also drop in your own .NET DLLs). So long as any third party .NET code works in the .NET 3.5 subset that Unity's version of Mono supports, you can use it. Be wary of libraries that provide too much abstraction, though, or at least use them sparingly. This is game development, not enterprise software. We do some dynamic scene construction in our Unity project, and all of the data for that is handled in pure C#, no namespace references except for where it wouldn't make sense to re-implement a data type that Unity already has (ie: ). We reference and could use JSON.NET if we wanted (but that lib's a little fat, so we use LitJSON instead). 

Since this is a small game, I think a 2D collision map would work great...that's what I call them. I don't know if that's the correct name. Basically, you have an image of where they can move, defined by 2 colors. Black, White. In my example they are allowed to move on the white part. It's a duplicate of the play screen but just containing 2 colors. Ideally your sprite that you want to move would be the exact width of the movement lane, so that it would move in the appropriate directions. There wouldn't be any small pixel movements to the sides. 

No, no, don't do that. Ram is MUCH faster then the file system. Not too mention, you need to have room in ram to pull in that data, so if you're blocking room for that data...just read it anyways! 

The game screen shot you posted is a 3D game. In a 3D game, the objects are drawn using vertices to draw actual 3D objects, which are then colored, textured, so forth. In a 2D game, the objects are taken from sprites / sprite sheets, etc. The difference between the two is how you can view them. A sprite is like a flat piece of paper. You can not view it at a different pitch or angle or the sprite will be skewed. On a 3D object, as the camera moves, you can see different parts of the object because the object is, well 3D. In a 2.5D game you are combining both of these worlds. Keep in mind just because you can't move a camera to see different angles, doesn't make a game not 3D. It's the objects that are in it that determine this. A good example of a 2.5D game is Ragnarok Online. What makes it 2.5D is that the world is mostly compromised of 3D objects. Buildings, landscape, etc are textured 3D objects. You can rotate the over head camera and see different sides of these objects at the same time. You can view the front side of a building as well as a left/right/roof area. The players however, are 2D sprites that are positioned to appear to be standing upwards. If you rotate the camera too much, the game must load a different cell of the sprite sheet for that character to change how it appears to be standing. You can not view different angles of the character because they aren't 3D. The angles are dynamically loaded in depending on the view of the camera. $URL$ This is a sprite sheet from the game. If you were to just look at it, you would assume it's from a 2D game. Alone, you would be correct. But once it's placed into a 3D world, you have a 2.5D game. 

You would be correct in your assumption that you need to create a better "Game State Management" system for use in your game. This is how you control how the game is working. Think about when a game is Paused. Nothing is happening, it's just waiting for the User to un-pause the game. This is essential in what you would want to do. A basic GameState might consist of an enum like such 

There are a lot of easy to ready gamestate examples written for XNA...even if you don't know c#, you could understand the logic just by looking at them. I'd suggest studying them. 

This is more of the complete step to your previous idea was looking for. Now, you are essentially buffering the viewport against image popping. This is a much better solution then the previous.