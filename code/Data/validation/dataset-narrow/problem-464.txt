As a result, you could eliminate the Calculate button. The end result is that your code-behind for the form looks something more like the following (minus the click handler if you decided to go with auto-updating ): 

One way to use an IDataReader's nice GetX methods is to start off by retrieving the indexes with GetOrdinal calls: 

Adding more test cases is just a matter of adding elements with new data and re-building/re-running. The How-To MSDN page can be found here, and some examples of DataSource configuration strings can be found here. Just to give you a taste of this in other frameworks: NUnit TestCase 

That saves having to deal with creating a new object and deal with a Regex Pattern There are a few things I would change: 

all the things With the addition of the operator in C#6, I use it wherever possible when referencing the name of a member. In , this is useful for all your s: 

I don't know your feelings on indenting using statements which are right next to one another, so I left it with default formatting. 

Note: I suffixed my properties with 2 so I could run them side-by-side and compare results to be sure I didn't miss anything. Note2: as Jesse suggests, you should ideally cache the results. 

The downside is that you have to declare the initial function as a Func type to start the chain. You cannot use the method group or a lambda directly. 

It does not look like you ever reference or directly, so I would take the YAGNI approach and roll them both into . With that done, would implement directly, so you no longer have to explicitly mark , , and as implementing . Additional Comments/Concerns: 

It appears you are using to insert query parameters. The problem with this is that it opens up your API to SQL injection attacks. For example, if someone were to somehow pass the following for userId: 

(note: I switch back and forth between C# and F# , so I use more often than most - feel free to keep the explicit type declarations if you really want) 

If your main goal is to verify the document structure, you may try using an XSD. Once you have a schema doc defined, you can use some LINQ to XML extensions to perform the validation and get the error messages (if any) that result. Additionally, you can use XSD to define default values for missing elements/attributes. Once you do that, the code can be simplified: 

(note: The MSDN page on Regular Expression Language is always a good reference to check on when coming up with regex patterns in .NET code.) String Formatting Rather than concatenating the strings together, I would use a format string: 

The underlying problem is that vio.EtchVects is , and LINQ functions still return . Your functions are expecting scalar values. For simplicity, I will build from @Bryan Watts' answer, starting only with the select statement. If you want only the EtchVectors as a flat list, you can do the following: 

The private method calls can largely be ignored unless they have external dependencies, in which case you should add some injection and mocking with your parent object. This will allow you to ensure your private method calls inside PrepareAndScheduleFlowJob execute quickly and return expected results. edit: The above solution requires that you override Object.Equals. You could change the assert to a set of asserts for testing equality, but Object.Equals overrides are preferable, as it will cover FlowJob and any future/current subclasses in addition to providing equality check capability to anyone using the class. Additionally, in a framework like NUnit, overriding Object.ToString is highly recommended, as many test frameworks will call ToString when printing assert failures, and having something more than just the type name is useful when assessing why your tests may have failed. 

Of course, you would have to account for roll-over for days and months in any final piece of code, but it illustrates how you could pull the date parts back out. 

The second one depends largely on how the WinSCP class is written. You may need to ensure that the session is closed even if is never called, though you only need to worry about actually disposing of it when is called. For the last one, I would just mark the class as , since you have neither nor members. Otherwise, you should provide a virtual method. Generally, when doing so, your empty remains non-virtual, and you would provide an additional protected overload which takes in a boolean. For more information, see: Code analysis rule CA1063 and the MSDN page on Implementing a Dispose Method. 

Dispose all the things While you have a using statement for your connection object, there are a few other objects which implement you missed. Both the command and reader objects need using statements. Naming The method doesn't set anything. It would be more appropriate to call it , since you are retrieving information. Your variable names could use some work as well - they are somewhat inconsistent. Some have prefixes, while others do not. Some are camelCase, while others are PascalCase (the convention is camelCase). I left these changes as an exercise for the reader :) Use well-defined data objects I also noticed that returns a which contains various user detail properties. It would be better to create a data structure to hold this and return it instead: 

With that done, you can do whatever you like to represent the final date relative to the current date. An overly simplistic example is as follows: 

This saves you from swapping out binaries to troubleshoot an issue, which can in rare cases impact whether a bug is reproduced. Instead, you drop a modified app.config file in and restart the program/service. 

Additionally, is not a very descriptive name for your entities. It seems something like would better indicate what it is. Similarly, is a dictionary storing the types of time-off requests, and it is a field, so I would call it something like . Finally, the class name itself, reads more like the type contains a list of possible time types that fall outside a standard set of types. However, it's telling you the aggregate number of comp, bereavement, and jury duty hours requested for a particular user over the current year. I'm pretty bad at naming myself, though, so perhaps someone else can come up with some good alternatives. Design The first thing I see is that the dictionary only seems to exist as a way of identifying the int values the database uses. This would actually be much simpler as an value: 

Additional Notes Naming is one thing you may want to look at. The class is called , which only describes the data structure you used, rather than the purpose of the object. You are using it to store words, so my first reaction is to call it a Dictionary, but of course, that name's taken. Naming is hard :( Also, it seems a little odd that you scan for words with a method and you add tokens with an method. The latter bleeds implementation details to the caller - why should they know there are descendants at all? I would probably use and , but I leave final judgement to you. There's also the use of in your method I would love to replace. However, since I am out of time on my lunch break, I leave that to someone else. As far as performance goes: use a profiler. I could take a crack at the performance issue you mentioned, but all I would end up doing is profiling it myself. 

As far as testing the method itself: In most testing frameworks, you would create parameterized tests that provide the inputs and expected outputs. NUnit example below (omitting setup code to build ObjectUnderTest): 

That's assuming, of course, that you even want to wait to calculate pay. Another alternative which might be more usable would be to calculate on-the-fly as users enter values. To do this, you add a call to in 's property setters: 

If you only want one of the vectors from each vio, you could use one of the scalar LINQ functions (e.g., First or Last) or one of the aggregate functions (e.g., Max or Sum): 

First and foremost, I would strongly suggest using an ORM (e.g., Entity Framework or nHibernate) rather than doing all this manual work to update the database. ORMs take most of the drudge work away and generally make things much easier. That aside, there are a few things I would change: 

The benefit is that if you ever rename text, your refactor tools will update the second example, while commonly, they will miss the string in the first example. by default As a general rule, I seal classes unless it has been specifically designed for extension. I could go into explanations why, but smarter people than I already have. Final code: 

and an appropriate suffix so the overall query is valid SQL, it would return all users. Other injected strings could do worse like modify/drop tables. Instead, you want to use a parameterized query by replacing your format specifier with an @-prefixed variable. Then, you can add parameters to the collection: 

The most canonical way of accomplishing what you want is to use the testing framework's functionality for writing data-driven tests, rather than writing a common helper method and then a number of separate tests which pass arguments into it. Different frameworks do this differently, so I will focus on MSTest first, as that is the framework you use. In MSTest, there is a DataSource attribute you can supply, which defines how the framework can locate your test data. Additionally, you supply a TestContext property of type TestContext. When the tests execute, TestContext will be populated with the data for a single test case, and you can access it by using named indexing into the property. (Note: I haven't done MSTest in some time, so feel free chime in if there's a better way nowadays) Example: (Embedded resource: foo.xml) 

Disclosure: I do an increasing amount of functional work lately, so I tend to use more than others might. Feel free to put back some of the explicit type names if you feel uncomfortable leaving them as . 

With an enum, it should automatically use the individual enum values as the selected value and display the enum values' .ToString result in the control. If you use localization strings, it's a little (but not much) more complicated. Instead of binding enum values directly, you will want to bind a list of objects with the enum value and your localized string representation for the value, and then set the DisplayMember and ValueMember properties to the appropriate fields on your bound objects. Once again, that can be done through the designer (under Data again) or through code, as follows: 

...and so on. It is not necessarily cleaner, but it is a little more correct for the object, and it uses fewer dictionary look-ups. 

In addition to the other two answers, you may want to use the DataRow.IsNull method within BCdotNET's method: 

A similar refactor can be done with the two decrypt overloads. I will leave that step as an exercise for the reader. Symmetric Encryption With what's left, I cannot help but notice that this appears to be a symmetric encryption algorithm. As a result, the encrypt and decrypt steps are nearly identical to one another: 

As a result, checking _shouldAutoSubscribe only adds extra work. The only times you perform fewer operations is if the input name matches one of the first three elements in _shouldAutoSubscribe. It's a wash at four. Anything else is extra work. This leaves us with the following: 

How I learned to stop worrying and love the var When types are obvious, the common convention is to use . var all the things! Return the simplest data types possible returns a , when it should probably be returning . If you need add/remove functionality, you can use , and if you really need list functions, you can use . Take advantage of ADO.NET interfaces Rather than directly using the command and reader object constructors, there are methods you can use to build them. When building a command object, you can use your connection object with the IDbConnection.CreateCommand method. Final Version Taking the above suggestions into account, I came up with the following for your two DAL methods: 

Use TraceSource instead. It is the suggested replacement for the Trace class. I would not use a compiler directive to switch the logging on and off. Omit the .Listeners.Add line (which also exists for TraceSource) entirely. Utilize app.config files to control whether or not the logging occurs and how it is output. 

For the first point, you could just remove the try/catch. It only has a purpose if you are planning on doing something in the catch. This is true for all of your try/catch blocks. The next point could be solved with lazy initialization of the session. If you change the if statement within to do a null check, you can create and open the session there. 

Have you taken a look at the System.Data.SqlTypes namespace - particularly SqlDecimal? Building on some of the other answers, you can use and the operator as follows: 

Given your requirements, it seems you would be best using String.StartsWith and a value which ignores case (i.e., , , or ). This should be a little cleaner and faster than doing case conversions.