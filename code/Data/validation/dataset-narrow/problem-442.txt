I did a maze thing ages ago that could support any number of dimensions, but it was very slow to generate. To get an idea of how it generally works with the multiplier and stuff, here's a gif of something I made with it: image $URL$ One thing that always bugged me was I couldn't figure out pathfinding, and I thought there'd be some cool looking intricate paths between some stuff. I asked about that (since I'm stuck at home doing nothing due to having a broken wrist), and someone suggested linked lists, so I rewrote it all, and managed to get pathfinding between two points working fairly easily. However, since I'd made the nearest neighbour check run by default, checking for collisions was a huge bottleneck. I tried to optimise it a little, by only doing the pythagoras stuff if the highest coordinate difference was within the combined size of two nodes, which did speed it up like 2x, but it was still quite slow. Someone else suggested that's what you use trees for, and since I have no idea how KD trees work (and also the list is constantly being added to), I spent a good few hours yesterday making an octree that would work in any dimension, so I could find which nodes are near to then narrow down what the collision function has to check through. The result was like 2.5x faster at 1000 nodes, but exponentially going up to like 10x faster at 8000 nodes, which I'm pretty happy with. I've just got it fully working and cleaned up now, so I'm looking for a bit of feedback on either my writing style or anything that could be improved. Also, before the line length is mentioned, I decided to do 100 instead of 80. 

$this->get('feed_parser') is just a fancy way of getting a SimplePie object from the PIMPLE container - you could just instantiate a SimplePie object yourself (if you want code you can't test). After running this code, $item would be a PHP array (or some collection class) containing the details of one image. In my case, I then exposed this as JSON and a REST API endpoint for use by JavaScript, but you could just as easily have PHP output the appropriate HTML. 

Since this is all the code you posted, I'm going to assume you're only using these functions in the place they're defined, so the later code would be best. It's more readable and doesn't include unnecessary identifiers. Your question is really about anonymous functions, not closures. To answer this question, you should ask yourself, "do I plan on using these functions elsewhere"? Since anonymous functions, by definition, are not bound to an identifier, they will be inaccessible everywhere except where they are defined. This is the version that I would recommend: 

As far as I know, Meteor's reactivity is one-way: changes in data are reflected in the DOM. To go the other way (DOM to data) there's two common methods: 1) grabbing data directly from the DOM when it's needed (i.e. to save it) as you've done above and 2) binding DOM elements to data models, and using the data models for CRUD operations. 1 is simpler to implement, but 2 gives you more control over data-flow, subscriptions, and life-cycles. 2 has plenty of great libraries you can use, so you don't have to reinvent the wheel just to leverage these benefits. Backbone.js is probably the most well known plain-JavaScript library for this sort of thing (also check out Lo-Dash and Exoskeleton if you haven't), but the Meteor ecosystem may have a preferred library for this. 

Now I've grasped the very basics of Pygame, I thought it'd be useful to make a few classes that I could use later on if I try make a simple RPG style game. I've done this to handle the coordinates for the player movement (and possibly for other things too), and tried to do it in a way where you wouldn't get the floating point precision errors that Minecraft and similar games get when you travel out very far. I tested it against the module, and mine appeared to up to 10x faster for small movements, though the speeds evened out when using super large movements like +- 10000000000000. It's only half a days worth of work so it's not perfect, I can't find any more bugs though. It's recommended you input the coordinates as strings though if you're using large ones to start with, especially if you're using floats. 

I decided to try make my own way to save normal python data yesterday after coming across the minecraft NBT format, it's more limited than cPickle but appears to produce shorter results and so far works reliably (if a little slower). It works on the type of the input, and is currently compatible with , and I couldn't think of anything else. It's really easy to add in new types if you use the current things, like I'd forgotten about floats until the end, so I treated it as which worked fine. As the type ID is still stored as float, it sees its a float, so reads it like a list then puts it back together. I'm not sure how many other similar projects are available, but I'm quite happy with the result. It works by building a list of 1s and 0s for each item, which is in the format . If the item is a list or dict, its will refer to how many values it contains, and the code be repeated recursively. 

RssParserService should NOT know concretely about its observers. It would be nearly the same as letting an abstract class know its derived classes. All your decoupling benefits through abstraction/dependency inversion (here the observer pattern) would be gone. On the other side your own observer implementations relies now on a dependency injection mechanism (@Inject) AND service construction (@PostConstruct). This looks really elegant at the first place. But me, I wouldn't make MY observer implementation depend on OTHER mechanisms. What you are missing is a model where your services depend on. In the use case presented you will never have any real problems. But if your code grows you should ... 

This looks a little bit ugly but it is the Swing way. Other frameworks do not work with the String-Type. They often work with the Object-type (Vaadin: button.setData(...), JavaFX: radioButton.setUserData(...), etc.). Nevertheless: the trick is to make the decision at the origin if possible. In your case in the buttons. You may also have a look here: $URL$ One big advantage ist: You are able to add new Buttons (plus 300??) without the need of enhancing any if cascades. 

Avoid comments If you want to make comments it is an indicator for that your code itself may not be clear enough. I intentionally said "avoid comments" but not "do not comment anything". First think about the things that will be compiled and run to be as clear as possible. Then if you think it's neccessary to comment then comment. Comments have to be maintained separately. They are "uncompiled" code and cannot be be put under test. So they may lie if they diverge from your code semantics. E.g. you have following signature: 

For any Maya users, this doesn't include the animation or colours yet, but here's a class to build it in 3D. You only need to iterate through to use and , so if you have a different 3D software package it'd still be easily possible to display. 

If you set some bounds and the multiplier to 1, it should draw a proper style maze, it's just a bit boring that way. Since the tree data isn't really stored after the generation, here's an example of what the tree looks like at 3000 nodes in 3D. There's probably a better way of doing it but it worked for me. One thing I've realised is I may be able to merge with , but I've given up on coding for now so I dunno yet. Edit: Added a few extra bits, mainly for Maya. You can now remap coordinates, so for example, you could use a 3 dimensional generation and swap with , so basically you have the 3D generation, but only 2D slices of it that you view by changing the time.I also added the shaders too, so now you can see 4D generations properly. To be totally honest, I thought they'd look cooler (the 4D generations, not shaders), but they're a bit disappointing haha, but I'll try render a video later to show what it looks like. If anyone has an idea for the 5th dimension or any others, I'm all ears. 

LogProcessorThread This thread while refactoring seems to become more and more an artefact that will ask for log messages from somewhere and passes these log message to somewhere. Here again: The thread itself is the monitor over "shouldStop" and the critical operations source.getNextQueuedMessage() and target.log(message) that should not be intercepted. 

General Nearly everybody has some concerns about using String as the favorite datastructure in this use case. I will try to sum up these concerns and have a look at WHY these concerns occur and WHEN they are valid or invalid. Quotes NPSF3000 says: 

The main problem of your solution is that your methods have temporal dependencies. Your are manipulating the "purchase" variable on in total different states of the object without checking if it is allowed. What if someone calls the method to calculate the tax twice beforw you even have a purchase? My suggestion without providing code but providing a strategy: Try to keep your object inner state consistent whatever the call order is.... OR If your structure may be inconsistent do not encapsulate behaviour on it. Let it be a simple Value object. This will be a more functional approach. 

OR-mapping You fall into the object-relational impedance problem. RawNode seems to be the same as Node but they are totally different in purpose. This doesn't even change if you use an OR-Mapper like Hibernate. The following definitions assume you do not want to have an anemic domain model. RawNode (mapping object) It provides a concrete representation what came from the database. It is a datastructure only with no logic. It abstracts from the raw resultset where you access columns via column names or indices. A RawNode is used as a datastructure to communicate with the database through the DAOs in both ways. A RawNode object is a value object. It has no assertion to consistency. You may check the values for consistency (e.g. Java Validation API) and get a list of constraint violations. But the current state of the object may be inconsistent. OR-Mapper can do validations but as they are not able to enforce business rules I would not rely on this. Equality of these type of objects should be checked either be on all values or on none. Node (business object) Equality of a business object is checked on a global unique id. This is a real business object. It has the assertion to be immutable in the current version. If the non unique values are different but the id is the same you have a different version of the business object. But it is the same object. A business object is ALWAYS consistent in respect to the information it provides. If it is not this is an error. Business objects enforce business rules and consistency when you try to make a change. They will process validation and structural checks to keep the whole system consistent. Useful assertions As you remap the business object to the mapping object in the DAO you can be sure that the communication object is consistent as the business object was consistent. As you remap an unmodified mapping object from the database to a business object you can assume consistency. Your code Avoid continue multiple return, break and continue are not refactring-friendly. They make it hard to extract methods if you want to sub divide a method. What kind of exception do you expect? You have all transient datastructure available. Do you expect a NullPointerException because a parent that was defined could not be found? If that is the case you should fix the algorithm that produces that inconsistency and not try to straighten it for further algorithms. The decision to fix the data is depending on your influence on the data holder of course. Extract methods Extract the following responsibilities into separate methods: 1. Build Nodes without parents and children from RawNodes 2. Build a temporaray map with Node by Id 3. Set parent child relationship 

People do this sort of thing all the time in the JavaScript (this.arguments) and Python world (*args); however, by removing type constraints from the parameter list, you have to be wary that you're always providing the types of parameters your function is expecting. If one of your parameters is supposed to be a string, and someone passes in an object, bad things may happen. Conversely, some very respectable projects use multi-line parameter lists. It's fine to have a lot of parameters, as long as they're all necessary, but it's always good to be skeptical. Long parameter lists is a good code smell – if you see them, the code may need refactoring, but not always. As far as the attributes of Box's, forget about programming for a second. Conceptually, what are the properties of a box? Can a box still be a box without a color, tileW, tileH, walkable, speedY, and speedX? Can a box still be a box if it doesn't know how to draw itself? If your answer is no to all of these, then your code is fine, and requiring parameters as a single collection/object vs. individual parameters is (arguably) a matter of preference. That being said, I would move the three lines to a separate method . It's best to only do construction in the constructor, and leave the rest – like rendering – to other methods. 

It's been a while since I had a bit of fun getting something useless working, so I thought I might as well ask if there's anything to improve about how I do things. The original idea was to convert to a higher base for more efficient storage, before I realised I was hashing the value anyway so that would be pointless, and you can simply do to achieve the same effect. Anyway, I got it working for all bases from 2 to 221, with the option for higher if you can find any other characters to add. The padding was a bit of a headache, but I figured out the maths to get the maximum expected length, though it's only really useful if you were doing a database input with a set column length or something. It also works with seeds, so it could be used for something similar to hashids I guess. 

: What type the input is : How many bytes to look at for . Because this number will always be quite low, it's stored as a bunch of 0s, ending with a 1. : How long the data is : The input stuff As to why there is both and , for example, if the input has 255 bytes, the current way would result in 9 bits to say the length is 255, whereas having only 1 value would result in 255 bits to say the same thing. When reading the data, instead of splitting the string up, it just uses offsets on which part to read. I'm not so happy with writing it but didn't know a better way, as I just store it as a string and basically use or . The en/decode functions work with the string of binary numbers, and the and functions just get it to and from a human readable form. For the record, I'm planning on having something in , just haven't thought of what yet. Example: 

Further steps Your solution parses and interpretes incoming data and processes calculations. This is best addressed with the state pattern and the interpreter pattern. This is an advanced technique you should have in mind when you feel ready for it. 

Decoupling receiver from sender. The WordTextField does not need to know if the action was initiated by a button. It could have been anything that triggers the model change. Decoupling UI from Model, so you do not bind yourself to a specific UI technology anymore. Throw away Swing and use JavaFX. This will also work. If you do not see any necessity to change your UI technology it remains decoupled code. The model will be testable without any visuals. 

Bitwise tricks may optimize your code to ONE aspect (speed?). You have to say to which aspect you want your code to be optimzed. But that is not that easy as well. BTW I see a deleted answer that got downvoted as it provided a solution with bit shifting. The best comment to that was "We should write code for people to read". But if you want to argue for readability: That is totally subjective if you have no real world anchor. If someone sees the code for FizzBuzz then he only can evaluate single statements and say what they do but he cannot evaluate an intention. If you want to argue for extensibility optimization you have a hard day. FizzBuzz is nothing more than an exercise to train algorithmic thinking. There is no real world anchor so you have nearly no chance to forcast any abstractions that are neccessary for extensibility. Once you are thinking you have the correct abstraction someone can come up with some completely artificial requirement you haven't considered. I do not say that this does not happen with real world requirements but they tend to be easier to be forecasted. Speed is indeed a measurement you can make. But can we really say that only the fastest code is the optimal code? I don't think so. 

You could simplify this even further by using a single CSS class for all elements that need animating. e.g. Also, if there are any animations that are triggered by mousehover, you could do all the animation in CSS with the pseudo-selector. Finally, make sure the CSS transitions you use are compatible with all the browsers you're supporting. 

After a cursory glance at the character codes for these, it looks like the lowercase is 32 (decimal) higher than uppercase. e.g. 'é'.ord - 32 == 'É'.ord You could try something like this: 

This looks pretty good, not much room for improvement I think. LinkedIn's JavaScript is calling linkedInApplySuccess, correct? All you have to do is specify data-success-callback, or something similar, in your HTML? The only minor thing I would do is instead of sending just the job ID, send the entire JSON object. As long as resources aren't an issue, it's always best to capture all data and disregard the stuff you don't use rather than only collect the stuff you're currently using; this is because requirements change, and in the future you may want to do something with the data you've been ignoring. For instance, you may want to calculate how many people are applying for jobs with the position "Chief Weasel Wrangler". You can alter your code to something like this: