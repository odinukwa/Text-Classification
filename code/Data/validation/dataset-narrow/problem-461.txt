The function actually parses the coeficients for each degree term. I won't dive too deep in to this one, but i'll start saying that you do a lot of . And many of them are almost identical, being not only inefficient as well as confusing. Consider this one for example: 

I should start by saying that the game is quite interesting, and for a beginner the code is good, but of course there is plenty of room for improvement. Small details You have many small things that may a bit odd or unnecessary even, such as: 

Both first blocks have the exact value you are looking for and will always be an empty because there is nothing to the left. Thus it won't affect the result at all. So you can drop the altogether, and adjust the appropriately. Personally i feel you must rethink your logic a bit on this one. Restating @Blindman67, you should take spaces into consideration to make the structure less rigid. On a simpler level you can strip down the spaces before parsing: 

To make this run faster, use memoization for the function getCombinationsRecursive(). Use BigInteger in the NChooseK instead of longs to support larger numbers, but then you will also need to use something other than string[] for the results for very large instances. Use parallelism if you don't care about the order in which the results get written (although as it stands, that could be difficult with this implementation). Write the results right to left by appending instead of putting the new values in front of the subResults. Completely change the algorithm to do a depth-first search over the possibilities instead of a breadth first search, that way each result could be written one at a time, instead of needing to store it all back out of the recursion. 

I make use of an NChooseK function so we can determine how large the string[] needs to be to hold the results from the subproblems which will be carried out at the next level down in recursion. Full Code with Timing Code 

There is a similar question that you may want to take a look at for some extra insight, even thought it doesn't have the contrasting color feature: JavaScript Random Color Generator Now lets get to the review. Naming 

Just adding a couple of things to what @Blindman67 already said, and focusing a bit on the code itself. 

Which given what it does, a better name would be . Given that all it does is sort the roots, its even questionable if it should exist, and probably better would be to do the sorting directly in . Considering we are talking about two values, you could easily get away with: 

While the whole code would now be longer, as you would have to manage both the page visual elements as well as the logic itself, it would also be more modular, organized and easier to maintain or add functionalities. It would still be necessary for some other function to call the game functions and update the corresponding page elements depending on the game state. A more modern way of doing what i did above is using ES6 classes: 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took the a problem from project euler: 

Is there a better way to write it in FP with pure JavaScript, i.e. no additional FP library? Any improvement suggestions are welcomed. 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Advent of Code: $URL$ 

I wanted to practice functional programming (FP) without using any library but using vanilla JS only. So I took a problem from Advent of Code. $URL$ 

I got 2 while loops that are nearly identical. Is there a way to refactor them? I tried to refactor them into one function. But that function takes and returns 4 parameters: 

The FP solution is longer and slower. I couldn't solve it without recursion. After a while you hit the stack size. Thanks to Thanks to @Blindman67 he suggested a workaround with . Do you know an FP approach that is faster and shorter than the procedural one? 

When we look closely to we can see that the code is barely the same, except for the very final returned root. So this leans towards repeated logic and creates all sort of problems. In this case it also makes your code less efficient because you repeat some part of calculations. Better would be to restructure your to return an array with both roots. 

In this refactored version both roots are returned as an array. I included solely for clarity. You also had an variable that wasn't being used at all. Always be aware of those, as they clutter the code and leave readers wondering what they are for. With this new roots calculation could be way simpler: 

Refactoring When you see yourself doing the same thing many times, it is time to think again and try to refactor that part because there certainly is a better way. You have very few code that represents repeated logic, but lets take a look at the function: 

Rather than moving the balls around, we can move buckets. That is, I will mark 3 balls with an 'x' and that ball and the balls to the left of it (until the next 'x') are part of the bucket, (since all balls are in a bucket, the right-most ball must be marked. So we get: 

There's a better way If there are 5 balls and 3 buckets, but each bucket must contain at least 1 ball, imagine the following set of balls: 

I think it is worth mentioning that for large data a different approach could be used, since keeping exact frequency counts of words is too time consuming. Streaming Algorithms like "Count Sketch" makes a single pass over the data, uses low amount of space, and based on the amount of space you allocate to it, can guarantee to get the Maximum Frequency Word with say 99% probability. Algorithms like these are used every day in routers to approximate which IP addresses are requested the most frequently, given that routers do not have enough memory to store everything it sees and only sees each IP address once. For large data, I would recommend this approach. Not sure if 10 GB of text counts as big data for this problem though, however if every word in the file was unique (except one word which occurs twice), you probably don't want to try storing them all in a Dictionary :p. As an aside, Multi-threading may be able to help give a speed-up, although pulling data from a single .txt file seems intrinsically IO bound. It seems possible to pre-partition the .txt file into parts for each thread to process independently, using "unsafe" code with pointers directly at the partition locations in memory, and writing the line parsing yourself from the bit representations of chars. I doubt the above would be worth doing in C#, since you might as well manage memory as well using C or another low-level language for that extra gain in speed-up. Multiple threads would exhibit higher speed-ups on certain processors like the intel i7 which has 3 channels to memory, and this is a highly IO dependent task. If it happened to be hundreds of thousands of 10 GB .txt files across a cluster of computers, I would consider using an approach utilizing MapReduce on a distributed file system. 

The code above has got more operation than in the first part of this riddle. But it's way faster and shorter than the functional approach of the 1st problem (Advent of Code 2017 Day 5 (part 1) in Functional Programming (FP)). My FP solution: 

Is there a better way to write it in FP with pure JavaScript, i.e. no additional FP library? I have problem with the lookuptable . Everytime I "add" a new element to the scoreboard, I had to pass the new scoreboard along. There is probably no other way around this in FP since FP functions have to be self-contained, i.e. every new value that needs to be calculated have to passed along. But I still wonder whether there is a nice FP solution to that. Any other improvement suggestions are welcomed.