...and these are only the ones I happened to buy and noticed that they used the XNA runtime - I'm sure there are more of them that I'm unaware of. And in case you don't know them, Terraria sold an amazing amount of copies (if you couldn't tell from the "over one million copies sold" disclaimer on the link above), remaining in Steam's best sellers list for a long time. And Bastion... well it just won three Spike VG Awards (incluiding best downloadable game of the year) a few days ago. I also urge you to check the other games. Chime is an amazing casual/music game providing an extremely relaxing zen-kind of experience. And Sequence is a really original mix of DDR and RPG (with some music by Ronald Jenkees for those who know him). Finally, Magicka is an action RPG similar to Diablo which is also pretty cool. I suppose that should say something about the feasibility of using XNA for developing PC games. 

As for your confusion regarding 3D, you should know that the class also works with 3D behind the scenes. It's basically generating two triangles (i.e. one quad) for each of your draw calls. Finally, I think what you're trying to achieve is usually done in another way, by using deferred rendering, where you'll also need an heightmap (and a normal map if you intend to do lighting) for each for your sprites. Check this amazing video example of the technique. I used to see an article with an implementation of the technique but I can't seem to find it at the moment. The video does state at one point "Writing the heightmap to the depth buffer allows for objects to intersect in 3D" which might be a useful hint. 

It's important to know what sort of forward vector you're talking about. If you're using Vector3.Forward directly that's simply a unit vector looking down the Z axis. Let's suppose your 3D model is designed such that its also facing that direction by default. In order to get the real forward direction of your character you'll need to tranform it using the character's rotation first. For instance if your character can only rotate around the Y axis (i.e. has a Yaw property), you can get the character's current forward vector like this: 

In my opinion the simplest way is just to add a public static reference to your game object, and assign it in the constructor. Has some similarities with using a singleton, but without all the restrictions: 

You could combine both into the regular expression: Horizontal flips can also be added just as easily (using the | operator too). Edit: Anyway, the regex part is not strictly necessary. It's just one way to encapsulate the problem in a single expression But for the variable location problem you could just as well trim the grid string of any padding spaces (or E's in this example) and do a String.Contains(). And for the multiple ingredient problem or the mirrored recipes, you could just handle all of them as multiple (i.e. separate) recipes with the same output. Step 3) Speeding up Lookup As for reducing the search, you will need to create some data structure to group recipes together and help with lookup. Treating the grid as string has some advantages here too: 

I've read a really good article before that described how collision detection was implemented in earlier Sonic games. That article would have been an excellent reference for this thread, but I just can't seem to find it at the moment. If I do I'll update my post. Meanwhile I'll try to take it from memory! I believe this technique is very interesting and might solve your problems, without needing to change to a physics engine nor let go of per-pixel collision entirely. Basically what the article described was a tile-based platformer engine where each tile type had per-pixel collision data like this: 

Although I haven't worked with the bullet physics engine specifically, I've done something very similar in another physics engine. The way that I solved it was to set the rigid body's linear velocity instead of translating it directly. Movement and collisions were then automatically handled by the physics engine update phase. From the documentation there seems to be a method that you can use. So for instance, if you don't want any accelerations happening, just set the linear velocity to an appropriate value whenever the character is moving, and set it back to (0,0,0) when the character is supposed to stop (i.e. when the player releases the key). As for which values to use, the usual approach would be to start with desired speed of your character (as a float/scalar) and then multiply it by a normalized vector that is pointing in the direction you want to move. From what I can see the class already has methods for all of this. Alternatively, you might consider treating the character as a complete physics object, and handle movement using either the or methods. These would result in a body acceleration, so your characters will have momentum and the results will probably look nicer this way. But you need to take some extra measures, for instance, by making sure the linear velocity never exceeds a certain limit, either by clamping it or playing around with damping/friction. So it will be a bit harder to implement and finetune. Experiment with both approaches and then choose the one that behaves closest to your needs. 

Maybe I'm not seeing the whole picture, but can't you just the apply the border (by setting those values to 0 / water) after normalizing? And I suppose you're normalizing correctly e.g: Some aditional ideas... last time I generated something like this, I used probabilities and a random number generator. I simply choose the center of my island, and a maximum radius. Then for each pixel, there was a probability of it being land or water based on its distance from the center and the maximum radius. At the end I also applied a few post processing passes, to detect oceans and remove inner lakes, etc. Maybe you could keep your current simplex noise approach, but afterwards do a similar post-process on your map in order to make it more "continent-like". This could consist of going through every pixel, and depending on a random probability convert some of them back to water (by setting the value to 0) e.g. 100% chance of water at the border and decrease to 0% about 20 pixels in). This way it would still look kinda organic. You could then apply a second pass to remove small islands or something, if you wanted. Just for reference, using probabilities generates shapes such as this (of course this is in a much lower resolution that yours because it's tile based, not pixel based): 

Sure. But bear in mind that this just my personal solution to a specific problem. Feel free to take from it anything that might be useful to you, but with a grain of salt; each project is different, and this solution just happened to fit well with my needs. It won't fit every project, and I don't claim it to be the best way or anything. My display list is made up of two separate parts: 

This way you only need to check for collision using these individual points (which ones depend on the situation, such as jumping or falling) and in case of collision you only need to adjust the sprite based on those points. For instance if one of the upper points collided with some blocked pixel in the ceiling tile, you only needed to bring the sprite down until that spot no longer collided. Edit While this is still not the link I originally read, it also mentions the collision points (named sensors) and should give a great deal of information. Read the other sections of the guide too! $URL$ 

This way your XML file will still be copied to the Content folder, without being built by the XNA's Content Pipeline. 

Here's a simple loading example without error handling. In a real scenario you should always check if or returns null: 

That takes care of the problem where movement should always be relative to the camera. Part 2) Clamping the light back onto the correct plane In step 1 the light was moved according to the camera, but disregarding the plane. Now it's time to fix that, i.e. you need to validate the light position to ensure that it remains at the same distance from the plane. The first thing that occurs to me would be: 

As for how to implement it, I recommend starting from here (courtesy of Catalin Zima and Roy Triesscheijn). 

Jonathan Blow licensed all of the music used on Braid from Magnatune.com (here's a post on his blog where he talks about it). So I was thinking that perhaps you could get an estimate of a reasonable price from their website. Here's their licensing information page and here's a sample page they provide that lets you estimate the price for licensing one song for a video game. As an example, here's some results from choosing one random song from that list with the bare minimum choices available (except for the music length): 

And if you invert the matrices you can also go in the opposite direction i.e. transform points from world space into each of the sprite's local spaces depending on which matrix you used: 

Step 2) Visibility Check You don't mention anything about this (unless I missed it) but are you perhaps drawing all the tiles at once? If you're doing that, then it's obviously a major source of problems too. Your camera can only see a certain amount of tiles at once, so you only need to draw those tiles. Step 3) "Too many monsters" Actually, I doubt it. I've managed to draw thousands and thousands of sprites at once, and never did the application grind to 2 FPS. The amount of monsters you have does not seem like much of a problem. But just to be sure and to gain a little bit of performance, make sure you don't draw monsters that are outside of view. Step 4) Disable panning on some elements 

Chapter 14 (Acceleration Algorithms) of Real-time Rendering also covers most of these topics, and this is actually my favorite general graphics programming book ever. Very comprehensive but I don't recall how much it covered this particular subject. The focus of this book is on the graphics theory, but it covers such a large amount of topics that I could hardly find a better recommendation for anyone interested in the field. Game Programming Gems 

It's hard to suggest an approach if you're not completely specific about the effect you're trying to achieve. Details such as if the lights should be obstructed by the environment or not, what's the point of view of your game, to what extent should the light interact with the environment, etc. I'll drop my two cents though. See if this tutorial by Catalin Zima entitled Dynamic 2D Shadows fits your bill. As you can see, the light has a radius and does not go through obstacles. You could animate the radius and the color a little to make it look closer to a real torch light. 

Main - The main Windows Forms Application. Content - The Empty Content Project where you'll add all your assets. ContentLibrary - The empty Windows Game Library project used to build your assets. 

Long Answer Do you know the difference between a View Matrix, a Projection Matrix, and Perspective? You seem to be using those terms a bit too loosely, but they're all different concepts. 

I fail to see what's the problem you're having. Update the time of day and tween the colors in the method (assuming it has access to the dt) and leave the method only for rendering. I think that's the more logical solution. Also, encapsulate this in some sort of Sky class if you haven't done so already. So I'd definetly stick to the 2nd option. Something like: 

Example In sum, something like this for the frustum class (just to give you an idea, it might have other members and features too): 

Step 1 - Making the Textures accessible from Level.cs The texture for each item is being stored inside the class inside . You should be able find something like this on your file: 

The vector is the result of adding and and normalizing the result, which is pretty much what you were trying to do. So, back to your problem, it should be clear from that diagram that simply adding the tangent space sampled normal and the world space surface normal together and normalizing the result won't be the same as applying the correct displacement to the surface normal as you expected. It will just return you some new vector that is halfway between both of them, and since both vectors aren't in the same space, the result wouldn't even make any sense. So it's important to do the conversion and work in the same space, either in tangent space or world space. Nathan gave the pros and cons of working in each of these spaces in his answer. 

Then call something like the following code once in order to render your merged tiles into the texture. Note: The way I draw my tiles is just an example, use whatever you're already using. The important part is setting and unsetting the render target: 

The origin is defined in local (or model) space so it doesn't matter if you're scaling the entire scene or even the individual sprites, the origin still won't change.