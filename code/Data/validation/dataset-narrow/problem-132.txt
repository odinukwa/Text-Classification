Notice how in the diagram, with all the crossing, the path from one PC's TX wire to the other PC's RX wire is maintained. Anytime something is sent on a TX pair, it is always received by an RX pair, all the way through the communication. 

If the protocol using TCP behaves like HTTP, where the first data transmission after the connection establishes is the Client sending data to the Server, then you're right to say the lone ACK (line #3) seems superfluous. The packet immediate following (line #4) would suffice tell the Server that the Client received their ISN (from line #2). However not all protocols behave like HTTP -- some protocols mean for the Server to send the data immediately after the connection establishes. In those cases, the server must wait for the client to send the empty acknowledgement packet before it comes to acquire positive confirmation that the bidirectional communication channel is successfully established and data transfer can begin. This is more rare in the Internet, but it does exist. Offhand, I can think of Passive FTP, where the client initiates the data connection (aka, sends the initial SYN) but the purpose of the connection is for the server to send the initial data packet -- which starts as soon as the data connection is established. TCP can not behave one way for certain protocols and another way for other protocols. Hence, the empty acknowledgement must be sent so that both scenarios are accounted for. 

When HSRP triggers a failover, it also issues Gratuitous ARPs to update all the ARP caches and Switchport MAC Address tables that the default gateway is now being served by a new interface/router. Its not terribly clear from your question, but as far as I understand, you are not actually running HSRP with your vendor, but instead are shutting and manually configuring what would have been the HSRP VIP IP address on different Routers. Given that you are doing this Manually and not within the HSRP protocol, the gratuitous ARP is not being sent to update everything, so a manual clearing of the ARP cache is necessary. This allows each device to "re-learn" the MAC address of its default-gateway, as well as the switched-path to get there. 

Remove this static statement. And apply NAT Exemption in a way where it will ONLY apply to traffic between the Inside and DMZ interface. Which means you have to do a Policy NAT Exemption (aka, NAT Exemption with an ACL). It will look like this: 

Two final points to keep in mind: First, in all cases, the ICMP Redirect is temporary. I believe that PC0 will use the information in the ICMP redirect for 10 minutes, before 'going back to' what it knew before... which would prompt additional ICMP redirects, and an additional 10 minutes of more efficient routing. Second, ICMP Redirect was created when the Internet was a nice place, with trust worthy people. Now a days, the Internet is a dark and scary place, for which you should have very little trust. As a security best practice, most Network Admins prevent their Routers from sending ICMP Redirects and prevent their Routers from 'obeying' ICMP redirects. Similarly, a lot of client OS's also flat out ignore ICMP redirects. The reason for this is it would be very easy to abuse the ICMP redirect to become a Man in the Middle. If you and I happen to be on the same network, I could easily send you an ICMP Redirect message that tells you the "better next hop" to reach your [Facebook, Banking, e-Commerce, Intra-net Portal, anything] network is through my own IP. Voila, instant Man in the Middle. As such, I think its good to know the basics of ICMP Redirect, but I think it isn't very functional to spend much time mastering how they work. Its nearly across the board disabled and/or disallowed -- for good reason. 

If you happen to have had two licenses, one for each pre-8.3 Firewall in an HA pair, and then you upgraded to 8.3 or later, then the licenses will be combined. Which is to say, if you had a 5 SSL VPN user license on the Primary, and a 5 SSL VPN on the Secondary, you would now (after upgrading to 8.3+) have 10 SSL VPN users allowed to connect at once. This works for licenses which offer a numbered feature. If your license was something like AnyConnect Essentials, there is no benefit to upgrading (*see note below), since its impossible to enable the AnyConnect Essentials twice. 

Newer versions of Wireshark will correct the protocol label to what was negotiated between the two clients after the Client Hello and Server Hello messages. If you delete the Server Hello from the capture, you will see Wireshark will continue to label the whole conversation as "SSL 3.0" since it does not know what the agreed version of SSL/TLS was. 

Since ASA 8.3 code, the interface ACLs expect the real-ip in each statement. In your example, your real-ip is . As such, your ACL entry will have to look like this: 

You are looking at a successful three way handshake (SYN, SYN ACK, ACK). And then an ungraceful connection closure sent by the client (R for Reset). IP 192.168.246.128.54955 > 192.168.246.13.80: S 2910497703:2910497703(0) win 5840 IP 192.168.246.13.80 > 192.168.246.128.54955: S 3762608065:3762608065(0) ack 2910497704 win 64240 IP 192.168.246.128.54955 > 192.168.246.13.80: . ack 1 win 92 IP 192.168.246.128.54955 > 192.168.246.13.80: R 1:1(0) ack 1 win 92 (I removed the timestamps so you could see it all on one line) This particular pattern often occurs when someone is scanning your environment for open ports. Someone completed the three way handshake, noted that Port 80 was open on the Server (192.168.246.13), and then close the connection. This method (actually completing the three way handshake) shows up less often on IDS/IPS monitoring systems than the traditional port scan pattern which just includes SYN, SYN ACK, RESET. 

If you are running code 6.x, you can also try setting both interfaces (inside and outside) to the same security level, which might preclude the requirement for you to NAT everything as it crosses through. I'll be honest though, I haven't tested this, and only just now thought of it as an option. 

A switch doesn't particularly care of, nor make note of, whatever IP addresses are in use on frames traversing the switch ports. A switch only cares about the MAC address. Every time a frame is received on a particular switch port, the Switch learns the frame's source MAC address. How this works with VLANs, is that each VLAN on a switch has its own, independent MAC address table. Given the following topology, a packet from HostA to HostB would bounce between each switch, going from VLAN to VLAN. The switch, upon receiving the frame, would learn each time from the source MAC address of each frame received, on each VLAN, on each Port. 

When Host A sends the frame, the switch does not have anything in its MAC address table. Upon receiving the frame, it records Host A's MAC Address to Switch Port mapping. Since it doesn't know where the destination MAC address is, it floods the frame out all ports. This assures that if host B exists (which at this point, the switch does not know yet), that it will receive it. Hopefully, upon receiving the frame, Host B will generate a response frame, which will allow the Switch to learn the MAC address mapping from the return frame. You can read more about how a Switch works here (where I took the animation from). I would also suggest reading the entire article series for a closer look at how a packet moves through a network. One last note regarding the terms Flooding vs Broadcast. A switch never broadcasts frames, a broadcast is not an action a switch can take. A switch can only flood a frame. A broadcast is simply a frame with a destination MAC address of . This is often confused because the end effect is the same, but they are actually different. 

source At any point in the animation, the is the Payload for the respective layer (Segment, Packet, Frame). Within the Payload of the Segment is the application data put together by the application layers. Within the Payload of the Packet is the L4 header (TCP, in the animation's case), as well as the application data. Within the Payload of the Frame is the L3 header (IP, in the animation's case), the L4 header (TCP), as well as the application data 

Despite all that, ICMP is considered a L3 protocol, mainly because its primary usage (ping) tests if a packet can get from one end of the Internet to the other. AKA, it is primarily associated with end to end delivery. As for the rest of the protocols you listed, this is where they typically are associated with: 

The command tells the Router to authenticate all incoming virtual terminal sessions via the local username database -- aka, users created using the command. Using skips the checking and validating against the VTY password set within . Therefore, you do not need a within if you have set. 

Notice that only a single TCP connection was used to request all three objects. This time, it only took 13 packets, a large improvement from the 27 from earlier. The last imrpovement to HTTP that we must discuss is a feature called Pipelining. This feature further increased HTTP's efficiency, by making it so the Client can requests multiple options at once, without waiting to receive the prior asked object. Let me show you: HTTP1.1 with Pipelining 

That is why this approach is not recommended. Your users (who don't know any better) will, for reasons they won't understand, not be able to speak to random companies on the Internet -- like HP in the 15.0.0.0/8 example above. As Ron Maupin pointed out, the recommended addresses to use on the internal network are the RFC 1918 addresses. Since no one is permitted to use those addresses on the Internet, there will never be another entity you won't be able to communicate with. 

If I'm understanding your question, you are asking if these three fields are always the same: and . We can compare the values on a traditional "normal" ARP conversation, and a Proxy ARP. Traditional ARP Request / Reply ARP Request 

We can use the highlighted values to calculate the EIGRP Metric using the default K-values and this formula: 256 * (BW + Delay). Which equates to: 

The Authentication Key and Encryption Key are used to secure/encrypt the ensuing Phase2 negotiation. In Main Mode, messages 5 and 6 of Phase1 are also protected by these keys. Furthermore, any future ISAKMP informational exchanges (DPD, Rekey events, Delete messages, etc) are also protected by these two keys. The Derivative Key is handed to IPsec, and IPsec generates its own Keying material from this Key. If you recall, IPsec does not innately include a Key Exchange mechanism, so the only way for it to acquire secret keys is to either set them manually (which is archaic, and never really done anymore), OR to depend on an external service to provide the keying material, like ISAKMP. The RFC says it like so: 

Simply because IPsec was not built to initially include a Key Exchange. In fact, early implementations of IPsec expected you to manually configure an IPsec Key, from which Encryption and Authentication keys were derived. When it was determined manually setting and rotating keys would not scale, they looked to find another solution, but one that didn't involve re-writing every IPsec implementation. So now, you have the ability to manually configure IPsec keys (archaic, no one does this anymore, neither should you), or you can use ISAKMP to auto-magically provide keys to IPsec. ISAKMP (Internet Security Association and Key Management Protocol) exists for the purpose of securely establishing keying material, over an insecure medium (Internet), for IPsec to use. But that is not all ISAKMP does. IPsec also wasn't written with a direct Authentication method -- verifying the other end is who they say they are. The initial idea was if both parties manually configured an IPsec key, and both parties manually configured the same session key, then clearly if they reproduced that key they are indeed who they think they are. But if those same IPsec keys are being auto-magically determined across the Internet, then there needs to be a way of first validating the other party you are securely exchanging keys with is who they say they are. Which is the other part of what ISAKMP does. So, ISAKMP (Phase1) is primarily responsible for validating the other party (securely), and generating keys for IPsec to use. Then IPsec is primarily responsible for securely transferring data. What ties both of these protocols together, is the Internet Key Exchange, or IKE. There are more details in a write up I made over on Reddit when someone asked "Why is secure tunnel established in ike phase 1 not used for data transmission?" 

The other answers have spoken to the topology and are absolutely correct. I will speak a bit to the PIX config. If you are running PIX code versions 6.x, then you are going to be forced to consider NAT. As you probably know, in PIX code 6.x, any packets that are crossing two security levels (aka, interfaces) must be NATed or they will be dropped. This "security feature" is called nat-control. It is called this because in code versions 7.x and above, you are given the option to disable this behavior using the command . So, your options: If you are running code 7.x+, disable nat-control, and let the PIX route the packets from one interface to the other. If you are running code 6.x, you will have to NAT everything crossing your interfaces. The simplest way is to configure an Identity NAT for every IP. The configuration will look something like this: 

Imagine a postal employee having to deliver a letter to your address. It would be impossible for the local postal employee to know every residential unit in the city. BUT, its far more feasible for the postal employee to know every street in the city. The postal employee will find the street you live on, and from there count out the residences until they get to 432. That is how they will find your specific house. In this analogy, the street is like a network (Park Avenue), it is a grouping of houses that a single postal employee can know the location of. One street can exist next to many other streets, and as long as each street is uniquely named, they can be found by your postal employee. The building number (432) is like a MAC address, it is the specific house/building within a street. Other streets may have the same building number, but within a particular street there can only be unique house numbers. Your mailman doesn't need to know every house on every street, they just need to know every street. Once the street is found, they can track down the exact location based upon the house number. The internet is the same way. Instead of forcing a Router to know every location of every host in the whole world, Router's are only concerned with knowing the location of every network. Once the packet is routed to the proper Router (aka, the proper street), the packet delivery process can look up the appropriate MAC address (aka, the proper house) to deliver the packet to. So in the end, a Router exists to know the location of every network, and to move packets from Router to Router until the final Router in the path is found. When that happens, that Router will look up the specific MAC address to get the packet to its intended destination. For more information on how a Router does its job (and therefore, the job the router serves) check out this article that discusses how a Router moves packets through a network.