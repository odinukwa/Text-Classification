Next, you've got some deeply nested sets of matches. You're also performing some unnecessary clones in those matches. Let's address this first. When you match on a lvalue that you can't move, you can obtain a reference to an interior value by adding before the binding. This means that the bound variable will not contain the value directly, only a reference to the value. For example: 

I would call the variable , shadowing the outer variable. Inside the branch, there's no reason to access the outer variable, so why not reuse the name? Instead of a expression, you could use an expression. For example: 

The function takes a by value, but doesn't take advantage of its storage — it's forcing a move for no reason. To make the function more general, it should take a slice instead: 

The sorting part doesn't produce a value, it merely mutates an existing value (the vector), so imperative style fits best. I'm using to simplify the matches where we only do something on one branch. Other details: 

Here, you know exactly how many elements the will have before you return it, so you could allocate it with to avoid reallocations while filling it. 

We can eliminate the clones on the addition by requiring and using addition on references instead of direct values. introduces a higher-rank trait bound – we need this because we want to implement , whatever the lifetime is. 

A slice is a pointer and a length. The pointer doesn't necessarily have to point to the first item of an array! Thus, instead of maintaining an offset, you can update the slice itself. 

And now, let's not be lazy and code this up properly. We'll need to introduce a type that can represent either a parse error, or an out-of-range condition. 

This is a very generic function: the parameter is used to extract a particular field from each item in the slice. I was using this function on a slice of objects and I was interested in finding increasing values of a particular field of these objects. The function returns indices into the slice, not the values themselves. I needed to know the indices of the items in the longest increasing subsequence because I had to do something else with the items that were not in the subsequence (without destroying the original sequence), and using indices was the easiest way to do that. If I wanted to return the values without consuming the original sequence, I could have returned a of references to the items instead (). Single letter variable names don't really help to understand the algorithm. Since I was using this algorithm for practical purposes, I took the time to understand and document it. If this is just an exercise to learn idiomatic Rust, I suppose this kind of detail doesn't matter much. I like your use of a loop on a reversed range iterator at the end. I should have done that myself! 

Here, we're merely computing a value, so functional style is appropriate here. I'm using ( is a shorthand for ) to simplify the matches where returns . I need to use a couple times to turn a into an , because takes by value but we don't own either in that function. I've replaced the loop with , which takes care of exiting early when a value is encountered. ( does the opposite.) We could also use to remove one level of nesting. 

The problem is that by putting a lifetime on itself and using that lifetime for the returned references, the user of is free to choose whatever lifetime they want (actually, any lifetime that outlives the , since you can't pass a lifetime that's shorter than the type's own lifetime). Here, the lifetime that's used for is the lifetime of . To fix this, the returned references need to have their lifetime connected to the lifetime in the or parameters on 's methods. However, if we connect a return value to the lifetime of , that effectively locks until the returned reference goes out of scope (even if the returned reference is an immutable one, it keeps the mutable borrow active). Naturally, this would defeat the point of the interner, so we'll have to stick to . That means we'll also have to use a wrapper that provides interior mutability in order to mutate the . I'll be using below, which is fine for single-threaded usage; you'll have to switch to if you're going to use the same on multiple threads. Regarding good practices, I've noticed that you used as an identifier in . Normally, identifiers beginning with an underscore are used to suppress warnings about the identifier being unused, but you do use it here, so you should not be naming that identifier that way. I renamed and below. Otherwise, I don't have anything else to say, this is very clean code! Here's the fixed code. I've left explicit lifetimes in the code to better highlight the difference between your version and my version, but in reality they could all be elided. Note that it's no longer possible to box a while maintaining references to string slices, so I've commented out some parts of your test function. Also, my no longer compiles, which is what we want! 

Here, the branch evaluates to and the branch diverges. When the branch is taken, the statement breaks out of the loop, so the expression never produces a value. Rust handles this gracefully without us having to put a dummy value on the branch just to get the types to match. 

You just have to initialize it before reading from it; if the compiler cannot guarantee that the variable will be initialized at that point, it will raise an error. 

Instead of checking if the parse succeeded and then unwrapping the result in two steps, you can combine the operations by using pattern matching instead. Here, an expression will do the job. 

In , you use byte literals to check which range of ASCII codes the byte falls in, but then you use "magic numbers" in subtractions to refer to ASCII codes. You could use byte literals again; this would make the code clearer. 

would sound better as a factory method on , i.e. . In , you can turn the s into iterators, the two iterators together and that into a new . defers to ; implements and uses the iterator's to reserve enough memory for the reported minimum number of items at once, whereas repeated calls to may need to reallocate a few times (which may mean copying the 's items every time). (Note: we don't need to call on , as will do it for us. However, you could still do it if you like the visual symmetry; it works because iterators implement .) In , you can use on the range iterator to turn it into an iterator of key-value pairs, then collect that into a . In and , you separately assign tuple struct fields to local variables. You can use a tuple struct pattern in a statement to destructure the tuple struct and assign all fields to local variables at once. (This wouldn't work in because of the casts.) The patterns could also be used in the parameter list, but I find that they're too long here. In , you repeat the condition. I would reorder the conditions to avoid that. In , you can construct by getting an iterator from the and collecting it into a . This works because 's iterators iterate on key-value tuples, which is exactly what you're putting in your vector! In , you want to order by in descending order. However, the way you do it will panic when overflow checks are enabled of the coordinate is equal to . A safe alternative is to just perform a bitwise not on the value (this is written in Rust); we don't even need to cast to ! In , you can combine the two calls to into one: make the closure return a tuple. This works because tuples implement (for up to 12-tuples). So instead of sorting by , then by , we can simply sort by . When ing on a reference, it's typical to use the dereferencing operator in the match expression instead of repeating a reference pattern on all arms. In , each arm repeats the call to with only the character value differing between each arm. I'd make a method on that maps a shape to a character, then use that method to determine the character to write. 

Bonus: Here's how I would format your original code (note the changes to whitespace and the removal of parentheses). 

I am not aware of any safe method in the standard library to do this, so we need some unsafe code. In your code, you have two blocks. However, the first one is unnecessary: you can use to perform the cast, but you need two consecutive casts, because we can't cast from to directly. Actually, you should use here instead, since you don't actually mutate the referent. So, instead of , you can write: 

This block is useless, because you are unconditionally setting to 1 after a couple of other blocks, and you don't read back the variable between these assignments. 

If the function's body was inlined, the slice returned by would be unconstrained, and the compiler wouldn't be able to report an error if the slice accidentally outlived the data it references, causing subtle memory errors at runtime. 

Here, you're not using any borrows, so we're only concerned with bindings. Note that values are not intrinsically mutable or immutable. Therefore, when you move a value from one binding to another, you can change the mutability. The methods and take ownership of the , therefore they can decide to declare as mutable, even if the original value is not declared as mutable. For example, this is valid: 

I present you my own implementation of the algorithm, based on a slightly different C++ implementation, which is why there are so many differences compared to your version. I wrote this about one year ago, but sadly, I no longer use it. Note a few things though that are not necessarily relevant to the code review: