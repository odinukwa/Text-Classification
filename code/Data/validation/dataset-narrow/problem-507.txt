Suppose we're implementing an interpreter for the bytecode of some stack machine. Let every element of the stack be a , and let the stack be represented by a list: 

What your code says is "given two arbitrary types and , the functions form a monoid". This is not very meaningful, as the resulting definitions for and are not very meaningful. In particular, something to the effect of is required. What I think you were looking for is . A category can be seen as a generalisation of a monoid where not all elements can be combined. Haskell types and functions naturally form a category, with being the identity for each type and being composition of functions. 

(You haven't updated the question based on Peter's answer, so I can't really comment on , and will primarily focus on the rest.) First of all, your function names are misleading: should draw a triangle, while yours draws a certain number of triangles. I suggest pulling the triangle-drawing logic into a separate function called and then renaming the current to . You might even be able to make a function which takes a function for drawing one shape -- I haven't looked too closely, but it seems like this could work: 

This already seems more readable to me. Now you can split the logic that makes the values for the various local s off into separate functions and document each one. In order to do it this way, you do have to have return an , but that makes sense anyway -- and if you really want them as an array, just call on it outside the function (i.e. ). Even if you'd rather not do that, you should still change numbers that are used multiple times (in your case: 60, 90, 120, 180, 220) into named constants, unless they're entirely unrelated. 

First of all, stylistic matters: Why are you making a singleton? There is no need to require that only one exists: it doesn't use of any global state except itself, and the logging path could easily be passed in using the constructor (along with any of the other "constants" that seem rather arbitrary). If you want to treat problems as more than just , tuples you can write a class for them, but as things are I don't see you using it as such. Neither do I see why you'd want to hide the . A stream which functions as a bundle of other streams sounds like something you may want to use in multiple projects; write it up properly and use it. I'm not sure why you've made the / distinction. They sound like they have weaker restrictions: let that be decided by the constructor parameters or parameters or template parameters, but don't duplicate code just for that. Especially seeing as how you ignore real problems entirely if there are any available. What you're doing with the debug stream looks like too much trouble for me. If you want to ignore all output from the problems, why not just set the to ? You don't handle the case where a solution takes infinite time to execute. Perhaps it should only wait and after that kill the thing? Why are you first writing everything to , and only then to ? As for your performance problems: quite frankly, I'm not sure. Does only adding one problem to the and running it as a normal problem work? Is the difference only in what is printed, or is it actually present? 

You also seem to have an awful lot of duplicate code. Try to factor common operations (such as setting up all those members) into separate functions. Speaking of which, your functions aren't particularly clear. Why does a method called not return anything? What is it supposed to get? You've got plenty of hard-coded values in there. I hope that is a placeholder value; the other ones should be passed in as parameters. Could you make it determine the agent ID based on the email? As things are, it seems like this is prone to incorrect combinations of input if anything is changed. 

Unless you have further restrictions on your input, your code cannot be correct. You're assuming there can be tag nesting, so you should be making a parser. As far as I can tell, your grammar is: 

This is C++, not C. Therefore, your linked list class should contain the methods for operating on the list, and it shouldn't expose implementation details like nodes. For traversing the list, provide iterators. You should also make it a template so that it can be used with any type That's the general picture. More specifically: 

To summarise, if the user of your class sees a single pointer, you can be sure you're doing it wrong. 

You instead could use a list, but then the indices would start at 0, which I don't think you want. Thirdly, although your functions are all short and fairly self-documenting, I would suggest adding docstrings to your functions, as well as comments whenever you feel like you have to make an important decision. Even if you don't expect the code to be read by anyone at all, spotting similarities may be simpler in text than in code. You may also want to name your constants -- the aforementioned 100 is a good example, as well as the point you use in (why did you choose that point?). Speaking of which, may be better-named , if I understood the purpose correctly. In general, you may want to have function names start with a verb. 

Using on doubles isn't usually a good idea, although it may be okay in the case as you know you've assigned exactly 1.0 to it previously. I would write as follows: 

The code is much longer and the bonus in efficiency isn't going to matter. Granted, with C++11 you could change the into , and then it would be decent, but in C++11 you could also just do: 

To address the question of being too long: let's reformat the code a little and change the name appropriately: 

Where is some (possibly empty) sequence of characters that don't contain and is some sequence of (probably alphanumeric + underscore) characters. Now you could use something like PLY to build a syntax tree. You'll have to define your terminals: 

Well, first of all, you should put code in an block to make sure it doesn't run whenever the file is imported. Thus, just copy pasting: 

If this looks confusing, don't worry about it; it's most important that you get the basics down (like using ), and iterating is just a nice option that you can keep in mind for when it's more efficient/clearer. 

We'll need opcodes for addition, subtraction, and unary negation. However, apart from acting on s, we might want to treat the top two elements together as a , and then the next two as another , and then do something to those. To keep things simple: 

I know I am currently using a simple algorithm for the binary search tree which will not auto-balance the tree. I'll take a look at fixing it once I'm sure this way will work. I'll also be splitting out the functions so that they class definition is easier to read. I'm also aware that I should add a getter of some sort, but I have no need for it and don't want to complicate the code any further. Questions: 

The next thing to notice is that a number being even is actually a fairly common check to make. Such things should be turned into functions. Mostly copy-pasting again: 

As for design: the implicit sharing of state between dice bothers me. It isn't detectable as-is, but it means that there is no way of specifying that a particular die will return particular results (for debugging). If this is used in a multithread application, the results of may be surprising; I'm fairly sure should not be called from multiple threads at once. I think I'd go for the more explicit approach of having an and pair, or ensure thread-safety of . You could also make this more generic: