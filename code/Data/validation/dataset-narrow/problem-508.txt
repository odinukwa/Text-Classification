In this way the first permutation is returned as soon as it has been computed and everything is running more smoothly. 

I think there is a little problem with the performance of your implementation. When the number of elements increases (> 8 - 9) the time the algorithm uses to calculate all the permutations growths significantly which causes an "unbearable" delay before the permutation can be used (the function returns). The problem is that the function returns a list of lists, and the solution is to change it to return a sequence of lists as shown below. 

There are a couple of simple errors: 1) In you replace the next line with the second part of the split instead of inserting it after the first part: 

Secondly I think it is a problem that has its own implementation of because you then don't evaluate the base class implementation which could be invalid. A solution to that problem could be as shown below. Be aware that I have dropped the IPrimeChecker, because it is unnecessary. 

Naming: is not an index, but the actual value in the valid sequence (from min to max). I would call it or or something like that. I don't like the name either, because the target is actually the sequence of numbers from to . would be better IMO. 

Some minor points: 1) You don't really need the variable, so just do the math in the call to TryGetValue(). 2) If are all positive you may the loop if . 3) It is stated that there is only one solution per input, so you can skip the check . This will never be true for the nums that add up to the target. As for the rest of nums it doesn't matter. 

It looks alright to me, although it seems odd having a young man of age 20 to equal an "elderly" man of age 30 :-). I have 3 minor things: 1) One MemoryStream can be used to serialize all expressions: 

Beside that, I think your naming is quite remarkable and rather hard to read because of the length: For instance it's hard to quickly distinguish between: 

3) For the fun of it, you could consider: Because you basically do the same same loop nested three times, it could be a candidate for a recursive function iterating over each addend and yielding all the positive sums. In that way you could generalize the algorithm to handle any number of addends... 

I assume that does not return a possible duplicate url-friendly title or else you maybe are positively redirecting to "Index" having a duplicate url-friendly title set on the model because is not checked for duplication before returning. 

An entire solution that uses a discriminated union type for factor/nonfactor and minimize the Mock derive could be as follows - not claiming it to be best practice or anything like that. 

which of cause requires a lot more work. Update If you want to filter a list of skills by SkillLevel, it can be done like this: 

First of all I'll upvote the question for the effort. You split the problem into subproblems and you show good understanding of C# idiomatic as well as general programming skills. On the other hand I think you overcomplicate the solution, because your general analysis of the problem is a little too "chessish". Instead I would try with some kind of "mathematical" model: 

index["6+"] = [0,0,3,4,7,9]. They are a running total, so will always increase. This means the first two blocks don't have any matches, the second has 3, the third has 1 more, and so forth. There are 9 matches in the entire file. I pick a random number from 1-9 (inclusive). I pick 8 (i.e the 8th word). The last entry < than my pick (8) is index["6+"][4] (which is 7). The number I want is somewhere in block 4. I seek to (blocksize*4), and read one (partial) line, which is really part of the previous block. The number of words I've already skipped is index["6+"][4], (which is 7). I subtract that from my picked random number, leaving 1. I read the file, counting down for each match. The match that makes my counter go to 0 (the first one in this case) is the one I want. 

This way, you only have to read the index, plus (on average) half a block. Bigger blocks = smaller index, but more for the final search. Smaller blocks = bigger index, but you have less data to search through sequentially. Make sure the word list hasn't been changed since you made the index. 

Depending on how often you do this, and how big the file is, it may be worth creating an index (probably a file). Decide on a block size, (e.g. 1mb), and read the file from beginning to end; build up a dictionary where the key is your criteria (if there is more than one), and the value is a list of how many matches there are, before the END of that block (i.e. a running total). Words spanning blocks belong to the block before it. When you want to pick a random entry, the steps would be: 

Find the dictionary for the criteria you want to use (if you have multiple criteria). Pick a number from >0, <=(last value in the list) Find the block number: The index of the last entry in the list which is < the number you picked. Seek to that block - seek(blocksize*index), discard the first line (partial word). subtract the lookup for this block from the number you picked While the counter>0, Read through the file; decrease the counter for each match When your counter hits 0, the last line you read was the one you want. 

2 more options to consider. I suspect these aren't relevant here (though nothing in your post rules it out), but they are worth keeping in mind. Put your data in a database, have all the work done for you. Databases are REALLY GOOD at what they do. If you think a database has too much overhead, consider sqlite - tiny footprint, all the advantages of a database, and if you want to move to a different database later, it's easy. If you're always looking for 7 letter words, extract those into a file. Then all the words you don't want, don't have to be processed. Optionally, you can make your target file fixed length records (at least the size of the longest word!). For example, if your longest word is 23 bytes, pad all your words out to 23 bytes with spaces. Adding a new line (optional) would increase this to 24 characters. Then, if your file is 2,400 bytes long, you know you have 100 records; pick a number from 0 to 99, seek to that position * 24, and read your word. Don't forget to trim(), and beware of the difference between letters and bytes in multi-byte encoding! 

I don't like the concept that you have to chain the -calls for every property you want to modify in the copy process because you create a new instance for each call. A simple non-generic solution could be to use the and named parameters: 

I think your code is not that bad and for small segments and data sets it is all right. May be a better naming of the class Estacion would have turned you in the right analytical direction. I'm not that familiar with your language, but I think translates to or in English where a more appropriate name would have been or . The class is error prone in the following way: In the constructor you calculate but both and (and ) are public properties and may be changed in the process which will leave the object in an inconsistent state. In stead you should make the a read only Property as or . As for the algorithm it self I think Janos' analysis says it all. 

Update I'm not sure, if this is obvious to others, but, if you don't want to "pollute" your classes with the DebuggerDisplay method or you want to create a custom debug display to a type that you can't modify, then you can place the DebuggerDisplay as a static method on a static class like this: 

The only caveat is (as others have pointed out) that you don't check the before you start walking. That could be solved by using in a way like this: 

As stated in a comment the above solution does not handle accented letters so a better solution may be: 

To avoid the overhead of cutting of the length you could use an enumerator instead like this in order to handle the first group separately: 

2) The names sumI, sumJ, sumK are somewhat misleading because they aren't sums. Better names would be valueI, -J, -K 

Beside that I would change the flag to an too, because you can then distinguish between more levels like: 

The first thing I notice is the somewhat misleading method name . I would call it , because it only checks if i is a factor of number - not if it is a prime factor. 

3) Have you considered using and let the item class implement interface to keep track of collection and item changes in a dynamically and event driven way? 

When determine if a number is a prime, it is only necessary to check primes up to (inclusive) the square root of the number: 

(The meat of the extension methods can surely be done more sophisticated than the above.) is an with a rudimentary definition like: 

I like your idea, but instead of ending the sequence of KeysToValue() calls with a call to ToDictionary(), I would make an Add-extension to IDictionary like below. You then only need one extension, and it is more flexible: 

I largely agree with JanDotNet. I'm not sure if it's a good idea, but maybe should clean up after it self as a IDisposable? 

Here the groups found so far are given as argument to the function and finally returned as the first part of the resulting tuple (with the remaining items as the last). Yet another aspect to consider is performance... 

I use , instead of IList/IEnumerable because there are at most 7 possibilities, so it is IMO a convenient way. 

Instead of the use of the union type FBCase, I would use the tuples directly in a way like this (some of the functions then may need a renaming):