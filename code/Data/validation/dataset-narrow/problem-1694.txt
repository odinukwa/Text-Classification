I would say yes. I've done this with a different ARM box and Debian Wheezy. I've been using rygel as the server software. Installation and starting should be simple: 

Possible to connect some pins? With suitable wiring (maybe buffered), yes. Will it do anything useful? Probably not. Maybe you could step the head or something, but transfering data would require a pretty complex controller. It would indeed be better to go with a USB fdd if you need to read/write floppies. Pretty much all floppy drives are also (mostly) Shugart cabled, not PATA (IDE). 

There is a config UI of a sort ( IIRC) or you can edit the config file ( IIRC). You can set a number of shared directories and more or less obscure plugins and other features. I've found it to be the simplest thing that works with a PS3 reliably. It should be possible to get thumbnailing and transcoding working, but I think I haven't looked into that on ARM. Thumbs work on my laptop. There are other projects around if you want to look, including Mediatomb (should be in Debian) and ps3ms (Java). Others may or may not work with PS3 in particular. Old versions of Rygel also had problems here. 

If you have the package, it will also do a timestamp saving trick to prevent the clock from being reset. That won't advance time while the device is off, so it will lag behind. The internal clock will also drift a tiny bit while on. If you have an Internet connection (or lan with a server) and run ntp (ntpd/ntpdate), you can get the time over network, as other answers point out. When synchronized, it is really quite accurate. Online servers will also give you the consensus "world time". 

You will probably need to figure out the pairing and connecting process. I haven't looked if there's a handy ui available for rpi for this, but you can script it or do it by command line. See $URL$ for some instructions. 

I think #3 happened because the devs thought WiFi is prioritized in peasant non-poweruser environments. I could only speculate since I can't find any info on this. 

Now that a game ROM is in the directory and a copy of the bios file is in the correct location go into EmulationStation with 

Disable unneeded software services on the Pi. Avoid unnecessary peripherals (USB devices, GPIO accessories) Shut down the USB controller and LAN chip using these commands: Undervolt and underclock the Pi by editing . Set the minimum ARM frequency to 250, minimum core frequency to 100, and minimum sdram_freq to 150. Disable the HDMI port using the command For Raspberry Pi 2: Limit the amount of cores you'll use. Add in where "N" is the number of cores you want. 

Yes, it's powerful enough. I've used it in an OpenCV project before. You may have to lower your resolution a bit to get the best speed. If you want to use a first-generation Pi (single core), just go ahead and compile it. If you want to use the quad-core Pi, you will have to compile it with multithread support. I'll leave it to you to figure it out. It's up to you which one you'll get, but I prefer the Pi 2 Model B (quad-core). You may want to consider power consumption if you plan on powering your project using a bettery. 

Take a look at a BMP085. In fact, Adafruit even has an article all about it (how to use + sample code) 

Remember that most carriers implement a very strict NAT when it comes to mobile data. You will need to, at least, implement a reverse connection from the Pi to the controller, depending on your setup. See below. Depending on your setup 

Here's a wireless and portable 315/433MHz radio sniffer utilizing an Invisicobbler: $URL$ I tied the Pi to the breadboard using an enamel-coated wire for additional portability. 

One does not simply connect something directly to the Pi's GPIO pins. Your solenoid will draw too much current from the GPIO pins. So, no. Your solenoid won't even move and your Pi will be fried if you connect it directly to the GPIO pins. As JaromandaX pointed out, you should use a MOSFET. Activating the MOSFET's gate pin will let power through. The Pi simply cannot power a solenoid directly. A better way would be to let the Pi control a switch that controls the solenoid, the switch being the MOSFET. Oh, and don't forget the diode in the circuit, else your MOSFET will release the magic smoke or explode/catch on fire (the former being much more likely), possibly taking the Pi with it. Take note that you're not limited to a MOSFET. You could also use a relay or something else. 

There is the risk of accidentally getting both pins configured as output at some point. Maybe you could add some series protection resistors to the input lines (and perhaps output)? That would give some extra safety and should be dimensionable so there will be no voltage lost from "low" impedance outputs to high impedance inputs. There should be no problem with edge speed on keypads :) 

I believe you can also just write these into a sysfs file at runtime in some cases. Seems the usbhid is read-only on my (desktop) system, though. 

I haven't looked into these more and you'll need to find the actual values from somewhere (source, LXR?), but maybe that's a start. 

I think the problem is that type reads happen instantly and blocks. So the program spends its time in the sleep statements and after one branch is finished, it reads the buttons in a flash and goes into a branch where it sleeps some more. Unless you're holding down a button at the moment the read happens, there won't be a count. While the program sleeps, the buttons are ignored. You could try holding a button down long enough for the next loop for a start. You may need a slightly different approach than this loop for a real-time problem. 

It should be possible, in theory. Practically, you will probably need a breakout board or an adapter of some kind to match the connector and interface of the camera module. You will also need to find out how that particular module (or family) is interfaced with. If a datasheet can be found, that should contain useful information for both projects. For starting points, you might try looking for (microcontroller) projects using the same kind of camera module and if there are any kernel drivers for the module on other systems. In any case, it will most likely be a great deal of work with somewhat special skills and usually very weak and hard to attain information and political issues. In other words, a magnificient learning experience. I urge you to publicly document all efforts. :) 

Your public files are owned by root. Apache can't access it. Change the ownership so that it's owned by . To restore ownership of the files in your public directories, run these: 

First off, your Pi is connected to your computer, which is connected to your router. I'm not sure why, but here's one way it can be done: 

Open up with your favorite editor. Search for a line that says . It should be on line 67 if I'm not mistaken. Uncomment it. I assume you know how to uncomment since I think you know scripting. Profit. 

Absolutely DO NOT connect the battery in parallel with the load. The charger will not know if the battery is full or not and will continue to pump power both to the battery and the step-up converter. Since the battery is still receiving power and is still charging, it will overcharge and explode. If you want to do this properly, you should use a proper LiPo charge controller with an integrated power output (link) which will eliminate the charger+booster combo in your setup. The module linked above is featured on Adafruit's blog (link). You can also search the internet for something similar and cheaper than that. 

For prioritization of connections, I recommend you install . Then, simply prioritize your connections in Highest priority is 0, next is 1, then 2, and so on. 

If throws a GCC error (something about a version mismatch), it's okay as long as your current GCC version is higher. Run instead of Then, proceed with your Hello World example. Create the folder and into it. Then, create the files. 

Also, consider proper shielding from heat, since your Pi and batteries are in a car. If you really want to use your own batteries, consider this. Oh, and this one definitely supports AA batteries. 

Then, save it using To restore, simply run As an added bonus, you can add the command on so you don't have to manually run the restore command every boot. Modify that file so it looks like 

One (very Unixy) approach would be to call a helper program (command) that can do the GPIO operations for you. That should be relatively easy in any language and doesn't need bindings beyond system(). The helper could be written in C, Python or something else and made to accept a few arguments for what you want done. A more elaborate helper might run as a daemon and accept connections over sockets from programs wanting to manipulate GPIO. This may have more issues from security standpoint, but may also be better since GPIO access is already a bit hairy issue. 

I believe "TTL serial" means async serial you'd find in a common UART. A natural way to attach this printer to a PI would be to find a UART on the board (GPIO 14/15?) or attach one to another bus. There are a few good (FTDI, CP2102) and worse (Prolific) chips available for USB and loads for I2C and SPI. If the device demands handshaking, you'll have to worry about that as well. The Adafruit page doesn't seem to use any (Tx/Rx only if I read it right). If you do want to do this over actual GPIO (logically fine, but see others for warnings about electical compatibilty), you could search for "software uart". 

If you can program, you can pick up python amazingly quick and get useful stuff done almost right away. There is an impressive library of stuff available as well. But it shouldn't be absolutely required for any pi related work. You can attach many sorts of IR receivers to a PI, from demodulating detectors (like used with TV remotes) on GPIO to somewhat specialized USB dongles and irda modules. What you use depends on what you're trying to receive. There are also less communication-oriented IR uses in e.g. PIR sensors, light beams, and raw "morse code" style flashers that are all accessible as well. Which ever task you want to do, you should try to find a receiver that looks like a standard device of some sort to avoid having to hunt for drivers. A USB serial port type might be handy for the pi. There's a logic level UART on board (might not be avilable/easy for this) and you can get bot LL and EIA232 voltaged serial dongles for USB for more ports. These do your classic cellphone-laptop-printer style communications, not TV remote style. For on-off signals, GPIO might be the way to go. It's harder to do fast signals with the roundabout way these are accessed in common operating systems. Accessing GPIO without breaking system security is another challenge. How you get to these from Node, or js, is another matter. There may be a library/binding for accessing some devices. Others you can access through device files or by running some kind of middleman program (this might be a natural spot for Python) that will handle the device and that you can talk to from js. If it all seems unfamiliar, think of this as some pointers and keywords to a lot of interesting reading :) 

It's already working since you can connect to it. Putty would give a error otherwise. In this case, make sure you typed the password correctly. If you did not change it, the password should be . Another possibility would be you're connected to the wrong machine. 

Add a pull-up resistor. Pin is high when it detects IR, and low if it doesn't. This will not solve the random HIGH/LOW state, but it makes sure that the value comes from detecting IR and not from random electrical noise. Sources of electrical noise include: 

A male-male USB-USB cable won't work. You have to make your PC act as a USB slave which is not possible for regular users and/or because of the hardware. PCs are almost always master-only. The Pi also thinks it's a master. We can't have two masters or else one or both of them will break and/or literally burn or, in the best case, the connection simply won't work. Also, going without adapters is not possible for regular users. You'll need adapters. Just go buy a cheap WiFi/Ethernet adapter if you want it cheap. It will save you the hassle. It's also cheaper considering you have to replace your PC/Pi when something breaks because of totally unnecessary tinkering (unless you're a hardware hacker, then I encourage you to do it). Going with adapters is the cheapest and the best way (if not the only way). If USB is not your thing, there's ENC28J60. It connects using the SPI port on your GPIO pins. 

Not that I'm aware of. But, you can do it yourself. (link) But, the interesting thing here is there's no difference between the Pi2 and the Pi3 kernel (yet). So, go use a KVM-enabled Pi2 kernel. Good luck with performance though. 

Primary step: get another power supply just for the relay. Connect the ground of your Pi and the ground of the power supply together. WARNING: Refer to your datasheets when choosing the correct voltages. In this answer, I'm using an NPN (N-channel) MOSFET connected as a low-side switch. Assume power supply is 5V. Make sure your MOSFET is rated above your power supply's voltage for safety (i.e. don't get a 5V MOSFET if your power supply is 5V). Assume I'm using a logic-level MOSFET for simplicity sake. You can also get a logic-level MOSFET for simplicity. Assume my mechanical relay will switch at 5V.