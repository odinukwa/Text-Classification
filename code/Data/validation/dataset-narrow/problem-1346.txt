In my 2D tile based platformer I have added plants to be able to farm such as the simplest, grass, to other things like corn. Now each of these speacial tiles must be updated to show how much it has grown (Simple states such as 0 = New, 1 = Mature, 2=Blooming) My question is, what would be the best way to do this? So far I belive I could: 

I've been thinking about this for a while. I have a 2D tile bases platformer in XNA with a large array of tile data, I've been running into memory problems with large maps. (I will add chunks soon!) Currently, Each tile contains an along with other properties like how its rotated, if it has forground / background, etc. An is static and has properties like the name, tooltip, type of item, how much light it emits, the collision it does to player, etc. Examples: 

This way you can just do and have a nice object oriented approach to accessing it (, , etc) and will probably help you later in the long run. One of the bigest mistakes that will hurt you later is not applying elapsed time. If your FPS drops (different computer, running alot of programs, etc) or rises then your sprite will move faster, since it is depending on the update rate. You can solve this by applying elapsed time. 

I have a 2D grid based water system in my XNA game, we have a method using cellular automata to simulate water falling and spreading. Example of water flowing down a slope: 

My question: Which of these two processes, if either, would be less of a burden to the cpu? If neither seem reasonable, what other alternatives are there? 

Personally, I use a spin on the first option you listed. When checking if A collides with B, however, a series of disqualifiers (or a singular disqualifier) can be used to reduce the computation required for each iteration of your collision checker. For example: 

While testing my player's jumpinig algorithm, I've come across two odd problems. 1) My player's hard-coded jump height is always much greater (roughly 1.5 times) than the in-game result, making me enter completely abstract numbers for the hard-coded value. 2) My player's jump height increases with lower FPS. At 60 FPS, the jump height was found to be 237, and at 30 FPS it was 269. This has me completely bumfuzzled. I've been using this article pretty heavily while implementing my jumping function which can be seen below. 

One solution would be to use raycasting collision for the circles, and traditional box-collisions for rect-rect collisions. 

Supposedly the Source SDK went bonkers when Steam implemented SteamPipe. I have tried it myself and I frequently get a pop-up error saying: "Failed to load the default scheme file. The map view may be missing some visual elements." All of the view ports in the ui are blank and I can't interact with them at all. I'll do some more research into it and comment on this if I find a fix anywhere. 

SDL2 is very capable of doing exactly what you ask. SDL2 is also more efficient and has much more utility. I highly recommend upgrading to SDL2 by following the instructions provided in the Migration Guide on SDL Wiki. EDIT: It took me a few days to migrate my project from SDL 1.2 to 2.0.3; most of the migration process was changing from SDL_Surface to SDL_Texture and figuring out how the new SDL_Renderer and SDL_Window types work together. 

Its perfectly acceptable to use TCP instead of UDP - if you turn off the Nagle's algorithm. Once you turn off Nagle, you have most of the speed of UDP and will be fully able to make a twitch reaction game. Indeed, I have made such a game using TCP in Flash: $URL$ Hope that helps! 

To answer the platform game specific part of your question: Platform games are traditionally tile based. Tiles are fixed size rectangles which comprise the building blocks of each level; they can have the appearance of stone, or grass or any surface you can imagine within reason. The best way to design them is to ensure that when two identical tiles are placed next to each other, the texture seamless repeats. A good example of how to design repeating tile sets is here: $URL$ Tiles are laid out in memory in what is called a 'map'. Each tile is given an identifying number; maps are rectangular arrays containing numerical tile references. An example map might look like this: 

I wanted to say, its Separating Axis Test, not Theorem. You'd use SAT on non moving polygons (2D), although you can extend it to cope with relative linear motion. $URL$ Don't use GJK in 2D, I found its actually slower than simply brute forcing SAT. Another technique you can use is Minkowski Difference, which shrinks one object down to a point and 'grows' the other by the shape of the first. Then you test the combined object against the point which is a lot easier - this gives you penetration distance and normal. I find this tool is conceptually very useful for approaching new collision detection problems; easier to visualise than SAT. For moving and rotating polygons (and polyhedrons) you can use Conservative Advancement to find the exact time and point of contact. $URL$ You can read more about these techniques in this blog post which I wrote a while back: $URL$ Hope that helps! Cheers, Paul. 

Obviously enough, if a collision-enabled object does not come within vertical range of another collision-enabled object, the collision system wont even both to run the numbers. There's tons of ways to implement this, too. If your system is texel based, you could even use raycasting as an accurate qualifier which might, in some cases, be simpler. 

I would use a circle for the body and a single rectangle for the beak, but that's just my opinion. Overcomplicating your collision geometry can slow down your app though, you're practically doubling (or more) the number of characters on-screen. 

The angle of the feet is equal to the angle of the inclined surface. Since we conveniently have two points on that slope, we can find the angle of inclination (it's also possible to use two corners of the slope's triangular shape, but gradual slopes would become over complicated; for rolling hills, this is the best solution). Ultimately the slope will be H/P (assuming the heel of the bent leg is directly beneath the corresponding hip), or arctan(H/P) rad. Using cosines, one can easily find that H = (F+T) - (Fcosθ + Tcosφ). The angle of the foot becomes arctan((F(1-cosθ) + T(1-cosφ)) / P) PS: If you want to REALLY get into, you could also find the added width to P. PSS: The foot will only bend to far up, so keep that in mind before you try to climb an 80 degree slope. PSSS: People don't climb hills on their heels, but they do rest on them. Keeping the foot perfectly flat up the hill could somewhat accurately depict the player standing on the balls of their toes, and allowing the heel to sink to the ground while idling could make for some very realistic movement. 

Implementing any constraint in an impulse/velocity solver comes down to finding the relative velocity between the two connected bodies that you want to remove. In the case of the distance constraint, this relative velocity is always in the direction between the constraint anchor points. 

Most platform games have multiple layers of these maps; background tiles generally have no collision information associated with them and are purely decorative, mid-ground tiles can be used to mark locations associated with game-logic, like entrances and exits, or for placing AI characters. Foreground tiles are used for collision information and the main body of the actual platforms. Maps can be connected together using special tiles which indicate an entrance or exit, when collided with the system can unload the current map and load in the new one. You can read more about platform games in general here: $URL$ Hope that helps! Cheers, Paul. 

If you get the relative velocity of the two bodies, project it onto the normalised vector between the anchor points, you'll have the velocity that you want to remove. 

I made a pinball game a while ago; it was pixel based as well. I had a collision map which just contained the collision data. An approximate collision normal was easy to find: Take the area of collision map overlapping the ball, find the centre, form the vector from that point to the ball centre, then normalise. Hope that gives you some ideas :) 

Then, all you'll need is an equation which lets you remove velocity by calculating an impulse. Plug in the velocity to remove and out pops an impulse which you can then apply equally and opposite to both rigid bodies. If you'd like to read more about this process, I wrote an article a while back which covers designing a constraint in a impulse/velocity solver: $URL$ Hope it helps! 

Like countless other video games, I'd like to have scripted sequences in my game. Character 1 says something, the player replies, then a rock falls, that sorta stuff. I could find a way to do it, but I would like to use a common method, assuming there is one. My current thought is to have a separate file for each level of the game that contains all the possible scripted actions for that level. When the corresponding trigger is activated, the function is called. I think early Call of Duty games (up to CoD4) used something similar, but I'm not entirely sure. 

As a mobile gamer, I can say (personally) that some in-game adds don't bother me at all. For example: the game Jupiter Jump by Noodlecake Studios only shows ads after the first attempt (full screen) as well as at the main menu along the top. I think this is well-executed, as it doesn't overload the player after every attempt. Vector, by Nikku, is a little encumbering. After every attempt (roughly every minute) a full-screen ad is displayed. This not only annoys the player, but abruptly interrupts the flow and plot of the game. Placing your ads away from the main focus of the screen creates far less stress for the user, and carefully managing the frequency at which you display ads can also keep your players engaged and entertained while unknowingly supporting the developer. One thing to avoid at all costs is "pay $2 to get 50 coins!" If the user downloaded the game for free, odds are that he or she will steer clear of paying for anything, unless they become obsessed with the game (Candy Crush Saga). Also avoid using "sign up for Dish to receive 1000 XP" sort of deals. It's completely irrelevant to the user, and encouraging the user to sling his or her credit card information at one random company or another is borderline immoral.