I just now also tracked down another issue with currently in Debian Sid. See Debian bug #682308. With , there is a regression bug causing tab switching and new tabs opening in Google Chrome and Chromium to stall significantly and spike CPU usage. Three different workarounds are mentioned in the bug report, awaiting an upstream fix: 

only finds files of maximum path depth 1 under the argument directory. Also: replace with a simple when trying out changes, as you most probably do not want to find out the hard way that your changes are not what they are supposed to be. will make the script only look for the special file in the first sub directories, and if it is not found, delete them. If the special file resides deeper, you have to do a full depth check, but this solution fits my interpretation of your question in its original form. 

Wikipedia keeps the probably most comprehensive and updated list. Another question is why it would matter to you; package count does not say much in itself, and to the largest part, all the "big" packages are available for all distributions. 

Just specify the files in wanted temporal order and it will use the timestamp of the first file as a base, and add one second incrementally to each of the following arguments. If the reference file is given multiple times, it will retain it's original time (this is only to be able to do e.g. "retime 0001.jpg *" without changing the reference timestamp). If another file is given multiple times, it will get the last logical timestamp. Without , will dereference symbolic links, which is most probably not wanted in this case (if you say "symbolic what-now?", then don't worry). 

and then once again try to delete the file. If this fixes it, you simply haven't logged in to the new group yet. The group login happens with your next login shell, and if you run a GUI, the easiest way might be to restart it (or the computer, which will imply the first). 

There is currently a process using the module. If X is running, this is surely it. You can try to stop things somewhat nicely (all graphical applications will die) by e.g. 

supports the option to treat binary files as , or . The last option should skip binary files. It is equivalent to . I did a test and it seems Busybox's supports to skip binary files. is not "magical" in determining if a file is binary or text: it simply checks the first few bytes to see if they seem to be text or not and assumes the same for the rest of the file (according to ). 

The question could as well be: "what does Outlook/Thunderbird/Mail actually add to the function of mutt?". There are also other text-based email clients that are quite popular. They simply blend well into many people's workflow. It's not for everyone, apparently, but neither are graphical clients. 

See and . matches the beginning of a line, which in practice makes this match every line. One can also opt to select only lines longer than e.g. 60 characters with 

See for more info, and what switches are also implied by . Since it's only a single argument, it would be more straightforward to use substitution: 

Here is a quick attempt that I could get to work like this. Note that it assumes that the input file is in landscape mode, as is usually the case for presentations. My was created with Inkscape in seconds (A4, landscape, create a textbox that fills the entire canvas, size 100, fill with underscores). Save the script as e.g. , make it executable and call it with a PDF file as only argument. 

A tip for readability is to use another regex delimiter character when you need to use a lot of slashes: 

When I upgraded a Ubuntu machine to 12.04, I managed to accidentally close the terminal that was connected to the updating process. Weirdly enough, the process actually continued in background (until it hit a "Do you want to install a new version of this configuration file" prompt and I killed it). This shows that the updating process is written robustly. Yesterday on a Debian Sid machine I Ctrl+C:ed during an installation. The prompt was returned to me, but Aptitude kept throwing messages about progress to the terminal for a short while, until the action currently in progress was finished. I believe that Aptitude (which I use, and I would guess that behaves similarly) tries to handle signals intelligently, and once an action has begun (such as installing/replacing/removing), it will do its best to actually finish this before exiting the process as not to leave the system (and especially the global package configuration state) in an uncertain state. I tried just now to send Ctrl+C during package downloading, and the package currently being downloaded was interrupted and not saved in a semi-downloaded state. Simply doing a new restarted the process at the file that was not correctly downloaded. That praise being said: if a couple of packages have already been configured, they will not be rolled back to previous versions if the process is interrupted. The best it can do is to quickly clean up, intelligently let you restart the updating process and hopefully start of where you left it. After doing this and all pending actions have been taken, the package state is again "clear" and you can start trying to roll back versions and so on if it is needed. Final note: don't start depending on this behavior, since it is very rough treatment of the package system and always might lead to package problems (fixable, but often with some manual package downloads and tinkering). 

Actually all the functionality in (, exit statuses, multiple file match inputs) can be easily added in this shell script context as well, but I leave that as an exercise for the reader. 

It's always risky to give a "No." answer to existence questions, because all it takes is a single counter example to completely refute, but let's go: no. That is not how explicitly VNC works. You can however change the resolution with on the remote computer, but it is not VNC that would do this. The best a VNC viewer can do is give you a scrollable window. Another option is to start a separate VNC server for your remote needs. Then you can choose the resolution you want. You can even connect to it locally on the remote machine if you need to do some work there as well. E.g. 

On a CRT, the entire image is redrawn on every possible refresh, since it is drawn by illuminating pixels by an electron cannon. The pixels glow for just a short while (which is wanted to keep latency low), and need to be re-illuminated many times per second (refresh rate). On an LCD (there are different technologies here as well, so this is well general) there is an always-on backlight that throws light towards a panel of pixels that are individually controlled to let through a specific amount of light depending on what the screen wants to show. This is controlled by (using TN technology to demonstrate) "twisting" a pixel corresponding filter to different degrees by applying a voltage. If twisted so it blocks all incoming light, the pixel is dark. If twisted perpendicularly, the pixel is maximally light (= back-light color = white). The twisting is not reset during every screen update if no image change is wanted (a few years ago, this would have rendered these displays unusable since they were so slow to update, hence ghosting), so LCD displays should fall under your wanted category, depending on what you mean by "redrawing". 

That you need to set the clock and boot order frequently means that the battery on the motherboard is bad. You could try to replace it. Since you have ruled out other factors, perhaps the above manifests itself in reboots for some reason. Otherwise I'd suspect the PSU (always suspect the PSU :-) ). Or it is just a symptom of the motherboard being very old, which might have worn out other components as well. You say you have exchanged everything but the motherboard and CPU - it's probably one of those then. Probably the motherboard. A distant last option is that your electricity is so spiky that the computer reboots, but you should notice this well more in lamps and other equipment. Computers are often less sensitive to this than other appliances since the PSU contains large capacitors to handle the power switching, and thus can handle short outages without problems. 

It can either be used as a CGI script on the server and linked directly from the <img> tag, or run on the command-line to generate standalone image files. From the homepage: 

(without GNU find, replace with ). This way will first find the directories that are named and then recursively grep only in these. To limit the search to PHP files: 

Use the UUID values instead of and in , just as the automatically generated entries above do. To find the correct UUIDs, do 

You are asking the wrong question if you want an answer other than "No" - root can not be hindered from doing anything (including changing permissions, but can *deity* set permissions so strict that even it can't bypass them?). What you probably want is to be able to give out some administrative privileges (installing programs and such) to users without making them almighty on the system. For this you can use e.g. with restrictions on a user/group level. 

should explain the switches clearly and probably better than I would. Piping is powerful, but the base tools handle many scenarios by themselves in a more straightforward manner. This avoids unnecessary process forks and keeps subtle errors to a minimum. 

There are many free OCR services for PDF files (I can't recommend a specific one myself since I haven't used them, but $URL$ can help you). These services can probably recover the text portions of the document, which may or may not be helpful depending on what you mean by "some precise formatting". 

If a file is opened somewhere, then even if you delete it by it will remain on disk until it is closed. Thus, if you e.g. have a program that is writing to a giant log file, just deleting the file might not give you back the disk space until the program also closes the file. Read about for more information on the topic. 

To also remove directories, as you ask for: just change into in the above commands and skip matching on only in the commands. 

You could/should use the package to create a dummy package that provides . This does that you don't have to install PulseAudio just to satisfy dependencies if you have solved compatibility otherwise. In this case though, the program seems to be working without any dependency problems (which technically is a problem in itself if it actually does not work without PulseAudio). 

will list the contents line by line. This can be piped to directly, but beware: do the deletion very carefully. You don't want to just everything that tells you, since it might include directories that were not empty before unpacking! You could do 

First, one of the points of tunneling through SSH is that you don't have to open up the port to the world. The communication in practice is carried out over your SSH port. Second, set the source port to 5901 and then connect to VNC server at . It might be interfering with an existing VNC session on 5900 (=) or something. Otherwise, it should not be a problem (I routinely do SSH forwarding 5900:localhost:5900 and it works, though there is no local VNC-server running). 

None of the things you say happen, actually happen. The four commands do nothing. Perhaps you have an alias for loaded. You can check this with . 

The first three lines are just a header explaining what the first three columns (the three characters under the signs in row 5) are acronyms for. You package Vim is shown as , which means 

where the glob hits the individual files within the directories (it could even be specified to , or similar, but it should not matter here). Note that this is the full command, without need for the construction. 

There is some additional functionality as well, but that is the gist of it. It should be easy to add a system call to your shell in the code instead of giving a user error, so take a look if you want. I made some modifications and small bug fixes that are available here. It depends on . Compilation instructions are on the initially linked page. 

I'll post my variety since it won't hurt anyone, and perhaps fits someone better as-is. I use it to resize a pane in a irssi session inside tmux that reads the output from the script. The pane frequently gets resized when I attach over different terminals, and it is needed to be >20 columns wide for the FIFO to work correctly (and it's unnecessary to have it wider, stealing my screen space). Ignore the convoluted calculation and use the grep+sed one instead if you want. The current one was mostly an experiment to keep the script entirely in shell (except the tmux calls, of course). It is most probably faster, which might be interesting for automation where the script runs frequently (I currently run it as a specific call, though). 

It is not needed to change ownership of the file afterwards when using redirection like you describe. When using as suggested, it is on the same premises not needed to use : 

There should be no issue having several kernels installed. In fact, to my knowledge it is standard practice to install newer kernel versions alongside the old versions, instead of overwriting the old kernel while it is running and thus risking ending up with a non-functioning system after next reboot. One can see the application in always keeping a verified working kernel in place. 

Microwave ovens completely kill my connection. I don't know how they would be represented in your program, but I would try to do some controlled tests of that, to see the characteristics of microwave oven signals. This corresponds well with your assertion that the signals don't last very long. It does not correspond well with that you say your analysis program seems to register it as a legitimate WLAN signal. If nothing else works, and believe me, this should definitely be the last option (after e.g. asking strangers on the internet), you can try actually knocking on their door when it happens and see if they know if they did something special. 

Home # Enter works obviously, and is quite short. An alternative to Home is Ctrl+A. Another possibility that might be closer to what you want in practice is to clear the line with Ctrl+U, which stores it in a buffer which you can recall with Ctrl+Y within the same terminal session. This won't save it to history, but from your use case it sounds like you want it within the same terminal session anyway. 

You should use a tool that is made for this purpose. If you really, really, really want to do it by parsing output, you could do something like 

I have been involuntary help desk for a similar Windows 7 issue, where it took, I kid you not, more than 24h for the update to finish. The only reason the computer was let to have this much time is that I was geographically not there and the best advice I could give was "just let it be". I actually have no experience of updates hanging forever, just that it can feel like forever, so I suggest just leaving it on for a long time (overnight) before looking at other actions. If there was a hardware failure, hopefully some internal test would notify you. 

The details on your environment are very sparse, but if you use Bash or equivalent (e.g. through Cygwin), you can set for this functionality. Demonstrated: 

Check the Task manager. Under "Processes" you can see individual CPU usage for your processes, and there is a global graph under "Performance". If there is dust in the cooling elements, the fan will have to work harder to keep the temperature down since the air flow is obstructed. This is common with older laptops. If you have the confidence, you can disassemble it to try to clean this, but possible warranty and such are (for good reasons) out the window.