This is not a problem specifically related to MMOs; single-player games often have level caps as well, and the fundamental reason for introducing them is the same. It's much easier and more practical to balance for a fixed range of progression than an infinite one. You postulate that one could just implement a "mathematically designed leveling system that keeps the leveling experience interesting and endless" but this is much harder to do than it is to say (assuming you still want "fun"). Essentially all this is doing is finding power curve that isn't too shallow or too steep and using that curve to scale a player's statistics. This is not likely to remain interesting for a long time. It lacks variety. It's just numbers getting increasingly bigger, and while that may entertain a few people for a little while you will eventually reach the point where the numbers are too big to be effectively comprehensible (42,132,927,189,100 strength) and don't have an appreciable impact (you might deal 92,101,626,001,292 damage per second at level 67,192 but enemies your level have a similarly inflated HP score, so it still takes you the same amount of time to actually kill them as a level 67 player). Players are usually engaged by progression that introduces variety and choice (for example in the array of abilities they can chose from). A secondary effect in the introduction of choice is the ability to plan, to elect abilities or skills or gear that synergizes with itself in a particular way. While many games end up with some of those synergies organically, at least a good portion of them are initially planned for; it's much harder to ensure that sort of opportunity for fun exists in a system where abilities are randomly-generated and made available. A system with procedurally-generated progression breakpoints is totally possible. It's hard to tune into something fun, though, because the more procedural variety you introduce the less designer control for fine-tuning you have. This means the designer is often forced to balance against the potential components of an ability set, not the abilities themselves. For a concrete example of such a thing in a small (non-infinite scale), consider the original Guild Wars and its expansion chapters. Each chapter introduced a large new set of skills, and player progression was mainly measured in skills and not level (which was capped at 20). Balancing for that combinatorial explosion was extremely difficult and allowed several undesirable, unbalanced (both over and under powered) combinations at times. That's why Guild Wars 2 chose to go with a much more directed and focused system. A fully-procedural progression breakpoint system would be interesting, but nobody's tried/done it well yet -- and besides, assuming a perfect implementation of such a thing, you wouldn't necessarily need levels at all at that point. 

There isn't one way that "it's done," really; it sounds like you may be coupling you renderer and your entity system too tightly together (generally they don't really need to know about eachother). However, it seems like a straightforward solution to your problem is to introduce hierarchy to the appropriate components. Presumably the gun entity has either a transform component or a visualization component with transform information. Or perhaps tranformation is considered important enough to be a first-class property of an entity in your system. In any case, add the notion of a parent reference to whichever aspect of your system has the transformation information. They you can recover the Z order information you need from that hierarchical structure, just like you would in a graph system: Order your top level components by whatever predicate you consider appropriate to break Z-order ties (such as by their screen height). Assign the first component the next available Z index, and then assign successive Z indices to its children before moving on to the next top-level component. This will not solve every possible problem, but it will put you back into the same problem space as a graph-based solution. 

however, your loops (with and ) are over the width and height of the source rectangle in pixels. For an input of (0,0), this works out fine. But for an input of (0, 1) (assuming and are both 0), you end up trying to access , which is not what you want (you want to access ). I'd write the loop thusly: 

You will note that the linked site details a four-step process to register, but notes that, before applying, the following requirements should be met: 

(Emphasis mine.) This implies that you can directly create a render component without a renderer itself. However, that fact doesn't actually gel with the architecture of the rest of your code, since you are having to go and look up some ubiquitous renderer instance and register the component with it. Invert that relationship, and have the renderer be the interface through which you create render components. That is, instead of what you have now, which looks like 

I know of three that still seem reasonably actively developed: Spring, OpenRA and Stratagus. Wikipedia has a list of open source game engines, some of which may be appropriate for an RTS game (such as FIFE, which used to bill itself as a Fallout-style engine, but should still be appropriate for RTS games). Some of these engines may work directly with 3DS Max model files, but that file format (.3ds) is actually pretty archaic, cumbersome, and suboptimal for direct consumption by a game engine, so you may find that the engines instead support some other model format that Max can export to (or supply their own conversion tools). Also, it's not open source (and does in fact cost money might cost if you need certain features), but people have used Unity to make RTS games as well. 

Do note that this could mean some objects that should be behind others show up "in front," especially if you are not then depth-sorting your transparent rendering. You may want to look into other ways to handle order-independent transparent rendering, such as depth peeling. 

The PNG format has support for more-or-less arbitrary metadata. The PNG standard defines a PNG file, essentially a series of chunks, some of which are required (and contain the image data). Others, however, are optional. For example, there's a chunk for storing gamma information or histogram data. In particular, there is a chunk that can be used to store arbitrary key/value text pairs. This can be used to ship around any kind of arbitrary data you want, provided you can represent that data as text (which is fairly likely). You will need a PNG library that allows you access and manipulate these additional chunks (such as the reference library), or you'll need to write one yourself. Then it's just a matter of choosing how to encode the data you want as key/value pairs. I'd suggest the following: 

I would strongly advocate the use of IDs, and GUIDs especially. GUIDs have a number of excellent advantages: 

Further, it is generally a very dangerous approach to use entire existing engines as learning material without guidance from somebody who was heavily involved in the development of that engine. Source code alone only tells you the how of particular design decisions, not the why behind most of those decisions which is often extremely important given that so many choices in software engineering are from among generally equally-valid options. You need context to understand why a choice is good, and if you just look at the source of some engine and parrot their techniques and idioms, you are hardly learning anything useful. Further, just because code shipped a game doesn't make that code good (Source in particular is prone to lot of now very outmoded design decisions with respect to C++ and OO, for example). There are plenty of horror stories dwelling in the engine codebases of even the most successful AAA titles. And as an impressionable neophyte, how are you going to be able to tell the good code from the bad? Be very careful using source code as a learning resource, and make sure to pair it with as much supplementary information as you can. 

In this case, the matrix is generated from the call to , which is a function (a static method of the class). It creates a 4x4 tranformation matrix which describe a rotation about the Z axis. The formula for constructing that matrix can be seen here, as . Extending that the 4x4 form used for the class, it would look like this: 

A cue is a like a trigger used to invoke a sound. A cue has multiple sounds associated with it that all play back once the cue is activated. 

The magnetometer and gyroscope are optional features, again, which you can specify the need for via your manifest as above. The Surface should have an accelerometer, gyroscope and compass (as should the successor). The Windows API has a parallel namespace for sensor access. 

FBX is a common interchange format, so ideally just need to find a library or framework on Android that supports loading them. Alternatively, convert the FBX files to some other format that your Android framework or libraries can load. If you don't current have any investment into a particular API on Android, and 

You'll probably want to use the REST API to recover a user timeline and/or a mentions timeline. To make requests you'll probably want a socket and JSON API for Lua. You find a specific example involving the use of both of those APIs to talk to a different REST API (not Twitter's) here, which you can probably adapt to use for Twitter based on their documentation. What you'll get from the Twitter endpoint is JSON data, which you can then format as appropriate to make it look nice within the context of your game. 

Making your game (or any software product) data driven is almost always a benefit. The only real con is that you may spend slightly more time building the relevant systems up front; it will pay off over the rest of your career as a programmer though (even if you don't reuse those same systems for that entire time, you'll reuse the techniques you employed to build them). The challenge, and where the disconnect in those two articles you linked comes in to play, is what you elect to put in data and who you elect to give access to that data. Fundamentally, data driven design and development just means that you put information in external storage, load that information at run time, and act on it. Your application code does what that external data tells it to, rather than you writing application code that directly does what you think the end result should be. It's not a complex idea. You don't have to build complex "component driven architectures" (as is the fad these days). Putting constants for tweaking physics (gravitational force, restitution coefficients) in a text file is data driven. Scripts (in Lua or something else) are data driven. Describing your level data in XML. Anything like that. You can drive just about any component of software with data, and you can pick and choose which ones you want to do so with. Developer time is expensive; programmer time especially so. If you can save you or other programmers time by putting behavior and data in external storage and not requiring the game to be recompiled for every little change, you should. You'll save money and get things done faster. Furthermore, you run a huge risk in attempting to make "designers design" and having programmers "make those designs a reality," forcing a programmer to exist in the iteration loop for a designer's job: you run the risk of making the programmer feel like he is just a code monkey, making trivial little tweaks for the design constantly. This can be massively demoralizing for a large majority of programmers, who want to work on interesting technical challenges and not on being a designer's proxy. For your specific questions: