This was shown non primitive-recursive (in a uniform way, thus $\mathsf{Ack}$-hard according to the above definition) by Mayr and Meyer in 1981 (there is a simpler proof published by Jančar in 2001). An $\mathsf{Ack}$ upper bound was first proved by McAloon (1984), with a simpler proof (but slightly worse bound) by Clote (1986), and improved and simplified arguments by Figueira et al. (2011). Many problems are shown $\mathsf{Ack}$-hard through reductions from the reachability problem in lossy counter machines (or slight variants). Those can be defined as Minsky machines where counter values may decrease in an uncontrolled way; see Schnoebelen 2002 & 2010 and Urquhart (1999) for a similar construction. 

Thus $L_2$ is generated by $G_2=(\{S_2,E,A\},\Sigma\uplus\{\#\},P_2,S_2)$ with $$\begin{aligned}P_2&=\{S_2\to aS_2a\mid a\in\Sigma\}\cup\{S_2\to E\}\\&\cup\{E\to aA\#Ab\mid a\neq b\in\Sigma\}\cup\{aA\#\mid a\in\Sigma\}\cup\{\#Aa\mid a\in\Sigma\}\\&\cup\{A\to aA\mid a\in\Sigma\}\cup\{A\to\varepsilon\}\end{aligned}$$ The idea is that $S_2$ generates $u E u^R$ for $u$ the longest common prefix of $w$ and $w'$, after which $E$ applies one of the three cases above. Thus $L(G_2)=L_2$, and the grammar is minimal. Relating the two grammars. Let $h$ be the homomorphism from $(\Sigma\uplus\{\$,\#\})^*$ to $(\Sigma\uplus\{\#\})^*$ defined by $h(a)=a$ for all $a\in\Sigma$, $h(\#)=\#$, and $h(\$)=\varepsilon$; $h$ simply erases $\$$ symbols. Then $\Pi$ has a solution iff $h(L_1)\not\subseteq L_2$. We define $L'_2=h^{-1}(L_2)$ and construct the corresponding grammar $G'_2=(N'_2,\Sigma\cup\{\$,\#\},P'_2,S'_2)$ in the obvious way (add a nonterminal $D$ with productions $D\to \$D$ and $D\to\varepsilon$ and introduce $D$ symbols everywhere in the right hand sides of the productions in $P_2$); it is still minimal and $\Pi$ has a solution iff $L_1\not\subseteq L'_2$. We are however interested in the full PCP on $\Pi$. Construct $$G=(N_1\uplus N'_2\uplus\{S\},\Sigma\uplus\{\$,\#\},P_1\cup P'_2\cup\{S\to S_1,S\to S'_2\},S) .$$ 

Here is a solution based on a reduction from Post Correspondence Problem. The general idea is similar to the ones used in reductions from PCP to the emptiness of intersection and ambiguity in context-free grammars. I am afraid I am using a Turing reduction for a preliminary claim---which I would consider fair game considering the number of variants of PCP `out there'. Preliminaries. A PCP instance is a finite set of pairs $\Pi=(u_i,v_i)_{i<n}$ of finite words over a finite alphabet $\Sigma$. A solution is a sequence of indices $j_0,\dots,j_m$ with $u_{j_0}\cdots u_{j_m}=v_{j_0}\cdots v_{j_m}$. The set of indices $I(\Pi)$ of a PCP instance $\Pi$ is the set of indices $i<n$ that appear in some solution; formally $$I(\Pi)=\{ i < n\mid \exists i_0,\dots,i_m <n\mathbin.u_{j_0}\cdots u_{j_m}=v_{j_0}\cdots v_{j_m}\text{ and }\exists 0\leq k\leq m\mathbin.i=j_k\}\;.$$ Then the PCP instance has a solution iff $I(\Pi)\neq\emptyset$. Claim. The following decision problem called full PCP is also undecidable: 

It is indeed well-known that LR($k$) languages for $k>0$ coincide with SLR($1$) languages, see e.g. M. Dennis Mickunas, Ronald L. Lancaster, and Victor B. Schneider, Transforming LR($k$) Grammars to LR(1), SLR(1), and (1,1) Bounded Right-Context Grammars, J. ACM 23(3):511--533, 1976, doi: 10.1145/321958.321972; it's not clear to me what EBNF syntax has to do with it: could you be more specific? 

I recently attended a talk with one such result, for the determinacy of one-counter Büchi games: Olivier Finkel, The Determinacy of Context-Free Games, STACS 2012, $URL$ 

I would suggest using the characterization of first-order languages by counter-free Büchi automata: see e.g. V. Diekert and P. Gastin, First-order definable languages. In Logic and Automata: History and Perspectives, Texts in Logic and Games 2, pages 261--306. Amsterdam University Press, 2008. $URL$ PS: over finite words, this BEATCS column is also very helpful: J.-E. Pin, Logic on Words, $URL$ 

canonicity (there is a unique minimal deterministic complete automaton for a given regular language, up to state renaming) and the existence of polynomial-time algorithms (the associated problem becomes PSPACE-complete for NFA; see Jiang & Ravikumar, 1993). 

Essentially the same argument is made by Andries P.J. van der Walt (1976, Lemma 2.3 and Example 2.9) for the variant of the pumping lemma where $N$ letters are marked and all three of $x$, $y$, $z$ must contain marked letters. See also Autebert, Boasson, and Cousineau (1978) for more properties of abstract families of languages satisfying this variant of the pumping lemma. 

Assuming that the complexity of the provability problem would satisfy you, the landscape of complexities of substructural logics with and without contraction is somewhat complex. I'll try to survey here what is known for propositional linear logic and propositional logic. The short answer is that contraction sometimes helps (e.g. LLC is decidable, while LL isn't), and sometimes doesn't (e.g. MALL is PSPACE-complete, MALLC is ACKERMANN-complete). Propositional Logics 

This is known as a Ritchie-Cobham property, or a honesty property of primitive-recursive functions. See for instance Theorem VIII.8.8, page 297 in P.G. Odifreddi, Classical Recursion Theory, vol. 2, 1999. Odifreddi refers to 

either $v=ax$ and $v'=bx'$ for some $a\neq b\in\Sigma$ and $x,x'\in\Sigma^\ast$, or $v=ax$ and $v'=\varepsilon$ for some $a\in\Sigma$ and $x\in\Sigma^\ast$, or $v=\varepsilon$ and $v'=ax'$ for some $a\in\Sigma$ and $x'\in\Sigma^\ast$. 

For question (2): the subgraph and induced subgraph relations give rise to well quasi orders on some restricted classes of graphs. One of the main references there is an article by G. Ding, Subgraphs and well-quasi-ordering, J. Graph Theory, 16: 489–502, 1992, doi:10.1002/jgt.3190160509. The paper 

The set $\mathit{ppc}(L)$ is certainly context-free, but I think it can be inherently ambiguous: consider $$L=\{a^mb^mc^nd\mid m,n\geq 0\}\cup\{da^mb^nc^n\mid m,n\geq 0\}\;,$$ then $\mathit{ppc}(L)$ includes the classical inherently ambiguous language $$L'=\{a^mb^mc^n\mid m,n\geq 0\}\cup\{a^mb^nc^n\mid m,n\geq 0\}\;,$$ and one can prove $\mathit{ppc}(L)$ is also inherently ambiguous by the usual argument (apply Ogden's Lemma to both $a^{n+n!}b^nc^n$ and $a^nb^nc^{n+n!}$ to deduce the existence of two distinct trees for $a^{n+n!}b^{n+n!}c^{n+n!}$). 

A reasonable formal definition of (context-free) parsing is thus: given $\langle \mathcal{G},w\rangle$ a context-free grammar over some alphabet $\Sigma$ and an input word in $\Sigma^\ast$, return the set of parse trees of $w$ in $\mathcal{G}$ (note that the grammar might be ambiguous, which means that this is indeed a set, which might even be infinite if the grammar is cyclic). Recognition then consists in finding out whether this set is empty or not. A very elegant way of solving the parsing problem is known as parsing as intersection: context-free languages are effectively closed under intersection with regular languages, i.e. given $\langle \mathcal{G},\mathcal{A}\rangle$ where $\mathcal{G}$ is context-free and $\mathcal{A}$ is a finite-state automaton (a NFA), we can construct $\mathcal{G}'$ a context-free grammar such that $L(\mathcal{G}')=L(\mathcal{G})\cap L(\mathcal{A})$ and furthermore the set of derivation trees of $\mathcal{G}'$ is (a relabelling of) the set of parse trees of all the words in $L(\mathcal{A})$. Of course a single word $w$ can be recognized by a NFA. This construction is almost as old as context-free grammars; see 

About Q1: Both the ambiguity problem (given a CFG, whether it is ambiguous) and the inherent ambiguity problem (given a CFG, whether its language is inherently ambiguous, i.e. whether any equivalent CFG is ambiguous) are undecidable. Here are the original references: 

Some of the work of Olivier Finkel seems related to the question---though not necessarily explicitly about the Axiom of Choice itself---and in line with Timothy Chow's answer. For instance, quoting the abstract of Incompleteness Theorems, Large Cardinals, and Automata over Finite Words, TAMC 2017, 

Edit: in answer to the more specific question regarding nullable nonterminals and LR($k$) vs. SLR($k$), the grammar with rules $$S\to aAa\mid bAb\mid aBb\mid bBa, A\to a, B\to a$$ is LR(1) but neither SLR(1) nor LALR(1) and does not have any nullable nonterminal. Another issue is that there is no "perfect" definition of LR($k$) for EBNF syntax---unless you convert to BNF in some specific way and ask the resulting grammar to be LR($k$); see Heilbrunner, Definition of ELR($k$) and ELL($k$) Grammars, Acta Inf. 11(2):169--176, 1979, doi: 10.1007/BF00264023. The issue is with the reduction operation: how much of the stack should be reduced when reducing, say, $A\to a^\ast$? Answering this question might require inspecting the stack contents, or adding special stack markers, or $\dots$, and is likely to restrict the class of accepted grammars below ELR($k$). Finally, I do not know about SLR($k$) techniques for EBNF grammars; a survey on the subject of parsing for EBNF was recently written by Hemerik, Towards a Taxonomy for ECFG and RRPG Parsing, LATA'09, LNCS 5457:410--421, 2009, doi: 10.1007/978-3-642-00982-2_35. 

When considering finite state transducers, you need similarily to consider `deterministic' transducers: those are called (sub-)sequential, and can be minimized (e.g. Choffrut, 2003 for a survey). The issue however compared to the case of automata, is that not every finite state transducer can be made sequential! See e.g. Béal & Carton (2002) for a proof of decidability of sequentiality and a construction of the equivalent sequential automaton. Note that in the more general setting of weighted automata, this question is still open for some semirings (Lombardy & Sakarovitch, 2006). 

Let's notch up the complexity a bit. Many decision problems about vector addition systems (VAS) are EXPSPACE-complete, but may require much larger witnesses. For instance, deciding whether the language of a VAS is regular is EXPSPACE-complete (e.g. Blockelet & Schmitz, 2011), but the smallest equivalent finite-state automaton might be of Ackermannian size (Valk & Vidal-Naquet, 1981). The explanation behind this huge gap is that there exist much smaller witnesses of non-regularity. 

I am looking for a reference on `reducing' Turing reductions to many-one reductions. I have in mind a statement of the following form (similar enough statements would also satisfy me): Theorem. If $\mathsf{A}\leq_T^f \mathsf{B}$, then $\mathsf A\leq_m^{2^f}\mathsf B^{tt}$. where "$\leq_T^f$" and "$\leq_m^f$" denote respectively Turing and many-one reductions in deterministic time $f(n)$, and "$\mathsf{B}^{tt}$" denotes a `truth table' variant of the language $\mathsf{B}$, which evaluates a Boolean combination of checks "$x\in\mathsf{B}$". Proof idea for the statement: Simulate the $f(n)$-time bounded oracle Turing machine used in the Turing reduction: it's easy enough to obtain a nondeterministic Turing transducer also in time $f(n)$ that guesses the answers of the $\mathsf B$ oracle and writes a conjunction of checks "$x\in\mathsf B$" or "$x\not\in\mathsf{B}$" on the output, to be evaluated by an $\mathsf B^{tt}$ machine. This transducer can be determinized by exploring both outcomes of the oracle calls, and handling them through disjunctions in the output; it now works in time $2^{f(n)}$. Oddly enough, I cannot seem to find any related result in complexity textbooks. Edit: renamed "$A\mathsf B$" into "$\mathsf B^{tt}$" to emphasize the relation with truth tables, as pointed out by @MarkusBläser. 

shows that both orderings yield wqos on the class of graphs with bounded path lengths, and even more interestingly, characterises exactly the hereditary classes of graphs for which the subgraph ordering becomes a wqo (the class should contain only finitely many cycles and "H-graphs"). 

There are "natural" problems hard for Ackermannian time; in fact there is a growing body of literature on the subject. A place to start is the survey in Section 6 of Complexity Hierarchies Beyond Elementary. What is even more interesting is that there are complete problems for Ackermannian time, under say primitive-recursive many-one reductions: define for this $$\mathsf{Ack}=\bigcup_{f\text{ Primitive-Recursive}}\mathsf{DTime}\big(ack(f(n))\big)\;.$$ Many examples arise with counter systems and logics. For instance, the oldest known such problem is the inclusion problem between the sets of reachable configurations of two vector addition systems (VAS) assuming these sets to be finite: 

More results in the case of the induced subgraph ordering can be found in this recent arXiv paper by A. Atminas, V. Lozin, and I. Razgon. 

(I guess the important word in the original question is ``published''.) There is such an encoding of context-free parsing (more exactly of CYK-style parsing) in Roland Axelsson, Keijo Heljanko, and Martin Lange, Analyzing Context-Free Grammars Using an Incremental SAT Solver, ICALP 2008, Lecture Notes in Computer Science vol. 5126, pp. 410--422, doi:10.1007/978-3-540-70583-3_34. They use it in particular to detect ambiguity of words $w$ in context-free grammars for growing word lengths. 

A context-free grammar is cyclic if there exists a non-terminal $A$ and a derivation in one or more steps $A\Rightarrow^+ A$. It is left-recursive if there exists a non-terminal $A$, a mixed sequence of terminals and non-terminals $\gamma$, and a derivation in one or more steps $A\Rightarrow^+ A\gamma$. Hence cyclic implies left-recursive, but the converse does not hold. Note that a cyclic grammar can have infinitely many parses for a single terminal string---that might be problematic---, while there is little interest in having cycles in the applications I know (natural language processing and programming languages syntax), thus they are usually removed. 

Pierre Wolper defined in 1983 extended temporal logic (ETL, in Information and Computation 56, 72–99, doi:10.1016/S0019-9958(83)80051-5), where a temporal operator $\mathcal A(\varphi_1,\dots,\varphi_n)$ can be introduced for a finite-state automaton $\mathcal A$. The formula is satisfied in an infinite word $u$ at position $i$, i.e. $u,i\models\mathcal A(\varphi_1,\dots,\varphi_n)$, if there exists a finite word $a_{i_1}\cdots a_{i_n}$ in the language of the automaton $\mathcal A$, such that for every $1\leq j\leq n$, $u, i+(j-1)\models\varphi_{i_j}$. Extended temporal logic has the same expressive power as the linear-time $\mu$-calculus or MSO on infinite words, so it does not answer your question. One can however go further and allow other languages instead of regular ones in the operator $\mathcal A(\dots)$. Paul Gastin and Stéphane Demri consider the case of context-free languages at the end of their chapter Specification and Verification using Temporal Logics of Modern applications of automata theory (IISc Research Monographs 2, chapter 15, pages 457–494, World Scientific, 2012, $URL$ You can certainly express non-lasso properties in such a logic. It is shown by Gastin and Demri to have (highly) undecidable satisfiability and model-checking problems. 

About the relationship between derivations (i.e. sequences of rules applications $\beta A\gamma\Rightarrow \beta\alpha\gamma$ where $A\to\alpha$ is a rule of the grammar) and derivation trees (i.e. where a node labeled $A$ is the parent of a sequence of nodes $X_1,\dots,X_m$, where $A\to X_1\cdots X_m$ is a rule): in a general CFG, there can be different derivations, which visit the same derivation tree in different ways. These different derivations occur because one has a choice between applying a grammar rule in two different places in a sentential form: in a sentential form $\gamma A\eta B\theta$ with at least two nonterminals $A$ and $B$, one can apply $A\to\alpha$ first and obtain $\gamma\alpha\eta B\theta$, or $B\to\beta$ first and obtain $\gamma A\eta\beta\theta$, but applying the other rule will lead to the same $\gamma\alpha\eta\beta\theta$. Imposing leftmost (always deriving the leftmost nonterminal in any sentential form) or rightmost derivations imposes a fixed order for visiting derivation trees, and there is then a single derivation for a given derivation tree. In a linear context-free grammar, there is no such choice, since there is at most one nonterminal in any sentential form, and there is a single derivation for a given derivation tree, which is both leftmost and rightmost. Having two different parse trees with the same yield $w$ (sequence of leaves) is the definition of $w$ being ambiguous, it does not change when considering regular grammars. Alternatively, one can also ask for two different leftmost derivations. Note that a derivation in a one-sided grammar corresponds to an accepting run in its associated finite-state automaton, which is called ambiguous exactly in the same way: when there exist two different accepting runs for a given input $w$. and 4.$~$ If you take the finite-state automata view, it suffices to determinize your ambiguous automaton in order to obtain an unambiguous automaton for the same language: there will be a single run for any given word. This deterministic automaton is equivalent to an unambiguous regular grammar. To answer your comment: there exist ambiguous regular grammars, for instance $S\to A\mid B,\,A\to a,\,B\to a$ has two leftmost derivations for $a$: $S\Rightarrow A\Rightarrow a$ and $S\Rightarrow B\Rightarrow a$. An equivalent unambiguous grammar is $S\to a$. 

Coverability in vector addition systems is EXPSPACE-hard: in R. J. Lipton, The reachability problem requires exponential space, Research report 63, Yale University, 1976. A vector addition system (VAS, equivalent to a Petri net) of dimension $d$ is defined as a pair $\langle v_0,A\rangle$ where $v_0$ is a vector of non-negative integers in $\mathbb{N}^d$ and $A$ is a finite set of vectors of integers included in $\mathbb{Z}^d$. A VAS defines a transition system over configurations in $\mathbb{N}^d$ where $v\to v'$ if there exists $u$ in $A$ such that $v'=v+u$ (note that no component of $v'$ can be negative). The coverability problem, given a VAS and a target vector $v$ in $\mathbb{N}^d$, asks whether there exists an execution $v_0\to v_1\to\cdots\to v_n$ of the VAS such that $v_n\geq v$ for the product ordering over $\mathbb{N}^d$, i.e. $v_n(i)\geq v(i)$ for all $1\leq i\leq d$. Combined with an EXPSPACE upper bound proven by C. Rackoff in 1978, Lipton's result shows the completeness for EXPSPACE. This result, as recounted on Lipton's blog, still provides the best known lower bound on the (seemingly? much harder) reachability problem, where one requires instead $v_n=v$. Interestingly, it was proven before reachability was shown decidable. The lower bound and the technique employed to prove it have been reused countless times in relation with various classes of counter systems, and indirectly for other classes of systems or logics.