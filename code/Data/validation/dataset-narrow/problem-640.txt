There are a number of common tricks to solving this problem. The most logical one in Java 8 would be to use a LocalDate instance.... 

When you merge two arrays, where the one array contains a key value, you can save a lot of time by indexing the keys. Consider an index on the column. It is really easy to index the data using an Object with named properties: 

Bug #1: 0.0n where n > 0 is equal to , and not as you have in your code (although 00 is 1, not 0, and 0.0n where n < 0 is NaN). Bug #2: You very carefully have the test method: 

That would be a much better asynchronous (note, not multithreaded) usage model. For a true multi-threaded implementation I would recommend a Java 8 streaming approach, with a parallel stream. That would be an exercise for the reader ... ;-) Other things to note about the above API, it has the following attributes: 

Update: About the as a global... is a slice, not an array. As a slice, it consists of a lenght, capacity, and a pointer to an array. Let's assume each of those are 8 bytes, so that's 24 bytes of data that a slice represents. It is not a problem to copy that data as a parameter in to the method. Read up about slices here: effective go Eseentially your performance concerns, or memory concerns, are not an issue when copying the slice, because you are not actually copying the array, just a pointer to the array. 

Note that I compute each digit separately (in to , , and ) and then return the combination as a string. Further, when running the code, I discovered that you are off on your assertion .... the max value you propose for is wrong, what you have is . - I discovered I had a text transpose of instead of in my constant. See the code running on ideone: $URL$ For the inputs supplied in the tests I get the values: 

There's a potential security flaw if you do not include an encoding. All content on the page is decoded using the specified encoding. If the decoding uses the wrong charset it may lead to scripts with errors, and allow unexpected consequences with things like cross-site-references when URL's are decoded differently depending on system defaults and expectations. For example, Chris Shiflett shows how a mismatch between the actual encoding of the page, and the way the system interprets the page, can lead to XSS attack vectors. Specifying the encoding as part of the page header would remove that vector. For accessibility reasons you should include the language 

Your code is begging for the use of the Chain Of Responsibility patern (or rather, a variation of it). But first, some observations: 

The choices of classes and other design patterns that you have made indicate to me that the books/tutorials you have been reading are pretty old. There are a number of things in your code which are almost ten years out of date in the Java 'world'. Also, you are only showing us half of your implementation, you have not included the code. While I can't review the whole system without the code, there is a lot to comment on without that still. General It is obvious that you are using an IDE to help you write your code because you have some code-template things like: 

but, it does not use a try/finally block to manage that semaphore (and, since you are locked on the semaphore, why do you need the at all?) Oh, that's static. But, it is a major bug to not use a finally block for the because you will leak semaphores as your code fails on intermittent problems.... which will happen. Hmmm, your levels of locking are so complicated, that I would recommend a rewrite. It is apparent that you have been reading up on the volatile-double-check-locking solutions, but why not just use the now-recommended enum Singleton pattern? Use a single strategy for locking in the sendMessage: the atomics, synchronized, and semaphore combination are too much. Use just one strategy. As it stands, it is essentially too complicated for me to even verify if the concurrency is safe, let alone efficient. 

... have you done an explain-plan to figure out which option it has taken? I suggested this in the first answer... have you done it? If the explain plan shows that the code is producing a temp-table for the name-concat of the TMP_CONTROL data, and that it does a nested-loop scan of the CLIENT -> temp-table to calculate the Edit Distance - then there is nothing you can do that will be faster. If you really, really can't create the tables manually, then it is likely that the best result you will be able to achieve will be to externalize the data and process it outside the database. 

EDIT: I have seen the following done (translating from memory of a C program)... this has been known to be able to compile down to SIMD-using instructions on supporting compilers, etc. 

Regardless of what system you use, you should still heed @Heslacher's suggestions about naming, and conditionals. 

Note, in that function I converted it from a do-while loop, to an infinite while-loop, with an early-return if the input is valid. I have nothing against do-while loops, but I find this early-return system simpler in terms of variable management. Note that the has a smaller scope than your code. You can call the code with: 

Again, that makes the logic clear, no need for a comment. I believe that has now eliminated all of your comments..... and replaced them with code that does not need a comment, because the code is self-explanatory. In other news, if you had more functions, with good names, then your code would be simpler to read as well. Bottom line, though, is that the comments in your code should fill in the blanks that your code does not. In addition, your comments should give details on the motivation, and not the application of your code. You should, in general, comment only on why your code does things, not what your code is doing. That leads on to the other comments you are missing... JavaDoc. JavaDoc is documentation that should explain what your code does at an abstract level. You have no JavaDoc, and you likely should. JavaDoc is where you describe what your code does, because, typically, the people reading the javadoc are not reading the code, so they need something else to tell them what the code does. 

I recommend you make the changes and see how it works out for you. You will find that the logic and flow of the structure is neater, and more manageable. 

... then, when you get the text value of the it will not have the symbol. EDIT: Of course, it would be faster/better to do: 

Conclusion I agree that the complexity is about O(n2), but I know it must be psosible to do it faster. The data types are a problem, but the result looks accurate. Alternative... So, I cheated, and looked at wiki, and it has a relatively easy function for calculating the row values for a function. I adapted it here. This is the way I would have done it, if I was able to google the algorithm. I would have used a similar approach to you, but as arrays-of-int instead, if I could not search the algorithm. 

Thus the whole thing is moot, and redundant. The other issue I see is in the . This has two problems. The first problem is the concrete method , which has lousy JavaDoc, so I am not sure of its purpose, but the implementation reads like a static method... I would consider removing that class entirely, and reducing it to a , and then you can pass it in for each search. There's abstraction overkill in there. 

there is no argument to the method (so it should be ?) it is really simple to just return for an empty list, and have the right result. 

Everything in reverse order. It is clear that your back-track to reverse the path taken is appending each point to the slice, instead of inserting each point at the beginning - and getting things in the right order. Having said that, the append is probably the right solution, but a slice reversal afterwards would be better. Your current back-track function is: 

The current thread 20 threads created in the method The CachedThreadPool has no upperbound on the number of threads, and will create a new thread each time you call but, that is gated by the Semaphore 

The above declares the genericType of . It is conventional in Java to use a single upper-case letter to declare generic types. I would have: 

you have multiple entries with the same you have entries without an the content in entries with the same ID in different documents is wildly different. 

print statements in a loop line-by-line parsing of input mid-list removals of values () not enough functions 

In general, labelled code is uncommon, but 'forbidden' is a bit harsh. Break, and Continue have better characteristics than GoTo, and should not be 'painted with the same brush'. The logic in your code is convoluted though.... you are 'searching' the input set, and ensuring that all members of the input set match a condition. As you search, if the member matches, you remove the member. If one of the members does not match, you immediately return an empty result. Note, that if a 'middle' member fails to match, you have already removed the first members, and yet you return an empty set. Your logic could be significantly simplified if you extracted part of your method as a 'helper' function: 

Note above how I use the 'diamond operator'. Using the full generic type on the right-hand- side of an assignment is no longer needed. The classes ensure that the memory model for get/set operations are correctly ordered, and thread safe. As a result, the way you get and set the List in that is currently just fine. As ratchet freak indicates, you should probably be using a , and not a . A set offers constant lookup times as your set size increases. If it were me, I would have something like: