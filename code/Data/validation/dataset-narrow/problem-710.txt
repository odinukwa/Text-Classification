The body is basically the same, we're just passing a type that is more clearly indicative of what we're actually doing. Now, we can generalize this to add arbitrary args: 

That way, the determination of "adjacent to u" can be done as follows: take all the tiles adjacent to our position. Drop the walls. Drop the doors for which we don't have a key. If we step onto a new square that is a key, turn on the appropriate flag in . That simplifies the code dramatically. No exceptional cases - no unnecessary copies or recursion. Now we're back to a normal breadth-first search. This actually has additional benefits in that you don't need your or either. Add Heuristics Consider also adding a heuristic to your queue. Rather than simply effectively sorting by path length, we can also add Manhattan distance as a lower bound. This will make our search more focused on the best candidates remaining. This approach is the search algorithm. Code comments 

Unnecessary Complexity We are conditionally selecting a distribution type based on whether or not is integral or floating point. Once we assert that it's one or the other, we can simply use : 

Why? Do you need to have every line in memory? No. You're just trying to count the words. What if the file was 100TB worth of "all work and no play makes Jack a dull boy"? Poor Memory Use 

I would say then then . The reason for this is that the lambda solution is the only one where the actual functor is in-line with the algorithm. Anybody reading that code knows exactly what should be immediately. There is no question. It is clear (to the extent that lambda syntax is) and concise. would be the C++03 way of doing this thing. It's... ok. We wrote that code for many years. The problem is the body of the functor is often hundreds of lines removed from the call, maybe in a different file... so readers of your code will have to find it. And it's never going to be perfectly clear either (who knows, maybe you named your functor weird and it's returning ? Naming things is really hard) is the worst. Having as a template argument adds nothing to your performance (it's not like you're optimizing out a comparison), has equal readability loss compared to the lambda with the functor, and on top of that, can't even be called with a variable. With the other two, I can easily write: 

There are three severe errors in your code: Rule of Three/Five/Zero This is an invaluable resource. Anytime you write a user-defined destructor, you will need to write the copy constructor and assignment. You lack the copy constructor or assignment, so the compiler will happily provide one for you, and that one will not do the right thing: 

First, the exception is misleading. A better exception type would be , and a message indicating this - since the issue isn't that we ran out of memory. That's an error that we would throw if allocation fails (in , you do the same thing - there you should throw ). But the main problem is this kills performance because on every lookup, we have a branch. Every time. And branches are slow. That's why on , is defined simply as: 

How would I do that in your system? The s confuse the logic, since in your example you're creating a bunch of gates that are floating around - and then just to see that and go into is split across several lines, rather than ideally: 

Side note on this guy. It doesn't actually do what you want. This isn't an arbitrary rvalue reference - it's a forwarding reference. In fact, we can even combine the two constructors here in one go: 

Rather than making 4 passes to find the max and min elements and their respective indices, we can find the max element and its index in a single pass (taking advantage of and the fact that takes a key function), and then simply searching the left side of that for the min element. We don't need a -type method since once we know where the max element is and its index, that defines the domain for where the min element could be. We don't have to pop elements to find it. A single pass We can do better though. For each element, we can keep track of the smallest element we've seen so far and the largest element we've seen so far, and simply update as appropriate: the min element can get smaller, the max diff can only get bigger we see the new biggest: 

Your code is fine. I don't know what you're so worried about. But there's just some unnecessary stuff. For example: 

This is on the order of 25 lines and far easier to understand. One Loop Of course if we really want to reduce the line count, we can do it in one loop. I wouldn't recommend this, since it's harder to discern, although it's not too bad. The key is just to see at one point we flip from going up by 2s to down by 2s: 

What can I do with this? Well, anything really. Now that I made it easy to generate the primes, anything we may want to do with them is easy too. Printing them? 

So drop it, and you get the correct answer, and it runs faster (or the same, within noise). Semicolons Semicolons are a C/C++/Java/etc. thing. While they're technically correct Python syntax, you don't need them, and they look weird, so you can simply drop them. Sieve Typically, we'd start our sieve with something like . It's a little weird to see it backwards, but I guess that's ok. More efficient sieving Let's take a look at the sieve part of your code, swapping bools like I suggested: 

That's the full signature you need. In the OP example, scores the first go will be so this should return , indicating that that is the loser. You don't need a variable - what if we were doing this for all of Australia and each candidate had over 5,000 votes! Your code would break. In fact, that's likely the source of your bug. The algorithm here is simple: for each score, if either we have no losers or this score matches the losers' scores, append it. Otherwise, if the score is worse than the losers' scores, replace the losers with this one. This also has the added benefit of not needing to main a separate losers structure that you need to remember to clear. Also you may find it helpful to remove all instances of votes for a loser whenever you drop one. For instance, our rankings initially started as: 

Treatment of Keys You're doing a whole lot of extra work - both in terms of actual operations and code - the way you're treating keys. You're copying the entire maze everytime you get a key, and doing a whole separate search. That is unnecessary effort. Consider the canonical breadth-first-search double loop: 

Next, this is going to be inefficient. We have to walk the entire string once (to make it lower-case), then again to split it. And then we have to keep all of the words in memory. We don't have to do any of that if we really start with the correct function: : 

State should always be valid One of the main issues I see in your class design is that the state of your object is undefined most of the time. If I have a triangle, I want it to be... you know, a triangle. But when you start with: 

Recursive case Doing something like is an anti-pattern. already gives you a , so that could just be used directly. The same can be said for your recursive case: you need to check that the first elements match and that the rest match: 

At the end of this loop, the banker either busted or stuck. Naming There are lots of different naming conventions in C++, the most common of which are and . I don't have a strong preference between the two, but both are strongly preferred to . Something like is much harder to read than either or , so prefer to use one or the other. Next, when you find yourself naming things and - consider that there are two cases: 1 thing and N things. You either need to hold onto one card, or lots of cards. Since you need more than one, it's better to simply have: 

PS. There is a fourth way to pass a functor: the lambda that was a lambda before C++11 lambdas: Boost.Lambda: 

So what one iteration will do is try to add to each of the groups in (which is a terrible name), and recurse on the next iterator. Just directly that's: 

That'll save some unnecessary operations. The second comment is about your member function . It's a little confusing in that it doesn't swap the arguments passed in - it swaps those indices. So prefer to name it or something along those lines just for clarity. Special cases In your , you start with the special case that . But there's nothing special about that case for the purpose of your algorithm. will just do nothing. So you don't need it. That reduces your down to: 

Now we just need the number of stars. It starts at for the first lines, then we get one line of stars (for odd stars), and then we go back down the pyramid. As a first go, we can just split it in 3: 

This looks pretty good. I don't have any deal-breaker comments, just a bunch of minor ones. Prefer Just straight up instead of . Raw arrays are broken. There's not really any real difference for the purposes of your use-case, but it's just a more pleasant type to deal with in general. Throwing and non-throwing For functions that throw, there's an extra mechanism that needs to exist to support that use-case. Plus even an always-predicted branch is going to be more code that no branch. To that end the standard containers offer throwing and non-throwing functions. If you rewrite your two s to be non-throwing: 

I'm going to throw out a fairly complicated solution here by breaking the problem into lots of smaller parts. The end result is that the compilation of the following: 

But instead you set a global variable. That makes it hard to understand. Also, your most important helper function has this signature: 

That will give you two benefits. First, users of your class would expect to not throw since that's pretty typical. But second, you no longer need to any of the free functions. only needed to be a friend because you wanted to avoid the throwing, now that's just a non-issue. Use some standard algorithms Your equality operator can be reimplemented with : 

Specify Requirements Up Front The whole point of binary search is that it's . If you're going to check that the array is sorted first, you may as well do a linear search. Not to mention that you're doing even worse here since you're checking that the array is sorted on every recursive call, so now we have an search. Binary search should assume a sorted list. If the user doesn't provide one, it's garbage in garbage out. Use appropriate defaults Usage-wise, it makes more sense to just write: 

However, making this recursive isn't great. We could just run out of stack space. There's no advantage here. Let's just loop until done: 

That is easy to understand. And let's actually factor out that loop that I wrote up there. So full rewrite of that function: 

So we're almost done with our nice algorithm, when suddenly... we start over and do a whole new search from scratch throwing everything away? Why? Let's examine such a scenario: 

Avoid putting lots of things on on one line Your reallocation line does three things: checks if you need to reallocate, doubles the buffer size, and reallocates. It'd be much better to just split that up. Don't write the bodies of your statements on the same line either, unless the body is trivial (e.g. ). Using s is a good habit to get into: 

What's in a name? This code is pretty easy to follow, and I could mostly understand it on the first read through. However, we could do better. Let's take a look at . This function doesn't return paths - it returns neighbors. It returns all the adjacent squares. Moreover, what is and what is ? Let's name these things too. 

What are , , , and ? I can't even tell from the body of the function. Avoid single-letter variable names unless used in a context where they are truly trivial (e.g. iterating over a range with or is fine). Function names should be , not , and should describe what the function actually does. Certainly and are not helpful at all. Which one checks which kind of diagonal? What arguments do they take? What do they return? docstrings belong inside the function: 

I know it's obvious, but it bears stating. A is not a . You compare a meter and a second, you cannot add them, etc. They are different types completely. So what you want is to make a different type: 

Code Duplication This is the big one. Let's start small and work our way up. and do basically the same thing, so it makes sense to factor that out. They're both filters, so let's write them as such: 

What's the root? . The first element of pre-traversal is the root. Now we just need to find the left and right subtrees. To find that, we need to break up our in orderings into the root, left, and right sections: 

Why do you need to walk the whole list to check if your list is empty? That reminds me, you should add . But secondly, you have access to your private data. When is ? When . That's a much faster check. When your is , be very wary of using it. I would try to use it... never. 

Simplify the interface My suggestion: simply the interface. Instead of having to and , and then separately having to keep track of whether or not they were called (which, btw, now your timing with has to include checking - that's not nothing) - just drop all of that and have: 

Why Code Generation? This is my main question. Why? What advantage does code generation give you over just writing the class templates in C++ directly? I actually don't think it gives you any - you just end up with this added layer of complexity for where the code comes from. Furthermore, the generated code isn't particularly easy to follow. We have , , , and . But where those differ is a static constant that is separately defined. That works functionally, but is confusing. Consider an example from : 

Those are two different kinds of values. If you're just returning "smallest tuple for weight ", then should yield . And your recursive step should just be: 

Exposing Part of the advantage of wrapping values into type safe units like this is to avoid having raw values floating around. Do you really need to expose ? I'd think twice about it. Just make all s friends of each other. 

It's worth mentioning that making the destructor private is a very good design choice, since your is just a tag. But I'd rather be able to construct my directly! Also, it's much easier to write comments in hand-written code than in computer-written code. Code Duplication Let's say we went ahead and setup and and and . We now have 4 different function templates for each operator. Now this is all correct, for the sense that your code will not allow me to do stupid things like adding and . But then... we have four. Consider a different sort of tagging system: 

I'd recommend the following approach. Split up into a public-facing member function and a private-facing member function. The private one's signature is: 

Note that gives you a dangling pointer so you should try to avoid that construct. Prefer s. Don't Typedef Meaningless Types When you introduces types like: 

There isn't too much to say here, since this code isn't the interest part of the project. Way to set me up with the call and then not have a code review for that part. I feel empty inside. Anyway, mostly minor comments. Is there a reason for to be pure virtual instead of simply defaulted? I'm wary of the class. It's just there to be able to stick a global variable somewhere to call the function, but the initialization rules are based on odr-use of the variable. You never odr-use , so I'm not sure that you have the guarantee that it will have actually been registered. Startup issues like that are weird. 

Just going to address the code, not the algorithm, as an optimal solution to this problem ends up being pretty boring but the brute force solution gives me something to talk about. C++ is not C You're using and . While those work, you should prefer to use and .