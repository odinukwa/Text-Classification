I made some changes to improve your code overall. This wont improve performance, but these changes are worth noting nonetheless: 

The only difference between the two is that the second is at least explicit about wanting a variant. The first is implicit. First bit of advice avoid implicit commands as much as possible. The reason for this is quite simple, there is a tendency to think that the computer is magically doing something it shouldnt be, but really you told it to do exactly what it is doing and as a result, you have a bug that can be nearly invisible. Consider for example : 

Admittedly, this is uglier than Mat's Mug's approach, but this is the approach I use because it suits my style and needs a bit more. The benefit here is that you can choose your approach to handling the error. So, for example, handling an error in the routine can be different than handling an error in the routine. I also avoid statements as much as a possibly can. There isn't anything wrong with them when used well, but I try to anticipate errors if I can. On that note, and as others have noted, some of your subroutines need some cleanup. Someone in the RD group recently reminded me of the 'Single Responsibility Principle'. Everything should be responsible for one thing, and in turn, that thing should align with it's own intent. Along these lines, I would argue, that one unique thing should only ever be returned by one owner of sorts. For example: 

Again, this is a very simplified version. Usually I am extracting more data than just a few simple scores. The worst I've had was Day-Over-Day tracking of roughly 40 students on an assignment level basis. This is what led to the need for a dictionary over an array. 

The include guard is too easily clashed with someone else's file when this is used. Use ; or if a guard is really needed, use a UUID. 

The is for efficiency — this parameter is a “sink” value. Declare it to pass by value, not const ref, and then move it into place, with no extra copies being made anywhere along the way. The struct will have a constructor. 

So, I sense a theme: Don’t Repeat Yourself (DRY). Keep this in mind at all levels of abstraction. Think about a task in terms of essential steps on a high level, and repeat. That is opposed to immediately jumping to the fine minute details of the implementation. That will help you structure the code in a Top-Down Decomposition, and help you see abstractions at every level in which they exist. How do you find the controlled squares? Answer 1 jumps right into minutia — look at the next square up-left, check it, etc. Answer 2 takes it down one level of detail: Check in each direction of movement, stopping when it hits something. Then, “check in some direction” is to write 4 calls to “check one” in a loop. See? Understand the algorithm at steps of detail, and make the code follow that structure as well. 

and have the same parameter issue. The functions are identical except for one data item!! Don’t Do That! Factor out the thing that changed and make it a parameter. Since “player 1” and “player 2” are not very descriptive anyway, I’ll use the X and O for the prompt, too. 

Conceptual thoughts Your are setting things up to handle a member function call on a receiver object. Generally, a callback may be a free function, and may involve one or more objects with lifetimes to be managed. It may well be a function of yet another class, or a free function written just for the use of this callback. Given (as discussed above) that you must use actual shared_ptr’s to the objects in question, there is no reason to intrusively adapt the objects that may be called back (e.g. your required base class). I see such a callback can be handled idiomatically※ like this: 

And now you can merge this function with into one if you want. I guess you have read this, but I just want to remind you that all described optimizations are still applicable to your code. 

I would like also highlight an extremely small memory footprint, which was achieved thanks to usage. 

I completely agree with you that such tasks is a good opportunity to learn new concepts and the language itself. And, as you asked, I have a few comments on your code 

For sure this task can be solved in \$\mathcal{O}(n)\$ time and \$\mathcal{O}(1)\$ additional memory, but extensive testing should be priority number one. 

Another proposed solution is checking number of on-bits in \$2^{n}\$ numbers. By this, you are limiting your solution on \$n<=32\$ and doing \$2^{n}-\binom{n}{k}\$ checks for nothing. 

You tried to implement a linear (\$\mathcal{O}(n)\$ time) solution, and this is the correct final aim, but, I think, you agree that the current solution is hard to understand especially without any comments. So let's start from something easy-to-understand and not very efficient. But this will allow us to check a correctness of your solution in a first place. Brute-force solution (\$\mathcal{O}(n^2)\$ time) It is clear that this task is related to the maximum subarray problem except the condition of replacing by . So let's make a loop through all positions of the original array; on every iteration let's replace the current element of the array by and find the largest sum by Kadane's algorithm. 

The main improvement which can be done here - not to use Recursion at all. Solution without recursion 

Split complex task on simpler ones - one logic per function Your function ParseInput is doing not just parsing, but also reading from standard input. So split this task - ParseInput will just do parsing. 

It is also best to declare variables as close to first use as possible (outside of loops though). You'll notice that I implemented this in my refactoring of your code. Option Explicit I highly encourage the use of within your code. This will give you a compile-time error any time you try to compile your code when a variable is used but undeclared. This helps with things like: 

This class uses a code pattern I learned from Mat's Mug. Declare the for the class as a , then declare a private that refers to that type. As a result, you have an organized to hold your variables, and you get intellisense. Once you do that, you just need to open up the property accessors. In this case, I made everything public. This isnt good practice, but I am avoiding teaching you too much at once (I would prefer not to use a class as is, but it is the best approach at this point). This Code Goes in Your Module 

Aside from the couple of instances of a single ratio being matched to two different aspects, they are fairly consistent. So then I checked each of the original aspects and their results: 

That was the first step I took in making your code make a little bit more sense. By extracting the two loops, and the dimension check, the main routine becomes much cleaner, and gets to rely on a few s to do the work it needs to do. The beauty of this is that your code now explicitly says what it is doing (anyone could read the code, regardless of whether they have been coding for days or years). The next step I took was explicitly checking for the supported types. For example: 

I am certainly not an expert on naming conventions, so find what works for you. Definitely be mindful of what your names tell your 'reader' though. The other point worth noting here is how you have names that are inconsistent: 

Do not call variables by reserved names I mean, I was sweating to understand what is going on here the first time 

Following the 18.06 Linear algebra course, I was curious to reinvent the matrix class and basic functionality, like \$PA=LU \$ decomposition, Gauss elimination, finding inverse matrix etc. Any comments about the code design, linear algebra and performance are welcome. 

In the book “Introduction to Linear Algebra”, that comes along with this course, the author highlights several times the advantages of finding L (low-triangle matrix) instead of E (elimination matrix). It becomes pretty clear by inspecting the code. 

First of all, your solution for this task looks pretty elegant, from my point of view. I would just provide minor comments to optimize this code. 

I would suggest to create enumerated list of those errors, return one enum element as output of your function. 

Your input data is a boolean matrix, so instead of keeping every value as a byte you can use just one bit. For that purpose you can use bitarray module. 

Let user know that calculation was successful or not Let's check which error can happen in your code: 

Yes, we are doing additional LowerGaussEliminationBackward, but it does not influence a lot on performance. Even EPA=U decomposition is better to be done through L matrix. This is the current state of the implementation. 

Another point, that you are loading whole matrix to the memory. It can be too expensive in certain circumstances. I can suggest one stream-based solution which will calculate a number of islands in dynamic manner. This method was discussed here. 

Binomial coefficient \$\binom{n}{k}\$ is growing too fast (with \$n\$) to keep a list of all combinations in memory. I would suggest to use instead. 

Be aware of the difference between || and | logic operations And without a need, do no mix up this two operators. So use 

Note that your input function still doesn’t verify that a valid number was entered. Type 22 for example and it will trash the stack — very bad! Make getting a legal input from 0 to 8 a separate function that is concerned only with that, and doesn’t return until it gets a good value. 

If you used a like I suggested above, you would not need to write a destructor at all! (And, it would not automatically generate a bad copy constructor!) 

You can use default initializers on the data members, and not have to list them in the constructors. 

(also, does the library require some special (and highly limited) construct? I notice you are bouncing through a static function . The (and before it) will work on member functions just as well as free functions. works just fine without help. So does the modern equivalent, a lambda expression. ) 

casting Generally, casting is bad. And old-style casts in the code are always a code review issue. If a cast is actually needed, use a new-style cast or more specific construct such as a helper function. But normally these should be eliminated. 

It is normal and idiomatic to write this as a non-member taking two arguments. And, write it in terms of , which is written as a member. Likewise for the other operators. 

As mentioned before, don’t use naked /. So, if you used a , then this becomes . The incoming is a “sink” parameter. That is, you will for certain be creating a new instance of that type in your fresh node. So, optimize for that by taking it by value and moving it to the final location. 

Don’t make this a , since it can be implemented using only the public functions. Write it outside of the class, making it a template function. 

If I interpret this bit correctly, you're just testing whether there is a second dimension within the array, and if there is, you're looping through the array as a 2d array. Otherwise, you're looping through as a one-dimensional array. Wouldnt it be nice if we could explicitly say that in VBA? 

This allows me to convert a range to an array, and then use those values more efficiently. Variants do have their place when used properly, but they shouldn't be used out of laziness. For example, in your code, (which should be ) and (which should be ) are used as numerics (and as such, should be Longs) but are declared as Variants. I assume, it is because they are then implicitly (without explicit direction) converted to strings, but even this doesn't justify the use of variants. You could do something like: 

This is easily handled with a simple function that checks for a potential error instead of triggering an error. Code first, and then an explanation: 

The code below is in two parts. I have pasted code with your old code commented out, and then additional comments for clarity. I have also posted a cleaner version with just comments. Note: From reading the code, it likely wont run properly. I was unable to figure out exactly what your loop is doing, and as a result there are still some bugs. Be sure to fully debug this code before using it. Full Version 

Option Explicit I cannot stress the importance of this being at the top of ALL of your code modules. What does is it causes a compile-time error when a variable is undeclared. This prevents run-time errors when you try to use variables that aren't set properly, and it will save you countless hours of debugging time. Go To Tools > Options Editor > Require Variable Declaration. You'll thank yourself later. Variable Naming Not to be a jerk here, but your variable names are horrible and difficult to understand. You have rng, rng2, rg, q, s, r, cell and the worst part is that you don't need all of them. I declared four variables total (and one of those you didnt even have a variable for, but you did need). Here's a tip, make sure your variables make sense. You should be able to look at them and have a pretty good idea of what they do. is easy to understand: it is the range we are searching in. is just as easy to understand: it is the cell we are currently searching in. Finally, , you guessed it, is the cell we found using our criteria. It is pretty much bulletproof when you start to code like this (actually, not really. You'll learn that bulletproof coding takes a lot more work than a handful of good variables.) and it makes your code easy to maintain. Additionally, there is no need to declare two variables if you need one. In other words, if is used only for the first loop, and never needed after that, I dont have to make a for the second loop. I can just use . General Names Just as Variables need good names, so do subroutines. It is all too easy to take the that the recorder gives us, and to leave it this way. When you have larger projects, and become undistinguishable, and god forbid you have a and as well. Name everything. That's pretty much my mantra. From Worksheets to Tables, and PivotTables, and Workbooks, to code modules, subs, functions, etc., give it a proper name. The sooner you get in the habit, the more time you'll save. Implicit Object References You'll likely hear this one a lot, so it is important to learn. Whenever you are working on an object, you must consider the scope of that object. While looks fine to the untrained eye, anyone worth their salt in the VBA community will point out that it is a unqualified Range reference. Even worse, is if we have and one step further is this nasty bit: