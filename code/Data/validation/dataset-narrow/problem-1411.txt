The third parameter specifies which parts of the sprite you wish to draw. From MSDN: sourceRectangleType: Rectangle? A rectangle that specifies (in texels) the source texels from a texture. Use null to draw the entire texture. You should change your code to something like this: 

I think this is the point of your homework. If you never try to implement what you've been taught, your education was just a waste of time and money. 

Where (ScreenWidth * ScreenHeight) is the number of tiles shown on your main screen at any time, and GridWidth * GridHeight is the number of tiles your grid holds. For example, if your window shows 30x20 tiles, and your Grids hold 100x100 tiles each, then 

The PlayerSkill's constructor should create a reference to the relevant SkillInfo instance based on the SkillInfoId property. This way, if you serialize the player (when you save the game), only the SkillInfoId will be stored. Consider the scenario, when you want to create a patch for the game, that changes the Weapon skill's description. This way, you only have to upgrade it in one place (weaponskill.xml). And as Sean said, you (or your artists) won't have to recompile the game exe. 5 . The basic principle you should follow: The source code mustn't have any "content". Content here refers to descriptions of skills, skill names, NPC names, experience level values, sprites, 3d models, animation durations etc. Keep the logic and the structure in the code, and the content in external resources. 

If the axis is fixed, then you can directly construct the orientation quaternion by supplying that axis and the angle. The angle argument is then the only one that changes, just like you want. If your factor is constant as well, then you may consider storing the incremental rotation as a quaternion and multiply the old quaternion by this new one each frame (should be faster than evaluating ). In terms of performance, creating a quaternion from angle axis is not a bad idea, but if you can avoid trigonometric functions and square roots, then by all means do it. As to your "bonus" question on whether it makes sense to think of an exponential operator on the quaternion space, your hunch is right. The only problem I see with this operator is that it's not going to help you in this particular case since it resolves to actually extracting the rotation axis from the quaternion and then building it back again. For more details, consult this short article $URL$ . It is here where the properties of the and are explained for quaternions. But their applications usually involve quaternion calculus or storing compressed animation tracks in more complex game engines. 

Although being a neophyte to network programming myself, I would like to share my limited experience by adding a few points: 

Never, never promise 'payments once we've made a profit'. This is a red flag to artists. It means we're never going to get paid. No matter how good you think your game is, promising profits is a really bad idea, and will scare away professional artists. If you want us to be reliable, we need the same thing from you. On a non-paid game, this means: getting all the info from you that we need for each asset, not having a ton of arbitrary revisions (as this is a lot of extra work), a reasonable deadline (if we're doing it for free, we can't do it fast - we need to work, too), and timely communication (don't leave us hanging for weeks). For a paid project, make sure you pay on time. I can speak from experience when I say that promises left unkept will halt all art production in the meantime. In the end, a non-paying gig is only going to hold us so far, as we need to eat and pay rent too. If you really want an artist to stick with you for a while without pay, you have to find someone really invested in both the game, and their partnership with you. Budget Negotiations. If you have a really tight budget, tell the artist! Many professional artists can be willing to dip their fees if the project is something they really believe in. If you can only afford $XXX to go toward art assets, tell them what the budget is upfront, and ask them to tell you how many assets/how much work that your budget can afford you. A good artist should be able to bring up an estimate, and as long as you're both reasonable, even if you can't work out a deal immediately, you can leave a good impression on each other and leave open the possibility of working together in the future. Find an artist who's work you love and that you think will fit the project. You're much more likely to find a good fit if you find them, rather than them replying to a job ad. A good idea is to maybe find 20 artists that you like, and contact them. Even better if you can find the common thread that you liked about their work - because then even if you get negative replies to your first batch, you have the vocabulary to tell other artists exactly what you want. Check out art forums. Some good ones: www.conceptart.org , www.cghub.com , www.cgsociety.org . There is also deviantart.com, but I would stay wary - the general population of artists there are in the amateur category, and while they may be really enthusiastic, they probably don't have a lot of experience and will therefore be more unreliable. Ask for a resume, portfolio, list of references. Just like any other job! Follow up on the references, and if they have published titles, look at the titles! Someone with published work under their belt is much more likely to follow the game through - they've done it already! 

What does it do? Starting from the center, it should modify a linear interpolation factor based on the texture coordinates of that fragment. If the fragment is "inside" the wormhole, it shows the new texture. If the fragment is outside, but not too far (swell area), it show a blended color between the original "swelled" image and the new image. The fragments that are further away maintain the original texture color. That's how I would write a very simple wormhole shader. 

UPDATE Basic maths: if your input is a variable called X and lies in the [a,b] interval, but you'd like to have it translated to the [c,d] interval, the common sense way of doing that is via a linear/affine transformation (affine operators are functions of the form AoX+B where o is a multiplication like operation - A and X could be matrices or other multidimensional elements). For a scalar x in [a,b] we have the following transform: 

The first six cases are actually less numerically demanding due to the fact that is by definition perpendicular to (it helps with avoiding to compute some dot products since they're 0). In the last case, things are a bit more complicated, but that's why I left it as a last resort test before deciding the objects might indeed overlap. Although not represented in this figure, is one of the vectors involved in computing the projection of the triangle onto the axis. To efficiently compute the amounts (cross and dot products) needed for this test, I wrote a small python script to generate the first 6 cases: 

This way I can customize the collision effects only when necessary. For example, in my game bullets simply disappear (with an explosion effect) when they collide with anything, so I don't have any 'if' blocks in the Bullet.OnCollision method. 

I have some ideas, although I'm not sure if any of these is better than your solution. Just something to think about. 1 . To filter out the cases where collision doesn't happen: Notice, that the area your brick object covers while moving between two Updates, can be represented as a Polygon (let's call it P1). The area that you ball object covers, can be represented with a polygon (rotated rectangle) and two circles (let's call these P2, C1 and C2). In every update, you create these polygons and circles (hopefully the acceleration of your objects isn't supposed to change between updates). Then check if P1 and (P2 || C1 || C2) intersect. If they don't, then you have no collision. 2 . To get the precision you want: Interpolate to get the object positions between two Updates. If the ball moves 50 pixels in an Update, but the brick is only 20 pixels thick (or also moves too fast), then you must compare at least 3 states between T1 and T2 (T1 is the previous update, T2 is the current update). You can calculate the positions of the objects in these virtual updates (T1i, T1ii, T1iii etc.) the same way you do for T1 and T2. Then do collision detections with the corresponding object positions (Brick.GetPosition(T1i) vs Ball.GetPosition(T1i) etc.). The good thing about this method is that you can achieve exactly the precision you want, without doing too many or too difficult calculations. 

Provided your aircraft speed is constant, you can "easily" compute a closed form trajectory.. but you have to renounce quaternions and think in terms of spherical coordinates. Since the aircraft velocity vector (when normalized) lies on a sphere, its orientation is thus describable by a parameterization of the sort: 

If your two quaternions are and , they represent the same rotation if either of these two conditions hold: 

The tiny details and patternless distribution of ornamental textures make me think that these terrains were not generated using a standard heightmap-blendmap method. 

Sounds like your engine constantly tries to update the parameters of that object. The object should freeze in position once it reaches a state that Bullet has decided upon to be "stable". Otherwise, numerical errors won't ever result in accurate collision handling, therefore that jittery motion (forces build up eventually, objects are penetrating again, oscillations result). Some ideas are mentioned here. I would start investigating the "sleep issue". Perhaps someone who has hands on experience with this engine could provide a way to set the sleeping threshold efficiently in your case. 

That's not gimbal lock: the camera simply aligns itself with the up vector and then you get a camera transformation matrix that's rank deficit. In not so mathematical terms, try to mind this: you must rigidly rotate the camera's lookAt and upVector together (using the same transform/rotation). I repeat, this is totally NOT gimbal lock, but it's quite similar in one aspect: you lose one degree of freedom since you end up with ambiguities when you align the up vector with the look at vector. Short solution: keep track of both lookAt and upVector and transform them together. That should work just fine (mathematically, but not necessarily optimized from a computational point of view). 

I'd like to second what Olafur and Iain said, but to add a comment to Iain's fourth point. Characters can speak, and they can speak a lot, as long as you make sure that their dialouge builds the story, and that story is engaging. A good example of this in a 'male-oriented' game that still really appeals to me as a female, would be Red Dead Redemption. Totally opposite most of my points! But his story is very strong and emotionally engaging, so I still want to get behind him and support him, even if his experience is very differnt from my own. Beyond that, I'd like to add one of the things I read in the book "Gender Inclusive Game Design" that always sticks with me: Have a female option for the main character! Having the option to play as male or female will already help you get your character to appeal to a wider audience, and help the female side of your audience empathize with the story. If you can only have one character option (as is necessary in some games), try to see if you can make it female instead of male. Given the option, most women prefer to play as women, and a lot of men to prefer to play as women too! (Gives them something nice to look at. :) ) If your concept has absolutely no way it can have women in the character base, then try to make your characters a little more base appealing. Some examples would be: The characters from Team Fortress 2 (Strong silhouhettes, bright colours, good humour and many options), and Link from Legend of Zelda (Androgynous enough that let's be honest, he can be a girl if you pretend hard enough). 

You will probably find what you're looking for here: Steering Behaviors For Autonomous Characters Maybe in this article: Steering behaviors (full article) 

4 . When you have for example 3 players with 5 skills each, you shouldn't store the name and description of those skills for all the players. Something I would do instead is: 

There are no pros and cons. These two methods fulfill different requirements. A skill tree works usually better in a scenario, where: 

Get a Vector V_r which points from the collision point to A's center point (let's call the center point P_A ). Set the object's new position P_An = P_A + (V_r * d), where d is a distance. This distance must be so, that after you set P_An, the object is no longer colliding with the wall. So d depends on your collision detection method. With pixel perfect collision, d must be large enough to put P_An on a different pixel than which P_A is on. Let's name the object's velocity vector right before the collision V_v. Set the object's new velocity to V_vn = -V_v * c, where c is a constant value somewhere between zero and one. This will provide the effect of some "inertia loss". 

If I understand your question correctly, your main concern is storing / accessing the generated tiles. Good news: you don't have to reserve the empty space for all the tiles that are not generated yet. There are many ways of storing 'irregularly shaped' data structures. For example, a possible solution is to build a list of pointers to the tiles you've already generated. 

First observation: The inverse of is not , that is completely wrong. Rotations with quaternions imply that these 4D complex number equivalents have unitary norm, hence lie on the S3 unit sphere in that 4D space. The fact that a quat is unitary means that its norm is and that means that the quat's inverse is its conjugate. If a unit quaternion is written as = (cos(t),sin(t)v), then its conjugate is =(cos(t),-sin(t)v), where t is half of the rotation angle and v is the rotation axis (as a unit vector, of course). When that Hamilton dude decided to play around with complex number equivalents in higher dimensions, he also stumbled upon some nice properties. For example, if you employ a completely pure quaternion (no scalar part w !), you can consider that crap as being a vector (it's actually a quat on what people might call the equator of the S3 sphere, which is an S2 sphere!! - mind bending stuff if we consider how technically impaired the people in the 19th century seem to us eyePhone cowboys nowadays). So Hamilton took that vector in its quat form: and did a series of experiments considering the geometric properties of quats.. Long story short: 

Although I don't know any XNA, this might help you "cheat" your way into achieving that rolling effect of the marble: