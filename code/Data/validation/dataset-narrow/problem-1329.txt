There are myriad other details but those were the two that hung me up the most. Once I broke that simple barrier, everything else flowed together very quickly. 

This is subjective, of course, but I think that consistency is much more important to game play than speed. Basically, players will put up with a slower frame-rate if the game is consistent, fun to play and not jarring. However, even if the game totally rocks, if it gives people headaches to look at because it bursts, and/or they can't control things, they will become annoyed & stop playing. So... Focus on consistent FPS throughout design & development. Focus on faster (but still consistent) FPS when the game is nearly done, and you have time to improve performance without worrying about bug fixes, etc. One way to get better performance is to use callbacks/delegates/interrupts (depending on your language/platform) rather than polling. 

I've been in development for 30+ years, and was QA for about 15 of that (also QA manager, and director of engineering, hiring both QA and developers.) If you can get a QA job -- if you have tenacity, attention to detail, and can reliably show up for work -- then, yes, it's a fairly "easy" way to get a foot in the door. However, do NOT fall for the romantic notion that game-tester means you "play games all day long." In fact, many people who become game-testers find that they come to really hate playing games in their spare time, as it "feels too much like work." In game testing, you may be asked to do things like 

This is a floating point issue and yes, you will get artifacts at very large values. The reason is because as the size of the value to the left of the decimal in a floating point number increases, you lose precision on the right side (and vice versa). The fix is to change your point of origin so that your offset positions are always within an acceptable range. I had to do this for a space simulator. EG. With my space simulator I used multiple points of origin depending on the proximity of the objects. Either using a planet, the sun or center of the galaxy as the origin with different scales for related objects. This allowed me to work in centimeters, kilometers and lightyears respectively. Another possibility to help alleviate the problem without having to move your origin, is to use doubles instead of floats but you will eventually still run into the same problem but at a much greater distance. One more option is to used fixed-point numbers or a big-number library but you will still need to do the matrix and vector math with floats/doubles, so it can get a bit complicated that way. 

PS. The SwitchCamera script actually cycles between all cameras in the list, so if you have more than 2, it will transition to the next camera in the list. 

This type of dumbing-down happens in most genres of games. It's the same reason that most packaged foods are bland: because they are trying to find the middle ground that appeals to the widest audience. Anytime you make something appeal to the average, you end up with something average. Most FPS games are not made for technical accuracy. Most are made to be mindless shootem-ups, made for mass consumption. While some players may not like the auto-reload, they are a minority and when it comes down to dollars and cents with a target demographic of probably 12 to 18 years old, who is the developer going to cater to? The abundant, trigger-happy gamers who get their kicks from simply blowing stuff up or the hard-core few who get their thrills from perfecting advanced tactics? It's a very different experience. Most gamers don't like having to think too much. Simplifying the mechanics also helps to level the field between new and advanced players, which makes it more inviting to new players. This is especially true for tournament style FPS games. If you want more realistic mechanics, then don't play games like CoD. Try games that have a lot more depth instead, like Rainbow Six. 

and then look for the move that will lead to the maximum score N turns in the future. You may also want to avoid moves that lead to any score below X (say, the cost of dying) N turns into the future. Once you've scored all the possible moves, added bonuses for how well it might turn out in the future and deducted for how poorly it might turn out in the future, then you just sort the array and take the best move. Let us know how it turns out! 

I would say that the answer lies in your Torque license, which your company's legal department should read and base their decision on that. You could also just email the Torque folk (they're quite friendly!), explain what you want to do, and ask if they see any problems or can suggest a path that gets you what you want. This advice works in the abstract, too, and can be the answer for any question of the form "does my XYZ license allow me to do FOO?" 

Also, you need to be passionate, but without too much ego. That is, you have to care enough to want to make things better, but ok with frequent shooting-down of your ideas for improvement, and not let it drive you bonkers. Back to your original question: what makes being software-QA (games or otherwise) an easy entry-level position is that the skill-set is something that anyone can develop, and doesn't require a lot of schooling. As above, tenacity, attention to detail and reliability are more important than many technical skills. It's also a good growth position. It's easy for a motivated person to go from "entry level QA" to "lead tester" in just a couple of years, and promotion opportunities are many. While it CAN lead to a development position, typically QA and developer skill sets are very different. It's also a lot of hard, frustrating work. It is NOT "playing games all day long"! Some folks love it, some folks leave to do something more enjoyable, like flipping burgers. The difference lies with the individual more than with the job. Btw, if you want to beef up your resume for an entry-level game-tester position, volunteer to do some beta-testing for games online, and learn how to write a decent bug report. (You can Google this. A good report is not "paladins suck" or "the space orb needs nerfed." Find out what it means to write a good bug report and then go out and write some. When you go to a job interview, take along 2-3 of your best to show, and explain that you have no professional training, but that this is what you were able to learn on your own. That's valuable skills, right there. Good luck! 

Aren't there any identites of some kind? If not, than I assume there's an "implicit protocol" based on component types. Have fun then! 

The collision system handles functionality concerning more than one game object, thus it must be separate from an independent actor and only communicate via messages. The collision system doesn't need to know anything except the position and physical extension of the object. @2 see BRPocock's answer. But yet again, the system shouldn't know anything about a components data. @3 

We are a small developer company planing to create our first social game. Social games look like a promising genre for monetization, but looking at the actual market (dominated by big players) and revenue needed, it actually appears like a very, very risky business, besides games being a hit-business anyway. costs: 4 devs x 5 months x 3k$ + ads+gfx+sfx+server ~200k$ using an optimistic ARPU of 1$/m, we have to keep about 20k DAU per month for one year This only sounds viable with a very simplistic (costs!) but engaging game ... and lot of luck. Are there any examples of fast to develop but successful social games - not necessarily indie - besides games such as card games, casino games? There is Pocket Frogs and Doodle God, which look simple to develop compared to content-rich game like FarmTown, but it seems these are the exception. 

You differ between intra-object communication (via reactive values. think signal/slots) and inter-object communication (via messages). 

Something like that exists for emulators called GoodTools. It's a suite of applications each containing a database of all "known games" and identifying ROMs via checksums to rename the files to a canonical scheme. Unfortunately I'm not aware of anything similar for the PC platform. 

In addition to Iain's and Ben's very good answers, an important concept is the differentiation between "what is legal" and "what is enforceable." Just because no one has a particular interest in enforcing their Intellectual Property rights doesn't mean they don't own them and couldn't suddenly change their mind about where to put their legal focus. It's safest (and most ethical) to make an honest attempt to seek permission from the rightful owner. This may involve cost to you, as to hire someone to find the rightful owner. Of course, you can choose to "live life on the edge" and just go for it, but the legal/right thing to do is to put in the effort. Btw, I have some experience with asking for permission to clone what you might think of as abandonware, and the rightful owner telling me "no problem, we're totally done with that IP, now", so don't think it can't happen. 

Tandem's idea of hill-climbing algorithm is good. Another is: some variation on A* to see how far you can go to see how you can get the highest score over the next N turns, where N is tuned to give the desire result. The scoring values you give can be thought of as "cost to move" -- you're basically on the right track, but you'll have to tweak the values until you get the result you want. In general (not PacMan specific) terms, you need to allocate appropriate values for 

The part that wasn't clicking for me -- and, as I suspected, was very very simple -- was that it's just a matter of implementing the doPost() (or doGet(), but I use POST) routine, and write back to the responder. There were also some bits that I didn't follow quite correctly the first time about setting-up the responder class-names and URLs, in the web.xml file (in the war folder.) Once I got that (web.xml) set up correctly, then the doPost() routine was simply something along the lines of: 

Use the inspector to allow the user (you, or other developers) to be able to easily define the Component themselves without having to modify your code. Use the GetComponent() method if there is no need to be able to change it from the way you designed your script. Efficiency doesn't have to do with it. If you use GetComponent() in your script, you will generally store the component in a variable so that it is cached for reuse in your script, so it works out to be the same thing in terms of efficiency. Where GetComponent() is slow, is if you are calling it as you need it to look up the component every update or something. Store it in a variable and then it's just fine. Same goes for the FindObject methods. Cache it when your script starts, then it has no impact during runtime. 

It's very difficult to move an object independently to match an animation. The standard method is to attach the object to the skeleton of the mesh. Otherwise, you would need know the precise dimensions of both meshes (character/hand and object) and the movements of the animation at every frame if you want it to look right, which can be pretty resource heavy. Alternately you would need to do some rather complex computations based on the key-frames of the animation and you would still need to know the precise dimensions of the mesh. You don't want to have to rely on 'magic numbers' like mesh dimension or else when you change the mesh, you need to change your code too and that is bad practice in programming. This is also rather computationally expensive for little gain, especially if you are trying to get the dimensions of the mesh on the fly. The animator handles all of this complexity for you if you attach your object to the skeleton. Though not perfect, it will almost always be good enough. Your attached object may still penetrate the mesh at some points, since the animator doesn't track the dimensions of the mesh either, just the skeleton. You might get more accuracy if you animate the object separately from the character mesh so you can make slight adjustments in your object animation to account for variances in how the object should move compared to the hand, but that is usually overkill and that kind of accuracy is rarely needed in a game. 

Minecraft is pretty quick, even on my 2-core. Java does not seem to be a limiting factor, here, although there is a bit of server lag. Local games seem to do better, so I'm going to assume some inefficiencies, there. As to your question, Notch (Minecraft author) has blogged at some length about the technology. In particular, the world is stored in "chunks" (you sometimes see these, especially when one is missing as the world hasn't filled in, yet.), so the first optimization is to decide if a chunk can be seen or not. Within a chunk, as you have guessed, the app has to decide if a block can be seen or not, based on whether or not is is obscured by other blocks. Note, too, that there are block FACES, which can be assumed not-seen, by virtue of either being obscured (i.e., another block covers the face) or by which direction the camera is pointing (if the camera faces North, you can't see the North face of ANY blocks!) Common techniques would also include not keeping separate block objects but, rather, a "chunk" of block types, with a single prototype block for each one, along with some minimal set of data to describe how this block may be custom. For example, there aren't any custom granite blocks (that I know), but water has data to tell how deep it is along each side-face, from which one can calculate its direction of flow. Your question isn't clear if you're looking to optimize render speed, data size or what. Clarification there would be helpful.