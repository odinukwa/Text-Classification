You have both CSRF and XSS vulnerabilities in your code. You should be using form tokens as mitigation against CSRF (this also means you need to be using sessions). And you need to consider cleansing text input before insert (for example failing if you detect tags or other XSS vectors), and at point of rendering (where you are also not even rendering proper HTML entities.). 

I am concerned with that fact that your model (which should represent a single instance of a given object in database) would have the ability to switch insert id's. Is the class a provider/factory or a model? 

DB Manager thoughts: 1) I am generally not understanding what you are trying to achieve by even having this class. It is not doing anything like managing database connections, abstracting the user from SQL formulation, adding transactional handling around queries, or other things that one might often implement a class such as this to do. As it stands now, you have in essence only added some custom exception types, while severely limiting the sorts of methods and ways of working the caller may desire since you have not implemented them in this wrapper class (How do we check number of rows in result set? How can we work with one record from result set at a time? Both very common operations.). I honestly think you would be better just having a simple PDO provider class and let your calling code just interact with the PDO object itself (PDO is an abstraction after all). 2) Without seeing code for the new Exception classes to understand if there really is some value being added by these (rather than simply more complexity for calling code to deal with), the value certainly is not clear here for having these. An exception specifically for getting an empty result set on a select query seems VERY odd, especially since there are many reasonable use cases when a DB might be queried and be expected to potentially return and empty result set. Now you may have a case where you would never expect a query to return an empty result set because of how the application is structured. In that case the logic calling the database should handle the empty result and perhaps throw an exception, but this should not be logic within the database class. If you were truly doing something useful in this DB class like trying to abstract out the caller from knowing there is an underlying PDO object, then perhaps you would catch PDO Exceptions (which you do in many cases) and map them to exception types more meaningful to your application - terminal exceptions, retryable exceptions, etc. - not add in additional subclasses to PDOException. 3) 

Now your option "value" is actually something meaningful, holding a string that can be used to directly instantiate a object. 

Do not echo error/validation messages to standard output. A validator like this should do one thing - validate, not deliver end user messaging. Leave that up to functionality further up the call stack that is more well-positioned to understand the context for how end user messaging should be delivered. This code might throw exceptions and/or log errors when it gets put into a bad state (i.e. invalid JSON is passed) but outside of that, it's contract to the caller should be to just deliver validation results and leave it up to the calling code to determine what action to take from there. If you are delivering error messages, you should also remove any HTML markup from it. What if this code is being used in a RESTful service where response is going to be JSON format and not HMTL? Now you have to go strip out the HTML mark-up that has been added. The takeaway here is to separate your display concerns from your business logic. 

You don't do a good job of validating . You just assume the value passed will be good (a bad mistake when working with user input). May I suggest something like: 

You should also strongly consider not hard-coding values that should probably be configurable by the caller. Why would you build a function that could only get tweets for a single user name? Why would you not pass in values such as username, number of tweets to retrieve, where the caching directory should lie, etc.? 

Really hard to see this conditional mixed into HTML like this and with all PHP and open/close tags there on one line 

Your usage examples here are a bit trivial and using a functional approach to working with the data in the database vs. an object-oriented model approach. I would think that you need to be aligned in your approach for how you are developing your application. 

rather than having some inflexible centralized approach being enforced via a wrapper class. Ideally the logic for each database access is co-located together in one place (i.e. methods on a model class) vs. being spread across a number of classes, obfuscating the logic in the process. For example, I have rewritten your example using only an injected object 

You could, in your current solution, even shave some memory utilization, in that you could discard the input strings once you read them into arrays, meaning you could get to 2x max memory utilization for both dictionaries. Of course you still spend processor time reading the strings into arrays. 

A stylistic note, and maybe a result of copy-paste, But I think having eight spaces for each indentation is a little overkill and makes your code hard to read. I might suggest four spaces if you are not locked into this particular style for some reason. 

Why do you ever need to store this? This is only meaningful right before writing a file correct? So why to you need to store the results of at all? I would just generate the content and then write as single step (though I still think it make sense the separate the logic into different methods. 

Note that the outcome here is very reusable code that could be pretty much dropped anywhere within a larger application to implement your quiz. In a real application you may also add something like a quiz rendering class to be able to render the quiz using javascript (and to separate display of quiz from core quiz objects). It also makes it much easier to modify your code in the future. You need to change how questions are scored? - well just change the scoring logic within the answer and question classes as implemented in those class properties and methods. As long as you keep the contract (i.e method calls) with the quiz, the quiz class itself would likely not need to be modified. 

If you are striving to adhere to the single responsibility principle, you will quickly understand that the router has too much responsibility in your application. It should own just routing the request to an appropriate controller and then get out of the way. 

Your code can become hard to read at times due to long line lengths. You should strive to keep lines under 80 characters. Break your code across lines as necessary. 

Even for a case of using long sessions (or true browser-controlled session lengths as you are doing), you should regenerate session id at regular intervals to mitigate against session fixation/hijacking. This means you have to start managing a timestamp in the session data. There really is no way around this in PHP sessions. I know one of your stated goals was to not have to get into this, but there really is no alternative if you want your sessions to be secure. Please read the "Session ID Regeneration" section of the second link given above. There is a pertinent quote there: 

You are not doing ANY validation or type-hinting related to the parameters being passed here. For public functions, you should typically validate passed parameters for at a minimum, things like data types, but possibly also to make sure the dependencies make sense to work with. Here for example, you could try a DNS lookup against the passed variable to see if that host is even reachable from the server the code is running on. When validation fails, you should throw an Exception or otherwise give caller feedback as to the failure. Also in this method, I wonder whether these default values should be specified here in the method signature rather than in class constants or properties. Perhaps your method signature should be something like this: 

The collection should just be a collection. With methods only for managing/accessing the collection not for calling methods on the objects contained in the collection. Note that generalizing to just a method would also allow you to call this method in the method to see if command already exists. Note that if you decided you still want to stick with Laravel as your base data structure, then you might also get to the realization that your collection class really adds little value above and beyond what the Laravel class adds. So why not: 

I don't understand the property at all. It seems unnecessary. You can use to design away your two code branches in method (or change operational order of update/insert if you wanted to perhaps remain more database agnostic as suggested in another answer). I also think that perhaps you are thinking of these method calls being made in more of a linear fashion than what might actually be presented. You may want to take a look at this great article on how session handlers are called relative to session management code in PHP. By looking at this, you can see that things like session ID change can happen between calls to the other methods. I especially like this summary comment from the article: 

This is honestly a little bit of a backwards approach in current programming culture, where it is now relatively easy (though virtualization, containerization, etc.) to guarantee environmental setup. The one exception being a case where you have a deployed application that must run in an end customer's environment and you aren't able to deploy a virtual container for it to run in. If this is not the case for you, I would guess you time might be better spent in learning/working with virtualization and/or containerization such that you learn to build consistent environments. That being said, you seem to have opportunity for refactoring. Rather than all these cases, does it make sense to build environmental profiles that can be loaded based on appropriate data in ? Where perhaps is base class that can be extended by , etc. for platform specific behaviors? 

I think you are missing an opportunity in only validating your form at submit time. You are using an excellent jQuery validation plug-in that will let you do things like validate individual fields when their values change, giving more immediate feedback to the user around validation errors. I also think you may not be taking full advantage on the configuration options that this plug-in gives you such that you might better separate your validation logic/configuration from your static HTML. 

The first approach seems to better separate concerns. You have one class representing a dog and another class which can perform database operations related to the dog model. I don't know that is a meaningful name though. I don;t see where any sort of mapping operation is happening. Perhaps , , or similar might be more meaningful. In either case I have a challenge with the level of mutability given to the Dog object. Are these objects supposed to be fully mutable by calling code and then the are only written to the database when calling code specifies (like for initial insert or later for update)? I see nothing that prevents the Dog from being reinserted into the database over and over again. So, should you throw an exception of Dog with id already set is passed to insert? 

I have concern over the overall data structure you are building. First, I think there are more levels of nesting than is necessary. Second, the repeated use of as key at different levels of depth seems odd and potentially confusing. I would encourage you to really rethink your data structure with an object-oriented approach. Think about what are the "real world" properties that should exist for each item in the hierarchy and how you represent the relationship between items. You might end up with a structure like that shown below (shown using JSON-like notation to indicate object structures - or alternately associative arrays in PHP). This has 4 levels of nesting instead of 8 as your current model does. Interestingly enough, you will also note that your logic to output this data structure has 4 levels. That is because four levels of nesting is what the "real-world" relations between these objects in your hierarchy really dictate.