Don't count. Calculate. The Wikipedia article on partitions gives the Hardy-Ramanujan estimate \$P(n) = \Theta(n^{-1} e^{k \sqrt n})\$ with \$k=\pi \sqrt\frac23\$. Since your code finds the partitions to count them, and since the "average" partition has a lot of \$1\$s, your running time is \$\Omega(e^{k \sqrt n})\$. The Wikipedia article also gives a number of recurrence relations, including one which uses generalised pentagonal numbers (giving a running time of \$\Theta(n^{1.5})\$), and another which uses the sum of divisors function (giving a running time of \$\Theta(n^2)\$ if you pre-calculate the sum of divisors using e.g. the sieve of Eratosphenes). An alternative quadratic approach (which you could find by following the Mathworld link from Wikipedia) uses the auxiliary function \$P(n,k)\$ for the number of partitions of \$n\$ into parts of which the largest is exactly \$k\$ and the recurrence \$P(n,k)=P(n-1,k-1)+P(n-k,k)\$. 

Why? If there is no word, returning a list containing no words would be more consistent and would simplify things for the caller. 

Heslacher's review covers most of what I would say, but there are a couple of things to add about the main loop: 

To start with, the spec is badly phrased. I know it's not your fault, but it might help you (and would almost certainly help reviewers) to clarify it. It talks about partitions of but since the are actually a partition of , and it requires unpicking of the definition. I suggest the following rephrasing: 

Secondly, the clauses in the subquery seem pointless, since they're implied by the class on the main query. Simplifying further, 

appears to be indented too far. Well, either that or there are some missing to include it with the previous statement in a single block. 

Enough depends on your requirements, but the answer to the question "Is it as efficient as it could be?" is "No". has to shuffle along every later element in the list. In the worst case the random number generator will return a long string of 0. The standard solution is a swap. 

The name is unhelpful: I think it would be better as . But that's a minor issue. The big issue which I see here is that 

This is also surprising. "Smallest" in what sense? It's unlikely that the smallest digit will coincidentally be the first one. 

I understand (for the most part) why this is written as it is, but the asymmetry slowed me down slightly. (The bit I still don't understand is why one half uses and the other half uses ). Would it be preferable to make the test symmetric using basic properties of twos-complement numbers? 

One high-level design question: why so much use of hex? It's a terribly inefficient encoding. If you want to be able to copy-paste passwords, at least use base 64 if not base 85. 

This will work, but it launches all of the downloads simultaneously. You'll probably find (and I speak from experience here) that you get better performance by running no more than simultanous downloads for some value of between and . Writing a method which uses to launch a new task when one completes is a good exercise in / programming. Note that the has to be lazy for it to actually work as intended. 

There are a couple of other directions which might be worth considering. One is to go the full hog and implement . The other is to slim down the dependencies by removing and implementing with . Both would make the implementation of more fiddly, and it's reasonable to decide not to go in either direction. 

Although not many people do it, it's best practice to use string literals for object keys. E.g. instead of 

You should be able to carry this reasoning through to fill out the entire list of fields required in and the logic to update them when reading an and when reading a . 

Why return all of the permutations in a single array? There are \$n!\$ permutations of \$n\$ elements, so available memory quickly becomes a limiting factor. I would consider looping over \$12!\$ elements, but I wouldn't want to put them in an array. Since the question is tagged ecmascript-6 you should be able to tweak it to be a generator function. 

I'm not a Pythonista, so I can't comment specifically on your use of Python. However, there's one language-independent issue which the existing answers don't mention. The algebraic solution of the quadratic equation is the textbook example of an issue in numerical analysis known as loss of signficance. The Wikipedia article on that topic goes into sufficient detail on this particular equation, but to summarise in case of link rot: When is much larger than and , is approximately equal to . That means that one of or will be subtracting two very similar numbers, and the result will only have a few bits of accuracy. The correct way to solve the quadratic equation in code is along the lines of 

Names are key to maintainability is a useful name for a datatype, but as a name for a variable it is opaque. 

This code aims to be simple over being efficient, although there are some efficiency considerations. It uses a for testing membership of the excluded set rather than iterating through it, and it uses to avoid duplicates. The next efficiency complication to add would be using and to quick-reject cases where we will certainly exceed . 

From what I did understand of the explanation as to how the data is used client-side, the versions and the actions should be in the same order. But if they are then it's pure coincidence. In particular, sorts alphabetically before , but comes before either of them, so if the actions are an insert, an update, and a delete then will be in a different order to . This looks like a major bug. 

One possible further optimisation would be a meet-in-the-middle approach. You can find more detailed descriptions of the principle in the context of e.g. Rubik's cube solving, but here's the basic idea. You want to find the least such that starting with the generators in you generate the (finite) group (here ). For the sake of simplicity, let's assume that the identity element is in . Then we're looking for such that for each element there is a sequence . The approach you're currently using builds up these sequences from one end. But you could equally well build them up from the other end. can equally well be written (and in this case, since each generator is self-inverse, ). That leads to the more complicated (and not tested - beware!) but perhaps more efficient 

Also, if you're going with either one or two loops of length it's worth using the symmetry that \$\binom{n}{k} = \binom{n}{n-k}\$. This can be as simple as . 

You asked how to expand to more fonts etc. The simple answer is to use a loop rather than implementing it by hand. Add to each of the preview divs, and then use to get hold of them. 

has an out-by-one bug: it cannot select the last image. Of course, if you want to be clever you can replace the (fixed) 

and here the indentation does pass PEP8, in part because of shorter names. Note that using an inner function allows memoisation with and allows the short name because its scope is restricted enough that this is sufficiently expressive. 

Finally, to address the security: give me two passwords encrypted with the same key and I will give you both passwords in very short order by finding the greatest common divisor, which will either be the hashed key or a small multiple of it. I will be able to tell when I've found the right multiple because the salt padding will all be from the reduced set of printable characters. 

You have common code, which moreover has applications beyond this one, so should you not pull it out into a function? Then you can reduce to 

and as method names don't follow C# conventions, which would be and -- although it would be even more idiomatic here to make them an indexer. The original task is phrased in terms which are as language-agnostic as possible, but in an interview you should aim to show language knowledge where you have it as well as general knowledge and skill. 

You should never iterate through a map's and look up the keys inside the loop. Use . That's even more important with , which doesn't even have average-case constant time lookup. So 

This is rather un-object-oriented. The most OO way of doing this would be for to have a constructor which takes (and possibly , although arguments can be made either way). If you don't want to be OO, the exposed API method should be and should not use fields to pass data to other methods. I'm missing some documentation to say what assumptions are made about the contents of . Can it contain duplicate values? Must it be ordered? Why is the return value ? I can see a strong argument for , and also a strong argument for with lazy enumeration, but I can't see why the order of the combinations matters, or the order within a combination matters. 

In C# it is more usual to use the type alias , but that's a matter of style. What makes absolutely no sense, though, is parsing an and storing it in an which is never modified. To be honest, I'm surprised to see longs at all: do the constraints which were in the original problem statement imply that they'll be necessary? I am morally certain that the number of cities is not going to exceed the limits of an int. 

You should easily be able to prove the invariant that , and since it's odd . In fact, we can instead work with : 

Before even thinking about performance, concision, etc., run JSLint or similar over these methods and fix the indentation, other whitespace, and bugs. As it is the lack of consistency and poor indentation makes it hard to read and hides things like a missing comma which is leading to implicit semicolon insertion: 

Lifecycle What is the intended lifecycle of an object of this class? I don't see any constructor, and the field 

Comments I don't see a single comment outside the parser. If it's throwaway code, that's fair enough, but it's rather counterproductive to ask for help improving your code and not explain anything about it. What approach are you taking? I can see that there's a DFS, but why? What does the return value of the DFS contain? Why is initialised to ? The lack of comments is very evident in the fact that VisualMelon offered a hint in a comment on this question for something which I think is essentially the very heart of what the code is already doing: but that wasn't obvious from a quick look at the code. If you write out the basics of your approach and the reasoning behind it, I think you'll find that there's a simpler way of doing it. 

The comments don't make much sense ("has one or more versions" is true if the group is non-empty, and if the group is empty then I don't think the expression would be evaluated at all), but that's a separate issue. 

What purpose does this serve? I think that it could be eliminated by changing some s to s, which would make the code easier to read. 

I don't think those three blank lines serve any useful purpose, but the excess of blank lines means that fewer important lines fit on screen. Obviously some of this is personal preference, but I think there are at least 133 blank lines which would be better removed. 

If you call this once and then loop through the resulting iterator multiple times then it will not consistently return the same values. You may think that in real usage you won't come across iterators like that, but sometimes the non-determinism is a lot more subtle. 

Think in parallel (Or: a lot of the preceding was because they're important lessons, but I'm now going to recommend throwing most of the code away and rewriting from scratch). Why is it necessary to first find the roots and then build parents? And why is it necessary to break out of the inner loop in the second half when you've found a node whose parent is already in the tree? [NB That's a rhetorical question: I know that you're doing it to avoid a concurrent modification exception, but there are standard workarounds for that which are less inefficient]. In particular, is there any reason not to structure things like this? 

That's an interesting trick, which I'd not come across. I've never really looked into because I favour static type checking, even at the expense of longer code. The static way of doing this in C# would be the visitor design pattern: 

Why 1000? There are two values which are easy to defend here: positive infinity (which is the value that an algorithms textbook would use), or half the maximum value of the datatype (to avoid overflow when adding two weights). Even the second one of those requires a comment to justify it. 

This comment is better, but a reference or sketch proof for why this is the appropriate value would be good. Also, I'm not convinced that this is the best stopping condition in general. See below. 

(Although see my previous comment on eliminating ). However, I'd be very worried about letting a random external class change or : I'd at the very least make the setters if not . Isn't just ? If so, it shouldn't be maintained separately because that's just an invitation to create bugs in the future. It could be replaced with a computed property. 

and assume there's a bug. (Surely bursts are about exceeding the long-term average, and in the example given of a long-term average of 1024 bytes per second with burst of 200 bytes we wouldn't be able to write 256 bytes per second if we tried to do it in one packet per second). The documentation needs to be a lot clearer if you want anyone else to use it, including yourself in six months' time. 

Firstly, this could use a better description (in a comment) explaining what it does. I had to figure it out from the code. I think the description should probably be something like 

Huh? This answers my earlier question about special cases, but raises a more fundamental question. Do you understand what the point of an LRU cache is? You should never have . 

Rethink method signatures Why does return a ? I can't think of many situations in which it makes sense to return a (or a ). Either you're appending to a /, in which case it should almost always be an argument and doesn't need to be returned, or you aren't, in which case it makes more sense to return a . Why does () return a string or ? The type exists for precisely the type of things which are or . 

It's a couple of years now since I used PHP, and I'm not sure offhand whether there are built-in functions to test whether contains as a subset, or to filter an array by a predicate. It may be that the whole function can be reduced to two calls to built-ins. If not, you could consider whether you want to factor it out as