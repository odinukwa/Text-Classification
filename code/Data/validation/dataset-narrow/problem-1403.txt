You do realise that when you're in game development you won't be playing many games? That most likely you'll quickly come to loath playing games because you have to test little bits of them over and over again to analyse errors? You seem under the impression that working at a game development shop means you're just going to be paid to do what you like to do now, play a certain genre of game when and how you like to do it. Nothing could be further from the truth. You're going to be spending a lot of time not playing games but in exhaustive meetings about minute details about them. The rest of the time will be spent working on implementing or testing those minute details, and if that includes any playing it'll be playing the same little bit of the game over and over again to test that little detail you happen to have been assigned to working on. It's a job no different from any other, and any job can quickly destroy what enjoyment you have in the thing you're doing. Which is why I always advise people to NOT try to turn their hobbies into their jobs. 

Of course this places a major burden on the servers, your server hardware is going to have to be rather more serious than that of old fashioned gaming servers which were little more than portals to transmit data between clients, but that's what it takes to deflect hacking/cheating attempts. 

To explain what some of this code means: The blocks variable is basically an integer that is storing the amount of blocks, or platforms. I am checking all of the blocks using a for loop, and the number that the loop is currently on is represented by integer i. The coordinate system might seem a little weird, so that's worth explaining. coords[0] represents the x position (left) of the object (where it starts on the x axis). coords[1] represents the y position (top) of the object (where it starts on the y axis). coords[2] represents the width of the object plus coords[0] (right). coords[3] represents the height of the object plus coords[1] (bottom). de2dCheckCollision performs an AABB collision detection. Up is negative y and down is positive y, as it is in most games. Hopefully I have provided enough information for someone to help me successfully. If there is something I left out that might be crucial, let me know and I'll provide the necessary information. Finally, for anyone who can help, providing code would be very helpful and much appreciated. Thank you again for your help! Edit: I have updated my code with a new algorithm that checks where the ball was previously before collision. Corner cases work on that single platform correctly now, but when I have a wall of objects, I keep can really slide against it, but if I move towards the wall while sliding, I pass through it and an essentially now standing on top of a block inside the wall. Also, there is a jittering effect that happens when I am on the ground, where the ball is constantly going up and down. 

It's been tried, it's been done, it's ugly. Games where people get hit by random events that kill them off without any reason flowing from gameplay are NOT crowd pleasers. 

why have such items in the first place? Rethink your system to where you don't have to choose between things that last forever and things that can be used only once. Have things wear down over time, at which point they either have to be repaired or replaced. More powerful items can be made to wear down faster, and/or be more expensive to repair and create (if you have a crafting system). Ryzom did this very well, having a highly involved crafting system where the best items in the game would require rare resources that could only be harvested at specific times in seriously high risk locations, often requiring teams of people just to protect the harvesters against the local mobs. It could take weeks to gather the resources to craft one of the best weapons or armour pieces in the game (over time of course people started hoarding the raw materials, some guilds even going so far as to harvest things they didn't need in order to deny them to others). Combined with storage options that allow enough inventory to keep items for special occasions, this created both a lively trade between players (it took a lot of effort to learn to craft those items too, so the number of people capable of doing it was low and not always the same as those who could harvest the raw materials) and provided an option for people to have different equipment sets for different occasions (which was essential, as different mobs required different armour and weapons to combat, and for pvp different gear was required again, harvesters needing different gear again for that). The game may still be up, haven't played it in a few years though, might go and take a look again. Good memories. 

I am trying to create a 2D platformer (Mario-type) game and I am some having some issues with handling collisions properly. I am writing this game in C++, using SDL for input, image loading, font loading, etcetera. I am also using OpenGL via the FreeGLUT library in conjunction with SDL to display graphics. My method of collision detection is AABB (Axis-Aligned Bounding Box), which is really all I need to start with. What I need is an easy way to both detect which side the collision occurred on and handle the collisions properly. So, basically, if the player collides with the top of the platform, reposition him to the top; if there is a collision to the sides, reposition the player back to the side of the object; if there is a collision to the bottom, reposition the player under the platform. I have tried many different ways of doing this, such as trying to find the penetration depth and repositioning the player backwards by the penetration depth. Sadly, nothing I've tried seems to work correctly. Player movement ends up being very glitchy and repositions the player when I don't want it to. Part of the reason is probably because I feel like this is something so simple but I'm over-thinking it. If anyone thinks they can help, please take a look at the code below and help me try to improve on this if you can. I would like to refrain from using a library to handle this (as I want to learn on my own) or the something like the SAT (Separating Axis Theorem) if at all possible. Thank you in advance for your help! 

There's no magic number, depending on the size and complexity of your system, the number could be anywhere from two or three people (you do want some duplication of effort, to cut chances that someone misses something) working for a few hours over a weekend to dozens of of people working full time for months. And with consumer products there's the added factor of disparate hardware/software combinations it will run on. It wouldn't do to test a graphics heavy game for example on only 2 computers, both with the exact same videocard, operating system, and drivers. It will need to be tested on a broad range of hardware/software combinations to determine if it works properly on all of them (or at the very least to be able to mention in your documentation what the hardware/software requirements are to run it). 

Will you be able to write something like that on a sunday afternoon in your bedroom? No. Can it be done? Well, it has been done so surely it can be done but it's going to take a team of skilled software engineers several months to years to put together from scratch. 

And yes, it has been done. Check out Second Life (and its clones) which is essentially just that, apart from being a social network of course. Everything in the world is created by its inhabitants (or in a few places by the owners/creators of Second Life, using the exact same tools). There's even a saying among SL builders "everything starts with a cube" (a .5x.5x.5 meter plywood cube is the default building block you get when you open the build window, it can be changed and twisted into all kind of things, as well as linked with others). It also has a decent custom scripting language, allowing interaction among objects, parts of objects, avatars, the world as a whole, etc. etc..