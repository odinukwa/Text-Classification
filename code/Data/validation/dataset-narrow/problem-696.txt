Review answer to FizzBuzz If I gave this test and I received the answer given I would not give it a full pass. It does work which is a pass, but compared to an expected answer it performs poorly. Granted you are stretching your programing legs which is great and the answer is good (not great) and I will say well done. Don't take the review as a negative on your coding skills, many people can't manage a for loop at the end of 1st year CS study. For a few weeks you are well ahead of the curve. Comments are dangerous. First a side note. We are all coders and all read code with ease and don't need comments to understand code. For example 

Hope this helps, take what you want, it is real quick nut I had to do something as your code looked like it needed a restart. 

When ever you are animating anything on the page were you define every frame use it ensures that the animation is in sync with the hardware and any other page rendering. It also prevents updated content from being presented to early or quicker than can actualy be seen. Smooth animation is not about speed, but about being in sync and limiting the amount of work the computer must do. 

A more robust function. The rewrite has made a few assumptions, and has been tested on a huge set of random inputs without failing (no fail in over 10 million random input tests). That does not mean it does what you want, it does what I guessed you want. Order events by time, in same time groups, order events in alphabetical groups Rather than modify the existing array I have created a new array to hold the results. 

becomes and you use destination to mean a link, we can abbreviate destinationEnd as and makes more sense as with better called 

Optimising for performance. Javascript has a way encouraging people to write code that is terribly inefficient. You are lucky the problem is one that can get a lot of benefit from just some minor changes. Memorize (binning) is not going to help, it will actually significantly decrease performance and massively increase your memory load. The crazy thing is you are already binning all the data in your code. First the rendering 

Avoid using more memory than you have to. The array is a duplicate of the data. You can Use the existing and use the second argument to set the start location of the search. Rewrite of you solution As you solved the problem, and the logic is sound I rewrite your code using your logic but with some improvements. 

An example There are many ways to write this function. I have opted for speed. In javascript string searches are slow when you use character by character searches. You can speed up the search by using regular expressions. (Though it does not reduce complexity it does give significant performance increase) 

Time not Date The best way to deal with dates is time in milliseconds. This is how JavaScript and most other languages deal with time, and is how a date is stored in Javascript. The value is milliseconds since midnight January 1, 1970, UTC. Once you are working in ms all date calculations are easy. ??? Your question is "Getting the remaining days of the current week" but the functions you call is yet the function does something completely different from both the question and the function name. I will go by what I think you want and that is a list of week days left in weeks that start in this month, excluding weekends, and holidays. I have also included a way to set the week starting day. So that you can start the week on any day, the example uses Monday as the start day. Some points 

Create the object We can put it into an object with the method and then run a good set of tests. You should always test for errors not just for good results. 

The next example shows how the tests handle other types of random showing how mean is unaffected while randomness (flatness of distribution) approaches values below 1. All gaussian like approximations. 

You also create too many variables. If you are using something only once in the same block then it is best to use it in place. eg 

Is there a better way? It is often better to embed as much context / semantic specific information in the page. In this example you could have used a map element to define the click areas and used Javascript just to change the image src. Example The example shows it done with minimum required code. I know that the sandboxed page is completely under my control and can thus reliably use directly referenced elements to add functionality. It is done without jQuery to keep it simple. 

The rewrite. The rewrite is as an example only. There are many ways to organised the code for an app, each has it pros and cons. These will vary with the individual, with the best style being one that best suits your way of thinking. Don't let code dogma spoil the fun of writing a game. The rewrite has added some things. I needed to test if it was all working, and being lazy, playing the game to find problems was too much effort, so I added an autoplay that plays the game at many time normal speed so that I could make sure all was OK. Check the to turn off. I also added a few more bricks. I have change all the collision logic to a more robust form that takes in account the object's travel during the previous frame. As there are 4 types of collision Ball / Paddle, Ball / Wall, Ball / Brick, and Paddle/Wall each somewhat different in needs, thus the code base has grown somewhat. I was tempted to add ball hit deviation depending on where the ball hit the paddle, but left that out in the end. 

and then finding the shortest angular distance a little bit hacky. This is even more so when the angles are originally vectors. Cross and dot products. of the cross product of two vectors gives the angle left or right of first vector in the range -90 to 90 deg and the sign of the dot product will indicate if the vectors are in the same direction or not letting you get the quadrant the second vector is in and thus the shortest angular direction from one vector to the next. The results are always relative to the direction of the first vector so you dont need to normalise the angle to - Polar to cartesian As you want to work in angles (polar) you just need the extra step of calculating the cartesian vectors. The function to find the shortest angular distance between any two bearings (angles). 

Pseudo random shuffle. Next your shuffle is not working very well. You are not providing enough variance in the selection of which array items to reorder. With very different hashes producing the very same shuffle. 

Not much to review but A few points Too many arguments. You have a lot of arguments that could actually be passed as just the handler, and if you make the timeout callback one declared in the (rather than call ) you can close over some of the variables and thus would not have to pass them (and keep them protected). The variable could be removed as it is only used once and may be better as 

There are many other tests. But it is important to note that none of them are perfect and all can be fooled or give erroneous results. The only way to improve the results is to increase the sample count. The above functions test 100s of millions of samples, but there is a flaw in its ultimately based on binay , that will start to show up if you have a very very long time to run the tests. It's not how random, it's random for what. It's about what you want from the random values. Javascripts random is not good enough for high security encryption or hashing, but random enough for games of chance, though generally casinos will use their own random generators. For games, image processing, its is more than enough. And for things like playlist shuffle it's too random. Javascript and function signatures. I have never found a good reason to write an inclusive random function. and I do not understand why some many people do? So all the example will not include inclusive calculations. I leave it to you to add the + 1 if you need it. Default parameters You can use javascripts default parameters to do most of the parameter logic for you. I think it better to have separate double and integer functions 

Yes 50MB is nothing these days, that is unless you have a low end device running on near dead battery, or a priority app sharing resources. Some pointers 

The way you handle the timers is too complex. The 100ms resolution is too high. The two types of countdown require too much code. In the rewrite the timer is set by a setter. and the time is counted down then the correct function called. The game play timer is set with The rewrite The rewrite has reduced the code size by about 20%. 

Spend a penny get a warning. Just for fun a warning not a rigorous answer The common approch Many places have a different system than have removed the smaller coins for convenience. Thus there is a need to round the change to the nearest coin value before doing the calculation. Also you would do the calculation in the actual unit eg dollars not cents, and you don't give counts of coins, you tally and give the total. Eg not "2 tens" but "20 in tens" The following calculates change in $ rounding to the nearest lowest coin and does not work, the logic is sound just the number system that cant. The function will display a warning if it can not balance the books. When dealing with indivisible units using division, be careful. 

Swap the first item with a random position. The first item has a 8 in 9 chance of being above 1, so there is a good chance it will be swapped with a random pos again, but the item that moved to 1 will only have the random selection chance to be moved again. As soon as you have a system in which starting position changes the odds of being shuffled you add a bias to the shuffle. Even if the result looks random to the eye they are not so in reality. Testing for random To test you need to find out how often each item ends up in a particular position after each shuffle (starting from the same pos each time) Example start with ordered 123456789 array and a count array, then shuffle, in the count array add one for the position the first item landed in. 

Protected states require enforcement.. Why would you use the possible colors and complicated apple color vetting process when there is no requirement in your code to do so? You are using a static list (array) in an effort to protect the state of the Apple, or associated states that rely on apples being specific colors. Maintaining trust in object states is important and allows you to make assumptions and reduce the code complexity. It is also one of the most important methods coders have of controlling our arch nemeses.. The Bug! But a chain is only as strong as its weakest link. Even if you put a big sign above it saying "Don't yank this pitifully weak link!" you can't trust coders, not even yourself, for one day the convenience is too tempting, and while in a rush to meet a dead line you yank that chain. 

Cycles never end. This problem is not as simple as it first appears. All path finding algorithms need to be aware of the paths that lead in circles. Your problem and the solutions for this are , , and ". but if we change the last link to we create a circular link. Your code will follow and so on until the call stack overflows. In most recursive problems where you encounter a cyclic reference you can easily avoid the endless recursion by simply tracking the objects you have already referenced. Ending the recursion when you find a link that has already been traveled. But your problem requires ALL paths which complicates the problem (Actualy impossible as cyclic links create infinite paths). Consider the links It has the following solutions 

And just to clarify Javascript arrays. Javascript only has 1D arrays. In Javascript there are really only 1D arrays. We can simulate 2D to infinite D arrays by adding arrays to each item. But you can not guarantee that each item will be another array, or if it is an array, what and how many items it contains. 

Note that benchmarking was on a set of random values in the range to selected such as to amplify the performance benefits of optimising code inside the loop. Testing the code on a larger range to reduces the performance improvements with the first snippet's improvements having error bars overlapping the original, in other words too close to call. However the second snippet kept the same performance increase mainly due to using to floor the value of outside the loop. All benchmarking on Firefox. Update Dont trust leetCode performance results. At the time of writing the answer I had no clue what the hamming distance was. Now that I know it is just the number of bits that are different the solution is very simple. Count the on bits when you xor x and y. So I came up with Solution C 

Implementing an iterative stack. If you count the number of times you need to compare 2 values the recursive function does about 10% less than the iterative function. But that can be changed by making the iterative function act like a recursive function. The replaces the call stack and heap, and holds the merged arrays. When there are no more items to merge in the job is complete. Note turns out a queue is quicker than a stack in this case but the idea is the same 

A rewrite This is how I would have written your code. It is just a suggestion example and far from ideal. I do not know what you wanted exposed but I only exposed what was not called internally (assuming this is a module) 

Assuming that if the first object has a property set to and the rule states no change then your code is almost spot on. Some minor changes 

Is there a better solution? Yes, always... biting my tongue. So first let's look at the function you have. The JS array functions that take a callback as an argument, like , are slow in comparison to standard loops so for more code you can get a performance increase by implementing only what you need in a reduce function. But we can avoid that as well. Using a The function is also a little inefficient. It needs to iterate each item in the new array and test it against the current item. This can be improved by using a hash table. JS has two objects that use hash table lookups and . For this case will improve the search for duplicates and will also serve to hold the unique array while processing. If we are going to use a we can take advantage of the constructor that will create a set from any iterable object. Thus all we need to do is create the set from the array, then convert the set back to an array as it will have removed the duplicates. Thus