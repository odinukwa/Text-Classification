This will iterate over each blocker only once - searching for the one, which needs least amount of player rotations (steps) to align with. Those two to convert value into 0..359 range are effective only when all source rotation values are near this range, otherwise rewrite it with modulus. If you will be profiling it, you may try modulus anyway, it will be probably faster in Java that way anyway. 

Generally I'm quite fine with your original source, looks nice. If you are pursuing absolutely top performance (what is the reason? This looks like a function, which should be used only few times trough life cycle of application) - you would have to dig into first, to see if for your special case of various sets of {-1, 0, 1} values you can generate permutations "manually" in a faster way, then the general purpose permutation generator does. Maybe there is a way, but the source will become substantially longer and more complicated. If you want to stay with , there's little room for improvement, especially without losing some readability of the source. For example with understanding how the is modified by last , you can cut out some initializations and sorting like this: 

how to use the result of (which has to be done anyway to test remainder) as approximation of suggested sqrt(input) test, for earlier exit. used to set zero into register (shorter opcode than plus modern CPU recognizes it as idiom of "set to zero" and optimizes for it) to check if remainder is zero (shorter opcode than plus modern CPU will recognize it as idiom of "test for zero value" and optimizes for it) resolving even numbers at the beginning (even numbers have zero in least significant bit: . And the only even number being prime is , no need to test other even numbers by . but that means only odd divisors have to be tested in the loop, because for sure. So my loop is testing divisors 3, 5, 7, 9, 11, 13, 15, ... some non-trivial usage of arithmetic instructions and flags to check for input values ahead of loop, as those would break the loop logic and produce invalid result. It may be nice exercise for you to "decipher" how it works. you should try to keep things "together" (if possible). For example you set up for at the end of your loop code block, so it's A) not together with , interleaved by (hard to read for human, no problem for CPU) B) you have code duplicity (), because you have to init the register values ahead of very first separately. => So I do initialize right ahead of , only single time in code, and it's easier to read IMO. 

Continue with other neighbours of current node, then go back to loop by fetching next current node from deque (if you have 4 of them, then empty the one with best word_distance first), till the (shortest) path is found. The word_distance is supplying some orientation in the path finding (absolute coordinate distance in A* when used with geometric coordinates) - it's more likely you will find shorter path with words which are becoming closer to the other end of path. I will end here, as it already took some time to write this, unfortunately I will not provide you with working source. 

in argc/argv is probably bug, the at end should have been ? Or it's on purpose? If it is bug, you could have avoided it by using internal method, to avoid duplicity code with implementation. Ok, enough for now. :) I hope I'm not way off, and this will give you some ideas how to improve it. 

View: I prefer to couple my views tightly with models, so the init/update methods take reference to actual model class (ie. View has to import Model). It's not storing the model reference, only using it's API to init/update it's current state and forgetting about it, so you can any time change the View to display current state of different instance of model. With the above model, and intent to have special effect for "level up" event, I would probably design API as: 

Do just if you are using only later. This at first did look as bug to me, because you have anything in , then I realized you will avoid that by using only. Actually this will fail if array spans over 256B boundary, then the will produce wrong address. But you didn't show how you define , maybe you are sure it is well aligned and will always fit into 256B "page". Still maybe consider more robust version doing whole to calculate with full 16b values. 

You should profile the game first. While your code is in worst case doing cca. 360*8 (360 player rotation decrement x 8 blockers) loops until it finds the blocker (and it will end in infinite cycle in case you don't have any blocker in blockers) => so it can be written much more efficiently... Still about ~3k of int compares should not lag modern phone, that's not much. So you are very likely having bottleneck in some code which is not part of your question. Anyway, to rewrite your current code you may try something like this (pseudo code): 

This will not compile, you should rather provide working source for review. By building it yourself before posting you will prevent some kind of accident, like cutting out more than you did want. Also I have no idea what is or , so no way to review it and put any advice on that. Except stop using cryptic short symbol names which can't be comprehended by reading like plain English. 

EDIT: The invalidity of PIC-ness was nagging me, so I finally did dig into the issue, and fixed it, these are things to be modified in the answer above: Commands to compile: 

So... I just guess it would run faster on real HW. But at least in simulator it does use about ~60% of instructions to run (~1500 vs ~2500), to use some measurable (but almost meaningless) number. 

(I did debug it in NASM, so if I'm unlucky, something may fail in FASM due to syntax, but it should be easy to fix. But it's highly unlikely, they should have identical syntax for instructions and I don't use any macros/etc) 

Your code is unfortunately weird mix of both. I will try to show headers for both ways here (just by hand, will very likely not compile without fixing, plus it's missing implementation): (and I'm afraid I'm at the moment tainted by Java too much (coding in Java in other window, so I may mess up some C++ syntax badly, this answer is more about OOP-like ideas, how to design your API and classes). 

Some more typos... don't you have spellcheck in your editor? :-o (I'm using simple kate for NASM sources, and Shift+Ctrl+O will switch spellchecking on/off, so it doesn't bother me on instructions, but I can use it to review comments from time to time). 

So things like belongs to View.update, belong to Model.addExperience, poking model/view in reaction to the click event belongs to Controller (although it shouldn't contain the logic itself, ie deciding whether level up happened or not, that's responsibility of Model). Model contains every important state of the world, so the view can be reconstructed out of it (above I'm breaking it a bit by that "leveledUp" value, writing it now, I would probably move it inside Model, and create one more getter being updated by last call) - from scratch. View contains everything what is displayed, for example it contains the string representation of experience (Model doesn't have to, as it can be constructed from the in Model, by "formatter" in View). And also contains logic, how to display it. Controller should only "connect the dots" and control the execution flow, when what should be called/updated. 

Overall this is quite nice piece of source, so only some tiny details here and there (some maybe even ruining it :) )... From code style perspective I think the variables naming is "only" good, not perfect. tells what arithmetic operation did happen to the value, which is usually not sought after during reading source. sounds to me a bit better. and are OK, to be ultra verbose you may still extend them a bit like maybe and , but that's already reaching some tutorial level. And itself sounds a bit inexact to me, again a more over-verbose variant like may be considered. Can the work with ? Just for the sake of exercising "putting everywhere". ;) (I don't believe it will change the machine code produced by compiler). Maybe even reference &? 

So whatever you plan use that macro for, you should probably stop and look into your SW architecture, as it doesn't make sense. If you want to use it for output formatting, I would suggest to use rather the already created and debugged C/C++ facilities, like . If you still insist to do it by your own, at least produce some kind of , not , which would immediately destroy your rounding (as I shown at the beginning of my answer). 

One note about your original code: You don't clear the input, which doesn't feel right to me. If the function is named , it sounds quite functional to me, so calling it twice with the same vector I would expect it to contain only single copy of vertices (your code would add another set after the first one). For your code probably some name along would be more precise. In my code I avoided this completely by creating new instance of vertices inside the function, and letting the C++11-post era compilers to optimize "return by value" situation. And you can still do twice to get two sets of vertices, to simulate behaviour of your original code (if desired). So the change in API is not limiting such usage, but it shouldn't happen by accident, reusing some non empty vertices. 

edit: When designing the algorithm, design also "memory". Where the data are stored, how much of them, why (purpose), when you want to create (temporary) copy, or when you want to use semantics, etc. I'm not suggesting to go after full "Data-Oriented Design" (unless you are designing some big-data processing application, where performance is main goal), but still some level of awareness how your data are flowing under the hood is good to have. Often by keeping data life cycle lean and without useless moving around, you will not only gain performance, but also simpler algorithm implementation and less code written = less bugs. 

I was thinking whether searching for neighbours for new word can be optimized by searching only trough "neighbours of neighbours of first-found-neighbour", but after short tinkering with it I think this is not valid, this would maybe work for all 4-letter permutations forming complete graph, not for regular words when plenty of possible 4 letter permutations are not available. 

Bug: if contains some low bits, you will get wrong display page value. Should be instead. Why ? First why , that's not English, and why -1, you are on x86 powerful machine, there absolutely no reason to save bytes on symbol names or amount of symbols. 1988 called, they want your habits back. 

AFAIK this is the proper 64b PIE (position independent executable), dynamically linked with glibc and ASLR-ed by common linux OS to random address space. Stripped elf64 binary on my machine has 6320 bytes, not that bad, although the real ASM content from the source is only about 170 bytes (but the elf header/sections data are of quite some size, and then the C-runtime is linked it as well). I know you didn't mention PIC/PIE in your original code and question, but in common current 64b linux OS it is highly desirable to produce PIE binaries only, as that's what the default settings are also for C/C++ compiler, and what makes ASLR and other security mechanisms most effective, so that was the reason why I myself set up to pursuit this side-goal. 

edit: my proposal has somewhat different logic, searching for another blocker, when the nearest one did move, while your original code (reading it now again) is probably moving the nearest one once, and then just finding it again and again, but not moving it. If that's the case, then remove the test from search loop, and add condition to the second part if. 

Another edit: Couldn't resist from showing off, how the function can be further cleaned up for better performance (unrolling the loop for special case, getting rid of in loop). The real world benefit is of course useless, as the loop is done only N-times (vs permuting N size array inside, which is much more complex). So just for your fun ;). (BTW, OCD is evil thing, even partial ... hard to dismiss some things from head) 

You can't. For example you can't round to 1 decimal digit as an with current HW, as the is not capable to store exactly. Try for example: 

Usually when you can UnitTest all model API easily in pure JUnit (without mocking JApplet environment or providing fake UI/display), you are on the right track. There's sometimes need to provide some complex back-end functionality, like database, or server API, for model classes, but it should be still quite easy to mock only a bit of it, and having model exercised to do everything it should. Testing View classes is quite often much more difficult, or straight counter-productive, if you change the design a lot, so your tests would have to be updated often. Testing Controller code depends, usually needs some good instrumentation helper to simulate all kind of inputs/events, mock views (just verifying the is called at proper places), and often may work upon real model classes, making such tests more integration than unit. Why I'm talking about tests so much, while you didn't even ask. Because once you do the MVC properly, unit testing "model" part becomes so easy, that it's low hanging fruit and should be probably your next topic to try out, after you get more comfortable with MVC patterns. :) 

Hmm... ok, one bit of source just to make it look a bit less like "wall of text" (although I'm afraid it's too late for that :D ). 

And the whole set cursor code is a bit fishy, I mean the calculation of based on [x, y], don't you have such code already somewhere? Are you optimizing for speed that you can't afford to call that? (probably not, as you are still in real mode) Also is again risky as you don't specify content (would work with my modification above to ). I would probably write separate subroutine to calculate based on coordinates, like for example: 

Overall your code is very reasonable for somebody learning Assembly, I would say quite nice work. I can produce something what will look more advanced (I hope), but it's more like tiny details improved here and there, and some of them for the price of worse readability of source. I mean on the syntax and low level. On the algorithmic level your code can be improved considerably, as Pawe≈Ç already answered, but he missed another opportunity to halve number of divisions. My variant of code, showing: 

Example implementation of those ideas in this post and comments: ped.7gods.org/WordLadder.zip Meanwhile, lured by the fun of figuring out algorithm, and writing the code, I completely went off the path of reviewing your code instead. Sorry Jonathan. And to make it even worse, my source is not as clean as to be proper example in every possible way, but I have it now for few days sitting on disc and can't get to cleaning it up more, so I'm releasing it at least for the sake of algorithm example, as is.