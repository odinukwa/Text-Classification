Order your includes. Specifically, group your includes by their source (i.e. current project headers, STL headers, library headers...). Most commonly, the following order is used: 

Order your s. The generally recommended order is: first the header the current file is implementing (if any), then includes from the same project you're working on, then includes from other projects and libraries and finally standard library headers. Also, you should sort the headers alphabetically inside their groups (i.e. sort all std headers, but keep them last etc.). If you had followed the advice from point 6, you would have quickly realized that is actually missing an ! You interface to users of your class is meagre. The only way you provide to access the current game state is through , which is not exactly handy if I want to do something with the data other than writing its string representation. Since you have a very convenient representation of your grid already, you should at the very least offer a way to access the current grid directly. You can omit from since the compiler adds it anyway. 

Why are most member functions of protected? Is this class intended to be derived from? Doesn't look like it very much, since you have no virtual methods (not even a virtual destructor). If you still intend to derive from this, you should rethink your interface, if not, those members should be private. Prefer over . It's more readable and more flexible. Don't use single-letter string literals when not absolutely required. Writing hurts performance, especially when does the same thing in the same amount of characters. You don't need to all destructors manually; the compiler will generate a destructor for you automatically. 

Overall, I have very little negative to say about your code. Still, there are some things I'd like to nitpick about a little: 

is extremely dangerous as you could easily overflow here since has type . Currently, the value of is 20, and your code is safe; however, if you decide to change this value at any point, you will likely overflow here, leading to undefined behavior either because of overflow of a signed type if is signed or because of the fact that infinite loops (into which this one will turn) that do not do IO are ub in the case of an unsigned type. In C, you do not need to cast the return value of . Simple assignment will do. In fact, don't actively cast the return value of malloc because it clutters your code with casts, which is a symptom of bad code in general, and can hide a bug related to implicit functions (only before C11). Actually, that loop from point 1 I mentioned can be removed altogether. This follows from recognizing that you are adding all integer values starting from one up to , for which there is an easy to compute formula: . Translated into code, this would be 

Conclusion Overall, your code is not bad. The thing that bothers me the most is lack of structure, which is the core issue you should attack. I didn't spot anything that would require immediate intervention, such as UB (except for your includes, maybe), which is a great sign that your code is pretty good. 

Find the next word boundary Allocate memory according to the distance between and the word boundary found in 1. Copy the word into the newly allocated memory 

is almost threadsafe Why almost? Well, you don't take the lock in . That means that some thread could be making changes to your object while some other thread spontaneously decides to call , which will then be subject to a race condition. Even if you do read-only accesses, as long as the underlying object is not atomic, you have to lock. Apart from that issue, seems to be threadsafe, at least as far as I can see. Why ? You do not do any recursive locking. There is absolutely no need for a , as far as I can see. A normal will do the job just fine. To answer the question you posed: No, the fact that is considered harmful does not apply here. However, you are not using any of the special functionality of it anyway, so why bother? Other Things 

You shouldn't include , but should include instead. is a C header while is a C++ header (with ultimately about the same content). I am somewhat astonished that your current code compiles, as you use and while the is only guaranteed to put its definitions into the global namespace ( guarantees them in the namespace). As a good practice, you should order your includes alphabetically and group them into sets belonging to each other. Preferably, include the header the current file implements first (i.e in ), then all headers from the project you're working on, then all headers from other projects, libraries etc. and finally the headers from the standard library. This will facilitate checks of include-correctness. Speaking of headers, you're actually missing an include in , the include for which is . However, in my opinion writing or omitting the return at the end of are totally fine, so you could do without the macro and the include. Don't use defines for constants, just declare your constants as variables. Defines are all kinds of bad, so it's better to use them as little as possible. You don't need to declare and define a constructor if it doesn't do anything special. Adding directly to what @BenjaminPhilippe said in his answer, you do not only need more classes, you also need to structure your code more. Currently, your function is doing way too much. You should introduce more functions and classes to improve your code structure, make testing and debugging easier and increase reusability. Disclaimer: I don't actually know anything at all about SFML. If SFML doesn't provide any callback capabilities, ignore this point. Polling for key events is usually not sustainable. Even in your little case, key event handling is quite a mess (including nested switch-cases). You should instead register callbacks for each key event that change some state variables somewhere (often, these variables are globals, which isn't exactly great either, but still better than drowning in a switch-case mess) and use those state variables for determining what to do. Why is in capitalized? All other variables seem to start with a lowercase letter, so you should be consistent and stick with . 

The behavior of that code is undefined, because has no virtual destructor. And this is just one of the issues you are prone to run into when abusing inheritance, apart from your code becoming more and more inefficient. What is the point of ? Do you plan to have other classes inherit from it? If yes, do add a virtual destructor, now! (See point 1) However, if I am honest, I really dislike the idea of having a base class as a kind of mixin or interface. The thing is this: Unless I am a child class of , there is absolutely nothing I can do with an object of that class, since its whole interface is protected. Inheritance is not a zero cost abstraction in C++, and should be used sparingly, especially when performance is critical (which is not the case here, however). In your case, I would advocate for just joining the two classes and into a single type. If you want to keep the around, I could also imagine a different approach to tackling this issue: Convert into a kind of event container (which it currently is not very far from) and replace instances of it as a superclass with member variables. takes arguments by universal reference, but you don't do perfect forwarding. That means that you are locking yourself out of the benefits of move construction, which is usually the reason to use universal references in the first place. Whether this matters here at all is somewhat unclear to me and depends on your use case (do you ever expect a listener function moving from its arguments?). Still, it is weird to not see around there. You can reduce the redundancy in the template parameter for while also improving type safety a little. What I mean is that the return type of the event functions you construct should always be void, since the result is discarded anyways. This enables you to actually reduce the template parameter from the full-blown function type to just the argument types, removing the need for writing out all the time and preventing the case in which somebody does not pay attention and tries to pass information through the return, which will inevitably end up in discarded-value-hell. As an added benefit, the lambda in would also become a lot simpler. 

which, to my mind, is much better readable. Look at the two code blocks in the point before, to the line where the assignment happens, to be precise. Do you notice something? Right. While you wrote , I corrected it to . As you can see, the order of and is different. Accordingly, the two lines do two very different things: You line assigns the unary plus of (which is just ) to the number at while the corrected version adds to it. The order in compound assignment operators matters! is a little like the C way of doing errors, except worse because you don't define any error macros. What does it mean if I pass 1 to , or 2, or -45633421? If I take a look at the function body, I can guess that 1 stands for "Out of Stock" and 2 for "Incorrect Denomination", but how am I supposed to know that if I don't have the function body available? C++11 introduced , which looks like it's made exactly for this use case. If you don't have access to C++11 and beyond, there is still the plain old , which has its drawbacks but is still a huge improvement over a magic-number-int parameter. Don't use . Never. is bad. Why is it bad? Because it leads to what is called Spaghetti code, a state in which it is nearly impossible to follow program execution and reason about the code, which also applies to the compiler. There is no reason here to have anything on the heap. Those five s you allocate would work just as well, probably even better as local parameters. Don't use the heap unless you have a good reason to; it's slow, it leads to memory leaks and all other pesky kinds of problems (such as use-after-free) and it makes you handle pointers which is a little more convoluted than usually necessary. Point 5 should have made you realize the dangers of dynamic memory already. Reduce your class to a single responsibility. In particular, have your class do either calculations or I/O. This is called the Single Responsibility Principle (who'd have thought) and is one of the fundamentals of object oriented software design. 

Put the game state into its own struct. Currently, your users can only play one game at a time. While this might be fine for your current use case, what happens if somebody says to himself: "Hey, I have a great idea! Let's build a server where people can play 2048!" and decides to use your code? They will not get very far because your current state consists of globals. Just put them together in a (or whatever name you find fitting) and have your functions take a pointer to this struct as an argument. This is a very common pattern. It might be nice to let your users know when something fails. Currently, returns , but if or are less than 2, you just print an error message and return, doing no initialization whatsoever in the process. This is extremely dangerous as there is no effective way to check for the caller whether the function actually succeeded and whether they can carry on working with your functions. Furthermore, calling I/O functionality from functions whose purpose is something completely different violates the single responsibility principle (as the name suggests, the single responsibility principle states that each component of a system should only fulfill a single responsibility, which, in the case of , is to initialize the game state, not do error reporting). The most common pattern here is to have your function return a return code that indicates whether everything is fine or something happened and the initialization wasn't carried through properly. people usually don't expect some random function to just go ahead and call . This is something that should be left to anybody who uses your code (for small programs, calling in is appropriate). However, when you make this change, you should also document somewhere that this function uses and that the generator must have been seeded before. is not a fitting type for an iteration variable in most cases (such as all of your loops). You know that the iterator can never be less than 0, and , happen to be , so you're also running the risk of overflow. Use here (and when not sure, use ). split lines such as this one up. The general rule of thumb should be one "action" per line, and two assignments are seldom considered the same action. The same is true for loops: is hard to parse because most people would expect the loop body to be on its own line (and ideally surrounded by curly brackets). what does 15 mean here? 15 apples? 15 cabbages? 15 metres? The point is: Don't use magic numbers. Give names to your constants. Since in this special case you seem to care about the bits only, use hexadecimal literals and a comment explaining its meaning at the very least. Why did you but parentheses around and ? Sometimes, paranoia can prove to be useful for security and avoiding evil bugs, but putting brackets around number literals is too much. is a bad name for a function that does cleanup. By analogy to the function from the standard library, I would expect this function to terminate my program somehow, not just do a little cleanup. My preferred name would have been maybe, or , or...