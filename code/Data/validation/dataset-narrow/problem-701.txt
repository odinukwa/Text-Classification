Buffered input I don't know why you chose buffered input as your method of entering the hint, but in case of this command the data has a specific format. 

A bit of explanation. This macro will do all the work that is required to check if a specific flag is set (specified as operand op1) and if so print the message specified by operand op2. We need to specify also our label as local so that there is no label duplication when macro is placed in code multiple times. We also keep the flags to be restored after printing. Having this we can simplify the code a bit to basically this: 

What we do here is just divide the number in by 10 and print the values stored in (result - only if >0) and the - reminder. Printing the hints On fourth attempt you are putting the character to be printed in . It should be in . You don't also have to use different registers so just: 

Using those instead of bare -ing will make your code more readable. Having those it's clear what you try to do with this code High-level functions 

is defined twice. First as a string ( and the second time as a label. I would rename the first one to and use it in 

which is just . So let's call it like that and make sure a requirement that when calling it we have dx 

The actual string starts on index 2 and before that you have max string length, and bytes read. Also there's no at the end. You have to put it there. 

You could also add a new line to those strings so that, they are a bit separated from each other when printing like this: 

You have a bit of code duplication that could and should be removed to avoid mistakes. FASM supports macros that you can use to remove duplicated parts. One can define a macro: 

Without the actual model and some numbers (how long does it take to execute/ how much 'space' it takes?) might be hard to optimize, but what I can tell is that you call quite a lot in such short method. When you do call it you basically iterate over a source (is it DB source? in memory source? other?) and grab it to the memory of your process. Try reducing the number of calls - it will improve your performance. Take a look at this fragment: 

as in the will be the number of characters not the ascii representation of that number. If we could restrict ourselves to maximum 9 characters that would be easy. Just add 48(dec) to the and you get the value. Since your secret is limited to 21 characters we could go with a simple method for printing. 

Other things that might be good to fix You have the same loop for scanning the characters. Why not enclose it as another proc and just use in those two places? You can make assumption that for example will point to the buffer that has to be filled. Also in this scanning you could handle for example backspace character and delete the characters. 

and similarly in the second place. Also some checks for input length might be good to do. You should also comment more your code. I strongly believe the code should be self documented but not on such low level as asm :) So comment more. GIST 

You have a bit of code duplication that could be extracted and consolidated. But first with some error fixes (at least the code did not compile on my TASM). Compilation issues 

You are calling on a source basically retrieving the whole collection with all the properties and only later you are taking just the two fields. If you want to reduce time and space - try taking only what's needed from the underlying source, but also it greatly depends on the typo of source you are using underneath. Consider dropping the LINQ at all. LINQ is great and compact but it has it's 'dark side' in term of hidden allocations. Also think abount some old-hasioned ways like 'paging'? For the dropdown that might not be the best way - but maybe it is. If for most cases only the top 20 repair issues are accessed then here's your optimization - and for few cases user would need to load more items to the list - that might be ok. 

Compare Your compare method is kinda strange. You do not iterate at all and you don't use any opcodes that would do that for you. It works only when you have one-char secret. Not so cool :) I would write it like this 

I find this very difficult to read without any logical line breaks or function types given. I.e., you should leave a blank line between definitions for different functions, and every top-level definition should be given a type signature. 

Here we look up the index of a in , then use a utility function from in the event that wasn't present. Because lists are 0-indexed we have to add 1. And tying all of our simple single-purpose functions together, 

One small change we can make is adding another base case to to account for lists of length 1, which are by definition sorted. 

And there we have it. Regarding your question about whether 's pattern matching was exhaustive, the answer is that it is not exhaustive because the definition of contained no case which would match every possible pattern (ie ). It was however "safe" to use because of how was defined, and the case of the empty list was handled through pattern matching at the outer level. In general you shouldn't rely on tricky business like that, it can be difficult to notice when coming back to code you or someone else has written, and can blow up on you if you have to change the definition of the function. 

Appendix † An inefficient but important implementation. Note that performance is O(n²) (consider e.g., ). 

In you can use instead of . and look to be dead code. You recognized that columns are just rotated rows, but then still duplicate a bunch of code to check them instead of reusing the function. I.e., 

can be cleaned up by favoring pattern matching over guards. Whenever you see a wall of guards that depend only on , consider pattern matching instead. 

You could eliminate the duplication further by extracting the body of the function into another function parameterized over the shift value. Something like this. 

I do question the necessity of writing this particular function. Concatenating and should probably be taken care of separately to prepending a tuple to a list. E.g., 

Now the third bullet on my list should really be broken in two, one bullet point for the predicate, and another for searching the sequence with it. But that's alright of course, our personal design documents don't have to be perfect from the get-go to be useful. The predicate is of course the value, expressed as a function. 

Consider that is an algebraic data structure like any other in Haskell. Pattern matching is the most elegant solution, but you can use even more of it to be even more elegant! 

You have made some uncommon stylistic choices which are not to your benefit, and a few things aren't doing what I think you think they're doing. First, the stylistic elements. Your whitespace is excessive, there's no need to push everything that far to the right and out of line with the beginning of the RHS. I also would move the colon down to begin the next line, this is mostly a matter of personal style. The parentheses around are unnecessary and while harmless noise for the compiler will distract your human reader. My version would look like this. 

Your solution lacks the use of higher-order functions that are an essential part of Haskell style. Instead of writing explicitly recursive functions that plumb state around (like an impoverished for-loop) seek out, create, and use constructs that have semantic meaning to your problem. Starting from the small, the problem defines a growth cycle as a either doubling a tree's height, or increasing it by one. We can encode all of that information in Haskell. 

This is probably as far as I would take it having started out at your original version. There aren't any real further improvements that I can see, just matters of personal style. If I were to write this from scratch though I'd probably produce something that looked more like this. 

You can perform eta-reduction again to write as . is a bit of a kludge though, in that it muddies the waters between your pure code and the outside world. Keep your (de-)serialization functions apart from the rest of your program, it shouldn't matter to the core logic of your application whether you were passed a or a value or length encoded sequence of unit values (). 

Now, are and equivalent? That depends on whether checks to see if you've been passed a with equal length sides. If you compile with GHC will tell you about partial pattern matches in your functions as well, but if you forget to include a guard you're on your own. E.g., my version of will not compile if you don't include the case, your version will fail at runtime if you leave out . In the example of , the guard version will perform three comparisons on . The default definition of defines all of the comparators (, , &c) in terms of , so in the worst case you'll have to call three times to figure out which guard matches. In the case version compare is called only once and its result gets reused, potentially saving a lot of time if the implementation of were costly. And lastly, having a set style and preference leads to consistency, which is always a boon to readability. I did it, therefore I do it.