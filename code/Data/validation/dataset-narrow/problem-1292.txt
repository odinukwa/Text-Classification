I assume you've left out some code? Like that and extends MonoBehaviour? Are you expecting to be able to access inside your class because you'd instantiated it inside another class? If you want to access you need to attach that script to a game object by using . This returns the reference to that you'd want to use, and will have the reference properly set. However, if you're attaching as a script you may as well call inside of the method. Alternatively, if you're not making into a script to be attached, and you want to act on a , just pass the game object into the call. 

There's a little weirdness going on with this code. I don't use Android, so maybe I'm thinking this is something it's not. However I did notice that you're getting the position twice, in two different ways: First you get it like this at the start of your loop: 

Well, it's interesting and really bad code. I would not emulate this if that's your intention. All in all, this code is trying to randomly set the position of and randomly setting it's velocity . I assume this would be used for spawning asteroids or other enemies. The only relation it has to movement (as you mention in your title) is the velocities set. There's nothing here that updates position based on velocity or anything like that, so I wouldn't call it movement code. I'll go through the code line by line. 

If you always have constant acceleration, you can use this equation at any time to calculate the position and velocity. It should give accurate results if you're calculating from the beginning every time. You can introduce small amounts of error when adding subsequent calculations like you're doing with in your code example. However, many times errors are introduced when you have an acceleration that changes, like when dealing with gravity. The downsides of using constant acceleration is that it's typically not very interesting. You're very limited to how many things you can use it for. Typically people will use these equations in very small fixed time steps with changing acceleration to calculate the position and velocity of objects. 

Where is on the outside edge and is on the inside edge. This means our noise is more likely to be solid at the inside and non-solid at the outside. This is the factor we apply to the noise we get from . Here is a more visual representation of what the values are, as the names might be misleading to the actual values: 

Now a call to will work on either the client or the server. This is pretty useful in the case of the server being a player as well. They share RPCs and the server and client can communicate easily. 

The easiest way to do this is to find yourself a physics engine. Since you're essentially asking how to create a physics engine. The equations and parameters you'd need are those of a collision detection and response system. If it's just for a simple animation, you can fake it using techniques like Rotoscoping and Onion Skinning to create the animation from a video of a real object hitting a wall and falling. Or you can use something like Blender, which has a physics engine, to set up and create your animation. 

Yes, you can make fewer calls. You can give each voxel data containing it's face information. Then go through and set the face data of all the voxels. The simple solid or not situation produces 4 cases: 

No, no such measurement exists. While you may be able to come up with a metric for skill. You'll be hard pressed to come up with a metric for luck (unless it's controlled luck). However, the two metrics would likely be different enough that you're essentially taking the ratio of apples/oranges. Further, the metrics will vary from game to game, so comparing ratios between two games is comparing apples/oranges to GI Joes/cats. However, there are ways to decide if a game is a game of skill or a game of chance, at least from juridical point of view. Specifically, gambling in law. A number of states in the US allow people to pay money to enter games of skill, but not games of chance (or at least significantly limit the amount of money that can be spent on games of chance). There is a paper on the topic, but the All Games of Chance website has a decent definition of how these are legally categorized: 

Any structure can be raided/conquered by other races. The longer a structure (like a town or fortress) exists in history, the more defensible it is, the harder it is to take over. And the more desirable it is for races that want control. Battles are waged where races meet (at at least one is hostile). Battles are named after landmarks or nearby structures, or if the battle is significant or the landmarks are not named, the landmarks are named after the battle. Roads, bridges and tunnels are expanded through commerce and resource transport. Each has a maximum throughput that can increase with resource expenditure. Building a stone fortress in the middle of grasslands? Those roads are going to get heavy use transporting the required stone. They'll become larger and get a name. Natural disasters occur, affecting populations and the course of history. Earthquakes might reduce a town to ruins or collapse a tunnel. A flood might wash out a road or bridge. 

The position of the child is the relative position of the child plus the position of the parent. So the x position of the child would be something like: 

See the Box2D manual for more information (unfortunately, their manual is not really linkable to specific sections, so just search for "Friction is used to make objects slide along each other realistically"). Some things you'll want to think about when implementing a stopping force. 

All in all, this is something you'll need to research and find out the specifics of what you want to implement and what features you need to support with the technology at hand. Additionally, just because XNA is being discontinued, does not mean it's going to disappear. There's still plenty of life left and unless you're waiting on a feature that XNA doesn't currently have, you'll be able to complete your game using XNA. 

However, the width is applied over the entire line. This likely won't work very well for your simulation of a pencil line. You'd probably want to create two LineRenderers. One for most of the line, which has a consistent width from start to finish, and a second for the last segment of the line, which will have its width taper off to something small. 

Make it clear that you're not doing anything to suggest sponsorship or endorsement. You're just using the name of the game to identity those games. Also ensure you're not using their logos in your trailer. Use a plain text to display their names along with the text saying how users should compare your game to those ones. Look up how to properly use fair use of a trademark to ensure you're properly crediting the other games. This fair use is something you'll regularly see at grocery stores, when an "off brand" product is asking shoppers to compare their product to a well known brand: See the lower right text: 

Since you're checking for events each update, you'll be relying on the key repeat events to start your continuous movement. That means that an event will be generated when the key is first pressed, then the repeat events will be created after a short delay. So, try removing your check and the loop (that one is actually unnessary for how you're using the class right now). That will allow the checks to operate without the event being triggered (thus bypassing the delay). 

See the image above. It's clear that the grass in this screen shot are textured quads set perpendicular to the ground. Also, check out the creature center screen. You can see that it's shadow and feet look very much like a 2D sprite over a 2D landscape. EDIT to address your EDIT You can implement the feature as I said, with the textured quad. The texturing of your ground tile is not affected with this addition. You will texture your ground tile the same as before. The quad for grass is exactly the same as you would use for one of your characters, except it's position is locked to the grid it's on. 

The "direction" of expansion would only matter if you already had data contained in the buffer. If you have a buffered image already, then want to make a larger one, you'll need to copy the data into the new larger buffer. When you copy the data into the new buffer you simply place the existing data at the bottom right corner. Like this: 

I've found that the DirectX (.x) model format is pretty nice. It will export the mesh, armature, and animations. The animations can be exported as key frame or every frame. It's not actually the joints that are controlled but the bones. And of course bones are just a matrix transform with a list of vertices and weights. Don't let the name fool you, this of course can be used for DirectX or OpenGL. It's fairly simple to parse these files to get animation data. The exported files are all in plain text and are easy to follow. I found some example code for writing an importer here. And a pretty useful explanation of the format in general here, along with animation details at the bottom. 

I'm getting near the point where I'm going to be ready to release an alpha of my game. I'm curious as to how to implement a system where the game is un-launchable if a user name and password haven't been entered and verified. I plan on having an authentication server setup for verifying user credentials. I'm not concerned about making the game pirate proof, because that'll happen. I just want to make it more difficult for the casual user to share. What needs to be in place for such a system to work? My thoughts are to implement a system similar to this: The first time the user logs in, have the users computer generate unique value based on their system attributes (not the actual attributes, I'm not collecting that). Logging in to the server sends username/pass and unique value, the server then attributes that username with that unique value and those are checked when the user logs in. I don't plan on limiting the amount of computers a user can install on, but I want to be able to disallow obvious abuse of an account, i.e. it's being used on dozens of computers. Is this system reasonable for a free-time sole developer? Or what kind of system would make sense for my requirements? EDIT Let me elaborate a little on why I want to use the system unique ID. I think that having a key like that is what would enable me to have an offline mode. I guess I wouldn't need to send the key to the server. But once a user name and password have been authenticated by the server, I can instruct the game to generate that unique ID and pair it with the user name. Then when the user tries to launch the game in offline mode, I can check to see if that computer has been authenticated online before. This would disallow people copying a verified copy of the game to a different computer to use offline mode. 

Which means that something grey like will turn into something very grey . You may want to try inverting the hue instead. Convert your color to HSV mode and invert the hue . You could additionally invert the saturation. Ultimately, it sounds like you're the one choosing the original colors here. So just choose colors that invert nicely. Another option would be to check for colors that won't change much. Something like: 

If you put the prefab into a directory called inside your directory, you'll be able to use the class and its functionality. This will load a prefab up as a , which can then be instantiated. For example: 

Your bones should be laid out in some sort of tree data structure. With the root bone (generally the hip or base of the spine) being at the root of the tree. Start with the character position in 3D space. This is the starting point for all the bones, it's the root. Use this position as the offset for your first bone. The way the bones are set up, once you have the first position, you can calculate the start/end of every bone in the system. Once you have all the start and end positions of the bones in your system, you're ready to draw. I'm going to assume you're starting with straight lines for bones. Draw in whatever order you want, but you might as well parse the tree you already have set up. So start with the root bone, and draw it. This is as simple as drawing a line from start position to end position of the first bone. If you're not sure how to draw a line in your system of choice, I'd recommend taking a step back and deciding if you're ready for this project. Continue parsing the tree and drawing lines from the start position to the end position for each bone. You may want to pull this information out into some other data structure for quicker drawing, but that's outside the scope of this answer. I have to say though, from your responses so far, I think this project may be beyond your current skills. 

The physics raycast is a different system and doesn't see UI elements. So you can not cause the UI to block physics raycasts. However you have options: What you can do is cast two rays. One raycast for your UI elements and one for your physics objects. If your UI raycast detects a UI element, you know a UI element is in the way, and you shouldn't cast your physics ray cast. Or, you can use the event system (which is already casting a ray into the UI elements) to tell you if you're over a UI element: 

Get an idea for a game. Easy, who doesn't have a list of those somewhere? Choose your platform and language. You'll always see this question on this site. It's a big one for new developers. (But don't ask here because it's off topic! This is one challenge you need to overcome on your own) Write the first line of code for your game. As simple as it sounds, this is a fairly big one. I bet there's 100 people who have an idea for a game they want to make but never start for each 1 person who completes this first milestone. They get stuck during a tutorial or they get so caught up in thinking about how to do it, they never do it. Get something basic going. This could be as simple as getting a triangle to render on screen or using the keyboard to move a little sprite around. At this point you have a bare bones game. It starts, displays some graphics, responds to the player and then ends. A million smaller milestones These range from getting your art assets loading correctly, to fixing that damn bug, to reading and writing to disk, to that premature optimization that was bugging you just too much to leave it. Getting past this collection of milestones is a pretty big milestone. Plenty of people will give up at this point or start working on something else and never come back. The majority of the milestones in this milestone involve code change->play->repeat. It's important to play test often! A playable prototype. This should represent your finished product fairly well. Now things are starting to come together. You're 90% there right? A million million smaller milestones. Oh the grind. You're deep in your second 90% with lots of little changes, fixes, re-optimizing your premature optimizations, brain meltdowns and code re-factoring. This is a major stopping point as well. This part is deceptively difficult. Broad strokes are easy in comparison to the fine art of polish. A complete game. Now you have 3 grey hairs and a finished product to show for it. Congratulations! Now you just have to publish, promote and maintain. 

Since you just uploaded it today, you won't see the number of installs yet. See the documentation where it says the statistics are updated on a daily basis. The statistics are not "live". You'll only be able to see how many people downloaded on a given day after the day is over. This is similar to Google Analytics. So be patient and check back later. Congrats on publishing a game. 

To sum up the comments: Use the following strategy for the arrival behavior. This paper has more information. 

EDIT This could be because of the way you're indexing into the map. Note orientation for your map as defined in code is not the way it will display on screen. You're indexing into it like this: