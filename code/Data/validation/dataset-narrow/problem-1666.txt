simulate this circuit – Schematic created using CircuitLab (So Mic1-Mic4 are audio microphones, Mic5-Mic8 are contact microphones.) Now - there's no audio input on the Pi, so you need to add this, and this setup uses quite a lot of microphones, so you'll need plenty of peripherals. There are many to choose from, I'll just give some examples: 

Once this script is placed in /etc/init.d it will start the minecraft server automatically when the system is ready, and shut the server down when the system goes down. You can interact with the server by running 

You shouldn't. Even if you can get a cross-compiler-chain up and running under VS, you would still need the graphics libraries for GTK or qt or whatever you decide, and getting that to connect smoothly in VS would be a hassle. Then you need to transfer it all to your pi to run it anyway, or else emulate in a virtual machine of some sort. Better just to do the development on the pi - it is capable of that. Have a look at qt 

Ok, as it turns out, the file you tried to print was called and placed in the same folder as the python program, but the filename provided to printFile was . The preceding slash tells the system to look for the file in the root folder, where it could not be found - hence, the cups framework could not access the file, and you got the error (). What you need to do to fix this is probably just to remove the slash in the beginning of the file name, and you should be fine. If that does not work, then give the full path to the file that you can get (when standing in the directory) with 

No, sadly, this is not easily achievable without extra hardware. What you can do is connect to the Pi via network and either from your laptop or from your tablet, but that requires the Pi to be properly set up. 

No! Noone knows how to make or maintain a secure Web server. All Web servers are targets and can be broken into. Security is a process, not a state. A server needs to be constantly updated and monitored to stay reasonably secure, but even the most professional servers are occasionally broken. If you want to play with a Web server, start with not exposing it to the Internet. You can still use it locally, from within your lan. If you want to expose it, make sure it is on a separate vlan, and that there is nothing sensitive on it. Make sure you update and upgrade your software often and regularly, and keep an eye on the logs to make sure noone tampers with it. 

If I where you, I would connect an iPhone to a recording device (with a 3.5 mm cable) and record the signals the app send to the device. Then it would be a simple matter of transferring the signals to the pi and play them there. 

You can't unmount the root filesystem on a running machine. The reason your terminal dies is that bash is your shell. 

The pre-built Ubuntu packages will not work, so you will probably have to build it from source. That means setting up a developer stack on your Pi, installing and and . From there, you will need to get , that in turn, from what I can read, will download the Lantern sources. Then you should be able to use this guide to build and run lantern. Note that I haven't tried. ;) 

These represent runlevels, and are filled with carefully named soft links to scripts in in directory that are executed in order in different stages of the startup and shutdown processes. The directory is filled with scripts starting and stopping different services, and one of the scripts you will find there is the service script. When you execute a command like , the script in is executed with the argument. What you want to do is to start the pptpd service at runlevel 2. That means you create a soft link in the -directory named that points to the script, like so: 

Using Raspberry Pis to power the screens is probably a relatively affordable solution, and reasonably reliable. If it's the best solution, I dare not say. If you are using animations, you should probably save them as movies and play them with , or . It is definitely possible to make them play content automatically on startup, but it will require some tinkering. Probably then easier to just let them run. 

It doesn't stop working. The script will save the files into a folder named after what time it started. See line 67: 

This means the command is not found. is the Gnu Compiler Collection and it is (a bit simplified) used by make to compile the source code into binaries that the system can run. Depending on what host system you are compiling this on, there are different ways to install . Consult documentation for your operating system. There is a post concerning this on the FreeRTOS support forum. 

pmount is a richer alternative to usbmount. It has knowledge about some desktop environments and is able to show an icon and so forth. Also have a look on the package hal. It is a feature rich hardware manipulation suite, that can do automounting among other things. 

The easiest way is probably to make the wire-water circuit emulate a switch, with current limiting resistors. Have a look at this diagram. (Found here) If you just hang the ground wire and the pin wire, the pin will detect when the circuit is closed by the water. I doubt you will need the transistor, but you will have to test. As for the code, you will have to define a pin as IN, and then read that continuously. Have a look at the source of the image above for some examples. 

This way, you will have two "separate" feedback loops: tilting front/back will only affect the power distribution of the motors 1 & 4, and tilting left/right will only affect the power distribution between motors 2 & 3. The easiest way to do this, of course, is to turn your sensor 90°. If that is not possible, you'll have to do some vector transformation before you feed the data into your loop. A common way to solve this is with a PID controller - where P stands for proportional, I for integrating and D for differentiating. There are several ways of implementing PID controllers programmatically. It's not that hard, and there seems to be several python implementations available. Good luck! 

For some reason X doesn't seem to start automatically. If this happens, try typing to start the graphical user environment. 

You have switched to an Indic keyboard, though it's hard to know which one. They look quite different depending on which one was selected. There are some examples here: $URL$ You basically have two choices: use another machine to into you pi and fix it, or reflash your pi and start over. 

I have seen some setups using bluetooth for similar use cases, but it will probably involve some hacking. The phones you want to detect are typically not in discoverable mode. If the phones use wifi, you can probably detect some proximity, but this will also probably mean you will have to scan for them at a rather low layer, since they will not access your wifi antenna, and they will probably connect encrypted. Have a look at kismet for some low level wireless bonanza. The easiest way to detect whether someone is in a room or not, though, I would guess, would be to use the camera module and a panaramic mirror. 

If you connect your rpi via wifi to internet, through some kind of wireless router, that router will most probably both assign the same internal IP to the rpi every time, and even let you access it through the name you have given it. You can definitely use ssh to connect from your laptop to you pi and at the same time use wifi to connect your pi to the internet. If you plan to use wifi, there is no need for a cable. 

You need to close the stream. The object you named is a , that in turn is-a . It should be closed to ensure proper release and clean-up. You need a condition in your loop, and when that turns to false, you need to do a graceful exit involving 

You can't. Not without additional hardware. There is no "off"-switch on the pi - when it's plugged in, it is powered. You can put it in a runlevel that makes it disappear from the net, and you can reboot it. The reason your php-script doesn't work, however, is probably that the user it is executing as does not have the rights to run the -command. This should show up in the -file. 

The network you try to connect to does not support or allow you to use DHCP. Try another network or enable DHCP on the network you test with. 

Yes, the script is still running som the session you had - no, it does not stop when you open a new connection. You can't really access that session from another one, but you can manipulate what it's doing - try . If you run the script in the new session you will start a new instance of the script - exactly what will happen in this case is hard to tell. Try it. What you want might be to create a service - that is one instance of a script that runs and can be started or stopped from different places. Have a look at $URL$ 

If you want your script to run once at boot, then is the wrong solution. You want to research the manual page of , and of in section 5. lets you install a rules table for the -deamon. In section 5 you can read about how to create such a table. Run 

If it is sluggish it's probably not due to a corrupt SD-card. Rather, I would guess that you have installed something that uses a lot of resources. Check with . 

You could compile a smaller kernel with less functionality. A small monolitic kernel is faster to boot. 

This depends on what you want to do. It seems that the java program does not get access to a running X11 server. Do you run X11 on your pi? If so, then physically connecting keyboard, mouse and screen to it would probably solve your problem. If you want the program running on the pi to use the X11-server of the machine you are running ssh from, then simply add the option to your command, like so: 

I don't really understand what you try to achieve, but I will try to answer in a way that is meaningful. There are two ways that I can understand the question, and both of them means you are probably overcomplicating things. The PL-2303 is a USB-to-Serial adapter. If you want to use the pi's USB connection to drive UART, then you can do it cheaper and simpler by using the GPIO for UART directly. You wouldn't need the PL-2303. If you want to use the pi's GPIO for UART, and use the PL-2303 to convert it to USB, then you are better of using the pi's USB connection in the first place. I have a hard time seeing the use of a PL-2303 in connection to a raspberry pi. 

It will not run on boot and will not run until someone starts a shell It will run every time someone starts a new shell 

What you really want, probably, is to create a minecraft service in init.d . I found one at gamepedia that I have modified slightly into this (still needs work, though): 

While it is certainly possible to create a hardware button to do this, it does seem a bit overkill. Easier would be to just let the Pi connect to networks it knows, and if no such network is found, it can switch to AP mode. Once an SSID and a password is entered, the Pi can turn off AP mode, try to connect, and cycle back to AP mode again if the connection still fails.