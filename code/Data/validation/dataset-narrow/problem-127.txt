Nothing on the switch prevents C from answering a request from A. However, in this example, A will never send a request to C. If A has traffic for C, A will use it's own IP address and mask to determine if C is on the local network or not. In this case it is not, so A will then look to it's routing table to determine where to forward this traffic (on most computers this will typically be the default route or gateway). Let's extend this example a bit and say that B is misconfigured with a /22 mask (smallest network to include both 192.168.1.0/24 and 192.168.2.0/24) instead of the /24 it should have. If B had traffic for C, it would determine that C is on the local network and B would ARP for C. When C receives this ARP request, it should not respond as it would determine that B is not on the local network. 

Edit based on comments: if you want to rule out the source port being incorrect, you can use the following with the above ACL to block all traffic from that MAC going out the second SFP port: 

This will drop any traffic with this MAC rather than forward it on and since it should be done in hardware (barring any features/problems that cause MAC lookups to be done in software), it shouldn't have a negative impact on performance. 

Without knowing the switch model or code version, and based on the routing table output you provided, it is most likely that your switch is operating in L3 mode (i.e. has enabled in the configuration). The command is only used by L2 switches and is entirely ignored by a switch in L3 mode. If you want to use the command and run the switch in L2 mode, you need to configure . On a switch in L3 mode, you need to create a static route in the configuration such as which is inserted into the routing table. Based on your routing table, you already have a static route configured. You may also need to remove this with a command. 

Let me preface this by saying that I have not used Fortigate, but speaking generally. You should have two links from each firewall (FW ), one to each switch (SW), just as you have a link from each FW to each server (SRV). This is what I suspect is happening. Assuming SW1 is the HSRP active interface, it initially receives traffic from SRV2 on the link to SW2 and creates an entry in the MAC and ARP tables. When the link between SW2 and FW2 goes down, SW2 removes the entries for that interface from it's tables, but SW1 doesn't know the link is down and maintains it's entries. When traffic comes in to SW1 for SRV2, it looks up the ARP/MAC information and sends the traffic to SW2. SW2 doesn't have an entry for SRV2 anymore, and floods it out all ports except the one it received the traffic on (normal switch operations). This results in the traffic never reaching SRV2 as none of the other links on SW2 provide a path to SRV2. With the second link the traffic between FWs and SWs, the flooded traffic would then be received at FW1 and be able to get to SRV2. If you have outbound traffic from SRV2 after the link goes down, or you clear the MAC entries on SW1, I suspect that this would work as well. 

You could look into a technology similar to either Xirrus (access point arrays) or Ruckus (antenna arrays). Both provide a means to listen in a "omnidirectional" sense, but transmit in a more directional means. 

No. Beacon frames are essential to the operation of 802.11 networks, but they are not very complex and they must continue to provide backwards compatibility with older devices. As such, any changes to beacon frames are generally relatively minor and simple, making it a change that is both early in the process and agreed upon quickly. I am not aware of any 802.11ac product (draft or standard) that utilizes a beacon frame that can be differentiated. Differences between drafts and final versions of the standards typically center around technical aspects (often of new features) and areas of contention. In many cases, the differences will be only in optionally supported features. 

Notice that while some of the commands are the same (or similar), many of the global configuration mode commands you might expect are not present, such as , or . This last would be present in interface configuration mode, but there is no CDP on the console so it is not present. 

Since you don't mention platform or code version, generally speaking, when a host moves from P1 to P2, the host will still process DHCP and the DHCP snooping binding table will update to reflect P2. So even if a particular implementation does check use the port there should be no problem. What I can't answer though is if you go a step further and add a dumb switch between the host and the managed switch running DHCP snooping/DAI. If you move the connection from the dumb switch to the managed switch, this often won't trigger the host to process DHCP again (i.e. the host's network connection didn't go down/up). Haven't tried this personally so not sure what would happen, but my guess would be that the switch may update the port on the DHCP snooping binding table when it updates the MAC address table. If I get a chance to test this at some point with my Cisco gear I will come back to edit this. 

Let me start by saying proxy ARP is at best a sloppy solution. They only time I found it useful as a feature is when I was dealing with devices on the network that could not utilize classless netmasks or couldn't set a default route. Yes, it can "cover" many client configuration or bad design problems, but it doesn't fix those problems. It also doesn't "cover" all of them and it can make troubleshooting issues more difficult. Getting back to your question, the most likely reason this isn't working is that your client's aren't ARPing. My guess is that you have given them what is often considered a "standard" network mask of /24. In your example, there is likely no solution to get proxy ARP to work as clients should not accept a network mask less than /8 so your client will never think the destination is on the local network and send out an ARP request. Why? A client uses it's IP address and network mask to determine if a destination is on the local network or not. If it is on the local network, the client checks it's ARP table for any entries for the destination and if one doesn't exist, will send out an ARP request to get this information. This is where the router with proxy ARP enabled can respond, but if there is no ARP request then the router cannot provide a proxy ARP response. If the destination is not on the local network, then the client will check it's routing table to see where to forward the traffic. This is typically your default gateway. Now, with the IP addresses you used, when the client checked the destination against it's IP/mask, it would find the destination is not on the local network. Going to the routing table, it won't have a specific entry for the destination network (clients won't by default) and no default route/gateway. It will then fail with a "no route to host" type of message. 

The short answer is no, it does not. The 802.11 standard and it's amendments are developed and maintained by the IEEE. 802.11ac is "Very High Throughput" standard amendment. Wi-Fi Direct is a standard developed by the Wi-Fi Alliance for which they also provide certification. This organization was originally formed to test and certify devices as adhering to certain aspects of the IEEE standards. This was done to provide a level of assurance to consumers that devices would be able to interoperate. It is a voluntary certification process and they can test and provide certification for a number of aspects of wireless. So the longer answer is that Wi-Fi Direct is not a standard created or maintained by the IEEE and as such there are no current plans to incorporate it into any IEEE standard officially. If it were to be included in the future, it would become the basis for an amendment and go through the normal process any amendment goes through to get approved by the IEEE. 

Use crossover cables to make connections Cross the infrastucture cabling Manufacture a cross into one of the two endpoints 

Of these, I have experience with all except Xirris within the last 3-5 years (at least 802.11n) and all have their benefits/problems. In most enterprise environments, I would only look at the top four options, the other three being more niche or small/medium deployments. Hands down, Cisco and Aruba are the top players providing the best and most stable product with the widest feature sets and flexibility. If you don't want to consider too many vendors, stick to those two and you should be all right. 

If that doesn't work, then the MAC address has to be incorrect and you need to provide more information. The ACL will work no matter if the MAC address table is updated dynamically or if you add a static entry. However, if the dynamic entry for this MAC is flapping between different ports, that could explain why the ACL didn't work as intended. Additionally, without additional features configured, the static entry will not have an effect on traffic arriving on a port, only on the destination port used for the traffic. And finally, the packet being highlighted in red by Wireshark doesn't tell me much. Different versions of Wireshark have used different coloring rules, the default rules typically include a number of matches that get colored red, and many of us use our own custom rules. You would need to provide more detail or the actual capture for us to know what exactly that means. 

DTP allows two switches to dynamically negotiate establishing a trunk link between the two. VTP allows two switches to share VLAN information (or the VLAN database) across a trunk link. 

With most repeaters, there is no roaming or renegotiation. The client device will either see the frame from the original AP, the repeated frame from the repeater, or possibly both. 

There seems to be some confusion about this topic for you. Let's begin by clearing up a few details. 

For complicated tasks, I suggest looking at TCL. You can use TCL to create scripts that can be stored and run on your IOS/Nexus devices providing an amazing amount of flexibility in collecting and displaying data. While it isn't necessarily faster for simple tasks, you can collect and correlate information from multiple commands and reformat it as you like. It can also pull information from SNMP. If you haven't looked into it, you can find one such document here. Edit: I didn't add this, but probably should have. Once you have your TCL script in place, you can use the alias command from Stefan's great answer to create a faster access to the script. For example: 

IP source guard prevents IP traffic that doesn't match the DHCP snooping binding table (or static entries). So if the traffic has no IP headers, it won't prevent any of the traffic. Port security works by matching the MAC address to restrict access. If the MAC address matches, then the traffic will be allowed. ARP is sent at L2 (no IP headers), so a host (compromised or not) with a MAC address that allows it to match port security could still perform attacks on ARP (i.e. ARP spoofing, poisoning, etc). DAI provides protection in this gap. 

When using the Sup II+10GE in redundant mode, you only have the first half of the ports on each supervisor. You can find that in the documentation from Cisco: 

Do not try to compare networking to computer hardware. While in some cases this could help, it is comparing apples to oranges and clearly in this case it is causing some confusion. I think it may be best to just give a simple example to show how they are used differently. Let's say your computer (192.168.10.1) wants to talk to a host (10.1.1.10). In this case, 10.1.1.10 is the logical destination or address you are attempting to send traffic. Your computer however has no idea about the MAC or physical address of this server, nor does it know how to get to the logical address. However it does have a default gateway and knows 10.1.1.10 is not on the local subnet. So it sends the traffic to the gateway router with the logical destination of 10.1.1.10 and the physical destination of the gateway router's interface. This router, will see that the logical address of the traffic is bound for another host, and will look up where it needs to send this traffic which indicates router2 is the next hop. It then changes the physical destination to router2's interface and forwards the traffic. Router2 is directly connected to the server using IP address 10.1.1.10, so it changes the physical destination to the MAC address of the server and again forwards the traffic. There can be number of additional routers on the path, but all through the process the logical destination address stays the same while the physical destination changes. This is also true for source logical/physical addresses along the route.