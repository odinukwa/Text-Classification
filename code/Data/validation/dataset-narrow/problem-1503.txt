Of course, after evaluating one lab, you can always evaluate other labs, and rather than answering the questions above in a binary, yes/no, fashion, you can answer them on a scale of effectiveness in meeting those criteria. If the labs presented by the College Board meet the needs of_your_ students, and the objectives of your course, then they are a good choice, regardless of the reviews from publishers, who may have their own labs to sell, or even instructors in other schools, who may have other objectives, and surely have different student bodies to work with. 

Rather than trying to motivate the students, or the reluctant ones, to progress into using your new tool ( after ), and finding a new motivating example every time, try to motivate them to be self-interested, lazy coders. Now that I'm under the tar and feathers, I'll explain. People like to find the easiest way, not the best way. Earlier postings reveal that you're in the teen-age world with your students, and they are no exception, if not the rule, to that thinking. Knowing that your students will have that natural preference for easy, use it as the motivation. "Quality is job one" makes a good slogan for a company, but isn't so good for motivation of students. Borrowing from the world of sales, show the problem first, and the solution second. To progress from a bounded towards a , as an example, use the bounded version in a manner already natural to them that is possible, but problematic, against a collection that can be -ed. Legitimately work out the checks and error traps and actually make it work. Once they've experience doing it that way, then you can present the "package" where someone did all that work, and more, when they created the . All the traps, special conditions, etc., are handled, and all the work has been done, and debugged, for them. The same approach can be used to step-up to any progression you choose. Under the hood in any chosen language the new tool might not be implemented using the old one. At least not now. Still, that's how they came to be created in the first place - refinement on a common problem and its solution creates the shiny new practice which becomes a tool. That's how we got structured programming to begin with. The key is that the new concept is not presented as better programming, better presentation, or even easier to maintain, update, or fix later. Rather it's presented as a real solution, to a real problem, right now that makes less work right now for them. Less time on coding, now, means more time, now, to be with their friends, or do other fun stuff. After a couple rounds of that, once the light bulb goes on, they'll start actively looking for pre-baked solutions, and libraries will be their next target. That outlook will carry them well into the future, and could even encourage them to look at new languages, either new to them, or new to the world, for an easy solution to a problem. Hence, they become self-interested, lazy coders. 

A good method will involve all three modes, in combination with each other. The mode will depend on the objective of the demo and the size of the code. If the students are not touch typists, there's going to be some, possibly hard to spot, errors, and entering a 50 line code segment will take a significant portion of the available time. For small, basic sections of code, having a type-along can work. Especially if you're inserting segments, and changing parts, as the design evolves. You won't want to have them constantly typing the same basic parts every time you do a type-along session, however. In some cases, you might want to do a larger demo of the small code. First is them watching you do the work, as you demonstrate some concept. Second, you do a type-along demo, where they help demonstrate the concept just learned from the solo demo, as the class writes a second piece collectively. Lastly, as lab, they apply the concept to a third code, following a problem statement you give them, but they develop the solution themselves with minimal guidance from you. For moderate sized code, have the skeleton pre-typed, and available for download before the lecture, then work through the section that is the target of the class session. Concepts that have already been mastered need not be retyped each session. When you get to the point where you are re-factoring code, or combining previous sections with new content, you can have that available for download as well, but do the demo without them typing. While doing the demo, you should also limit your typing. Have what you want to type ready, and to a copy/paste of the proper blocks. They presumably will be familiar with the concepts in the smaller sections, and the the objective is combining them to create a larger concept. The last version is to distribute completed code for them to analyze, except that it's not fully working code - it's broken. The task is to find the error using the clues the compiler/interpreter gives. Of course, that means trying to design broken code that fails the way you want it to. 

You can't teach the value of the command line. You can, however, sell it. Students have at least one of two primary goals in any class: 

This is also a case where the recursive solution is faster, significantly, than the iterative solution. Running a series of time trials, with the output comment out and disk count set to 25 (33,554,431 moves), the iterative solution averaged 1m22.4s and the recursive solution averaged 0m28.4s. Granted, my code is in Perl, and most of your classes are in Java, C++, or a functional language, so it would have to be converted for use in your languages. I took advantage of a few of the patterns inherent in the puzzle solution, and stated the "tricks" used in the comments. I did not, however, try for serious optimization or other forms of code cleaning. In spite of that, this is the final version of a tested, and timed, version of the Hanoi puzzle using an iterative approach: 

Notice that everything is there, but it doesn't help you figure out how to change a flat tire. What's really needed is instructions not names. Compare the following. Not in any programming language. Just a list of instructions. In this case the instructions are executed by a person, not a computer. Still, the instructions enable one to change a tire, while the images that have markup on them don't help any on their own. 

Neither is better. What is true for one student may not be for another. Studies can show trends. Students are not trends; they are individuals. As an example I encountered today that seems to go against that wisdom, I caught a news piece about a local girl in the Scripps National Spelling Bee. As she spelled the word she was moving her fingers in a weird fashion. Half-way through the word I recognized what she was doing. She was "typing" the word as she spelled it. She was able to remember how to spell the word by remembering how she would type it. I have personally attended classes with someone who "doodled" their notes. She drew random-looking doodles, not pictures or pictographs, as the instructor presented. Later she was able to translate her doodles better than I could translate my long-hand notes. She also scored better on the fact-based questions than most of the class. There is one major drawback to laptop note taking in class, however: noise. Few keyboards are truly silent, and the key noise, even if it's just the sound of fingernails hitting the plastic, can be very distracting to other students. If you're willing to allow it, and school policy does not prohibit it, a third option is audio recording. I've only been in one classroom where computers were allowed to be on, and it was distracting. I've never allowed them to be used when I lecture, or even during study time unless it's also lab time. What seems to work best for situations involving lots of data, especially where layout and syntax can be significant, is to provide the lecture material in some manner after the lecture has been delivered. That could be done via Google Drive, or some other online source. Online access allows the student to retrieve it when they need it without having to access it immediately after the lecture. It also helps for the disadvantaged students that may not have laptops to bring to school. They can access it from the library, or any other source of online access. 

It seems that the presentation of the material is done well. Given that the problems assigned from the textbook are in a sequence that increases with complexity, there isn't much you can change. A possibility is to assign one problem at a time, going over the results of it before moving to the next one. That way, maybe, you can find out where the ones without traction are skidding out of control. As you have said, they intuitively know how separating things makes sense already. If not included in the lecture, you could explain the trade-offs between doing the normalization (the design work), and storage space for the extra tables vs. the potential savings in coding and possible duplication of data. To emphasize that point you might have some examples of code (or pseudo code) to handle both a normalized and non-normalized version of the same dataset and the storage requirements for a sample dataset at each level of normalization. Take what they know "intuitively" and make it explicit. 

Syntactically, the loop is guaranteed to execute at least once and the loop may not execute ever. Many languages which do not have an control statement still provide for testing before or after execution of the loop. In the case or RobotC, the language of this question, the syntax is like this: 

Lastly, to get things rolling, you could offer to do a session or two in another class to teach their students extra features of the Office software that they use, if any, with the students. Lab science classes probably need at least Excel for processing and presenting measurement data from experiments. 

The answer here, as it seems to be so often, is "it depends." The courses you've compared are comparing apples to oranges. Which are you trying to make, apple juice, or orange juice? You have to select to version implementation or application, which best moves the lessons, and the students, toward the objectives and goals set for the course. The Apples 

Students have a particular mindset for taking tests, or other evaluations, that contributes to the problem. Students are driven to maximize their time, and the potential for high marks. They will do anything they can to find the answer in the shortest possible time-span. Once they have a possible solution, they will test it just enough to see if it is probably the answer, do whatever is required to demonstrate that answer, and move to the next question. You can attempt to precondition the students to be thinking in the right mindset to "see" what you want them to see by ordering questions in a fashion that leads the student to the proper mindset. There is no certainty that such a tactic will succeed, however. Many students, especially in the higher levels of education have a test taking skill where the test is scanned first, then questions are answered. Shorter and/or easier questions are answered first, longer questions latter, and the hardest ones last. In that style of test taking the preconditioning questions can be somewhat removed in time from the final target and may have lost their "conditioning" value. Asking observational questions in tests, or quizzes, will result in answers showing what the student focused on the fastest that might answer the question. The answers are not even a true measure of how the student thinks, or how they would evaluate the same information in a non-test environment. The more obvious clues you can give about the expected answer the greater the odds are that answers will fall closer to your expectations. Yet, even that is of limited value in most programming contexts. Even with the clue of "design problem" the students, as seen in your case, are going to branch off into several directions, only one of which is going to be how the given code is connected to the greater whole. As seen by the answers you did receive, other possible branches are the "design" of the code inside the class, and even error checking, which is often considered a "design" issue. Unless a code segment has a compile-time error, or other syntactical error, a blanket statement of "find the bug" will lead to a range of answers, most of which are technically correct while not being what you had in mind. If it is a syntax issue, or an error which will cause a compile-time error, the question should still be explicit in that a syntax error, or compiler error is expected and you want the cause, or the correction to avoid it. Without that qualifier it is still often possible to find a "problem" with the code that is other than what you were expecting.