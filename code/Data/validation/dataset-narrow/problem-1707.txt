What you're looking for is probably called a medium-range wireless modem. This is a radio link between two data devices. Unfortunately the hilly environment might be the worst for radio because the hills will block some radio signals. Each region of the world has their own rules and regulations about radio. Some of the modems I've seen need to be licensed, some don't. 

SSI is a protocol that uses the RS422 transmission standard. The easiest way to read this is by using an RS422 Line driver IC. This one is available from Digikey. A differential signal is a way of reducing noise on the line by transmitting a logical high and a logical low simultaneously on a twisted cable. In the case of SSI it is two twisted cables because one has the signal and the other the clock. You need to do two things to interpret the SSI signal. First, you need to shift the voltage and recover the data from the differential signal. Then you need to real the signal. It might be possible that it could be read as an SPI signal. 

The GPIO pins of Pi aren't built to take 5v. You could use a voltage divider (two resisters which will divide the voltage so that you have 3v3 to deal with). This is a simple solution, but has some problems also. For instance, a simple voltage divider won't protect the gpio pin from voltage spikes from your power supply. In my opinion, a slightly better solution would be to use an lDO (low dropout) voltage regulator. A quick search turned up the Microchip MIC5365-3.3YC5-TR which is only about $0.15 at a single-quantity price. You could not power a Pi off of this chip because it only runs about 150 mA. You'd still want to put a series resister along with it to keep the current down. I assume that you'll also have enough battery power in your UPS to keep the Pi awake long enough to shutdown properly. As for your other questions, simple research, both here, and at raspberrypi.org will answer them. I believe that any unused GPIO pin can be used for your project. 

The Pi is a 3.3v device, not a 5v device. You'll have to take that into account when you are using the GPIO pins. 

Rather than use "Magic" numbers, I would have defined the constants so that I would be able to understand the code when I looked at it again a month from now. Rather than averaging four samples, I would use (if I'm remembering correctly, I don't have my code here) a low-pass filter to remove most of the noise. Another possible choice is a Kalman filter which is good for estimating the correct value but is more computationally expensive. Happy programming! 

I don't know what the shipping would be, but it may be available from a local seller. It's also small enough that the shipping might be inexpensive. The Powerboost 1000 charger from AdaFruit. It isn't specifically made for the Raspberry Pi,but it will work. You have to supply your own 3.7 volt LiPo battery and a normal 5v charger. it works just like a phone. One thing: the battery is not optional. 

You wrote that you're not using an external power supply for the motor? This motor probably requires a separate supply. I could not find the stall current for the motor, but under load the motor will probably drop the power enough that the Raspberry Pi no longer functions. However, that isn't the worst problem. Motors are very noisy, electrically speaking. This means that they put voltage spikes into power wires. And when you stop a motor, while it's stopping, the motor turns into a generator and will put power back into the system. You will need capacitors to deal with the voltage spikes and a clamping diode to deal with the reverse current flow. You can put motors on the same power supply as the electronics, but you have to be very careful. I am very careful about my power supplies when I build robots. I usually use two different batteries, but that's my choice. Sometimes I will use a single power supply, and then I will take precautions. 

The APA102 LEDs are what Adafruit calls DotStar LEDs. They have a lot of information and libraries for them. The 5050 in the title of the question is misleading because that is just the physical size/form factor of the LED. There are 5050 LEDs available which are not individually addressable. 

This is labeled as a difficult project, so you have to know what you're doing. However, just from my experience and the labling of the board, the G is ground, and the B buttons go to the pins for each button. The software should set the internal resisters on. As for the two ground connectors, it is necessary to have a good connection to ground, and this allows you solder the same wire twice. Why would you think that "G" denoted a wireless connector? 

Since this is a device that needs precision, I would use a stepper motor, if a direct drive were absolutely required. In addition, I would have something that the Raspberry Pi could sense to know that the disk was in position. If the number of positions is constant, I think a very simple mechanical device known as The Geneva Drive would be better. It was originally designed for watches. Using a motor at a constant rate of rotation, this would bring a new hole under your collector at equal and periodic intervals. You could use just an inexpensive DC motor and controller (or a servo motor) to drive the disk. If your intervals are not strictly periodic, then you could stop the motor until the hole was ready to move again. In any case I would use a sensor to detect when the hole was in place so that the collector could fill the test-tube or whatever you have waiting for it. This same sensor could also allow the Raspberry Pi to stop the motor until the the collector is ready with a new faction. It would also be good to have some sort of sensor so that you don't overfill the containers. 

Controlling a DC motor takes more power than the GPIO pins of a Raspberry Pi can directly source. In other words, if you try to connect a GPIO pin of a Raspberry Pi directly to a motor you will burn out the Pi. You can control a DC motor in one direction with a transistor. Here is an example. This example uses an Arduino rather than a Raspberry Pi, but the electronics are the same. That is the easiest version of a motor controller. I tend to use prebuilt motor controller. Adafruit carries a couple Hats for the Pi. This one controls up to 4 DC motors or 2 stepper motors. This one controls up to 2 DC motors. If you need to control a larger motor, there is an excellent group of motor controllers at Servo City. I use the RoboClaw series of controllers for my robots. 

You talk about motors, and yet your code looks like it's controlling an RGBY LED. To have a robot stop when it hits an obstacle requires some sort of sensor to be triggered when the wall is hit. I generally use switches as such a sensor. If the robot is small, then a simple contact switch is fine. If the robot is larger then I use a piece of plastic (3d printed now) to spread the force so I can use two switches per side of the robot. I mount the plastic piece either on the switches, or so the switches will be triggered when a wall is hit. Since one switch is on each side of the plastic, I can use the information from which switch is hit or the order that the switch is hit in. Or you can wire the switches in parallel to be read with only a single pin. If the robot can do some damage if it hits a wall, or a dog, or a person, then you will want to have some other sensors that work at a longer distance, such as IR, sonar, or LIDAR. None are perfect, but it's best to slow a larger robot down before it hits the wall. At the time the robot stops, the communication with the server should be interrupted. If the communication is two-way, then the robot should inform the server that it has stopped due to contact with an obstacle. After this there are several possibilities to continue. The person running the client could maneuver the robot away from the wall. Somebody could manually walk over to the robot, pick it up, and press a button which will communicate to the server to resume. The robot could autonomously move itself away from the wall and signal the server. To actually advise on the code I'd need details on the languages and processors involved. For example, a Raspberry Pi could be programmed with multiple threads, whereas an Arduino has to be programmed with a single thread to simulate listening to multiple things at once (the communication and the sensor(s)). Once piece of advice I have is that contact sensors should be read by interrupt, and in a larger robot should turn the motors off by themselves (and require the main processor to turn the motors on itself). Large robots can be dangerous. I tend to cheat: I use a single-board computer (like a Raspberry Pi) and a microcontroller like an Arduino. 

Which log file? There are many. Most of the log files are in /var/log. However, there is a command called "dmesg" which allows you to read the kernel ring buffer (the kernel log). This will often tell you things that might have gone wrong with the boot sequence and is the most useful thing I've found to find out what is wrong. I often use it as "dmesg | tail" or "dmesg | more" 

Since the current Raspberry Pis have no analog inputs, I'm assuming that you are getting a 1 or 0, depending on the light level. This makes perfect sense. An LDR (Light Dependent Resister), or photocell for old fogies such as myself, acts like a resister that changes value depending on the amount of light shining on it. If you have a normal resister hooked up to 3.3v and ground (with another resister in series so that you don't waste too much power), sort of like: 3v3 -- resister -A- LDR -- ground Put a GPIO pin at A. With the proper resister (experimentation will work to get the right value) you will have the pin reading a logic one or zero depending on the light recieved by the LDR. You'll get more information with an ADC (Analog to Digital Converter), but sometimes you don't need to all that information. If you just need to know that if it is dark, than a simple logic circuit is cheaper and easier. 

The MyoWare Muscle Sensor is an analog device and the Raspberry Pi has not Analog to Digital Converter (ADC). You will need to read the sensor from a device with an ADC and transfer this to the Raspberry Pi. Adafruit has a number of ADCs, the first three that show up would be suitable. In addition, any number of microcontrollers or Arduinos (or similar controllers) that have built-in would do the same job as a dedicated ADC and still be able to communicate to the Raspberry Pi via I2C or SPI. I prefer the dedicated ADC devices because they tend to be faster and more precise. They are also smaller. There are also HAT's for the Raspberry Pi that contain ADC's, but I've never had the opportunity to use one. Happy Making! 

The Octopi distribution of Raspian Lite which is meant to be an easy way of setting up an Octoprint server for controlling 3d printers requires you to edit a couple of files in the boot partition. They provide explicit instructions on how to do this. Since the boot partition can be read and written by Windows, Linux, and Mac computers, it is easy to find a computer to do this. They do require that you use, on Windows, a programming editor that understands that "/n" is a newline. They list notepad++ as one of them. There are many free editors that can do this. I would have run a script first that would have fixed the file that Windows could have munged, but that's just my opinion. The files are octopi-network.txt and optionally creating an empty file called ssh or ssh.txt. The octopi-network.txt file has everything needed to setup a wireless network and creating one of the ssh files will activate ssh at startup. I do not think that requiring somebody to have an unlocked WiFi access point is reasonable. It is opening up a large security hole. I also would not give my network information to somebody who wasn't a personal friend. It would be much more reasonable to allow ethernet access. Almost all wireless routers have ethernet ports, and all technical companies have ethernet wired. If the Raspberry Pi is installed inside a device, it wouldn't be difficult to put an ethernet port on the outside of the device and run a short connector to the ethernet port of the pi. I did something like that for a robot I built once. 

If the times of the two Pi's are synchronized, put a small routine at the start of the script that starts them at a specific time. You could make this an option: python -t 14:25 adxl345test & You'd have to type in the same time on both Pi's, but at least they'd be fairly synchronized. If this were written in Java I could easily show you some example code that would do this, but my python skills are sadly out-of-date. 

Rate gyros are notorious for being noisy. The major problem I see in your code is that you are reading four high bytes into an array and then reading four low bytes into another array and only then combining them into their int_16 forms. I think that you should read the two bytes that form the value as a single read so that the value doesn't change in the middle of the read. There should be a function that reads a block of data from a number of successive registers on the i2c device into an array on the Arduino. The SparkFun MPU-9250-DMP Arduino Library uses a generic function to do this. It works because the bytes are in successive registers. Using the library above, you might need to read the data like 

First, do you have a fixed ip adress in your home (or where ever you host the Pi) for this server? If you do, then you talk to your ISP about putting your ip-name on their webservers. You also need to add the routing inside your home, but that's very router specific. If you don't have a fixed address, you'll need to pay to join a DDNS (Dynamic Domain Name Service) company that follow your ip-address changes and make sure that your name and address are linked. In either case, you'll need to set the hostname and domainname on the Pi so that everythig is consistent. You can do this through raspi-config which handles all the files. I know you need to modify /etc/hosts and /etc/hostname, but it's easier to do this with raspi-config. 

First of all, I'm surprised that your Raspberry Pi is still working. The SIM900 is a 5V device and the Raspberry Pi is a 3.3v device. You should be communicating with the SIM900 with a USB->serial cable that handles the voltage transition safely. Have you tried to sent commands to the SIM900 by a basic terminal emulator program? PuTTy is available for the RasPi as is lxTerminal. This will allow you to see the responses to your command. For example, if you type in "AX" and return, you should get an "OK" back. I'd also suggest that you link to the datasheet of the device that you are asking help on. I had to google it and it took me a while to find the important information. 

Have you read the datasheet on the AD7193? This will include enough information to tell you what data you need to send and receive. I will admit that datasheets are a pain to read at first, but it is a necessary skill to learn. At first, they seem to give too much information, but with practice you find most of the information useful. Raspberrypi.ord had an SPI tutorial. SPI is just another serial interface. You send data to the DAC, you receive data from the DAC. It looks complex when you read the datasheet, but it really isn't. 

I have two laptops, and one of them runs Ubuntu. This is easier to me than running virtualbox, but I'm lazy. A more affordable solution would be to purchase a used PC and put the Linux distribution of your choice. Debian and its offspring (like Ubuntu) would probably be the best because Raspian is also a Debian derivative. I agree with @bierschi that the gpio's would be difficult to emulate, but you could write a library to simulate the gpio's in software. Besides, it sounds like you're taking input from a camera and sending the output to a screen. You might have to put a wrapper on a library meant for a USB camera to act like the Raspberry Pi camera if you're using that. In fact, emulating a Raspberry Pi under Windows or Linux is such a neat idea that it has already been done! QEMU already does this! Disclaimer: I've never tried this for myself.