After rotating the object from the center by (B) degrees, the vector for the offset has been rotated as well. So the new corner position will be: 

Lets say we have a set of points where we know (same for and ). Now that 3d space is populated with monsters, players or what not. The points represent their location. We want to find the largest vacant 3d space. What would be an effective algorithm to find, let's say, the k largest disjoint empty boxes inside that space? I was thinking of using Voronoi Diagram and measuring the space near each seed (the points being the seeds) and looking for pairs of neighbors that have a large space. 

There is! You need to path find in a 3 dimensional space if the car is steering in a 2d space and use the third dimension as the cars angle. Then you could use A* or any other graph path finding algorithm and you"re good to go. The algos I go with are usually probabilistic roadmap or rapidly exploring random trees to generate the graph and A* to find a fast path. Obviously you need to adjust the "collision space" or passable area differently for each angle of the vehicle you are moving. I usually use a low res 3d bit (2d for the plain and 1d for the angle) array to represent the passable area and then randomize vertices in the 3d-space made from the slices of adjacent 2d slices, each representing one specific angle. Since this is not 100% perfectly accurate (only 99%) I usually add a 2-3 bits thick border around obstacles to make it obvious the vehicle is not colliding with anything. You need to know if there is a path between two vertices, for that you'll need to draw a trace line in that 3d space and check if it collides with 1 bits. This should be a question on it's own as there is a solution based on Bresenham's line algorithm. Again to clarify, obstacles are calculated against the center of the "truck" in your case while taking the angle and shape of the track into account. Meaning that if the track is 5 units long and 2 units wide, and the center is less then two and a half units away from an obstacle, that area may be impassable depending on the angle of the track in that slice. 

2D - We need to place sprites on the screen, this is often called "Blitting" which is basically copying 2d image data from a sprite frame to the screen. There are also more modern ways than "Blitting" that use hardware accelaration, basically placing the sprite as a texture on flat rectangular planar object and using the GPU to render it. 

k is a coefficient and x is the distance between the objects. F will determine the acceleration speed between object A(attractor) and object B(attracted). Edit: Like dreta mentioned, you could use (distance) to help calculate the new speed: 

Then you can use the const identifier to refer to the entity instead of the string itself. This could help reduce the amount of typos. The reasons why you want strings have already been provided by @Patrick Hughes. Like mentioned Hashes are fast and the memory access is unlikely to cause performance issues. There are ways to boost performance but using enums is not going to contribute to that and is against the purpose of ECS. 

That is because jumping is an impulse and gravity a force. Impulses happen in an infinitely small time frame. Forces act over time. 

Procedural generation works on the idea that you know what you want to create and how it is created but you leave out the details. Think of a set of sliders for color, size, roundness / sharpness, amplitude and such aspects. You don't want to define every aspect of the result by hand. You want to outline a general idea of what you'd like and won't like to see, color sets, surface smoothness, and such. This obviously defines the world in it's virginal state. You are saving hard drive and memory space because you aren't storing a lot of detail. You let the details get randomized with a predetermined seed which means, you don't know what will happen but it will happen again and again every time (like perlin noise from a seed), in fact, the creator says the worlds are created by noise that uses a seed to repeat the same results. It is all build on the notion that you have the functionality to build a planet using a set of values to define it's properties first and then you let the algorithm, randomly pick these values. The universe itself is built on the concept of randomly picking far enough but not too far spots to place planets. To store player modifications, you normally wouldn't want to store the entire mesh with the modifications applied to it (i.e. storing the result) as that would be space consuming, what you normally would do is store the actions the user took. Think Command Oriented Architecture. Then when someones else approaches that area, you need to "replay" these actions as you generate the mesh. This is where things get challenging. If the player has a lot of power to modify things in the world, it could require a lot of processing power to replay these actions. This is why I think something like digging tunnels (like it's done in Minecraft) would be very hard to accomplish if you don't store the results. It is entirely possible though. Also think of more complicated aspects, a player kills a bunch of animals. Now time passes by and the world changes because time affects it, would the players actions affect the world? In a sense probably no. Killing a hundred deer will probably not cut down on deer population (as we have come to expect from MMO) as the world will be restored to it's virginal state and be repopulated according to the seed of time and space. Unless of course, the server stores the hunting activity and takes it into account when respawning new creatures. A lot of interesting effects of player activity that don't relate to game mechanics and have to do more with simulation are lost if everything is generated on the spot. How does cutting down the herbavor population affect the carnivor population? How does it affect the plants in the area? But I digress. 

we being by randomly picking vertices on the graph (possibly a tree). We now pick random distinct vertices. We compute the Dijkstra distances of each such randomly picked vertex from the closest existing checkpoint. We then proceed to declare the winner as the one furthest away from any other existing checkpoint and add it to the set. We now pick a "bad" checkpoint to remove by looking for the checkpoint closest to another checkpoint (there is a pair) and then compare by closeness to the second closest checkpoint. We remove the "bad" checkpoint. We repeat step (2) twice. We go back to (4) until we have enough checkpoints. 

A sprites-sheet (often refers to a large image that) is supposed to contain the animation frames of a specific 2d character or projectile in a game. You can almost think of it as the model of a 2d-character. It stores all the various animations created for a specific character. 

I admittedly probably missed something or glossed over some subject but this covers most of what an Engine does for you. So what is left for you the developer? 

This is valuable knowledge, I used linear solvers often for work projects. ILP is basically a way to solve selection problems where you want to achieve a maximum or a minimum for some linear function. You can read more here, using Integer Linear Programming and Linear Programming is the same for the programmer only that Integer is far more complex for the computer which may result in long running times. Not in your case, It is very simple and should only takes less than milliseconds in the worst case. I guess you could read more here: $URL$ This explains it well: $URL$ It is basically a decision problem solver, how to make decisions that maximize the result you want. This assumes the function that judges the result is linear which in your specific current case it is. The function that judges the result in this case, sums up the blocks for all the T shapes you decided to darken. Mathematically, how to set the variables: in our current case Booleans(Did I darken T shape with index i or not) to the optimal values to maximize the result we want: darkening as many blocks as possible without darkening intersecting T shapes. As long as the result you want can be calculated with a linear function when you have all the variables set it will solve it. In our case, we check which T shapes we darkened and sum the blocks they cover. 

"I'm getting caught in collision detection and how to make a character jump and how to make a character walk up a slope or steps..." Why do you want to write it yourself? You could (if you want simple 2d graphics) use an existing framework for platformers and save a lot of time and energy. How to make characters walk up and down a slope or a stairway entirely depends on how you model this slope and or stairway in the code. :) It also depends on the kinds of physics you would like to involve, is the steep slope, slippery? I think these questions could all find answer, however it would be simpler to ask them one at a time and have some base code to start with. I will start by answering the question about collision detection. This is implemented in a lot of existing frameworks. If you are using a 2d-array to represent a tilemap, you can handle collision between the character and the wall this way: Assuming the character starts in a collision free area and her feet are positioned in (x,y), you check which tile that is: 

Which room indices it is connected to. How to describe itself in it's state. What entities are inside. It's own description's template needs "blanks" inthat get filled with useful information about the entities inside it. 

First thing first, creatures should not avoid the "edges of the screen" because that is part of the View and not the actual Game Model. Game Entities should interact with the Game Model and not the View. The view is only the way you present the game to your game's players eyes. Secondly, what you are asking of has little to do with Obstacle Avoidance steering behavior because these techniques were mostly designed to help finding a none-collision path through obstacles or avoiding moving obstacles (see this for more info). It also should have little to do with fleeing because that is conceptually useful in building distance from moving creatures. If something is trying to get away from the edges of the screen as much as possible, it may just stay in the center of the screen. How to avoid the edges of the screen If the game type is a brawler (beat'em up) or a platformer, you could make it so that if the distance from the camera is greater than on axis-x or , on axis-y, the creature will move towards the camera until it is close enough. Alternatively if there are obstacles, the creature could find a path to some spot close enough to the camera and stop once it is near enough. Normally a creature follows a path. Sometimes the path is generated with a path finding algorithm such as A*. Other times the path is picked in advance by the games' creators. If the path is picked in advance and the edges of the screen don't move, it could be selected so it doesn't move through obstacles or outside the edges of the screen. If the path is created by a path finding algorithm, the edges of the screen could be marked as an impassable obstacle and avoided. 

Randomize new control point Imaging new segment calculate new red point Draw Bezier from previously last red point to the new one Repeat 

Great! now the simple question appears: How do you programmatically tell in the human sense if and are on the same side of the trail and if and are on the same side or not? My intuition is that you Dijkstra the shortest path between them and if it goes through the trail an even number of times their on the same side. However that is not defined if you don't know what goes through the trail computes to. If thinking if it was 2d and we could project these trail edges on some flat surface this would be made trivial. My current solution is a lie. Each edge is normally shared by two faces unless it's an orbifold which is currently not interesting to this question's input population set. Also, in our world, each face has percisely three vertices.