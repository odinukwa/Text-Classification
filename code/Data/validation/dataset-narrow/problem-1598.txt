This is really a routing question. Your RPi has routes to any it network is directly connected to. So long as that "network with 2 Pi zero's" is directly connected, you will be able to access them with no problem. The same applies to any other devices on the same network as your Internet router. To connect to the Internet or any other network which your RPi is not connected directly to, your RPi will use its default route. So long as all of the "unknown"networks are connected via the router your default route (default gateway) points to, your RPi will direct traffic to the router and let it sort it out. So far as the Internet goes, you're still in good shape. You may run into problems if there are any devices not accessible via your default route, and which the RPi is not directly connected to. From what you've described, it should work. Just be aware that if you have more networks on the non-Internet interface, it may get complicated. 

Does the display have on-board speakers? If so, audio should play back over HDMI without any special configuration. 

If you are overly concerned about it, you might try using DietPi, although in my experience, by the time I configure the system the way I want, there is very little actually memory gain. According to the DietPi pages, the actual difference in memory between their optimized configuration and a basic raspbian lite install is 4 MB. They claim 11 versus 18 processes running, and a 1.3 second faster boot time. I suspect much of those gains are due to running dropbear in place of "regular" services such as openssh. There are specialized installs that are even lighter, but you sacrifice a lot (e.g. regularly updated and patched repository) for little actual memory gain. There is something to be said for minimizing the packages on disk in order to speed up updates, but you're not going to see a lot of memory, performance or boot time gains by doing so. Here is the output of : 

You can certainly have multiple instances of motion running. Could you just build the needed version from source and use it for all instances? 

By default, samba will create a share for the user you log in as corresponding to that user's home directory. Since you're logging in as user pi, that's the "extra" share you're seeing. If you want to disable this behavior, look for a [homes] section in your and comment that entire section out by prefacing each line with '#', or just delete it. You could do the same with the [printers] section. 

Configure one of your wifi interfaces as a hotspot. You do this with . Configure the other wifi interface to connect to your Internet connection - presumably some sort of existing network. Configure routing or bridging to pass the traffic between the wifi interfaces. From what you're describing, you probably want routing with Network Address Translation (NAT) to allow your wifi devices connecting to the RPi to share its IP address for Internet access. 

I connect to the RPi for basic configuration using the Edimax in AP mode. Once connected, I configure the RPi as a wireless client to connect to the local wifi network, which changes from location to location, so can't be configured beforehand. Once connected as a wifi client to the local office network, I can ssh into the RPi and configure eth0 to work on the test network. 

A USB-TTL serial cable would allow you to connect via serial over the GPIO pins. You'd use some sort of serial communications program (e.g. on linux) to connect. An Ethernet cable would allow you to directly connect the RPi to the laptop. Of course, the laptop has to have an Ethernet port. Both the laptop and RPi should be assigned IP address ranges in the LAN Local (169.254.x.x) range after approximately a minute. You should then be able to connect from your linux laptop with . If the existing card is a recent raspbian version, create your own wireless network, perhaps using on your linux laptop. Configure the RPi by removing the card, mounting it on your linux laptop and configuring it to connect to your newly-create wifi network by creating a file on the (VFAT) partition. 

You should still be able to ssh into the RPi in a bridged configuration provided you assign an IP address to the bridge (br0) interface. 

You can use USB Gadget Mode to use the OTG USB port on the Zero as a network port by adding to , and adding to the end of . This will cause the Zero to emulate a USB network adapter if you connect to the Zero using the OTG USB port. Depending on the specifics of your debian server, this will work as a normal, albeit slow, network connection. By default, it's going to use lan-local (169.254.0.0/16) addresses, so you'll need to do some work to configure your debian machine indoors as a router. The downside is that performance of both the on-board wifi and USB gadget-mode networking isn't the greatest. So yes, it certainly can be done, but the results may not be worthwhile. 

If those conditions are met, it should "just work" as a router on your local network. Keep in mind, if your external connection is an Internet connection, you probably need to set up NAT as well. 

After creating a new user with sudo access, I log in using that account and emasculate and disable the user pi account without deleting it in case I need it later: 

If you have no connection, it's going to be impossible. You need to get some sort of connection. If the RPi is connected to an existing wifi network and you just want to find it, try: 

Be sure to add your new user to the group since that is what allows the use of the command by the new user. can be important for configuring network devices. As others have noted, you're probably better off simply changing your hostname (can be done with under ) to accomplish what you're after. Also, don't forget the old pi account still exists, and possibly with a default password, so be sure to at least change the password for the pi user for security reasons. 

The simplest might be to create a delayed job each day from your python script. You can install the command for one-shot jobs like this if the time varies each day (). One plus to this approach is that you could have your python script schedule several days' worth of captures in one go rather than checking each day. Alternately, you could have your python script just idle and call the executable at the appropriate time. If you prefer to control the camera directly, you can use something like picamera. I used this to run a timelapse sequence over several months. 

Do be careful connecting 5V power. Generally, you want to power the RPi through a separate power supply, not via the USB adapter. As to specific sequence, I'm not aware of any. I had no issues plugging and replugging into a PC USB port. YMMV. 

This is an older question, but always a good one to ask. In addition to the advice already provided, I recommend some additional steps. Based on observing login attempts against default user accounts (e.g. pi), I like to configure ssh to only allow specific users or groups, and limit those to pubkey authentication: 

To enable routing, assuming you're running a standard kernel, etc. sudo sh -c "echo 1 > /proc/sys/net/ipv4/ip_forward" So far as addressing, just configure the interfaces however you need to. If your RPi is going to be an access point, you'd want the wireless interface (wlan0 presumably) to have a fixed IP address. If the Ethernet interface (eth0 presumably) is your outside interface, use DHCP if the network it's connecting to provides dhcp. The main requirements are that: 

You will need RW access to the filesystem. If you can't log into the RPi directly, you can mount the partitions on the card on another system that can mount ext4 partitions (ideally linux) to make these edits. Otherwise, connect the network and make these changes as root. 

Debian is a rolling release, so there aren't specific release dates fixed to a point in time, if that's what you mean. An RPi running raspbian jessie that was installed in late 2016 can be fully brought up to date with the one installed in February 2017. Both will be "current" with the debian release configured in /etc/apt/sources.list. The jumps between debian releases (e.g. wheezy to jessie) tend to be pretty significant, but within a release, assuming you keep it up to date, an install will be "current". It is possible -- though not always trivial -- to update debian systems between releases with dist-upgrade. That's one of the beauties of the debian rolling release approach. There's less need to wipe and reinstall to get the latest. 

A little googling indicates that some efforts are underway to port CentOS to ARM. Probably best to try a few basic searches for that sort of info. You certainly can use a RPi as a web server, but you can't reasonably expect it to perform as well as a device costing 100 times more. Disk and network performance are restricted to USB speeds. For a small server, this may not be an issue. Memory is limited compared to a full rack server, so you may run into issues with complex sites or heavy usage. Again, may not be an issue. If you're doing other things on the RPi concurrently, you might run into issues. It really comes down to what you want to do. The RPi can certainly be useful for learning about web servers, so long as you have reasonable expectations. 

You need to verify that your serial communications are working first. If you can communicate with the printer, you should start researching setting up printing with CUPS. Under CUPS, you can configure the drivers assuming they exist for Linux. I always look for a printer definition (ppd) file and import that into CUPS. 

As noted in the comments, if you are using raspbian or can add the package, you can reference your RPi as (substituting the actual hostname of your RPi). This functionality is handled by handling multicast DNS (MDNS) on the RPi itself. If your DHCP server (i.e. your router) supports the feature, the DHCP server (not the RPi) can create dynamic DNS entries for addresses it hands out via DHCP. I use as my DHCP server on my router, and it supports this functionality out of the box. If my RPi named gets an address from , I can simply refer to it as (e.g. - no necessary).