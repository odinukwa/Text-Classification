All you need to do is to emulate a USB HID device with a couple push buttons. There are many examples of these, mainly in the arcade emulation field. They are called "fightsticks" and this is a sample available from Amazon. I'm not suggesting that you get one, merely using them as a proof of concept. Another product is from Adafruit and is a small Arduino compatible that can be programmed to act as a keyboard. And yes, you can have a keyboard with only two keys if you want. Adafruit almost certainly has sample code for this purpose. Adafruit also has a variety of switches that can be used if you don't already have any. 

I would suggest buying a low-power PC in a mini-tower. Just enough of a machine to fit your PCI board in. Anything I have seen has cost more than such a PC. You can even probably get it used to spend less money, but even a low-end PC will cost under $1,000. Nothing I've searched for will connect a USB port to a SAS device. If you really wanted to do this, you'd have to do a lot of work. I'd start by looking up the PCI bus' electrical specs so that you could connect to it. Then you'd need a power supply to power the tape drive and probably the PCI board. Then the real work begins: you'd need to write a custom driver. Just get the PC if there is a driver available. Otherwise you have an interesting-looking paperweight, unless you are very good at electronics and programming and have a lot of spare time. I like these things and are good at them, and I wouldn't try it using a Raspberry Pi unless somebody were willing to throw a lot of money at me. 

Or replacing /dev/ttyUSB0 with whatever device file actually corresponds to your USB serial port (for example, the first Uno connected would likely be /dev/ttyACM0) Even with regard to the PI's own native serial port, this behavior of DTR is ultimately under software control - anyone who argues otherwise is ignoring the fact that it is only the Linux driver, and not the hardware, which has any knowledge of the port being opened or closed. The actual port hardware can only tell that it is being read from or written to or reconfigured, none of which are actually synonymous with opening the serial device. 

No, it is not possible (at least on the model B I'm familiar with, you can check the schematics for others) to toggle the USB VBus power, as there are no power switching devices on the board to implement this, and USB lights typically use only (abuse) the USB power without being command-able over the data lines. It's true that a few USB hub implementations provide per-port power switching (many hub chips have the output pins to drive power switching FET's, but few hub PCB's have the FET's installed), and there may be ways to command them under Linux, but that's not relevant to an implementation where they are not present. You should be able to accomplish your goal with a USB- or GPIO- commanded switching device - FET or transistor driver, mechanical or solid state relay, etc. These are available both as bare components or already packaged on a board/module, direct wired or opto-isolated, etc. If buying a USB-connected device, be sure to get one where driver source code is available either from the vendor or someone who has reverse engineered it, as neither a windows driver nor a binary-only x86 linux one would be much use on the pi. 

I've never heard of trying those strategies. I've never heard of a Raspberry Pi hat or other add-on that adds a new CPU. I suppose you could use the Raspberry Pi Compute Module with multiple modules, but that would be more expensive than choosing a more powerful single-board computer. There have been people who have made parallel computers with a network of Raspberry Pi's. These clusters are more educational than useful, but they might increase your CPU speed enough, and they should be able to share a hard drive. I don't know if this will help enough, though, because I've never tried this. Have you considered a more powerful board such as the Udoo x86 series? This is an x86-based board (or rather several of them with increasing speeds and prices). It will run Linux just fine, it can also run Windows. It includes an on-board Arduino clone, which is useful for robotics. The Raspberry Pi, while a wonderful computer for some things, has too many networking bottlenecks to be useful where networking is important. Don't get me wrong, I like the Raspberry Pi. I have many of them. I'm going through my electronics, and I have many more than I thought I did. Maybe I will try making a parallel Pi someday, purely for educational purposes. 

If you only want one picture per day at the same time, it might be better on batteries to shudown the pi after taking the picture and storing it. Then use a timer to turn on the pi at the same time each day. You use use a very small, low-powered microcontroller to do this. They could run off the same power supply. I haven't heard that the Raspberry Pi has a low-power sleep mode that can be set to wake up at a given time. This would be extremely useful for your application. The battery for the power supply should use some environmental supply, such as solar, wind, or water to recharge. I'd use a lithium-ion battery. I agree with OyaMist that you'd want about a 12v battery and use a dc-dc converter (not a normal voltage regulator which wastes a lot of power). And unless you need something more powerful, I'd suggest using a Raspberry Pi Zero. It's cheaper and you save more power. 

Yes, you can use multiple input circuits driving multiple GPIOs, provided that the voltage range is appropriate and all share a common ground with the pi. No, this is not a particularly good way to do time measurements, as the pi typically runs a multistasking operating system such as Linux (or, if you must, Windows) and that is notorious for resulting in a substantial and variable latency in responding to external stimulus. In theory you could overcome this by doing the timing in the kernel, or better yet using a realtime kernel - but it is a lot of effort for marginal results when the real issue is that the wrong platform has been chosen. Theorectically, if you wanted to do it in the simplest way anyway you could use another checking the other photogate input, or better yet use something blocking on a read of the interrupt node for that gpio, and hope that this results in the scheduler waking you up as quickly as possible. But it will only approximate the timing. If you want to build a good photogate timer, use a barebones microcontroller and/or feed your inputs directly into a counter timer block's capture trigger. This could potentially be a $1 class part accessorizing the pi, if you really need the capabilities of that for other purposes. (Or to put it in hobbyist language, this is properly an Arduino problem not a pi problem, but you could potentially use a baby Arduino to accomplish it and report the time difference to a pi). 

You do not want to power the motor directly from the Raspberry Pi. I'm surprised that your attempt at it hasn't destroyed the Pi already. The L9110 chip datasheet states that the L9110 Vcc (input power) can be from 2.5V to 12V. The +5 volt specified input is probably because the motor can't take a high voltage. You should not use USB to directly drive a motor. One way to power this is to get a 6v battery pack (4 AA batteries - non-rechargeable - would do) and connect it like the breadboard power supply is connected. Another way would be to use the breadboard power supply and power that with a 9V battery pack (6 AA batteries). Happy Making! 

Yes, if you setup a DNS server (Domain Name Server) you can create you own little internal network. However, you will need to make sure that the server rolls over onto an outside DNS so that you can find outside machines (like amazon.com. google.com, tvtropes.org, and other such important sites). I have a Synology NAS that has the option of having a DNS run on it. It is a fairly tedious process. I've only done this on unix/linux machines, but there must be something that runs under windows. I will be setting this up on my Synology NAS because I don't have a Linux machine that it up all the time. Then you have to have your central router (usually that machine that runs WiFi in your house) to give your internal machines specific internal ip-addresses. This is so that the DNS server can associate each address with each name. And then you have to go to all the machines and tell them about this new nameserver and not to use DHCP to get their addresses and names. And also inform the machine about their new fixed ip-address. This is usually under settings in a setting called "Network." It's easier than I make it sound. Here is a recent article on how to do the setup under Linux. One further suggestion: decided on an unique domain name. I use my first name because it's short and I can remember it easily. Sometimes people have a theme in naming their individual machines. I've seen machines with the names of science fiction characters and one with the name of small towns in Pennsylvania. Go wild. I may name my machines after cinematic superhero names. :) 

Individual crimp pins in heat shrink work well. A wire wrap tool can also be very handy for interconnecting boards in prototype systems - although not designed for it, it will typicall work on 2mm headers as well. 

GNU screen may give you an interactive terminal to a usb serial device such as an Arduino, but for use in a program you want to use the serial APIs for C, python, or whatever you are writing in. There is very little distinction between the pi and other Linux (or even unix) systems in this regard, except that some runtime framework too heavy to have a practical pi port wouldn't really be an option. What the Arduino does in response to commands on the serial channel would depend entirely on the sketch which you create and load into it; out of the box it will do absolutely nothing. An Arduino by itself probably does not exceed the pi's USB peripheral current limits, however an Arduino with accessory shields might. Powering the Arduino from a hub is one option, but some Arduinos/Arduino-like boards will allow you to use an external power supply for the board, even when USB is connected. 

The 5v pin on the Raspberry pi is simply not controllable, at all. Your edit provides a picture of a relay module with an optocoupler input. It is quite likey that you can successfully drive this from a pi GPIO output (I've used similar ones with an ATmega at 3.3v), ideally using where the pi connects to the cathode of the LED and the anode goes to the 3.3v rail through an appropriate current limit resistor (the resistor can really go on either side as long as it is in the path). You would then output a "low" to enable the relay. Ultimately you should determine the part number of the optocoupler and check its data sheet for the required current. If that is more than the pi can handle, you can use the pi to enable an NPN transistor which functions as a low-side switch in the optocoupler LED's drive circuit (much as how TV remote projects typically drive high brightness IR LED's), but that will probably not be necessary 

Is there a way to attach another microSD slot to the Raspberry Pi 3? I have searched online for shields or breakouts that can be attached to the pins but have only found solutions for microcontrollers such as Arduino. An alternative is the use of a USB Cardreader, but I want to know if additional slots using pins are possible. I was considering using one of those microSD breakouts with the pins on the RPi3, but I'm worried about the sensitivity of the signal lines because of previous breadboarding nightmares: 

The datasheet above shows different pin configurations for SD and SPI modes on either SD or microSD cards. Does the built-in microSD slot on the Raspberry Pi 3 B use SPI or SD mode for activities like booting, writing, reading and more? 

I can't find anything online about installing Windows IoT to an USB drive. My Raspberry Pi 3's microSD slot is occupied, and the official guide says I need to use a microSD card in order to flash it with Windows IoT. I want to flash a USB drive with windows 10 IoT and have my Raspberry Pi 3 boot from that instead of the microSD card. I have thought of two ways I could do this: 

Set up my Pi 3 to boot from USB, copy the Linux image to a USB microSD card reader with a microSD card inserted. Follow the Windows IoT setup Hope Windows IoT installer won't complain I'm using an USB card reader.