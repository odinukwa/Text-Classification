You will basically be trapped in an arms race with the botters, and based on logic along the lines of the above points, as well as my experience with such games, you will not be able to keep up. Some game developers employ extremely aggressive anti-cheating measures: For instance, Steam will scan memory and the file system to look for hacks, and offenders can be punished by losing accounts worth hundreds of dollars. Yet there are still bots and other hacks for Steam games, and some of them even work half the time. Unlike them, you have an API that's wide open to the user, and no control over the users computer. It's an uphill battle from the start. The problem you are trying to solve is essentially a Turing test: Except it is a very easy Turing test, because you cannot cheat by requiring hard AI problems like language. No matter how many heuristics you create, it would be trivial for a botter to add a little randomness to the bot's action to have it mimic almost exactly a human. It wouldn't even be very hard to have the bot watch you play for a bit, and learn how to time actions exactly like you. Then when you ban the bot, the botter posts a huge rant on the forum about how he's just a dedicated player (and maybe he is actually a false positive) and your core audience of hardcore players will rise up in arms against you. Make the game too fun to bot The main reason someone uses a bot is because there is a part of the game they want to skip. If they enjoyed the game and found it fun, they wouldn't have the bot play it, they'd play it themselves. But if the game is so boring, why play it at all? Presumably, some parts of the game are boring and mandatory to get to parts that are fun. For instance, in MMOs everyone loves going up a level, but nobody wants to kill 42,324 dire undead poison rats to get the XP. So they let the bot grind and drop in to play the fun part. This is not a criticism of you or your game, but clearly at least some players find some parts of your game tedious. You should see if you can reduce these tedious parts, and look into adding more difficult, meaningful decisions: Bots aren't good at deep strategy or lateral thinking compared to human intelligence, and besides humans enjoy making difficult game decisions. From your description, I get the impression that this is a browser game similar to Travian, where there is a build queue with a single best build order and certain "maintenance" (such as keeping farming raids going) tasks that must be done. You say there is no conflict, but in any MMO drama and petty politics is inevitable (IMO it's the main attraction) so I'm sure your players find ways to butt heads. With these sorts of games, a lot of the tedium comes from these "maintenance" tasks - what players really want to do is make alliances and play the diplomacy game with rival clans, the maintenance then becomes a sort of tax where you have to wake up to an alarm at odd hours to be allowed to get into that fun diplomatic part. So cut out the tedium: Automate boring things yourself (but maybe imperfectly to keep it interesting), so that players can focus on the parts they like. This approach may not always work, unfortunately. Not all players have the same tolerance to tedium or the same concept of fun. You could have a prominent mechanic that 99% of your players enjoy, but the 1% find boring. What if the 1% then start writing bots, ruining the fun for the 99%? But ultimately, it is a matter of degree. You can never remove botting completely, but you can minimize the damage. Undercut botters A lot of the really negative effects of bots come from bot authors commercializing their work. If this is the case for you, you could simply compete with the bots. Many real-time based online games already have premium features that allow time-skipping and automation (such as extended build queues). These amount to a developer-sanctioned official bot. If you have these, and price them appropriately, players will buy your premium instead of buying bots. The good news is, you are in charge of the API, so you always have a strong advantage at developing quality automation for your own game, so this time it's a losing battle for botters. This will not eliminate amateur botters, or people who feel that your premium is not good value for the money, so again the effectiveness of this approach depends on the situation. Manually look for them As I said above, what you are doing is essentially a Turing test. Since interaction with humans is famously considered a difficult Turing test challenge, you can try to leverage that. Manually inspect top-level players and see if you find anything suspicious. You might even be able to get away with occasionally probe them in ways restricted only to your imagination, to see if you can trick the bot into doing something it wouldn't do. While it is hard to write an algorithm that will detect bots reliably, it isn't so hard for a human to learn how to spot them. I think a lot of browser games use this strategy, and it can be pretty effective. The disadvantage is that either you need to do a lot of boring work all the time, or you need to pay game masters to do regular bot patrol. 

I wanted to clarify: Inside there is usually a call to . It is my impression that this line is responsible for drawing attached components. Whatever code you put above it will be drawn before, whatever you put below it will be drawn after. If you remove the call to base, presumably the components will not be drawn. If you have components A, B and C, and you would like to draw A and B, then draw some of its own stuff, and then draw C, it seems you'd have to draw each component manually by iterating through . 

For this post, y = f(t) where t is the parameter you vary (time/progress) and y is distance to target. So I will speak in terms of points on 2D plots where the horizontal axis is time/progress and the vertical is distance. I think you can make a cubic Bezier curve with first point at (0, 1) and fourth (last) point at (1, 0). The two middle points can be randomly placed (x = rand, y = rand) within this 1-by-1 rectangle. I am unable to verify this analytically, but just from playing around with an applet (yeah, go ahead and laugh) it seems that the Bezier curve will never decrease with such a constraint. This will be your elementary function b(p1, p2) which provides a non-decreasing path from point p1 to point p2. Now you can generate a b(p(1) = (0, 1), p(n) = (1, 0)) and pick a number of p(i)'s along this curve such that 1 

If the destination tile itself is impassable, the algorithm shouldn't check any tiles at all. Before even starting to do pathfinding, it should query the destination tile to check if it's possible, and if not, return a no path result. If you mean that the destination itself is passable, but is encircled by impassable tiles, such that there is no path, then it is normal for A* to check the whole map. How else would it know there's no path? If the latter is the case, you can speed it up by doing a bidirectional search - that way the search starting from the destination can quickly find that there is no path and stop the search. See this example, surround the destination with walls and compare bidirectional vs. single direction. 

If you want a perk that affects RateOfFire, you must allow the guns' RateOfFire to be open for modification by outside actors, by definition. Escaping that would be a logical problem. For your example of running faster after dying five times, wouldn't that work nicely as an event for your class? 

When the object is created, create a variable . Increment this at regular intervals; this is your time. When placing the object, don't give it a random position. Place it at . This is your phase term. If your gaze direction is parallel to the plane of rotation, evaluate where is your frequency. You will play with until you get the right rate of rotation. You will add to the x-coordinate of the character to obtain the position of the object. You will check if is to decide whether to draw the object's sprite behind or above the character. is the maximum distance from the character, i.e. the radius of rotation. If your gaze direction is not parallel, you will evaluate and where is half the width of your bounds rectangle, and is half the height. In other words, maximum vertical and horizontal distances. Your rectangle better be centered on the character, or else. You will add to the player's x and to the player's y to obtain the position of the object. You will again consult to determine draw order. 

I don't see why not. I'm sure the fact that you can demonstrate your ability will be a big plus during the selection process. 

If differentiating collision with bottom (stops falling) and sides (stops movement) is a problem, do them separately. If you check sides, and push, before starting to check bottom, you will be out of the sides by the time bottom is checked. Also, you can do friction and collision checks separately. What I do is use a rectangle intersect method similar to Nic's. I have a small area around the sprite representing "space where the sprite can go", and if any colliding objects overlap that boundary, the boundary is shrunk. Then the sprite is locked to the boundary. It seems simple enough. $URL$ has a detailed explanation of a sophisticated collision system. It is impossible for an object to be "above two tiles"- its position is a vector, and is above only one tile, unless tiles overlap. 

In playing around with my hobby projects in various object oriented languages, I have realized that creating good class structure and program architecture is both crucial and not straightforward to effectively develop a program, in particular a game. I am a self-taught programmer with virtually no formal training, and I've only learned the things which seemed to be of immediate practical use, so I have never really looked into things such as design patterns, software architecture, code organization principles and the like. The resources I find are often limited in scope (most commonly it's a showcase of a single pattern) and/or quite technical (all the UML going over my head doesn't help). Is there a good resource which explains the important concepts and basics of software engineering, where I can learn about things like when and how to use Components, what kind of class structures are appropriate to what tasks, how design patterns relate to each other and which are useful for what? 

I have a sprite which has and , either stored as . At each cycle, velocity is added to the position. I would like to give the sprite a third vector, . New targets may be given at any iteration. I would like the sprite to essentially move in a random walk pattern, however two parameters must be exposed: 

Again, you can use a list for exits. It would be a separate list for exits only, and go like "7: 64, 2" which means there is an exit at 64, 2 which goes to level 7. You can easily come up with a system for defining whole rectangles as exits if you need to mark large exit areas. Again, I don't understand. 

This is more of a silly bit of trivia, but if you don't care about perfect precision (who cares if you give or take a second when talking about centuries?) then as is a double, the maximum value it can store is . I am not sure how overflows work in C#, but if you run the game for longer than this, I guess it would either go back to something like , or simply not change. It also depends on how it is implemented internally. That said, that number of milliseconds is pretty big. If you compare it to the hypothetical age of the universe, it's... Uh... Well it's still pretty big. Of course, as Sam said, the time is actually stored in ticks (tenths of a nanosecond?), so you would run into the "limit" after a "much shorter" time period. It's still something like a cube of a googol times the age of the universe. I'm not sure how stores time, exactly, so this also means that you may never actually see output get "close" to its maximum value. Although, if it's packaging time into days and years whenever the ticks value gets high enough, and not just when you call the getter, then the timer will increase until the maximum value of in years, which is even higher. If, for some reason, your game should have such plentiful content as to require spans of time in which a great many universes are born and perish to fully explore, there exist specialized data types for storing arbitrarily large numbers. Java has a whose size is basically limited by your RAM (and through virtual memory, even hard disk space). Apparently, C# doesn't have , but it has . Should you make such an epic-scaled game, doubtless to be played by the very gods themselves, you would probably start by duplicating the class, and then reimplementing the class (or even just periodically adding 's value to your ) to use it. 

The script which plots the function for a random seed (note that this is the only place where a random function is called, the random variables to all other code are propagated from this one random array): 

If the game is supposed to fit into an existing genre, or it is somehow similar to another game, simply try to make a crude, simple imitation of that game, or make a "typical" example of the genre. If you are not a good coder, follow a tutorial which will walk you through making a game similar to yours. After a while, you should naturally feel the urge to "diverge" from your model, and start taking the game in your own direction. From there it's a downhill road of adding a feature there, fixing a bug here, and generally improving in small steps. If there is a certain concept that is somehow unique to your game, you might also start by building the simplest demonstration of that concept. There's also the option of simply building your game around that concept. 

If people want to bot, I don't think you can really stop them. You can of course implement many measures that make botting more or less of a pain. But you can only do so much before your codebase turns into a gigantic mess that's hell to maintain, error prone, and annoys legitimate users. Meanwhile the botters will always find a way to defeat your countermeasures: 

It appears the problem is this: XNA claims to support Truetype and Opentype fonts. However, some Opentype fonts have Postscript outlines, which XNA doesn't support. So they won't import. One example is Philosopher, an otf font which doesn't have compatible outlines. The solution is to convert the font to Truetype. The font I mentioned won't work in XNA, but after converting it to ttf with this online tool, it does. Make sure you delete the old font from Control Panel/Fonts to avoid confusion. Moreover, restarting the OS is unnecessary. Restarting VS is sufficient. 

"Technically", no. SpriteBatch exists for 2D sprites. However, you can supply transformation matrices to the SpriteBatch, and unless I'm mistaken this allows you to skew and stretch your sprite to your heart's content. You would, of course, have to manually calculate everything, but you could fake 3D by clever transformation of 2D. 

How helpful (or otherwise) the interface is tends to be a crucial aspect of the game, so it often falls within the domain of reviews. You might have some luck searching for "game name review interface" for instance. Personally, I have a blog where I review a game occasionally, and I make a point of explaining what's wrong with the interface in detail when it's a big hindrance to my enjoyment of the game. I can't be the only one.