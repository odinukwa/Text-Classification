I only see the init/awake message printed in the console. What am I missing ? EDIT: Sorry, I forgot to add the BoxCollider(Physics>Box Collider) to my object, so no events were triggered. 

As @Iain mentioned, that is not why the WiiFlash was made. You will be using actionscript 2.0 to make Flash Games for the WII. There is a title out there on this subject:Nintendo Wii Flash Game Creator's Guide HTH 

I've just started to learn Unity3D. I want to create a simple 3D menu with just two 3D Text instances. I've created and named them, then dropped this script: 

You need to implement either something like bones or morphs. As stephelton suggests, a WebGL framework would make this easier. Since you're using Blender, how about using three.js ? It already has a Blender exporter and there is also a python script to convert objs to the json format the framework uses, in case you need to use other applications. Among great other projects, it was used for Ro.me and you can see samples of morphs there. You can have a look at the source code for the models as well. 

I started to learn Cinema 4D. I've noticed it's really easy to use for motion graphics, but I want to use it for modeling for games/realtime 3d engines. Before I used 3dsmax and it was easy to estimate how a model would look/behave in a 3d engine. The two main things I did was displaying Polygon triangles and displaying the Polygon Count. I've found the Total Polygons tick in HUD settings in Cinema 4D, but I can't find any display mode that will show triangles. Is there there a way to display triangle faces/not quads in Cinema4D ? If so how ? There is a Triangulate function, but I'd rather not Triangulate/Untriangulate all the time, especially since it's converting back and forth between the two doesn't always produce the same result. I imagine I'm asking for old school techniques, but I plan to use these to make low poly models for web(canvas/webGL) and mobile. 

I am working on an isometric game and the designers want to use a different isometric angle than the default one, where I simply had to do a 2/1 offset based on tile size. I know what the new isometric angle is, how can I work out the w/h ratio to offset my tiles ? 

I've been playing with Blender and Python, doing basic things like accessing vertices/normals,etc. I can get the normal of each face of a mesh. I was wondering, how can I get the rotation of a face based on it's normal ? Can I 'decompose' the normal's rotation into rotation x,y,z ? If so how ? I remember 3dsmax had something that allowed you to easily place objects on another object's faces/surface. Haven't seen that in Blender, might be handy. 

Although the damage is somewhat random, it only varies by 26.5 percent over the total range, so you're guaranteed to do a certain level of damage on average over time. These types of attacks are useful for characters who have both low stats and low levels in games that normally account for those factors in dealing damage. Plus, they ignore the defense of the target (although the formula could be easily reworked to fit in defense if you so desired). 

One thing you might think about here is looking at more strategy-oriented games like Civ, Starcraft and roguelikes such as Nethack and Crawl. In these games, game difficulty and player progression are not simple single-variable functions. The gameplay evolves over the course of the game. In the early-game the goal of the player is to simply survive, progress, increase in level, get the next equipment with a +1 bonus, etc. Generally everything the player finds is better than what they currently have - whether that's a new fishing spot in Civ, or a new sword in Nethack. The mid-game often features the player exploring the environment for gameplay options. Now, maybe they're setting up strategic forts, or collecting equipment with special effects that have situational uses, but still simply trying to survive to accumulate more stuff. The late-game forces the player into a showdown, usually with the toughest opponents, but also with the most options at their disposal. More experienced at playing the game, now not only must the player survive, but also exploit the effective weaknesses of their opponents with the tools they've discovered and refined from mid-game forward. You can see the same progression in Final Fantasy games - in the early game, most enemies can be killed with a simple attack, and maybe a couple healing spells as needed. Mid-game enemies begin to appear that are more difficult, but with obvious elemental or status weaknesses to exploit. Late in the game, the enemies might be practically unbeatable except for clear well-thought-out strategies based on less obvious weaknesses or AI script. 

A formula like this is good if you want a very simple method of estimating damage, or a quick jumping off point for modifying damage based on other factors like skills and elemental weaknesses. To show how broad this kind of formula can truly go, consider the damage formula for Inflation RPG, an Android and IOS game (See $URL$ The formula is heavily both stat and equipment dependent. Each piece of equipment has two stats - a bonus to the ATK stat, and a multiplier value. Some pieces of equipment have low multipliers, but high bonuses, others have low bonuses but high multipliers. For a character with only 10 ATK, the Battle Axe with it's 5000 ATK Bonus but low 145% multiplier is a great choice. The total damage is , but the Estoc, with 0 bonus and a multiplier of 300% is a poor choice - the damage is . Later in the game, a character with 5000 attack would prefer switching weapons. Stat- and Level-Based: A good example of this is Final Fantasy V, VI, and Final Fantasy XII (See $URL$ for example). The formula for swords in FFXII is: 

My reasoning was that this would be much faster than doing the perlin noise all over again, but there are still little spikes of lag when you move in between chunks. Edit: Would it be possible to create a 3 dimensional array list so that shifting of chunks within the array would not be neccessary? 

Ok so here's the deal. I've written an isometric engine that generates terrain based on camera values using 2D perlin noise. I planned on doing 3D but first I need to work out the lag issues I'm having. I will try to explain how I am doing this so that maybe someone can spot where I am going wrong. I know it should not be this laggy. There is the abstract class Block which right now just contains render(). BlockGrass, etc. extend this class and each has code in the render function to create a textured quad at the given position. Then there is the class Chunk which has the function Generate() and setBlocksInArea(). Generate uses 2D perlin noise to make a height map and stores the heights in a 2D array. It stores the positions of each block it generates in blockarray[x][y][z]. The chunks are 8x8x128. In the main game class there is a 3D array called blocksInArea. The blocks in this array are what gets rendered. When a chunk generates, it adds its blocks to this array at the correct index. It is like this so chunks can be saved to the hard drive (even though they aren't yet) but there can still be optimization with the rendering that you wouldn't have if you rendered each chunk separately. Here's where the laggy part comes in: When the camera moves to a new chunk, a row of chunks generates on the end of the axis that the camera moved on. But it still has to move the other chunks up/down in the blocksInArea (render) array. It does this by calculating the new position in the array and doing the Chunk.setBlocksInArea(): 

I am having a problem in LWJGL with zooming in and out. I am using glScaled(zoom, zoom, 1) before glTranslated. There are 2 problems: 1. The rate of zoom speeds up a lot when zooming out (lower zoom value). 2. It zooms in on the bottom left corner of the screen rather than the center. Eventually, I would like to have the zoom focused on the mouse position. I have tried to fix these problems by make it glScaled(zoom^12, zoom^12, 1) so that the greater the zoom value, the faster it will zoom in order to balance out the faster zoom at lower zoom values. To compensate for the zoom focused on the bottom left, I have tried to subtract (zoom+1)^10 + 2^10 from the X and Y of each sprite. This results in a curved zoom path, first to the left and then to the right. It is a 2D game.