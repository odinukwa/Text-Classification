This decision is important because of the students familiarity with java. TypeScript offers more similarity to Java (what with it having, em, types, and all), but it is more complicated to teach than just sticking to javascript. This decision is influenced greatly by the fact that the students are familiar with Java, which means it has to be a big factor in the choice we make. Naturally, no method is "better" than another, but some methods would teach the students valuable skills. So, which skills (and how significant are those skills) would the students learn, should we teach with typescript, instead of just javascript? 

Show them a number of examples where a Priority Queue is used (task management, patient treatment etc.) and for each one discuss how the priority queue impacts the performance or efficiency. Let them be creative and try to think of a use for a priority queue, and let them implement that usage on their own (a lab period). 

Now, this isn't exactly how it works, but the idea is that the students remember that what they create in a block, is accessible only inside the block. So: 

My problem: This lesson shows absolutely nothing about what Java does in the background for the GUI. I am talking about the intensive OOP the goes on in the class, and the incredible flexibility with everything extending (allows , and many others to be treated almost identically). How could I extends one (or more) of the above steps, or possibly add a new one, that will teach these parts of java GUI? I find that these parts are important for anyone who wants to make Java GUI. Would simply saying what I have written in the previous paragraph be enough? 

In most cases, writing optimized code is actually easier to write (and to debug) than code which isn't optimized. If you want to show them this, then you can show them a comparison between optimized code and their code. For the example you gave (this is pseudo-code): 

Notice that the pseudo-code has only 1 loop that creates both matrices. So that's the optimized code, as you referred to it in your question. Also, that code uses a minimal number of variables. So that's two for the price of one. Then if you show them that writing code like that is shorter, and easier to understand, they'll start to write more optimized code. Additionally, you can point them to sites that show optimized code vs. non optimized code from the perspective of complexity, as well as readability. 

A fun and useful puzzle type is logical operators. Anything and everything that uses logical operators, and the more complex your operator, the better. Working out how a mysterious logical operator works is a great way to increase, well, logical thinking. You really have to figure out what's the logical output. An example puzzle would be: Input: A B C (binary values) (((A or b) or (not C)) and (C or (not (A and B)))) And then they need to figure out how this thing works. Building a truth table, figuring out tautologies or how one parameter can completely change what the operator does. ( I think C is like that, in the above example). A very, very important skill this teaches is tautologies. Sometimes programming needs to be tautologous. The question of whether the program works should be true for every input which is allowed. While that isn't always possible (practical-wise), striving for bug-free code is, as I see it, a good thing. It's also interesting to show the students how a very simple set of blocks (and,or,not) can be used to construct unbelievably complicated things; and to work out how those things work, the students have to develop logical thinking. So logical operators overall improve a number of aspects of logical thinking. (It doesn't add too much, but my personal experience has shown me that puzzles such as these are one of the only things that taught me logical thinking). 

After teaching Priority Queues, I want to give the students some notion of what it looks like when they are used in code. I have two approaches and I am unsure about which would serve my goal better: 

This list can go on and it strengthens the point that, regardless of learning mathematics before learning Computer Science (that is, learning math with the intent of learning basic Computer science), most applications of computer science are implementations of mathematical models. This means that when learning a subfield of computer science, an introduction to the relevant mathematics is almost always necessary. That being said, being a talented mathematician surely would not harm one's level of understanding of those subfields of Computer Science. 

Each students is assigned an index. Each student gives their name and knowledge $\,\,\,$(does this count as alliterative?)$\,\,\,$ A random number generator gives the index of the next student in the "game". repeat steps 2-3 until a fine dough until all students are familiar with each other. 

As for , the students know about inheritance but the explanation of "it can be accessed by things down the inheritance tree" doesn't really get the idea through. Examples only show it so far and only works for a number of students. So this got me thinking: How can access levels be explained in an intuitive way to high school students? Note: I'm not only asking about , that is my main problem when explaining access levels. Clarification I am talking about access modifiers for objects and methods, not classes: 

1The initializing of the stack isn't exactly a special operation a stack can do. A stack is something used in programming when you need to keep a record of the history of versions. For example, many text editors use a stack data structure to save the changes made to the file. Also, revisions of posts on Stack Exchange have some form of a Stack (funny coincidence, isn't it?) to save the revisions (though I think the SE system uses partial functionality of a stack. I'll check that and edit this post when I have a definite answer about this particular part). The very obvious usage of stack is, of course, the stack segment of computer memory. The call stack is, well, a call stack. (more on this can be seen here) Another handy example is the browser back button. The browser has a stack with the links (technically, sort of cached versions) of pages you've been to. When pressing the "back" button, the stack's function is called, and you get redirected to that. When a link is pressed, a new element is onto the stack. 

The effectiveness varies from teacher to teacher; but generally, it works well. (And can be optimized) The method I describe has a few stages, each dependent on the previous ones. To teach something you don't know, share this method with the students (after you did a part of it, preferably after reaching the third part). Learn it at a quick pace, and let them see how you learn it. Two things are achieved in that way: You can answer their questions, and they are exposed to new methods of learning. Firstly, If possible, sacrifice a few sleepless nights (not one after the other, mind you) to dive into the material and learn it. Read it, reread it, and then again. If the night is needed for other things, then allocate time during the day. As I've said, every stage is important. If you do sacrifice the night, then bear in mind: There is indication that learnt material doesn't actually "sit well" in the mind if one hasn't "slept on it" (keeping it simple: during sleep, the brain makes new connections in the brain, and that's how we learn). So after rushing through a subject, you should let that subject cool down. That last part is the semi-second stage. It usually happens by default, but (speaking from experience here) one might get carried away, so... Thirdly After reading the material for a subject, do what your students would do if you had known the subject. Give yourself exercises. At first, find online ones. For APCS-A, I'm pretty sure there are exercises available somewhere on the internet. As is with everything, practice. Start simple with online things, and then: After you feel sufficiently practiced with the material for a subject, start creating your own exercises. This is the big one. This is the main point. This is my answer. I cannot emphasize that more (I suppose I could make it italic...). This part is, by far, the most important. This is far from saying that one can "skip" to it. I've tried, it doesn't work if you don't do the previous parts. For a better learning curve, try to think up of a division of a subject (for example, dividing OOP to sub-subjects in a logical). Create exercises for yourself for each division of the subject. Try to make both practical and theoretical questions. The latter being questions of pure knowledge, and the former - questions of applying said knowledge. Track the difficulty of the various questions in each sub-subject. These stages will come in handy when you teach others. You'll have a well ordered collection of exercises, fully covering the material, in varying difficulties. I have done what I have described on multiple occasions. This works for self learning (Not so surprising ). 

As a pilot project (which was delayed by an incredible amount, seeing as it's starting 8 weeks after it was meant to), my school grouped together a few kids (high school, they know basic OOP and work in Java) and we teach them a bit about C and working in C. We use CLion, which in turn uses CMake to organize header files. Naturally, the more inquisitive students asked what cmake does. (Like a plant, because it is in the curriculum anyway). So, I was trying to think of ways to explain what cmake does, in an analogy. Because CMake can get exponentially more complicated as one adds modules, I am focusing on analogies that simplify this, and hopefully present in an enjoyable way (such as a demonstration or student participation). The idea is to explain how CMake can be useful for arranging header files. So my question is what analogies can I use, which preferably include student participation? 

The class I teach (a class whose teacher I assist1, to be precise) is learning intermediate Java this year (data structures, basic OOP and a few lessons about how Java actually works). A few of the students have some familiarity with C and it would seem as though this makes some points or subjects difficult for them to understand (such as preprocessor, explicit pointers etc.). This raises the issue of helping these students overcome the differences between a C mindset and a Java one. It was proven time and again that simply saying "That's just how Java works" is not enough (and frankly not very helpful). So I'm looking for explanations (or analogies or examples) that might help students see the differences between the two mindsets in a clearer way. Which points must be present in such an analogy, to properly show the main differences between the two? 

Commonly, the jargon I see in class (former student, new to being a teacher assistant) is meant to serve one single purpose: increasing student understanding. This seems relatively straightforward, but it is not as simple. The jargon is meant to make expressions and keywords easier to explain. If one explains the jargon ahead of time (each subject has its related jargon explained before delving deep into the material) then one can use the jargon while teaching, which is a powerful aid. If you explain what you mean by "declare" and "identifier", then whenever you use those words, it's as if you used the "new" keyword in java. Java knows exactly how to deal with that keyword. Your students will know precisely what to do when you say "create a declaration for so and so with an assignment to such and such...". This worked wonders with students I have worked with. The key point is to explain your jargon. 

Step 1: Think big The most important part is not to think "this is too big". All big projects are, well, big. You need to find something you'd like to do. Sometimes just looking around, and thinking: "I'll make a system that imitates <insert real life thing here>" works great. Just make sure not to think too big. You'll know if it is too big in the next step (making it an iterative process until it succeeds): Step 2: Break it into pieces Now that you have what you want to do: Search google to get an idea of where to start. Better yet: think for yourself what such a project might incorporate and thus break it into pieces. Each piece is like small projects which you are used to from tutorials. Once you have an idea of what are the separate parts of the larger picture, start working on them. Some might be disconnected parts (different pages if it's web related, for example), and so you can work on them separately, and when you get tired and\or stuck with some section, just switch to another one until this "writing block" () is over. Step 3: Profit? Now that you have a work plan, remember to stick to your original project. I know that for myself, I ten to run away with myself when it comes to projects: I add things I didn't intend to at first, and make drastic changes. It eventually is not the project I thought of in step 1. This isn't very productive work if step 1 is done correctly .