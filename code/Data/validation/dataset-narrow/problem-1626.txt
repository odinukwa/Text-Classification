I would suggest buying a low-power PC in a mini-tower. Just enough of a machine to fit your PCI board in. Anything I have seen has cost more than such a PC. You can even probably get it used to spend less money, but even a low-end PC will cost under $1,000. Nothing I've searched for will connect a USB port to a SAS device. If you really wanted to do this, you'd have to do a lot of work. I'd start by looking up the PCI bus' electrical specs so that you could connect to it. Then you'd need a power supply to power the tape drive and probably the PCI board. Then the real work begins: you'd need to write a custom driver. Just get the PC if there is a driver available. Otherwise you have an interesting-looking paperweight, unless you are very good at electronics and programming and have a lot of spare time. I like these things and are good at them, and I wouldn't try it using a Raspberry Pi unless somebody were willing to throw a lot of money at me. 

Windows 10 IoT is intended to be an "embedded" operating system. So not an OS on its own (like Raspbian is), but more a set of functions and procedures that allow you, the developer, to turn the Raspberry Pi into a custom device, using "familiar" Windows10 programming principles, augmented with access to all the GPIO peripherals connected to the rPi. Let's say you want to build an automated ticket dispenser for an event - you connect printing hardware, a screen and a few buttons to the rPi, write a GUI for the user interface, package the whole thing in a nice looking box and connect it to network and power. 

I'm failing the first part of your question, but a piece of black electrical tape over the protruding part of the dongle should help you with your issue. 

This is not possible on a Raspberry Pi, as the RPi's USB ports can only work in host mode. This is fine when connecting a controller, but will not work when connecting the RPi to the PS3. Both the PS3 and the RPi will assume the host role and will hence not be able to communicate. You might want to look at the Odroid C1+ for this project. It has a mini-USB OTG port, which should be able to work in both host as well as slave mode. This article mentions a few other options as well, such as the Raspberry Pi Compute Module (but you need to check if it can run in both Slave and Host mode at the same time) or smaller microprocessors with OTG capabilities which you could join to the RPi via the GPIO. 

I need more information. What is the range of travel? I ask because there are different cellular standards in different places. Pianywhere (BTW: it would have been nice to have a link there) would do the job in many of the places. For example, The Americas is one region, Asia another, and GB and the EU yet another. The Pianywhere does seem to have a GPS in it. I have no idea what the SparqEE is, but if you'd linked it I'd have looked. Other things to think about with travel would be power: if you have to run on batteries, how are you going to charge them? And what about weather-proofing if necessary. I assume the Pi will be outdoors because GPS doesn't usually work indoors. 

Does this driver run even without the -mfloat-abi=hard? I ask this because figuring out where the problem lies may involve looking for defaults. First, does your system have the directory: /lib/arm-linux-gnueabihf ? That directory has your library files in it compiled for hard float. If the directory is missing, then you may not have a hard-float linux. If you have the directory /lib/arm-linux-gnueabi then you have a soft float linux. I don't know what happens if you have both of them. It's probably like crossing the beams or something. I'm doing this on very little sleep, so the best I can further say is that the build system has defaults for compiler switches. There seems to be a switch set for mfloat-abi=soft somewhere in the build system. 

"Millions of entries" is peanuts for databases (or even data files as @joan suggests) nowadays. Let's say you need to store a 64-byte datavalue (maybe readings from a few sensors). If you store that a million times, you've used up 64MB of space. Even the RPi doesn't think twice about that file size. And sorting through 1M records is a breeze for any proper db. Once you start getting in the billions of records in several tables with complex joins - then your database choice might play a role. Until then - use whatever you like. MySQL is straightforward and well supported 

Phone power supplies are not as reliable as dedicated switching power supplies. You can buy a switching power supply for the rPi for very little money (this one for example). A powered hub might work, but depending on the hub you might get feedback issues. A separate, well spec-ed power supply (at least 1.5A for rPi. 2A for rPi2) is the best way to go. 

You specifically mentioned a USB to TTL converter. The Raspberry Pi is a 3v3 device and TTL is a 5V specification. Or did you mean a USB to 3v3 serial converter? 

If you can program in Go, Node.js, or Ruby, then you might want to look at GoBot.io. GoBot is a lightweight framework that has several communication frameworks and Raspberry Pi is one of them. I have my Linux laptop speaking to a Raspberry Pi Zero W, just to see if I could do this. My next experiment will be to have wired communication. If you look on the front page, they have "sister projects" written in Ruby and Node.js. The Go code runs on a larger computer (PC, Raspberry Pi, that sort of thing) and through and "adapter" (a communications protocol) they communicate with microcontrollers if necessary. The same technology allows for communication between multiple Raspberry Pis. It is a much lighter framework than ROS, though, but it is much easier to learn. 

Your problem is clearly because apt-get is trying to get amd64 packages which don't exist for the RPi (the RPi has an arm7hf architecture). You said you looked at other forums, but did you actually execute some of the troubleshooting steps from those forums? The one you've linked to deals with amd64, so if you did any of those steps you might have created an issue somewhere. Also, I just noticed that the contents of your have issues, the correct content should be: 

You do not use the nRF24L01 transceiver but instead buy a 433Mhz transmitter, such as this one. You would need to look for a library to control it, or write something yourself. You can break open the 4-button remote you receive with the relay, check the voltage that goes through the 4 buttons (hopefully it is something like 3V3), remove the buttons, solder a wire onto remote at the output end of each button, and connect those wires to your rPi. Then it's the same as in option 1. 

You are defining the location of the scripts with the "~/" notation, which only works if the same user that is running the python script is storing the scripts. I'd put the scripts in something like /opt/project_name/script_a.sh The scripts might not be executable by the user that is running the python script. You might not have the #!/bin/bash at the top of the shell scripts. 

You do not want to power the motor directly from the Raspberry Pi. I'm surprised that your attempt at it hasn't destroyed the Pi already. The L9110 chip datasheet states that the L9110 Vcc (input power) can be from 2.5V to 12V. The +5 volt specified input is probably because the motor can't take a high voltage. You should not use USB to directly drive a motor. One way to power this is to get a 6v battery pack (4 AA batteries - non-rechargeable - would do) and connect it like the breadboard power supply is connected. Another way would be to use the breadboard power supply and power that with a 9V battery pack (6 AA batteries). Happy Making!