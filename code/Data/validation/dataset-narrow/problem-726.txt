MessageEventArgs Event args raised by client, during the sending and reception of message to server, which includes the data and status. 

MyTCPWrapper class is show below, which will do the following a. Controls the life cycle of MyTCPClients, based on the connection status and message reception status. b. Add multiple clients, to provide redundencies like (Active - Active, Active - Passive)... 

Client code is as below. Input can be taken in any format depending on the requirement. I have not added any basic checks. 

Populate mails in batches and process batch by batch instead of sending mail one by one, this provides better scalability and also have more control on the usage of number of threads {cancellation[if required]}. 

MyTcpClient class is shown below, which will do following tasks a. Expose methods to start and stop communication with server b. Expose Connection Link status c. Raise events like MessageSentSuccessfully, MessageSendingFailed, Disconnected, ConnectingSucceeded, MessageReceived. 

Rather than inserting the EpisodeHistory, then checking and updating based on the data we've just inserted, this code just does the operation all in one. First I'll explain the left join. The point of the join is to find the of the earliest matching row (since we want to put it in , right?). So we do a normal select of the table, except we also add a column for , which, when combined with the fact that we've put in the join condition, will means it will only join to the first that matches. This makes sure that if there are two rows with the same , and , it will only join to the one with the lowest . Now the actual columns that are inserted are fairly simple. If the left join fails (if no rows in EpisodeHistory match), selecting will return . Therefore, means that if a was not found in the join, it will just do a normal insert of . If one was found, it will blank that field. The next line is fairly simple in that it inserts if the join happened, otherwise it puts in 0. Since the entire operation can be done in one statement like above, so you can ignore that bit I said above about temporary tables and an clause. This code above also has the added bonus of working for multiple-row updates. It's a trigger... You may already know, but the SQL Server community is fairly divided when it comes to whether triggers should be avoided or not. They can be easy to forget, hard to debug, and can hinder performance as they become part of the write operation. Since you mention performance I'll elaborate on that aspect, and I'll make some assumptions I hope you can forgive. I'm going to assume there's an application that sits in front of this database, and the application prompts the insert/update. Say the user is on a form and makes changes to an episode, and submits the change. Usually the application will wait for confirmation of the update/insert operation before proceeding (before loading the next page, for instance). With the trigger, the application now has to wait for the initial insert/update, as well as the trigger to complete its operation too. Therefore, if you haven't already, consider the possibility of separating out this process. In this example I gave above, you could have it so that the application still waits for the initial insert/update operations, loading the next page normally, but then in the background (asynchronously) it tells the database to perform audit operations. Boom, you've reduced page load time, better UX. This also has the benefit of you not having to worry so much about performance tuning the auditing operation. Checksum? I'm going to assume since performance is an issue that you've considered indexes, and have an index set up to optimise this and comparison. Have you considered the use of ? I don't have any experience with it myself, however I'd imagine you could use it in combination with persistent computed columns to improve the load when write and maybe reading to the indexes. In this instance you'd have an extra column on both tables called something like , which would be a checksum of eDescription, and you'd put that column in the index instead of . Then when you perform the comparison to see if they're the same, you'd be comparing the relatively small and light checksum column instead of the potentially-huge column. Minor issue I see when you set the , you select from multiple tables. It's recommended to use joins instead â€“ use of multiple tables in the clause is being depreciated by all DBMSs. If anything's unclear, let me know. Hope you found this helpful. 

In general if you have a statement, you should reorder your code to not need it. In this case, your code actually tries 9 times, not three, because you 3 times, and then jump back to your goto label up to 3 times. The simple fix in this case is to remove the extra calls, enclose the entire try/except block in a loop and or if the call is successful. Something like: 

It doesn't sound like waiting more seconds on later failures is important. If you find it is important, you can do something like: 

Variable Names: In static typed languages it's common to use short names for variables in part because writing out the types provides some documentation. In Python however no such hints exist so we use longer variable names. Grouping Like Things: your code has no data structure to keep each player's information together so things like roles, position, etc are all jumbled together. Reusable Code: Not using a data structure also means that adding players beyond the first is greater than linear effort: you have to write out all the same new variables for each new player, and implement a new level to your loops and if/else statements to handle them. If instead we create a data structure for player information, we can easily create a new instance of that structure for each player. If we then keep the instances in a list, we can iterate over them and reuse the same code to play out each player's turn. 

In this way you could able to reuse the Client and add have different wrapper classes based on the functionality like (Active-Active client, Active - Passive client, Broad cast clients)... I would like to share the abstract code (doesn't have any DI or pattern implementation), you can modify according to your requirement. 

One more point I want to add is that, Call filter after some duration when the user is entering the input and not for every text change. Setter should be simple and move the logic out of setter. 

Use delegates for calling appropriate conversion methods, and Move the responsibility of conversions to a separate class. We can have separate classes for each type of conversion, but for simplicity i have created every thing in same class 

Use async/await and Task => Create separate task for sending each mail in each batch, which uses multiple threads. Process Batch 1 => 5 users, Create 5 tasks and execute => Wait for all tasks to complete Process Batch 2 => 5 users, Create 5 tasks and execute => Wait for all tasks to complete ... Use only async/await => which will use almost same thread for processing. 

There's no such thing as an "If" loop, but perhaps you meant a While loop? That is exactly what you need. Otherwise this looks like a pretty good start. Next you might consider: 

The simple answer is "yes". But let's take a look at why that's true and how you could make this look better. 

The keys are our player numbers, and the values are their position. Now we can iterate over the dict for each players turn. 

I'd probably use instead of forcing the user to input an even number. "round" usually means 1 turn for each player. Also so if users enter 0 they'll get a crash when the program skips the loop and drops down to despite points[player_1] having not been defined yet. Note: I've been writing a lot of python2.7 lately so this may have syntactic errors... You could have unlimited players if you add some more loops. 

Now you can access the created IDs using . Of course you'd want to store the or something in the same table, to relate them. EDIT: Untested replacement So I've just roughly written some SQL I think should work instead of everything including and below the statement. The main issue I have with that part of your trigger is that it will only work for one-row updates, and it performs an INSERT then an UPDATE on that inserted data, which can be optimised. 

Per billinkc in the comments, before would do what you intend. Per Michael Green, avoid using where possible. I recommend using instead. Here's an example: 

Since s are used, you'll only ever be returned rows where the is smaller than the , so the code works as intended. If I understand correctly, you want the code to check that is smaller than AND is bigger than . However, those two conditions are the same so you only need one of them. As a sidenote, your code will not work as intended for the following reasons: (1) It will bring back any actors who have starred in ONE movie together, rather than two, and (2) it does not list the movie names they have starred in. The first problem is easy to fix; add to the end of the statement. The second problem depends on the version of SQL Server you are using (use to find out):