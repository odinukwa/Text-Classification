I don't think there are shortcuts hereâ€”the students just need more foundational knowledge before they can be independent. It takes significant expertise to be able to transfer knowledge to new contexts [ref]. Novices have shallow knowledge that is closely tied to shallow features. As an expert, you have insight into meaningful patterns in your area of expertise. You have also seen many, many different problems and cases that you can relate to current problem-solving. Your knowledge is organized in terms of its applicability to new problems [ref]. It seems so straightforward from your perspective! But think about the challenges facing novices. To them, the problem looks different than anything they've seen because they don't recognize the generalities. Do they even know what words to Google? I agree with other posters that confidence is necessary. Knowing good resources to use (e.g. user-friendly documentation) also helps. But most important is foundational knowledge. Teach your students well, with many examples, and as they learn more they will begin to seek out knowledge on their own. 

Read and re-read the problem statement Determine what the inputs are Determine what the outputs are Write down information on the inputs and outputs, including names and sample values 

This step could further elaborate on the details of the Process step, of course. Implementation This is where you finally code! But note that the previous steps require no knowledge of syntax at all. Those steps could be learned in the first few days of class before a single is ever seen. Here's the full outline of Rick Mercer's CS1 text (aimed at college freshmen): 

I have no recommendations for the theory part but since you are asking for implementation advice as well, here we go. If you are looking to use C sharp (you haven't specified a specific language of choice) then, as a dot net guy myself, I would recommend you start your self learning on concurrent programming with .NET implementation of same at Threads and Threading. The link provides with what you can (most of the things you have discussed can be done in C sharp Threads) and what you cannot do. If you wish to dig deep, there are no specific books on threads in C sharp, but you can use the reference book I used which contains detailed implementation notes on the same at C sharp 70 483 

I am preparing to teach Scheme now, so I need a good reference book. I like books which can dig deep, with none of the beginner level introduction stuff that some books like to spend time on. So, what is the best book to use as reference? Note : In line with my usual style, I would prefer books that are available in both dead tree and online editions, with the online edition having a higher priority. 

We don't have Scheme in our entire country (here in India) but that honour goes to C programming language. For the purpose of my answer, substituting C for Scheme, I keep asking myself, why bother with C. After that 1 semester of C, I have never used C professionally anywhere. In fact, once I step out of educational purposes, C becomes useless. That begs the question, after almost 25 years, why are they still teaching C? Why not something else? I think, why they are still teaching C (in my country) and Scheme (in yours) is probably because it is ubiquitous. there are any number of books written on C. More importantly, the faculties who teach them ( I think most faculties change their jobs once in 60 years) can teach the same thing for the rest of their lives, use the same lab manual, and use the same code, and ask the same questions, use the same evaluations. From a strictly logistical point of view, it makes sense to teach C 30 years ago, and 30 years hence. Can you image the mess, if every five years, the universities change their syllabus? Thats a logistical nightmare (not to forget other challenges) no one wants to deal with. For instance, one university could decide to go with C sharp, and another with Java. That creates all kind of problems. However, if all universities agree (which is how things are now) to simply keep using Scheme (in your case) and C (in my case), life becomes simple. Further, the foundation that you get by learning an ancient language is that, everything that came after it, be default, would be easier. I learnt to ride a bike (as in motorcycle, not bicycle) in my dads old bike which was, well not that good. However, because I drove the tough one, all of today's bikes seem like child's play. Although I don't use C itself, anytime I learn a new language, I unconsciously compare it to C, and learn from that. Update 1 : To add some context, I have been part of the IT industry for 11 years, and 5 of them as a developer/trainer/educator who travels widely. I am sure C is used somewhere, I haven't seen one single enterprise usage of C and I have worked for startups, small companies (less than 100 employees) and for MNCs (more than 2000 employees) and never ever has any division, anywhere talked about C, used C or implemented C. Again, no disrespect to C (or its legion of fans) but I request that my opinion be taken in this context. 

I can tell you are very intelligent as this is something only someone who truly understands algorithms and proof of correctness can say. It is actually very difficult for younger students to see this as they are tunnel-visioned by the actual loops in the code instead of the bigger picture. Instead, I think what you are trying to convey is to look for "what part of the code is doing what the algorithm is meant to do" 

That depends entirely on the context of your CS1 course. Are you teaching unit testing suite to your students? If you haven't learned something then how can you use it? If unittest is part of the curriculum, then definitely students should use it. At my University, students are formally introduced to the suite during 2nd year, and thus for all their Java projects they are required to have their own testing suite. As for their C projects, we do not require unittesting because is already enough hair pulling. So to answer your question, no we are not using unit testing in CS1 because it has not been formally taught yet. 

Let's start with the term "Loop Invariance". It is a property of a loop that is true before and after each iteration, thus in-variant, non-changing. So then, what is the purpose of the loop invariance in proving algorithm correctness? That is, it is a predicate about what the loop is supposed to do. Thus with proof by induction on this predicate shows the correctness of this algorithm. I know this is still very theory heavy so let's break this down even more. A simple insertion sort. The purpose of insertion sort is to sort an array. Therefore the loop invariance would be that after each i-th iteration, the array is sorted up to the i-th element. The magic here is that instead of looking at the nested for i, j, loops of the algorithm you are choosing the loop invariance that contributes to the goal of the algorithm. To answer (1). There is no sure guarenteed way to choose the correct loop invariance unless you are very experienced in algorithm correctness through countless examples. The best approach is to choose the segment of code that is actually doing what the algorithm is trying to do. Such as the example above, sorted up to the i-th element. (2). I believe this has to do with the proof itself, rather than understanding the loop invariance. Structurally, to prove that the algorithm is correct, you would have to use proof by induction (either simple, or complete) to pove the loop-invariance and the fact that the algorithm actually terminates. Usually proof of termination is a 1 liner, such as when i > array.length, loop will terminate. 

By default, I approach every training I conduct ( I mostly conduct sessions for folks who are in their final year, or finished graduation but looking to upskill for a better career) with a simple underlying goal. If you learn xyz technology, will help you (eventually, if not right away) to make a little more money than what you do now. I have noticed that there are a lot of students (defined above) are pretty good in what they do (coding stuff). However, they lack certain essential skills that are really warranted in a work atmosphere. Taking my own example, at best, I am a below average developer at best, but somehow somewhere, I end up working in some high level projects. When I self analyse, I notice that my communication skills, presentation skills and simply the ability to discuss without fear with the key stakeholders (like the VPs, CTOs and CEOs) allows me get assignments that otherwise would not. So, over the years, I have made it a point to provide feedback about non-technical skills to my students. Now, after so many years of training, I want to take this to the next level. instead of just giving feedback, I want to make it part of my curriculum. There lies my challenge. In a session I conducted last year, I noticed that an entire team of developers were just straight up bad with their English. This may seem strange to other community members, but English, the preferred language of communication itself is a huge challenge for many of us folks here in India. When I finished my gentle tirade by concluding that the reason why all of them being billed lowered rates despite being technically competent (and I was one of the trainers who made that happen) is because you guys cannot speak and communicate in general. Eventually, despite maintaining excellent ratings for all the previous ratings, for the last day, I got 1 out of 10 ratings for every point in the review sheet. So, a very long story short, like the English example above, there are so many other qualities that are lacking in developers in general. I want to make it part of my training, but at the same, I don't want to end up with negative reviews either. You folks are in the education domain. Have you faced this issue? How can I handle this? Right now, the only solution I have is, just give up on that. My pay is linked to my reviews. At the same time, I feel strongly about this. As always, if this is too broad, I hope the mods will flag it, or I can break it up into individual questions. 

Tell students explicitly that the mind works like a muscle when learning computer science. Carol Dweck showed that students can be explicitly trained in growth mindset, leading to better outcomes for those students. 

(Note that this problem provides indentation information, but others on Runestone do not, allowing students to choose their own indentation -- this is known as a 2D Parsons problem) Recent development is in the process of adding cool new features to these Parsons problems within Runesone [reference], like 

Design This is where the algorithm is figured out, and psuedocode is written. It's also a great place to introduce common patterns in solutions, like the Input, Process, Output pattern so common in beginner programs. For example: 

Help students make improvements to a toy website with git & Github I have taught git and Github basics with this activity from OpenHatch. It was successful for helping students learn git basics: clone, add, commit, push, and pull, as well as Github basics: making an account and repo, submitting an issue, and making a pull request. In the activity, small groups work to improve a small website housed in a Github repo. The site is also hosted on Github, so they can see changes immediately. Issues are available in the repo for students to claim and then work on. Students really see the difference between running the site locally and seeing the version hosted on Github. It requires some setup before hand, since students interface with a real Github repo. But it's worth it, since students get to use git in a realistic way (and so they have contextualized knowledge!). Another bonus is that no specific programming language is required, since students can modify text in HTML to complete tasks, or hack some javascript for the most advanced tasks. 

In SCRUM, during the end of each sprint, there is a Sprint Retrospective and Spring Review. Important artifacts from the two should be extracted into this report, as it reflects the "developed work". I'm not sure the scope of what you require from your students for documenting the work, is it for the whole internship, or just one cycle? In any case, because Agile is done incrementally, they can just write one template per sprint they've completed. 

Since programming languages are made for humans to easily learn and write in, it is like writing a book. We choose alphabets of the language and write meaningful segments that perform tasks whether it is to loop over an array or read some files. 

High level: Just like any language that exists in the world today, it has it's own alphabet, syntax and grammar that is for communication. Technical: First off I just want to note that some languages are interpreted while some are compiled, as for their differences I believe it's off-topic. The idea is that your "code" is tokenized based on the language's alphabet and syntax and formatted into a parsing tree. The parsing tree is then translated into some intermediate code. Lastly the compiler translates the intermediate code into source code or machine code that can be executed by the CPU. 

I've found a lot of success giving real world (often times very silly) examples of boolean algebra to give them a more intuitive understanding in addition to the pure algebraic laws. An example would be "If it rains tomorrow, I will bring an umbrella so I will stay dry". This is a simple A -> B: If it rains tomorrow then I will bring an umbrella, I will stay dry (T -> T = T) If it rains tomorrow then I will not bring an umbrella, I will not stay dry (T -> F = F) If it does not rain tomorrow then I will bring an umbrella, I will stay dry (F -> T = T) If it does not rain tomorrow then I will not bring an umbrella, I will stay dry (F -> F = T) Using DeMorgan's we know A -> B = !A V B. We can say A = it will rain tomorrow, B = bringing an umbrella and whether you stay dry or not is the equivalent of the resulting truth table value. You can incorporate students in coming up with these silly examples, and having them figure out how the narrative would look like to reflect the truth table values. In addition, pairs can come up with scenarios and test each other's knowledge. (This was during 2nd year University too! So it's never too old to get silly) Lastly as a remark, I did not see you mention some Laws of Boolean Algebra such as Associative, Commutative, Idempotent, Identity, and Distributive. I think it's worth while to introduce these laws during lesson 1 or 2 because solving boolean algebra down the road is built off of these fundamentals. 

I haven't taught about analog television but thanks to my gaming related experience (both as a gamer and game development trainer) I know that the topic of horizontal and vertical sync is very important for understanding one of the more core things of computer science, the display. Further, I am all about the cutting edge stuff. Yet, when it comes to getting the concepts of display, I am all for going to the roots, and CRT is by far the easiest way to explain these things. So, to answer your question, yes, the analogy is still relevant. And going further, It will and continue to be the starting point for studying this display stuff. Eventually, you will have to upgrade to modern screen but CRT is definitely the go point on the table. 

First up, I started my talking to some of the folks who are already working on large projects. I am talking folks who are in the industry for a few years. These experienced gave me knowledge about the kind of tools they use, programming languages they use and stuff like that. After that, I decided to build a 'project atmosphere' right at home. For instance, I was advised about using servers and databases extensively for every project. So, I used Azure to create my own IT department, and then consume all those IT resources in my applications. Another individual suggested that I become 'full stack' developer, so I learnt all the languages/components of dot net that are required to go from a project concept to delivery. then, I decided to fill the gaps in my own learning. For instance, I had realised that without even knowing, I had become extremely good at the basics of programming but throw an advance component, I would falter. So, I grabbed all the industry authored books (the ones aimed at working folks rather than students) and pretty much went through them, essentially relearning things. Finally, for practice of getting that 'team' feel, I had some of my students to act as my project members by create real but practice software projects. I would take upon on the role of the project manager or team lead, distribute the work load, conduct presentations, coordinate code over repositories and then deploy the whole thing myself. 

Ultimately it comes down to if the work can be done alone? The purpose of group work should not be so that everyone has less work to do, but rather if the original work could not be done within the given span by a single person. In the workforce, you're most likely to be working in a team and contribute to iterative releasts (Agile Methodologies). If your expectation is that because you're in a group, you don't have to work as hard compared to working alone, then you are set to fail. My suggestion would be to design a project such that bi-weekly or monthly iterations are presented, building up towards the final product. Incorporate Agile Methodologies into this as it is very useful in the workforce and teaches team management / tracking. Groups should be no bigger than 3-4, otherwise it is too big to be efficient. The number of hours required for the project should be big enough that everyone is kept busy. Of course some will do more than others, however one person should not be able to do the entire project. If this is too heavy for your course, then I'd suggest stick with single person projects as there is no merit to group work. 

I've always admired the Swiss' education system of teaching kids where they rarely have examinations, but rather through constructive assignments and homeworks to teach students. At a conference I've attended, I heard a quick introduction on gamification of education and I am trying this out with some students. Here is what I proposed: Assesments (excluding exams and final project, due to curriculum and school board constraints) have unlimited re-tests, limited to once a week. 0.5 credit is awarded for 50%+ and 1.0 credit is awarded for 80%+ At the end of the term, their number of credit earned is divded by total number of credits for a "term work" grade worth x% of their final mark The goal here is for students to not worry about a 50, 60, 70, 80, 90 or 100, but rather track their progress through completion of content. I believe the unlimited retries gives incentive for students who are falling behind to realize early and catch up immediately, rather than later. This is to avoid the mentality of giving up because it is "too late" or "wait for next test". To some degree, I believe in the innate competitive nature of CS students transferred from love for gaming I believe this method (with modification to suit your needs) meets what you are looking for. Accurate enough to give a % mark because you track progression. Although I foresee multiple 100% with this method Does not disturb students because they are well aware of their progress, and know they can make improvements rather than blankly stare at an unfortunate poor test 1 Quick and low effort - I just use an excel macro and export to show my class after each week their progress 

Whenever I run into students who are baffled by the return concept (and in your case, them substituting it with printf), I do something like this. I use role-play. I become one function (lets say the main function) and the student is another function (lets say some function add that adds two numbers and returns the values). Here is how the role play works. 

I train full stack development and that includes user interfaces (which falls under if not cover the entire gamut of interaction design). When it comes to examples, I talk about the infamous case of how Microsoft screwed up Windows 8. I use Windows 8 because a lot of people are familiar with it and may have actually used it. Or at least read about it. Or at least read about the many, many jokes made at windows 8's expense. You could use Windows 8 as an example how badly even a big company like Microsoft can screw things up, and the kind of impact it is going to have on users. Then, you can follow and reveal how Microsoft learnt from their own mistakes and fixed things with Windows 8. I always use this in my UI classes, and it elicits a lot of interest, familiarity and some fun stuff.It also seems to drive the point home. 

A quick online search led me to this. A Beginner's Guide to Access Technology for Blind Students It covers all the essentials 

I learnt a lot (like kept hearing about it) about functional programming after coming to this community. I had heard of it before but was unaware of its importance. Then, I started including functional programming in my daily conversations with my students. Now, a couple of students (who are already familiar with dot net) are asking me if I can teach them functional programming. Given that I am a dot net guy, my mentor suggested that I try F sharp. The question is, is F sharp a good choice for learning functional programming? If not F sharp what are the alternatives. Note : Any alternatives that you suggest must have full support on windows as well as Mac. For example, F sharp works just fine on Visual Studio for Windows and Visual Studio for Mac.