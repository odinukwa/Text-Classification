makes no sense. Why would method call internally? Shouldn't it be the other way around? Shouldn't method call instead? Those methods calling each other is the reason stack overflows. You can remove method, and call instead of . It will work just fine. 

However, I agree with sir I'll add comments tomorrow, you probably need to pick up a better mathematical model to describe infinite lines in order to avoid special cases for vertical lines. Maybe ? The formula for intersection will be a bit more complex, but there will be no special cases. 

Your approach looks fine to me. Except i would probably use prefix-casting, to get cast exceptions straigt away if something goes wrong, instead of using . This can be achieved without modifying code-behind tho. You can bind container's IsSelected property to appropriate item's viewmodel property. 

looks like an accident waiting to happen. The entire framework is built around zero-based indexes. I would not recommend having it any other way in your collections. Otherwise it is really easy to make a mistake: your program will have hundreds of arrays flying around, where most of them will be regular arrays, except for that one special array, where you have to skip first element and subtract from before doing any operations (including LINQ queries!). At least make a custom array class, which would override and would throw an exception when you access index. Or save yourself a trouble and just use regular array. And add to index when reading form it. 

I think you can just inherit from if all you do is wrap methods and override . Recursive methods are hard enough to understand and debug in their own right. When you add enumerator which you move manually to the mix, it becomes even harder. I think you should come up with non-recursive solution. Here is a solution I came up with (which might not cover some edge cases): 

Which lookup is faster will depend on average array size and key type. Assuming this is still "work in progress", I don't think it matters at this point, honestly. Once you have a functional world model of your zoo, you can always come back, do the actual profiling and change internal implementation if needed. 

So called "marker interface" pattern is a controversial topic. Personally, I'd say that yes, it is fine in this particular case. It is a small price to pay for type safety: you can be sure that you can only call with types that were specifically designed for your component system. Not to mention that it might not stay empty forever. Maybe it will turn into -kind of mess. :) Or maybe you would want it to have a single property, that would reference the this component belongs to. Who knows. I say - keep the interface for now. 

Well, i think, you should first ask yourself do you really want to complicate things? Is this something that you will re-use in other places? Because the feeling "i need to create something reusable and extendable" if familiar to every one of us, but the amount of code you'll need to write and debug is not always worth it in the end. If you answer is "no", then you can simply do a little refactoring: move classes to separate files, replace individual viewmodel properties with , stuff like that. It will end up looking fine. If your answer is "yes", then i would probably create a tree-like structure from my view models by implementing something like: 

Is there any reason why you can't use the standard WPF filtering? At first glance your code looks extremely complex and bug-prone. I think you should keep it simple and use the existing abstractions instead. In your case I would go for something like: 

That's more code than I can handle, so I'll just cover some of it. exposes too much methods and is way too complex. 

If you have control over your data, you can try to change its format to simplier one. You can also try to move the logic to lower level, where possible. So it will look like instead. Its hard to tell an exact refactoring without seeing the bigger picture. Using "shortcuts" for commonly accessed fields is fine as well, as long as you don't overdo it. Use extension methods for that where possible, so that class structure remains clear. You can use shorter naming. Do you really need to have , for example? Isn't just as readable? Also if is an equivalent of individual "cells", then using indexers makes sense: 

There is no point in cathing the exception if your code will crash afterwards. You are only making it worse. - this should be . 

Overall, i think unless you are doing it for studying purposes, you should just grab an existing DI library, as you've metioned yourself :) 

As for your actual question: If you place your "buttons" in two-column and use for both of them - your problem should be solved, as you will be able to use the same transformations for both canvases. 

Just wanted to mention, that you can do it with LINQ only (without creating additional collections): 

is not thread-safe and write operation always happen on new thread with zero synchronization. Looks like a recipe for run-time crashes to me. 

You don't show enough code to give you accurate advice on design. But from what I can see, class has a bunch of problems: 1) It has two huge static dependencies that are not immediately apparent. Hard to read, hard to unit test. 2) method is synchronous. IMHO, network-related code should never block, and it should not be consumer's responsibility to call on thread pool. It's your connection implementation that should provide asynchronous api. 3) Since there is a , I assume there is also , , , etc. Having one method per request will not be that bad for small protocols, but it scales poorly. 4) Storing password in memory in plain text is a security vulnerability, but if the attacker gets access to your memory, you are probably screwed anyway. However sending it in plain text over network is much riskier (since it is much easier to access your network traffic than your memory). Make sure to either encrypt it before sending or to use an encrypted connection (or both). 5) method looks like something, that will be copy-pasted over and over again across other implementations with very little modification. Which is a sign of poor design. From your explanations it is not clear why can't you have a message-based api, that does not know and does not care, which type of request you are trying to send: 

IMHO, this method's implemntation has big wtfsurprise factor. Imagine if were to silently drop some of the items you've added based on some undocumented criteria. I suggest you: 

The only way to quickly get the last index is to store this index after each write operation. Other approaches will not, quote, "pull as much performance as possible". I have a feeling that this problem you are having is a symptom of a much larger design issue. In general you should be able to just pick a correct data type, in this case it's , and work with that. You don't have to come up with your own ill-thought-out implementation. 

Do not hard-code settings. Store IP, port, buffer size, etc. in configuration file and load those settings from it. (Not that important for sandbox projects) You should not reopen every time you send a message. Instead your class should open stream once and only close it when the client is closed/disposed. should re-use existing connection. Always sending bytes is clearly not the best approach. It bloats the traffic if message is smaller and cuts the message if it is larger. A simple solution is to prepend size to the messages you send. Use when variable type is obvious. Consider using methods (e.g. instead of ) to improve responsiveness of your apps. 

I also tend to use instead of whenever I need neither sender, nor arguments. Yes, someone, somewhere on MSDN says that you should always use for events blah-blah, but unless the event is exposed as part of public API I see no reason why you should be dragging those empty arguments around. 

To make the code flow more obvious and your code style more OOP-ish, instead of nesting methods in each other you should call them sequentially, so each method has single responsibility: 

Additionally, I would like to point out an old design issue. Which is: inheritance does not work that well, when it comes to programming behaviors. It is somewhat ok for small applications, but it scales poorly. For example, your class is not going to cut it, if you add an entity that is "movable", but does not have a name or age. You'd have to implement another base class, without those properties. This can quickly turn into really complex hierarchies, as the number of behaviors and entities grows. That is why applications, that heavily rely on entities and behaviors (most modern games, for example), normally use composition instead of inheritance. So you d have something like: 

I think the naming for event handlers is more common, so should probably be or something. Either way, you should choose single naming notation and stick to it. 

Arguably, 452 lines of code in a single class (which, to make things worse, is partial) is good enough reason in itself. Another reason: it is not really UI layer's job to query windows api for process updates and track active process. This is a business logic, which should be separated from presentation (in case that one day you get fed up with Winforms evil ways and join the ranks of holy WPF warriors). You should extract it into separate service: 

I mostly agree with vishnu vardhan's answer. However I disagree with his 4th suggestion, which I think is hardly an improvement. It still uses which should never be used in production code: you shouldn't pay your worker to sleep. Either use a or write your own synchronization using . If no tasks are being processes your thread should just hang on some wait handle. It should not spin in a loop, constantly consuming CPU resources, while doing no meaningful work. I also think it might be a good idea to refactor your code into an actual TaskScheduler. P.S. Common pitfall, when using Task.Factory. 

I suggest you convert your image to separate buffer and then use in-between lock/unlock to block-copy the pixel data. 2) The way you use statement looks fishy. What exactly are you locking and why? If events come on different threads and you can't handle them fast enough, then you have to come up with a throttling mechanism, that would drop some of the camera frames. Otherwise events will just keep piling up on this in no particular order and eat up your CPU (which is what you observe). 3) Depending on what else is going on in your app, call can be pretty expensive performance-wise. on the other hand is much cheaper, but you will have to be really careful with your buffers, so that background threads do not overwrite the buffer, that is currently being rendered on UI thread. 

call does not return EOL symbol, so there will be no ">" in the string ever, resulting in exception being thrown even for valid strings. You should handle the instead. This line wont work either: 

but frankly i'd go with Re-sharper templates (or VS code snippets) instead. Edit: A quick test on my machine shows, that on average it takes about 0.22 milliseconds per call to execute 1000000 times with different (not null) arguments. With first call being ~20 times slower (perhaps repeated compilation is optimized and/or cached in some way, tho i am not competent enough on that subject to make any claims). Is it slower then one equality check? Well, obviously. But it is still unlikely to become any kind of a bottleneck in real life scenario, unless overused. As i said, however, i would not use it. The original code looks clear and short enough to me, even shorter, when templated. So i always go with simple explicit check. 

It's a matter of perspective. If you do allow multiple components of the same type, then yes you'd want to have method that returns all components of given type. You would also want to be able to specify whether or not any given component can have multiple instances (using attributes or some property) and in method accordingly. 

There is a lot of copy-pasting even inside class itself, let alone between the two implementations.You should move common logic to private methods. You can even create an additional class to represent infinite line. This looks a lot better, IMHO: 

Personally, I would not want to use any "magic enum" class, simply because in the end of the day it is not enum. And therefore any code, which takes as an argument, fetches an attribute or calls won't work for this class. In rare cases where method is not enough, and you actually need to enumerate flags, some static/extension method (say, ) should do a better job. 

Use only to add single object to the collection, because that's the contract defined by . Use different method to add multiple items. if invalid item is added. Otherwise add the item to collection. Document any weird or unexpected behavior. You might have a reason to implement that way, but this reason is not obvious. 

The way you described it, the should represent the action to be performed. And it should not matter, whether you invoke this action via menu button, toolbar button, hotkey combination or whatever. If that is the case, then it should not depend on interface. You should reverse the dependency. The button adding itself to menu looks weird. I think you need an abstrction for menus and toolbars with method, which would take your button as argument. Again, reverse the dependency. method looks pretty generic to me, should be easy enough. I don't like parameters. It feels like half of those should be properties in interface. Class name starting with underscore is something those eyes have never seen before.:) 

I think this is a bad idea. If you want do disable a cancel button when bgw finished working - then you should do so in appropriate event handler (and you already do!). Doing so depending on progress bar state is a lousy solution. I don't get this hate i see everywhere. Yes, you can replace it with , yes, it will look more fabulous. But frankly, there is no difference what so ever in such simple case. I would even prefer a (or ) solution, because it does not force me to go look for actual mapping somewhere else. is there for a reason and it is certainly not something you should "always eliminate". What you can do is remove empty s, the operator should deal with those. 

No delegates involved and the code is much easier to navigate. Not to mention, that this will allow you to extract yet another massive code block from your oversized form. 

When i was facing a similar task i decided to separate request/response classes from writing/parsing logic for better encapsulation. It doesnt take much time, but it allows you to change protocol or format in the future without changing your request classes. I ended up implementing two interfaces, lets call them and for example. Resulting classes ended up looking a lot like and classes you might know. In your case it might look like this: 

You should avoid using statements. Not because it took me a minute to recall what syntax even means, but because makes it extremely hard to follow the execution flow. Cases where makes code more readable are rare, and yours is not on of those. Just use another (or ) loop instead. is a poor name for a method, because it doesn't say anything about what sort of calculation it performs. It calculates distance you say? Name it then. Oh, wait, it also calculates angle! Maybe then? That doesn't look right... Which is an indication, that you probably need two separate methods: one to calculate angle and one to calculate distance (related to SRP). 

What are you trying to achieve by locking statement? It feels like you are misusing the , because default event implementation (when you declare event in a field-like fashion) is already thread-safe. You can just declare: 

1) You should use for classes and methods, see capitalisation conventions. 2) You can use auto-properties, if you do not need any additional logic in setter or getter. 3) You should probably use singular tense for . 4) Integer fields are equal to 0 by default, you do not have to set them in constructor explicitly. If you take all this into consideration, your class should look like: