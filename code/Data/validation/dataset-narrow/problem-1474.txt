I think you pretty much need to use metaphor/analogy initially. The students need a hook to get called into the game. You make a good point, though, about finding metaphors that work with the generation of students you are teaching. It isn't so much a problem if you teach the same things (same sort of things even) over many years as you can evolve along with your students. One Pedagogical Pattern is Consistent Metaphor, which suggests that the parts of the thing being taught needs to map onto the parts or elements of the metaphor. This may be easiest if you use a Physical Analogy (another pedagogical pattern) as the parts of the analogy object are often pretty obvious. But without metaphor you are pretty much limited to technical detail, which can be hard to visualize and map to a mental model. However, every metaphor has limits. You need to make the students aware of the limits. This is how is like . This is how is NOT like . Equally important, or students can go astray. 

This seems to me to be the sort of topic that is best covered with an assignment such as Write a paper, citing resources, on the topic of XYZ. There are a number of other things that can be addressed this way. One advantage of such an assignment is that students have to write using natural language, which often gets too little attention in technical fields. Another advantage is that you can have the work done in pairs or teams. Another advantage is that you can follow up with class discussion, seeking consensus on the problem. You can, of course, provide them with an initial set of resources so that they are forced to look beyond Wikipedia and other easily found resources. You can also ask for critique of the resources that they find, not just reporting. You can even have a debate. Lots of possibilities since the topic is both serious and open ended. 

The Dutch National Flag problem is linear in running time. Essentially sort an array with only 3 distinct values each of which may appear 0 or more times. (not length 3). You are allowed only one pass over the array, so the solution is a single while loop with some prior initialization. It was probably originally posed by Dijkstra. It is mentioned in David Grits's The Science of Programming where it can be solved very nicely by posing pre and post conditions using David's ideas of finding invariants from pre and post conditions. You can also make it a simple object oriented problem if you like by using objects as the array elements, for example. A more interesting formulation of the problem refers to the Dutch National Flag which is a Tricolor: Red over White over Blue. You have an array that has some jumbled up red and white and blue cells, zero or more of each. You want to move all of the red cells to the left end, all of the blue cells to the right end, with the white cells in the middle. The restriction is that you may make only a single pass over the array. The correct solution is very creative and demonstrates the power of loop invariants. I have mentioned this problem in answers to other questions here. A search for "dutch" on the questions page will reveal them. Solving it without hints can provide a gigantic a-ha moment for almost everyone. If students can do the classic version, they can also think about a modification that will handle 4 values instead. From that you can talk about the inherent complexity of sorting values from any finite set. 

tl;dr: (a) solve the problem at its root, (b) know your students. There are some things that aren't clear from your question and they impact on what action is appropriate. First, you describe the problem in the past tense. But is it a continuing problem or just a one time occurrence due to poor instruction in previous terms? If is just a one-off, perhaps you don't need any solution at all. If you expect it to continue, perhaps you should attack the problem at its root. You don't describe your own position within the institution. Do you have any power at all to affect the overall process? Can you start discussions about what is happening and come to an overall solution, perhaps involving other courses, that make the problem go away. The specific symptoms you describe seem to imply poor teaching in an earlier term. Can your institution fix that problem (if that is really it)? Perhaps an earlier professor needs help and is either inexperienced or was him/herself faced with a problem such as yours and had to compensate just as you did. Of course, you need to be proactive in a situation in which it is likely to recur. Do something at the very start to help you know your students better. A few weeks is far too late to learn these things. Some sort of exam or exercise at the start can tell you a lot. If you wind up in the same situation again and need to compensate, a boot camp such as suggested by Jay here might work for you. You can also prepare a checklist of tasks for the students on the first day (Install the IDE...). Also a syllabus that details expectations (using the appropriate language...). If you can't make assumptions about the students, as you seem to have done, then try to anticipate the problems. But if you are without power to affect anything, then you are also at professional risk if the students don't complete the course requirements and pass into the next course. This again, suggests that you have an institutional problem and not just one with a given class. Note that institutional change may be difficult. In some institutions students are allowed to take courses without the necessary prerequisites. In some institutions that accept students from elsewhere, it is difficult to impossible to assess the real skills of the students prior to enrollment. If any such issues are present, a discussion within the department about how to make everything work is called for. It need not be confrontational. 

The song's name is called Haddocks' Eyes The song's name is The Aged Aged Man The song is called Ways and Means The song is A-sitting on a Gate 

OOP languages, however also provide a mechanism for the creation of objects. There are two main mechanisms for this (Classes and Prototypes), which don't affect the discussion here. I will assume a class-based languages since most (non javascript) programmers are most familiar with classes. In creating a class definition the job of the programmer is to define the behavior of its objects. In Java, that means the visible methods (visibility is a bit complex for this discussion, think non-private for a simplification). An object of the new class must be able to respond to a given message (with parameters, perhaps). That can be made to happen in different ways. For example, the object might defer the action to another object. But it might also define a (classic) variable, and give it a value. Having given that variable a value, it is free to retrieve it later and (perhaps) modify it. But don't be naive about things. Just because the name of a method is "setDisplay" doesn't necessarily mean that there is some variable (anywhere) that will have its value changed. It is a concept, nothing more. The object will somehow (up to the programmer) retain the value given so that the "state of the computation" can move forward. So, in this "pure"OOP view, the job of creation of objects is the job of defining the behaviors to which the object can respond. You can think of an object (if you like) as a bundle of state + behavior, but that should only work at the definitional stage, not the usage stage. Note that in this view, a computation is seen as a collection of independent objects that communicate via message passing. The objects may be normally active (actor model) or not, with the latter being more common. An object is, in the non-actor case, only active when it has been sent a message. It is easy to visualize that a PC comes along with any message allowing the object to execute the method. If the object sends a message itself, the PC is passed along as well, letting the receiver of the message act. 

Yes, I write a lot of classes. But each is simple to conceptualize and simple to build. Each object is a bundle of behavior, nothing more. 

If you are teaching assembly code or maybe Fortran then probably you need to discuss and possibly flow charts. However, if you are teaching a modern high level language, even something as old as Pascal, you should probably avoid them other than as an historic curiosity. This was settled almost 50 years ago, actually. Along with some other illuminati of CS, David Gries has always used the term "flaw chart" for the classic diagraming technique. It is too easy with such tools to create unmaintainable code. There is a form of Structured Flow Chart, however, which is not much different from, say, Pascal. It has no arrows, but, basically, only containment and sequencing of structures. But even that is probably just a waste of time as the constructs of modern languages make it unnecessary. Even if you are programming in a language that requires however, you should probably only use structures like and that have been proven to be sufficient and also result in better (maintainable, understandable) code. Just Say No. On the other hand, there is one reason for teaching to students of modern languages. If those languages permit then eventually the student will need to read programs that contain them even if they don't write such programs. So, purely as a defensive measure, they should know how to interpret these programs even as they disparage the authors of those programs. There is a story from the past that is illuminating. In the old days IBM had a company policy that every program had to be documented with flow charts. However, they also had a tool that would create a flow chart from a Fortran program. So, the program was written, then the tool produced its flow chart, often spread over many, many pages. But the policy was satisfied. But, as a design tool, no. See: $URL$ 

For paired/group work that does not involve just programming you should seek to assure that the members of a group don't just "divide up the work" between them, but actually work cooperatively on it for all phases. Students think that division is a great idea until they reach the point of trying to integrate possibly inconsistent separate work. On Agile teams, pairs work together, but the team's pairs work on different things. The daily Stand Up Meeting is the way for all of the pairs to assure that they all work toward the common purpose. So, you might institute a practice of daily face to face meetings in each pair/team so that if they work separately they do so only on small and easily integrated things rather than big chunks that don't necessarily fit together. 

Since the two languages are from different paradigms the difference in resulting code can be quite stark. For example, reversing a list in linear time in Scheme is quite a lot different than you would likely program it in C# with mutable data. But even Java and Ruby, closely aligned, are not the same language and have different thought patterns. It is the thought patterns that are the most important lessons of the various paradigms. 

Note that I often write an interface when I intend only one implementing class. Capture the concept first. Again, note that I often write an abstract class that has protocol (abstract methods) for every method in any intended subclass. This lets me capture a common implementation, but keeps my concept clear as I subclass. I never need to ask instanceof and I never need to cast an object reference. Everything naturally fits together freeing my mind to think of other (higher level) things. 

I'll try not to write a book as an answer here, but my experience with this is long and deep. The first thing you need to know is that you don't start with just the programming language itself. If you try to teach integer variables and 'if' and 'while' statements before you get to objects you may fail. I'm going to assume that your intention is to teach a first course that is also objects first. The students in a course like that might have no prior computing experience, though some will have. The key to a successful course is to teach object-oriented problem solving, and not an object oriented language. In fact teaching problem solving via programming should be the objective of any first course no matter the paradigm. You want the students to learn to use objects and you want them to learn to create objects and you want them to be able to define new kinds of objects. But you don't need to do those all at once. You can spread it out over a short period of time - days, not weeks. The key is proper scaffolding, written (or found) by you. The students work within a defined framework that can be quite complete (even Turing Complete). Another big idea that you want to believe yourself and teach your students is that an object is a "bundle of behavior." Never mind instance variables (fields) at the beginning and never mind getters and setters. Define for the students one or more kinds of objects and their behaviors. I've done this with most OO languages and all of them can be introduced the same way. I'll focus on Java for the rest of this, as it is the language of APCSA. It is also a good, though not perfect, OO language widely used in industry. I have a lot of experience with Karel J Robot (KJR) so let me describe how it can be used as an introduction, that might take half of the first course in computing and teach students how to program. It is not, however, specifically tied to APCSA, nor does it cover every topic needed by your students. But in about half the first course, students will be able to write serious programs that require deep thought. At the end, I'll try to list many of the things not covered. The KJR world is a simulation in which one or more robots can be created and which have a few behaviors. The "world" of the robots is a rectangular grid and one or more robots can occupy an intersection. An intersection can also contain one or more movable "beepers" that robots might pick up or put down. Infinitely many beepers (effectively a beeper making machine) is also possible at an intersection. A robot always faces in one of the cardinal directions North, South, East, or West. A robot can perform one of five primitive actions: move, turnLeft, pickBeeper, putBeeper, and turnOff. Those are your primitive behaviors and when the student begins programming, nothing else is known, though some additional things are revealed later in the course. In particular, a robot doesn't "know" where it is in the world. The world can also contain walls between intersections that will block forward movement and cause an error if a robot attempts to move through them. So, what kinds of programs can you write (using only and the primitives? Well, to a programmer they are pretty boring: Move forward three blocks, pick up the beeper that is there and return to the initial position and direction. The solution is just a sequence of primitive actions, of course: move(); move();... Students see a bit of syntax in the language and think in terms of the behaviors and nothing else. The learn about statement sequences, the most primitive control structure of programming (arguable, I guess). Next they get a much more complex problem (first day's homework), which if solved with only sequences of primitives is unwieldy. It is obvious that something better must exist. But if you choose that program correctly you can notice that there are patterns in the solution. Even in the first assignment the robot had to turn around twice and had to move three blocks twice. On the second day you discuss the homework and find the repeated sequences of instructions. Now you introduce a new class (their first view of a class) in which you get newly defined behaviors. This class is a subclass of the most primitive class. You are introducing inheritance (too early perhaps, but essential in KJR). The new class has a few additional methods: turnAround(), moveMile()... Note that it is too early to introduce parameters. All of the methods so far, and for a long way in KJR, are mutators, the state of the robot is changed in some way. But the notion of a mutator is in no way linked to any idea of a "setter." Now you have the basic framework of problem solving. Define a new class. Within it define new behaviors. Create robots with new... and exercise the new behaviors to satisfy some programming task. Note what is NOT done. There is never any speculative class writing. All classes are purpose built to solve some small part of a larger problem. The book talks about the decomposition process in detail. You are now in the third day of class and have covered three chapters of the book. The fourth chapter is much deeper and discusses polymorphism, largely by showing how the Strategy design pattern can be used to modify the behavior of a given robot without writing a new robot class. Instead Strategy classes (and Decorators) are used to build a much more sophisticated model of computing. This chapter requires several days. It introduces object-valued variables which up to now have only referred to robots. The fifth chapter introduces selection and there the student learns about booleans as well as the fact that robots also have some self knowledge. However, there are no methods returning information about the current location or explicit direction. A robot can respond true or false whether its front is clear (no wall) or if it is facing North, or if there is a beeper on the current intersection, etc. All of these accessor methods return booleans, so the student can now write conditional statements, which opens the door to more sophisticated exercises. These accessors are not "getters" either in concept or in fact. The sixth chapter is repetition, but note that the student already has a good knowledge of the nature of computer programming and they haven't seen any of the primitive data of Java other than boolean. loops are introduced here, so integers are used, but only in simple ways - step counting, for example. Later chapters (they are all pretty short) cover recursion and even concurrency. The key to all of this, however, was a well thought out scaffolding structure in which the students can learn deep lessons in a way that you can control and in which it is harder to go astray in the minute details that you find with integer operators, float/double, ... The point isn't to teach Java as a language, but how to think like a programmer - specifically as an OO programmer. The BIG idea Java defines a logically consistent virtual world in which students can program without reference to lower level (machine level constructs) and can create consistent mental models without having to mentally compile their code to bits. A well designed simulation defines a yet higher level virtual world that if (Turing) complete can be used without reference to lower level constructs to solve any problem. That is very powerful. Robots can sort (piles of beepers) for example. A slightly smaller idea is that you, the instructor, should think about what not to teach, especially at the beginning, as you do about what to teach. Teaching a complete subset intensely can be more powerful than teaching "the whole enchilada" at a shallower level. Caveats If the instructor skips the polymorphism chapter, students will come away with the unfortunate view that OO programming is all about inheritance as all of the robot classes must derive from a simpler such class. In fact, OO is really all about building "bespoke" or "tailor made" objects out of parts that are also objects. Skipping polymorphism also gives the impression that selection and repetition are all you need in order to know "how to program", that they are the real thing, an impoverished view IMO. KRJ is not the only way that you can implement this general course framework. The Greenfoot system is a simulation rich world in which you can build similar (or not so similar) things and use the same general plan. There is an associated instructor site, the Greenroom, to which teachers have contributed many simulations. The general idea there is a World in which Actors can move, turn, interact, etc. What is missing The big one is counting with integer variables (other than simple loops). One issue with teaching int and counting early is that from then on every problem becomes a counting problem, so students wind up with a poor mental tool kit. If you teach counting later, rather than earlier, students need to think harder about problems. You can "count" with decorators and encapsulate the actions themselves, rather than just the count in a (strategy) variable. You also can teach recursion without having to justify it as an alternative to counting. There is no discussion in KJR of many of the things we love, arrays, for example, collections, iterators, and such. There is a companion book that covers most of what would normally appear in a first course but it assumes the students can already write sophisticated programs. APCSA In the past Karel was used a lot by AP teachers, but the course has changed as has the exam. I've never tried to use it to teach APCSA. I'm sure there are many things missing that the instructor would need to add to a complete course.