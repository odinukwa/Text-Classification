The explanation is not very clear. You describe what are the nodes of the tree but what are the children of a node? 

A documentation string here is important. The names of the variables are so vague that even knowing the task in advance is difficult to understand their meaning. 

You can make the early stopping better (and maybe simpler) by checking that the current_sum plus the product of the remaining terms by the smallest term is larger that the target sum. You could also make the opposite check: if summing the larger possibile terms you cannot reach the target sum. 

There is no improvement which can be done on the code you show us. If the function really needs to be called for each combination of the parameters, there is nothing better you can do. You should try to optimizie the function, maybe it is possible to cache some part of the construction which is common if one of the parameters is fixed. For example you can pop the computation in the outer loop, so that you make it once for every Word (instead of once for every City). But I think this is a slight improvement. 

I think that the data structure and the organization of the code is far from optimal. You are making an interpreter with some sort of precompilation (the function which searches for brackets). The data structure used to store the "compiled" code is bloated. You have a doubly-linked list for something that will never dynamically change. The pointer is never used. The pointer is rarely used. What I suggest: 

In the original PongÂ® brand video game, there were two bats which were confined to move vertically. A collision would be detected if ball circuit was triggered at the same time as one of the bat circuits, and if the ball was not already moving in the proper direction for that bat. The ball's vertical speed would be set to an odd number in the range -15 to +15 based upon the number of scan lines of bat that were displayed before the collision was detected (basically the difference between the ball's Y position and the bat's position). What exact bounce behavior are you looking for in your game? 

Such an approach would allow the property to simply return a wrapper object, without having to do any real "work". Code which needs a detached copy of the list could use use , but code which will need it only briefly need not bother. 

Note that in a garbage-collected system, it's possible to add items to the start of the list, or perform the #2 style of deletion, in a lock-free thread-safe manner. Nodes which are deleted may get unlinked in one thread and accidentally relinked in another, but the delete flag will cause the node to be unlinked again on the next pass. In a multi-threaded system requiring explicit deallocation, such an unlink and relink sequence could be disastrous, since a node could be unlinked, deallocated, and relinked; locks would thus be necessary to avoid problems. 

You code is quite efficient and well designed. I think you can get a little bit more efficiency at the cost of making the code more specific to this particular task. In particular there are some shortcuts: 

You can move a window by increasing as long as the window does not contain all terms, then increasing as long the window contains all terms. This will find in linear time all possible windows containing all terms. Then take the shortest one. Here is an implementation: 

You are using the float value -1000.0 as a sentinel to represent null values. In a real project this is a very dangerous design choice! Your program will give unexpected result if -1000.0 is a value coming from the interpolation or from user input. To overcome this issue you could use two varibles and to mark the interval of non null values. Otherwise use a FLT_MAX instead of -1000.0 as a sentinel. This is very unlikely to cause problems. 

For each token you are describing a triple of sets (pairs,suited,off_suite) which are parameterized over a value. It would be nice to have a code like this in your : 

use a single call to followed by a call to to get the same result. In the rest of the code I would suggest to take advantage of the fact that characters have consecutive ASCII codes. This would simplify (and speed up) the code significantly. In this case you would silently assume that alphabet is given by ascii codes from 'A' to 'Z' and to find the index of a character in the alphabet just compute . Of course this won't apply if you plan to differentiate frequency of lower/uppercase characters... but it would not be too bad to extend your frequency map to all 128 ASCII characters to anyway take advantage of this hint. 

Contrary to what some people say, there is nothing fundamentally wrong with having an inheritable immutable class provided that the inheritance contract dictates that if two or more instances are ever regarded as equivalent, they must always and forevermore be regarded as equivalent; further, the class must work correctly without complaint or visibly altered behavior if some or all references to an object are replaced with references to a object which is considered "equivalent". A class won't be able to prevent the definition of illegitimate derived classes that violate its inheritance contract if its methods aren't declared , but since it won't be able to prevent the definition of illegitimate derived classes even if its methods are , so making the methods doesn't particularly matter. What does matter is that the inheritance contract specifies that all derived classes must be fully immutable not only in their inherited fields, but also in all observable characteristics, inherited and otherwise. If a derived class doesn't abide by that contract, code which uses the derived class might malfunction, but the fault will lie entirely with the derived class that violates the contract. It is probably a good idea to make immutable types if one doesn't want to specify exactly what will be required and may be expected of any derived types. There are, however, many situations where it may be helpful to have an abstract base class or interface which specifies that all legitimate derived classes or implementations will be immutable. For example, one might define a class or interface with members to get the dimensions or read the cell at any (row,column) coordinate. Although the most common implementation might use a 2d array as a backing store, there are many different ways that derived classes might store information. If were a class which used an array as a backing store, then all objects that were usable as type would have to have a backing-store element for every cell even if 99% [or for that matter 100%] were blank. Making it a non-final class would make it possible to define derivatives like which could use a much simpler backing store. 

Here the complexity is too much... we have four variables plus the three of the enclosing function: very difficult to keep track of all of them. is repeated. should be the return value. 

invert the two lines above, so that you can use size in the previous line. Why to use instead of ? The name of the variable is not very good for my taste: it is not "sorted" (maybe it is "sorting") and what does "indice" means? Maybe you mean "indices"? 

(added: the difficulty to achieve a DRY result is an indication that the variable could better be an integer in which can be used as an index in the "OX" string.) Two. This: 

is a thing I would avoid. Since the program is so clean and self contained, I would keep it as abstract as possible. Maybe in 5 years there will be an OS which could run python happily but which does not have a 'clear' command... what a pity if your program will break for such a triviality! And if you insist in using a system call, wrap it in a function, don't write it twice! 

even if you have only a single option it would be good to write your code as if there were many. This could be simpler to understand and easier to extend. I would keep the options (in your case which you could transform in a boolean variable ) as global variables, and parse them in a dedicated function. Once you have extracted that code from the main function you will feel more eager to add other options (for example --help to print the usage message). You function is definitely too large. Extract the arg parsing code. Put the logic into a separate function and let main just be glueing code. Here you are reinventing the wheel: 

one would then be able to infer that because at least one of the 4's was correct, at most one of the other numbers could be correct. 

Of these, perhaps the first would be most justifiable if one says that degree-polar objects are unequal to any xy object except when the angle is a multiple of 90 degrees, and radian-polar objects are unequal to any other object except when the angle is zero. Even though the closest to the polar-degree object's x coordinate is 1.4142135623730951, the actual x coordinate is closer to 1.4142135623730950488016887242097, so it won't quite match any point whose xy coordinates are specified using a . Unless there's some particular reason for using polar coordinates, I'd suggest having the type explicitly encapsulate an and , both of type . Use fields for those and set them in a private constructor. Even if you have other methods which can construct a point for a given radius and angle, or report the radius and angle associated with a point, make it clear that reported values are not inherent properties of the object, but simply calculations based upon its x and y. 

Implementing a precise atof function is surprisingly difficult since there is no limit to the number of digits code may need to read to ensure correct rounding. Consider, for example, the following two values: