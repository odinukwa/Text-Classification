For better boot times, update the firmware (with rpi-update), install the system with hard-floats and keep it updated. Older firmware are usually slower, hard-floats increase a lot the system speed, every day there are more optimization for arm, specially for rpi 

First, running or on boot is useless, as you are already running as root. Only if you want to run as a different user you should use the . You may doing this to setup the login root , but then the command is As for running the command, use 

Just to cover all ground, also check if your power supply is good enough. try other charger or plug the RPI to a PC USB port to test it. Remember that the recommended RPI supply is about 700mA, but some weak chargers might not sustain this at stable levels. I had a router that start to act crazy for some days, then went ok, then again went crazy and later fine again ... i found that the power supply was outputting changing voltage (3V to 5.5V) on the time the router was crazy. Replaced that supply with a new one all is fine. So try replace the power supply and measure the output voltage. Finally, turn off the RPI by shutting down the OS and only unplug the RPI when you got only one red led. the RPI is not really shutdown if you have other than one red led. Also, try to avoid disconnect the rpi by removing the power supply from the plug, it's better to remove the power from the RPI and only after remote the power supply from the plug. 

If you want a share to use in windows, forget NFS, go to samba... NFS can work in windows, but every time i tried i had problems with it (with external tools, with MS Windows Services for UNIX or with more recent windows server 2012). All are really just hacks to windows, not even MS gave me enough support when a NFS start failing on a server after 1 year of use. Samba just works, windows know how to work with it, no problem ahead. Performance, a tuned samba can be as fast as a NFS. Many small files is always a problem with samba/cifs, but that is a protocol limitation. 

I just grabbed a audio cassette box and cut the needed slots using a small saw. I recommend to glue some tape on the cutting zones, not only to mark the cutting places, but also to helps to avoid breaking the plastic when cutting. Its a simple case, but easy to build and manage. grab a transparent cassette box and you have a pretty case for free! This is not my case, but its a reference:: $URL$ 

A popular choice is the DS18B20 1-wire sensor. The link is an example, not an endorsement. It only requires three connections to the Pi (one gpio, ground, and 3V3 power) and a 4k7 resistor between the output line and 3V3. It has Linux kernel support so reading the sensor is simply the matter of reading a file. If you search the site for DS18B20 you will find plenty of examples. 

You would need to ask Adafruit about which GPIO are available when using that HAT. $URL$ has details for some HATs. Some HATs propagate the header pins on the HAT itself. If yours does that will make it easier to get physical access to the GPIO. 

That will be fine and will work as long as the transistor needs 3V3 or less to trigger. Of course you need to connect a Pi ground to your circuit ground so there is a common voltage reference. In the circuits I have seen a series resistor is used to limit the (base) transistor current. 

I suspect you are using lower value resistors if the Pi LEDs dim. I would wire a GPIO direct to NO and connect ground to COM. Set the GPIO to be an INPUT and enable its internal pull-up to 3V3. The GPIO will read back as 1 when the switch is open and 0 when the switch is closed. If you connect to NC rather than NO the read values will be reversed. 

The Pi has two hardware PWM channels. Channel 0 may be fed to GPIO 12 and/or 18. Channel 1 may be fed to GPIO 13 and/or 19. GPIO 12/13/18/19 are brought out to all Pis with the 40-pin expansion header. My pigpio library supports use of the hardware PWM pins as well as providing hardware timed PWM on all the GPIO (equally suitable for motor speed control). I have no idea how easy it would be to integrate pigpio into your environment. You mention Java. There is a Java library called Pi4J which might be suitable. 

If we accept the Adafruit technical specs, and you bought the dongle from Adafruit. 1) Leave the red (5V) lead unconnected. 2) Connect the black (ground) lead to P1-6 (Pi ground). 3) Connect the green (TX) lead to P1-10 (Pi RXD) 4) Connect the white (RX) lead to P1-8 (Pi TXD) $URL$ for Pi pin numbering. Even if TX/RX are mislabelled you won't harm the Pi. I've often connected them the wrong way around. It just doesn't work. Don't try to power the Pi with the dongle. It won't be reliable even if it works at all. 

Servos require accurate and regular pulses. More accurate than software timing will provide. If you want your servo to stop twitching you have several choices. 

I've posted more on this on a few other questions, but this should fix your issue without resorting to drastic measures. 

This will cause the user 'pi' to not require a password for ANY sudo invocation. BEWARE! This can be considered a security risk. Balance your need for this usage against the potential risks involved. (see man sudoers) 

Would wake up the screen. (Well, should... works for me(tm)) (Do remember that you'll need to either set up nopasswd access to sudo, or be prepared to type the root password when you use this command) But wait! If you call now! We'll include this gem: How to remove the need to supply a password for sudo usage! Operators are standing by! Add this line to a file named "no-sudo-passwd-for-pi" (no dots allowed!) in /etc/sudoers.d/ 

Try disabling the console blanking. I put the following in /etc/rc.local to turn off the automatic blanking that is on by default: 

This command resets/clears the screen, returning to text mode and turns off the blinky cursor. handy when I don't want the distraction. 

Perusing the sample 'everything' config file found at: /usr/share/doc/wpasupplicant/examples/wpa_supplicant.conf.gz It looks like in a network block would be useful: 

This sends setterm's output (magic codes!) to the proper terminal to wake it up as you desire. Since I do this often, and use other options too, I made a little script I call 'tty1' 

The command has to be run so it outputs to tty1, and you can't do that (easily) from a remote connection. I use a small script to send setterm commands to tty1: 

(entire file here to show exactly where I put it) Essentially, the setterm -blank 0 command sets the terminal blanking period to 0 seconds (off), disabling the blanking which usually occurs. rc.local is executed at the end of the boot process with root privileges so it affects all the physical consoles (the TV & HDMI outputs here) You could also change the command to include turning off the cursor (not the mouse pointer, text cursor in console): 

should unblank the screen from a login, BUT... usually you need to send the appropriate codes to /dev/tty1, not the /dev/pty/X you're using as an ssh user... thus: 

The command splits (tees!) its input into two streams, one going to a file specified on the command line, the other to . In this example, I've used the ability to specify a filename to write to that file with sudo privileges, and discard the duplicate output going to stdout. 

to turn off the blinky cursor. If you're connecting via wireless and are having connectivity issues, I'd recommend disabling the wireless power saving options, which turn off the wireless dongle if nothing's happening for a bit. Annoyed me greatly. (I've posted a longer answer explicitly for this here somewhere, but I'll paraphrase here) Create a file '8192cu.conf' in /etc/modprobe.d: 

Servos do not require a motor driver board (the servo itself incorporates a driver board). You just need to supply power via the power and ground wires and a control signal via the control wire. The control signal is generally a pulse between 1 and 2 milliseconds long transmitted 50 times per second. The length of the pulse determines the servo angle. You can generate the needed pulses from the Pi. If you use an external power supply you need to also connect the Pi ground to the servo ground. You can connect the servo control wire direct to a Pi GPIO. My pigpio library can control the servo. Alternatively you could use servoblaster or one of its forks. 

It depends on the environment the camera is operating within. Some people have had success with 4 metres (probably more, I haven't looked through the whole thread again). See $URL$ for stories and potential vendors. 

Nobody knows the effective limits for software or hardware. For software PWM you would have to define the number of steps between off and fully on you need for the dutycycle. Generally I'd expect a practical limit for software PWM of about 10kHz. Software PWM will suffer from jitter so it's probably okay for DC motor speed control, but little use for servos or LEDs unless you can ignore glitches. The hardware PWM limit is down to how well your Pi was manufactured and the quality of the silicon. The hardware pads are designed to work up to say 25MHz. pigpio will let you set frequencies in the range 1 to 125MHz. I don't expect anything above 30MHz will actually work. 

My pigpio and the bcm2835 library will both be faster as they don't use the Linux SPI driver. I think the Linux SPI driver tops out at about 20k calls per second on all but the Pi3 where it reaches about 70k calls per second. I don't understand why the Pi3 seems so much better. pigpio 

To enable SPI just add the line to . Nothing else is required. You should see the SPI devices in after boot (try ). I2C needs a similar device tree entry in /boot/config.txt AND the line in . There is no problem in loading and using I2C and SPI at the same time. They use different GPIO. 

I wouldn't attempt to remove them manually. You can see YouTube videos of it been done successfully but I reckon the guys have the right tools (and they don't say how many they have ruined). element14 have a customization service. Minimum order 5000 units. 

I use a UBEC like that. I carefully cut off the signal part of the socket so I could fit it over the 5V pin adjacent to the ground pin. 5.3V will not harm your Pi. I have measured 5.8V on my Pi test points. The only concern would be anything connected to the USB ports. EDITED TO ADD: The Pi I'm currently back powering via the USB ports is showing 5.55V between TP1 and TP2. 

Old thread, I know. I've written a utility I call , which forwards your keyboard (and soon, mouse) to the console of another computer you're ssh'd into. This allows you to view your RPi's display (for instance) on a TV or monitor, and type as if you were logged into the physical device with a keyboard. Considering everything in my house is wireless, it's rather neat to sit on the couch with laptop and type away, seeing it happen on the big screen on the RPi. Feedback welcome, fauxcon - Github - $URL$ 

Old thread, I know. I had a need for this exact situation, so I wrote a program for it. Using , I forward my ssh connection to the console keyboard (and soon, console mouse too!). Effectively, it connects your keyboard directly to the RPi, as if you were typing on a USB keyboard plugged into the RPi. Certainly interesting to type on my laptop, and see the output on the bigscreen, as if I were typing on the RPi itself. I have some plans for this utility, it's usefulness is growing as I play with it. I'm planning on forwarding the mouse events too, so really you could use keyboard & mouse on a remote computer (not just RPi!), great for demonstrations and show&tell type things. Disclaimer: I wrote this. Good, Bad, or just plain Ugly, it's my fault. fauxcon - fake console connection 

It's the console blanking that is kicking in. I tried several suggested methods, but the one that worked for me was to edit /etc/rc.local and add a setterm -blank 0 command: 

Next reboot, it'll turn off the power saving for the wireless. I've had rock steady connections since this. Um, if it means anything, this is for a generic edimax wireless micro-dongle, the teeny-tiny one. lsusb output: 

Old thread... I know. I've written a utility I call , which forwards your keyboard (and soon, mouse) to the console of another computer you're ssh'd into. This allows you to view your RPi's display (for instance) on a TV or monitor, and type as if you were logged into the physical device with a keyboard. Considering everything in my house is wireless, it's rather neat to sit on the couch with laptop and type away, seeing it happen on the big screen on the RPi. Feedback welcome, fauxcon - Github - $URL$ 

The shell interprets and handles redirection before the command is executed. So the redirection (>/sys/class/leds/led0/trigger) is attempted with the user's permissions, thus fails. The generally recognized solution is to use the command: (man page and wikipedia) 

I've been playing with Wii controllers, they're bluetooth, good resolution and cheap. No harder to interface than the I2C and GPIO methods, easier for me as I had already been working on bluetooth interfacing for another project. And the bluetooth dongles are inexpensive too. If you get a newer Wii controller, they've got substantially improved accelerometer output due to the Wii-max or such, I forget the name. There's also the multitude of buttons and the IR sensor you get in the package. Quite entertaining.