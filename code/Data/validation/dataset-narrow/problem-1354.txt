There are one major source of open sourced models for Ogre3D available: WorldForge Media Repository WorldForge assets are licensed under the GPL, meaning that you need to contribute back any changes, but you're free to use the models in any project, closed source too. Then, a repository not directly available in Ogre format, but very useful none the less: Ryzom Asset Repository Ryzom assets are licensed under the CC by Sa (Creative Commons) license. 

A good resource manager is key to how well - and how flexible - your game 'engine' is going to be. Not only does it solve a lot of problems with low level resource management, but it also helps to ensure that resources are loaded only once, and then reused if they are already loaded. If the resource system is abstracted well, the underlying details can wary between file system, physfs storage, sql even... You just request a resource, and it's given to you. No need to worry about resource IDs and stuff like that. Duplicate resource conflict handling, etc. Let the resource manager sort that out. Depending on how you design it - if C++ then make friends with your scenemanaging class(es) to ensure that ownership is properly handled. Resource pool ? No problem. Forgetting to release resources? No problem. Same interface to resources no matter where they are: memory, disk, archive, network. No problem. Do you want streaming? Threading? Let your resource management hub take care of that. And you can rest assured that it will inform you when the resources are ready to be used. Ogre 3D has a very flexible resource management system, but I am sure there are others 'out there'. 

My advice would be: Do! But only if you have a use for it. No need to create a DSL if you are just going to use it yourself - internally. Galaxy is the scripting language which the Startcraft II editor is using. It's a prime example of a domain specific language. It targets game designers rather than programmers: 

I know this topic is flagged as 'solved', but IMO you should look into FBX. Autodesk is using that format, and it's the exchange format of all the major 3D programs. So don't bother with Collada. It's bloated, unintuitive - and not backed by the major players. Which is Autodesk - they're are buying pretty much every 3D app out there. Autodesk FBX SDK: $URL$ 

$URL$ I agree with these remarks and think it is a stellar discussion of why DirectX is better than OpenGL. That journal is in response to David at Wolfire. I hope that serves to balance it out a bit. ;) But in general, if you're using a cross-platform, cross-API framework: Use DirectX on Windows and OpenGL on *nix. 

Sample Tutorial Lisp is the perfect language to use to create domain specific languages, but there's other options, of course. Like Boo. That way your designers/modders don't have to learn programming, even if it's just Lua, it's still programming. Edit: Let me add that a DSL can be implemented in a scripting language - it's not synonymous with not using a scripting language. Especially if you are using Lisp or similar, since it lends itself extremely well to create domain specific languages. 

Globals are much faster! So it would fit perfectly for a performance intensive application, like a game. Singletons are a better global, IMO, and thus the right tool. Use it sparingly! 

May I suggest that you buy the book Artificial Intelligence for Games by Ian Millington - it's excellent! :) $URL$ The source code is at Github - MIT license. Of course, if you're not using C/C++, then this might be less relevant. But really an awesome introduction to the world of Artificial stupidity/intelligence. Things you're going to need from it are steering and state machines. For starters. 

There's this cool project called Pseudoform, formerly known as 'Portalized', which handles physics simulations using portals in a groovie fashion: Pseudoform Check it out! Especially the videos - it's staggeringly cool. It's open source, so you get to see how they do it. I bet that's what you want. :) 

I have problems with that too, actually. Let's say you have a Game. Instead of making 'Game' a state like 'Loading', 'Main Menu', etc. - IMO it's better to let Game have several states: "Loading" - "showing menu" - "paused", etc. The Game is still running, but when it shows the main menu it would be in 'show menu' mode. And when Game is not in any particular state, it's just running. It makes much more sense, at least to me. :) 

Take a look at this OpenGL getting started page: $URL$ You'll see that The Communist Duck is right: it's just a matter of downloading a header or two from the extension registry: $URL$ However, as he also said, it might be easier for you to download an extension handler which does all the gritty work for you, like GLee - or GLEW: GLee : $URL$ GLEW : $URL$ 

Copying my comment up there on why you do not get the proper result your way : Lerp(A,B,C) returns the interpolated value placed at (C*100) percents between A and B (in that order) If you use what you wrote every frame this is what happen : CameraPosition gets incremented, and then that incremented value is passed (in the next frame) as parameter to the next frame incrementation. Lets admit that instead of Time.time you used 1, you would get : 

Actually Lights does not contain colliders, but what you can do is add a CircleCollider2D component to a light, then track if your object collide with the collider of this light and only then trace a ray from your object (character) to the light, if the ray hits a collider before hitting the light then you know your character is in the shadow part of this light! I am not sure you could go away with this without using raycast2D, but dont be afraid once you get a hold on it it can be very straight-forward. For example to put on your character : 

Unity (or any other 3D engine i believe) is not using pixels for positioning objects in space (maybe mostly because there is no Z axis in pixels and also because it brings thousands of other issues) Unity uses Unit system (i personally see it as metric) you should take the unit cube as one meter, this means few things : 

Why multiplying by DeltaTime might fix the issue?? : Because AddForce() ADD a force to the sum of forces applied to your rigidbody, and then each force applied will diminish with time (except if you have no gravity and even ther i'm not sure) and if used in Update() it will add every frame the amount of force you want but frames are NEVER evenly timespaced so sum of forces will have different value each time you apply a new force so even if you add every time the same force, because you do not add it at the same interval of time it will stutter. What delta time does is that it will multiply your force by the timespan between the previous frame and this one so the final value will compensate this timegap between the two frames It is worth noticing that in this particular case you might try : 

In unity, SortingLayers (or camera layers for that matter) are not groups of object you should see them as tags : specifically for the sprites, sorting layers are used to define the order of render of the objects. you can go through all the sprite-renderers and check their layers and apply something to their transforms but that will consume "a lot"* of resources. better solution is to really group your objects by parenting them to the same transform, and then you move that transform. For ex : 30 objects and you want to make three "layers" (but once again it is parallax layers not sorting layers (they can be related (you want stuff to be drawn in order) but are not the same thing)) what you would do in that case if create three empty game objects and drag 10 object onto each of them, then you'd move those 3 game objects according to the camera to achieve the parallax effect 

Actually for that particular case for future reference i want to add as answer that restarting my computer did gave me 60FPS after reboot on the emulator, without changing anything, with more optimization it could go even faster. @concept3d answer is still the valid one though and the article about why FPS is an incomplete indicator is a perfect reference 

Either two sprites backing together, or a custom shader with no Backface culling could be the way to go, you could use a mod of the original sprite shader which is here : Unity Built-in Shaders (select the last version and you should find them in the same order as in the menu) I did a shader once with a different texture on each side, with the same vertex count but i'm not close to my code right now. EDIT : If you go for the custom shader dont forget to create a material and associate it with your sprites. I just realized by the way that there could be an issue with the fact that the Sprite renderer accepts only one texture, but you could trick it by making a texture with the front and back on the same texture, and then offsetting your UV's to match the correct positions. 

So for the same force applied the velocity of the point where the force is applied will be the same, knowing that : If the diameter change but the force stays constant, a smaller diameter means smaller perimeter so less way to travel to make an angular degree so the angular speed in degrees per seconds will be faster with a small diameter than with a large diameter for exactly the same force applied! More math frenzy definition at wikipedia