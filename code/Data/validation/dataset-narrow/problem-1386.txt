Set all of your GUI objects' layer to "UI", and your GUI camera's Culling Mask to UI only. The GUI camera's Clear Flags should be set to Depth Only. The scene camera's Culling Mask should be set to everything but UI. UI Camera's Depth should be set to 1, Scene Camera's Depth should be set to 0. 

What I think should happen is the environment should be baked into hidden geometry which qualifies as cover. Then, I would detect sphere collisions (blue) with the generated cover areas (purple) to find out when one is in range. 

Vertices are stored in memory using local coordinates. So no vertex has a "currentPosition," they're always positioned according to their offset from their original origin. In the "world," they are displayed according to some transformation: scale and rotation about their local origin, then translation with respect to the world origin. With the exception of static level geometry, vertices are almost never stored in a current position. So, to get the "current" position of any vertex, you must apply a transformation to it that takes it from local to world space. Applied to all vertices, you need only find the vertices with the greatest Y coordinate. It's been a while since I used XNA, but going off of the MSDN docs it should look something like this: 

If you need to store entities in chunks it's probably better to actually store them in the chunks rather than a separate array. 

However, these two options are probably overkill for what you're going. Keeping with the YAGNI principle I strongly suggest sticking with specific modifiers like you've stated. 

Edit: Okay, with a little bit of testing I'm prepared to revise my answer. Going from 2D to 3D, you must now consider that "Y" isn't always going to be up. When you try to treat 3D as 2D, you can actually make things a little more complicated. So I'll do it both ways and you can decide which way works better for you. 2D in 3D As usual, we want the direction vector from our current position to the target. 

I've used forward/backward momentum here since it's easier to describe, but the same principle applies to lateral movement and turning. In order to turn, they need to shift their weight counter to the direction of the turn while moving forward or backward. 

You can still maintain the Chunks in row/column format elsewhere, but this way each chunk will be aware of its neighbors as well. When an entity leaves its CurrentChunk's Size bounds, remove it from CurrentChunk, add it to the corresponding neighbor, and change its CurrentChunk. You'll have to repeat that, of course, if an entity somehow moves an entire chunk's size in a single frame. 

If you are creating it from a different object, you will have to figure out which object it is and create it from there (ie: 

I just implemented in C a way to calculate the angle between two vectors A,B, given an origin C. Look at this Wikipedia article to understand where I am coming from. Here's the pseudo-code: 

It's probably not the "proper" Unity way to do it, but it should help you understand how to calculate the angle between two vectors (if that's really the question you want answered :P). 

Another method (which I answered the question Byte56 linked to) would be to check if the collision resolution puts the character in an empty spot or not. So in your problem, you get a collision from the inside rectangle's ceiling to move it up, which would be illegal (as you're still in collision with another tile). Instead you only move it if it you're moved into a free space (such as how the collision from the upper tile would move you to the left), and once you find that collision, you are done. The answer I gave had code, but it became overly complicated. I'd keep track of all collisions within that timeframe and only take the one which lead to a free space. However if there were none, I think I resorted to resetting the character's position to its last position, however that's really ugly and maybe you would rather try implementing something like the original Mario where he just moves in one direction or something when no free space resolution is possible. Also you could sort that list of collision resolutions and only move to the freespace with the shortest distance (I think that solution would be the most preferable, although I didn't code for that). 

This question concerns the order of events (when they are relatively called to one another). My answer takes advantage of the fact that mouse click events occur between Begin Step and End Step events. That means one solution would be the following: 

Have an obj_controller (bad name and design practice, but fairly commonly done with GM) that has a variable and a variable. In obj_controller's Begin Step, set and to false In obj_controller's Global Mouse Left Pressed event (this would indicate there has been a hit somewheres on screen, possibly a misfire, possibly not), set the variable to true Have an object called obj_clown that is the target your user is trying to hit. In obj_clown's Left Pressed event, increment score, tell obj_controller that there has been a verified hit by setting obj_controller's variable to true (this can be done using the following GML: 

Try using Stopwatch to capture a start and end time at the beginning and end of your Update method to find an average time spent in Update. Then, add a branch to a breakpoint when the time exceeds the average by some threshold and take a look at the program state at that time. You might consider recycling your objects by moving them to a pool, instead of simply forgetting about them altogether. While it probably isn't the GC interrupting the flow, it worth checking out. Also, try building the game in Release mode instead of Debug, if you haven't done so already. 

Toggle returns the current state of the button - either the same state passed in value or the new value as changed by the user. So a better pattern would be... 

You can add wall-specific information to the Wall class, Tile specific information to the Tile class, and further refine conditions in the "CanGo" method. For example, when a wall is actually a locked door - say, a Door class. In order to draw this, you would start with some arbitrary tile - say the tile in the middle of the current camera position. Then move toward and to the left of the camera according to the size of the tiles. Then do a breadth-first traversal of the IMapFeature nodes, drawing each wall/tile in the order encountered. A* will work on this structure, though you would obviously need some modifications to handle something like locked doors. If you wanted to, you could also maintain a spatial index of the tiles, which would implicitly include the walls, in order to find out which tiles were within camera bounds. You'd still only need to pick a starting tile and a distance to traverse based on tile size. 

This is why trademark law exists - to prevent brand confusion. If someone actually buys your app thinking it's the other app they heard about then you've harmed the other app's business, or vice versa. It's also kind of rude to use a name someone has already published, particularly when publishing has an associated advertising cost. While you might have thought of using the name first, they may have invested money (or time) into that name already. Thus, you would effectively steal the benefits of their advertising money as well. 

WASD is just a de facto standard for FPS games. If you play an FPS from the pre-Half Life era, you'll end up with all sorts of variations. That said, the analogue from 5DoF to 6DoF is jump/duck, which varies for each game. Case in point, Quake used jump and duck for up/down movement underwater, even though it used arrow keys for forward/back and turning, with alt+left/right for strafe. The original 6DoF FPS, Descent, had flight-sim like controls and used the +/- keys for up/down. 

If you are creating/spawning the bullet from within the obj_carrier that is to create the bullet (ie inside its step event, or alarm event, etc), you can just use x and y: 

), and destroy itself (so the clown is gone). In obj_controller's End Step event, check if is true and is false. This means there has been a click somewheres that isn't a clown (because the clown would've told it that the hit was good) and we can decrement a life 

You may want to change the y to say y + sprite_width/2 (or - depending on your coordinate system) so that it checks to the left of the middle your sprite instead of the top (or bottom). This is how N implements wall checks for wall jumping (last paragraph). After that you must decide on how tight you want your wall jump. If the vertical velocity of your jump overcomes the horizontal before the player is able to reach that same wall again, you will not be able to wall jump up the same wall and will gradually fall back to the bottom (like in Mario games with wall jumping). If you do allow the horizontal to be weak enough for the player to get back to the wall, he/she will be able to progress up the wall (like in Meat Boy). Another approach not mentioned is Super Metroid's. In that game when you are against a wall, if you move off that wall a very short "moving off wall" animation will play. If you jump during that animation, you will do a wall jump. (Super Metroid also allows a player to climb up a wall using wall jumps, but it requires a bit of skill (in fact everything about wall jumping in Super Metroid requires a fair bit of skill...).) 

I have a few questions before I start answering this. First, in the original bug in which you got stuck in the walls, were those tiles on the left individual tiles as opposed to one large tile? And if they were, was the player getting stuck in between them? If yes to both those questions, just make sure your new position is valid. That means you'll have to check if there's a collision on where your telling the player to move. So solve the minimum displacement as described below, and then move your player based on that only if he can move there. Almost too under the nose :P This will actually introduce another bug, which I call "corner cases". Essentially in terms of corners (like the bottom left where the horizontal spikes come out in your .gif, but if there were no spikes) would not resolve a collision, because it would think that none of the resolutions you generate lead to a valid position. To solve this, simply keep a bool of whether the collision has been resolved, as well as a list of all the minimum penetration resolutions. Afterwards, if the collision has not been resolved, loop over every resolution you generated, and keep track of the maximum X and maximum Y resolutions (the maximums don't have to come from the same resolution). Then resolve the collision on those maximums. This seems to solve all your problems as well as the ones I've encountered. Here's the code I use in my update: