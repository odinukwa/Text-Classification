There are times where it makes sense to use some level of coupling between the server and client side exchange of data, particularly in a conversation. But generally I've usually followed the notion that the underlining numeric representation has no relation between one another. As an example: 

Before addressing the specifics of your question, I do want to point out that I disagree with your approach to your inheritance model. A generally does not implement a but instead a consists of one or more active s that are being rendered and updated in a main loop. It's important to think about whether a class relationship can be described as has-a versus is-a. In the former, it implies composition and therefore a property/variable of the class. In the latter, it implies inheritance. Therefore as I said, a game has a list of active scenes so the code might look like: 

There isn't necessarily a reason to have all these action classes you are defining but instead have a component that represents specific state about a certain use case. So your movement component has a series of booleans that indicate forward, backward, left, right, etc. Now each game tick, you have system that inspects all movement components and sees what their current state is and calculates a velocity and direction and passes that to physics for simulation. In the case of players, your PlayerController interprets keyboard/mouse operations and sets state on the movement component. Similarly your AIController interprets behavior tree results for AI and sets appropriate state on the movement component. From this point, they both follow the same path of execution through the movement system which interacts with physics. 

It isn't uncommon for parts of a code base to be considered cornerstone objects or a foundation class, but that doesn't justify it's life cycle to be dictated as a Singleton. Programmers often rely on the Singleton pattern as a means of convenience and pure laziness rather than taking the alternate approach and being a tad more verbose and imposing object relationships between one another in an explicit manor. So ask yourself which is easier to maintain. If you're like me, I prefer to be able to open a header file and briefly skim over constructor arguments and public methods to see what dependencies an object requires rather than having to inspect hundreds of lines of code in an implementation file. If you had made an object a Singleton and later realize you need to be capable of supporting multiple instances of said object, imagine the sweeping changes needed if this class was something you used pretty heavily throughout your code base. The better alternative is to make dependencies explicit, even if the object is only allocated once and if the need arises to support multiple instances, you can safely do so without such concerns. As others have pointed out, use of the Singleton pattern also obfuscates coupling that often signifies poor design and high cohesion between modules. Such cohesion is usually undesirable and leads to brittle code that can be hard to maintain. 

A model often refers to it's geometric data such as vertices (aka mesh data) and it's rendering properties commonly refered to as materials to give you the actual rendered object. A single model can reference multiple materials where a material describes the blending algorithm, texture data, and shader references that combined together yield what finally gets rendered for a particular subsection of a model and other various rendering artifacts. It's important that your shaders are kept separated like this because you likely will reuse a shader on multiple models or objects in your scene. For example, I have a shader that fades an object in and out of a scene based on opacity. Such a shader is useful for transitions as objects come into view or leave view for various reasons. 

It's typical than an Entity System will duplicate some data. Some solutions I've seen is that the Position component contains a transform representing the world position & orientation of the entity. The renderable component has a reference to the position component, as does the physics component. In other designs, the renderable system and physics systems connect to signal emitters on the transform component or register for some event/message notification when the position is modified. When such a signal/callback/notification fires, the renderable and physics components both update their internal state by copying the vector from the position component. By duplicating the data, you eliminate coupling, can avoid using pointers which often can be a source of bugs if a dangling pointer isn't cleaned up and has some benefits to potential running various updates in parallel without contention (ie: can run physics while rendering allowing physics to update the position but the rendering can render to the old location until its safe for the renderable to update its position value). Also keep in mind that you may be creating the position component first. If you expect your position component to have a scene node or sprite position pointer but you haven't created the renderable component yet to allocate a scene node or a sprite component to create a sprite object, then you have no pointer you can yet reference. Now you've imposed a dependency order needed on creating & adding components to entities. I generally prefer to avoid this and have some dependency check system in place when adding components that allow them to link up as they need in a special init phase for an entity. Lastly, there is nothing stopping you from creating a Mesh component that allows you to 

You could consider inverting this approach where a system acts as both a factory and the place where your update logic resides. These systems are updated in a deterministic order and perform small sets of operations on a large bucket of entities based on criteria. This often yields faster and more cache friendly operations. Essentially that update logic above could be pushed into a series of systems like this 

Many problems can always be solved with a bit of decomposition. First off, if your target is the MMO space, then I suspect you either elected to create your maps in continous connected zones much like World of Warcraft's world maps are designed or they're separated into zone-based maps much like GuildWars2. In either implementation, a map includes area triggers that signify sub-areas or sub-zones within that map (terminology is entirely up to you). So if you combine the characterId, mapId, and areaId; that can easily describe an entry in an exploration table on the server side. When a player enters a particular map, it's the server's job to query this exploration table and send the client information about what the player has already explored so it can update it's world map state, etc. As the player navigates throughout the world, the area triggers fire and check whether the player has ever visited the area. If so, nothing happens. If not, the server updates the player's exploration state, sends a packet to the client so that it can do the same and perhaps inform the player they've discovered the new area. At some checkpoint on the server side, the exploration data held in memory will be committed back to the database. Such a narrow table can easily hold millions of rows with little overhead. But it's important to note here that it's the server's job to detect when new areas are explored and to simply send visual information to the client. In no way does the client update any of this state on the server. It's all transparently done based on the player's current position in the map and the area trigger objects defined by the game map design team. 

I come from the mindset that components contain nothing more than data. Depending on your game, that data is derived from static files that ship with the game to sometimes being combined with the information sent from the game world server to your client if we're talking about networked games. That implies that rather than components generating anything, I prefer to offload that to systems. I prefer this route because it sometimes makes sense for a component to be shared across a few systems and rather than trying to muck with managing all that logic in one class with an Update() method, I can separate it out into multiple systems and allow each system to work with that same component. As an example, when your game loads, you have some level data file that desribes what you want this level to look like, what entities exist within it, where, what their attributes consist of, etc. So this LevelLoader reads this level file and determines it needs to place an Orc in the scene at 1, 10, 5. 

Serialization can be implemented in any number of ways, but I would strongly suggest that you find ways to decouple entity/component semantics from network serialization as it will make it easier as new things are added to keep them in sync. For for creating of entities, I would have a packet that gets sent perhaps on some periodic basis that contains all entities within an area of interest radius. This packet could be sent once the player enters the game world or as objects enter/leave the interest radius. Such a packet would be a combination of necessary attributes to begin rendering the object, such as but not limited to: 

There are many ways to design a game engine and it really all boils down to preference. To get the basics out of the way, some developers prefer to design it like much like a pyramid where there is some top core class often referred to as a kernel, core or framework class that creates, owns, and initializes a series of subsystems such as audio, graphics, network, physics, AI, and task, entity, and resource management. Generally, these subsystems are exposed to you by this framework class and usually you would pass this framework class to your own classes as a constructor argument where appropriate. I believe you're on the right track with your thinking of option #4. Keep in mind when it comes to communication itself, that doesn't always have to imply a direct function call itself. There are many indirect ways communication can occur, whether it be through some indirect method using or using . Sometimes in games, it's important to allow actions to occur asynchronously to keep our game loop moving as fast as possible so that frame rates are fluid to the naked eye. Players don't like slow and choppy scenes and so we have to find ways to keep things flowing for them but keep logic flowing but in check and ordered too. While asynchronous operations have their place, they're not the answer for every operation either. Just know that you'll have a mix-in of both synchronous & asynchronous communications. Pick what is appropriate, but know you'll need to support both styles among your subsystems. Designing support for both will serve you well into the future. 

I would wager you're attempting to mix multiple concepts here. There are multiple culling algorithms used in video games. The most notable is the one used to determine what should be drawn on the screen and to what level of detail. This culling is purely render engine driven and shouldn't live outside the render system at all. Another is what is considered within the purview of an entity to react upon. For example, once you get close enough to a specific entity that is considered hostile, maybe it will attack you, but only if it can actually see you with it's eyes. If a corner blocks it's vision despite how close you are, maybe it cannot sense you. This type of culling happens with the AI subsystem by exploiting functionality provided by other subsystems. For example, provide a collision sphere around an entity to represent it's sensory area to detecting other entities, notably players. If an entity enters that collision area, it gets added to a list of collided players associated to that NPC. For every collided player, the NPC attempts a ray-cast to find them. But if obstacles block their view of those collided players, it cannot react. Once I move to where I'm no longer obstructed by a wall, the NPC can enter it's attack state and move toward me because all it's behavior validation succeeded. There is nothing wrong with inter-system dependencies in a game. What you do want to minimize is the component-to-component dependencies. This way you avoid what can often be expensive lookups during the subsystem's update loop, destroying your cache coherency. 

The great part of this design is that you can clearly see the system dependencies because we use constructor injection to represent them. This helps knowing how to order these systems in the update loop so that all your state changes remain consistent in each iterative loop. The above example demonstrates reactive updates. If you would have rather done proactive updates instead, possibility minimizing the number of sprites to update each pass and the number of physics system calls, you could easily have your physics system check whether a physics component's position changed since the last frame. If it did, send an event/message indicating the entity id and new position. The sprite system could cache those events for when it updates and it would have looked like this: 

There are several ways you can accomplish it. One way would be to use screen fade techniques to transition between the camera location swaps (current camera position & the camera track start/end positions) so that it blends nicely, which is generally great for cut scene type scenarios. The other option would be to do as you described, interpolate from the camera's current position to the first camera track sequence node and applying some focal point so that the camera twists & spins as desired over the interpolation. Then begin the camera track sequence and when it ends, repeat the interpolation for the camera from the last track sequence node back to the camera's original position when the trigger was activated. 

Whether your game uses an Entity-Component model, Inheritence Hierarchy, or some mixin of both strategies, it doesn't dictate what a combat system is within the scope of a game. As Qqwy points out, we're discussing the notion of some damage modifier applied to health. The damage modifier can also affect the durability of the attacked entity's gear with time too, making it less useful with every attack made. You may need to factor in resistences, temporary stat modifiers too which could make an entity more powerful or more susceptable to damage. My advice is design your combat system very high-level like. Consider what you want your combat system to involve and how it will behave. Once you have this guideline, you'll quickly notice what makes sense to be components. One obvious idea would be to just create a CombatStatComponent that has all your stats. This could include the base stats an avatar can have, the extra stats they can acquire possibly from gear, resistence levels the avatar presently has. The combat system uses this components data to measure the damage possible between two entities when an attack is made. When the attack occurs, an event gets sent to the damaged entity with the damage done. It simply modifies it's health component's value. But keep in mind, all the ECS does in this scenario is describe how you organize the code that makes up this combat system. But the internal steps the system must perform to apply some damage remains the same from a generalistic point of view regardless of how you manage entities as a whole. 

I would rather treat the component system a means to invoke logic and nothing more. Instead, you design a generic component that manages a logical boolean state of 0/1. As the component's state transitions to 1, you fire the activated script. As it transitions to 0, you fire the deactivated script. The benefit here is whatever logic you need is external to the ECS as the component is merely a means to invoking logic, regardless what it may be. In fact, the component could have a time factor associated to the transition so that it takes X number of frames or nanoseconds to transition and allows for a tri-state like script executor rather than just two. Now this component can work for doors, switches, vertical/horizontal moving platforms, flashing lights, etc. Basically anything that manages 2 or even 3 states.