Let $P = (V,\leq_P)$ be a poset, and for each $x \in V$ let $x^P = \{ y \in V : x \leq_P y \}$. A well-known property of certain posets (forests, Young diagrams) is the existence of a simple hook length formula counting their linear extensions - while the problem is $\# P$-hard in general. To make this notion precise, we say that $P$ has a hook length formula if there exists a function $h : V \rightarrow \mathbb{N}$ such that for every $x \in V$, the number of extensions of $P | x^P$ is equal to: 

Are there linear-time recognition algorithms for these classes? By the previous remark, an algorithm for class 2 would immediately yield an algorithm for class 1, although I suspect a more direct algorithm to exist in that case. What is the complexity of the subpattern problem for two skew-merged or two vexillary permutations? The subpattern problem is known to be polynomial for separable and 2-increasing permutations, and these classes seem the next to study. 

While exploring different techniques of proving lower bounds for distributed algorithms, it occurred to me that the following variant of Ramsey's theorem might have applications – if it happens to be true. 

Now if we assume that each pixel has its shade picked i.i.d. from this distribution, how much entropy do we have? My Python script told me that we have as much as 3.3 bits of entropy per pixel. And that's a lot of noise. If this really was the case, it would imply that no matter which compression algorithm we use, the 1000x1000 pixel bitmap would be compressed, in the best case, into a 412500-byte file. And what happens in practice: I got a 432018-byte PNG file, pretty close. 

I update my reply in light of Aravind's comment. The claim in my previous answer was clearly incorrect but, in my defence, I never had a good intuition about graphs. By adapting Aravind's argument you can show an upper bound of $O(\sqrt{n})$, as every $n$-vertex perfect graph has an independent set or a clique of size $\sqrt{n}$. It should be possible to show the tightness of the bound by reasoning on the tree-representation of the cograph. Consider for instance a complete binary tree $T$ with $N = 2^n$ vertices, and label its nodes as series/parallel in an alternating fashion. It represents a cograph $G$, and any $P_3$-free subgraph $H$ of $G$ must span a subtree of $T$ that does not contain three alternations along a root-leaf path; it should imply that this graph may have at most $O(\sqrt{N})$ vertices, but I leave the details to you. A related question would be to look for a partition in bicluster graphs, as they are exactly the bipartite $P_4$-free graphs. Observe that this problem can be solved in polynomial time by computing the chromatic number of the graph: an arbitrary pairing between color classes then gives the optimal partition. 

I will answer this from the perspective of distributed graph algorithms (distributed algorithms that solve a graph problem related to the structure of the communication network). Here are some non-obvious reasons for designing deterministic distributed algorithms in this setting: 

If $A$ was positive semi-definite, then everything would be nice and convex and easy, and we could solve the problem in polynomial time. On the other hand, if we had the integrality constraint $\mathbf{x} \in \{0,1\}^n$, we could easily solve the problem in time $O(2^n \cdot \mathrm{poly}(n))$ by brute force. For the purposes of this question, this is reasonably fast. But what about the non-convex continuous case? What is the fastest known algorithm for general box-QPs? For example, can we solve these in moderately exponential time, e.g., $O(3^n \cdot \mathrm{poly}(n))$, or is the worst-case complexity of the best known algorithms something much worse? 

An OH relation is then a conjunction of OH clauses. The authors state in Theorem 5 of the paper that the satisfiability of an OH relation can be decided in polynomial time, but the algorithm doesn't seem 'self-contained' as it relies on a generic algorithm for propositional Horn theories. In relation to a problem I'm currently studying, such a self-contained algorithm seems desirable but it's unclear to me whether it is possible. To tell the truth, I have an algorithm for a subclass called Restricted Ordered Horn (containing the relations expressible using clauses without $\neq$ in the rhs) but unfortunately it can't be adapted to the full $OH$ class. 

That is to say, $\sigma_i$ combines the effect of a swap and a conjugation at positions $i$ and $i+1$. It might be possible to solve this problem optimally in polynomial time, which would answer to your question. 

Given two strings $x$ and $y$ and integers $k$ and $K$, I would like to solve the following problem: 

Put otherwise, the task is to find a labelling $x'$ such that $x'$ is as close to $x$ as possible (minimise the number of elements that differ) and the labelled trees $(T,x')$ and $(T,y)$ are isomorphic. Variant 2 The same as above, but only leaf nodes can have non-zero labels. 

We discovered that problem A has some hidden structure, which makes it possible to design a new, clever algorithm for solving problem A. We just need to know how to solve problem B. We realised that in some special cases, problem B is basically just problem A in disguise. We can now see that any algorithm for solving problem B has to solve at least these special cases correctly; and solving these special cases is essentially equivalent to solving problem A. We are back at square one: to make any progress with problem B, we need to first make some progress with problem A. 

It is commonly accepted that matroids provide an abstract setting for which greedy optimization works (although there are more general structures known as 'greedoids'). I was wondering whether there had been attempts to formalize a notion of 'semi-greediness'. Intuitively, it means that we would still construct a solution iteratively, but going from a solution $S$ of cost $i$ to a solution $S'$ of cost $i+1$ would work differently: instead of having $S'$ of the form $S \cup \{x\}$, we could for example have $S'$ of the form $(S \Delta T) \cup \{x\}$ i.e. we would replace $r$ elements present in $S$ by $r+1$ elements exterior to $S$. This could possibly model interesting problems such as bipartite maximum matching, optimizations in $\Delta$-matroids or 2-polymatroids. 

(Warning: somewhat biased views, oversimplifications, and blatant generalisations ahead.) Often the difference between distributed computing and parallel computing can be summarised as follows: 

You may also be interested in the "congested clique" model, which is the special case such that $k = |V|$ and computer number $i$ is aware of the edges incident to node number $i$. 

I think I finally understood what is going on here and why we seem to have two conflicting answers: one saying that we can simply apply the directed, vertex version of Menger's theorem / max-flow min-cut, and the other one saying that the problem of finding a separating set of vertices in directed graphs is NP-hard. Obviously I'm no expert on this kind of things, but let's see if I can get these right... Let $G = (V,E)$ be a directed graph. Let $p, q \in V$ be two distinct nodes. In what follows, $X \subseteq V \setminus \{ p,q \}$ is a subset of nodes that doesn't contain $p$ or $q$. Let $G-X$ be the subgraph of $G$ induced by $V \setminus X$. Now let's define two (non-standard) terms: 

is it possible to adapt the above proof to handle distinct orders? if so, what part of linear algebra carries over to this setting? if we can compute the rank for permutation groups as suggested above, are there other, presumably infinite, groups for which this is doable efficiently? are there any algorithmic applications of this notion to problems involving graphs or permutations? 

Let $S$ be a finite set. Following Lovasz (Matroid matching and some applications), let us define a polymatroid function over $S$ as a function $f : 2^S \rightarrow \mathbb{N}$ such that (1) $f(\emptyset) = 0$, (2) $X \subseteq Y \Rightarrow f(X) \leq f(Y)$, (3) $f(X \cup Y) + f(X \cap Y) \leq f(X) + f(Y)$. The function $f$ defines a 2-polymatroid if $f({x}) \leq 2$ for every $x \in S$. My question is as follows: given two such functions $f,g$ over the same set $S$, and given two integers $r,s$, what is the complexity of counting sets $Z \subseteq S$ such that $f(Z) = r$ and $g(Z) = s$? The $\# \mathsf{P}$-hardness of this problem is not clear to me, if by chance it was in $\mathsf{P}$ it would have some interesting consequences. Indeed, it encompasses natural problems such as counting the number of $k$-vertex trees in a graph, which complexity is open afaik. 

The model studied in the following work should be a fairly close match with the model that you described (see in particular graph problems "without edge duplication"): 

A more general recipe for generating problems that are hard on trees: Take any NP-hard problem related to supersequences, superstrings, substrings, etc. Then re-interpret a string as a labelled path graph. Then pose the analogous question for general graphs (subsequence ≈ graph minor, substring ≈ subgraph). And we know that the problem is NP-hard even on trees (and on paths). 

Then of course we have the issue that the distributed computing community is actually two different communities, with surprisingly few things in common. If you lump together all models from two communities, it will certainly look a bit confusing... My answer above is related to only one half of the community; I trust others will fill in regarding the other half. 

Some structures have a property of closure by a "sum" or "product" operation. Given a family of structures $(S_i)_{i \in I}$, we can then define a new structure denoted by $\sum_{i \in I} S_i$, resp. $\prod_{i \in I} S_i$; structures enjoying this property are vector spaces for instance. I consider these operations as "undirected" as the result does not depend on the order of the summands, up to isomorphism. I am interested in structures for which we can define a "directed sum" / "directed product" operation, meaning that the definition of the sum / product could now depend on the structure of the index set $I$ (e.g. it could be a totally ordered set and we would compute non-commutative sums / products according to this order). To illustrate this, consider the following definitions for posets. Let $I = (G,\leq)$ be a poset and for each $i \in G$ let $S_i = (U_i,\leq_i)$ be a poset.