You require pry, and you don't seem to use it. Perhaps it is being used for troubleshooting, and the or other code, has been removed. In that case it may be more appropriate to simply use the option as in . Then you don't have to remember to remove that line, just the troubleshooting line. (Or even better, set up a system that lets you leave things in but turn them off and on from an option in the system call. Perhaps -w or -v flags. Perhaps an environment variable. A line in with this in mind may look like this: And a ) Looking at your tells me that you have an infinite loop. But you have a well defined exit strategy, there is no need for an infinite loop. Using something like will run the block at least once, and will stop when your method returns true/truthy value. You also call 'play' from inside the loop inside of play, but it is already going to start from the beginning of the loop. If you had folders , , I would expect some of the code in your file to be in maybe . The equivalent for sure. This will allow you to use the file in a way that someone that requires that library would expect. Right now, you are unable to require that library file without starting the game. The interface of using words like seems clumsy and error prone, even if it is nice. Creating a numbered or lettered menu or presenting the grid with numbers or letters could make play easier, less typing to do, less error prone. Perhaps a lettered 'x, y' grid. Presenting that grid would also document the game play, and make initial play more straight forward. Your "choose_character" method does two things, it prompts and processes the choice. The @player_character and @computer_character is repetitive, confusing in a way. Simply having @player and @computer is probably clear enough. @player.character might be better, though I think we consider that letter a 'marker', as the player mark may be 'X' and the AI mark may be 'O'. Looking at you could be using the new named arguments in Ruby 2.0. In the Board file you can likely use the Enumerable method, if an array has the markers that match the current players marker, then that player is the winner. 

It is often bad practice to catch every single exception in one catch block, especially if the exceptions can be predicted. In this case, we have and . First, we can identify where and why these exceptions can be thrown, and if they can be prevented. The can be thrown on the first line of your block because can be . You can prevent this by doing: 

What??? confuses me. Might want to do some naming changes. I would simply remove in and use instead: 

A couple of things: Indentation Indentation seems a little off in your question. Is this because of formatting issues when copy and pasting from your IDE, or is it your code? Most IDEs have a format function that formats the code for you. In eclipse, that is found in -> or the keyboard shortcut . Spacing You have what I call overspacing: 

Again, should be and should be . This is the same with and . I also see some poor naming. For example: 

Since also has to deal with stuff like \$2^{1.5}\$ and has to use a more complex algorithm to figure out the result, so a simple recursive algorithm can easily be more efficient than . 

Your solution seems to be the most efficient, except for the fact that it doesn't seem to work. You could try finding all possible groups like so: $$18=4^2+1^2+1^2$$ $$18=3^2+3^2$$ $$18=3^2+2^2+2^2+1^2$$ $$...$$ Then find the smallest group. Your code would sure like some space. After some nice, wide spacing: 

Why the "A" in the middle? I would remove it completely, as it both reduces readability and is doesn't add anything to the meaning. Same with all the other ones. In 

Even though it saves a lot of lines and typing, it's at the cost of performance and readability. Import each class individually. 

I wouldn't create a new temporary map for each loop. Instead, I would create one outside the loop, and dump the contents of the temporary map into the map at the end: 

This will only use 4000 arrays, converting the array into an array of arrays containing 2 elements each, given the 8000 element array you mentioned. I have not timed it though. 

This is made possible by Player and Referee They are not both classes, as you can see in the code above. Here is 

Given that on some file systems a directory is simply a File with special attributes (or to put it another way a specialized file), does it really matter? Unlink it if it can be unlinked if that is what you want to do. If it can't be unlinked, why would you bother? And why would you care what it is? If you care what it is, then use If the inode can be unlinked, unlink it. 

Though I would probably do away with the variable named result, this would be a clean way to do this. In other words, regarding the variable assignment, don't conditionally assign a variable through all conditional paths. Just assign it the result of the condition one time. 

You asked if you should set up an array to keep track of things. I find math is sometimes much easier to keep a count of things. I do so in the code below. I have set this up with the following (somewhat standard) folder structure: 

Because you call you are actually getting a much larger array than what you start out with. Don't you mean to partition the array collection by pairs, rather than taking all elements of the array and getting every combination of possible pairs? Instead of dealing with 4k pairs, you are dealing with almost 32 million pais. Your method name suggests that you will return pairs from a given array, but it returns an integer. The name doesn't convey the idea of the methods return. This makes it more difficult to understand the intent of your method, even with the code. 

Successive elements of the list returned by genPositions and xs are zipped together; captures this pattern. i is now not needed in its non-rooted form and I recommend changing the interface to take N as an argument instead. Non-square arguments can currently crash !! anyway. genPositions is only used once, therefore I inline it. 

is . points out some redundant brackets and suggests using in . , and are superfluous once-used one-liners. All the passing can be abstracted with the monad. For example, becomes (I assume reversing the order of adding does no harm) and can be inlined. And s are , so no need for . And becomes and can be inlined. (I note these because it might otherwise look like I'm rewriting the code from scratch as opposed to reviewing.) 

If you used , would be Using , is , except that the list is the right way round. Replacing with allows you to remove the last line, and thus the recursion, in loop's definition. Prepending to allows you to remove the . skips getting system time. 's allows you to require ability to generate random numbers in exactly the upwards call hierarchy of if you use mtl-style type signatures. You won't even need to specify that it is actually provided by (except in ), giving type level gurantees that you aren't using IO except for random numbers. Then you can wholly reduce to . 

Repeatedly sorting is asympotically slower than keeping a sorted data structure, takes quadratic time, = , and try to use library-defined recursion combinators instead of explicitly using recursion. 

To bring 's last lines closer in method with the rest of your code, you could do and put another to the right of . (Or , because the repeats everything anyway, but that's kinda incidental.) When you implement a transformation of a simple partial algorithm into a safe one, chances are 's already got something, here . in its prefix form allows me to not close each option with a multi-line closing bracket, and shuddup indentation blocks split code into units just as well as names do, and then you don't need to choose names for everything. Each option even already lists a description of what it does! 

Sets all numbers to (as in, is a prime). Starts at 2, and works its way through the primes. While doing that, marks all the multiples of a prime to . If it has 100 primes, the loop will terminate. Print the result. 

Since you said that Step 6 takes a lot of time, and is mainly executed in the method, why don't we simplify it? 

You have a constant, which is pretty much a . You use it to append. Instead of doing that, you can easily append the char itself, which saves a String creation. 

Here, I suggest you do instead of . It is a matter of preference, but I think is easier to understand. 

Some notes: Your bracing does not follow standard Java conventions. This is more of a matter of preference, but this is how I would format your code: 

Also, the extra spaces you added for line three of that snipped can be removed without affecting readability: 

This code seems to be a specific BucketSort made for a specific program. I would instead create a more generic BucketSort: 

And add your method in another class in another file called . That would look like (if you want to time it): 

Since Java 7, there is such thing as a try-with-resources statement, which automatically closes the reader when an exception occurs, which you are not doing here. Your current code has memory leaks! With some other improvements: 

You must only say numbers consecutive to the previous said number. You may say 1, 2, or 3 numbers at a time. 

Well, the first thing that's bad is the the fact that everything is crammed on one line. Max line character count is usually 80. To handle the hardcoded , you can use . (You don't need it anyways for my solution.) You don't need to use ; instead, assuming is a object, you can use . The thing that makes this so hard is the fact that does not have an method. Instead, we use 's method, which is better than what you have up there. Continuing from point 4, don't use (I don't even know what that is). Instead, use , and its methods. 

Library functions, particularly Maybe's Applicative/Alternative instances, can make your code more consise: 

You can make nonpartial by using . Then it turns out that already implements that and calls it . Using it, you can eliminate another case from pull. 

I would inline, eta-reduce and use more library functions to make the code short enough that adding another command is trivial. Perhaps give the fields names so adding another can't mess up numbering, and you need less comments because the code describes itself. Edit: I'll use non, making the map not add a value for new users until they want to change it. This way we don't need to initialize with on logging in, and we can get rid of the Just returned by the "get" action without needing to promise we already initialized. (Which we don't necessarily have, as the initial ""!) 

The "intermediate array" takes no extra space due to lazy evaluation. is . Yes, swapping the parameters makes sense. Inline and once more. I wouldn't worry so much about constant factors - have you compiled it with -O2 and tested (eg with criterion)? import Data.List (minimumOn) 

There doesn't seem to be a reason to filter out the s. List comprehensions neatly let us skip the empty tail, and get rid of . 

Here's how to use to brighten the day a little. You may have hoped for a way to do only once after combining the s with ... but I also don't know how to do that. If went to arbitrary MonadError instances, could have been more concise. 

The general idea is to use library code, particularly to eliminate explicit recursion, and inline things used only once. abstracts computations that can fail and abort at some point, and allows you to bind into pattern matches that fail the computation if they don't match. abstracts retrying them until they work, using s instance. abstracts computations that carry around a piece of state to read and write to. defeats the need for to manually loop. Contrary to that comment, abstraction is kinda Haskell's thing.