If you get two near-identical projects, it can be nearly impossible to determine which was the original. If you can only punish the one who copied, then you won't be able to punish anyone without determining which is which, and people can cheat with impunity. Suppose that Alice and Bob are friends in the same class, and Alice asks Bob to let her copy an assignment. If it's known in advance that there will be no consequences for Bob even if they get caught, there's some social pressure to go along with it. But if both are punished, Bob can simply say he isn't willing to take the risk. The policy makes Bob less likely to aid in cheating and also lessens any social consequences for doing the right thing if he would have done so anyway. Helping someone else cheat is unethical, so I have no problem punishing someone who does so willingly. 

As much as I hate the fact that we need to consider this, paper and pencil makes it harder to cheat. Even if you restrict them to using lab computers and not their own laptops, and cut off networking to the room, it'd be easy to smuggle in a USB key with entire books worth of notes and the source code from every one of their labs and projects. (Yes, with enough effort, you could lock down the computers to the point where they can't even mount a USB key, but the logistics are a lot trickier to manage than just scanning the room periodically to see if anyone's got a small library of cheat sheets on their desk.) (I don't think that this should be the only factor considered, or even a deciding one, but other answers have covered various pros and cons well enough already, and this is a factor that hasn't been mentioned yet.) 

Version control is most effective in an environment where at least one user understands it quite well. As long as you have one individual on the team that understands how to recover from a messy situation, everyone else can comfortably learn as they go. However, if one does not have such a knowledgeable individual, there may be no clear way to recover from the sorts of situations that VCS is supposed to help you with. For example, if I'm not on your team, and you come across a "Tree conflict" in Subversion, it's unlikely that anyone has bookmarked the StackExchange answer that lists each tree conflict and the series of commands which resolve it. Instead, "Tree conflict" quickly becomes "wipe out your repository and do it again." In a commercial setting, there are typically senior developers or team leads who are actively monitoring the state of the repositories and can guide you down your path. In an academic setting, one is not so lucky. If I were to introduce VCS to a curriculum, I would use it in the context of group projects, and I would want to make sure the VCS tools are actively maintained and used. This may call for extra effort on my part, or that of a TA (which may not be an acceptable cost). I'd say 95% of the value of VCS becomes apparent when one is working on a team, rather than on their own. 

It's almost impossible to convey a sense of wonder when they don't appreciate what they have. My personal favorite approach is to point out that the Apollo Guidance Computer (AGC), which sent us to the moon, was a 2Mhz processor with 2k of RAM. The original Game Boy had a 4MHz processor and 8k of RAM. The old game boy was more powerful than the AGC! Well, almost. The AGC did have triple redundancy on all circuits, so you would have to duct tape 3 Game Boys together if you really wanted to compete with it! And, of course, a modern cellphone chuggs along at 1800Mhz! I find it helps to first appreciate just how blindingly powerful and fast computers actually are. Then we can talk about where they came from. One of the calculations I did a while back was comparing the speed of a cache hit versus going out to memory to get the information. It turns out, due to serendipity, that the difference in speed between a L1 cache hit and a round trip to memory is actually the same speed difference as that of a Cheetah at full sprint vs. the top speed of a snail. No joke! Of course, that doesn't help if you don't have a sense of how fast either of those are, so let's compare them both to something we can appreciate: how long it takes to load a web page. There's a latency associated with going across the world over fiber optics. It turns out that your round trip ping time from America to Europe (the absolute bare minimum portion of loading a web page) can be put on this scale between cheetahs and snails. This web page access proceeds at the speed of the San Andreas fault slowly opening in California! Yes. On this scale of speeds, California actually starts sinking into the ocean! 

First, focus on how the return always knows to transfer control to the statement after the line the function was called on. So for instance, the return from might go to either or , depending on where it was called from, and in the former case, in turn knows where it was called from. If the language they're using is one that prints the call stack when it crashes, they're probably already somewhat familiar with this. Make sure they fully understand how the control flow works first, then bring in the concept of a stack and explain how you can implement function calls by storing the return addresses on the stack whenever you call a function, and popping them whenever you return. Once they understand that, you might want to proceed to explain how parameters are stored on the stack. That might confuse them a bit, though, since you can't access elements other than the one on top in a "theoretically pure" stack, but you do when accessing values in the stack frame. I would probably just mention to them that the reality is a bit more complicated than what you just described, but save the details for a later lesson. 

The call stack They've presumably already learned about functions, so if you use that as the example, you both teach them about stacks and give them a deeper understanding of how functions work. I would take it in two main phases, using code similar to this as an example. 

Alice looks at Bob's assignment when Bob isn't paying attention. This is less of a problem in CS than it would be elsewhere, due to the large number of coding assignments; a quick glance generally won't be enough. But for instances where it might be... The students are informed that keeping their work from being copied is their own responsibility, but if a small enough portion of the answer is copied that this is a plausible scenario, I'd probably give them the benefit of the doubt anyway (especially since small similarities can happen by coincidence). Alice and Bob collaborate a bit more than they should have, but don't actually intend to cheat. I'm perfectly okay with students discussing assignments so long as they're helping each other learn the material instead of just copying answers, but sometimes the line between the two isn't perfectly clear. My policy here is to insist that if students collaborate (or ask for help on stackoverflow, for that matter), they cite their sources on the assignment. If too much of the answer came from another source, I might take off a few points or have them redo the assignment (or more likely, just let them know that in the future, they need to do more of the work on their own), but as long as they're honest about where it came from, there's no ethical violation. 

I'll now put my teacher hat back onto the shelf where it was gathering dust, and put my engineer hat back on. I regularly read and write requirements documents. (A test question is a kind of requirements document for the answer.) Requirements documents should be precise, but they should not be subtle. If I notice a subtlety in a requirements document, I'm not going to blindly implement what the document says, I'll send it back for clarification. If I'm writing a requirements document, I pay attention to being clear, I'm not going to convey a requirement through something like a plural. If the plural is at all important, I'll at least highlight it with a word like “multiple widgets”, and probably “multiple simultaneous widgets” or “multiple concurrent widgets” or whatever it is I actually want. 

Many coding standards for embedded programming forbid using goto for anything else. In languages that have a better clean-up mechanism, such as try/finally or C++ destructors, goto is useless. Understanding goto is a secondary skill for programmers, part of understanding how a program's code relates to the way the machine executes the program. A good programmer understands goto, but a decent programmer understands how to program without goto. The primary skill for a programmer is understanding how a program works, not understanding how a machine works. (There are exceptions, obviously — I write OS code, doing things like memory management and context switching and accessing peripherals, and that obviously requires a precise understanding of how the machine works. But that's a highly specialized field.) The real difficulty with goto is, as I mentioned before, that it isn't just a jump. It's a jump to a different context. The invariants that hold at the location of the jump may not hold at the target location. A goto introduces a non-local connection between two points in a program that makes it hard to figure out how the program state evolves and what invariants hold. Paul Powell's statement that “GOTO (…) is easy to understand” is just wrong. What's easy to understand is how a machine executes a goto statement. But the most important part, understanding how a program that uses goto works, is difficult. The statement that “it can be used to explain what loops and other items of structured programming actually are” also completely misses the point. Goto can explain how structured programming items are implemented on a processor. It explains an implementation, not the concept. Goto is an advanced step after structured imperative programming, not a step before. Using goto to encode flowcharts is also very misguided. With goto, “we can code directly from a flow chart” — this is true: goto makes it easier to write a program from a flowchart without understanding how the program works, without figuring out the structure in the flow of events. But when you do that, you end up with a write-only program. Sure, you've been able to write it, but you won't be able to explain its behavior when a parameter that isn't reflected in the flowchart turns out to be important, or to modify it in a way that isn't easy to draw on the chart. Write-only programming is the mark of a mediocre programmer, capable only to fumble in the dark until they somehow manage to pass the tests. Goto has its place when you teach how a machine executes code. It's what's happening under the hood. It has little to no place in teaching how to program, and Dijkstra would be quite right to complain about its use in this context.