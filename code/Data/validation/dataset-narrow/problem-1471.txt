Before you try it, I'd suggest you consider setting the upper limit of each loop a bit lower. But still, the iteration values aren't used. So... 

I'd like to add two notes. First is that if you write both the unit tests and the code, then all they test is that the code does what you think it is supposed to do, not what it is actually supposed to do. That is why Acceptance Tests are also used in agile development to test that the code does what the client/customer thinks it is supposed to do. With an imperfect understanding of requirements (or an incomplete test suite) you can pass all the tests and still not have a valid program. Also, if you write the tests after the code, then all they test is that the code does what the code does. That is a waste of time, of course, except, perhaps, for regression. Second, in the context of a course, if you are lucky enough to be able to project a computer screen for all to see then you can spend part of a class period developing a small application (100 or so lines) in front of the class, perhaps with a student "navigator" showing how TDD actually works. Bit of test, bit of code, repeat. You can also expect that the number of lines of code in tests exceeds the number of lines in the application itself. That is normal. But if you use an adequate programming environment it isn't a burden. Especially since something like Eclipse will fill in the application method skeletons from what it finds in the tests (assuming JUnit, at least). Think of the test framework as your low level design space, where you design the public interface of your classes. 

As user ctrl-alt-delor mentions below, there isn't much to the Scheme language, so a "reference" fits on an index card. The problem with functional languages for those that program in other languages is that you need to expand the way in which you think to use them effectively. So SICP, while not a reference, as such, will help your students make the mental switch necessary. It isn't like needing a Java reference if you are a C# programmer. It is nothing like that at all. 

Note that we can introduce only one disease into a population (extensions can be built, of course) but the particular kind of disease is independent of the population. This is the beauty and usefulness of using interfaces here. To explore how a different disease spreads in a given population you don't need to re-write any existing code, but just build a new implementation of the Disease interface. It is possible, with this Population concept to introduce barriers to spread of disease, much as an ocean serves as a barrier to the spread of natural diseases. However, infection can also spread at a distance, perhaps across barriers if the "cells" of the population move (shuffle) or visit other locations, much as air travel has reduced the safety of isolation for such diseases as Ebola. The simulation also has two Enumerations, Direction and State. The Direction is used to help in setting up barriers. 

This sort of thing is perfectly valid and valuable, provided that students already understand the underlying structure. So if they understand your first loop without continue (but with the print in place) the adding lets them see the effect dramatically. The same is true of your second example. If they understand strings as arrays or lists (or ... whatever term is appropriate in your language) then introducing the [] "box" operator as selection makes sense. But I wouldn't write a large program as an exemplar of good programming if it had these kinds of things. But note also, that throwing in a continue in a loop is sometimes good for debugging, so it isn't entirely useless as a technique in "real" programming. tl;dr teaching by showing modifications to a known base is fine. 

Intention Revealing Names: A name should always have semantic content related to the problem being solved. Don't use abstract names like $x$ and $y$ . Use semantic names like $size$ and $figure$ . Names from the problem space, not the solution space. If you are totaling up some array, don't use $total$, use $sumOfAges$ , if that is a concept in the problem space. This can permit each statement in the program to read like a description of some thing or action in the language of the problem being solved. In Java, use singular nouns for class names. Use verbs and verb phrases for the names of mutator methods, describing what the method does. Use nouns and noun phrases for accessor methods, describing what the method returns. Predicates can usefully start with $is$ , as in $isRunning$ . An implication is that methods should not be simultaneously an accessor and a mutator. There are other reasons why access-mutators are a bad idea in any case. One name per concept. The same concept will occur in a program in several ways. A class name $Ramp$ describes how to construct a ramp. A variable name can be $ramp$ . An accessor method in some class might be $ramp()$ . A field in some class might be $ramp$ . Java does a good job of keeping these distinct, thought you sometimes need to (and should) write $this.ramp$ . Since the language can distinguish them the programmer doesn't need to keep track of an entire set of names for the one concept. And, concept is from the problem space, not the solution space. This helps the student programmer imagine that their program is a model of some "real" world scenario, not just a set of notations providing a result. (See Miller's Rule, below) Avoid names that emphasize the implementation of a class. Names should emphasize the structure and evolution of a concept, not the fields of a class and their modifications. Unfortunately names like $getSize()$ and $setSize()$ emphasize that there is likely a field named $size$ . (See below for more). Don't abbreviate names. Ever. Always spell out your names and never abbreviate them. You will, over a lifetime of programming spend more time looking back for the definition of something you abbreviated to use it consistently than you will just typing it out in the first place. A few exceptions to this rule can be tolerated for standard things, but in general, you waste time abbreviating. The thing that makes programming hard isn't typing. It is understanding. Modern IDEs can help you with word completion, of course. 

There are two things supplementing the answering of student questions, whether you use an IDE or a shell. The Oracle Java Docs are online and can be consulted easily, perhaps via a Google Search for some classname or concept. The other is Stack Exchange itself, especially StackOverflow. 

I don't claim I have a complete list here. There are many other possibilities. Each person's development environment is personal. It is good if it makes them more productive and less frustrated. Is is subject to update and modification at any time that you learn of a new tool or technique. 

The book is quite deep. I'd only consider it in secondary school if the students typically go off to top universities, MIT, Cambridge, Berkeley, or similar. Otherwise, I's strongly suggest that they get a deeper knowledge of whatever language they already know. Java version 8 has extensions that permit learning much about functional programming, for example. Learning lots of languages shallowly isn't really a path to success. Of course Scheme and Java are sufficiently unlike that studying both opens new thought processes to the student that learning both Java and Ruby would not. But learning how to become a true expert in one language gives you a powerful tool for whatever you want to do. It is often a shock when a top student at a top secondary school winds up at, say MIT and finds themselves just average. 

My usual explanation is related to names; specifically names of people. People have names. The names are not the people, but can be used to refer to the people. Some people don't have any names at all. This is common just after birth at least, before the parents decide on a name. Names can be changed. A person can have a name for a while and then later have a different name. So, different names can refer to the same person. Similarly we have come to rely on names known to only a few other people. A father might refer to his son as junior even if their names are not the same. Spouses often call each other honey without confusion. Just as important, a name isn't necessarily permanently bound to a thing (person, value, object). A name like Sue could refer to one person in a given household, but a different person elsewhere. Also, a name like "kiddo" could refer to one child at a given moment, but to a different child, even in the same household, at a slightly later moment. 

Well, you may want to do this outside. You may want to have a lot of time, and for some, you might want to have medical personnel available. To really do it as an active learning exercise, you need three student monitors, one for each loop, who will keep count and signal each iteration and the end. First suppose that the action is the same in all cases and is simple and fast, say clap hands. The three cases will have a different number of overall claps, of course, and the last will take a while. Next, suppose that the actions can be different for each occurrence (I'll still assume they don't depend on the current value of the iterator.) We might have something like the following: Fully Un-nested 

The cited research seems to be about improving teaching, not about detecting plagiarism. No student should be accused of plagiarism based on statistical measures only. The paper seems to correctly make that point. 

For the record, I'm interested in drawing an accurate picture of work in the field, not horror stories or overly optimistic projections. 

reduces the redundancy. Note also that 5 is a valid value of the following C# types: byte, sbyte, int, uint, long, ulong, short, and ushort. What is your intention here. The declaration above doesn't say. The compiler will choose something it "thinks" is appropriate. By saying less about your intent you give less information to the compiler, which may then provide a less-than-optimal translation of your code. So this sort of redundancy is a good thing. When used with objects (or otherwise polymorphic types) there is an additional consideration. If you say 

But these are flaws applied to the "fun" example, not the thing (blockchain + bitcoin) itself. Reading it might lead to a better understanding of the technology, but it is not a lot easier to read and understand than these, from Wikipedia: Blockchain Bitcoin Fun, though. As a classroom activity it might bring enlightenment, but, I fear, mostly enlightenment about the unworkability and complication of the scheme. 

which is, of course ugly. We need to assure the compiler that x is, indeed, a Horse so that the count method is available. However, this cast introduces a check into the runtime code, which is both inefficient and can be wrong. What if somewhere else prior to this x was reassigned to an Aardvark object. Then whether or not Aardvarks can count or not, the run-time type check will flag an error. This sloppy typing combined with casting is an attempt to replace the normal static type checking with dynamic type checking (as is done in, say Python). But that is misuse of the language. Moreover, it introduces a maintenance nightmare into your program. You declare a variable in your program to have a given type, but in use it has a different (more specific) type. The compiler isn't going to remember those actual types for you, so you have to do this yourself. You can't look back to the declaration of x to find out what sort of thing it represents, you have to keep the details of the dynamic system in mind for every use of the variable. In a program of any size this is obviously infeasible. It is why we have types (and also polymorphism) in the first place. Again, this sort of casting (down casting) is a recognized Code Smell, indicating poor design. Every explicit cast in a program is a potential point of error. Just Say No. For completeness, let me give a few rules here that will lead to better design and better code. 

I just noticed that most of the answers here, while good, don't answer the originators question: How can I .... My suggestions, all of which are hard work: 

If the class isn't too big or too small, you could organize some simple games. You can have a tournament, possibly with prizes. The prize can be as simple as a gold star sticker like the ones elementary school teachers have given out for years. Darts Basketball Free Throws Baseball/beanbag: "hit a target" Frisbee (Ultimate) Make a circle of people and throw a few small balls back and forth around it, calling out the name of the recipient as you throw. Musical Chairs Hand slapping (Pease Porridge hot -- ) Or plan in advance and have people recite some poem - dramatically (weirdly). The idea is to get them on their feet doing something together, possibly competitively, but not too competitively. Find something that will make them happy and laugh. Don't just make it free time. Change of pace can also free the mind. If they will be together as a class for a long time you could ask the students for ideas for the activity. If part of their work in class involves teamwork this can have a positive effect on team building as well as getting a bit of exercise. You may not even need "prizes". Yes, I'm intentionally giving strange examples here, but you know a lot of this stuff from when you were a kid. You can find more online. Many of these games can be adapted to adults. It is hardest to do with teen-agers who are often too self conscious. Note that PLoP Conferences in the Patterns Community have several sessions of "Game Time" each day. Fun and active. It is one of the main reasons that it is a community, actually. They often have a special role of "Games Master" to organize it. I've used this idea in intensive courses both to break the ice at the start and to get people doing things together as a team. 

There are a number of facets to this question. But the first thing you need to remember is that students (like anyone) will tend to apply solutions that they are most familiar with. In the student context that means, often enough, the things they learned earliest and have been practicing with the most. This effect is most pronounced on hard problems that may not have an obvious (to the beginner) answer with the new techniques. For the above reason, I prefer to teach a thoroughly object-oriented course to students, having them build classes and write and use methods (some of mine, some of theirs) before they seen things like primitive data (int, double...) or low-level program structure (if-while...) More generally, I advice against a strictly bottom up approach to teaching programming, in which low level constructs are taught first with a lot of emphasis on language primitives. It takes quite a lot of scaffolding, however, but my students start their programming learning in a world that I construct, not a "naked" language. So, when they come up with a hard problem and need to "fall back" on what they know best, it will be something like writing a test for something or an interface for structure, rather than just trying ad-hoc methods. The reason for this is that ultimately I want to teach them to be OO programmers and when they get a new problem, I want them to think in a thoroughly OO way. So they will naturally write 3 line methods rather than 30 (or 300) liners. If I try to teach them procedural programming first, that will be their fall-back and I want to spare them that pain. However, if you don't want to employ such an "extreme" change in the course, there are other things you can do. One method is to employ a Spiral approach in which a lot of topics are introduced early with only relatively shallow usage in the first loop of the spiral and then repeatedly going deeper on each while you introduce new topics also. This, rather than completely explaining all the nuances of any given topic. (Spiral Pedagogical Pattern) Another trick you can use, whatever your overall syllabus, is to introduce a rather large program early on that shows a fair number of important topics. One way to do this is to give them a program that is essentially correct, but which you have "broken" in a few ways. Their assignment is to understand it enough to fix it up (Fixer Upper Pedagogical Pattern) Ultimately, then, the answer isn't really to "encourage" them, but to structure the course itself so that the "higher level" topics come before the lower level ones. There is really no reason why arrays need to be discussed before (Java) collections/lists/maps... Then the foreach construct becomes their fallback and you can later teach them the c-like $for$ loop as a possible way that foreach can be implemented. I'd rather they used the libraries in their code in any case, just as I want them to program within my original framework rather than riding bareback on the language. If you introduce "deep" and "important" topics only late in the course then it is with those that they will have the least practice and experience. tl;dr: rearrange the course so that they get the most practice on the most important topics.