If you create a sequence that counts back from some really large number, you could assign an ever increasing priority. Then your prioritized dequeue would get messages in a LIFO order. 

If that is the actual DDL you are using to create the table, you could use the NLS_LENGTH_SEMANTICS parameter. If you set that to CHAR rather than the default of BYTE, a VARCHAR2(5) will be allocated enough space to store 5 characters in the database character set (potentially up to 20 bytes) rather than 5 bytes (which could allow just 1 character). Unfortunately, changing the probably won't be terribly helpful if you're relying on the import process to create the table-- the dump file will inherently add the CHAR or BYTE keyword so it would actually issue the statement 

I don't see how this query could ever have returned the current day. starts with 1 so will never return the current day and neither will . Both sides of your return exactly 32 rows so the entire query should always return 64 rows. If you want 32 days before today, 32 days after today, and today in your result set, it would need to be 65 rows. This query should return 65 rows and should include today. 

The "why" goes back to the fact that when Oracle was originally built, output almost always went to some sort of fixed-width medium (either a terminal window or a physical printer). That meant that everyone's general preference that output widths be fixed since it made sure that everything was in alignment without the programmer or the application having to do any work. Today, of course, things aren't rendered in fixed width fonts all that often, the output of SQL statements is rarely sent to a printer, and applications have controls that make it very easy to present data in grids without anyone having to worry about blank padding output to make it align. But the behavior of functions like was defined back in the olden days so when the preferred behavior changes, the only way to handle that without breaking backwards compatibility is to provide new format masks that provide the newly desired behavior. 

There is no difference for a single SQL statement. The '/' character on its own line tells SQL*Plus to execute the command in the buffer. You can use the semicolon at the end of most SQL statements as a shorthand for the '/'. If you want to execute a PL/SQL block or to execute a handful of SQL statements like , however, you need to use the '/' 

Can you define "corruption" and explain exactly what happened to the files? If the data is really valuable (in which case you'll hopefully be investing a lot more in your backup and recovery to make sure that you can't lose your database and all your backups simultaneously), there are tools that may be able to salvage some of your data. Oracle Consulting (which you'd access via support) has a data unloader that they'll charge a small fortune to use. There are a handful of other such tools-- DUDE being the most well-known. Jonah Harris has a listing of other data unloaders that I know much less about. Realistically, none of these are going to be cheap. And there is no guarantee about how much data will be recoverable depending on the nature of the corruption. 

If you are trying to upgrade an existing database, depending on the Oracle edition and configuration, I would tend to suspect that you'd be better served with something like Oracle Flashback Database. If you create a guaranteed restore point before you start the upgrade, for example, you can simply flashback the database to that restore point if the upgrade fails regardless of how many transactions you've committed during the upgrade. 

Our guess was off by ~20% and that was when we were perfect on our estimate of the size of a row. That's because Oracle allocates space to tables in chunks called extents that we've ignored. There are different algorithms for this that depend on the setup of the tablespace. Assuming recent Oracle versions where all tables are in locally managed tablespaces, you would be choosing between uniform extent allocation and automatic extent allocation. In my example, the tablespace I'm using is using automatic extent allocation. The exact algorithm for that, in turn, may depend on the version of Oracle you're using. In my case, though, the first 16 extents are 64 kb, the next 63 extents are 1 MB, and the last extent is 8 MB 

No. You'll need to create a new private database link. Public database links (and synonyms) are owned by a different user than private database links (and synonyms) and you can't alter an object to change the owner. 

The two major benefits tend to be efficiency and flexibility. Streams is a much more efficient architecture. Rather than synchronously capturing changes in materialized view logs which adds overhead to the transaction, Streams mines the redo logs that are generated by the change in order to generate the change vector to send to the target system. That also allows the change to be replicated to the other system(s) much more quickly. Streams is a much more flexible architecture. You can write your own custom apply processes which makes it relatively easy to inject additional processing or logging, to ignore certain changes, etc. You can send a Streams logical change record (LCR) to a JMS queue or to a non-Oracle system (though, of course, you'd need to write code to apply the LCR on the non-Oracle system). 

Using , you're never going to have two instances of a job running at the same time. If I do something like this with an that is 1 minute in the future and a procedure that takes 3 minutes to run 

The second expression is syntactically invalid (at least on its own, it could be a valid part of some other expression). 

Normally, listing out the columns you want to select, particularly doing it once when you are defining a view, isn't a big deal and isn't something you should seek to avoid. It's just part of coding. Normally, explicitly listing the column names is the appropriate way to define the view. Be aware that, unlike with a standalone SQL query, Oracle automatically expands the when you define the view. So even if you define the view with an 

Oracle doesn't have an (or a or an ) table. That's something that SQL Server provides in a trigger. The Oracle substring function is also not . My guess is that you just want 

You can't dynamically change the column you're sorting by using static SQL. You'd need to use dynamic SQL. Something like this should work 

According to the query plan, the optimizer expects that the statement is going to modify 1 row. It appears to expect the Cartesian join to return a single row as well. Based on the fact that the query isn't returning in a few milliseconds, that would generally imply that the statistics on one or more of the objects (tables or indexes) are substantially incorrect. When was the last time statistics were gathered on these tables and their dependent indexes? Has the actual data in the tables changed substantially since that time? 

Since you're using a standard Oracle-to-Oracle database link, Oracle automatically does two-phase commits. If you commit (or rollback) on one system, any changes made as part of the same transaction on the other system will committed (or rolled back) as well. If there is an open transaction on the remote system that has row-level locks, that strongly implies that the local session is still there as well. So you probably just have to do a (or a ) in the local session to remove the locks. If the ETL process is really stuck waiting on locks that are held by the other session, you should be able to query on the remote database and see that the session that the ETL application is running is waiting on row-level lock contention. Specifically, you would expect to see an of in . You would also expect that if you queried that you would see the session ID of the session that connected from the local database over the database link and that if you queried that you would see that the ETL process's session was blocked by that session. 

I am hard-pressed to guess why you would define your parameter to be a when you seem to treat it as a number internally. It would seem to make more sense to either define in your procedure as a or to compute a string value. I am also not sure why you would want to use a procedure for this sort of thing when it would be much more appropriate to put in a function since functions return something. Functions are, in general, used for calculations that do not change the state of the database. Procedures are, in general, used for things that manipulate the state of the database. 

You can't change the owner of a table. You can create a new table that is owned by , copy the data from the old table to the new table, drop the foreign key constraints that reference the old table, and create new foreign key constraints that reference the new table. But that's realistically going to require a downtime window since the tables need to be static while this copy is going on. There are various ways to create a new table that is a copy of the old table. Personally, I'd use your favorite PL/SQL IDE (i.e. SQL Developer, TOAD, etc.) to generate the DDL for and then manually edit the DDL to create . You could also do an export & import with the and parameters. Or you can use the package to get the DDL 

I wouldn't suggest removing those tables, no. The Oracle XE browser-based interface is written in APEX (Application Express, a framework for developing web-based apps in the Oracle database). If you break APEX, that interface will likely stop working. 

Different tools may have slightly different conventions for how you execute multiple SQL and PL/SQL statements in a script so be aware that this is SQL*Plus specific. 

Depending on the edition (enterprise, standard, express, etc.), the licensed options (particularly the Performance and Tuning Pack), and whether you have installed Statspack, I would start by taking an AWR or Statspack report for both system when they are executing a similar workload and compare them. If you are licensed to use the AWR (note that querying the AWR tables violates your license agreement if you aren't), use an AWR report. Otherwise, assuming you (or the prior DBA) installed Statspack, use that. Otherwise, you'll have to install Statspack in both systems. If your guess is correct, I/O is the bottleneck, and the problem is that the I/O subsystem on the new server is slower than the I/O subsystem on the old server, you would expect that the top wait events in the report on the new server would be primarily I/O, that the amount of I/O would be consistent across the reports, and that you'd see that individual I/O operations on the various tablespaces and data files were consistently slower on the new system. Otherwise, comparing the reports should tell you what the bottleneck is (though an AWR report has a ton of information and a comprehensive discussion of interpreting an AWR report is a book not a forum post). 

You'll want to prevent the from starting automatically. Assuming you used the default SID of , that would be OracleServiceORCL. You'll likely also see a number of other services that start with that are for various other components (i.e. your listener, your MTS recovery service, etc.) You can set all those to not start automatically if you want. Given that those services tend to use many fewer resources, it's generally easiest to let them run to make it easier to start the database later on. 

should correctly invoke your procedure. Second, you have issues with the naming of your local variables. Normally, you would not create local variables like and that are the same as the names of columns in tables in your database. That makes it far too easy to introduce errors in your code where you intend to refer to the local variable but scope resolution rules mean that you are really referring to the column name. For example, if you write the perfectly valid function 

Are you really trying to use Windows 8? No version of Oracle is supported on Windows 8 yet and, if history is any guide, I wouldn't expect any of them to work without patches that aren't available yet. Is Windows 8 even in public beta yet? I'd hate to try to take a class using an early beta operating system. Oracle 11.2 is supported on Windows 7 (which seems like a more realistic Windows version). If you have Windows 7, that's realistically the version you need to install. What, exactly, does the class cover? If you are learning how to do data modeling and to write basic SQL and PL/SQL, you should be fine using 11g since everything will be backwards compatible. If, on the other hand, your instructor is teaching about database administration or is making heavy use of the Oracle Enterprise Manager (OEM) GUI, there are going to be a lot of visual differences that you'd have to compensate for across versions. You can almost certainly get the same information from the 11g OEM GUI, it just may be in a slightly different place. 

Posting the query plan for the two versions of the query (and the exact SQL for the other version just for clarity's sake) would certainly be helpful. I would guess that doing so would prove out the following theory. Without it, though, I can guess what is likely going on but I can't be sure. In general, the database is free to evaluate the elements of a query in whatever order it expects to be most efficient. That may mean that it executes the inline view first in its entirety and then applies the outer projection which would include calling the and functions. Or it may mean that it transforms the query so that the outer functions get called for every row and that outer predicates, if any, get pushed into the inline view. If you add a to the inline view, in any current version of Oracle, you prevent the optimizer from pushing logic into the inline view since the optimizer can't be sure that it won't impact the results that are returned. In theory, some version of the future optimizer might be smart enough to figure out that evaluating the and functions in the inline view wouldn't actually change the that is generated but that pushing the could change the result so some transforms would be allowed and others are rejected. But in the present, adding a acts to basically force the optimizer's hand to leave the inline view "as is". Most likely, the optimizer's estimate for the cost and the selectivity of the various function calls are off. If the function is less expensive than the optimizer expects and filters out much more data than the optimizer expects, it may decide that it is more efficient to call and on every row rather than filtering all the data first and then taking a second pass through it to call the functions and do the sorting. Ideally, you'd give the optimizer better statistics about the various functions so that it could come up with the more efficient plan without you needing to add a (particularly since that trick might suddenly stop working at some point in the future) but I've certainly been known to add a like this a time or two (along with a comment explaining why) if I needed a quick-and-dirty fix.