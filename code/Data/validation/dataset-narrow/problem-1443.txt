Coding positions seem to be becoming less exciting/creative and less respected with each passing year and increase in team size :( For each 'exciting' dev position (e.g cutting-edge graphics, or gameplay coding on a big title), there's about 10 coders needed to to fairly dull work (front end, TRC/TCR compliance, tools, porting to the lesser platforms) You won't make big money coding games unless you really get lucky (right place at the right time). The only real money is in founding a studio and selling up to a megapublisher. Or creating an unexpected big hit with a very small team. As a career, games programming seems somewhat dead-end unless you have what it takes to start a studio of your own, or are willing to give up coding and aim for a management role... 

I've heard this approach to timesteps suggested quite frequently, but in 10 years in games, I've never worked on a real-world project that relied on a fixed timestep and interpolation. It seems generally more effort than a variable timestep system (assuming a sensible range of framerates, in the 25Hz-100Hz sort of range). I did try the fixed timestep+interpolation approach once for a very small prototype - no threading, but fixed-timestep logic update, and as-fast-as-possible rendering when not updating that. My approach there was to have a few classes such as CInterpolatedVector and CInterpolatedMatrix - which stored previous/current values, and had an accessor used from the render code, to retrieve the value for the current render time (which would always be between the previous and current times) Each game object would, at the end of it's update, set it's current state in to a set of these interpolatable vectors/matrices. This sort of thing could be extended to support threading, you'd need at least 3 sets of values - one that was being updated, and at least 2 previous values to interpolate between... Note that some values can't be trivially interpolated (e.g. 'sprite animation frame', 'special effect active'). You may be able to skip interpolation entirely, or it may cause issues, depending on your game's needs. IMHO, it's best to just go variable timestep - unless you're making an RTS, or other game where you have a huge number of objects, and have to keep 2 independent simulations in sync for network games (sending only orders/commands over the network, rather than object positions). In that situation, fixed-timestep is the only option. 

Is this a true isometric game? If so I question the value of using real 3D models since the idea of isometric engines is to create the illusion of 3D without it being proper 3D. Or by 3D models did you mean just the appearance of 3D? In that case 4 different directions should be enough (up, down, left, right) which is not too much work. You could maybe look at reusing some of the animations by scaling them with the Flash IDE transformation tools (so scale the down animation into the left animation, but they will look like flat pieces of paper which you may not want). I would avoid pre-rendering the animations as frame sequences unless you could really keep the size down to something reasonable. However, maybe you meant a 3D game with the camera aligned in the sky facing down towards the ground (like with SC2). In that case you will need to use one of the 3D engines out there. Papervision has a nice API and plenty of documentation. Some footage of the next gen 3D apis for Flash have been released recently and look promising $URL$ 

Hi, I am using LibGDX and OpenGL 2.0 to create a game. So far I have created two meshes. The front mesh is the one with the brown circle texture and another mesh on the top with a green to white gradient texture. I am using a perspective camera and everything looks ok except for one small artefact where one of the textures that should be obscured from view by another is showing through(see image). I am fairly new to OpenGL and LibGDX. I have culling enabled on the back faces and was under the impression the problem could be solved with GL_DEPTH_TEST. If I set the glDepthFunc to GREATER or to LESS nothing is displayed. Currently I am using LEQUAL. So I am not sure if I am on the right track or if the problem is caused else where. Any help would be appreciated. I am using some very simple shaders: 

SMB was originally a console game where it's safe to assume that it's able to run at 60fps on all Xbox360s (well, maybe 50 for some PAL players). Assuming a fixed timestep simplifies the code a fair bit. Whilst it's easy to scale a lot of things by a variable timestep - 'pos += velocity * timestep', it gets quite tricky to do it correctly when you're dealing with accelerations, and rates of change of acceleration, and so on. Decoupling gameplay and rendering is a nice solution in theory, but implementing it well (with good interpolation) is quite tricky, and things can easily get messy. It's fairly uncommon for this technique to be used in real games (although some big games do do it, particularly RTS games, but more for network game synchronization). When also designing for a fixed screen resolution as well as a fixed framerate, there's one other thing you can do to make the scrolling extra smooth. You can ensure that the game scrolls at a whole number of pixels-per-frame - avoiding any 'subpixel wobble' you may get by scrolling a fractional number of pixels per frame. 

Matrices are the 'right' way to approach this - but if you really can't use them, you can still create a hierarchy of nodes (as a tree) and do something along the lines of: 

UPDATED INFO: The idea is that I am trying to create a 2.5D terrain. The brown area is the cross section of the terrain and the 2D part. The green terrain is the "roof" and it has the z-depth set to give it the 2.5D perspective look. The problem is that the section in the circle should not be visible. One can see that there is a slight hill with the green roof, and then the terrain dips down. The roof of the terrain in the dip is not being blocked form view by the top roof part. It is the only section that this is happening. I have shaded the part that should be hidden in pink. 

As for my z-orders I have set the indices to create triangles in a counter-clockwise order. I think that part is correct as if I change the culling from back to front I get the expected results. The way I create the top mesh is to iterate backwards through a Box2D chainshape (that the physics uses) and setting the z to -10, I then loop again but this time from the start and add the positions with z set to 0. This creates a circular mesh. From top down this creates a rectangle that I subdivide into quads which I then break down into triangles. This is the code that does it: 

Today's target platform is... all of them! Or at least several of them. If you're making games commercially... you really want support as many platforms (and therefore as many potential customers) as possible/practical given the requirements of the game. 

If you just want collision detection, and not a full physics engine, it might be worth taking a look at OPCODE - $URL$ (although it is a bit old now, there may be newer/better things out there?) 

It may be of little practical use these days, but writing at a software renderer, at least a basic one (maybe just some spinning textured cubes), is a worthwhile exercise. Understanding how to transform, project, clip, depth-sort, rasterize, and texture map polygons yourself will give you a much better understanding of what 3D hardware and rendering APIs are doing 

This may be slightly off topic, but I'd suggest thinking very carefully about whether you really need day/night cycles for your project. By supporting that feature, you're essentially saying 'no baked-in lighting/shadows allowed', which will make it much more challenging to get pretty results, whichever engine you choose. A lot of people were recently wowed by the Epic Citadel iPhone/iPad demo. Technically, it's not doing anything incredible - it's a combination of good art and nicely baked-in lighting.