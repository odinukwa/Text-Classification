(You may note that there's a page number between the last grade of one of the candidates and the ID number of the next one right in the beginning of the fragment) So I had to find a way of detecting and removing the new line characters and the page numbers, and put each part of the string in the correct place taking into account that the names of the candidates could be of any size (Like "Anderson Soares Freixo" or "Maria Auxiliadora da Silva Santos Xavier". I came up with this code: 

2) When the program asks for a value to the extra bum, it says you can choose 0 for no extra bum, but you set the minimum input allowed to 1. So you must change min to 0. Answering some questions: 

I know these are minor changes, but I believe some of them may save some CPU and I hope they're useful for you. 

Other suggestions Well, the code has some bugs and I agree with what Fac Pam said about splitting the code into more functions since it's a little hard to follow it's flow. 

I made this script to carry out a specific real-life task, which was to sort a list of candidates in a public competition by grade. The file with the informations consists of a text file copied from part of a pdf with the ID, name, grade in the exam and grade in the composition. There are a little more than 1,000 candidates. I needed it sorted by the final grade, which is obtained by the formula: 

What you have is a very good start. I would suggest refining your exception type where possible. In your case, I would suggest using IllegalArgumentException. Using a specific subtype helps with diagnosing/debugging. Additionally, since IllegalArgumentException is a type of RuntimeException, you can then remove the from your method signature. 

Indeed, there isâ€”good catch! We can speed up the duplicate counting by using a instead, mapping a name to the number of times we've found it. (This is essentially a multi-set, but our standard libaries don't carry such a data structure, so we 'fake' it.) Our printing code will look quite different, though: 

The max delta idea feels a little awkward. If the idea is to stop something from going out of bounds, there may be easier methods. But if you're following the book, it may be best to stick with it. To me, the most natural approach to the issue would be introducing the concept of an axis. Ideally, an axis would abstract away other coordinates, translating our input for us: 

The code returns the first product, not the maximum product. For example, it returns 6240 instead of 7500 on input 60: 

Note: ObjectOutputStream.close() closes the underlying stream, which will close the socket's outputstream. It's not an issue here because the socket is closed immediately thereafter anyway, but you may want to flush rather than close in some circumstances, or to slip a close-ignoring filter in between. Subtle trouble has a potential issue in its nested loop: 

You have too many statics in your code structure. Eliminate all statics that are not effectively global or constant to your application. Specifically, and must not be static. Consider using the scoped try-with-resources (since Java 7) to acquire and close your connections, statements, and result sets. In case using Java 7 is not an option: your method has a copy-paste issue where you check for but close . (The use of finally looks great.) has multiple issues: 

When you say retry you mean something like a "play again"? In this case you could use something like: 

Well, I'm a beginner programmer too, so I won't be able to answer all your questions, but I have some suggestions: Some minor changes: 1) This part: 

(I used .format here because it's the way I know, but it's not ok to mix format and "%" styles in the code. You should change that for the sake of coherence!) 

I'm not an advanced programmer, but I have some suggestions I think could improve the performance of your code: 1) In the first line you make and then you use this variable 3 times calling . Instead, you could use , so you'd call this function just once. 2) I don't understand the use of here. At least in Python 3.5.2 I ran the code wihout the and it works just fine. 3) In the first if statement inside the for loop you test the minimum and maximum values of inp[1] twice. You probably wanted to test inp[2] in the last part. 4) Here: 

The code works, but I'd like to know if it could be improved (is there a clever and cleaner way of doing it?) and if the style is good. Thanks. (Here is a link to the original PDF file: $URL$ 

This file had some singularities: 1) The information about each candidate was separated by '/' and not by new lines. And each information about the candidate (ID, name, exam note, composition note) was separated by ',' 2) new line characters were spread randomly throughout the text (I think that was caused by the Notepad or by the PDF program auto-break line) 3) The page numbers of the original PDF remained in the text file, and could be found beside the ID number, one of the grades or between parts of a name, surrounded by new line characters like "\n26\n". The page numbers ranged from 15 to 26. This is a fragment of the original text as read by Python: 

This may sound really picky, but if this is actually some library code that you would like to reuse in different environments, then you might run into minor issues because of the line : 

I'm assuming that the reason for needing this is for some form of interoperability between a Java process/routine and a C++ process/routine. For the sake of having a more robust solution, have you considered using some form of serialization library to handle the byte array format for you? For instance, Google's Protocol Buffer project is perfect for creating a single definition of your data model, and then creating bindings for different languages (Java and C++ supported) so that you can serialize/deserialize that object from any source. Essentially you'd create an definition of the data you want to represent in a file (like so): 

This works fine on Linux machines, but Windows uses to denote line endings, and Mac traditionally uses for line endings (though I believe this is relaxed a little). If you were to run this code in those environments, your outputs may look strange or not separated at all. You can save yourself from some confusion down the road if you modify that line to be : 

What if you eventually want to serialize data that contains newlines? If the data you're about to serialize contains a newline, instead of throwing, you could simply replace it with a magic character that transforms back into the correct newline character for your system when you deserialize. Using is technically fine in the scenario that you're only looking for a character to delimit values, but if you're expecting that the serialized data is human readable on any system that it's created on (or copied to), then you might want to consider changing your delimiter to be something more platform friendly like a comma () or pipe () character. Alternatively, if making it readable isn't that important, possibly a non printing character? The Character is noted as a "Record Separator" in this symbol table.