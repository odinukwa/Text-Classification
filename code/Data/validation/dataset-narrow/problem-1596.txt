Use to check it DNS requests are getting resolved. Use a well known server by IP address (e.g., 8.8.8.8 or 1.1.1.1) –  Then try the same thing using the DNS server that you have configured. Then try pinging a "new" host (one that you're confident isn't in your local resolver cache. 

In cases like this it helps to break the problem down – which in turn means knowing something about the pieces that need to line up for a network connection to succeed. Much of this information isn't specific to the Pi or it's OS, but it will be helpful to know the tools and foibles of the particular hardware and OS that you are using. This question and its answers may help: How do I set up networking/WiFi/static IP address?. Testing with other devices on the same network may also help pinpoint where the problem lies. Rebooting often works wonders. In general you want to start close and expand as you test, so you might: 

There are a number of questions asking about installing/running FreeBSD on the Pi – it looks like there are a lot of problems. Is FreeBSD runnable on the Pi? How can I get started? 

A lot has changed, for the better, since the early days of FreeBSD on the Pi. In my experience installing and running a recent version (11 or 12) is pretty painless these days. Here are the steps that work for me on the "big" boards – I don't have a Pi Zero so I can't speak to them: 

Generate a key using ssh-keygen on the client, using the account that will be making the requests. Accept the default value for any prompts. Copy the public key (default file name is ~/.ssh/id_rsa.pub) to the target machine, and append to the file ~/.ssh/authorized_keys for the user that will run the commands. You can do this via From the client, you should be able to run commands on the target with a command like ssh -luser target command 

This will silently request that motion take a snapshot and discard the response. A symbolic link, lastsnap.jpg, in the motion file directory, will point to the snapshot itself. See $URL$ details on using http commands to control motion. 

Or probably better, use dhcp to assign an IP by changing "" to "" on the "" line, and delete the , , and directives. 

Assuming your pi is directly connected to the internet (no intervening router -- verify this by checking that "sudo ifconfig eth0" shows your 103.37.x.x address), you will need iptables rules to accept incoming connections on port 80. I don't have a config were I can test this specific scenario, but you will want something like this: 

After a apt-get update/apt-get upgrade ended with errors, my system became unusable. I was able to determine that the /boot partition was missing several files (useful ones, like kernel.img...) I copied the missing files from another pi's /boot partition, but I don't know if the versions are in sync with this one. The pi does boot, and seems to work correctly, although a couple of my startup customizations seems to have been lost. Is there a list of packages that I should reinstall to sync the files in /boot? The only files that were on /boot after it was corrupted were: 

If the SD card isn't called substitute the name you see in Finder. Then eject the card and put it back in the Pi and reboot the Pi. Next you need to figure out what IP address the Pi has been assigned. I'm assuming that it is "headless" so you can't just watch the console. That would be too easy... So, take a look at this question: Find Raspberry PI address on local network, my favorite method is to the broadcast address on the network () then use . Once you connect to the Pi run the command and permanently enable it is under Option 5, Interfacing Options. As I understand it, the trick in step 1 is a one-time thing. 

Take some time to read through the documentation for the module and your library. Then if you still need help tell us what you've tried and post the code that you're working on (or a relevant snippet). 

Well, 2GB is the limit of a signed 32-bit int, so you might well be right. Why is it signed? That's a harder question – it could be just defensive programming against the chance that somebody used an int where they should have used in unsigned int. Or, it could be that the math involved needs negative numbers. As to why it hasn't been compiled with large file support, that doesn't make sense to me... 

The internal design of the Kill-A-Watt does not physically isolate the low voltage circuitry from the mains power. A direct connection from the Kill-A-Watt to the Pi would allow for the possibility of destroying the Pi or a lethal injury if there was a malfunction. No responsible tutorial publisher would want the liability associated with such a design. 

where user is the username to use on the target (can be omitted if same user as the client) target is the name or ip address of the target command is the command to execute An example with a user account jim on target host utilipi might be 

On a linux client, this command will login to the pi, launch raspistill, and pipe the camera output (the .jpg) back to you. Using a certificate avoids scripting a password (see SSH login without password for an example of how to set up the cert). Syntax will vary, but the same thing can be done with windows ssh clients. I prefer this method for simple tasks, because it avoids the overhead of running a web server on the pi. 

You can execute shell commands remotely using ssh. has more info than you'll ever want -- here's the essential info: Let's call the host on which you want the commands to run the target, and the host requesting it the client. 

So I've had a chance to try out the RPi for this purpose. Short answer: it works great (with some limitations). The RPi does not support OpenGL. I approached this system with the idea of using a python environment to create and present experiments. There are two good options for this that I know of, opensesame and psychopy. Psychopy requires an OpenGL python backend (pyglet), so it won't run on the Rpi. Opensesame gives you the option of using the same backend as PsychoPy uses but has other options, one of which does not rely on openGL (based on pygames). This 'legacy' backend works just fine. But the absence of openGL means that graphics rely solely on the 700 mHz CPU, which quickly gets overloaded with any sort of rapidly changing visual stimuli (ie. flowing gabors, video, etc.). The RPi does have a very good video card (for a $25 computer) that supports OpenGL ES. Riverbank software provides python bindings for OpenGL ES (pogles), so there is the possibility for hardware acceleration in python. This has not currently been implemented on PsychoPy or Opensesame. It probably won't happen anytime soon, because there is currently an additional limitation on this system: there's no way to use OpenGL ES in the linux windowing environment (xwindows). This will probably be developed in the medium-term. But currently even a lightweight version of xwindows on the RPi is noticeably clunky and slow (overclocking the CPU helps with this). OpenGL can be used on the Pi through CPU emulation (via Mesa)... but this so heavily overloads the CPU that it's effectively useless. So the RPi is not well suited for displaying rapidly changing visual stimuli (ie. flowing gabors, video). And PsychoPy effectively doesn't run. But Opensesame runs fine with the non-openGL 'legacy' backend. For a manual RT experiment involving the presentation of static images, this setup running on the Pi will have much the same timing resolution as the same setup running on any other computer. And it will get better, probably pretty quickly. OpenGL ES support in xwindows should come pretty quick, and once this is available it will be possible to use OpenGL ES python bindings currently under development to make backends for PsychoPy and OpenSesame. These will support fluid moving stimuli and video, and free up the CPU for other tasks. My personal hope is that this will free enough resources to allow the RPi to interface with other systems... like an eye-tracker computer or an eeg amp. But for now it seems just fine for basic no-video psychophysics. And it's very, very cheap... even factoring in the cost of a small DVI monitor you should be able to get a data collection system up and running for less than 100 euro. 

If you have a clear shot to the buoy you should do some tests. You may be able to get considerably more than the nominal range with no obstructions in the way. Do a test on the beach or in a field where you don't have to go for a swim... On the shore side there are "tricks" you can do to improve the efficiency of the antenna. That would also help with your range. A search on will net you lots of ideas to try. 

Look at the efficiency specs on the converter (higher is better) and get the lowest power rating that will do the job. Both of those will reduce the waste heat produced by the power supply. Is there any chance of either venting the space where the project is installed or putting the power supply outside of the space in free air? 

Once the Pi is up and running, login – ssh, keyboard & display, or serial all work (for credentials use or you can also login with if you're on a serial line or the keyboard) and have fun. If you are doing a headless install it may be a trick to get to connect to the Pi. Find Raspberry PI address on local network gives some good techniques for finding the IP address assigned to your Pi. Once you have it: 

I would avoid building your own components and consider using an established (and UL-listed) solution that you can manage with your Pi. You could replace your existing wall switches with (for example) Insteon switches, and use software like Openhab to manage them. The switches still have local control, and Openhab can tell what state they're in and turn them on/off or adjust dim levels. In addition to Insteon, you can look into UPB and Z-Wave controlled switches; each of these systems has their advocates. The one downside is that these switches generally require a neutral wire in addition to the hot that is switched. Depending on the age of your house and the habits of the electricians that wired it, you may or may not have that wire available. This doesn't have quite as much DIY mojo as what you are planning, but it avoids the (small) risks associated with switching high-voltage with non-conventional devices. 

This will bypass the handoff of those requests to the NAT logic on the FORWARD chain. (If you have existing rules on the INPUT chain, you may want -I to insert these new rules at the beginning rather than -A to append them at the end). Before you do this you should be sure you have physical access to the pi in case you lock out remote access. Don't save the iptables config until you're sure it works the way you want it to. You should also be aware that allowing direct access from the internet can be risky. You should be prepared to update your system regularly (perhaps even daily) to apply new security fixes; you should also make sure your web server config doesn't have any unnecessary modules loaded or allow any unintended access. My final advice would be to make a backup of the working system, and be prepared to trash the running copy if it is compromised in some way.