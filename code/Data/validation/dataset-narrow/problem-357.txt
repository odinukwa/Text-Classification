Unfortunately, that looks like you're not allowed to use tab either. (Test: Informix 12.10.FC5 on Mac OS X 10.11.6.) Incidentally, I tried some alternatives: (alert, aka Control-G) and (backspace, aka Control-H) are both accepted, but none of (formfeed, aka Control-L), (vertical tab, aka Control-K), (carriage return, aka Control-M) of (newline, aka Control-J) are allowed. Any other control character from through (octal numbers, all except 9-13 decimal, 011-015 octal) seems to be OK (and NUL or 0 being OK did surprise me!). Do you have any tabs in your main data? If not, you could export with one of the acceptable alternative characters and then map that to tab. If you have tabs, life is harder because you'd need to protect any tabs that are in a data field with a backslash. DB-Access allows without problem and produces an unload file with tab delimiters, so the problem is not in the shell code I'm using. If you're certain you must have tabs, then investigate Art Kagel's which is part of his package from the IIUG Software Repository, which also uses my SQLCMD, available from the same source. Using (or , or various other twists of the command line) produces output in a tab-delimited format. (On its own, SQLCMD does not handle a full export; it will cheerfully unload single tables, though. It does not yet handle NUL as a field separator or line separator — a design decision or artefact that I need to review.) 

This uses the fact that the flag column contains either or and sorts before . So, if there are two rows for a given key, the value will be selected, else the value will be selected. 

The answer may depend on the DBMS which you're using. However, in the DBMS I'm most familiar with (Informix), when you start a transaction explicitly as shown, I would expect that if there is an error in SP2, then an exception would be raised in SP2, and since there is no exception handling in SP3 either, the error would propagate back to the caller — and the COMMIT in SP3 would not be executed. The caller would need to know that the transaction was started and decide whether to commit or rollback. If the caller didn't make that decision and simply exited, the transaction would be rolled back (because it was never committed explicitly). As a consequence of this, the actions completed by SP1 would not be automatically rolled back, and neither would the actions completed by SP2 (but the SQL operation that triggered the error would be treated as if it was never executed). I observe that the lack of exception handling means that the stored procedure SP3 is not very well written. Since it starts a transaction, it should handle errors and ensure that the transaction is rolled back if an error occurs (or committed if that is deemed to be the better course of action). It should never leave a transaction in flight as there was no transaction in flight when it was called. I believe some other DBMS take the (to my mind) draconian view that once an error has occurred in a transaction, all further operations also fail and the transaction will be rolled back. That seems overly intolerant. If I understand their manuals correctly, it means that if you try to insert a record and find that the record already exists, you can't do an update instead. I hope I misread that book (or that the book was mistaken). But it does emphasize the importance of stipulating the database you're using — different DBMS may have different answers to the same question. 

You might also want to switch to , because, as SQL Server does not support unsigned types, you will have only 127 positive values using the type. Additionally, if you want to ensure the values cannot be negative or nil, you can add a check constraint: 

The performance will likely remain the same as with your syntax, but without making the query any faster this rewrite will at least make it more concise and arguably more readable. That being said, there is another method, fairly common as well, that you could employ, which might offer better performance as the number of the attributes increases. It uses grouping and aggregation: 

Of course, it would probably be better to use the window functions in the WHERE clause directly, but that is restricted by the syntax: window functions are only allowed in SELECT and ORDER BY. 

That is basically it. If you need to return the result as a single-row single-column dataset or otherwise use it as a derived table in another query, you will probably want to assign an alias to the aggregated column by changing the line to this: 

When either country or region is not set, the composite foreign key will not be checked because of the NULL(s) – similarly to how a single-column foreign key is not checked if it is null. If both columns are set, however, all three foreign keys will work, preventing the discrepancy in the regions between tUsers and tCountries. 

The figures seem correct now, so how can you turn those , into , ? Why, by using another CASE expression, of course: 

The error indicates that you have invalid references in the column. This error shows when you are trying to insert a row with an invalid reference, update an existing row with an invalid reference, or delete a row that is referenced. You also get it when you are trying to create a foreign key constraint on a column that is already populated and contains references to non-existing rows, which is what happens in your case. Solution: check the contents of the column and correct/remove the invalid references. 

The PRINT statement will print nothing if the expression evaluates to a null. Apparently ends up being null as the result of the preceding statement, causing the PRINT to output nothing. If you want to print something even when the variable is null, use ISNULL or COALESCE: 

Updating the list is implemented in the form of additional computed columns without explicit aliases, namely these: 

Again, that would be wrong. Fruit may well be related to food item 100 as may vegetable , but if these two items are not related to each other, there is no reason to store them on the same row. Commonly, when you want to store a relationship between a subset and an item, you use a separate table. As you have two subsets of different kinds that are related to the same item, you just use two tables. So it would be: 

If the count results need to be returned in one column, here is one way to do that avoiding unions. First, label each row with a value representing the bucket in which the date falls (30 for the bucket of 0 to 30 days, 60 for 30 to 60, and 90 for 60 to 90): 

If you are aware that this might be a problem in the future, you can create your procedure with a SPECIFIC name, which must be unique across all procedures in the database. If you aren't aware that it will be a problem when you create the procedure, then you can't officially go back and add a specific name, and you do have a problem. The UPDATE of in the selected answer should only work if the user is connected as (or, in the case of a private server, the server owner). 

If you have support for your Informix product, you should probably contact IBM/Informix Technical Support. If you don't, you might do better via the IIUG mailing lists. It is free to join and you can choose which lists you receive. You probably want the 'ids@iiug.org' mailing list. Failing that, over time, and possibly with increasingly fiddly diagnostics, we might eventually get to the bottom of the trouble. But to do so, I'll need answers to at least some of the questions above. 

You say the directory has permission; does it also have permission. You need permission to access the files in a directory (so you might set the permissions on the directory to ... gritted teeth ... 777, but you shouldn't. Is the directory owned by user and does it belong to group ? Ideally, it should be owned by , and the permissions should be 770 (or ). 

Contract — holding the single-valued data about a contract, excluding receipts. It might record the latest receipt number for the contract, but that would be an optimization, storing derivable data. Primary Key: Contract Number (aka Lot Number). Contract Items — holding the 1-6 items for the contract. Primary Key: Lot Number, Lot Sequence Number. Lot Number is a Foreign Key reference to Contract. Receipts — holding information about receipts. Primary Key: Receipt Number. Foreign Key: Contract Number reference to Contract again. 

Using means 'the table called found in the database ', whereas you want to refer to the table owned by user in the current database. For that, you need a (not a ) between the user name (schema name in standard SQL) and the table name. When that's fixed, you get the error: 

(When the expression is quoted, you get the error .) You have some curious types in the table — DECIMAL(2,0) is not a common type (consider , for example — though I suspect you mean ). The other problem is that you've passed 26 arguments to the procedure, but the you created only takes 22 arguments. You're also trying to pass where the procedure expects a . In fact, after the second argument, the alignment of arguments given and arguments expected goes haywire; I can't work out what is supposed to be what. If ever you needed an argument against huge parameter lists, this code is it. This mismatch leads to the error because functions in Informix can be overloaded based on the argument list, so your call doesn't match the function that is defined, so presumably you were attempting to call a different function that couldn't be found. When you get past those issues, by editing the EXECUTE PROCEDURE statement, you then run into problems with the notation: 

One is to try downloading the ILS — International Language Supplement. This has many extra locales in it; it might have (but no promises). Another is to try copying an existing locale (maybe or to . You'd probably want to edit the LANGUAGE and TERRITORY lines. However, be aware that the French and German locales are different; it will matter which you choose. Report a problem to IBM Informix Tech Support, requesting the file for . 

Additionally, you could make the query return the smallest matching set (i.e. first try to return the first set of exactly three consecutive numbers if it exists, otherwise four, five etc.), like this: 

The first predicate matches the rooms, obviously, and the other two determine if the ranges intersect. Any two ranges intersect if the beginning of each is less than the end of the other. Secondly, take the time difference between and . Finally, just aggregate the time differences per user. So, the complete query might look like this: 

If you insist on storing the results in a table, you can just add an INTO clause to the query. A possibly better idea, though, might be to save the query as a view. 

you cannot expect to get a match on every ID in the list. This is because is not expanded into a list and instead is treated as a single item of the IN list. The commas inside it will be seen as just characters inside a string value, not as syntactic delimiters. In order to use the way you want, you will have to build and execute a dynamic query around the value of . It could be something like this: 

The recursive CTE extracts from the previous CTE's result set only the adjacent ranges starting with the row with the lowest ID. It also adds a "zeroth range", one that starts with 0 and ends with the lowest ID. This is the output: 

because in your case would be an invalid reference: that column is not in GROUP BY and may not be referenced without being enclosed in a (non-window) aggregate function. Your main query already aggregates it using SUM – that is how it can be used in as well: 

The immediate issue with your first statement is that it has BEGIN without a corresponding END. In this case, END should be at the very end of the CREATE TRIGGER statement. Once you add the END keyword, the statement becomes technically correct, but you will have trouble executing it in MySQL. The reason is that semicolons, while being standard statement delimiters in SQL, are also treated by MySQL in a special way. MySQL splits the input text at semicolons and sends each part of the text to the server separately. The server thus receives incomplete, syntactically incorrect pieces and returns an error. See here for more details: 

Get all permissions Now if you want just to return all effective permissions, you can adapt the GetPermissionStatus function: 

That may look like redundant coding, which it probably is, and there are ways to eliminate the redundancy in this case – for instance by using a derived table: 

In this case, and are aggregated before they are joined to . As a result of grouping by , neither derived table has duplicate entries at the time of joining. That prevents the joins from producing mini-Cartesian products – the effect you were experiencing with your original query. 

I cannot see a problem here. If anything, I would say the problem was with the older behaviour, because it was just inconsistent. Depending on whether was passed as a literal or as a column value, TIME would return you either a or a null. Since version 5.6, however, it consistently returns . So, to answer why the behaviour changed, the previous behaviour was buggy and the new one is (more) consistent.