To stop a service doesn't prevent the deamon to start the service on boot. For this you should deactivate the service to come up on all run levels A simple command for this on raspbian is 

Based on your comment, I recommend to check pigpio where a Java wrapper exists. The libraryâ€‹ is maintained by another user of this community. The wrapper is also well documented. I think with this you can develop bit more efficient. 

it is not nessesary to expand the file system, but gives you the maximum of available space of the SD card. Therefore it's recommended and in newer releases the resize will be done automatically ( i think i was reading something like that) Auto resize a part of NOOBs and will not be done in Raspbian. The downloaded images are mostly smaller than a SD Card and there will be disk space unused left on the card. By expanding the space this will be available for additional package installations or for data as user data, logs, ... The addidional space made available by resize cant be there by default, because after copying the image to the card raspbian doesn't know how much space is there or if the user wants to create another partitions with it. 

You say it works fine now but it sounds quite inefficient and it will take longer and longer as you add stars and add frames. To speed things up you should look at reusing the Rect objects, and using the method to move each Rect object to where you want. Then you don't have to delete and destroy objects, reallocate memory, and create and resize arrays for each frame. I don't know enough about pygame to know whether painting 200 Rects black and then 200 white is better or worse than just clearing the whole surface black, drawing your white dots and then calling (without passing all the rects). 

If you like coding in C, you should look at wiringpi, if you prefer python, then look at RPi.GPIO. Either library will let you easily access the GPIO pins and trigger anything you want when something happens to your GPIO pins. Basically all you need to do is choose one GPIO pin to use, and tell the library that that one should be an input. Then you should set up some kind of callback or interrupt so that some function of yours is called when the value of that input pin goes either high or low. In your case, your relay could connect the input pin to the Ground pin, and you'd use an internal pullup resistor so that the normal state of the pin is high. This way, low means that the relay has connected those two pins, and high means that it hasn't. Just set up a callback to notify you when the input value goes high (a rising edge), and that will tell you that the relay has stopped connecting them. Once you set this running, it doesn't actually load the Pi much at all - just waiting for the edge doesn't require any noticeable work this way. So the Pi can be doing all your other stuff at the same time. 

Okay... Your system is starting transmission with the script. So all you need to do is to edit this to include the log file option: Change the line: 

Okay, whats going on here is probably that your ISP is using NAT, and the IP address your router has is in the private range. The only way to get it to work without a VPN or some other tunneling*, is to ask your ISP to assign you a public IP address. Some ISPs do this for an extra fee, some for free and some just don't. *ngrok is one such provider, there are others, and may or may not suit your purposes. 

At work, we have used the Behringer UCA202 with the Raspberry Pi, (Pi 2 and Pi 3) with JACK, similar to what you'd set up for sound recording. It is powered from the Pi's USB ports. Yes, it "should" be safe to assume that a compliant card should not draw more than the 500 mA specified for USB. If you have other stuff hooked up to USB it is always better to use external power, so that's yes to your first question too. I have tested different external USB sound cards with the Pi, and the not-so-positive answer is that they sometimes work and sometimes not. That cards are USB compliant is no guarantee that they will work with Linux. I have not tried the cards you mention and the difference seems to be design and the pre-amp chip. That may or may not be important for Linux compatibility. If you buy the card from a good dealer, ask them if you can check if it works and get an option to select another card if it doesn't (or get a refund). We've done that in our local shop, they tend to be helpful. Another thing, the Pi does not like hot plugging USB powered devices. If you know you will do that, get a powered hub. 

Here's the first hit I get when I search for this: $URL$ According to that link, "down" means a regular logout, and "crash" means that it couldn't find a logout entry so it assumes that it crashed at the given time. Maybe you pulled the power or something. tty is a terminal, pts is apparently a "pseudoterminal", not sure what that means, but pts/0 is therefore pseudoterminal number zero. Also, is your friend. Maybe try as a parameter to to get it to show the hostname for 192.168.1.3, otherwise use something like on your laptop to confirm that it has that IP address. 

Steganography, a video of a cat, and youtube. Or alternatively, an F2F network. You don't make it clear whether you need to keep secret: (a) the content being transferred, (b) the sender, or (c) the recipient or recipients. It may not be easy to keep all 3 completely 100% guaranteed secret. When you mention tor, you probably mean Tor's hidden services. 

With this, the RPi will connect to Open WiFis automatically. If you want to connect to the "nearest" network, you should write a small script. With you get a list of Wifis an its signal level. You can select which are 

and a script that scrape the SSISD form the output and write this to a text file. Use this text file to provide a select list in the config web site. This "get ssid" script run periodical you can use some ajax to refresh the config web page... ... but this is maybe just an approach if you have many users or like to fiddle around. ;) 

can be an option to get some more memory during the apt-get process. If you run your raspberry without GUI try to reduce the memory allocated for graphics. 

This is a really vague question, or set of questions. You might want to start by searching the internet to get some ideas, and then ask more specific questions once you've decided what you want. You could search for "raspberry pi robot" or they're often known as "pibot" for short. There is boatloads of information available and loads of different designs you can use as starting points. Basically, if you're building a robot you're going to want to use some kind of motor, so you will need some kind of interfacing board between the pi and the motors. An Arduino can do this, or something like a Gertboard maybe. One starting point might be The MagPi issue 6, which talks about the basics using an old BigTrak. Other issues of the same magazine deal with other aspects of the design as it is built up. Or you can buy a book ("PiBot: Build Your Own Raspberry Pi Powered Robot") or even buy a basic online course (same author, same title). You might find some further ideas at let's make robots. Yes, you're going to have to solve the power problem, presumably using some kind of battery-powered supply for the pi and all the other stuff. Yes you can use sensors, lots of different kinds. Yes you can also stream camera images if you have wifi. I don't really see why you'd want to synchronize two raspberries but for sure they can communicate with each other, probably again over wifi. 

This is the 5% file system overhead reserved for root. This percentage may be tuned, but normally it is not advisable as the overhead is needed for the system to function properly. My advise is to consider moving some of your data to a network or USB disk. 

Okay, got inspired and checked omxplayer out. I've worked some with VLC, but not omxplayer. It turns out that omxplayer has a DBUS interface with which it can be controlled. But I also discovered that there is a option that can be useful. If I don't kill the omxplayers already running, starting the new player in a higher layer (higher ) puts that video on top, pretty much instantaneous. Then I kill of the previously started videos in the background. A big improvement. My quick and dirty code: 

I use Owncloud for a similar use case. As for Google Drive, OneDrive, ... you need a dedicated app (existing for iOS or Android) or you can access your own Owncloud with the browser. For desktop existing clients for Windows, OSX and Linux. For installing the Owncloud server on your RPi you need a Webserver with PHP support. If you want to access the files over internet, i'd suggest to use HTTPS. You can use self signed SSL certificates or a SSL cert from a trusted CA. Here is a tutorial for setting up a Owncloud with "Let's encrypt" certificates and here a tutorial for self signed certificates My Owncloud is running with self signed certificates, but the Let's encrypt certificates should be now the preferred solution (nevertheless it's good to learn more about generation of certificates). In my idea, if you just want to share few files with few persons a SQLite3 data base is sufficient. As storage you can use a flash drive for storing the files, this will minimize IO on your SD card. 

This would be a great (in several ways) project, but I think that a passive AF system using contrast measurement is not feasible with the kind of focus system possible with the Raspberry Pi camera. So, in theory it could be done, but I'd say at a considerable development cost. Look for an USB camera with autofokus. 

Yes, there certainly are such lcd screens, both with and without touchscreen. Adafruit is one supplier with a large selection, there are others too. They usually have a step-by-step tutorial for their products. 

In Panel Preferences, you can select your panel in "Currently loaded plugins", and move it "up" or "down", which means left or right if you have a horisontal panel. 

There are bridges that do this available. Arduberry springs to mind. Try googling for "rpi arduino shields" and you will get some options. Don't count on all shields to be supported, though. 

But that still might not fix your USB A port access (if you need it), and it still doesn't solve the problem that your Pi is going to rattle around in that case if you don't use the board mounting screws like a proper Pi case has. Plus your box is much bigger than it needs to be, mounting diagonally and wasting space, and you're still going to have at least a power cable coming out of the lid (if you don't want to drill holes in the metal). All in all, maybe this case isn't quite as "near-perfect" as it first appeared? 

It sounds like you're 80% of the way there, you just need to link the bits together. Instead of just outputting a "3" or a "4", you need to remember the previous button numbers. One way would be to hold a string (and append to it), another would be to hold a list of integers and add integers to the list. Then in your webpy script you wouldn't return the same fixed string each time, but you'd return either the string you've remembered, or a string made from your integer list. Try doing this bit first, before you link it up to the GPIO pins, just return a string which is different each time. 

The Arduberry communicates with the RPi over a simple serial line (as would any arduino), there is no direct access to the RPi filesystem. However, you can write a sketch for the Arduberry to communicate with a process on the RPi that stores data on the RPi filesystem. To my knowledge there is no readymade solution for this. 

I don't have much experience from bare metal programming on the Pi, but I do know that is much like working with a MCU. You should think of it as if the Pi is an Arduino and your programming environment is a computer with cross compiler, kind of like the Arduino IDE. (just not an IDE in this case). Following that analogy, there are no drivers to "install". Instead you need include libraries that support the hardware you intend to use. I guess you are aware of that as ethernet is not supported out-of-the-box for bare metal Pi, it is supported by the USPi library. The documentation for a library/driver should tell you how to use it. Or you'll need to read the source code and possible examples. And all configuration for WiFi must be done when writing the code. Or code must be written to allow configuration, like when using an ESP8266 with the Arduino IDE, in which case you must also provide a user interface to do the actual configuration. As of February 2018 I'm not aware of any WiFi library/driver for bare metal Pi, any pointers or links are welcome! An obvious solution for bare metal gurus would be to port an existing library for ARM. For RPi 3 and Pi Zero W users that want to take advantage of the internal WiFi, there is a complicating factor: the Broadcom chip is not exactly well documented.. Now, I'm ramblin', but it seems to me you are crossing the creek to get water.... If you just want synchronized multi-room audio, there are other solutions that can take latency into account. Just google for it. Some of these work on the RPi too, and does not require you going bare metal. On the other hand; if you want to educate yourself, you're up for an adventure!