Now, you might wonder why bother having at all; with non-member functions seems to do fine. This is true; the only advantage of currently is that it collects member functions into a well-defined scope. However, this is not always worthwhile, and you should feel free to just stick with using non-member functions. I would reconsider . A direct translation would be 

for state, though. This is a very bad idea. is an input argument, whereas and are locals. Pass them around as function arguments, because that's how they're meant to be passed around. Faux-pas globals are much, much worse. Just make functions, doing function-y things. It'll be cleaner and better express the intent. 

TL;DR: Just use PyPy; it gets you to about 10x the time of C++. If you really want to use CPython, a lot of clever optimizations (not algorithm changes) gets you as fast as PyPy and then using Numpy gets you close to C++ (2x the time). 

! This is fixable. The neatest way I can think of is to use an , which fixes insertion order. All you would have to do is 

This is not strictly true. Any function that modifies its input as its primary output is in-place. Consider : 

The first thing I note is that your naming is too terse. What is ? ? ? ? ? ? ? ? I have no idea. I think might stand for . Secondly, your one comment exists seemingly solely to confuse: 

since each subsection is a logically separate action. In fact, you could make each a separate function if you wanted. Consdier the first branch. 

If and are wildly different (they can be up to \$10^6-1\$ different) then this will take a long time. For a maximum of \$10^6\$ iterations, this could take a while. What you should do instead is pre-process the string so you can quickly do 

Well, let's try and write it a little nicer, eh? First, a real argument parser is a good idea. I like Docopt, because it's so simple that it's normally easier than a hacky manual parse: 

This does mean there's more boilerplate, since it exists for each piece of functionality you add, but the logic itself is an order of magnitude simpler. 

Your solution is recursive and does a lot of allocation. A much more effective way would be to make a function using this Wikipedia section, either generating them lexicographically or by some more efficient method. 

This gives a noticeable speed improvement. Frankly, though, if you want a reasonably fast integer selection sort, use an array. is unboxed, which means that it's some 4x the speed. It's actually faster to copy into a temporary , sort and copy it back than to sort in a boxed . 

I don't like the idea that you're decoding and re-encoding the position into a single number. I also don't like the assumption that the board is square; it seems like a rather pointless and unhelpful one. Those checks are probably wrong, too. So lets try to fix that up and make this class a bit comfier. First, cache the width and height 

You write but should really write ; you end up multiplying the result by whenever you use it anyway! You can also extract the zeroing logic: 

since in Python. I suggest doing so since it makes the action self-explanatory. This could be better with formatting: 

Your code could do with doc comments; at least could. These don't need to be long. There's nothing wrong with caching files locally, but I would suggest writing to . returns a file-like object. Moments later you use on a file object but you neglect to do so on 's! I would do an early return in . Your check is strange; if it's a directory instead you don't actually deal with the resulting problem. It's not a big deal, but I would use to prevent it looking like you're actually checking. would be better as a default argument, and I'd call it or even . IMHO isn't that great a name either. Here's the updated code, still writing to the same file: 

which always allocates a new , one can index with a borrowed . Sadly this isn't supported by the API right now, but you can hack around it: 

This isn't as nice as the Julia code, but it's giving you a lot of opportunities to be a lot more efficient, and it's catching a lot more errors. It's true that locking feels like a chore on 50-line examples, but it fits Rust's macro-goals of faster, safer APIs. 

I'll assume the first few style changes that jonrsharpe mentioned. I think setting up colours separately to other constants is actually advisable, but you should at least use the class: 

You need to invert the condition to . Then you find a noticeable speed improvement of roughly 10x to the overall algorithm. You should think of better names. instead of ; instead of . A much prettier way is to filter an infinite sequence with and take the th. 

Your is an exception, so should be called . It's also not needed since already occupies this nich√©. You should break this onto multiple lines: 

I don't have installed (yet) so I'm going blind here, but I have a few comments. First, the problem you described can be solved very easily with : 

Get input Put input into an iterator Call function, which a. Puts input back into new collection b. Sorts collection c. Creates newer collection, a d. Merges new collection into newer collection 

\$\sub{s}\$ can be stored in a 10-long array, the sum of which solves your original problem: $$ \left[\ \sub{s}^0;\ \text{sub}_s^1;\ \text{sub}_s^2;\ \ldots;\ \text{sub}_s^9\ \right] $$ Clearly, for the empty string \$\varnothing\$, we have $$ \text{sub}_\varnothing = \left[\ 0;\ 0;\ 0;\ \ldots;\ 0\ \right] $$ The interesting trick is that extending a string \$s\$ with digit \$d\$ is a simple update $$ \sub{sd}^n = \begin{cases} \sub{s}^n & \text{if}\;n \ne d\\ 1 + \sum_{i=0}^{n} \sub{s}^i & \text{if}\;n = d \end{cases} $$ as the paths for subsequences that don't end in \$d\$ are unchanged and the subsequences that do end in \$d\$ are \$d\$ itself, \$d\$ added to the end of any prior subsequence that ends in a digit less than \$d\$, or any of the prior subsequences that did end with the digit already.