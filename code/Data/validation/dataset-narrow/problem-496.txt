So, that is 'can the code be improved?' and 'will sorting help' As for the 'unrolled' (no recursion) version of the system, it can be done. It would require three int[] arrays: 

Which make specific implementations of generic Interfaces. I have no problem with this, it is nice, and clean. Then you also have: 

There's the potential for integer overflow when calculating the mid point. This is a 'famous' bug. Your code should be done as: 

That's a relatively complicated loop. It puts both the readline, and the loop-check in the same place. It reads the line in to , then also makes sure that is not empty. While the above is relatively uncommon to see, it makes the conditional really concise, and reduces duplicate checks. Oh, and using a on the resulting list makes the print really easy.... 

The above method will return a list of factors that have the target as a product. How would that be coded? First, some math.... 

You need to have a fresh array instance for each row. Even though it is mundane, the logical way to do it is: 

You say the problem is to find missing values from a 'Range', but your method only takes a start value, not an end value.... is this intentional? The method comment says: 

If you want to get a real interface-based system going, where the implementation is opaque outside the package, then there are a few things you should do to bring the interface out of the struct. First up, your struct should not be exposed, drop the capitalization... to . This will immediately make your method fail because you can't really export the type outside the package now, but that's OK, because you should not be exporting the struct, you should export the interface. This makes the signature of become: 

The advantage of the above is that you do not need to manually track the size of your data, and you do not need to keep allocating new ByteBuffers each time, 

Why? Why use a Queue to implement a stack? A Queue, by definition, (Computer Science Definition, not Java interface) is a FIFO device. A Stack, by definition, is a LIFO device. They are significant opposites of each other. Doing it this way is .... silly. Also, it is not using the features of a FIFO queue to do the work, it is using the features of a Collection (add, addAll, Iterable). The only methods you should be calling on the queue are add, and remove. A native array with a size would be a much, much better implementation, and would have \$O(1)\$ and complexity, with occasional \$O(n)\$ if a resize is needed. Also, your code is buggy, three things: 

Note that, in the above code, the key features are that it uses the enumerate mechanism to get both the index and value from the input array. This allows us to identify the left-most index of the data that contains the complete set. That set is found by resetting the pointer each time there's a new distinct value. Once it has fully scanned the input, it then starts from the right side, and removes each distinct value it finds from the . When the dict is empty, it means we have covered the entire distinct set of values. The difference between the end of the left set, and the start of the right set, is the number of solutions that are possible. Performance I compared the performance of my algorithm with that of Ashwini's. The solution I propose is about 40 times faster, for larger inputs, and about 10 times faster for smaller ones. This makes me believe that the time-complexity of my solution has a reduced dimension somewhere, compared to the other. I am not exactly sure why it is so much faster, or what that dimension is.... Here's how I tested them all.... note that your solution effectively does not complete the larger test cases... it's simply not scalable enough. First, though, the results: 

Now, I have taken that concept and implemented it on Ideone, and you can see that it arrives at the right solution, using a simple algorithm, in almost no time. 

Discussing performance of methods which are almost entirely in the main method, is sort of pointless. Java performance requires hot-spot compiling, and that does not really happen until methods are run many, many times. The main method is run just once, so is seldom compiled efficiently. Perhaps it's only ever interpreted. In terms of efficiency, the algorithm you are using is documented as being the best for this puzzle. Essentially there is no better way. Your subsequent question about how to incorporate additional multiples is complicated.... the way the algorithm works right now, is to calculate the sum of multiple sequences. One sequence is: 

That's doing a native object comparison, and you are comparing , and not . This is bound to fail, and I am surprised it works for you (I presume Java is reusing Objects for your int value boxing). You should be calling this instead: 

Now, if you want to find a search string that is a complete suffix (like "bar"), then the binary search will find it no problem, and return true. But, what if you want tos earch for an "infix", or a not-complete suffix, for example, "ba"? Well, "ba" would normally fit alphabetically between "ar" and "bar". The will return the 'insertion point' of -2. The -2 indicates that there was not an exact match, but if we want to insert the value in the array, we would insert it before the element at , or, since the ip is , at , or before position 1. Note though, that because of the alphabetic order, if the search term is an infix, it is by definition, a prefix of a suffix ;-), and if it is a prefix of a suffix, the suffix it is a prefix of is alphabetically immediately after it. So, if the search term matches the start of the insertion-point value, then the search term is an infix of the original word. That's all just a complicated way of saying: if the search term is an exact match of a suffix, it is a match, or, if it matches the beginning of the suffix alphabetically after it, it is a match. Either way, you can locate that match with the binary search, and test the insertion point. Code 

Like most times, it is best to validate your data before you use it. In your case, since the input data needs to be validated by the Database infrastructure, I recommend adding it to the interface. I also assume that the is the you want to run, and not part of the user/login information. I suspect the logical thing to do is to extend your interface to look like: 

Variables I understand why you have the and to avoid confusion about where those variables come from... If you need the as part of the teaching exercise, then sure. Otherwise, I would recommend three things.... 

By taking the address of the var and giving it to flag, we can then use the variables as-is later without having to keep the pointer handling at all, so code like: 

You have an interesting problem to solve. Your solution would be helped a lot with a small extension to the class. Consider the following version of it: 

Then, when you construct you should also add all the thresholds and messages that are needed in the class. By doing this, the actual implementations ( , , etc.) become simple classes with just a constructor and no methods at all. The Base class does all the heavy-lifting, and the code is in one place only. 

You want the 'outside' code to look something like (this code will be in the resource-using threads): 

I have a feeling your application is slow because it does a lot of network access ... ;-) The amount of time in your code will be a very small fraction of the actual 'latency'. So, the question is not "How can we make your code faster?" but rather it is "How can we reduce the amount of network traffic?" I am not very well versed with managing the performance of the javamail API. When I have used it the Mail servers have been local, and not really a factor in performance... But, without actually trying it myself, you should be using the method. Also, there's no real need for the outside . Sometimes it is better to explain with code, rather than with blurb: 

Your description says that you want to check whether the is less than 10 minutes old. Your code does something different, though. Your code checks whether there's less than 10 minutes between the times (the difference is <= 10 minutes .... If the searchTimestamp is 2 minutes in the future, it will pass the test, if it is 9 minutes in the future, it will pass the test, and if it is 11 minutes in the future, it will fail the test. Of interest, the math you use does a 10 minute check, but the message says "greater than 5 minutes old." Your message should say: "timestamp is older than 10 minutes, or more than 10 minutes in the future" So, changing your code to be what I think it should be, is a lot simpler than you would think. What you want is for the to have happened sometime after 10 minutes ago.... this is the way to do it: 

Mike is correct that you are repeating the sum multiple times for each value. A simple array with the stored sum will make a huge difference. On the other hand, you are also doing a huge amount of unnecessary work in here: 

Using the full implies there is a class called , which there is not. The subclass hierarchy is also overkill. I would prefer a single final and immutable class. There is no reason why a single and cannot accommodate both sides of the result (with, and without an exception): 

then the i-loop will never get far enough in to the String to make a problem - remember, the requirement is that the front/back are not overlapping. For what it's worth, I would consider a loop in the other direction.... 

Then, the above code changes the value of that variable, runs the expression, and returns the first Element. That last part is double-important. The call is much better than because the does two things: it stops searching when the first instance is found so it is faster; it also does not throw an exception if there is no result (instead it returns null). Other Otherwise, I can't see anything else that's 'off' with the JDOM usage. Using some short-cut methods will help, the evaluateFirst XPath method is important. I like how you have used the live-iterator code for manipulating the document. As an aside, I like using a for-loop with Iterators. Where you have: 

Despite your assurances that a ScheduledExecutorService is not up to your needs, I think you are wrong. But, for good reasons, not bad reasons. the tools often need to thought of in a back-to-front manner, and, if you reverse the logic of your problem, the solution is actually quite simple. What you want to do in order to solve the problem, is to have two classes. One class is a that gets scheduled on a ScheduledExecutorService. It periodically runs, and, when it does, it creates Tasks that, instead of processing immediately, it just dumps them on to a . It does not do anything more. Then, you should have another thread pool that, all it does, is sit there and pull items off the queue, and then dump them on to your parallel-thread service. I would do the second class as a nested class of the first. So, in your class, I would have a few things: 

There are two problems here... both related to datatypes. First, though, I don't believe you can get much more in the way of performance. Make sure you have adequately warmed up your system before you take benchmarks though, the Java runtime will get faster with successive compiles. Make sure you are benchmarking it at it's fastest. OK, now the problems: First, the inputs are double values, but you are calculating int values for the rectangle. If you input the data as ints, it will be faster. The second problem is that, if your input doubles have a fractional component, then your bounding rectangle is wrong... it shoudl be on the outside of the points, but, because you are doing integer conversion, it will not bound the points on all sides, but will sit inside of what would have been the rectangle if the rectangle's coordinates were double too. I would guess that a large part of your performance hit is from type-conversion. Finally, it may not help, but I have had success before, from converting the method, and all the values inside it, to be final. This may help the Java JIT compiler to inline the calls in to it's compiled code. Try it, and benchmark. Edit: More about the double/int bounding rectangle. If you have the points and then your code will compute the bounding rectangle as , but it should be ... (or should it)? 

This is not doing what you think it does. Because the instances are the key to the WeakHashMap, they will never be garbage-collected (the key is a strong-reference....). Using a WeakHashMap is complicated, and harder to describe than what can easily go here. 

A while ago I was experiencing 'flakiness' on my home ADSL line. I run a Linux server in my basement, VOIP, and a few other things (like Netflix) and I was experiencing a few minutes of network downtime every few hours. This was dropping very important things, like the kids watching cartoons, and my phone-calls with my parents. In communication with my ISP (who are fantastic, I'm not complaining), they wondered how often the connection was dropping, and I could not easily say... so I wrote a script to monitor.... All it does is ping the remote side of my ADSL line every second (my gateway). This is a short hop, and not much of an impact. Here's the script I wrote, and, based on it, I was able to escalate the problem, and copy relevant mails to the ISP, and they were able to correlate the issue to problems somewhere... which ended up with me replacing my ADSL modem, and problem solved. Long story, for some short code, but, this is a classic perl hack... My perl is somewhat old-school, so I am looking for ideas on how to modernize my usage, and any other tips and tricks. 

You should pass in the number of bits you want in a byte as a parameter value, or it should be a constant. The value is a magic number that should not be there in the method.