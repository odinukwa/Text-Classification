Use private where needed I believe must be private. insertAtEnd() I might suggest you use instead of . What will happen if list have more than 255 elements 

You need to use prior declaration. Because you are playing with dynamically allocate objects + polymorphism, you MUST add . I do not think the code will work correctly without it. 

Everything looks good enough. Code style is OK. You are using , so it will be quite fast and there is nothing you can do in the code to speed it up. You may or may not need to check this: 

Here is what I came up. It is header only library now. I believe is much more clear like this. myhash.h 

Finally, if you have C++11, you can clean up things some more, including you might remove constructor and use default generated constructor. 

Once again I decided to beat system function. This time I decided to use a template and to "precompile" all cases from 0 to 31 bytes. Result is 400% improvement - from about 1:15 min to 0:25 min. Finally I had rewritten with naive looking for statement and I noticed that the compiler can optimize it as well. However I did not tested with random data, so I am not sure what role the cache line and branch predictor plays in the tests. Here is the code: 

I would even move it to the file. skipping for now Integer.h same considerations for the and . Initialize the value to zero. If you do so, you can ommit initialization of . once again doing nothing. this time you can remove it. Display.h remove and . on all your code, you use . now suddenly you switch to . Why? Answer is - to make more ugly :) main() Do you think there will be exception thrown? is deprecated. If you are using , change it to . Make to be . You really not need to write it several times. 

In your case, I would suggest to do two functions, and instead of , use . I can not be sure if this code will work, but this is the idea: 

Unnecessary casting You should avoid unnecessary casting. Since returns a , you don't need to cast it when assigning it to a . You can simply do: 

The first one takes in a pointer and directly uses it. Any other nodes that are pointed to by the node will be added to the list, although not included in size, so will be output by your print method, however will be beyond the tail of the list. That sounds wrong. The second method only adds the data from the Node, which at least makes the list make sense, however isn't the behaviour I'd expect if I was passing in a Node chain. Remove You don't appear to be reducing when removing from the list. That looks like a bug. I'd also consider writing it based around the contents of the nodes (_head, _nxt) etc, rather than having decisions based around size, I find it easier to follow... It also looks a lot like it will blow up if you try to remove index 100 from a list that only has 5 items in it. Also, if the last item from the list is removed, it doesn't look like you're updating which means it'll blow up when you add to the end of the list afterwards. Insert If you insert to index 20, on a list that only has 5 items, it goes to index 6. This doesn't comply with the expected contract and is likely to cause confusion. Usually I'd expect methods like (add_head, add_tail). If you're allowing indexes, you should return some error if that index doesn't exist. Count If you track in a list, it's usually as a convenience variable for returning the count of the number of items in the list. You don't expose a method for doing this publicly, which seems like an omission. 

The caller is then responsible for supplying the (including cleaning up after it if it's a file. The class has given up responsibility for opening / closing the reader. and aren't required so would be removed. Approach two: Create one or more test files that are used for testing and change the interface to supply the path: 

Even better if you do it as , but I can understand that you probably want to avoid it. Use instead of raw pointer. If you use , then you do not need to have destructor. I think this is some example where you learning how to work with memory management, but you need at least to explore the possibility. If you are using , code will not slow down, also will not use additional RAM compared normal (raw) pointer you have now. 

Naming things Why you have all caps function name? Why you have variable with capital letter in ? At first I thought it is template parameter i miss. Use auto more often: 

inline methods in ListNode inline methods are present into the class definitions. Remove all "inline" keyword, it does not needed. However ListNode is so small, I would merge it in .h file like this: 

Make for list elements. Currently the list is using . If you decide to use or , you need to change it in 100 places in the code. Make some or (C++11) so you to be able to change the type from one place. It could be inside the class: 

Do you really need to check ? My experience is you can use directly. If there is a session created, statement will do no harm. I believe you need to initialize , but only if is not set already. Something like: 

return 0 from main() In latest C++, from is optional. Since is there, do not remove it. const method 

What is the doing? Is this because of incomplete . comment - remove , use or . helps the optimizer a lot to speed up the code, when class is known. - I think you need to check somehow for it. Probably in . Fraction.cpp prefer initialize list: 

This class was inspired from Microsoft's array_view. It intended to use with mmap-ed memory for easily check bounds and so on. I probably will need to throw exceptions, but this is not my usual way of working. Any comments are welcome. I left some casts like C-style casts because I see Alexandrescu is using the same and I am not alone :) I also added a method for relative as(). It uses pointer and pointer arithmetic. First here is some real usage: 

That's just my particular style, but even if you don't like mine, there should be a consistent structure you use throughout your code. 

Stop declaring your variables and then setting their values. You can just set the values in the same line that you declare them. Always use the appropriate type parameter for generics (i.e., , not just or . Don't create variables where you don't need to (i.e., , , ). Wherever possible, separate out different functions into different methods. For example, in your refactored code below, I split the anagram generation into a separate method from the actual file IO. This not only improves code readability but also prevents your program from holding a lock on the file for the duration of the run. (Think about it; there's no need for the file to be locked up while we're actually checking the list for the anagrams.) People generally use the interface rather than the underlying object whenever possible. ( vs. ) Not really sure why, to be honest, but this is the accepted convention. The function probably doesn't even need to exist, but if you're going to leave it, it can be a one-liner. Use variable and method names that are actually meaningful. Don't convolute code where it's not necessary. For example, see the refactored method below. 

Now we can simply call this method whenever we need to get numbers from the user. Much easier, and we've reduced the complexity of our code. Another thing that's redundant is your constant re-declaration of . You really only need to do this once. If it were me, I'd have it as a static field for the entire class, e.g., 

I'm sure there's a lot more, but that's what I noticed off the bat. If you shorten the code a bit given the above comments, I'll take a deeper look at it all. Good luck! 

I think the biggest problem here is that you're trying to do too much in a single line. It seems obscure because it is obscure. If I were looking at this outside of a Code Review setting, I would think that someone had purposefully obfuscated it or condensed it for some character count restriction. Consider breaking apart your lines in order to make your code more legible. Whoever looks over or has to maintain your code in the future (even if it's just you) will be incredibly grateful for it. I was going to try and break this down into a legitimate block of code, but I have absolutely no idea what your various variables are supposed to represent. What does the list hold (e.g., what is ? what is ?). But let's take your last line of code, which is at least somewhat comprehensible: 

In general, I think I prefer the second approach, because whilst there is more code overall, each handler has a distinct job in the flow. I can see how I can expand it with more states to handle player creation / add better validation to each step (for example adding retries on failed password entry). That said, there are somethings I am not so keen on. At the moment, the handlers all implement which makes sense for most of them, however some (such as the and ) only transmit to the client, they don't process input. Does this mean the name's wrong or am I shoehorning handlers in that shouldn't really be there? Any and all feedback welcome. This is a work in progress, so some of the periphery classes (repository etc are stubbed) and others like the will change as more commands are implemented. I think I've added all the relevant code for the review, however I'll add more if needed or it's available here. 

Break up the code It's never to soon to start thinking about breaking your program up into classes. At the moment, most of your variables and processing happens in your main function. Defining at least a class to represent the game mechanics would help you to break up your program. Data like the can then be shared amongst the methods within the class (such as ), rather than having to be passed into the method. Move Counting Currently you're main game loops gets a move from player one, then a move from player two for each iteration. This means that in the case of a draw, it still waits for player two to take a final move, even though the board is full. It would be better to have a single move as the core of the loop, with it alternating which player is moving. Input Validation You aren't validating your input. If the player types 'randomText', or even '10' it will result in the application blowing up. You need to check anything you ask the user for. Move Validation Whilst you check if the board has already been played on, you don't handle it as a failed move. So, if player 1 plays in position 1, player two can also specify it, it is ignored but then it's player 1's go again. Play shouldn't progress to the next player until a successful move. Checking for Victory is quite naive in its approach, it checks every possible combination to see if there is a win for anybody. You only really need to check if the current player has one. More than that, you only really need to check if the current move has triggered a win. 

Please note, many people (me excluded) will not like in the middle of . Anyway if you do it this way, readability will be much better than with . 

Is this conversion or just check if class is Integer / Number? Naming is unfortunate. Change it it or change return type to . What is ? If it is a pointer, change it to or if you are using to . Number.cpp way too big, skipping for the moment. Fraction.h once again this will not be compilled, because you are using unknown . must initialize the and . I suggest following: 

I agree with Loki, but hare are some more things: Destructor I do not see the destructor. What happen when you destroy / the class? Answer is huge memory leak. You definitely need to have to release the memory and prevent memory leak. If I read the code correctly you need following or something very similar to: 

I do not see much thing to review, except . Code style... ...is OK. I will suggest to be no more than 10-15 lines, unless you doing something that can not be separated, such preparing parameters for SQL database or things like this. issue You should avoid at all costs. Remember in there are operators such , here is an example: 

constructor class member "initializers" I may be using incorrect term, but constructor better be like this: 

variable is static. This means it it accessed using lock + semaphore or probably is atomic. Why not move the inside the class? 

Why you pass by reference? size_t is as big as the pointer, but there will be additional hidden dereference that will slow down the execution. keep the const, remove 

You also might decide to remove them and use directly. Or you can do static method . Here you create session as well: 

I don't believe the code works as expected. One of us for sure made mistake with . If is me, comment so I can fix the answer. Code style You will have better readability, if you indent everything inside the class. You need to work on statement in . I can not read it at all. I personally would do it on single row, but then many people will not like it at all. Constructor - I do not see where you need this? You initializing the static fields every time. 

He already checks for and then checks for . The only reason to use the second construction for a comparison is to avoid a ... which he's already done by checking against . So either he doesn't know that Java short-circuits conditions, or he has no idea what the purpose is behind the second construction. Also, it's generally a bad idea to have huge wrappers around entire method bodies. It would be a better design to have something like this (if it were needed at all): 

Putting it all together, we get something that looks like this. If it were me, I'd probably further specify the function so that you could pass in something like or rather than the three decimals, but that can be for a future release, haha. There's some further encapsulation you could do to make the code still more elegant and readable, but I leave that as an exercise to the reader. 

What I'm going to do is walk through your code step-by-step, explain why I made certain changes, and then present the finished code. I'll also point out any assumptions I've made in constructing my version. I had to make a number of them due to your inexplicable variable names, but it shouldn't affect the final outcome drastically even if I made a mistaken guess as to what the variables meant. You should just have to rename them to something appropriate. So here are a few assumptions of mine right off the bat: 

Your code is really good and very well written. I think that's why you haven't received a response; not much to critique! You have good comments, good style, pretty much good everything. I wish I saw code like this in my production environment. The only thing I noticed that you might clean your code up a bit is this part: 

If you don't know what an enum is, now's a great time to learn. It's a very useful data structure which lets you define exactly what its potential values are. Here, it seems like your missile types are PAC-3s, GEM-Cs, and GEM-Ts, so that's what we have above. This is why object-oriented programming is so powerful. A missile is a thing in the world with its own properties, and so it is here. This enum may have been more appropriately named , depending on your preference, since technically it will hold values for multiple missiles, like the . But having this data structure set up is what will let us completely rewrite your method in just five lines.