Side note: Whether or not a door will be open or closed at the end depends on how the prime-factorization of it looks. Consider the number \$12\$ for example. How to prime-factorize it? \$12 = 3*2*2\$ And the door will toggle on \$1, 2, 3, 4, 6, 12\$. Note that those numbers can be written as 1, 2, 3, 2*2, 2*3, 2*2*3. That's \$6\$ times, which means that the door will end as being closed. Unfortunately, there is no efficient way to prime-factorize a number. What you have built here is very similar to a number sieve, but instead of removing non-primes you are toggling them. Modifying your code to be a real sieve instead would not require many changes to the code. 

(There are probably better ways to do this, you could hard-code the values into the array for example, but I was lazy. It is very possible that this code needs to be reviewed itself) Now, loop through your and check if your is within the to range, and the same for . Once you have the offsets array setup, you can loop through it like this and perform your operation for the matrix: 

XML Considering the pattern of your XML files, you might want to create the layouts dynamically, with code, instead of using XML files. I don't really see why you're wrapping all your inner LinearLayouts inside an outer LinearLayout in your I think that you can remove 

It would then be the job for a single utility method (or two) to create a list of files from these parameters: . As for the question about return type... If you need an interface for this or not depends on how you are using these counters. And also: Which possible counters are there? If you have one counter for returning total line count and one for returning a of line counts, then you don't need two different counters. Since you need to know all the line counts in all the files to know the total line count, using a makes perfect sense here. 

I said before that copying is potentially bad for performance (each copy takes time). And we're doing a lot of it. This line: 

Second, you could inherit from the stdlib one and add the missing functionality. If you want to add directly to timedelta this way as well, you would also have to override and to turn any object they are about to return into your extended . I was going to suggest monkey patching as another option (this being one limited context where it does seem worth it), but it turns out you can't ( and use ). I only recommend adding the strict compatibility things this way. The idea is to set it up so that if you stop supporting 2.6 down the track, you can delete this code without having to adjust anything else, except maybe some imports. in particular ought to stay separate, especially because it fairly specifically enforces/assumes your local policy ("serialised dates will be in one of these two formats"). 

That was almost certainly coming up because of your previous exception handling. You were printing the error and then ignoring it and continuing on, which made return by falling off the end. So now, you can change this guard to so it gives you a better idea of what's going on. You should probably also rename , since it's not really a url anymore (it's a , so for lack of a better name, let's call it ). This is the right place to handle that error. But instead of calling here, consider using the module . Above this: 

There is plenty of things to be said about your code, this was only some of them. Perhaps others will add more. 

One major "overthinking" to me is the I personally use that mostly for the Builder pattern. As your class is named , it doesn't sound like a (possible rename?). You mentioned that you have other methods as well, so the main question is: Does it makes much sense to chain them? Or do you only have to call one or two of them and then get the result? If it does not make sense to chain them, which it doesn't by the look of your code in your test: 

You don't need all these three loops, simply one is enough. This will also make the arrays you use unnecessary. There's no need to store them in an array at all. 

Your question is: Is it good to use a Singleton here? My answer is: If you can avoid using a singleton, do it! And you answer this yourself: "Of course I can avoid using a singleton if (...)". Passing a object to the constructor or some other method is more preferable than using a singleton-pattern. This is part of the principle Tell, don't ask. The method in your "singleton" defies the Singleton pattern, which states that it 

A completely different approach This problem can be seen as a problem about factorizing numbers. Consider \$4^2=16\$, why is that the same as \$2^4\$ ? Because if you factorize it differently, we know that those two values are exactly the same. So this problem is actually solvable without calculating the actual powers, by factorizing the powers instead of calculating them. I am unsure whether or not this approach would be any increase in speed, but when in doubt about performance there's only one thing to do, benchmark! 

These three classes differ only by one hard-coded string argument. I'm assuming these are going to be expanded a bit later, but even so - consider consolidating them. 

These things together will make your code easier to follow, more maintainable, and often both faster and shorter. So, start by looking at your core data structure: 

Note that the first condition changed from testing a length to testing a position, and that the helper function works completely in-place. This makes one copy, in the outer function. You can also change it back to an in-place sort like your original code by deleting two lines, and it will make zero copies. This is probably the best a recursive insertion sort can be. 

This is a list of lists of strings. For most of the rows, you don't seem to care about column 0 at all. Column 1 contains row labels, and corresponding to keys in your dictionary . The rest of it is numeric data, currently stored as strings. It also contains 'header' rows - you only keep one of those around, so presumably you only expect one to be in there. I'm guessing that is column labels, which a DataFrame lets you include directly in the same data structure. The only trick parsing this into a DataFrame is that it is a little easier (and, apparently, more efficient) to swap the columns and rows from how you have them currently. That will affect how it prints, and which methods you call to relabel things, but not much else. This is how I would parse it into a DataFrame: 

could be named with what the means, to make your logic flow more self-documenting. How about ? Coffee, Coffee, Coffee, Sugar, Cream This code is very tedious to write and I bet you used Ctrl + C and Ctrl + V when writing it! 

I had to look much further down in your code to see where/how these variables were used. The current names of these variables is not optimal. You might think that "the cool programmers" use short hard-to-understand variable names, but I'll tell you the truth: We do not. In this case and would be much better names. Additionally, to better see the usage of these variables, it is recommended to declare them as close to their usage as possible. Don't declare them at the top of your method. In fact, they are not needed at all. You can change the code that currently uses them. 

Using strings in themselves to determine the isn't the biggest problem, but you really don't need to create classes and subclasses and stuff for this. Instead, use an enum! 

Variables Your naming leaves some things to be desired. and for example should be named and , the current names makes it sound like it is related to coordinates, which it is not. The only variable with any meaning is and . It is hard to tell what kind of max is though, naming it would make that clearer. As for your other variables, , I certainly cannot tell what they're used for without looking at your code for a while. These variable names tell me absolutely nothing! To get a better overlook of the variables, it is better to declare the variables as close to their usage as possible. () is declared at the top, but not used until the end of the method. 

This will end up falling off the end of the function, and so returning . The rest of your script will continue, but eventually fail horribly. This probably isn't what you want. 

You have a variable to capture the links on each iteration of the loop, and to accumulate them across all the pages you parse (which is only one at the moment anyway, but I'm assuming that could change later). Those names are quite confusing; it would be good to differentiate better - call them for the one that gathers all the links, and for the one that gets the links for just this page. Your function parses what I would call your 'main' data structure. Since that is a lot more than just email-related information, isn't the best name for it. The data structure that creates seems awkward for your data. If you think of people as 'records', and the information you capture about them to be 'fields', then it would make more sense to have it as a list of namedtuples, or or even a pandas dataframe if you're working with a lot of data. That way, your code to parse it is a little bit simpler: 

You can check that this list comprehension will give you all the True/False results of that in that loop: 

In terms of raising the as soon is called (rather than when its result is iterated), this general pattern is likely the best. There are a couple of other points that bear mentioning, though. First, is one of the worst ways to handle a detected error (marginally better than, say, ). Make the assertion self-documenting so that if when it gets triggered sometime in the future, you have more immediate information in the stack trace about what is going on. At a minimum, include a message with the assertion: 

425 is a magic and seemingly random number. Magic numbers should not be entered in your code directly but instead used as named constants. Instead, use this at the top of your class: 

Having static variables are usually only used for constants. Are these variables supposed to be constants? Constants should be marked . If you would mark them final you will quickly see that you will get compiler errors on and on , because you modify those values inside the method. There is a good reason to not use them as public static variables!! Consider what would happen if your main method would look like this: 

I'm not sure how your algorithm works, but I can give you a couple of suggestions about modifications that you should to do. First of all, I think that you should have separate methods. One for returning all possible combinations of a fixed size and one for all possible combinations of all sizes. Secondly, you should return instead of . For two reasons: 

"If not x equals zero and y equals one or y equals 0 and x equals one." Please don't have me read that again. I would add extra parenthesis around to avoid mixing up and . Also, by switching the logic around it becomes this, which is clearer: 

What I would do is to store several things in local variables, so you don't have to repeat calls to getters over and over again. Since your call to is performed in all if-statements, it can be placed after the ifs to reduce code duplication. 

Consider moving this function up to module level and passing the colours into it (or, if you really feel like it, use a class for the squares and make this a method on it; but that probably isn't overly worthwhile). 

Then you can move your inside the loop, in place of the . At that point, continuing the search to find all pairs is trivial: change the to a , and your function will become a generator that will keep yielding every pair that works until it has exhausted the search space. This outer loop: 

Your current code is a little schizophrenic about whether it allows multi-valued fields: eg, can a person have more than one phone number? The code parsing it looks like it does. You parse out a list of data, then you extend it onto the accumulated list. But then when you write out your CSV, you assume (by your use of to regroup them) that all fields have exactly one value. In the comments you clarified that you only want single-valued fields. That being the case, don't include a full list of every match you found in your data structure. If you get three phone numbers for a person when you're only expecting one, you want to either consider it an error and bail out, or forget all but one of them. Your current code would silently remember all of them, forget that it did that, and end up with corrupt data. To take the 'signal an error' path, do something like this: 

instead of - that way, Python will try (the equivalent of) and only give if that is also . means "I know that these two are not equal"; means "I don't know how to compare them".