That may not be the best metric. Even if it's actually possible to tell apart populations of people with basic programming abilities and those lacking them, it's not enough of the solution. Some people may be quite capable, but still dislike the process. So there will be people trying to study CS that will eventually want to leave. Maybe it's better to just make these people leave quickly The way that my university was approching this was to put fast paced programming course with focus on algorithms in the first semester. The course, apart from teaching obvious skills, had an explicit purpose of failing or discouraging all the people without the skill or interest necessary to finish the studiesÂ¹. And then in the second semester, it was followed by writing a sizable GUI application as an individual project. While I don't have any numbers, I believe it worked kind of well. It seems that whoever survived the first year and was willing to stay, was well capable to finish the undergrad course and find work in IT. However, there are some caveats The main issue with the presented approach is that it's strongly negatively biased. It discourages all the people that should be discouraged, but perhaps discourages also some happened to be just a little bit to slow. And while a university sucking up in all the best country talents may afford being picky, I'm sure it doesn't work everywhere, at least not at this scale. It also must be more tricky in a private school. My university was public, and people generally paid no tuition. 

Starting languages for wannabe-developers Now, to the other question: "do you agree that starting with C/C++ is beneficial for a deep understating of programming"? Yes. For a person planning to do any serious programming, I'd perhaps recommend starting with C++ (where "++" stands for "streams, strings, vectors and maps", maybe now also "smart pointers"; the rest is confusing and unnecessary noise) or Pascal/Delphi (that's what I actually started with) for less opportunities to shoot your feet, and a good GUI library with IDE support. It is also very useful to do some programming in a functional language (OCaml? Scheme?) early, to get some different perspective on programming, with better structured framing. I'm not sure it's a good first choice though. However, I'd be careful to not go into too far into high-level programming in C++. C++ "high level" structures are actually thin wrappers around explicitly low-level stuff. To write classes and abstractions, take a proper high level language, perhaps Java or Scala. C++ is not a high level language, and I tend to treat it's high-level features as a kind of a last-resort: if you are bound to using C++ for performance and low level features, that is how you get some abstractions. As for starting with higher-level languages, my intuition is that thinking about classes and this kind of abstraction is unnecessary noise at the entry level, which is why I look with great suspicion at starting with Java (in which even a "Hello world" is in a way OO). I don't have any data-backed point here though. Additionally, I find the Java memory model (i.e. references everywhere) to be both confusing and misleading. 

How you do it exactly depends a lot on the topic and on your own preferences. Be it the occasional large 2-week project; or a "background project" that runs through the whole semester, or whatever. I would certainly stay clear from encouraging the students to do every single bit of homework together. Having "heureka" moments is incredibly important. At the end of the day, much of the content in CS is incredibly complex and difficult, but can readily be chopped into pieces which can be handled individually. Students really need to be able to do that; but to do that, they really need to know the building blocks themselves, intuitively, and get into the habit of flexing their brain muscles, a lot. 

I'd say it is important to be very clear about the fact that these are not "three equalities". The in these three statements are completely different (e.g.: mathematical constraint <=> assignment operation <=> equality expression) and have no particular relationship with each other except for using the same symbol and some vague, indirect and maybe confusing similarities. That is a great time to introduce related concepts: 

I don't see why you restrict your choice to either lie or be pedantic, both of which are negatives. It is pretty clear that almost all topics in CS are more complex than they seem at first; there always is a small visible surface, and a huge ice berg below. In fact, having a software developer who thinks he knows everything about a topic and has no open mind for further stuff is very hurtful in the real world, it can really wreak havoc in software projects. Your solution could be as simple as "Today we are looking at the aspect of Java interfaces that makes it so they guarantee that classes implementing them define certain methods." (or whatever better formulation you can come up with). The important point is the "Today we are looking at the aspect of ...", the rest is just part of your irrelevant example. Any student should pretty easily understand that if we look at one part of a puzzle, there are other parts. Get them into the habit that you never give them the full picture (because, as the Hitchhiker tells us, that would be too humbling for our sanity...). If you, depending on the age of your audience, have to hammer it in, then preface your lecture by a picture of an iceberg (maybe together with the Titanic for some added humour...). Also, you could find an exhaustive list of features of your interfaces, and give them a kind of "breadcrumb" somewhere in your presentation (if you are not writing by hand on a board), highlighting the topic of the current session. Even if you lose no word about the other topics, they will be aware that there are other topics. Like "Interfaces: multiple inheritance; abstract method definitions; default code...", if todays session is just about the fact that classes implementing the interfaces have to implement the methods, and that the caller can use the interface as a type if he does not need more information about the concrete classes. 

This is not a complete answer, and it misses the "drawing an accurate picture of work in the field" goal, but I think it shows an approach worth mentioning. I'm not sure you can show the picture accurately without a hands-on experience with coding. 

Note: Initially my answer was just about computational complexity, but then it grew a bit, so I broke it into multiple sections and tweaked each a bit. Thanks to commenters for pointing out the details to fix. Understanding computational complexity That may be covered by your "understand better how these structures behave", but it important enough to deserve its own place. It is very hard to appreciate the computational complexity behind a library structure operations. You don't need or should care how things work under the hood, you should be happy with information that given operation is guaranteed to run in "O(log n)" or "O(container size)" or in "amortized linear time". But to get a good grasp what all that O-speak means, you should actually write the code that iterates over a linked list or finds stuff in a BST. Once you have some well set expectations of how things work, you can move on and perhaps never write own containers again - but you will forever remember what happens under the hood when you call some random library method (or at least have a rough estimate, see Certainty about behavior). General knowledge about writing containers (mostly inspired by Buffy's answer) If you ever happen to actually write a container (e.g. one missing in given language), you will not only benefit from specific knowledge about containers you wrote, but, more importantly, from general knowledge about writing containers. There are several reoccurring patterns about containers design, and knowing them from the "internal" perspective certainly helps. Certainty about behavior That one may be important for educational value. Only writing your own structure or algorithm gives you certainty that it behaves as you expect. Built-in structures may often contain extra optimizations and don't necessarily implement any "canonical" structures. They differ in details. Avoiding over-complex library APIs Library containers not only may behave in "non-canonical" way. Their APIs usually contain many additional functions that, while useful in production code, for learning are just unnecessary distraction. E.g. in C++ containers have multiple variants of every method just to allow optimized memory management, or some syntax shortcuts. C# is not very different. De-mistyfying library code Direct answer for question "why do we have to do this": to see that there is no magic. You can do all that things, using libraries is mostly just about saving time. Debugging your own components will likely help you appreciate that libraries are well tested and patched, but should also show that writing similar code isn't something unreachable. 

This is very understandable and "normal" to me. I have started programming when I was roughly 13, in the early 8-bit home-computer area (Atari etc.). These days, I am a senior manager in a large IT company, and when I need stress relief, I grab some project and program for a bit; also I frequently am able to help youngsters out when they are at their wits end with some programming task. Last holidays, I played the games TIS-100 and Shenzhen I/O for a week straight while sitting at the beach, which consist of programming some more-than-weird assembler dialect. That said, during my studies of CS and subsequent work in the field, first as programmer, then team-lead etc., the number of people that align with this view were indeed minimal. Unfortunately, many, many people really are in this job for "solving problems", not because they enjoy programming. It is not about being a recluse, sitting in the corner of a room all day, and writing lines of code until your finger bleed. But enjoying something is, at least in my opinion and experience, the only source of real learning and improvement. I see it everyday, people who do not actually enjoy programming a) regularly fail to grasp more complex topics, b) are stressed out a lot, c) do their best to get out of programming ASAP. It is a meme in my rather large company, that young people do programming, and older (sometimes even starting 30+) get out of it as quick as possible for some managerial position. I am one of the few in a "post-programming" position who grasp what we are even doing today on a less-than-abstract level, and it is very saddening to me. (And do note that I am not lessening the importance of having experienced "architects" or other roles, which make up a significant portion of my work as well, obviously.) For me, this is like working as a cabinet maker, and only wishing to sell the finished result while not being interested in the look, feel and smell of the raw wood or the beauty of the work itself. That said... I view it as the most important and beneficial job of a CS educator to instill fun about the field, not the least about programming, in the students, no matter what age or experience level. Do not be dissuaded from that by the difficulties you face. That said, I have not really found a way myself to instill real, deep joy and interest towards programming in people who do not already have it. I have met many people who program all the day for many years, and don't enjoy it a bit. They enjoy "solving problems". Which usually means taking as many shortcuts as humanly possible and trying to get done with it ASAP, scorning the type of the work they must do. Do all you can to make it fun for your son. With my (younger) daughter, I'm very slowly and partly successfully introducing her by the means of Minecraft (=> with its minuscule amounts of "programming" optionally available there); we tried Scratch (didn't interest her); she will probably get a Nintendo Labo set for her next birthday; I even showed her some BASIC (in an actual Atari 800 XL emulator :-) ), but that was more like "look what your old dad did 100 years ago" and obviously not really applicable in todays world. She saw a "hello world" (or rather "hello YOURNAME") and at least has a small inkling about what it's all about. Aside from that, she's obviously also at the level of "dad, can you show me how I can program a game like Minecraft, pretty please"... She is still a bit too young for more, but my strategy is to get her hooked at some point, when she will be able to research stuff herself (just as I did back then with paper books). And obviously she will need to find something that actually interests her. If we don't find that, then I will be very happy about her not becoming a programmer / CS girl in the future. 

Both are a requirement of one of the courses that I teach. I like to start with a flowchart, as (for all the reasons mentioned by @GypsySpellweaver already) they provide a good visual representation of the problem to be solved, and can help then to generate the pseudo code. Value of flowcharts Although I have seen it argued that flowcharts are somewhat outdated, I think they still have value due to: 

Expanding their use Regarding the last point: Once the solution is coded in your language of choice, I like to show the solution in a number of different languages: Fortran, Pascal, C, Java, Python. It is interesting to see how similar the solution something to Fibonacci will be in each of these, and it gives (imo) learners some confidence that, once they master one language, and the concepts involved in software development, they may be better able to learn additional languages in the future. Equally, providing some code in Fortran and having them generate a flowchart and code in your target language can be an interesting exercise. Apologies for migrating tangentially here, but I'll assert that it is still related to both pseudocode and flowcharts :) Free Tool for Flowcharts A really nice FREE tool is draw.io. I've tried many, but settled on this one as it is free and is stored in the cloud, so they can work from any computer on a work-in-progress. 

I use peer evaluation forms as a part of group projects as discussed by @Buffy above, and I also split the marks between group and individual elements. Taking the question in a wider context, I'll just speak from my own experience of peer evaluation, and the opportunities and difficulties I have found with it. My first experience of peer evaluation was on the Rice University MOOC, An Introduction to Interactive Programming with Python. I liked it from the start, and thought it was a great way to grade work, provide feedback and reduce teacher marking time for formative assessments. We do not use it for summative assessment. 1) Sample exam questions: theory An exam paper based on the theoretical elements of the course was designed, and a grading rubric with sample answers prepared. I assigned each learner an ID number known only by myself. Each learner received a copy of the exam paper with their own number on it The exam paper had space for answers- no separate sheets. At least one question has some ambiguity- this is not told to the class, and they cannot ask questions during the exam. This is to allow discussion of question design afterwards. At the end of the exam, all papers were collected and each photocopied 3 times. Each learner is given a copy of a grading rubric and three random answer papers (not including their own) They are given time to grade each paper and make a note where marks not were achieved or partially deducted- this provides each learner with feedback. All feedback must be positive- indicate what would have improved the answer, and why marks were deducted. Collecting all the papers and re-ordering to give each learner back a copy is tedious work. After the exercise, we had an open discussion on each of the questions, if they could have been phrased more effectively. Expansion option: Given a specific Learning outcome, how might they create an appropriate question for an assessment. At the end of class, I provided them with sample answers to the exam so they could compare with what they had themselves. Outcomes: It was interesting that many found it difficult to award a grade, and did not realise how much time it can take to correct a paper. There was some variation in the scoring of identical questions- this proved a useful talking point. Each learner got useful feedback on their own work. Learners have a greater appreciation of the creation and marking of assessments. It was quite time consuming, but a useful exercise. 2) Coding mini-assignment- peer grading on Moodle Given that photocopying code is a non-runner, I set up a peer-graded Assignment on Moodle. Each learner had to work on a mini-programming assignment and had two days to complete it and submit online. Firstly, getting this to work the first time on Moodle was very time consuming. Even on the day, there were several delays in getting started. The grading rubric identified many elements such as use of "appropriate" names for variables and functions, header info, docstrings (Python), clear user prompts/instructions, working code, use of comments and so on. When peer-grading, it is possible to place a comment in each section to explain why mark(s) were lost, and each marker can place a final comment/general observations. Benefits of Moodle Peer assessment Learners are assigned the work of others to mark randomly Anonymity is an option in the setup Each learner was forced to really look at the grading scheme, which was provided from the outset. Many lost marks for simple things that they should have included (e.g. header information). This is important- that they realise they can get some marks even if the code doesn't work completely or partially. All got to see examples of other learners approaches, structure, working and non-working code. Seeing mistakes others make should help them identify those that they make themselves. Teacher can review all more easily without looking through a lot of paper, i.e. the grades given and received by each learner, and the comments given and received. Difficulties I have to say, from a practical perspective, it ran about as smooth as a dragons tail (i.e. not at all smoothly) but this was likely due to my inexperience with using this in Moodle. That said, it was better than paper. Some students failed to provide any feedback even when it was a requirement of the exercise. There are some relevant/complimentary points also raised here.