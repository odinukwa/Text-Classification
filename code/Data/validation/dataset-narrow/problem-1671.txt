From the looks of it, yes. From the info I've read, the BCM43438 is connected to the SoC in two ways: 

It's not a bad idea. It's supported by some boards. Don't do that. The usual solution is to use a stacking header. Do the same to PCB 2 to allow another PCB to go on top of it. See answer #2. It also depends on how you make your boards, but I think an addressable solution will be better (if not the only way). 

I recommend a pull-up on your pins (just Google if needed). Leaving them floating (pun intended) generally causes issues with random high/low signals, and sometimes gets stuck at that signal. 

Port forward the needed ports (do some research on this) Go to your domain registrar/DNS provider. Set the A record of your domain to your public IP address. 

If the above fails, try to do the time update manually by running . It will use NTPPool's server. As it's running, you will see the compensation algorithm in action. Your 700ms ping won't bother it. 

These take advantage of the Raspberry Pi Camera Module connector to harness the full performance of the GPU. This frees up the CPU to do other tasks. You also don't saturate the USB ports, enabling you to record to an external HDD for example. And yes, they support 1080p 60fps on HDMI. There's a sample video on the linked sites. 

With this setup, you're not wasting CPU power compressing RAM but you still have something to work with in the event that memory does run out. Note: I'm using RAM and memory interchangeably. 

Load a GBA game and the game should play! If you are using a controller you might find out that it isn’t working. This emulator does not use the RetroArch configuration file. By default only a keyboard is set up so you will need to plug one in if you don’t already have one. Load the emulator menu with F10 and go to the option to configure a controller. You will have to use a mix of the controller and keyboard to get all the buttons set up but once you do you can unplug the keyboard. One thing to note is all the hotkeys that you may have set up will not work. All the options though are in the GPSP Menu system so it will just be one added step. The input file for the controller and keyboard are located at: 

What I do is simply to make it run on boot. Add and , in that specific order, in your file. I forgot if works out of the box for Jessie, or even if you should touch it or not, but it should be trivial to find another solution (I already did). And this solves #1. 

Yes, you may. Oh, have you considered ? makes sure to run any shutdown tasks, clean up a bit, then power off gracefully (red LED will still be on on the pi, green LED will blink a few times to indicate shutdown is done. Unplug after that). just kills the system. Update: Turns out they're technically the same. 

Contrary to an answer posted, NTP is quite ping and jitter tolerant since it can compensate for it, but selecting a close one should't hurt. Also, selecting the right NTP server doesn't really matter since NTP only uses UTC time and the operating system does the time zone calculation. As a rule of thumb, just select reliable NTP servers. 

You could also test by connecting the Pi directly to your PC using an Ethernet cable and properly configuring the direct connection, but network configuration is outside the scope of this question so I'll leave it to your Google skills how. 

Eliminate the timing completely on the access point. Set it up so that the two Pis have a permanent lease on the AP. This is because WiFi hotspots periodically kick out devices. There are good reasons for this like getting rid of stale connections and refreshing the encryption keys. The devices basically have a timed connection or "lease". Most routers have the option to make the lease permanent per device or at the very least have the option to set the lease time. Set it to the highest setting it allows. 

No, no theoretical data here. The new camera mode(s) can go 90 fps at 640x480. As for the timing, I think it's up to your code to handle the incoming data stream. 

Uses 3.3 volts (you can use a logic-level converter) Just connect the sensor to 3.3v. Usually it just works. Works with whatever software your Pi is loaded with. 

Technically, yes, but direct USB-USB communication is not possible. What you'll want is a USB-Ethernet adapter for your Macbook. After you get one of those, networking should be straightforward. 

As of recently, no. Reference link: $URL$ Also, 's author is working on it, but there's no ETA. Here's the Github issue. Check the last few messages. You could push your luck by exposing the CEC wires in an HDMI cable then bit-banging it with your GPIO port. Pin 13 if I'm not mistaken, red wire wrapped in foil together with white.That suggestion might be a little too extreme. You could do it for science. 

GameBoy Advance also needs a bios file in order for the games to work. Copy into the following directory: 

Add even more delay in between. I prefer to add about 5ms delay for every step in my loop. If the display is updated too fast, the segments will be utterly dim to the point where we can't see it. Pseudocode: 

Note: I'm not responsible for any damage you may do to your Pi. Tests were done with adequate cooling measures (heatsink, fan, air-conditioned room). PandaLion98 and related entities are not responsible for any damage that you may do to your Pi. Do at your own risk. 

It's dead. It should have been okay if the board was completely silent (blown polyfuse, wait a few hours) but you mentioned that the SOC heats up immediately. Therefore, it's most probably dead. 

It's possible that the Arduino was not detected by the system yet when the script ran. Try to run it after booting has completed. You can place your script on with the flag so it runs only after the system has finished booting. Run then add your bootup script as a new line: 

Yes more or less. If it's transparent, you're good to go. If not, the case might block the LED lights since it got moved over near the MicroUSB power port. If it's metallic (fully or partly), it might interfere with the wireless antenna (the antenna is located where the LED lights used to be) and might also block the LEDs. 

In short, no. On the other hand, it might work, provided you carefully pick your packages. Oh, and you can only use packages built for the architecture specific to the Pi since Debian packages target while Raspbian's packages target (That's why Jessie works with the Pi 1). Even after all of that, you may will encounter issues. So... Still no. Read more (Link) 

Your Pi is most probably dead. Specifically, either the SoC or the power supply died, but the SoC has the higher chance of failing. 

Nope. Not wiring issue. Double check if you got the exact same chip in the tutorial. If so, it's probably a software problem. Try running the program as root. 

What you are referring to is called "Stacking". Provided that your board pins do not interfere with each other and/or you provide addressable boards (e.g. SPI or I2C), you're okay stacking them. And NO, you do NOT replace your Pi's GPIO headers with freakishly long ones. See below: 

You could completely replace the default entries (just comment them out to be safe) Add the mirrors as new entries. I got them from here, hand-picked since some of the ones in the list are dead. 

Then you'll want to configure your WiFi router (or other devices connected to the Pi) to use the Pi as its default WAN gateway (in your case, set the WiFi router's default gateway to 192.168.0.1). Then I suggest setting the WiFi router's IP address to 192.168.0.254. Giving the WiFi router a static address will get rid of the hassles of setting up a DHCP server on the Pi. 

Well you mostly have to work on the software side instead of the hardware. I'm sure you're capable of doing this: 

No. Yes, although unjustifiable unless done for the sole purpose of learning. You'll need programming know-how, logic level converters (not necessary) (5v to 3.3v) and this thingy. No. No. 

There are practical benefits in using different forms. This is based on the discussion in the comments section: 

which means that the connection itself is bad, not the Pi. If the Pi was bad, you would simply fail to connect to it and your network is just A-OK, but since your PC is also complaining, the network itself is bad. This sounds like a router/switch/Ethernet cable issue. 

As others have mentioned, you only need the right voltage (4.75v to 5.25v), but you need the right amperage for your workload. For example, I recommend getting a power supply rated 2A and above for heavy computation and an external hard drive. A phone charger rated for 1A or a bit lower will be sufficient for a Pi monitoring temperature around the house. The Pi will only draw the current it needs, so a high-amperage power supply is not really a problem. 

I DDoS'ed my pi as part of a stress test using 2 laptops, fully saturating the 150 Mbps LAN interface on it. Less than an hour later, I found out that the pi doesn't respond to the ping flood and TCP flood anymore. I double checked and saw that the interface doesn't work until I restarted the networking service. When I checked (before restarting networking), I found a lot of these: 

Here are some resources for you: Parallel to USB, RPi Parallel port, Cursor library in python It's designed for Arduino. You're gonna need logic-level converters, datasheets/oscilloscope, deep knowledge regarding the pi's GPIO or about the protocols you mentioned (USB and HDMI), maybe some FPGA's and development kits for USB/HDMI, C/C++/Assembler programming knowledge and a high-precision workbench (I'm sure your soldering iron won't do). Just go get a screen designed for a Pi, and also an Arduino Uno so you can still use that TFT shield :) 

Yes, there is a problem. The red lights are supposed to stay ON. If they are off, it means that there is not enough power. I suggest getting a better power adapter. Try not to use generic phone chargers, and make sure it can supply at least 2A. A good example would be a charger for a flagship Samsung phone. 

Try this: First, put in . Then reboot. An alternative, if you don't want to reboot, is to run (as root) Then, flush your entire iptables. 

Less technical answer (i.e. step-by-step): I prefer to teach people about MOSFETs since they just need a voltage. No need for complex resistor calculations (e.g. transistor). 

The GPIO header isn't entirely made out of GPIO pins. What you're referring to are only the power pins on the so-called GPIO header. They're almost directly connected to the power rails so it's true they can provide the remaining allowed current. I even powered another Pi using those pins. The GPIO pins themselves which are connected directly to the SoC are limited to 50mA. 

Open up a screen session using the command . Install it if you have to. Run from there. Press Ctrl+A then press D to send the screen to the background (i.e. Disconnect from the session). To connect, run . 

This also would work only locally (i.e. on the Pi only). You'll need to set up an entry in your router or set up a DNS server if you want to use it on the rest of your LAN. I recommend . 

If you're working with Arduino, you may already have a UART cable handy. You can use that to interface with the Pi via the serial pins. Any cheap UART interface will do for the purpose. I personally use a $1 CP2102 clone that I got from eBay, directly wired into the Pi's serial pins. Once you're connected, simply use Putty in in Serial mode, enter the COM port number (e.g. ), set baudrate to 115200, and you're good to go. You can read more about the serial interface here: $URL$ 

After changing your default routes, you're going to have to set up packet forwarding using iptables. If you still haven't flushed your tables (or have existing, unneeded rules): 

Simplified version: Raspbian partitions your SD card. The partition named is using the FAT file system. Also, it's usually the first partition. That's why you can open it up on Windows. The partition is also using FAT but due to some weird Windows limitations, it can't see it since Raspbian makes a lot of partitions. Sometimes partitions beyond the fourth one won't show up on Windows. Macs don't have this problem since they're basically Linux and Linux is okay with it. 

To restore your memory card to its former glory, reformat it on Windows since Windows is usually aware of the card's real capacity and usually deletes additional partitions. If it doesn't delete the extra partitions, you can use SD Association's SD card formatter. (Link) 

For the GameBoy Advance tab to load in EmulationStation, make sure you have at least one game rom loaded in the GBA directory located at 

I guess your flash drive is fried bricked. Try unplugging then re-plugging. If it's still the same, plug it into Windows. If Windows tell you , it's most probably bricked. If it works, reformat the flash drive on Windows as using HP's utility (download link) then try it on the Pi again. 

Browsing around, I found this: $URL$ Since the interface bandwidth isn't that great, a workaround (or solution?) would be to quickly switch between the cameras. The site provides some Python code to do just that. 

If you used , there should be a folder on the top level named . That's the kernel backup that the updater makes before updating. Simply move/rename/remove the contents then copy/move the contents of to and you should be good to go. Some commands to get you started: 

You do not need multiple cores. NFS transfers usually only use one CPU/core. You will have already reached your Ethernet connection's limit before you hit your CPU limit. It only matters when you heavily encrypt your transfers or when the CPU is already at 100%. Your single-core pi is more than enough. Even a Pi Zero is way more than enough. But, it wouldn't hurt to use a Pi 2 if you are also running lots of services on it. 

Try doing it over TCP. Your ISP may be blocking UDP traffic or they're reserving it for themselves (e.g. IPTV, etc.) Source: Experience 

You need the library. You can install it by running . In addition, you may also need additional libraries to compile OpenCV properly. Running the command should get you everything you need. 

Calm down, there's no need to use exclamation marks and bold fonts. It's quite simple to connect those on a Pi. For the circuit, this is it: 

These lines add OpenDNS' nameserver (first line) and Google's DNS server (2nd line) Alternatively, you could add the DNS servers in the GUI network manager by clicking "Properties" under the connection then setting Static DNS to the IP addresses provided. 

Nothing else really, except return the card and possibly get another one with the same problem probably caused by outdated software. Waste of time + waste of effort. 

Add to the group using the command Add to the group using the command Change the permission of the directory and everything in it so that it's readable and writable by the group. Use the command . 

Connect the drain pin of the MOSFET to either pin A or pin B (i.e. either pin of the coil pins) of the relay. Attach the other coil pin to your external power supply's positive rail/connector/pin/whatever. Attach the marked (usually with a white/black band) part of your diode to the coil pin that's connected to positive. Attach the other end to the other coil pin.