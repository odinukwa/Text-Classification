Use they have everything you need built in. Here you forgot that can fail. In which case you will end up leaking a lot of memory (if it is not the first new that fails). ###Is this test not redundant. while (!q.empty()) { if (visited.find(q.front()) != visited.end()) { q.pop(); continue; } If you have entered the loop. Then is not empty. If is not empty then will not be . 

To see what I have to pass to this function. I need to look up (which is in the class). I would make it more explicit so that I can see exactly what is expected: 

If you are using C++03 then is still acceptable. But nearly all implementations now accept . This is better it is type-safe. 

But don't get into bad habbits. No using the braces can lead to maintenance problems on C/C++ code because of macros. Best practice dictates that you always use for sub statements of . To make the code easy to read when including the code in the interface declaration put the variables at the top. Thus you can read the code in with the context of the variables and knowing their type. If you interface declaration is just an interface (and the code is put in the source file rather than the header) then it is fine to put the private variables at the bottom. 

Also and just call on the pointer. I am betting that the SDL library has a special function to delete render objects. In which case you need to add a class that knows what function to call. Also can be used in containers: 

Never do this. It is OK if you are writting a ten line toy project. But once you get past anything more than a toy it causes more problems (in name clashes) than it is worth. The reason is shortened to is to make it easy and quick to type. 

I don't see any advantage to defining non standard names for them. Also is easier to write than ? Also and are never used in the code below. Re-inventing std::function. 

Throwing Objects Though it is not required. You should generally throw an object derived from std::exception. Preferably something derived from std::runtime_error. 

Using this rule it is easy to only include files you need. In your header files only include other header files if you need them. You only need them if the object you are defining has a member of that type or is derived from that type (or takes a parameter to a method by value). In all other situations forward declare. This reduces the header count considerably. In the source file you include all the header files of object you use to implement your code (that your header files have not included). 

But if you have a lot of dynamically allocated stuff this may not be suffecient. You could pass a then check of the subscriber is still available before sending the message. Use the new foreach loop 

I would change the interface to specifically take a unique_ptr that way people know that you are taking ownership of the object. 

Now that we have re-arranged it. It becomes more obvious that you are leaking . You create in the first half but don't use it till the second half (and there is an early return in there). 

But please put the closing brace '}' underneath. There is absolutely no need for this insane attempt at saving space and making the code unreadable. Also this would make it consistent with the rest of your code (which is much more important). 

Not sure that's how I would have written in. Its not normal to call and on an iterator. I would have arranged for a some type to represent the stream as a container: 

So what you need to do is imbue the stream with information about how to break a word. In this case we will just turn all punctuation into white space. 

Use a condition variable. Also empty blocks are hard to spot and understand if you are going to use them then put a comment that it is deliberately empty. Never do a manual set and release: 

This is a C thing. C++ we have better ways of handling all situations were macros appear. In this case use a const (or in C++11 contexpr). 

First improvement: The result of the read operation (operator>>) is a stream (this allows chaining). But when a stream is used in a boolean context (like above) it is converted to a bool like value that can be testes. We can use and change the above loop to this: 

Given that the function actually only checks for duplicates I would return a bool as a result (unless the output here is being used for other purposes) and I would pass the parameter by const reference. This prevents a copy (if the compiler is feeling sloppy) but more importantly is an indication that it will not be modified. Avoid C style casts in C++ code. There is absolutely no need for them. There are a whole set of new C++ casts that are designed to be much more easily seen. Avoid C++ style casts as much as possible. They are an indication that you are overriding the compiler because it can not do something you want it to do. 

Since we are not longer bound by a word size. I would change the loop to check for the end of line (or end of input)). 

Probably not what you want. Also URL as they pass through systems tend to be normalized (so they can be sorted and all sorts of other things). So your URL may have started of as the above but because it was normalized your query parameters have been re-ordered. 

Python not my favorite language (but recursion is). I would personally move the recursion out of the tests. Thus you do the test for return and other things first. Then the final statement is just a recursive call. This is because a lot work has gone into optimizing tail recursion and you can get significant benifits from it. So: 

I would try and do t for you but I can tell what the type really is. It looks like it should be some container type but you use it like a scaler type on the next line. 

Always use the '{}' to surround a statement block. This will save your ass one day when you use a crappy macro the expands into several statements. 

Move the declaration of outfile to the point just before you tart using it. In C++ because of constructors/destructors the side affects may allocate resources. If you don't need them don't use them so wait until you need them. It also has the benefit of making the declaration near the code that uses it so it makes it real easy to see the type of the object you are using (as it is just there with the code). Encapsulation 

Personally I think the tree could handle this. But I can't really complain about the usage. So this is just a personal comment. The parent. Hmmm. 

Also you should be using vector rather than list. It has two advantages: 1) You can allocate all the space you need in advance. 2) Spacial locality can make access faster. Times: 

Basic comments: No point in functions that do nothing. Also avoid as definition for empty parameter list. 

Why not have a move const for vectors? The Constructor that takes a string foes a lot of validation. Why does this constructor do zero validation? This constructor requires that you move a string (or provide an r-value reference). But you don't actually move the string you still make a copy!! 

No this does not meet the definition of std::lock(). It (std::lock) guarantees that no matter what order you specify the locks in the parameter list you will not fall into a deadlock situation. This basically means that the order you lock the mutex(s) in must be consistent (thus independent of the order they are in the parameter list). Your code is not (m1 is always locked first, m2 second; the actual order should be defined in terms of some immutable property of the underlying mutex (like its address)). This also means that if a lock in the list is already locked it must be released so that the locks are acquired in the correct order. Example of Deadlock: 

Operator[] Vs at() In C++ we have a guiding principle. You should not have to pay for something you do not use: 

Avoid use of for this type of case. Here the types of the variables provided contextual meaning to the reader. Here I found myself thinking lastEnd was an iterator and it took me several reads to actually work out what it was. 

If you are copying something and not going to use the original again. Then try and move the object to the destination rather than copying it. 

Better technique. I would generate all the cards first. Then randomly shuffle the pack. Then you can draw from the pack until you have no cards. 

If you don't explicitly put a return in the code then the compiler will add one for you (that returns 0). It is sort of traditional for programs that can not fail (ie they never return anything but zero) to have no return value in main(). The other side to that coin is that if you see a at the end of main, it is an indication that main() can fail and exit with a non zero value (ie you have another return point in main() that indicates failure). So if your code never fails (a in this case) just leave out the . 

Now you can have multiple loggers. But you can re-use loggers (as each logger has its own name. Most of the time people should be using the default logger. Building a streamming logger is not that difficult it just requires an intermediate buffer object to accumulate the message. When it is destroyed it sends the message to the logger. 

You should prefer to use automatic objects (that is perfect here). If you are going to use then you should wrap the result in a smart pointer to make sure the allocation is exception safe. 

What it does do is try and queue an item twice then in a tight loop try and queue it again. I assume you only want an item queue once in one of the lists. Thats not what is happening. Maybe if you tell us what you are trying to achieve (the final result/not what the code is trying to do). Then we can provide help in achieving that. Code Review. Global state bad. 

You are only allocating size space. But your capacity is 20 bytes larger. Why 20 bytes? Should this not be 20 objects BUG: You use the allocator construct routines when you are doing . This means the space has not been constructed before. If the location has already got an element in it you must copy over it using the copy constructor. Thus in 

Ignoring the memory problems with cache invalidation (which will slow the code down). Creating a thread is relatively expensive (as you have to allocate a stack and maintain it). So rather than creating and destroying threads it is better to maintain a thread pool and reuse the threads. The number of threads to put in the pool should be slightly larger than the total number of cores you have (as a rule of thumb * 1.x (where x is in the range 2=>5) is the number of threads you should put in the pool). 

The main problem with this code is that it is not C++. It is basically a set of functions (ie. Just C code that happens to use some C++ structures and objects in passing). There is nothing inherently C++ about this code. You should never be including this. 

Main Flaw You have committed the biggest C++ sin. You have a class that contains an owned pointer but you have not done any of the resource management. Please look up the rule of three. Currently your code is just broken because you forgot this. Currently any copy of the object (through the compiler generated copy constructor or assignment operator) will mean both objects are using the same underlying list. Thus updates to one will update the other. You don't have a destructor so your objects just leak memory when they go out of scope. Interface Why are you exposing the SSL internal object via a public API? 

Your main issues is that on input you have different types for each key. So you spend time building a generic class hierarchy to hold each of the types. But the main code we see that each specific key expects a specific type of value and thus you try and decode the generic type based on the key value. Personally I would reverse this pattern. As you read the input. When each key is found extract the type you want and call the appropriate handler method. Your second problem is the number of keys that you will eventually have. Yes you should re-write the code to be data driven. That means you to store the mappings of key to action in data not the code. Thus making the driver code short east to read and the same in every case. The only interesting part of the code becomes the data. Below I have mapped keys to actions in the data structure .