This includes timing code which runs the algorithm enough times to take longer than a full second, then divides by the number of iterations so you can get an average time elapsed (also it subtracts the average amount of time it took to loop that many times). On my computer this computes 16 buckets and 24 balls in an average 2,278 milliseconds. (Of course, printing the solution to the console takes a lot longer) Other Optimizations/Changes 

Rather than moving the balls around, we can move buckets. That is, I will mark 3 balls with an 'x' and that ball and the balls to the left of it (until the next 'x') are part of the bucket, (since all balls are in a bucket, the right-most ball must be marked. So we get: 

I make use of an NChooseK function so we can determine how large the string[] needs to be to hold the results from the subproblems which will be carried out at the next level down in recursion. Full Code with Timing Code 

There's a better way If there are 5 balls and 3 buckets, but each bucket must contain at least 1 ball, imagine the following set of balls: 

I am concerned that you have config files buried within your code base. These typically should not be part of your code package (other than maybe providing a template). For example, you should not be including DB credentials within your repository at all (and you absolutely should not be using DB credential for an application EVER) (note to other readers, this was seen in GitHub repo, since code is not here). You have you DB credentials out on GitHub!!! Change them now and get this file out of your repo! 

This means you could even go so far as to pass template file paths into the function on the fly to switch out templates to be used (or you could have some config settings for template paths that the function uses). This could totally get you out of having any HTML within the function itself. 

Does it even make sense to have a public constructor for this class? Why would one ever want to instantiate an object of this class without having appropriate settings for host, port, auth, etc? You could perhaps end up with half-set-up object being passed around your system. If you want to have public constructor instantiation, consider removing the method and making sure the dependencies for that method are passed to constructor and that the constructor actually performs the connection successfully. Also, I would think you should have a failure somewhere MUCH earlier in your call stack that a core dependency like functions is not being met. To me, this might be more of an application set-up concern rather than something deferred until object instantiation. If you are on PHP 5.6+ you might consider placing before your class definition to both make clear the dependency and to enforce that this dependency exists at compile time. 

To make this run faster, use memoization for the function getCombinationsRecursive(). Use BigInteger in the NChooseK instead of longs to support larger numbers, but then you will also need to use something other than string[] for the results for very large instances. Use parallelism if you don't care about the order in which the results get written (although as it stands, that could be difficult with this implementation). Write the results right to left by appending instead of putting the new values in front of the subResults. Completely change the algorithm to do a depth-first search over the possibilities instead of a breadth first search, that way each result could be written one at a time, instead of needing to store it all back out of the recursion. 

I think it is worth mentioning that for large data a different approach could be used, since keeping exact frequency counts of words is too time consuming. Streaming Algorithms like "Count Sketch" makes a single pass over the data, uses low amount of space, and based on the amount of space you allocate to it, can guarantee to get the Maximum Frequency Word with say 99% probability. Algorithms like these are used every day in routers to approximate which IP addresses are requested the most frequently, given that routers do not have enough memory to store everything it sees and only sees each IP address once. For large data, I would recommend this approach. Not sure if 10 GB of text counts as big data for this problem though, however if every word in the file was unique (except one word which occurs twice), you probably don't want to try storing them all in a Dictionary :p. As an aside, Multi-threading may be able to help give a speed-up, although pulling data from a single .txt file seems intrinsically IO bound. It seems possible to pre-partition the .txt file into parts for each thread to process independently, using "unsafe" code with pointers directly at the partition locations in memory, and writing the line parsing yourself from the bit representations of chars. I doubt the above would be worth doing in C#, since you might as well manage memory as well using C or another low-level language for that extra gain in speed-up. Multiple threads would exhibit higher speed-ups on certain processors like the intel i7 which has 3 channels to memory, and this is a highly IO dependent task. If it happened to be hundreds of thousands of 10 GB .txt files across a cluster of computers, I would consider using an approach utilizing MapReduce on a distributed file system. 

If you think of the scrabble board as something that is immutable, I don't know why you need to have a function like this at all. Why not build a matrix to represent the board and simply look at the element in the matrix which represents the column/row combination you are interested in checking to see if it has any special behavior (like double letter score). For example if you built this out into a class (in this case within a supporting module), that might look something like: 

You also have case where it looks like you are "indenting" with single spaces, with really isn't indentation at all. 

Now on the javascript side, let's first start with your method names. There don't seems to match to what the functions actually do. For example, might best be called . I would consider a function signature like this: 

I am guessing that there is some bootstrapping script which is instantiating your slim application an including this controller, so my first thought is, if that is the case, shouldn't fundamental includes like setting up database connections and including security functionality be part of that common bootstrapping process as opposed to being required here? Unless this is the only route (or one of few routes) on your application that leverage this functionality, I would find it odd to include here only in the context of this controller. 

Basically the code is using i,j, and k to mark x's on the balls, and then we get the number of balls out. We don't need to remove any duplicates, since we generated just Combinations, and not permutations. This code works for 3 buckets and n balls. But because of the 2 hard-coded For loops this won't work for more or less buckets. Using Recursion to Infinitely Nest the For Loops The real difficulty here is that each possible combination needs to be written as a line on the console. This means that our recursive function needs to be able to return multiple lines, and add to each line as the recursion comes back. The Base case of the recursion is easy, if there is just 1 bucket, put all the rest of the balls in it. Otherwise we loop through the number of balls we can put in the first bucket, and recurse with a smaller problem size, then add the first number of balls to each of those results coming back. We use a recursive function which is called by a helper function so that we can move the timing code into a separate place. Code to solve M buckets, N balls 

Why would you call this variable when it does not contain JSON, but rather a data structure resulting from JSON deserialization? Call the variable something that is meaningful to what it is actually storing. What if fails (i.e. server sent you something that is improperly formatted)? 

Your singleton is implemented improperly. The constructor must be private to prevent object instantiation from outside the static instantiation method. 

You should STRONGLY consider taking an object-oriented approach here. I think that, because your function is doing too much, you have great opportunity to refactor this code into appropriate classes/objects which each handle a slice of the overall behavior. 

I don't see how this is scalable if you have to hard code product id's into your jQuery code and duplicate handlers for every category you may want to add. I also see no need to have separate logic for "first time" execution vs. every other time. I would consider putting a attribute on each checkbox that can indicate the target category the checkbox filter is to work against. And then put a attribute on each product to indicate what category it belongs to. So let's assume your products are like this: