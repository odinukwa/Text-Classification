I prefer to read test names; they're too short and don't tell me everything. When I run my testing tool, I see the method names in the list as "test passed" or "test failed". It is INCREDIBLY handy to be able to spot that every method with "preventOverwrite" in the name has failed. Your names don't quite allow this. The name of a test method can be longer than usual; nobody has to actually call it by name. becomes for me. Maybe the "With" is optional. 

Lastly, you should consider the case where the entire array is a single value. You will get . You must check if the array is within length. Two solutions for this: either check for this in the () or, check beforehand if the last element in the array is not and use this to guarantee you won't run off the edge. 

And give the local a better name too, I almost thought you were appending 'ISO_8859_1' to your urlImage. 

Next, further reduce the duplicate code. You can see that if is 2, we'll add 2 to index. If is 1, we'll add 1 to index. We can just add to index. (We're reducing duplication of constants here) 

A lot of your methods have side effects. I recommend adding javadoc comment blocks to list these side effects, or to rename them to explain that they have side effects. For instance: 

You have your tile sizes hardcoded in the TileMap ... in an obscure place (render code). Consider placing them as constants in Tile or TileMap. That way, upscaling to 64x64 tiles is a lot easier. 

Have you ever heard about tussenvoegsels? They're parts of people's names. Well, in the Netherlands anyway. When used for authors, it's usually done as "van Surname, FirstName". Your regex doesn't support this, instead only accepting the last word of the surname. You should allow surnames to consist of multiple words. 

Weirdly enough, all that matters for connect-four is that the top row has to be filled in order to block all remaining plays. Perhaps that's not what this method checks, but if you're going to use to check if a new move is possible, then what this really should consist of is checking if the top row has any free spaces. There's no need to start from the bottom up. 

And lastly, give Game a 2D array () for storing cells. This array is for iterating cells. The array is not for searching for things. That's what are for. And have the game just go through the cells, asking how many neighbors have and instances on them. Add the relevant changes to a list, then make the relevant changes. This solves your problems where your Ocean is recreated each frame. This solves your problems where Critters of various sorts need to hassle with and . This solves your problem where adding a Critter to an Ocean means you need to hassle with and . This localizes your game rules in one location. The hassles you gain are that you now need two iterations. First iteration is to find out what needs to happen to all the cells. Second iteration is to apply the changes. I think you'll want to make a new 2D array of objects to place on the cells. The alternative is storing a set of commands per critter; Whilst this does make more sense, it doesn't scale. ... in a functional programming language it would: one would create a set of delayed function calls, then execute them all after another. 

Now, that's regarding all the slashes for your functions. In other places, they are down right dangerous: 

But maybe you'd benefit from writing some abstract function which "overwritesExistingValues"? You're doing the same thing twice already... Lastly, back over here... 

If head is null, do stuff, then set last to the added node. If head is not null, do other stuff, then set last to the added node. In such cases, you should move it out of the if-statement: 

Here you make 4 calls (but only 2 at most per method invocation) to , which is a bit of a waste to me. Try storing the result of the method call in a temporary variable. Alternatively, consider extracting changing of color values to separate functions; one for animated color changes, one for static color changes. Arguments would be the body text color and the RGB from the swatch. 

You need to get the Location from the Land, then you need to get the Orientation from the Land, and then you need to make the Land reposition a Unit... in order to move it. I don't have the source for Land or Orientation or Location but I assume the following: 

So there's no need to include the Locale. Remove the argument. Doing all these in a loop is pretty silly, though. Move it to outside of the loop, so you only lowercase once. Results in this: 

And the rest afterwards. By doing this, (and by adding whitespace) it becomes clear that you're creating a that you're not gonna use, in certain cases. So do your guard clauses first, and THEN instantiate objects. 

Looking at the code for , it seems to be a lot of work to convert an integer to a string. At the moment, you're doing the conversion twice. However, getting the length of a string, via , is a simple getter. As such, you'd probably be better off with storing the string representation in a variable, and calling on that. 

You should put most of this (the switch statement specifically) in the Colors enumeration itself. Something like "fromNumber", which takes the random number and returns a color. Same goes for this section: 

I dunno what you're doing here, but from what I can see, you're calling or . Naturally, this produces or . Then you're comparing it to . Well, if is below 1 but not below 0, then you can just remove the check, as well as the for loop, since doesn't change in the for loop! If is below 0, then the check is not needed. Thus, (please check if my syntax is correct) 

As this is accessed by multiple threads, it should be . That said, though, your multithreading is really flawed, all of the threads just deadlock and 1 is allowed to do all the work. First, multiple worker threads only work if you've got work for several threads to do. In your case, you'd be better off if you could somehow offset each thread by a value (if we treat passwords as numbers in base-(your character set size) then you could say thread 1 starts at 0000, thread 2 starts at 0001, thread 3 starts at 0002...) and then advance by threadcount steps. So the threads interleave, rather than doing the same work: Thread 1 does cases 1, 5, 9, 13... Thread 2 does cases 2, 6, 10, 14... Thread 3 does cases 3, 7, 11, 15... Thread 4 does cases 4, 8, 12, 16... Like that, you can run threads in parallel without them doing the same work over and over and over. 

That saves you one instruction for each time you end via that one execution path. Additionally, you know what pivot is already, so I'd split this in a helper function and a recursive function. 

This method is one good way to burn a lot of CPU cycles. You do not need a separate thread for this. If you simply moved the file opening and closing to the , you could handle the file closing in the function. This saves you a lot of spin looping and ought to give you a boost in performance. 

Your approach is mostly correct, but it seems to be too specifically written to solve the problem as stated. For instance, you're making the assumption that any line that doesn't start with a plus or a minus is a line containing student names. One example case: what if a student gets no pluses or minuses? This wouldn't occur in the case as stated, but you usually don't get this "it's already handled" and it just helps to program in such a way that input which slightly deviates from normal can still be dealt with gracefully. You're also making the assumption that when you're counting pluses and minuses, everything that is not a plus is a minus. This works, for now. But if changes in the scoring mechanism are requested, you might want to go with a more flexible approach - one which separates the I/O and the counting, for instance. 

Don't put multiple statements on the same line. It turns your code into a wall of code. You think understanding a wall of text is hard? Try a wall of code... Naming Use for methods and variables. Use for types. Use for constants. This means that... 

What it does is it looks for the smallest string in the array. So you could turn this into a function, with arguments for the array and the starting position ( will get you the end). The swap, 

That way you go to the database once and allow the database engine to optimize your one query, rather than the lot that you're shooting at it. You could do the same with other queries, but you'd have to do some more processing to split the resultset back to something you can work with. 

... What's the difference between this method and ? The people in the vehicle? Mind you, the entire reason I can get this confused about the requirements is because you put no explanation in code what so ever. This sort of thing is hell to maintenance programmers. 

Algorithm - Reducing search space I'd define as . Then, do a binary search for the point at which is too low, and is too high. Set to . Next, do a binary search for the point at which is too high, and is too low. Define to be . Start your for loop loop with at . At the start of each iteration, set to . Instead of your current moving up/moving down scheme, just start downing k. As long as is too high, = . When is no longer too high, resume your uppy-downy scheme. Whenever you increment , check if is too low. If so, increase i until is no longer too low. Check if gives a better match and store it as temp. AFter changing scope like this, check the opposite end of the scope. So if you just reduced , check if is too low. If you just increased , check if is too high. Do this until scope is stable. Perhaps binary search could speed this (upping i and downing k) up too, but I'm not sure. What this would do is potentially eliminate is a lot of your search space. You see, if I gave you the number 42 to find in an array that contained random numbers between -500 and +200, -500, +199, +200 is simply too low. So you can kill off any number that's below -357, provided it's not the last number at or below -357. This is a reduction of 20% of your search space with a simple binary search. Additionally, once we get to -70, any number greater than 182 that is not the last number at or above 182 is not going to help. 

First, you duplicate an entire array just to change a single variable, with the line . Let's not, and just temporarily store the altered variable in a temporary local variable: 

I think what you've got here is looking pretty fine. You could move the comment explaining that it's recursive to the function header if you want it to be more explicit. The recursive function isn't doing anything strange, though. Usually, with recursion, one can unroll the recursion to be iteration instead. I wouldn't recommend that in this case. Right now, you have about 10-12 lines, depending on how you count. It's just two forloops. The whole function can be summarized as "make a div that contains, for each wpi zone, another div containing it's sub wpi's, similar to the div we make now." If you were to unroll this recursion then it would get messy. You did well. 

So at least 4 cases aren't covered, because you've got 12 cases and the total amount of cases you can have is 16. Let's cross off the matched cases... 

Hang on, if we don't have to determine WHAT comes next, then we only want to know how long the normal text section of the string is. This vastly simplifies the code! 

I would suggest a more sophisticated way of doing client-side validation. This all depends on what your design is (if the customer wants it this way, then that's it), but personally, I'd prefer it if you check the field after I've edited it, and if it is not correct, that you change the styling on the field, maybe set an error label. Right now you're throwing alert dialogs around which disrupt flow. By making the validation reactive like that, the user has instant feedback, rather than "do -> submit -> error -> repeat" which is a cycle that causes frustrations. Imagine you had a separate check for a single digit, or a check to see if there'a capital in the password, and a check that you're using at least 1 special symbol... the user would trigger these warnings one at a time; they'd end up with about 5 errors (1 for the length, 1 for digit, 1 for capital, 1 for special characters, and then 1 for the repeat password because they forgot). Looking at the code, it seems mostly fine for your purposes; the only thing I'd do is move to a separate constant . 

This entire section of code looks like you could get rid of it if you made proper use of enums. You could store an offset multiplier in them; would have a -0.5 multiplier to height and a 0 multiplier to width, whereas would have -1 and -1 respectively. Then you could just write a function , which would work like this: 

You ought to flip this sort of thing, so that the guard clauses are more apparent and less in the way. So handle the bad case first... 

The "old" method doesn't support a length 0 or 1. It'll always return at least 2 elements, so maybe you should add a special case for that? You ought to write out your method names in full - is pretty unclear in meaning, unless you're generating lies. I also notice that... 

Only the case (a and not b) results in a false case. So if we invert it to "if not A or b", it simplifies the condition. This way you only have 1 case where you need to copy a value, rather than 3. 

Should rename to . ... And even better would be to rename it to something that explains what it is. Right now I have no idea what a is. 

Starting at 0 and ending at . Why don't you start at 1? You don't even do anything with the index, so it's not like it matters. 

silently fails with and returning NULL if you provide it with bad params. You might want to replace this with a . 

Either write a statement on one line, and skip the braces, or write it over multiple lines and use the braces. "does not allow building command yet" - is this a TODO? What use is this to a maintenance programmer / API-using-developer? Point to ready alternatives, not future ones. 

This can be deleted. The only constructor throws an exception, so barring weird reflection (in which case, you're doing it wrong), any methods which rely on instances cannot be called. The other option I can think of is if you have a subclass that uses this method. Then this method would see some use - but it's existence remains questionable. Without the exception, however, you can make use of it as normal. 

Okay. So is it threadsafe NOW?! Hmmmm... well... no. Here's a new situation - an external thread stops the application, and then starts it again, but meanwhile the application thread ALSO wants to stop the application. Basically like so: