But even better might be to start the script on startup. That way it will resume collecting, after e.g. a power outage. Easiest way for this would be to start your script from . Just run and add the line before 

No need to add other GPIO pins. You could just use the same pins for your halt-button. Here is some python code that will poll pin 5. When the button is presses pin 5 is pulled to ground (pin 6), and the code will read a LOW. In that case is will run the command 

USB, according to the spec, can only provide 500mA. But it depends on the motherboard you have in your PC. Most I've heard of happily provide more. If you draw more that the mobo is willing to give you, a fuse is tripped. Most mobos have polyfuses, so the fuse will reset after once everything is normal again. But there is a very small risk that you will permanently disable your usb port. 

Program will stop after some time. Thought the time it take will fluctuate a lot. To overcome this use 

I think you are out of luck. A DVI cable has lines for both digital, and analog signal. The Pi will only send data over the digital lines, while you monitor (being a VGA monitor) only listens to the analog lines. DVI cables are kind of weird in that way. The can even carry USB signals. 

PS I though that board was a bit overkill, but the HARDOFF feature is very nice and useful. PSS. sample python code for doing the shutdown, when psw pins are connected/shorted 

Make sure you use dd to write to the SD card, not to the first partition on de SD card. So of=/dev/sda and not of=/dev/sda1. 

You can definitely make you own. You can either cut up and existing micro usb cable, and solder the red and black (not always though) to a central (thicker) cable. You can also buy the plugs themselves Some people have powered the Pi though the GPIO header. The downside to this is that you bypass the polyfuse and the Transient voltage suppressor diode. So you will lose some protection. 

You have to use the solution that is right in the middle of both. Use the layout as per the first image, but also connect the ground to the pi. So the ground goes to both the Pi and the external power supply. 

You need to be root to execute those commands. You current crontab is executed as the pi user. Put the command inside the root's crontab instead by using As to the inverted input values. This is quite common for sensors. These sensors will pull the output to ground, when an event occurs, instead of outputting a voltage. This has the advantage that that it doesn't matter what voltage the receiver requires. This makes it safer to use. Just change you code to account for this inversion. 

You'll also need to connect the ground on the switch, to the ground on the Pi. Otherwise the 3.3V can't go anywhere. You also need to add a resistor between the GPIO pin and the Base of the transistor. Optocouplers are better if you are working with higher voltages, or if you don't want to connect the grounds of both items. 

You'll have to resize the partition inside the image, as long as the amount of real data is less than 4GB. You could do that on a different linux machine. Another Pi would be slightly difficult, as you need enough disk space to extract the entire image. Though you could use an external disk or large usb-stick. First mount the extracted file. Then shrink the ext4 filesystem on the second partition using . This will move all the files to the beginning of the partition. Next resize the second partition, using e.g. gparted. You'll have to calculate the appropriate values, as 4GB isn't always the same on all SD cards. Once the partition is resized, you could expand the filesystem again to fill the entire (now smaller) partition. Then truncate the the image file, or just copy the first 4GB to the other SD. 

Composite output defaults to NTSC. If you got a PAL tv it wil display monochrome. Try changing your config.txt and uncomment the line : 

Servo's can do that, but you have to make sure it has enough range. Most won't do 360degrees. Servo's however require some addition circuitry, to make them stop moving. You don't want jerkiness, when taking photos. This will reduce power usage. Alternatively use a stepper motor. You'll have more precise control angle of rotation. But unlike with a servo, you have to set the start position of the device, as a stepper will only move relative to it's current position, where as with a servo, you can just specify the angle. 

Powering the Pi with 5volt through pin 2 will work. Note however that this will bypass the poly-fuse on the Pi. The power-supply you are planning to use has a 10A fuse, but that's a lot more that the 1.1A fuse the Pi has. Personally I would just solder the micro-usb to the DCDC output, and connect it the official way. But it up to you. Easiest would be to connect in to a ground pin and an input pin with a pull up resistor. So pins 13&14, 19&20 or 25&26 (don't use 9&10). The broadcom chip on the Pi has internal pull-up resistors. So no need for any external resistors. The pull-up will give a constant high signal on the gpio pin, until the PSW closes the connection between the pin and the ground-pin, pulling it to a low signal. don't connects the 3.3v line. The Pi itself will create the 3.3v for the 5v input. 

Most receivers require a microcontroller on the receiving end. The XBee already has a micro on board, so you can use it to directly turn on/off a pin on the xbee. If you don't want to have to program some micro-controllers (e.g. arduino's), you best bet is to get some more remote-plugs. If you don't want to use 220V, just crack them open, and reuse the board inside. You'll have to provide it with low dc-power yourself. Instead of reusing the remote, you can use one of these modules to send the commands. That way you are not limited to only 3/4 devices (depending on the remote you're using). 

Do you have a TV? Just plug it into the TV using either HDMI or Composite (or use a composite to scart plug). 

You could use the GPIO pins to attach some kind of sensor. I'm checking to see if my stereo is on, using just a simple LDR. I placed the LDR inside the SPDIF output of my stereo. If my stereo is on, the is light coming from the SPDIF, and the the LDR will pull the GPIO pin low. Works like a charm. I found out that the LDR I used in combination with the build-in pull-up resistor inside the Pi's chip will result in a LOW if the stereo is on, and a HIGH if off. So all I needed to do is connect one pin of the LDR to ground, and the other to one of the GPIO pins. No other components needed. This is (part of) the script I use to control audio playback, only when the stereo is turned on. 

You can use something like this python script, to poll the input, and to run the toggle-backlight script when pressed. 

The developers of the Pi had some connection with broadcom. That's why they choose Broadcom. There are a lot of SoCs that run ARMv6 (like the Pi) and the more recent ARMv7. Also note that a lot of linux distributions are dropping support for ARMv6 

I think all cameras have an infrared filter. But you can easily remove the filter from the camera board. See this post: $URL$ 

Just use serial, and add an individual line (similar to the CS in SPI) to every Arduino. Just make it so that the arduino ignores all serial input, and queues all output, if his Select line is low. 

You can make multiple partitions, no problem. The issue however is whether or not the camera supports multiple partitions. Also the rasberry OSs have a small fat32 partition at the beginning of the SD card, for storing the bootloader, and kernel. So your camera should skip this first partition, and also the second EXT4 partition. And only use the third fat32 partition you create into the free space at the end. Alternatively you could move the ext4 partition to the end of the SD card, and extend the first fat32 partition. That way both Raspbian and the camera can use the fat32 partition. Since most cameras put their files nicely into separate folders, the filesystem won't be a mess bunch of files. This solution has the most chance of working on your camera. 

The RTC uses pin 5 as an output, for the SCL signal. But you want to use it as an input. This could be difficult, and could even damage the Pi (if SCL is 3.3V and you press the button you'll be creating a short, possibly damaging pin 5 and maybe even the entire chip). To prevent any damage you could add a resistor between pin 5 and the button. Reading pin 5 while it is an output isn't possible, but you can just connect a second (free) pin the the button, and read that one. See schematic below 

It seems you can also control pianobar from the command line, instead of the UI. I see a file called in the git-repository. Either find it in your filesystem, or just copy and past in into your own file. To let the remote select the next song, add the following in your .lircrc file 

R2 looks to be connected to the SDA pin. I guess R1 would be connected to SCL, and R3 to SQW. But you could just unsolder all three of them. You don't need those, as the Pi already has 1.8K resistors on the I2C lines. SCL is just an input on the RTC and the SDA is an , so all it does is pull the line to ground, so the RTC chip will never put 5V on any of those 2 pins. Minimal signal voltage required on the SCL and SDA lines is 2.2V so well below the 3.3V the Pi. So all should work fine once those resistors are removed. (PS eBay has better RTC modules, for half the price) 

Not directly I think, but you could just run a script on bootup that checks the values in . If they don't match the values needed for the current state of the hdmi, changes the values in config.txt and then performs a reboot. Easiest way to implement this is to just have two config.txt files. Something like and . Then in pseudo code 

Just try lowering the GPU-memory values. Once thing start crashing/hanging or display incorrectly, you know you have to go one multiple of 2 above that. 

That temperature shouldn't be a problem. Just watch out for humidity. Especially when you remove it from the cold environment and put it in the warm one. Water vapor in the warm air will condensate on the pi. And water and electricity don't mix. Leaving it unplugged while it get up to temperature prevents any damage from happening. Happy brewing. 

This doesn't work The top resistor should be less than 116Ohms to make GPIO 5 get below 0.8V. This is because of the relatively low value (1.8K) pull-up resistor present on the board, and the voltage drop of the diode. However when pin 5 is an output, and high, 28mA will flow when the button is pressed. Which is more than the Pi can handle. To prevent a LOW on output-pin 5 from registering as a button press you need an additional diode. Not ideal, but it will make you use a single button for both wake-from-halt and shutdown. Also note that it will disrupt I2C communication if you press the button while the PI is talking to the RTC module. Though the chances of that happening are slim, as communication is maybe once every few minutes, and only takes a few milli-seconds. 

Just use CSV. That way you can just append your data to the existing file. That way only the last block will change, resulting in fewer writes to the SD. Once the block is full, it will never be rewritten. Maybe do some to create a separate file for every day. That way any data-corruption will only mess up one day of data. 

You could also achieve this effect with a simple 555-timer chip a capacitor and some resistors. I myself plan on using the following circuit for my tardis project: $URL$ 

From what I found online, there are at least two version out there, On one it seems the coin-line only outputs 3.3v. But you'd have to measure it on your model using a multimeter. If it's higher, you could use a voltage divider to bring down the voltage to 3.3V (a lot cheaper that one of those opto-isolaters) The other version has the coin-line pull to ground, so here you'd only need an (internal) pull-up resistor. 

A better alternative would be the . It drives up to 8 7-segment displays (using multiplexing). It also has inbuilt current limiting. There are however quite expensive. You can however get them a lot cheaper on ebay. Another alternative would be to use a shift-register per 7-segments. You can just daisy-chain these chips together, so you only need 2 or 3 GPIO pins. You however need to add current limiting resistors to all segments. To drive the 12v led strips you have to use transitors or mosfets. These strips, generally, already have current limiting resistors on them. Are you going to build a 7-segment display using led-strips? I don't quite follow the last part of you question. 

Indeed not all SD cards are the same exact size. You'd have to shrink the partition to make it fit on the smaller SD. I had a similar problem myself. What I did was have a separate SD with (in my case) Raspbian. And I plugged in my SD I wanted to resize, using a USB card reader. Before you can safely shrink you partition, you need to make sure there is no data present at the end you are removing. You can do this with (you have to substitute /dev/sda2 with the correct path to the USB-card reader and the linux partition you want to resize). This will resize the filesystem to the smallest size possible. You could actually specify the exact size you want, but it involves some math and converting sizes to blocksizes and sectors and what not. Safer and easier to not do this. After that you can shrink the partion. I think I used for this. Get the exact start position of the partion, delete it an recreate it using the same start position, but with a smaller size. Lastly you need to enlarge the filesystem again to occupy the entire partition using