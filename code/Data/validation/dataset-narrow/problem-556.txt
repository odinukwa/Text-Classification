At this point we could start to tackle the loop, but it would start to get very micro optimized. One might consider aggregating the results in prob and then using and outside the loop, but that only nets like so it's more of a personal preference thing. 

further we can replace the strings and with a Boolean and stay in numpy for longer (down to 1.633 seconds): 

There are a lot of debug prints in your code snippet. I will mark them with a if I can't see any use for the end user. I would opt for removing them. 

Output I've ran the and it tried to create a image. That's (Gigapixel)! as an uncompressed image is no fun. At least on my machine it doesn't fit into memory uncompressed. Similarly, if I look at your it doesn't seem to open correctly; I only get a reddish shadow. On your machine (assuming you have a bigger one, since you can apparently fit 30+GB into memory without issues) you might get more out of this. Fortunately most of these pixels are empty / transparent. In fact for only 2.2% of the pixels are not transparent. Potentially even less, because I've noticed that they sometimes overlap, e.g. a "GC" sequence would only be visible as "C" sticking out to the side. My attempt would be to use matplotlib, however that is still fairly slow and known to not cope too well with big data. It runs slightly faster then your initial version and the memory requirements are better; still its not enough for on my machine. Yet, you get an interactive figure that you can zoom around in and "take screenshots". I like this way to explore the sequence better. Another advantage is that you can specify file format and viewport, legends, axis and so forth. Here is the code for that: 

Given a postfix expression, construct an expression tree. Looking code code review, optimizations and best practices. 

This program connects all nodes of the binary tree at the same level. A node of a tree contains a left, right and a sibling pointer which would connect it to the next node at the same level. This connection is from left to to right. Example: consider a binary tree with parent as node A and left and right child as node B and C. then this program joins B.sibling to C. If the immediate sibling is null, then it is skipped. More details if needed can be found here. I'm looking for code review, best practices, optimizations etc. 

Given a singly linked list, swap kth node from beginning with kth node from end. Swapping of data is not allowed, only pointers should be changed. 

Finer details such as tie-breakers, rules of input params etc, are well documented. Looking for code review, optimization and best practices. 

There is a steep gap after buildins.sum, i.e. you spend most time there. We can use instead (pushing it down to 3.457 seconds): 

I now average over 1000 runs for a single game for both versions (compared to 1000 different games in my original post), using the method posted in Update 4. The other answer is very efficient in cutting down on the constant overhead and rightfully points out that the number of calls (even if it's doing no modifications to the board) adds unnecessary bloat. Juvian also pointed out that I do have access to the current move, which inspired this idea. For each adjacent field I use floodfill to find the group of enemy stones (if any). While doing so, if I encounter a border which is free the group has liberties and I stop the floodfill. If I manage to fill the entire region without encountering an empty border field the group has no liberties and is thus captured. Another advantage of this approach is that it conforms with the rules (See this Boardgames SE question), because I remove all stones in the opposite color first. Here are the two relevant functions: 

in this case and out only parameters. and you need say to caller - which api need use for free returned buffer. 

if buffer not big enough - error is returned - (in case no valid data in buffer at all) or - in case exist some valid data in buffer, but need large buffer anyway. anyway you need here additional out parameter allocate buffer yourself 

here - in/out parameter, but in only - if you reallocate user buffer - you must return new buffer size to user. may be next signature: 

then reallocate caller supplied buffer - this is very bad idea. for reallocate you need exactly know how caller allocate buffer. you must add to interface contract - how caller must allocate initial buffer and free final. which concrete routine use. say for example caller must allocate initial buffer with and free with . but nobody do this. usual used 2 ways: 

Here is a faster version (around per batch). Its essentially refactored for readability and often in vectorized code, more readability / code beauty makes code run faster: 

This avoids duplicates for corners and edges and I could cache the results for even faster computation (though this is not very expensive to compute). Here is the full example as a gist: $URL$ 

Here is my list of thoughts (in random order). Since you don't specify any particular goal I am reviewing mainly for "relative beauty" of the code: 

First of all, this is not a Python issue. Rather this is an issue of the implementation itself. I agree with @Gareth Rees . You should always provide a minimally working example of the code. This is true for StackOverflow and especially true for CodeReview. In that respect all we can review is the little snipped you provide under the assumption that the functions you don't provide do certain things. The first thing that you can cut is the block. It enters iff the last element of is in and what it does is it adds the last element of to ; in other words: nothing. As a side effect you do pop the last element and since you do it in both cases it is better allocated above the . It looks like will return an iterable thing containing all rank 1 neighbors of . If you don't do any caching, is incredibly slow! Loosely speaking that's for the naive implementation and for the one given in the blog post you mention. To make matters worse, you do this for every friend of a word exactly one (since you prune duplicates). So what your running is which in the very crudest worst case can be (!); although this case is only relevant for theoretical considerations. Here is a list of things you can do: 

There are n balls kept on a table and connected by same singe connected string (which can be cyclic or maynot). Write the code to select a ball such that after lifting the whole structure from that ball height will be minimum. (algo+code+ mathematical proof of correctness) Note, I do understand merits of unit testing in separate files. But deliberately added it to main method for personal convenience, so request you donâ€™t consider that in your feedback. Looking for request code review, optimizations and best practices and complexity verification. 

Given a binary tree, return the next right node. This question is attributed to GeeksForGeeks. For example, consider the following Binary Tree. Output for 2 is 6, output for 4 is 5. Output for 10, 6 and 5 is NULL. 

Design a Data Structure SpecialStack that supports all the stack operations like push(), pop(), isEmpty(), isFull() and an additional operation getMin() which should return minimum element from the SpecialStack. All these operations of SpecialStack must be O(1). To implement SpecialStack, you should only use standard Stack data structure and no other data structure like arrays, list, .. etc. Looking for code review, optimizations, best practices. 

Unfortunately, you didn't specify your Python version. In 3.X there is the flag. Hence you could refactor this to You could also get access to (there are implementations for 2.7 on pip). This would allow dealing with paths in a pythonic way, because you can now do things like: rather then and have python deal with the os specific bits (symlinks, correct slashes, ...) 

I can also limit the amount of elements processed. That way I can visualize the first 10 million elements of . I find this visualization to be of limited use, but I guess it makes more sense to you? 

will concatenate all sequences, despite them potentially belonging to different DNA Sequences. Here is Wikipedia (the best source to cite xD): 

A) This is not very useful output. I would rather return how many lines have been inserted into the database or nothing at all. The fact that something happened somewhere while this code executed is implied by the user calling the script. B) If the script fails, you should inform the user; however, it is probably better to not catch any exception and then continue. The block will be executed regardless of what happens in . You can omit the entire block. A setup is thought of as a "cleanup block" which will make sure that the finally is executed before any exception is escalated. 

SetCommTimeouts again - senseless code. this api simply send control code to device on which file open. usually only serial controller driver handle this ioctl. the npfs.sys, which implement pipes - not understand and not support this ioctl. driver return to you ( mapped to win32 error) but you not check for errors here. 

another way - use for buffer. windows let reserve memory space. we can reserve tens of megabytes how minimum. this operation not allocate any memory but simply mark memory region as reserved. then we can already commit memory to region begin. when, after read, will be not enough committed memory - we commit more and so on. advantage - we from begin will be have contiguous memory - we never will be need copy/move/reallocate memory with this way. this solution is better when we assume big enough final data. example: