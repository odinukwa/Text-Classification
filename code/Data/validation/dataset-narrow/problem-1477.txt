In an ideal world, you might give students a problem, and let them explore solutions to it rather than actually covering the content directly. For example: 

Automatic grading is great for saving time on marking programming tasks, so there's more time to focus on actual teaching, but I've noticed a few flaws. Since work is essentially marked based on passing unit tests, thoughtful design often gets ignored, and excessively complex solutions are considered just as good as elegant ones. I recently read this article about how this is a problem on MITx—instead of this solution: 

(and that's just from the script that generates everything!) I would imagine that Rails would feel a little bit overwhelming for a beginner to web development. It brings a lot of baggage with it, like the MVC pattern and a lot of handy generators that are useful to experienced developers, but hide the logic to a learner. It seems logical to me to teach using Sinatra first, and then let your students realise what the problems are. They'll be more inclined to go through the process of learning Rails, with all the extra boilerplate involved, if they see why using an opinionated MVC framework is useful. For trivial backend applications, like you'll probably be developing at first, RoR is overkill, and there are too many concepts that you'd have to teach before actually getting to make anything. I'm a fan of teaching from the basics in this case—showing why each additional layer of libraries and frameworks is needed is far more valuable thank saving some time by skipping Sinatra. And, of course, the motivation to make something can be more easily satisfied by starting with Sinatra, and you can later introduce the 'batteries included' framework of Rails. 

Write some code that is unfinished with some deliberate mistakes and share it with your students on GitHub Get your students to clone / download your code, find and fix the bugs then talk about the problems with having so many different versions of the same code in the classroom. Get your students to fork your code into their own repositories and commit their own changes. Discuss code and commenting conventions and why they're necessary (e.g. PEP8) Get your students to go back and recommit their code in line with the conventions discussed Ask your students to issue a pull request on your code so that their changes can be contributed to the original resource. 

The easiest way to set the conditions so that they can all be reached continuously in every class period is to make the conditions so easy that all can achieve them with very little effort. However, this is not at all motivational and sells the students short of being stretched, inspired and challenged. Dumbing-down the curriculum so that all succeed can get great results on paper but is counter-productive in the long term. A good lesson almost should contain some objectives that can be reasonably achieved by all students whilst also featuring others that create scope for curiosity and intrigue for the fastest/brightest learners. Any teacher knows this isn't easy: 

Websites such as $URL$ and $URL$ are great for students to practise this type of competitive programming activity. In order to prepare them for that type of competitive challenge it can be good fun to create opportunities for competition and collaboration early on when you're introducing new programming concepts. For example: 

Introduce test-driven development. TDD and agile methods of development are very popular at the minute, and for good reason — you know, ahead of time, exactly what each part of the program must achieve, and you can confidently say that the program will work as intended as long as your tests are thorough. I think that sometimes, the confusion begins when students aren't actually sure what they're trying to achieve in the first place, so they're reluctant to test because the code is already so fragile. TDD helps to ensure that there is a clear specification of behaviour for the code, so the students are clear on what should happen, and that the code they're written fulfils the specification. Make it clear that testing is part of the project in your lessons, and it should help to solve some problems. When students are asked to write a program, they may not realise that writing some tests along with the project (or even beforehand, as in TDD) is a good idea. Having the red-green-refactor cycle would seem helpful here; it will give your students confidence that their code works as intended, and then the ability to clean up and improve their code without breaking it. Test-Driven Development Goes To School was interesting reading while I wrote this answer. They evaluated the effects of teaching using TDD at several university courses, with generally mixed/positive results. At Virginia Polytechnic Institute: 

It would seem obvious to explain that the code below that block runs when the sprite is clicked. Similarly, in Node.js, an event-driven programming language: 

Now we've discussed what the problem is, and what most people would do to solve it, you should be able to see why lessons don't actually reach every student, despite no-one actively aiming not to reach everyone. The Solution I can't really promise a straightforward solution that works now, and reaches more students without a lot more effort. pddring's ideas are excellent, and you should strongly consider providing different 'routes' of challenge so that all students can take something away from your instruction. At the very least, you probably need to ensure that students understand enough to build on the concept you've taught (e.g. understanding syntax to a reasonable level before moving on to constructing more complex algorithms). The holy grail is the 'Digital Aristotle' that CGP Grey talks about, but I don't think it's entirely here yet. Some Internet resources like Khan Academy provide excellent self-paced resources and self-test questions which might be helpful to use if students need to work on things at home, so that they do have the prerequisite knowledge. In essence, there are two options to reach more students: provide different teaching for different abilities of students, or try to make sure everyone is on the same page before they get to your lesson. I feel that I've written a lot without actually proposing a real solution, but it's extremely difficult to solve this problem. If you're willing to put in the time, you can provide different levels of difficulty in each lesson, which would at least ensure that the vast majority of abilities are taught well, but I think that the future lies in computers adapting a curriculum just to your students. If you find a platform where you can put tasks that adapt to a student's ability, it may be worth considering so that you can challenge every student to reach their potential. 

Split students into groups Give all students some code that is deliberately incomplete or broken. Award points to the first person who fixes the errors or completes the challenge Once someone in the team has finished, their job is to support the other students without touching their mouse or keyboard. Award points to the first whole team to complete the challenge. 

Problem solving and computational thinking is a hugely transferable skill in itself. Almost any science / engineering route through academia into the workplace is greatly benefited by the ability to write / modify some code that will process data efficiently and generate exactly the sort of analysis / evidence that you require. For example, a substantive part of a Psychology degree involves collecting and processing statistical data. Even without the logical and analytical benefits of CS, the ability to write code to automate the analysis of that data immediately gives you huge advantage over peers without any CS skills. 

The Russell Group of Universities has published a useful list of recommended A level subjects for different degree options which suggests that other than a CS degree, CS A level is recommended for: 

Once they've been through that process in a safe and controlled environment they'll be much more confident joining in with an open source project. It can be intimidating jumping in for the first time, no matter how friendly and supportive the contributors are. You might also want to look at GitHub Classroom which automates the process of creating, sharing and collecting programming assignments from students. 

I tend to avoid multiple students working on the same code simultaneously (Google Docs style) because it's really difficult to assess what has been done by each student or to stop one student dominating whilst the other doesn't understand what's happening. Either that or students tend to get distracted by what the other is writing. Having said that, you could try: 

Of course, there is the overhead of writing the tests and understanding how to use a unit testing framework. For smaller projects, this might be an excessive overhead, but for most non-trivial projects, test-driven development can still be useful. If you're only developing a few functions, you might only need a few tests, and it's great preparation for industry, where TDD is very common. So, in short, don't just stress the importance of testing and hope they listen, integrate it into your teaching. If writing good tests is the norm in your class, it's far more likely that rigorous tests will be written. 

Agile doesn't mean "don't plan", so there should be plenty to talk about. Have your students developed user stories? Can they talk about these? For example, let's take this example user story: 

I would argue most teachers do want to reach every motivated student in their classes; the issue tends to be that there isn't enough time to tailor the teaching to each individual student. So, in answer to your title question, I don't think you need to convince other teachers that you should reach everyone; but instead argue how to effectively reach everyone. As discussed in this fascinating CGP Grey video (who, incidentally, was a teacher—of Physics, not CS, though), the style of teaching adopted in most subjects hasn't changed for hundreds of years — a subject expert discusses the material in the curriculum, which marches on whether you understand or not. That leaves most students either bored because they're ahead, or confused because they're behind. The Problem With 20 or 30 students in front of you, and a lesson that might only be an hour long, there isn't really a lot of leeway to reach each student individually. $$\frac{1 \text{ hour}}{30 \text{ students}} = 2 \text{ minutes}/\text{student}$$ Instead, you have to deliver material to the whole group. Generally: 

Ask them to switch their screens off. They don't like it if you do it too often or for too long but it's surprisingly effective, saves you having to repeat yourself unnecessarily and forces you to try to make your instructions clear and concise. If you can't see their screens you can always tell by the glare from their screens on their faces who hasn't followed instructions. 

How about IP addresses being countries and ports being sea ports? In the UK it works well because there are so many different sea ports that students recognise from looking at an online map of the British Isles. You can extend the metaphor by talking about firewalls blocking off access to ports (e.g. sea blockades during WWII) or increasing security by removing external access (landlocked countries don't need to worry about sea invasion). The main advantage over an address / flat number analogy is that you can extend it by talking about different types of ports (e.g. airports) for different protocols (e.g. UDP / TCP) with various implications for speed / reliability. No analogy is perfect though - students who want to understand it fully should have experience using or hosting different services on the same server. 

You can get a fast-paced, fun lesson where there's enough challenge to get the brightest students being competitive with enough support for those who take more time to understand and complete the work. 

Ultimately, I don't think it's a question of choosing a particular type of student to pitch the level of difficulty to. As teachers we have to be deliberate in our planning and delivery so that there's something even the least confident student can leave having achieved but also some bait dangled tantalisingly just out of reach for those who want to discover for themselves. All that, whilst not neglecting the majority of students who find themselves in the middle of the two extremes. Realistically, my answer to your question is that we can't guarantee every condition will be reached continuously in every class period for every student. I can't anyway. But it's worth giving it a try - it makes teaching more fun as well as more productive.