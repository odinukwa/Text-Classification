So, my question is, can I get Unity's NetworkView.RPC method to put it's serialised objects into this "args" parameter? If not, can anyone see anyway around this? By the way I'm using Vexe's framework, so you might see unusual things like "base.Serializer" etc. 

When I disable an active script in unity, will it be disabled then and there, or will it only be disabled at the end of the frame? For example, if I disable a certain script from within a "OnCollisionEnter" event method, will the "disabled" script still perform it's Update method for this frame? 

No, there's no way to do this. What you're looking for is a container, that holds references to rectangles that are insides its bounds. This isn't an easy thing to do when you really think about it. There is no way for the rectangle object to know any other rectangle object exists, let alone know if one is inside of it or not. However, there is a few data structures that do what you want. For 2D, which I'm assuming you're working in, there's a structure called a Quadtree. A Quadtree can start as a single container spanning the entire map. Now, as you add collidable objects to your game, you must ( manually ) add those objects to the quadtree. The quadtree can then split up into smaller areas recursively depending on the number of objects in the game. The result is that you can pass the quadtree a rectangle, and it can quite quickly return to you all the rectangles that lie in that area. However, moving objects around the quadtree is a whole other story. Here's a better explanation: $URL$ Of course, I wouldn't recommend over complicating things. Unless you're building a fairly complex game, there's nothing wrong with checking every rectangle with each other. 

If you need to, you could use the Assimp file import library's 3ds export function to create the 3ds files directly. The procedure would be as follows: 

I am now creating a 64 bit and 32 bit executable of my game. How could I achieve so that the executable and dlls lie in a separate folder without changing all the path variables in the game? To clarify I want to have a folder structure like this: 

I base all this on personal experience from implementing an animated mesh with assimp and glm myself.(which now works) But it might not be the correct way of doing things. 

To clarify things a bit: I want to create a kind of database for my game, that simply is a class that stores all game-state information like object positions, player scores, etc. The main problem I am facing, that the whole game is to be scripted, to the level of the (lua)script controlling what members should the database have. The reason for this is that I want to create a game that gives modders complete access to the game via lua scripting.(its one of the core features) For this to be viable I need to be able to add custom elements to the database. I want to avoid using a 'real' database and roll my own solution. For example I want to be able to do the following in the script file: 

First off, I think using the GPU is not suitable. Your usage defeats what the GPUs are made for: One program running on a lot of threads. Also GPUs don't support intercommunication and conditionals very well. But your expectations are quite low. 20Hz for lets say 10 000 computers. Nowadays you can count with a 3GHz CPU, with multiple cores. For simplicity lets assume you only have a single thread for this virtual simulation. I am also going to assume that the Lua code(or the one of your choice) is 10 times slower, than compiled C/++ code(Can be improved with LuaJIT, but will be worse due to constant switching between computers and cache misses, etc.). 20 * 10 000 * 10 = 2 000 000 Hz needed to simulate your virtual computers. or 2 000kHz. or 2 MHz. And you can safely assume a computer with a ~3GHz core. Please bear in mind that due to cache misses, memory operations, and because you probably underestimated your instruction needs you will need much more than 2MHz, but you are safe as long as you don't need more than ~1500 times more power. I think this idea is viable performance-wise. I would recommend using Lua, so you don't have to reinvent the wheel, and have a solid base to build on. Its also easier to program for starters(if you want your players to program them). This is pure speculation. If you want a real answer, profile it. As to whether you should research further or not, you should create a simple prototype(throwaway), which will test both if your game is fun and if its viable performance-wise. 

I've implemented client side interpolation, where a specified delay is put on each client. This allows them to interpolate between positions and rotations. Unfortunately, this means every thing else must be delayed, otherwise events ( like a particle effect on a collision ) will happen ahead of time( according to the interpolated data. ) Should I delay everything along with the interpolated data, or do I have the wrong idea about client side interpolation? I haven't seen a single mention of this problem anywhere, which makes me think I'm missing something. 

This vector scaled downwards instead because it was negative to begin with. So, if we scale by a positive number, it's just going to get further away from the origin, the same with the top vectors. They just have different directions. You might wonder why the cube is constructed like this. The cube's origin is 0, 0, 0( this is chosen to simplify things like placing the object, and scaling. Like I said, the origin doesn't have to be 0, 0, 0, but it's a good idea ) so, to get a cube of area 1, we want the total length between vectors in each component to be 1. So, you can see how it works mathematically. Technically the origin is as arbitrary as the bottom center of the cube. Having weird origins can be a pain when scaling though. 

It turns out Resources.FindObjectsOfTypeAll where T is GameObject, returns all game objects "resources" in the project. In other words this gets all your prefabs. They do not have to be in a "Resources" folder. Using this list I can now search them by some sort of ID( either assigned by me, or Unity ), then send that ID over the network and find the prefab from that locally. The problem with this is that the prefab has to be "loaded" on both machines. It's reasonable to believe that if a prefab is loaded on the server, it should be loaded in the client. As long as there is some reference to the prefab in a script( through the inspector, direct or indirect ) or the prefab is explicitly loaded using Resources.Load, it will be able to be found this way. Also, assets are always loaded in the editor. Don't be fooled by this. It does not mean the asset will be loaded in a build. 

The problem is a typical starters error: you chose both loops iteration variable to be the same, so they modify each other. You should always choose nested loops to use a different iteration variable(usually called i, j, k), otherwise things will get messed up. In other languages completely, but here you got the two objects already and using the keys only to remove, so only the removal part got messed up. The correct code should be: 

You could also not re-invent the wheel and use some already existing library for noise-generation. I recommend libnoise2, which is highly optimized and uses SSE/2/3/4/AVX to speed up the process and does a great job. It also has multiple generators and multiple parameters which make later terrain varieties easier to implement. You could also use libnoise, which has much more options, but is a bit slower. Another way you can speed up your terrain generation is parallellism. Most CPUs already run 4 cores, so your gain can be well above 50%. 

The way I(And I believe many others) do it is to have not only one noise generator, but multiple ones, configured differently, and then interpolate between them based on some value(perhaps chunk type, perhaps just another noise function). Also generating a specific terrain type is more feasible by combining multiple noises too. The website of libnoise has some nice information about all this, and also about the various noise generation and mixing techniques. Some basic generators are: 

I would consider P2P a good choice because the average internet connection is getting better and better, in the future P2P latency might not be a problem at all. Also much about P2P depends on the specific implementation. There is also some architectures that combine P2P with Server-client. 

Unity will invoke the RPC method on ALL methods with that name that appear in any of the game object's components. Yes, you could do that, I personally wouldn't recommend it. It will add unneeded dependencies in your project, and pretty much destroys the point OOP. Right now the RPC scope thing is really quite terrible. Imagine if you have an RPC method in a base class called A. Suppose classes B and C inherit from A. Now, if you attach scripts of both B and C to a single game object( not unrealistic ), RPC calls to methods in the base class simply won't work properly. Fortunately, this seems to be getting fixed: $URL$ They seem to be sorting out the networking component of Unity. Hopefully we're not waiting too long. 

If draw is making the whole application slow, logic update will still be on time. If the user doesn't see a few frames, that's okay. If updates don't happen, that's not okay. That actually changes the game. If you're using a well competent 3rd part library for this, then it should have this covered for you. So, basically, everything is still based off time. View can be updated as much as possible, logic can only be updated if a certain amount of time has passed. 

I want to instantiate an object on only the server and one client. This means Network.Instantiate is out of the question and I have to instantiate it manually. Since Network.Instantiate takes a prefab, there must be some way of identifying a prefab over a network( you can't send a reference in an rpc. ) How can I do this? Drag and dropping the prefab from the inspector is also not an option, since the component with this reference is on the server only( the client doesn't have a local reference. ) 

Lets start with general rule of optimizing things, especially when it comes to games: Profile it. It's not worth working on something that works already, because especially with games, you will get stuck optimizing and refactoring what you have, instead of doing actual work. When a player is playing a game, they usually are doing just that, because a game requires most attention, especially as this will only get called when the player is moving, so the CPU cycles you save are not needed for anything else. But lets put that aside, this is a learning project, so you want to try what can you do. The idea you describe has two big negatives: 

Answering your comment: By rendering only quarter tiles, the possibilities decrease dramatically. You shouldn't have to handle tiles on tiles, as they should be on a different layers alphablended or keycolored on each other. Also, I don't see why would you need built-in neighbors, but that could be handled separately in the neighbor calculation, perhaps using some sort of maps(list of pairs that blend). The map is usually static, and the images are low-res, so no need to worry about performance. 

Just as the title states, whats the best way to expose current settings like resolution to my classes? (I know this might have been asked, but I couldn't find anything) I was thinking of the service-locator design pattern, but I am unsure, as I read that it can be abused easily.( I mean it might not fit this particular use-case ) 

Edit: From the video it seems you are overshooting the position you are aiming for. There are three ways to solve this: