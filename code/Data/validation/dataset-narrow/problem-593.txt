The problem of replay attacks also applies to the actual messages themselves. As each message is only protected by the shared secret, you are unable to detect when Eve maliciously repeats a recorded message of the same session repeatedly. A practical solution to that, is to append a fresh nonce to each sent message, which is expected to be repeated in the next message. Now you can tell for sure if the order of messages in one direction has been altered. As for ensuring the coherence of a dialog, you might want to think about acknowledgment messages, which confirm receiving a content message. 

No need to peek ahead for the loop condition. Especially not AFTER incrementing it already. Coincidence that this function was not part of the test suite? 

There is no longer a need to expose the original publicly, as the only legit caller is now inside the same class: 

This is a dangerous design for the interface, as it requires strict type checks in the calling code to distinguish between the error case (non-zero integer) and the success case (true boolean). Stick to a single data type for the return value at all cost. This would have been quite easy in this case, as every error case yields a non-zero integer. So just returning to signal error free execution would have been acceptable. 

You just spun off 3 threads. The one handling the input is acceptable, you don't want that one to be blocked by anything else. But what about the other two? That stuff belongs into the actual game loop. Which you don't have in your design. It would look pretty much like this, if you had one: 

Your approach of separating the actual algorithm from the input/output handling was almost correct. Except that you forgot to implement the latter part. You are neither capturing any input, nor are you creating any output. Except for the log spam resulting from placing your strange test cases into main file. Providing a user interface of any sort is usually considered part of these challenges, even if it's just a console application which reads from and outputs to . Or in the case of JavaScript best a small HTML application. 

Problem with that? You managed to do this for every single instance of . Some problem with and . In your simple application, the effect may be minor. You only have 10 bullets, 6 obstacles and 1 ship in your game. But that doesn't change the fact that you managed to keep 10 identical copies of the very same image in memory. This is actually not so simple to solve. The problem is, that you encapsulated resource management entirely within each instance. Solving this requires a different pattern. Treat , and solely as data containers, holding only the attributes unique to each instance. These containers don't know anything about being displayed. Manage the resources, and also the painting, in a central location. This actually fit's very well into the class. That class only needs to hold one copy of each texture, and the simply iterates over the list of positions at which the instances should be drawn. Alternatively, at least load the resources only once per class, and not per instance. 

Your classmates solution is better, but not perfect. While he realized that you can just access an as if it was an array, and avoided the handling of , going via indexes is usually not the preferred solution in C++. It's just far too easy to introduce an off-by-one error when doing that. The solution to that is simple, rather than going by plain array indexes, stick to iterators when dealing with C++ code: 

If you had tried to implement iterators, you would also have encountered another design flaw, and that is the visibility of and its attributes. You don't want that struct to be visible to the outside at all, and if you ever gave out a reference to an instance, it would be easy to accidentally break your list. 

You must use the same mutex to protect access to , right now it's not even guaranteed that changes to propagate at all. 

The second occurrence where the functionality should have been encapsulated inside is . This function requires specific knowledge about how the storage is implemented, so it's inseparable from it. This also raises concerns regarding the visbility of and . These properties don't need to be exposed, if the methods belonging to are actually moved into that class. For the invoking side, only the capabilities of storing, counting, and reciting stored paths are of interest. Nothing else, especially not how the tree is implemented. Not even the fact that it is implemented as a tree at all. 

This is by no means a unit test. A test is characterized by either failing or succeeding in a replicable way. Simply sending the output to console does neither, even less so when the expected value is only denoted as a comment in your code, making it impossible to run the tests automatically. If you don't want to use a full testing framework, the least you could have done would have been to use the builtin function to assert that each of your test cases either succeeds, or your test suite fails. Your tests should not have been placed in the main file either. Even less so, when that means that they run on every inclusion of your library. And less again when they cause log spam without any good reason at that. As pointed out by @BrunaCosta, your unit tests are also flawed in another way, as they don't test any non-trivial case. 

Why are these variables write-only, apart from the initial check when to run the corresponding logic first? Respectively why does the main loop wait a full second before starting any of the workers at all? 

This only protects you from accessing a null pointer in , but in return it now leaves uninitialized. Not "set to 0s", but actually uninitialized so it contains whatever garbage was previously at the memory address. 

No. Your regular expression only tests for the used character class, but does not evaluate the semantic structure at all. While it is - to my knowledge - not possible to inject arbitrary executable code into the context, due to not having access to parenthesis or , it's still easy enough to provoke an syntax error during evaluation. You also don't validate your stack. Not ensuring that it is empty at the end of your function is just a matter of lacking input validation. Not validating that it doesn't underflow during execution is slightly nastier, because this can result in returning , which then when casting to string results in , which then again during the casts to the identifier which can - other than the name suggests - be defined. 

Be careful when you log. Logging when something spawns? OK. But spamming a log entry every single frame? Waste of resources. 

Understanding what the database does You've got a nasty bug / conceptual error in your code. You code does work "fine" if the field is either entirely missing from , or if it contains a valid value. Well, actually it does not work fine in the first case. Because what actually happens, is that accessing sets this field to , so you are querying the database for a row with as the primary key. You then continue to insert a new row with explicit as the primary key, which the database then automatically replaces by the next sequence number. This side effect is a bug, and should be fixed. But what happens if was set before, not to , and not to an existing primary key either? You create a new row, but you did not use the sequence number generator intended by the database for that. Even being set to an empty string will most likely break this already. Actually, when does it occur that the row, which was supposed to be updated, can't be found? Either someone just guessed a random primary key (which should not happen), or the row was deleted in the meantime. In the latter case - is it actually the expected behavior to re-add the formerly deleted row? Or throw an error? Un-assign the (known to be invalid) primary key and let the database assign a new one? Either way, you certainly don't want a primary key in your table which wasn't generated by the sequence number generator. For various reasons. 

One more problem with your approach: It only "works" at all for type functions. What with more complex datatypes, e.g. collections and alike? For these, you can't trivially encode the error case in the return value. Simply because there isn't a solution with potentially different semantics, inevitably leading to undefined behavior later on. 

To be honest: Not a very elegant approach. Let's have a look at a different hypothetical sample data to see where it breaks: 

That information is key to solving this challenge. Saying that the target sum can't change, is identical to saying that if the sum wasn't found up to now, none of the elements except for the last 3 need to be considered ever again. Your current implementation runs the sum test again every time a different sum is queried, which needs to happen every time a set of fresh summands has been added. This results in an effective run time of \$O(n^2)\$ for single value additions. However, by checking each possible sum only exactly once, you can lower the run time cost down to \$O(n)\$. In the best case, you can even discard all further input for the same run, once the expected sum has been found. You don't need to hold the entire list of previously entered numbers in memory for that either. All you need to remember, is the sum of the last 3 inputs, as well as the inputs themselves so you can recompute / update the current sum accordingly. For remembering the last few inputs you can simply use a , it's specifically made for such scenarios. This allows you to drop the memory footprint from \$O(n)\$ to \$O(1)\$ as well. If you want to express it with OOP, you can now just encapsulate each run in a object of its own, and you are done. 

So what you have in your database isn't a tree to start with. Add a new node which is the only root to your graph, and attach all of the previously created root nodes to this new node. This makes it much easier to work with the data. 

Reinventing the wheel. While it is possible to fix the flaws in the design to get the recursion working properly, storing a tree with a fixed order in a database is actually a standard problem. A problem to which much better solutions than explicitly storing parent-child relations are known. Before we go ahead, ask yourself a question: Given that the database actually contains a much larger tree, and you only want to fetch a sub-tree starting at a given node, how would you do that? Right, you couldn't, at least not without modifying the algorithm slightly. You would always have to fetch the whole table content. There is actually a model which provides that, and also gives the sort order of children for free: Nested set model Have a read for yourself, knowing how these structures work can never hurt. 

Even when you set , any worker thread waiting on can't exit the wait as the wait condition won't be fulfilled. Only threads which were already inside at the time of invocation can even reach the loop condition and hence terminate. Which means your destructor can get caught in a deadlock. 

is also awkward for another reason, and that is being hard wired to . An acceptable compromise would have been to overload on for debug purposes instead. But that's not all, it's providing debug information on the inner structure of the class, not a simple serialization as you would expect from a function with that name. 

That algorithm does build the index in less than 2.5 seconds for a list of 663k words. ($URL$ with ) The catch? Memory consumption is at ~750MB with php 7.0.6 on Arch 64bit. How does this approach then differ from the original one? Mostly by storing the tree in a flat hash map, rather than nesting right away. It's also storing the full prefix in the hash map. The latter one is responsible for the higher memory consumption, but it does also allow to traverse the tree from longest(!) to shortest prefix, and stopping right away when encountering an already known prefix. This little hack makes the effective runtime independent of the length of the words, you are only paying for each unique prefix once. Just removing the will already triple the runtime, and writing to the index unconditionally ramps the runtime back to the ~10s, which is almost the same magnitude as the OPs approach with php7. Actually, in the current implementation, about 50% of the CPU time is spent on , but I can't invoke it less often than that. String handling in PHP is pushed to the absolute limits here. You can do the same in C++, and probably even cut the runtime at least in halt once more. But don't expect the memory usage to go down by much this time. This is a good example of how dynamic programming can trade additional memory consumption for a vastly improved performance. Why do OOP and the array approach differ so much? There is a lot of overhead involved when working with objects in PHP, mostly related to possible magic and reflection. The compiler isn't able to just inline functions as it would in other, stricter typed languages but needs a rather long detour to dispatch method calls. Objects themselves are also nasty little beasts - then compiler can't just deduce from the context as what to interpret the memory block, like any compiler in C++ can, but the Object itself holds a lot of metadata, including the information what datatypes it members currently(!) have and alike. The compiler will surely try to work around this, but as PHP is weakly typed, only rather simple constructs will be efficient. There is actually a tiny difference between the implementations: