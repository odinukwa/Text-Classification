Well, it really isn't a big pain: but I fear of security risks (if that is even possible). Background: I decided to (sort of) abandon my Sudoku project (because I accidentally deleted it from disk), and was given the idea of a JavaFX Helper Library. I started with the , as I find I use login popups quite often. The code is here: 

I am currently creating a chess game, and have so far done the board. The board is pretty much a two-dimensional array, where s are stored in their positions. For example, will be the position , which at the beginning of the game, is a White Rook. The board has some useful methods (as well as required methods), such as , which checks if a specified square is protected, or , , and , which allows test-moving. The only problem to this is that it doesn't handle En Passants. Here is the class: 

What does mean? I can't suggest a name, because I can't understand it. All your comments can either become JavaDoc comments, or removed. I suggest JavaDoc comments, which look like: 

I don't really like seeing empty statements in Java, as there is always a way around them. It's my opinion; you may think different, and that's fine. 

Your file has awkward indentation. I don't understand the extra tab after . Instead, you should keep indentation same for the same level of code: 

You have extra spaces all over the place. To me, it makes the code look not natural. If you like how you write code, you can keep how you write it, but these are some suggestions. 

Your code at the current state looks very slow. Partition sort (or quicksort as it is generally known) is supposed to be faster than Bubble Sort. With my quicksort and bubble sort code, here is what I get for a 1000-element array: 

Then replace all the with length. What does exactly mean? Use a more specific and more detailed (but not too much) variable name, such as . The is completely unnecessary. Instead, use : 

It is in fact pretty good code, just some small nitpicks: Order The fields should go before the methods; in fact, it should be near the front of the class, only after the and fields. Conventions This piece of code: 

In Java, you should declare variables where you use them. Also, the variable is useless if you immediately set the string message to : 

After all, who wants to do that? I don't see any point in making a separate class for finding the deepest node int the tree. Why not just put it under one class? There is a better way to do it with recursion: 

Here, you calculate , add it to a , and then return the minimum in the . It can be faster if you have a variable that holds the minimum of s: 

In the statement, if you don't put a new line before the method brace, you shouldn't put a new line before the brace. You are inconsistent in order. You set the foreground color first in one, and the text in another. Be consistent. You should put 2 new lines between methods, and any non-related lines. It is recommended to have a space after the . 

The program will delete the file, but will not delete the file. Leaving a mess was not what I intended. 

Your method names are currently in , when they should be . should be , should be , etc. Now to individual challenges: Challenge 1: No problems there, just some minor readability improvements (plus closing scanner): 

A couple of problems: Line 2: Space between and Line 2: Space before brace Lines 3, 5, 7, and 9: Newline can be removed but may be left in wanted Line 11: Space before brace Lines 13-14: Should be merged Line 15: Space between and comment Lines 17-18: Should be merged Line 23: Space between and Line 23: Space before brace Line 25: Space between and comment Line 25: typo, I assume? dont -> don't Line 28-29: Should be merged Line 30: Space between and comment Line 33-34: Should be merged Line 37-38: Should be merged Line 41-42: Should be merged Result: 

I can't even follow it. In addition to the above suggestion, always put braces for , , and statements, no matter how long or short the statements are. Result: 

The issue with that code is that everything is in the method. Another issue is that it doesn't follow any OOP principle. But first, let's fix the code. A lot of it can be replaced with ternary operators. 1: 

Horrendous useless methods... Use a instead; it's pretty much the same thing, the only difference being you don't need to specify all the methods: 

Time and space complexity is usually represented with and , so and would be and . For complexity, if is sample, and is check, time complexity is actually , or \$O(n^2 - m)\$, which I would say is simple . Same with space complexity, as well (this I am not sure about, please correct me if I am incorrect). 

I find your indentation a bit strange. You have two-space indentation in one place, and eight-space in another. Keep it consistent. Java conventions recommend four-space indents. 

Does this even work? It seems to me that you are trying to test to each of the above values, but what you are really doing is a binary math operation of and . Let me explain... "and"s each of the bits in the number, e.g.: 

You don't need to keep a flag that you will eventually return with. Just return directly. You don't need an : just use an array. Final Code 

There is a similar line in , and a lot of lines after the function declarations. Let's go format the rest of the code: 

has duplicate code. Though @Michele did an excellent job talking about separating into methods, keep in mind that duplicate code can always be reduced. In this case: 

You will be playing AI, and you will start. Try your best, but no matter how hard you try, you will lose! I will personally give the one who can find a way to beat the AI (i.e. a bug in the program) with a 50 rep bounty. Main.java 

That's a very lengthly piece of code. To delete a Node, it's not about doing something confusing; it's about changing links around. Imaging this list: 

Yes, it looks longer, but it is more understandable (IMO) than yours, and does not require as much String concatenation. Since is a String, you can call it like so: 

fields are usually . You do fine with that everywhere, but here... should be . EDIT: I know that you don't like the spacing, but I will leave it here as a reference as it is the standard java conventions (eclipse formatting implies that too). 

Formatting I can't even read your code. Format it better; in an IDE, you can find a formatting option. In eclipse, it's . If you don't use an IDE, I suggest you install one. Eclipse is available here. Choose the installer, or the "Eclipse IDE for Java Developers" option. Naming 

If the code that is calling the method performs minimal s to the list, it is preferred to use instead, as is faster at adding but slower at getting. Same thing here: 

Notice that vertical checks are easier, due to the easy creation of a with a array. Horizontal and diagonal is similar in structure. 

This way, you don't have to create a . You can further increase efficiency by making your own method that only accepts a and an : 

And you can possible warn the user about only requiring one argument if they provide too much. Something like: 

In java, it is usually bad practice to use so often, as java is a OOP (Object Oriented Programming) language. I have no idea what your class is doing, so I can't redesign your code to be more OOP. EDIT: After providing me with some information, I came up with this: EDIT: With some more information, I would do: 

You have some lines with spaces, some lines without. Choose a style, and stick with it. I suggest the spaces version, because it is easier to read... Spacing here: 

Line 1: Space before brace (hey, I just realised it rhymes!) Line 2: Space after Line 2: Space before and after operators Line 2: Here, I do see a reason why you made it a one-liner. I would usually not do so, but I wouldn't complain if I saw it. Line 3: Space after Line 3: Space before and after operators Line 3: Space before brace Line 4: Space after Line 4: Space before and after operators Line 4: Again, I do see a reason why you made it a one-liner. Line 5: Separate into two lines. I would never put two statements on one line, no matter how related. Done! Result after formatting: 

Always put braces around your statements. If not, horrible bugs may occur when you change your code: For example, lets say you have this statement: 

Isn't it annoying when you can't find a file you recently created? Especially when you either have a very disorganized drive or a directory with lots of files. Even if you don't care, isn't it nice to have a program be able to locate a file for you? I did this because I have files that I can't seem to locate, but I know roughly where it is. The class can: 

Naming Most of your variable names are not exactly good. Names say what the variable is for, and is not just there to identify from . I would suggest: 

Putting it together, I get: $$O(\frac{n(n+1)(2n+1)}6)$$ I am not sure if I'm right; correct me if I'm wrong. Since , , , and are not significant, we can remove them, to get: $$O(n^3)$$ I can't think of a better algorithm, but maybe there is one. I will concentrate on the naming of your variables, and other conventions. Formatting All right, time to complain about how bad your formatting is, part by part... 

It first gets \$10^n\$ where \$n\$ is the number of decimals Then multiplies the number to round with the previous result, and rounds it to the nearest integer Finally divide \$10^n\$ from the result 

You do not have to create empty methods just so another class can override them. Just simply remove them: 

Create a new that holds all the numbers from to the first integer in the array. Loop through each difference. Set to . to the first integer in the array if it was not already . Check if the first integer in the array is . If it is, return , otherwise, return . 

(And yes, add your and methods as well) This way, your code can be faster as implementing a with a can slow you down, because a also has to deal with and more complicated s. I like the fact that you did . Most programmers would (or at least I would) use . Here: 

Your lines are long. To be in the 80 character limit (or as close as possible) while still avoiding string concatenation, do: 

If it is the original way in the IDE, your IDE should have a format option. If you can't find it, search it up on google: you'll eventually find it. Naming Subtitle is one word, so you can easily change to . This applies to may parts of your code. 

Many of the board's methods require you to pass a object as a parameter, whether you are calling , or if it is . A position simply is two integers, stored in an object: 

Thoughts I think they are both equal at 1000, but as the numbers get larger, the first one will slow down significantly. 

To expand on @Caridorc's answer: The method suggested is indeed the fastest way to do this type of question. First, you create a method with a two-dimensional array and a to look for: 

You can just as easily return in the inner statement immediately, without going through the checks in the loop: 

In the and class, there is a array . After each loop, should this array reset, or should I create a new one? Does the logic make sense? (As in, does the way I handle row/column numbers and board checking make sense) Anything else? 

And there you go, small methods! As for the extra methods, I think they are unnecessary. Final code: 

Now you have a horrible bug. It looks fine, but when you run it, will execute no matter what returns. If you actually had braces: 

Close the . Don't use . When you use an , and you know the size it is going to be, first of all, it's a generic type! Set it so that it only accepts Integers. Also, set the size: 

Is there a more efficient way of implementing what I am doing here? Are there some bad practices in there? What is the time-complexity of the methods? (Just want to find out) 

First check if the element being attempted to be added is . If it is, throw a , as I want the list to be "-free" (Only because can't really be compared, because it will throw a when attempting to compare). Increment . Check if the list is empty (i.e. if the Node it ) If it is, create a new with the value of the added element and set it as the first. Otherwise, loop through the elements in the list until one larger than the element attempt to be added is found. Then, add the element there. return . 

The separators will be the upper limit of the bucket right before it; and the uppermost bucket will catch everything that is larger than the largest bound. Now for the actual code: