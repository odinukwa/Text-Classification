Maybe the method would be faster if the process of determining whether a cell is on an upper or lower edge already uses the prospective index of the adjacent cells. This would probably help mostly for the lower edge check because there's one additive operation less, seeing as the value can be used twice (I don't know if it helps much for the upper edge check, because it doesn't really save an additive operation since is the same as ). The checks for left and right edges wouldn't benefit from such an approach, because then you'd have to do the modulo twice on different values without saving additive operations (for the right-edge check, it would only move the addition/subtraction of from the modulo comparison to the modulo calculation, and for the left-edge check, it would even increase the number of additive operations needed, because you'd have to calcuate the modulo of and compare it to , and you'd also have to make a special case for ). However, since you can use the edge neighbor indexes for the corner neighbors, it might help to calculate their prospective indexes in advance anyway. 

Your double pointer array beats the hash map again. Finally, increase the array size to 5,000,000 (the program ran out of memory when I tried to run it with 10,000,000-size arrays, probably because I generated all 10 test cases in advance instead of only generating one for each benchmark). 

This admittedly reduces to a utility class, but it also makes the method a lot more compact, because the responsibility of detecting the range in which height and length fall that determines the token would then lie in the class, which means that the transcoding method can simply pass the height and length as a parameter without having to worry about in which range these values fall. It might also be faster than your code, because it doesn't have to loop through several enum values in order to find the correct one, but calculates the character directly from the height and length. The next thing I would do is redesign the methods and . If I understand your code correctly, these methods are only meant to operate on objects that represent one-length-bin-runs. This means that the length of the objects should never be passed to these methods in the first place, because the methods not only don't depend on the lengths, but they would even produce incorrect results should an with a length other than be passed to these methods. So instead, I would make these two methods accept a rather than a , where the represents the frequencies of the single bins. This is only for readability, it doesn't impact performance, but as I said, your code is so complicated that every opportunity to simplify it can help prevent headaches. Now, let's look at the method in detail. I would omit the two boolean flags and because they are interdependent, meaning that it is possible that they contradict each other (namely if and ). Using one integer as a switch, as you did, is sufficient. However, for the sake of readability, I would redesign this switch to store the maximum upper boundary, which could either be or , because right now, it is impossible to tell what the variable is for without reading through the whole method. 

Depending on what you want to do with the class, you could also consider overriding to generate this . 

Then, you write a separate method that tests that method by constructing a map like you did in , passing this map to and then inspecting the returned . This would be a unit test, because you are testing the functionality of a unit, i.e. the method . 

I tried an even hackier approach using a single variable as a bitmask instead of a in hopes that setting an to would be faster than filling a of 26 elements with . This was indeed a bit faster than a , but not much, and of course, it has the drawback that it only works for up two 32 different characters (or 64 if you use a ). I also replaced the with a , because by taking advantage of the method , the variable becomes obsolete. Finally, you said that you need the program to work for strings of up to 1,000,000 characters, and while experimenting, I noticed that the number of steps for randomly generated and scrambled strings of length 1,000,000 containing only the characters to were getting dangerously close to . While the number of steps for randomly generated strings so far have not exceeded , I constructed an extreme example where the result would indeed not fit in an . Suppose you have a string that starts with 38461 A's, followed by 38461 B's, then 38461 C's etc., and the scrambled version would simply be the reverse of this string, i.e. 38461 Z's, followed by 38461 Y's etc. The string would have a length of 999986, and the number of changes needed to turn one into the other would be 480,755,769,325, which is greater than (2,147,483,647) by far. Ironically, the algorithm runs in under one second for this special case with the optimizations for repeated/already encountered characters, while without these optimizations, it seems to take forever (I've stopped the program after 40 minutes or so). But seriously, I really doubt that it's possible to squeeze any more performance out of this algorithm, at least in Java. Maybe using a language that's not interpreted by a virtual machine but directly compiled to machine code would make the program faster, but I have no idea whether this is really true in this case. I don't know anything about this, but I've read that compilers today are so optimized that even a program in an interpreted language does not necessarily run slower than if it were written a compiled language. But this probably depends on the program, the language, the compiler and other things and cannot be generalized. Nevertheless, if the programm is still too slow, it might be worth a try to use a different language altogether, although I have no idea what language could be more suitable for this, and if it would actually make a significant difference. 

Also, I don't know if the properties of a specific can change during its existence, but if they cannot, you might consider making them to eliminate the possibility of involuntary modification of these properties. And if they can change, you'd have to make sure that these changes are reflected in the properties of a object, which your code doesn't seem to take care of, so you already have an example of why storing a property in multiple places is dangerous. 

Instead of using two s, you could use two instances instead, because duplicates in any of the two arrays can be ignored. Also, the declaration of and in could be moved into the innermost loop to reduce their scope to the smallest extent necessary, which would make the code a bit clearer in my opinion. Other than that, your code seems to be succinct and working. 

You are horrified by "the type of that thing" because you are using stream operations for something they were not meant for. The purpose of streams is to perform pre-defined operations on an arbitrary number of elements of a kind. However, you have a scenario where the operation you want to perform depends on the nature of the stream itself. I did not really inspect your code in detail, because, based on your description of what you want to do, my suggestion would be to use a different approach altogether: It is possible to obtain an iterator over the elements of a stream by calling on a stream (which is a terminal operation, so the stream will be consumed after creating the iterator, which means that you can obtain the iterator only once). Using that iterator, you can simply accumulate the elements inside the encountered s in a as long as they are all right eithers. If you encounter a left either, you stop iterating and return this left either. If the iterator is exhausted before you encounter a left either, you just wrap the now fully populated list in a right either and return that either. 

This advances a queen until it is either safe or can no longer be advanced, which is basically what your code did, but here, this is achieved without recursion, saving a lot of stack memory. 

I'm not sure what you expect from writing an - construct where both the and the block contain exactly the same code. Your method is effectively equivalent to the following: 

Here, both and should be a that only contains options (a fits here perfectly, because it cannot contain duplicate elements and the order of the elements doesn't matter). The number of serial numbers containing this combination is only a value that is associated with this combination and not a part of the combination itself, and an empty belongs here even less, because it is only relevant for the output format and has nothing to do with the combinatorial logic itself. If you apply these changes, the above code could be replaced by this: 

Update I've refined the code that demonstrates the usage of the binary search algorithm provided by the class. Instead of simply creating a copy of the original array, sorting that copy, finding a number pair from that sorted copy and then iterating through the original array to get the indexes, the updated code binds the original indexes to the numbers prior to sorting them. Unfortunately, this cannot be done with a , because then it would not be possible to use the binary search methods in , since, for one thing, a is not comparable, and for another, its method also takes into account the entry's value, which in our case would represent the index in the original array, which is irrelevant when just searching for the numbers. It is therefore necessary to design a helper class that ignores the index the numbers are bound to in its and methods. This might seem convoluted, but from a purely programming-logical point of view, this is the most elegant solution I can think of for your algorithm (note that there might still be faster algorithms â€“ I'm just trying to optimize the implementation of your algorithm). 

Now, I also have some points of criticism on the code design prescribed by your instructor, which I'm going to mention here as well for the sake of completeness. 

The problem with your design is that you have different fields that, to a certain extent, represent the same property, leading to interdependent state, which makes the code fragile and confusing. I am talking about the class and . For example, the class contains a field , but it also contains a field , both of which represent information about the size of the fine. So it is possible to construct an invalid object by assigning the fields and contradictory values, e.g. and . The same applies to the number of points gained. Since the fields and already contain all the necessary information regarding the the fine size and the number of points, the question is why you actually need an enum. 3 of the 5 enum values, namely , and , only represent information that is already stored in and , which means that these enum values are practically useless. So the question arises what the enum is actually supposed to represent. Let's look at the other two values, and . Disqualification is an additional action that is taken on top of the fine, and a warning is issued in place of a fine, so both are not really "types" of a fine, but actually have nothing to do with a fine directly. So how to represent a warning? That probably depends on what you want to do with a warning. Does it have any state associated with it, like a object that contains the size of the fine and the number of points gained? If so, it could be a class of its own (and and could be subclasses of a common superclass). But judging by your code sample, it doesn't look like it, so maybe it would suffice if the file that contains the driver's registration details has a way of storing the warning without the warning itself being represented as an object, for instance a of dates on which a warning has been issued to the driver. Similarly, the disqualification is not directly related to the fine, so like the warnings, it could simply be stored in the file with the driver's registration details separately from the fines. Finally, about the field in the class . This should not be a field at all, because its content only depends on the other fields. Instead, I would write a method that generates the based on the values and , for example like this: 

Here is a slightly convoluted algorithm that yields the same result as yours but is faster. It takes advantage of Java's native support for arrays instead of using an internal : 

But I think there would only be a point in doing that if you need it more than once, because otherwise, it would not really be a remedy for code duplication, but just unnecessary code (since you don't really need it for the first three cases due to the pre-existing method ). 

I assume "next" in means "after one unit of whatever temporal unit you use in the unit of the velocity", since the change of a position based on a velocity only makes sense in the context of a time span. As for your code, you could simply model the path of the object by breaking it up into subpaths where the direction does not change, like this: 

Other than that, your usage of and looks fine. However, there is a phenomenon called a "spurious wakeup", which means that a thread can be awakened for no apparent reason at all. This is very unlikely, but theoretically, it is possible that one of your two threads is spuriously woken up after it enters the waiting state but before the other thread acquires the lock on , which could result in one thread printing two consecutive numbers if the thread that was spuriously woken up re-acquires the lock. You might take a look at this. Also, your program never terminates. You can rectify this by calling or after the loop. 

Your first version is unreliable if there are numbers that consist of more than one digit. For example, the method would count only two distinct numbers in the array , and only one distinct number in the array . Apart from that, you could also use a stream: 

You are only able to access 's fields and from the method because this method is declared in the same top level class as . I don't know why you chose this design for your code sample, but the fact that you made the method a method outside the class rather than an instance method of makes me think that is also supposed to work "from the outside" without having access to 's internal implementation details, so I'm wondering whether your code design in this regard is intentional. If it is, then I won't argue against it, but if it isn't and if should also work if it were declared in a different top level class, then you need to implement a way for to provide some way of accessing the contents of the list it represents. A way to start could be for to implement the interface , which would require to have an method. This method could, for instance, look like this: