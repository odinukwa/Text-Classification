Note how I create a even though the input is a String constant? This is deliberate so I can use reference equality () on the check, and guarantee no collisions with some other String. Let's put that pill on the class which is the coordinator for the other classes. Now, back to the Reverse thread's loop... The 'industry-standard' way of coding the loop in the reverse thread (using the new poison pill): 

Note, I would normally recommend the Map should be a HashMap, but, read the next section... Class Choices and bugs Your class choice of Hashtable is wrong, it should be HashMap. This will lead to Iterator instead of Enumeration as well. Also, you are making big assumptions about since you use it as the key to the table/map. This is a problem because the keys need to be immutable. I would recommend using an instead. Conclusion... There are a lot of things which can be done differently. The code has a lot of work to do still 

Why all the redundancy? That method name duplicates all the signature components. It is tautology. Also, why does it take a collection, and return a List? It should return a Collection too, or it should be parameterized too.... at minimum, just rename the method to something like (I like the word ): 

all expected elements in each row are present all expected elements in each column are present all expected elements in each mini-square are present. 

Note, that if the recursive call is required as part of an exercise, then it is implemented correctly/functionally, and I can't see any problems other than the limited size of the array (I would guess about 40,000 elements is too many to handle). 

???? Your Node class stores it as an , so there is no reason to do the multiple conversions. The algorithm you have used for the 'sorting' is similar to what I would do. There are a few nitpicks though (one of them is not so small....): 

measuring performance with a single call is never going to do anything in Java - you need to call the code enough times to allow the JIT compiler to compile it. It is unlikely that the JIT compiler will ever compile the method So I extract the 'hard' logic in to a seperate method that the JIT system can compile and isolate. I handle the special cases seperately.... put the user-dialog outside the calculation.... 

Note that Now, your warn method is creating a new , just to print the trace. Moreover, it fills in the trace, even though that is not needed. Let's compare the performance here. I built three methods in to this ideone here: 

the methods are all thread-safe now (you can find many paths in parallel using the same methods). the data and the logic are both self-contained. there are no static variables. 

would be better as a (or rewritten as ). Your current logic will return for an input value of , and that's not appropriate for an function. Additionally, I don't know how you would really test these things, because, if I am not mistaken, in floating-point comparisons with signed-zero values, yet I would expect that would return . How you resolve this issue though, I don't know. 

Your algorithm is very sub-optimal. Essentially you take a copy of the input array, then you randomly pick an index values, making sure you have not yet picked that index. Once you have randomly selected the indices, you then copy the data back from the temp copy, back to the input array. The bottom line is that you loop through the indices once, and, for each time, you check to see whether you have already selected the index. This is a \$O(n^2)\$ operation, with an unlimited down-side..... you could possibly be sitting there forever guessing index values that have already been selected. This problem has been studied many times, and, by general agreement, the Fisher-Yates shuffle algorithm is about as good as it can get. It is an \$O(n)\$ algorithm (time complexity), and it takes no extra memory space to run (\$O(1)\$). Do some searches for shuffling, and you will soon arrive here: Fisher-Yates Shuffle. That algorithm is proven to be optimal, and as reliable as your random number source. Use it, or understand why your algorithm is better/different before you re-invent this particular wheel. 

To put things in perspective, on a 64-core computer (128 hardware threads), a program that was able to run at 80% CPU (i.e. 100 hardward-threads running at 100%) was reduced to about 3% CPU when about 1000 traces were taken each second. This sort of performance is highly dependant on the JVM version, and the vendor. Stack traces are considered to be part of exception handling, and building the trace is not supposed to be fast. Questions about Trace versions (FYI, this may, or may not help you): 

... in fact, the only methods that can be used reliably are , , and similar ones. Extending seems to introduce a lot of ways to break the code/data integrity. I recommend encapsulation instead. In fact, this is a common "debate": Inheritance vs. Composition/Encapsulation (search for those topics on google). In this case, composition/encapsulation would remove a lot of your issues, and reduce the class to just what you need. Underlying your class you could still have the ArrayList and Stack, (except class is deprecated in favour of interfaces) but it would look something like: 

This must be one of the most complicated implementations I have seen in a while. I object to this being called a hello-world problem at all... by definition (wikipedia) a hello world program is supposed to illustrate the simplest way to do it.... and is not supposed to be used to illustrate complex processes. I would call your program, and the text it outputs, as something else.... based on what you are trying to teach... but I can't figure out what that is. Are you using this as an example of: 

The use of ListIterator is a great solution for manipulating linked lists, and because the operations are O(1), it's quick (of course, the linear scan is slower, but we hope that the topx is much smaller than the total number of lines, so we hope that most of the records are smaller than the first record. Of course, if each string is longer than the previous string, then all items will be scanned each time :( 

Your algorithm makes the probabilities of some numbers much higher than other numbers. Is this intentional? For example, 0 will appear 3 times as often as 1. It would be better to simply have the input string and have the uniform distribution. The range you supply in your for-loop is confusing, the requirements are for 6 digits, but, you use the magic-number 5. in the random. Consider using: 

This makes the and the implement the interface. Before it was the and that implemented it. I know, subtle difference, but, what this means is that your line of code: 

At face value it appears that there can be only one place where the major bottleneck is: the actual file transfer. Your code does the following: 

merge multiple input files (at least one) to an output file each line is treated as a line, not necessarily a "word". If the input files have just one word per line, then the output would be the same as the original specification. take the input files from the commandline (the first file is the output file). 

Note how your initial array already contains the "next" password when initialized. Then, you can convert that to a string, and then increment the array to be ready for the next call. But, I want to sugges tthat you are doing it all horribly wrong... ;-) What you should be doing is using a simple long value to store your next value, and then using integer division and modulo to work your base-62 system. Additionally, your variable names are quite horrible.... but that's OK, we wil lget rid of them all except the worst.... 

Lots of extra objects The largest single criticism I have is the creation of LinkedLists where they are not necessary. Creating Objects in Java is a performance issue, especially when done often. Methods like the following: 

So, I would probably handle the escaped-backslash, probably with a negative-look-behind on the split regex .... Then, I dislike the use of the StringBuilder. Because I know the internals of StringBuilder, I know that it is faster to append. I would treat the StringBuilder differently to you in 2 ways: 

This has presented an interesting problem. Your solution concerns me, because it does not solve things the way I would. This, in itself, is not a problem, but I had to look through your code, and figure out why you were doing things. Your solution has a couple of unexpected, and useful side effects. 

The reason that the MessageDigest methods contain the method, is to deal with larger files, and allow you to hash them in parts. I would use this as an opportunity to learn the somewhat older NIO features: Channels, and Buffers. Consider the code: 

Your powInternal is also a functional extraction that is redundant. I suspect this is a copy/paste issue, or a refactoring that was partially undone. Still, the assert is meaningless, and cannot happen, and the function should just be re-integrated in to the public function. Then, I would also make base the variable that mutates in the loop, and remove the variable, allowing you to convert the loop to a while loop. Finally, I know it is pedantic, but you should sjift the exponent with instead of , even though the exponent is not negative. Something like: 

Since this is tagged 'algorithm' I am going to review your algorithm.... Your algorithm here is wrong. Looking for all combinations () is a very expensive way of doing it. I know very little about Scala, but, can assure you that a much better (the best?) algorithm would be something like: 

That takes the second letter from the Enum name (e.g. it will pull from ). Since all your Enum names have a systematic name scheme, this will work, but, it's not the best system... But still, once I have the working off the internal values of the enum (instead of the ), you can do the following: replace the line: 

This will be much faster because it uses the hash lookup instead of the array loop to find the category. you will need to adapt the output to loop through the @categories, but print out the %catcount 

Build up two Strings, one of spaces and the other of 'x' characters. Each should be at least as long as the longest value we will need. loop through the rows and use parts of each of the two above strings. 

That inner code gets the scores, if it does not exist, it creates a new scores, puts the new scores back (if absent), and if some other thread already did it, it defaults back to the winning thread's scores.. so, it works. But, the same concept is not checked on the outer map... the outer map handling is, summarized: 

It follows that, to test if any number X is prime, you only need to find 1 prime number less than X which divides in to X without a remainder. There is no need to test non-prime numbers, because if a non-prime divides cleanly in to X, then the prime factors would also divide in to X. So, if you keep a record of the previously calculated primes, then you only need to scan those values to see if they divide in to X. In essence, each time you print a prime, also add it to a list. This will require 'seeding' the prime list with the value 2. A second optimization is that a number X is only prime if it has a factor. A factor is a number, multiplied by another number, that is equal to the original value X. The useful theory here, is that, as the value of the first factor increases, the value of the second factor decreases. There is a point when the first and second factors 'cross over' and the second factor becomes less than the first. The cross-over point is the square-root of the number X. When you pass the square-root of the number, you have tested all the possible factors... there's no need to scan values larger than the root, because, if they were factors, you would have found them already by identifying the small factor that matches the larger factor. Putting these two items together, you should modify your code to: