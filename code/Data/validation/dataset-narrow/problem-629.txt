See also below. Flawed implementation Your code can easily be made to overrun the bounds of the array. In fact, that will happen if the number of usable key characters is smaller than the number of letters in the message. To (partially) fix this, you need to wrap around the end of the key inside the loop, rather than at the end of the loop where you now do that. That will, however, expose another flaw in your implementation: it does not handle the case where there are zero usable key characters. Your current implementation will just immediately run off the end of the array in that case; after the fix, it will loop infinitely. See below for a suggestion that will help. Error handling does a decent job of noticing when memory allocation fails or nothing is read from the input. It helpfully returns in those cases. , however, ignores those signals and unconditionally passes the result to . For its part, assumes that its argument is always valid. Either 's behavior or 's could be ok in isolation, but together they constitute a flaw producing undefined behavior under some circumstances. Similarly, returns in some failure conditions, but pays no attention, assuming that the return value is a valid pointer, in attempting to print it. Implementation improvement If you have (which is standardized by POSIX, not C itself) then it is a convenient alternative to + + . calls before prompting for the encoding key. This is useless. Move the flush after the prompt, or remove it altogether. Since the prompt ends with a newline, it is probably unnecessary to flush even after printing the prompt. I remarked above on problems with your key handling. I observe also that you handle your key inefficiently if it is short relative to the phrase to encode. You shouldn't need to check on each pass through the key which characters are usable. You shouldn't need to account for upper- vs. lowercase on each pass, either, if indeed you make them behave the same way. Instead, process the key once, before the encoding loop: remove characters other than letters, and convert all the letters to a standard case. Then it's also easy to validate result to ensure that there is at least one (or two, or whatever) key characters. It doesn't make sense to me that your encoding code is not parallel for upper- and lowercase key characters. The code for uppercase keys looks equally applicable to lowercase keys except the computation of , but you use a more complicated and difficult to follow scheme for lowercase key characters. Indeed, one of the alternatives for lowercase keys cannot even be exercised, because and cannot be true at the same time. Design improvement Your function modifies the input string in-place, but also returns a pointer to it. On the other hand, the function's name suggests that it will create a new phrase. I suggest changing that function's signature to 

Common characteristics Asymptotic complexity Both algorithms perform θ(n) operations for strings of length n. Since the task always requires examining every character of the input, there can be no alternative that provides better asymptotic complexity than these do. Additionally, each has memory overhead that does not vary with the input, which affords no asymptotically better implementation in that respect either. Of course, implementations with the same asymptotic complexity are not all equivalent by either measure. See also below, however: your implementations of these algorithms are potentially flawed and less efficient. Wrong range for Your codes assume that the string elements all have numeric value between 1 and 126, inclusive, but can be a signed type, and whether signed or unsigned it can have more than 7 value bits. Also, is always a valid (from C's perspective). As a result, on any conforming C implementation there are valid C strings which, if provided as input to either of your functions, will cause that function to exhibit undefined behavior. To solve this problem I suggest declaring your arrays with dimension , and casting input s to type before using them as indexes. Failure behavior Each function exhibits somewhat surprising behavior for non-empty inputs that contain no unrepeated characters. They return that character among those with the minimum number of repeats whose first appearance is earliest in the string. It's unclear what the function is supposed to do in that case, but the the actual behavior is potentially misleading. It would be better to return an error code. You could use 0 as an error code, as it is the only value that cannot appear inside a string. Your functions will already return 0 when presented with an empty string as input, though I'm uncertain whether that's by design. Alternatively, the functions could return type , with the result being -1 when there is no unrepeated character, else the first non-repeated one cast to . This is the scheme the function uses. Loop termination conditions Both codes contain loops with for their termination condition. The compiler can lift the evaluation of out of the loop only if it makes several assumptions about that function. Inasmuch as that's a standard library function, it is conceivable that that would happen, but by no means certain. If it doesn't happen then your implementations become θ(n2) instead of θ(n); I therefore recommend lifting the call out of the loop manually. Alternatively, consider avoiding altogether -- since you need to iterate through the whole string anyway, just break the iteration when you reach the terminator. That should be more efficient. Using type for character counters Each code uses objects of type as character counters, but 

and the answer is certainly "yes". Other than broad generalities such as I have given so far, however, code review is not really a good platform for what essentially boils down to designing a complete replacement for your present code. From here out, therefore, I focus on the code you actually presented: 

Failing to use braces where they are not technically required has contributed to real-world bugs of significant consequence. Using braces may seem a bit unnatural to a person coming from Python, such as yourself, but such a person is especially at risk of writing buggy code if they do not adopt a firm rule of always using braces. Their eyes are used to attributing significance to indentation that just doesn't apply in C. By all means, however, do indent consistently. That's not a problem in your code; I just want to underscore that indentation makes code much easier to read, and should not be overlooked. Indentation was the norm long before Guido van Rossum thought of making it significant. 

My first observation was the same as @EmilyL.'s: that you're performing unneeded string concatenations. Upon investigation, however, it turned out to be a loser to substitute two invocations of methods for a string concatenation plus one method invocation -- the result ran about 70% slower than the original code for me. It took a while for the lightbulb to turn on, but that slowdown is a key symptom of the underlying problem: is unbuffered, at least when it's not connected to a terminal. In a comment you described addressing the problem by building the output in a and then printing it all at once. That's a viable mechanism for buffering manually, but cleaner and easier to integrate into your original solution would have been to wrap a buffered stream around and print to that. In other words, at the top of add ... 

(Or even better, use static final strings belonging to the class instead of string literals.) The localized format strings on which that method relies will use argument specifiers to designate which argument to format, so as to be able to accept the same (some possibly unused) field values in every case. For example, in the en-US locale, some of them might be 

... does not perform well. Regardless of the details of the palindrome-checking algorithm, it is performing far more work than it needs to do when used this way. In particular, it is very wasteful to test every deletion candidate, and it is slightly wasteful to test separately whether the full string is already a palindrome. For each string it tests, your code may perform work proportional to the square of the length of the string. Instead of testing every possible deletion, simply scan each test string from both ends until you find a pair of corresponding characters that differ. If the string can be made a palindrome by deleting a single character, then that character will be one of those two. They are the only candidates you need to consider. By limiting yourself to considering only those as deletion candidates, the maximum amount work performed by your code is only linear in the length of the string. (Also, if every corresponding pair of characters matches, then the string is already a palindrome, so you don't need to perform a separate check for that.)