should not be placed in a function like that, define at file scope. In this case it seems unnecessary since you could declare it as a constant instead since it is used for dynamic allocation. 

memory ownership is not easy to follow in your code avoid using raw pointers. By using smart pointers ownership is always clear and you dont need to bother about where to delete. 

arguments to the function should be declared const since it is a good indication for the user of your function that you are not going to change the contents of strings 

with less versatile I mean that if your class does not throw exceptions the user of the class cannot take any corrective action if something goes wrong or give out custom error messages in his own language. 

sidenote: when you declare functions that do not take parameters, write as argument. In C when you write e.g. it means that the function can take any number of arguments (as opposed to C++). Writing makes it clear it takes no arguments. get_slices There is no reason to declare as static, better to have a local variable that you return. You should also check return values of allocations, they may in some cases return NULL so that must be handled. also again, lose the gotos generally speaking it is good to check arguments to functions so that they are sane. e.g. with asserts 

Lot of code but here are some comments. class Card Personally I put private parts of a class at the end of the class, those are implementation details. The public parts OTOH are more important for the user of the class. (IMHO) Use scoped enum for the card suit, as it is now you use char so any char can be accidentally assigned. assignValue assignValue depends on the order of when the member variable m_card was defined, it would be better to make it static and take as argument the card otherwise this can be an error source in the future. A std::map could have been used to hold the values of the cards e.g. map constructor you do not initialize all declared variables, std::string is initialized automatically to empty string but it is good nevertheless to show that you initialize it for clarity. one day you may change the type of the variable and forget to add it to the constructor nameCard you seem to have omitted the King. your switch sets a string for 0-3 but forgetting to call this function will forget to define that variable, you could instead make sure the card has a textual suit by defining it in the constructor same time you assign m_suite. again the mapping from value to some string could be held in a std::map both for suits and for the textual values like "Ace". that would make things like Deck::fillDeck smaller. Deck Use a smart pointer instead of a raw pointer to the cards, that you do not have to worry about memory leaks. 

You should not change the function parameters like you are doing to 's'. If the function becomes a little bit more complex it then becomes very hard to read. Instead create some local variables with descriptive names; trust the compiler to optimize the code for you. 

Your pop function just removes the top most int, but normally one would like to get the value as well not only remove it. seems more natural. Your functions do not deliver any error codes to the caller instead you select to display error message with cout. It makes the class less versatile, instead you should let the user of your class handle the error messages and just return error code/throw exception. It is good to be consistent with {} for each if statement not switch between with and without e.g. 

you should also check the function arguments to see whether they are null or empty. you start out directly by assuming points to something and increment it. at the very least have asserts to see if caller is following the contract of the function, asserts only trigger in debug mode. 

I would like to add to @LokiAstari's excellent answer It is a good rule to write out all possible tags in a switch statement, you have one case which you do not handle also add a default as well to catch any invalid values that may be added in the future. Your / functions I find are a bit too long, IMHO it would be better to split up the function in a couple of separate functions to make it more readable. (Also here you suddenly stopped having any comments). You have quite a few variables in your functions so separating the functionality into several small functions will help with that too. When you write comments have in mind that the reader often wants to know why something is done, not what is being done since that is the purpose of the code. When you initialize member variables do it in the form of 

Another point is memory occupancy at every level of the hierarchy. The read no number exceeds 105 - or should do fine instead of . Instead of counting incoming and outgoing edges separately, keep balances (incremented for one, decremented for the other): graph not Eularian if any balance differs from zero after input. As a rule, instantiate "Java Collection Framework classes" using an expected size where possible. Here, no vertex will have more than m-n outgoing edges - but even instantiating n "Array-Collection"s with that size is Θ(n*m). Not specifying a capacity leads to Θ(mlogm) time if "almost all" edges are from one vertex. should be linear, but with high factors - for the hell of it: 

(Dare I mention comments, doxygen, or statement of purpose?) No documentation of and in particular means not knowing if there are any invariants to keep (at least on return). There is quite some open coding of doubly-linked list operations: use a library or try and factor out as much as possible (which only carries so far with intrusive lists/trees in a language not supporting OO). Regarding the amount of lines: consolidate early outs, e.g.: 

is on the long side. If you factor out recreate_node_array() (under a better name), you can return early from that avoiding the repetition of . Guess confused me - oho: following the pseudo code in the Fibonacci heap chapter of CLRS quite closely (consider referring to that near the top of the questions). 

As interface design is pivotal in type design, I'm happy to start there - let me refer to . In no uncertain terms, the documentation summarises in just two sentences what is about: element access and bulk boolean operations (see for something irritatingly similar) (leaving out summaries ( and ) and paraphernalia). I like that it is possible to have non-reflected binary codes - assuming a : . I second AJD in preferring a constructor with a single parameter as an alternative to a separate generator class for reflected binary Gray codes. With that change, the whole API collapses to - which in itself is weird: Objects should be constructed in a valid state and never get invalid if that can be helped. (Another hint about the API is the lack of documentation - compare to .) Then, there is implementation: 

Checking from the end of a promising index range intending to leap as far ahead as possible, thereby reducing the number of checks, is the way to go. There is nothing special about the indexes you start to check from: Why start checking upwards without knowing there's a new record? Work in progress: not named, not documented, not tested 

You seem to be bent on thinking of nodes numbered starting from 1 - nothing wrong with that, and coding the way you think about a solution/problem is the only sane way to start: for a shot from the hip, allocate one more array element, don't use index 0 and drop all of "the ". 

I think this implements Hierholzer's algorithm in O() (with a bit of hand-waving around adding up to m - n edges to an taking Θ(mlogm) time - with constants "never" allowing to be faster). (If that was true, there shouldn't be a performance issue - I should really set up a test.) 

Note the order. Start readable. Start with What shall this be good for?: (doc)comment your code. No slower than what? A "well known implementation" for reference and as a base-line would be useful. Things I liked: 

(While expected run lengths for uniformly distributed bit patterns are (1 +) smaller than 1,) There is no need to process the remaining bits in a loop: 

You noticed that just the last bit of the value of SimpleFunction is used in the described check, and implemented using an "early-out" encountering the largest common digit. Apparently, this uses O(N1 * N2) evaluations of SimpleFunction. (I failed to find an analytical approach promising to be much faster for just shy of a million pairs.) The evaluation of SimpleFunction better be fast - you seem to plan to cache function results, an do back-of-the-envelope calculations of the resources required. The impact of memoisation depends on the time taken to (re-)compute a result and to retrieve it, respectively - let's try to make computation fast. The signatures for the digit strings are the sets of digits used, in a normalised representation. As long as is no larger than the number of bits handled in a basic operation, this can be handled as a "bit set", allowing fast intersection (bitwise and), union (or), …. With nine digit values allowed, there are 29(-1) possible combinations: one could represent the baskets with 2*511 10-bit counts, one for each possible set of digits, instead of 2*1000 9-bit signatures. To check if SimpleFunction for a pair of signatures would be even, get "the and" representing digits common to both strings, find the highest common digit using or some such and map to even/odd. 

in use instead to get the real error from the OS instead of "can't open" e.g. i also agree with Emanuele that seems a bit ... vague? better with in if you run out of memory you silently return, it would probably be good to return some kind of error code instead allowing for a user of the function to take action. This applies also to exit(), doing an exit in the middle is not a good strategy, better to return with an error code. Let the caller determine what to do e.g. write an error message. in you but there you do not check the return value. 

it is a common defensive programming technique to put asserts at the beginning and at the end of a function to ensure that the functionality is as expected. first you check if the caller contract is fulfilled, then that the expected result is reached. 

Exceptions in C++ are normally not used to steer program flow as you do in handle_replay(), I think it would be better to have a simple do {} while loop to handle "replays" When you create a project like this it is good to put it in its own namespace to avoid problems with functions overloading/collision when you don't expect it. E.g. 

general impression overall the code looks clean and tidy so it is quite easy to follow some comments/suggestions MISRA and other coding practices recommend to always use compound statements after conditionals to make the code more clear and more foolproof for maintenance 

Having user/pwd in code, especially in clear text is a bad idea. If you still want them in the code at least encrypt them in some way. As they currently stand anybody can with a hexdump program read them. 

There are several style guides (e.g. google has one), it is up to you pick one or do your own but there is no universal style guide. Important is just that you are consistent in your code so that you don't use different styles in different files, that is confusing (irritating) I find your code looks fine from the style point of view. Normally one would avoid (if possible) to include the headers like Hangman.h and CharReader.h in your header GameManager. Instead you declare them as pointers in the header and remove the headers. 

It would be interesting to know why you start at 22. EDIT: I see you have some of my comments already in your todo list, anyway I will keep them here as well. 

The while loop's expression says it should quit when c is not a digit but after that you do not handle the case if c was EOF. Should you then return EOF or 1 ? Personally I get a bit confused by the function name, when I read getInt() I expect it to return an int instead of getting the value via an argument but that is just me. 

is the name of the function if you want to use standard C but I understand your compiler has some convenience function. You should also check the return value of ungetch() to see whether it failed or not. It returns EOF when it fails. Code is for programmers to read so there is absolutely no benefit of making terse expressions by ocular optimization, instead let the compiler optimize and focus on writing clear code. Use compound statements instead of single line statements for clarity. 

You class contains a number of raw pointers e,g, LineCodeGenerator* which could be replaced with smart pointers to make ownership clear and memory handling easier. 

It seems unnecessary to have the macro when you could have just have written a define with the actual size 

other than that i find it was quite clever way of calculating atoi, it took me a moment to understand it -- sometimes it is better to let the compiler optimize the code for you than try to write too clever code. 

Prefer references instead of pointers when you pass arguments to functions, that way you are sure in the function that they are defined and not null. Also you see that it is not clear from the function prototype 

in general it is better to write functions that do not force the user of them to look at the implementation in order to figure out how to use them. your function allocates memory and returns a buffer that the user needs to free. this fact is not obvious from the function name (it could have returned a ptr to a static buffer for instance, or a pointer to a global array whatever).