Finally Finally, you need to run the script on each reboot, add the following two lines before the on the file `/etc/rc.local' to run the script created before. 

The client.php will receive the hostname on the 'host' variable and from the header, you can extract the caller IP address (and port). At the same time, client.php, can return other information to the client, saved on /tmp/reply. 

I have Ethernet and Wireless , each one connected on a different ISP. If I disconnect is kept unchanged, in my case ATT, pointing at their 'private' 'dns-servers' (75.75.75.75). My other network belongs to, in my case ; is not happy lending their DNS servers to a competitor, so they block the access. If I do a the communication is established again. I may use public DNS like 8.8.8.8 or 8.8.4.4, but I want a more generic fix to this issue. 

if you finish using the device, just it, do this otherwise the partition will be marked as dirty and may need a cleanup on next mount. 

You may edit your .conf to remove (or '#' comment) the replaced network. This network definition will be enough to associate/register. You don't need the usual parameters like: 

This will show all the past Wi-Fi connection plain text passwords ... no more secrets. If you mac have Ethernet connectivity, perhaps you can share the Wi-Fi doing Internet Connection Sharing and just plug your RPi to the Ethernet port. pd: If you know the SSID and password of your home Access Point (router), you can add as additional network statement on keeping your friend's definition. 

Alternatively (and probably more safely), you could just install a clean Raspbian Jessie image on your Pi, and the dependencies should be satisfied as expected when following the instructions. 

contains pre-compiled binaries, which, by their nature, only work for a specific architecture. Pip only has builds for x86 and x86_64 (no ARM builds, which is what you'd need on a Pi). You will need to compile OpenCV yourself instead, since there aren't any available binaries for ARM processors. Be aware that since the Pi isn't very beefy, this will likely take a non-trivial amount of time (this site claims 2.8 hours for the Pi 2 and 9.5 hours for the original B+, and this site estimates about 1.5 hours for a Pi 3). For instructions on compiling OpenCV, see: How to install OpenCV on Raspberry Pi 3 in Raspbian Jessie? 

I couldn't find any explicit mention of voltage in the Pi FAQ, but it turns out that the voltage constraint is part of the USB standard. Note that the tolerance listed there is 4.40 — 5.25 V (in the sidebar). See also in the RetroPie overclocking documentation: 

Yes. This is noted on their bug tracker; you'll have to use Raspbian Jessie instead. A recent pull request to their Git repository suggests that this is being worked on, but, for the moment, you're out of luck. To get rid of and , the packages you installed, run: 

Probably you don't want to start all over again. If you are short of space after cleaning your multiple downloads and unused source code, move to a larger memory card. You need to be able to mount a secondary card on you RPI, either with a 'pen drive' carrier with SD socket or similar. Your installation is based on NOOBS, so you finished with a few partitions no longer in use, however the amount of wasted space is not that significant, the elimination can be painful. Some open spaces are created for boundary alignment. Create a clone on a larger SD card (16GB or more). Using Win32DiskImager create an image backup using the 'read' button on a filename of your preference, then, use 'write' to copy the image to the new SD Card. Mount the new card and boot. At this point, you must be running a clone with the same original empty space. Using , 'p' print the current partition. Copy-and-paste this information to where you can use as a reference. Will look like as follows (yours will be different): 

In my case, sometimes with no apparent reason I get disconnected (once or twice a day). I have this job running every few minutes to reconnect the WAN if not up: 

What you want is a headless unit, sometimes referred as Kiosk computer with a touch screen and perhaps a few GPIO controlled relays. Boot time for a Raspberry Pi is less than 15 seconds, including a possible WIFI reconnection, from power up. I'm not sure where are you looking at your messages, if you are looking at your UART serial port output, they can be easily removed (raspi-config). You did not mention what kind of screen you will be using, the TONTEC (an probably others) will not show the boot info, unless you designate it as a primary display. Then you bundle you application as a service you will not require any manual input. Also, the application will be active as soon as your app prerequisites (defined by you on the .service ) are running. 

There's no reason to disbelieve the maintainer here, and it does indeed seem that no-one else has managed it since (at least not visible despite copious searching). The closest I'm aware of is Google's AIY Projects Vision Kit, which runs a TensorFlow network on a co-processor connected to the Pi Zero W in this kit. The co-processor is an Intel Movidius VPU and the kit is apparently for sale for $45. It's worth noting the co-processor is specifically designed for vision applications using convnets and I'm unsure if it even supports anything other than the video input from the camera. You also are expected to train the network on a more powerful computer; doing so on the Pi, even with the co-processor, would be pointless and would waste your time. Training a neural network is pretty intensive, and the Pi Zero simply would not be up to it in reasonable times. 

Notice the line . That's equivalent to 3 GB, which is more than the 1 GB of RAM available to the Pi 3. You will need to tell Gradle to use a smaller heap; somewhere between 512 MB and 768 MB is probably wise, but you'll need to test it and see. To set the heap size, create a directory called in your home directory, and in there, a file called . If you're using the default user, the commands to do that in the terminal are: 

The Raspberry PI family run on BCM2835 ARM6 512kB or BCM2836 ARM7 1.0GB peripheral controller. Installing on any other processor, will operate just like any other Linux, without the rPI functionality (GPIO), so will defeat the purpose; drivers required to handle your phone will not be preconfigured, finally, the boot process on a phone is significantly different than on the rPI. So, the answer is no, keep using your phone as a paper weight. 

W10 IOT when running on RPI is a headless system due limitations imposed by the amount of RAM memory available. You should handle your W10 using powershell; after the proper installation of WinRM, run Enter-PsSession '-ComputerName ` only then you can execute remote commands on your Raspberry IOT device. Your probably noticed that the HDMI is basically, not in use and there is no GUI. However, there are drivers to use the GPIO ports and you can make it great IOT device. 

Looks like the CRDA package was missing from Jessie. To fix this issue just install the CRDA package 

I always have success with the following simple process. After burning a new SD card (or the one in problem), using windows or any other alternative method, open the on the new card FAT partition directory. On windows, this is the first partition, the second is not directly readable and windows will ask to reformat (Ignore!). At the bottom, add the following two lines : 

Essentially, the documentation states that generates unit files at startup for the services in , and uses the LSB headers to determine when the services should run. In Jessie and Stretch, LSB headers have been added to all old-style init scripts in , so these can continue to work despite the switch to systemd. As for why this is the case: this answer suggests that the plan was to have sysvinit as a fallback in Debian, and most likely for compatibility reasons also. That said, there are some contradictions between the documentation, and what users have observed to actually be true. This answer on Unix & Linux claims that the headers are not required at all for systemd to convert them, which would explain why systemd still used your script, despite you probably not writing a perfectly LSB-compliant header. You will need to remove the init scripts as you would with the old init daemon in order to stop these services from running too. See also: disable init.d script in systemd on Unix & Linux. 

For running the scripts in series, you probably don't want to use a Python script, but rather a Bash shell script. Create a file called with the following contents: 

So that's a factor of 10x, when idle. You could expect significantly higher power consumption when the networking is active, although I suspect that the Wi-Fi power requirements would grow much faster than the Ethernet power requirements. The baseline power consumption for a Pi 3 with Wi-Fi is about 250 mA, so I'd expect nearer 230 mA for Ethernet-only (although sadly that wasn't tested in this benchmark). Of course, you'll always get the best results testing it yourself. Plug-in energy meters tend to be a little expensive, though, so it might just outweigh any gains you do get, but it is interesting to know nevertheless. 

You will noticed that our external drive UUID is '1C0EBC7A0EBC4F10'. so, now instead of using the physical location (ie sda1) use the UUID: 

Prerequisite Make sure your Wi-Fi is properly configured and working. if something goes bad your access to the device through will be limited or inexistent. Setup We need a couple of packages to start: 

In a nutshell, the RPi family of devices does not provide a method to keep power alive while finishing a write operation on the SD card. If during a power disconnection the memory card is in a write operation, there is a high chance that one or more sectors will be unexpectedly damaged. My personal opinion is that the Raspberry Pi Foundation should take a look at this situation. 

then find the location and name assigned to the device when external drive was mounted. This location may change, you can use the 'UUID' to make it location independent (Universally Unique Identifier) (*). 

Note that the boot partition is MS-DOS, so if you have to fix you can mount the SD elsewhere and edit. If boot fails, the loader will show on your (HDMI) screen the available mounting points. This setup is contingent to the mount order. The partition number may change if the device is mounted on another slot; you can make this location independent as follows. Find the the device 'UUID' 

Here you have two simple voltage regulator circuits that you can build, parts will be available everywhere. They are inexpensive and easy to build, parts are very common; your neighbor electronic repair will have them. A Ham-Radio friend can also be very handy! The optional fuse can be 3Amps for one Raspberry. 

Yes, if you create a custom OS version. You can create a custom OS version for use with NOOBS, and include that with NOOBS Lite. This custom OS version will include the image, so no network connection will be required. The documentation specifies that a Linux PC is required to do this, and provides step-by-step commands that you may follow. Note that if you don't do this, though, according to the NOOBS documentation: 

[Note: there is a typo in the tutorial as it asks you to ; if you did this, you would end up in a non-existent directory because of the leading pointing to the root of the file system] If you list the files in with , you should notice an file among others. That is the missing module you were looking for. If you create and run your script there, it will work just fine (as the tutorial suggests you do). Alternatively you could add the directory to your so that you can resolve it in any directory. 

Python's built-in IDLE IDE is far less resource-intensive than PyCharm, but still has a "debugger with persistent breakpoints, stepping, and viewing of global and local namespaces". To make sure IDLE's installed, run: 

Why does Raspbian think you have the latest version of when you don't? I'm guessing you're running Raspbian Jessie. If you are, it turns out that 2.2.6 is the latest version of in the repository, so clearly when APT checks the repository, it finds that you're already up-to-date and doesn't upgrade anything. Why isn't the version in the repository updated then? That's down to how Debian's release system works. I'd encourage you to read the second half of my previous answer on a similar topic—essentially, once a release is marked stable, no packages will receive feature updates, ever. Alright, just tell me how to fix the problem! Version 2.8.6 is in the buster (testing) repository. Because you're a responsible Debian user and don't want to make a FrankenDebian, you might want to add the backports repository instead to access these packages. As noted in the documentation: 

This is a faulty design, it's easy to fix doing some manual edits, however this should be on the basic design. the temporary fix is just: 

The table from all is very complete and accurate. The interpretation is as follows. Looking from the top, connector on your right, numbers are odd on the left, even on the right, the square on the PCB is pin '1'. 

The problem When disconnecting the interface that was assigned as the primary, the one holding the default route, the secondary interface, now primary, will not be assigned as default route. The default DNS assigned to the first interface will not be assigned to the default DNS of the newly primary interface. So, we have two separate issues: 

On the default Debian repository the Zoneminder package available is the version , however the last version is (with a functionality I need). Following the advise on Zoneminder 1.29 I added the repository (*) 

On either case, you will need to find (and track) your router's public ip address, often randomly changed by your vendor. Notification when someone connect the device to the internet is a complete different story.... 

Interfaces edit the file to match the following, this will set your eth0 a fix ip address (10.10.10.1) and will recreate . 

This assumes the static IP on eth0 is 10.10.10.1 and you have a DHCP server listening on the same (or clients with static ip). Now, I want to add IPv6 to the mix. IPV6 is working fine, however, thus far, not success in sharing it on the ETH0 port (or whatever name on Stretch). Among other setings, I have 

Otherwise, you will likely need to download the sources and compile/setup the appropriate version yourself, it appears. 

This line doesn't make a lot of sense as written. returns an array matching the glob pattern (the sort of pattern you use in your terminal, e.g. ). Your code doesn't get an array of images, as you're expecting here. 

The convention of being used for escaping is used in many programming languages, too, such as C (and its descendants). Cron also adopts this convention. 

However, it's unlikely to be terribly economical, and probably costs more in electricity, but it is possible to mine (slowly). Surprisingly, though, one person reports that mining Monero (which also uses CryptoNight) is profitable with Raspberry Pi units running a CPU miner. Testing your hash rate and power consumption would evidently be wise in this case, as it might turn out to be modestly profitable, or might not. 

Alexa can't play (and isn't even aware of) music stored locally. All music that Alexa can play is processed on the cloud and streamed to the device, so Alexa won't natively support playing music. That said, if you're willing to store your music on a cloud hosting service (with HTTPS only1), you can build a skill to do that. (an official Alexa sample skill) could be adapted to play your local music, by cloning their code and following the steps provided. This is, unfortunately, very tedious. Alternatively, you can upload up to 250 songs to Amazon Music for free: