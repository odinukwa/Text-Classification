Your code exhibits some inconsistency about whether binary operators are separated from their operands by spaces, sometimes even within the same expression. I find code much easier to read when there are spaces around such operators, but if you choose not to place such spaces then at least be consistent about it. Personally, I prefer also to see space between keywords and parentheses (, , , etc.), but not between functions' names and the parentheses around their arguments. That's a bit easier for me to read and parse, but it is of little significance as long as you're consistent. 

This isn't a big deal, really, but as a matter of style I recommend using -family functions only when you're actually relying on them to do some formatting. For outputting string literals, one of , , , , or is usually a better choice. In particular, I would recommend as an improvement on . 

... and skip the initialization loop. (Elements not explicitly designated in the initializer get initialized to 0.) Comparative efficiency It's hard to be sure what to compare here. The two codes comprise slightly-different versions of the same underlying algorithm. Implementing fixes for the various shortcomings I discussed would bring them to pretty much the same place, which would look more like the second code than the first. There are a number of possible variations on this approach, some of which may run slightly faster than others, but I don't see room for anything substantially more efficient. 

When I read "algorithmic complexity" I immediately thought asymptotic complexity. But of course, improving asymptotic complexity would require choosing a better algorithm, and I am disinclined to believe that that's what you were trying to do. On the other hand, it's not actually what you said, either, so I guess I'm just saying that your wording could have been better. 

That can be implemented in about 8 lines, as opposed to your 100-ish, with those 8 being largely self-documenting. Or just a few more if you want also to output the per-position messages that your current code does. Impossible / incomplete results Your simple approach to filling the board affords results that could never arise in a real game. The example run you presented in fact demonstrates this: players 1 and 2 both have threes-in-a-row. This may not be a concern in practice (i.e. that may be what you intend to do). You also do not produce representations of many of the possible games -- specifically, those that end in fewer than 9 moves. This, too, might not be a concern in practice. Spelling You're at least consistent, but in English, a flat surface for playing a game upon is a "board", not a "bord". The misspelling makes no functional difference, but it is distracting. Code style The code style is pretty good in general, but the most widely accepted coding conventions call for class names to start with an initial capital letter: . 

- Make use of initialization. In C, "initialization" means designating the value that an object will have at its creation, and it is accomplished via (exactly one of) the object's declaration(s). This is distinct from assigning a value later, even immediately after, and it has its own rules. For example, when you initialize an aggregate object other than a union, any members not explicitly initialized take default initialization values (generally 0). Thus this ... 

Code structure The nested loops obscure the structure of your code. In method , all iterations of middle loop are being performed during the first iteration of the outer loop, before the rest of its body, and all iterations of the innermost loop are performed during the first iteration of the middle loop, before the rest of that loop's body. That's effectively three separate, unnested loops running in sequence, and it would be much clearer to write it that way. Variable scope and protection Class has multiple instance variables that should instead be local variables of method . In fact, the only ones that appear to make sense as instance variables are and , and possibly also . The others have no business being part of the state of a ; they are details of a particular run of method , and therfore should be local variables of that method. Furthermore, few, if any, of the variables that are retained at class level should be . As a matter of style, convention, and good practice, member variables should normally be , with accessor methods where appropriate. There are exceptions, but you've presented no reason for me to think that any of those are in play here. Improper use of You initialize a new instance of for each random number you want to generate. This is at best wasteful, but it may actually be biting you by producing results much less uniformly distributed than you presumably hope to get. The correct approach is to instantiate once, and then to draw all (pseudo)random numbers you need from that one instance. Convoluted algorithm You're just filling the board, not simulating a game move-by-move. With that being the case, there are far simpler ways to go about the task than the one you have implemented. For example, 

For example, the number of palindromes less than of equal to 1,000,000,000 is 1 (for the palindrome 0) plus the sum of 

That's still O(n2) in the worst case, but it cuts out a lot of excess temporary objects (duplicate palindromes are now the main source of unwanted temporaries), and it avoids all the unneeded reversals. Fine details In , there is no need to perform a null test on before closing it because there is no way can be at that point. The bounds on the inner loop of don't capture the true limits. This is evident from the fact that you compute at the beginning of each iteration, and if that is too large. That's actually bad two ways: not only is the loop's termination condition deceptive, but you perform a bunch of do-nothing iterations that you could easily avoid. That is, instead of this ... 

It's at least twice as costly as rearranging a min heap appropriately without removing the modified element could be made to be. You've given no basis or context for putting that on absolute grounds. 

... and everywhere else print to instead of to . Doing that cut my run time by more than 50% relative to the original code, for a maximal-size test set. 

Your code looks pretty good, and surprisingly free of bona fide problems, even for code posted here. I find that I have little or no criticism of its behavior. C does not have such a strong sense of common stylistic convention as does, say, Java, but here are some things to consider: 

You cannot reverse a standard linked list without touching all its nodes, which has a lower-bound asymptotic complexity of o(N) operations. Your method has O(N) complexity and uses O(1) extra space, so you cannot improve its asymptotic complexity in either of those dimensions. Note that the usual recursive solution consumes o(N) overhead, all on the stack, so an iterative implementation is clearly a superior choice. You could, however, make it slightly more efficient by updating just once, at the end, instead of at every iteration. In particular, instead of inside the loop, you could use immediately after the loop. No other changes would be required. Consider, however, that if speed of the method were of paramount importance, such that it was reasonable to sacrifice a bit of list-traversal performance, then you could create a List class for which is O(1). I would do that with an internal circular, doubly-linked list of Nodes, with node traversal performed via a Node method that relies on an instance variable of the host List to determine which direction to consider as forward. With such a structure, (logically) reversing the list would be achieved simply by changing the value of the single variable that controls list direction. Example: