On top vnp's answer, I would return and instead of and unless you have good reason to do otherwise. (Which you might, i.e. in the case you want to run a simulation. Otherwise, returning and instead of and is un-Pythonic.) 

Instead, I would first switch to PyPy (which uses JIT compilation to make the code, in this case, much faster) and run the program that way, install PyPy, then (this worked for me): 

As for the overall structure of the code, I would try to avoid the -- chains. Instead you can use either a dictionary with a keys , , etc. and with functions such as , etc. or a list that stores just stores etc. in the order and in a particular order. To go even beyond this, you could add a function attribute to , , etc. called and generate the start menu by iterating through the list and loading each . Here is an (incomplete) example of what it should look like: 

Are extremely similar and should be placed into a function. This is doable if you put stuff like into an approprate dictionary (maybe ?) - chains Instead of: 

There may be some others. Please read the link so you can find the issues, or run pylint on your code to correct all of these issues. Structure You really should avoid using global variables unless you absolutely have to. In this case, you don't need them. Classes Given that you have some global state at the moment, it might be a good idea to write a class describing your game. 

This assignment is not terribly necessary. Your algorithm can be simplified considerably. I think this should be left as an exercise, but here are some things you shouldn't have to do in the new algorithm: 

divides so now assign to and update . Update by multiplying it by so and increment . divides so now assign to and update . Update by multiplying it by so and increment . so terminate the algorithm. Return which is the number of divisors for . 

Based of the statement I would know that this the purpose of . I would omit it, but it does explain why you increment , so there is some grey zone here. You write some good comments toward the end, let's analyze why they are good: 

The word sounds like your taking an iterable of some sort and summing all the values in it. would be a better name. Even then, I would expect to return all possible pairings, which the code doesn't currently do. 

The two sets you use , and . Maybe you should allow the user to supply such numbers? Allow one to change the sides of the dice. 

Also, add some spaces in between your function declarations, it's hard to read when everything is clumped together. But don't over do it (in particular, don't double space everything). 

On top of what @alecxe has said I would advise you update your docstrings to include the parameters and descriptions of what they do using some well known convention. Also, I would emphasize you use a well known convention so that way some documentation generator (for example, Sphinx) can use the information to generate readable docs. Note: Sphinx uses the reST convention. 

Why not something like and ? and are used so often I would certainly forget (even with the comment) that this referred to falling objects in particular. 

Is prone to errors when you don't use braces. Python enforces indentation so it is hard(er?) to make a mistake with the lack of braces, but in Java the indentation doesn't influence anything here and some programs will silently "work" that shouldn't and no error message will be given. 

Firstly, "sub-string" is different than "word". I think "word" is more appropriate in this situation. (A substring can contain non-alphabetical characters). 

Documentation You should definitely add a docstring. It took me a few seconds to figure out was was going. Make sure to add some examples in the docstring as well. Naming The name may not be the best name. Why? Let's look at the definition of cache: 

naive: 10.82 incremental: 4.74 There are some asserts in the code which all hold and might help you read it. The given benchmark parameters and grid are all typical of my simulation. Background: Imagine a geographical area divided into disjoint regions (cells), where each cell has a base station which provides service for cellphones within its area. Two mobile callers within some distance of each other cannot use the same radio channel, lest their handsets will interfere. When a new caller requests service, we must therefore find the set of channels that are free in the cell of the caller and the neighboring cells within some given distance. We can represent such an area and the channels in use with a boolean 3D matrix where the first two dimensions represent the geographical position (i.e. the cell) and the depth represents the channel. Cell areas often are circular in the real world, and we can approximate them as hexagons instead. Finding the neighbors of a cell we must therefore use the hexagonal distance. Assigning new calls requires to find the channels that are free in the nearby area (eligible channels). However to select channels that will optimize grid usage as a whole, statistics, i.e. the feature representation, are useful. So when an action happens, i.e. a caller terminates a call or a new one requests service, there's a set of legal actions to take depending on the action type ( or ) and the grid. The afterstate is how the grid would look after performing an action, and the feature representation of that afterstate, when compared with the others, informs the decision making. 

I have implemented two genetic operators, which is really just a fancy way of mangling lists. In particular OX-1 (illustration) and displacement mutation. I found it necessary to extract out the randomness from the algorithms in order to do unit testing with some known examples. Is that a decent way to go about it? Any comments on performance, structure, clarify and so forth is appreciated. 

The code below is the core of a Genetic Algorithm (NSGA-II to be precise, without crowding-distance calculation), but I've taken out all the GA-specific parts and made a generic example. I think I've carried over most of the principles/'constraints' from the original algorithm, but I might have missed something. As you can see in , I need to convert a nested list (2-dimensional) to a flat list pretty often and I'm curious of if there are any better ways to do it. I've added some so that it's easier to follow the size and type (nested or flat) of the lists. Since expected size of input is m=100 individuals () for 500 generations (loops), speed is important. Memory usage is not that important (although knowing how to reduce it would be interesting), but execution time is. Any comments performance-related or otherwise are appreciated. 

This algorithm sorts a list of Individuals, each with two fitness values, into what's called non-dominated fronts. A non-dominated front is a set of individuals where none of the individuals dominate each other. An individual is said to dominate another if is equal or lower (<=) for all fitness values and lower (<) in at least one fitness value. And so dominates both and , but neither of the last two dominate each other. The rank of an individual indicates which front it is a member of. would have rank 0; and would both have rank 1. Non-dominant sorting is a small piece in bigger puzzles such as multi-objective optimization with genetic algorithms. If you are interested in how the algorithm works you can check out Jensen 2003, but I'm completely new to Haskell so I'm sure there's a lot to pick on without understanding squat about the actual algorithm. Here it goes: RankSort.hs 

I'm completely new to Javascript and NodeJs and functional programming in general. The code below scrapes a torrent-website containing movies, gets info about the movie from the OMDb API and lets a user choose a movie to watch by streaming the torrent. Any feedback appreciated. 

Short answer Use a state machine. Longer answer I haven't read your code in detail, but I already worked with the Java's non-blocking sockets. So I can say it's pretty difficult to get it right. I once inherited a codebase that was similar to your code. My task was to write unit tests, in order to be close to 100% branches coverage. I tried to write tests without touching the code, but there are so much states to track (the selector, the buffers, the socket's state) that I was not able to reliably test the code. So, I re-wrote the code, using a state-machine to encapsulate these states. I ended up with 7 small classes, each one representing the state of the sockets, or the state of the request processing. The resulting code was more robust (many missing edge-cases became obvious), easier to understand and to maintain. Writing the tests was easier, then. If I had to do it again, I'd try to use Netty (as Ihor suggested). Netty encapsulates the states too, and manages the connection errors in a more unified way. 

And then you can use to find the content of the groups. There is still one thing missing : the fact that the numbering of the original pattern is lost. For that, you can parse the original pattern string to extract those numbers, to create a mapping table. When you convert your pattern string into a Pattern, be careful to escape the substrings between the using . I don't know if this solution would be an improvement of yours, but it's an alternative to consider. Edit The implementation of my solution : 

The biggest subset is (3 4 5 8), and its size is 4. Complexity The sorts can be done with O(n log n) The creation of the third array is O(n²) To find the subset, I think we can do that with O(n²) (I'm not sure about that) So, the whole thing should be O(n²). The algorithm for finding the ascending subsets is not trivial. I'm sure it will be fun to implement ! 

A big performance killer in your code is the use of mode to open the file. The forces every write to be synchronously written on the physical disk. A quick benchmark gives me a 500x speed improvement just by removing the in your code. I did a profiling of your code, and it appears that the majority of the time is spent in the function. This is because internally calls eight times, and each time a physical write is performed ! You should remove this mode and insert flushing instructions at strategic places. I think is the right method for that. Adding this instruction in , and gives me a 12x speed improvement compared to the original code. 

The function is actually a pattern matching function. It just uses a different syntax than the pattern format of . I suggest you to convert your pattern string (the one with signs) into a valid . 

So, you are generating every possible permutations of the array, which is a O(n!) operation. This is huge. I think this can be done with an O(n²) algorithm. I would do : 

You can replace by For the rest of the code, it would help if you explain the algorithm you are implementing, or if you name it (if it's a known hash algorithm) 

What is the purpose of your class ? You are just using its constructor to run some code which is completely unrelated to itself. You are doing the same thing with the two other objects you instanciate : and . When writing a GUI in Swing, you generally write classes that extend , and the constructors contains the code that initialize the inner components. It's a bad idea to let the constructor have a side effect (the display of a frame) like you have. Also, try to follow the Java naming conventions : variables and types names use camel case, and variables start with a lowercase. When initializing a , you might be interrested in calling the method (generally with or )