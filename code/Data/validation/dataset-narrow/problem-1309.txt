You'll likely be using constant acceleration. So no need to worry! The derivative of constant acceleration with respect to time is 0. That means it doesn't change with respect to time, so it doesn't matter what your frame rate is. If you were using variable acceleration you'd set up your equation like: 

I believe the reason this is happening "instantly" is because you seem to be using a while loop inside your update loop. That would cause your characters position to go through the entire jump inside a single frame, meaning it would only be drawn at the end of the jump. Try something like this: 

Then you can generate new faces to cap your object. Select the perimeter of vertices/edges that will make up the cap, these should not have any faces between them. Then press Alt+F. This will generate a new face. Something like this: 

Check out colliders. You'd likely want to implement in your character class. When something collides with the player, this method will be activated. Inside this method is where you'll deduct from the player's health. If the player can only collide with one thing (the sphere objects), you can make it pretty simple: 

Using an object like this makes it reusable for other animations, instead of just being used for the hit animation. Now when you want to change animations, you can easily just set the to whatever animation object you want, and use all the same code for updating the animation. 

Which is likely the header file that has the definition for . Try to just compile the exact code in the tutorial first, then make your changes from there. Recompile/test after each change you make, then you'll know which change broke the code and you won't have to backtrack so much. 

A few years back Morre made a game for Ludum Dare, it meets most of the requirements you asked for. It can be found here: $URL$ I haven't looked at the source code, so I don't know if it's good to follow that structure. However the game play is pretty good and the game is complete (graphics, sound, etc.) If you find it useful you should contact Morre and thank them. Edit Well I had a chance to look through the source code. It's not a code structure I would emulate (for example, the update function is about 550 lines of code, yikes). This is understandable however, since it was created for a competition. I know when I did LD, I didn't worry too much about good looking code. I think you'll still be able to learn some things from it, but it'll be more difficult than a tutorial. 

The z value should be the difference from the camera to the object. For example, with a camera looking "down" the Y axis: 

This will ensure your endpoints are met and allow you to control the randomness to a great degree. For example, I would not randomize roads as much as rivers. Whatever intelligence is building roads typically attempts to be optimal about it. Take care to ensure that if your map has obstacles, you check after each iteration that you're not crossing through those obstacles. Another method would be to generate Perlin noise after finding the optimal path, then shift your points based on the noise generated. For example, using this noise: 

Have you tried the debugger? The code looks like it should work, if the sprite and a block are indeed colliding. Here's what you do, create a sprite and a block at the same position. Have a breakpoint on your statement. When it breaks inspect the elements rectangle values to ensure they do intersect. I imagine that if these are currently intersecting you're just not set up to see the log properly and/or not doing anything with the variable. EDIT According to the documentation you're using the method correctly. One of the few remaining things to check is to ensure that your is actually getting run. What I told you to do with the debugger should help answer that. Otherwise you can stick a inside the loop and ensure that it's actually being run. But I recommend the debugger method, as that's more useful in the long run. 

Hmm, I'm not so sure about rotating the vertices. Perhaps this is not the answer you're looking for, but I can suggest an alternate method. I've done something similar with maps in my game. I wrote a shader to wrap terrain into a sphere, but it can easily be done outside the graphics card too. It's as simple as mapping the Cartesian coordinates to spherical coordinates. The code would look something like: 

Convenient? Unlikely. It may seem like just a file conversion, but it's much more than that. An apk file is an application package designed to run on the Android operating system. An swf file is an animation or applet designed to run in a flash player. They're completely different technologies. Similar to asking if there's a way to convert an .exe to a .swf. One of them is meant to run on an operating system, the other is run in much higher level application. You might think since there are tools to turn swf files into apks that the reverse should be just as simple. It's not. "Converting" a swf into an apk is more like taking a pre-made Android application designed for playing flash content and adding the resources found in a swf file. This type of conversion will have to be done at the source code level, not the packaged file level. It likely means re-writing the source code into a language capable of exporting to swf (likely actionscript). 

Choosing a data structure will depend on what other features you want to support. In this case, you may as well use the ArrayList since it's easier to work with and more flexible. It would be best to just store a reference to the unit in the tile, and have the unit objects stored elsewhere. 

I just write the body and shape values to a file. Then when reading them, I create a new body and shape and set the values to those read from the file. From what I've seen this works great. I haven't seen any strange behaviors or anything like that. Bodies that were flying through the air, continue to do so when the game is reloaded. The values I read/write are: Mass, Friction, LocalInertia, LinearVelocity, AngularVelocity. Acceleration values are stored from other components as I just apply impulses anyway. Saving takes place after a frame step, so there are no existing forces other than gravity. I just take those values and create a new physics object just like I was adding a new one to the DyanmicsWorld. Works well enough for me. Your results may vary if you're using the engine in a more advanced way than I am. 

For those looking for a copy/paste answer, or something a little more code like, here is an implementation for OpenGL. It supports a zoom feature to zoom in/out on the center of the view. I think the variable names are fairly self explanatory. 

I don't remember the specific names of the games, but I know there was one racing game where when you hit something and slowed down, the AI racers were always right behind you to overtake you. No matter how much of a lead you had on them. Don't do it that way. 

This would work just fine for the initial generation of the maps. If the generation algorithm is using a deterministic approach for generating the chunks, you will get the same chunk every time. This means you can't create any random generators on the clients them selves unless you're using the seed from the server as the seed for the random generator. This can be demonstrated in Minecraft with the world generation seeds shared among its users. If someone finds a map they like, they can share the world generation seed with others and Minecraft will generate the exact same map. Obviously you'll need to send the clients any changes that are made after the initial generation. Since those could not be predicted by the generation algorithms. In that case it would be far better to transmit the map instead. You can try to only submit the changes, but it may more complex and could be more time consuming to find what has changed and send the changes than to just send the entire map. 

You want to keep your drawing and update loops separate. Attempting to draw inside the update loop is likely to cause issues. Additionally, putting logic for drawing a game over message inside the update loop of a game character isn't the best place for it. You can try using a global variable for setting when your game is over: 

So, how significant? Very significant. However, I would purpose it's better to finish a single player game than to never finish a multiplayer game. If you have doubts about the added difficulty of completing a game that includes multiplayer, don't include it. You can find a middle ground along the way, by trying not to make architectural decisions that will shoot you in the foot later, if and when you update the game to be multiplayer. 

It's a research task. You need to define your game well enough to assign a genre to it. Then find games in the same genre. Watch play videos, read descriptions, buy and play the games, etc. (Further, you can post about your game online somewhere, and you can be sure that someone will question why you're making a clone of game X.) However, as Code Assassin said, you should just try to make the game you want to make. It doesn't matter what someone else has made. Playtesting your own game should give you ideas on how to improve the features you've implemented. 

So the error message you're receiving is accurate. If you want to draw a filled rectangle, choose the enum type, then use shape rederer to draw a rectangle: 

You can narrow the choices to half by checking if one box is further along an axis than the other. For example, if Box1 is at x=1 and Box2 is at x=5, there's no way that the Xminus side of Box1 could be colliding with the XPlus side of Box2, so you can remove it from the options. I'm not sure exactly what would work, but you could do it something like: 

Sounds more like a you'd want a breadth first search, instead of a depth first like A*, a common one is Dijkstra's algorithm. It is typically used for path finding, but you don't need to have a goal in mind. You can almost use it as is, except you want to limit the depth to the number of moves the player has. A gif from the wikipedia page shows how this fits your situation: 

Yes, A* is still suitable for this. If you don't want your AI to "cut corners" you need modify the navigation mesh to remove corners. You just need to make sure your navigation mesh only has nodes that are a minimum distance from solid objects. These are the steps I would add to your current algorithm: 

Looks like the texture is actually a texture atlas, or tile map. The split method takes one texture and splits it into texture tiles. The image has tiles that are 20 by 20 pixels, passing into splits the image into tiles that are 20 pixels by 20 pixels. So something like 

You'll need to use one of the common node path finders to PathTo() rooms across "the map" Hopefully that's clear enough to get you started on something. 

Where is the magnitude of the vector. I suggest you read up on linear algebra. Wolfire has put together a nice series of blog posts on the topic that should get you up to speed on the basics. 

The size of the screen does not directly dictate the number of pixels. You should be taking screenshots at different resolutions, not different screen sizes. I have a 16 inch screen on my laptop, and a 5 inch screen on my phone, but they both have the same resolution (1920x1080). Use the most common devices to get some average screen resolutions for the different form factors. Then you can produce all the screenshots on a device that has the highest resolution (as long as you can change the resolution of your game to whatever you wish). 

I would make the transition snappy and clear cut. The user needs to know when to use which keys. While I agree it's more natural for to be forward on a side scroller and to be forward in 3rd person follow, transitioning between is not so common, and less intuitive. If when in side scrolling mode there is no use for then I would allow the user to continue to use it for forward, in addition to . Otherwise, you'll need to make it clear that is not moving them forward when in side scrolling mode. The transition between doesn't need to detect camera angle or anything so complex. Surely you have a trigger that makes the camera switch modes from 3rd person to side scroll. Apply the keyboard input changes at the same time the transition is initiated. And always make sure the transition happens at a time when the user doesn't need to be moving forward. If you want to make the change automatically, you can set the change to happen when the camera forward direction and the player forward direction are perpendicular or close to. You can test that by finding the angle between the two. EDIT based on your update. I would not switch the controls at all in this case. If the camera is free flowing between states, it will be difficult and frustrating for the user to keep straight which button to use for going forward. If the transition is not clearly defined by a state machine and you have to derive it based on the camera angle, then the player will also have to derive it. If the transition is not immediately clear and only happens when the user is at a door or some other stopping point, it will be confusing to the player. When it's close to the transition point, the user will have to guess which button to use. Guessing wrong means frustration. Additionally, since they could be holding to move forward, and the camera freely switches to side scroll follow, then they're suddenly moving up and not forward. 

There are many more things to the game that will be taken care of by a game engine than just the management of meshes. Control input, sounds, lighting, GUI, meshes other than the terrain, camera, etc. So the benefit of using an engine comes from all the other features it provides. If you're going to be writing a voxel engine anyway, might as well have everything else taken care of as well. 

However, some customers may be able to set up payment through their mobile carrier and people can put money into their Google Wallet with gift cards purchased in store (or online). 

What is the GLSL required for the last part of the process? It seems like I need to set a attribute pointer to the data somehow, but I'm not sure where to do that when the data is stored in the VBO. 

The easiest way to do this is to keep a copy of the vertices on the CPU-side, and perform the same transformations to your "local" copy. This can usually be done by accumulating the rotations and translations in a transformation matrix, then applying the transformation matrix to each vertex whenever you access them locally. 

The gaps in the octogons make for an unappealing game world. Typically, if you wanted to allow for eight directions of movement, you would just use squares. 

I work in security software for a large company. If I saw an 8-year degree I wouldn't even bother reading the rest of the résumé. Degrees don't teach you how to program, experience does. Make a game. 

Where and are references to the canvas for your pop up element and the text component inside the pop up. 

Yikes. Don't use exception handling as part of the normal flow of code. Exceptions are called exceptions because they're anomalous or exceptional events, they shouldn't be part of the standard flow of things. Simply do a check to see if the tile the character is moving to is going to be outside the bounds of the map. It could be as simple as something like: 

You can always check each face that can collide. Since the bounding boxes are AA, you'll have these collision scenarios: ( indicates collision, X_Plus represents the YZ plane on the X plus side of the box) 

It's just a simple check to make sure everything is in order. Basically it wants to make sure that you created your "map" file properly. You don't really have to throw an exception, you could just ignore the extra characters, but there would probably be more code involved in that. I assume you know what each character represents since you have the rest of the code. 

So unless you're super fast on hitting that ESC key, you're going to trigger this line twice (just twice because after is updated again, no longer gets updated): 

This will then show up in the Inspector as a field where you can select the exit object. This is the most ideal solution if your exit is static and predefined. Or, you can find the exit object in your script start up, with a tag, object name or if has some kind of "exit script":