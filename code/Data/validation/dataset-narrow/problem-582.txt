etc. the class would be in charge of managing the objects. This way I'm not passing around a root to all my functions. For someone who wants to use this tree, I shouldn't need to know about how all these s work. A is an implementation detail of your Make use of , and . Implementing these methods would allow you to compare and display your objects very easily. You could also implement and to compare nodes via rather than (although may not actually be required here) very small stylistic thing here. The code should be (no spaces) according to PEP8 guidelines. Some additional methods you could add 

From your question, it looked like the was some sort of requirement, if that's the case, I would ask whoever set the requirement why! Misc you can re-write as . Similarly for -> Hopefully this review was useful for you, and that you can see the benefits of naming things well and using functions to increase code re usability as well readability on top of reducing code duplication. 

in your constructor, If I make a stack of size 10, I'm actually making one of size 11! You're also accommodating for your +1 size in your constructor with 

Thanks for sharing your code, You should write code to adhere to the PEP8 standard, for the most part you've done that correctly, you have variable and function names, but you've put all your imports on one line. 

again, very similar to , you could even consider making an Abstract Base Class instead of an interface, but let's keep going with this for now. And one more example 

So there's something to do with some sort of iterator, but doesn't tell me a whole lot about it. It's also just giving back Strings. So far everything is dealing with Strings, it becomes hard to keep track of. Instead, to make it more readable and easier to follow, I'd like to see something like this. 

At the moment this code will mutate the existing array, so you may want to create a copy instead. Hopefully you found some of this useful! 

Some changes of note and general advice Added some logic to the Player class where I thought it would be reasonable to do so. These should hopefully make the code more readable too. The return statement in the method when either player dies will exit immediately. Made it so each player has a different random number. Otherwise here the Player would win every time since they hit first. I would recommend making values final if possible. E.g. the userName or the Random object. Don't blindly make getters and setters for everything (this is a commonly encouraged practice especially when you're first learning to code), make getters only if you need to and setters if you really need to mutate the value. Don't make member variables public. This makes it very hard to change your code. Use getters if you need to access the values. small thing here, the line could simply be replaced with A class should be considered a blue print for making an object, not a way of accessing all information about all the objects. Hopefully this review was helpful for you, keep it up! 

Lots of good answers already but I just wanted to add to Josh Dawson's point about not exposing private data members. The only getter that you need to have is One thing to watch out for here, when I think "size" such as list.size(), I think current number of elements, not maximum capacity. Maybe a name such as getCapacity or getMaxSize might be more descriptive. Anybody using the stack shouldn't need to know or care about the variable, it is just an implementation detail. However also acts as a value which represents the number of elements that are in the stack. So I would maybe create a getter not called but maybe or something along those lines. (or if you decided to rename your current one) One pitfall here is that you start top at -1. If you started it at 0 and used top++ instead of ++top it would reliably give back the number of elements without the user needing to know that a value of -1 means "no elements", they would just be left with a 0 instead! Your current method can also break your stack. All it's doing is mutating the variable. It's not actually adjusting the size of the internal array and copying over existing elements (say like an ArrayList does) If you do want to provide a way of expanding the stack, you could implement something similar. The method is also extremely dangerous. Consider the following code 

Implementing adding/removing cards like this severely limits flexibility. At the moment, the only card I can add back to the deck is the last one I took off. But what if I run into this scenario. As a player, I want to take a card off the top of the deck, and replace it with a different card from my hand. This seems like a fairly reasonable thing to want to do, but at the moment, as soon as I draw 2 cards without placing one back, that other card is gone forever as it's no longer the self._draw_from_deck value anymore. What if I had code like this 

There are already some good answers here, but I want to provide another method for reducing some of the duplication in your code, specifically the fact that you have 1 method per player turn. and . As Austin pointed out, these can be turned into just one method and you pass in the player who's turn it is. But you can also remove some of your statements to make it even simpler. your current board is 3 separate rows, , and . If we make this a dict, we can cut out some duplication. 

In the next section you compare them to each other, you could simply then unpack these into variables like 

Code like this could end up corrupting the state of your object. In general I would try to avoid passing references to any objects that are implementation details, and if you have to, clone or copy them as said in the other answers. If you're looking for ways to add new features, you could consider implementing the Iterable interface, so you could iterate through with a for each loop. You could also override the equals and toString methods. 

in 6 lines we have 4 mystery variables. Now, of course I can make a stab at what these are based on context, but I should be able to know what they are from their names! How about this instead: 

Then in the method, the Items from the can be added to the . Similarly to the Chest method, this method 

Thanks for sharing your code, Full disclaimer: I know nothing about NBA, so I'll just be talking about the code itself :) Avoid returning references to mutable objects, here you return the underlying ArrayList objects, this means that the caller can edit these lists and it will (most likely unintentionally) mutate your NbaDraft object. Consider this example 

instead of printing "Stack is Underflow", why not throw a new EmptyStackException(msg). That's what it's for after all. In your push method, you print a message if the stack is full. Again I would suggest throwing an appropriate exception here, or even better, you could resize the array to accommodate the new element. (This would be great practice for making an ArrayList implementation.) What's Missing? Your stack is missing an isEmpty() or empty() method, this should just return true/false for if the stack is empty or not. This is extremely simple to implement so you shouldn't have any problems with this! Your stack is missing a peek() method, this should show the next element, without removing it. Why Stop There? Some other methods you might like to add for practice could be, 

Watch out for using . There are lots of reasons not to use , but the one I want to talk about is that here you're relying on the user to know variable names. Variable names should never matter. But here if you were to change a variable name, your program would not function as intended. If the goal is to call a method on a Rod object based on user input, just do a standard if/elif block 

I would save this as a local variable and use it in both conditions instead I would maybe consider moving the ASCII art to a file, and read in your list of art from there. It takes up a lot of space in your program. And do you even need to use the Counter class in your program? The Counter class is intended for when you want to know the number of occurrences. If all you are doing is comparing a list of 3 values, your roll_dice could return a sorted list and you could compare them directly. 

Another technique that we can use to make code more readable and easier to write (once you get used to it) is by using classes. Consider this partial example of what your code could look like 

Some final points to consider. When you another entity, you could get the currently equipped and the other entity's currently equipped and do some simple math based on their instead of a method, you could just override and then print the directly in the calling code. Before you start coding anything, think about what Objects could be involved in your System/Game in real world terms, then start thinking about how these could be implemented as Objects in your code. Instead of , why not just make a of Weapon objects. Hopefully this review was useful for you. Keep it up! 

(we no longer need a getSongName() method now!) if you had a Map, your selectPlayList would almost be identical. 

So there's not a whole lot of code here, our just makes runes a player through all the levels. It we then just do a short class to tie it all together. 

Now, the code that uses the dict no longer needs to be changed when I add a new Critter. I can simply add a new Critter to the dictionary and nothing else needs to change! You could replace every if/else block that checks a name and calls a corresponding method on an object this way. It's fewer lines of code, and it's also more maintainable. If you think about how you're currently doing it, you have the object, then you take the name from it. Later, you get the name and get the object back. It's a lot of extra overhead that you don't need to do at all! Hopefully this was useful for you. 

This is looking very good for just one week of learning Python, good job! Comments When writing comments, you should aim to document why you're doing something, not what you're doing. Through using clear and meaningful variable and function/method names, it should be obvious what you're doing. The ideal situation is that you don't need any comments at all because your code is self documenting. This isn't always the case however. for example this line 

If you're not used to Java streams this change may look a bit complicated, but really all we're doing here is getting the Stream of the list of employes, filtering out based on the isFree method, and sorting by the getPriority value. So now we've deleted some unneeded methods in the form of addX addY. We're now just handling a single list, not a list of 3 lists. It's open to modification in that we can add any other Employee type in the future and this code will still work! With this new code, this is what your main method can look like. 

} Now I'm sure someone who know a lot more about or could give some basic examples of how to implement those, but lets look at how it could be instantiated. 

It's just as readable (if not more readable) than before! Don't trust anyone In your PlayList class, you provide a getter to a mutable object, in this case a list. If you're providing getters for mutable objects like this, you should provide a defensive copy. To make more robust code, it's better to be less trusting of people using your code (including yourself!) So instead of 

So we've added new functionality to an existing location (we could have just as easily added a new one!) And the class remains unchanged. I've done , this might make more sense as being or Hopefully this review was helpful for you! 

I'm not sure why you do a check for null in some of your add methods. The only time the list can be null is if the caller sets the list to null. If you want the setters, I would maybe throw a when trying to set one of the lists as null. (another danger of providing a setter) I don't think there's a good reason for providing a getter/setter for any of your lists, instead you should provide an and method. If you just do this, your List can never be null, provided to initialise it in the constructor (like you do already). As for your actual question, I think Mibac provided a good alternative, just make a copy constructor instead.