Apply bit mask technique In order to solve time out issue, I had to use bit mask instead of using encoded key by using the above function EncodeKey with the argument HashSet numbers, apply bit mask techniques learned through top coder article called A Bit of Fun: Fun with Bits. The code is much easy to follow after I did draw recursive tree on the test case, and bit mask set operation is also easily to look up through the top coder article. Here is C# code with those two test cases. C# code passes all test cases on Hackerrank. Please help me to be a good tester, a smart problem solver to work on basics first. 

Introduction of algorithm The implementation of the algorithm is to scan the string once from left to right to filter out non-alphanumeric characters first, and then check the string is valid palindrome ignoring cases. The reason I like the implementation is that the code has some simplicity, avoid mixing checking if it is alphanumeric character with two pointers techniques. The C# code passes leetcode online judge. 

First row of table, left = 20001, right = 21024, since Modify API is called and function arguments: start = 0, count = 1024, value = 1, inside Modify API the variable is calculated as 20001 and is calculated as . The two variables of left and right are iterated from beginning to end 10 times, each iteration two variables's values are recorded in the table. And the highlighted color yellow of column marks that the index of will be incremented by value , column marks that of tree will be incremented by value . 

This function should do 1 thing and do it well, not a bunch of them and doing it ok-ish. The already-mentioned readability Variable names should be descriptive. Example of variables you have: 

This could help a lot with any future class change. You repeat 3 times. This shows a little of misuse of the library, and you should be careful with this since it kills performance. Try to save it into a variable or chain it's methods, if possible. You have a "magic" number there! Imagine that now you want to change the width that the class it removed from 990 to, say, 1020. You can argue and say "I just edit it manually, duh!". Now imagine you have 300 lines of code and you don't know where it is and it's previous value. I recommend storing that value in a variable by itself. You can eliminate a lot of bloat by reducing duplicated conditions. You have the following code: 

Still, there is no validation of the data. And there's no way to pick 0.5â‚¬ (50 cents). You should look into that. 

The method name should be . Boolean methods begin with , like if you were asking a question. Since you are 'asking' if a directory has some defined attributes, you should reflect this in your method name. Based on your current name, I wouldn't expect it to return if it had a file there. One example of this is the method . You have another example on the following line: 

This code was written purely for fun, but that's not an excuse to write it poorly. Still, I feel that there's something to improve on it. Besides of any performance issue that there might be, and some readability crimes, what else can I improve in this code? 

I ran the submission again and it works for Leetcode online judge. I also questioned myself about hash function design last year, should I focus on the study of computer science or mathematics, cryptographic hash function? 701 is a prime number. 

Introduction of Algorithm: I am learning the segment tree and also binary index tree this weekend, and I studied binary index tree from the article on hackerearth related to binary index tree and segment tree from the blog algorithm: Ahoy, Pirates, so I decided to take some time to practice the algorithm, spent a few hours to work on the algorithm "Kindergarten Adventures" on Hackerrank university codesprint again. Also, I like to present the idea from Hackerrank editorial notes first, and then share my C# practice code to ask for code review. Editorial notes: If a student asks for a minute extra time, then he can never be happy. We can ignore him. If a student with id asks for a minute extra time, then if we start from id \$a-t\$ (if \$a-t\$ is negative, wrap it around), then he will be happy. Not just that, if we start from any id lower than that he will be happy. So we get a range of students ( the range may wrap around ), from which if we select an id, we are sure to make happy. For each student, we get a range. Now, we have to select an id which is covered by maximum number of range. This can be done using Binary Indexed Tree or Segment Tree. We need to deal with ranges that wrap around. The students are sitting in a circular fashion. Imagine they are sitting linearly like an array from to . Now just append \$1\$ to \$N\$ to the array, so that we have two segments that go from \$1\$ to \$N\$. Now any \$N\$ consecutive elements of the array is a valid ordering of the students. Now work with the second segment of the array. For each position \$N+1 \le i \le N+N\$, if student \$i-N\$ request \$t\$ time, then we need to add \$1\$ to range \$i-N+1\$ to \$i-t+1\$. Next, to find the value of \$X\$, we iterate over \$1\$ to \$N\$ using \$i\$ and select the index for which sum of values at position \$i\$ and \$i+N\$ is maximum. My Implementation of segment tree I documented the step by step how a segment tree is built using the array starting from , and added some notation for each node in the segment tree using array index ID, range of the node is represented and also the value of node in the comment, went through the sample test case . Make sure that every step is making sense and then assume that the learning of segment tree can be accomplished by this simple test case. Most important is to implement the API of Modify and Query using time complexity of , whereas Modify function is the second argument which is the range of interval, Query function is input argument value. Otherwise timeout will be an issue in the problem solving. Test case study I did spend time to learn the algorithm about time complexity. For any N smaller than , I certainly can choose as to analyze. Suppose that there are students in the circle, suppose that the first student only need to minute to finish drawing, so that the first student can complete the drawing for any student chosen by the teacher to start. Related to SegmentTree class Modify API, it has to increase those nodes by value . If the time complexity is linear , and if all students has operation, then there are operations of N2 = , almost million operations, but the time limit is only 3 seconds, so I am pretty sure that the function will cause timeout. So that we have to lower down to intervals to cover the range of using segment tree. To make it simple, we assume that the range's width is instead of , and see how many steps we need to mark in SegmentTree class variable tree[]. We will show only increment operation. Let us get our hands dirty on the calculation of tree.Modify(0,1024,1). We read the code pasted here first. 

And to improve performance, you don't need the . It's a waste of time and CPU power. Also, why instead of ? And why not an array with these objects? I would rewrite the whole thing as this: 

It draws a 1-2 pixels high horizontal line, using the specified color. Some HTML engines and browsers use , others , others simply and others need the tag for coloring. And yes, using actually changes the color on some browsers and engines. Is there any other way to write this, but still keep it as compatible as possible with as many email clients as possible? 

It isn't the prettiest thing on Earth, but may work for you. To call it, you don't have to change anything! Just remove that on . With some bitwise operations, you can cut down this code by a lot! 

What's wrong? The names! implies some actual text, but you have a . is alright, but it is actually . And that is a . I propose the following rewrite: 

Knowing it is a rather large script, I've tried to split it into multiple functions, to make it easier to understand, read and maintain in the future. You can see the complete instruction list on $URL$ As far as I know and tested, this is working as it should. All it's functionalities function as intended and there seem to be no obvious errors. Regarding readability, error handling and readability, is there anything else I can improve? 

As @Dan said, you are re-re-re-re-re-forcing jQuery to painfully look for the header, every time you scroll. Can you imagine how slow that is!? I will take @Dan's suggestion and change it a bit: 

My introduction of algorithm The Gridland Metro is the medium level algorithm in the contest of Hackerrank World CodeSprint 7 in Sept. 2016. I did manage to solve the algorithm in the contest but I spend too many hours, problems are related to runtime error and timeout, the test cases I used in the code does not help to figure out the issue. Since , and are with large value and I did not have good techniques to work on simulation of large test cases, I examined the code and remembered the coding guideline phrase "express the intent", and then change a for loop to one statement to get distinct rows with train tracks first, in the function , first statement:. Today I spent near 2 hours to review the C# algorithm, and put together the readable code, I have to relearn the algorithm and also write code with less smells, with some instructional notes. The code passes all test cases on hackerrank. 

Problem statement You're researching friendships between groups \$n\$ of new college students where each student is distinctly numbered from \$1\$ to \$n\$. At the beginning of the semester, no student knew any other student; instead, they met and formed individual friendships as the semester went on. The friendships between students are: 

I am not sure if variable names can be named better, and 5 arguments in depth first search function can be replaced by better implementation. 

I like to answer my own question after 12 months. My review is to work on a simple algorithm first, at least a medium level to help understand the dynamic programming solution before asking code review. Try to understand the algorithm and how to solve it using dynamic programming solution with time complexity O(N) first. The best way to do it is to work on the problem "Find maximum two disjoint subarray product of sum" first, fully understand the design of dynamic programming solution first using the array's problem. I spent a few hours to think about the algorithm on May 30, 2018 and then I tried to isolate dynamic programming algorithm. The problem "Find maximum two disjoint subarray product of sum" is very close to Leetcode 152 Maximum product subarray. I wrote partial solution and the link is here. After that, the rest problem is to work on how to solve a depth first search algorithm on a tree. The whole algorithm should not be hard to solve anymore. 

This won't be a very in-depth review since I don't know angular.js, and I will focus only on some superficial issues. 

Remove . It's useless there. Change the id to Give the class to the . The is the one that will control the width of your . It makes sense to set it this way. Closing in the same line Since you are using jQuery, later on you may want to use the pseudo-selector , which won't work if you have newlines in it. 

As pointed out before, in a comment, non-magic methods in a class shouldn't be prefixed with . Since they are private, they are prefixed with . 

You don't use the variable anywhere, besides in 1 method a few lines below. Instead of all that, you can chain the methods and spare a dangling reference later on. Something like this: 

Named as , I can access it as , which would execute the PHP code! Also, you even allow names like , which can be used to place executable code somewhere where an attacker can access. This can be solved by using , which returns the filename and extention. This is a tremendous hole! NEVER verify the mimetype. The mimetype is a lie! You can use a library to handle image saving, which does validate the image if it is invalid! One example of a library is WideImage. Here's an example, using WideImage: 

I'll end the Javascript review here, since it is already too lengthy. Notice that I didn't made any attempt on making the changes incremental. I took right from the original code and showed you with the changes. All these changes are left as an exercise to the O.P.. 

Base Case Function FindKthSmallestElement_BinarySearch's two arguments start1 and start2 should apply to multiple statements. Here are details: 

Problem statement: Find \$kth\$ largest element in the union of two sorted array. My introduction of the algorithm I spent a few hours to review two algorithms, Leetcode 4:Median of Two Sorted Arrays and Leetcode 215:Kth Largest Element in an Array together since median is a special case of kth element problem, and also read the article to talk about the kth largest element in the union of two sorted array, 3 solutions: 1:The trivial way, \$O(m+n)\$; 2: A better way, O(k); 3: The best solution, but non-trivial, O(lg m + lg n). So, I decided to practice the algorithm "Find kth largest element in the union of two sorted array" (similar to Leetcode 4 and 215, but with some difference.), using binary search non-trivial one, C# Source code. Please help me to review the code. 

To summarize, to increment nodes value by 1, only need to increment nodes represented in tree variable, the index array is . The design concern The API Modify and Query works together very well with SegmentTree, but however each node in the tree does not explicitly include the range it covers, I need to look into this issue and see if there is a quick fix. I may not fully understand segment tree or binary index tree and have some misunderstanding of segment tree, I like to ask code review. The C# code passes all of hackerrank test cases. 

My introduction of the algorithm The algorithm is a medium level one in the hackerrank contest of week of code 28 from January 9 to 15, 2017. I wrote an algorithm in the contest, and the code has over 300 lines of code, with timeout issue, not efficient. So I learned to use dynamic programming method to solve the algorithm today. I read the editorial notes on hackerrank first, and studied one of submissions, and then built a frequency table for the sample test case to clear my questions from code reading. And then I wrote the algorithm following the ideas showing in the frequency table, using dynamic programming bottom-up method. Hackerrank Editorial Notes In this problem, you are given a sequence of digits of length . You have to find the number of non-contiguous subsequences, such that the number formed by their concatenation is divisible by 8. Observe a bit, The number is formed by concatenating the non-contiguous subsequences, which implies that the number itself is a subsequence and vice-versa. So the problem boils down to counting the ways you can make a subsequence divisible by . This can be done by Dynamic Programming. At any position of the sequence, you need to consider two cases: