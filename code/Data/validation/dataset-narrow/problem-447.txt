Edit: Dunno what PCG is and don't want to read the paper? Maybe this video of Melissa O'Neill (the author) explaining things will be palatable instead. Original: I attempted to answer this question last week and was thrown off when someone mentioned in a comment that my method would show bias. Eager to prove the naysayer wrong I discovered that things were even worse than he suggested as certain ranges will cause things to break down entirely. So I decided to start from scratch, do some more research, and try again. Performance was also much more important to me this time around so I decided to try and find a way to avoid calling to generate every single value. Eventually I settled on PCG as an appropriate modern algorithm. Floating point math has also been entirely avoided while working with integers in order to avoid the sorts of issues I encountered in my previous attempts. Looking for potential ways to speed things up or simplify the code; the branch statements bother me quite a bit but can't envision a better way to include the full range of values without them (the upper bound cannot be generated by the method). Haven't been able to find any bugs so far but that doesn't mean they're not lurking either... 

Regardless of how you do it, at some point in the execution of a method like that, there will be a enumeration. What you can do, is make the method more terse by using a LINQ method: 

Pagination should be done by the database server where applicable. There is really no point pushing data down the wire if it is not being used, so what you should think about doing, is passing in your page number and count variables to the query or preferable a stored procedure, and use SQL to select the subset of data you want. There are SQL constructs in most SQL language variants to do this. Here is an example using MySql: 

That's very neat and tidy code, and it is obvious what it is doing. A pleasure to read. And, since the critters are so cute I was smiling all the way through! Good work. I think you've kind of missed the main point of the exercise though, which is "Create a Critter Farm program by instantiating several Critter objects and keeping track of them through a list." Let's walk through it. Instead of this... 

Which means you don't have to change the code if you add another critter, or rename one, or delete one. Also it is shorter. And the same goes for playing with them, and talking to them. (It's a little bit more tricky to do the same sort of thing when selecting the name of a Critter you want to interact with, but since you seem to be doing so well I think I'll leave it to you to work out how. Drop a reply here if you want some help with that.) I suspect also that you don't actually need separate methods in Critter for, for example, play_one() and play_all() as the only difference is whether the critter responds to you. You could just add a parameter to the call like this ... 

Over the weekend this article inspired me to write an ASCII string implementation that avoids memory allocation during basic operations like and . It's still a work-in-progress but I think this is a solid foundation to build off of and wanted some help checking my logic/maths. The main method of interest is the overload of that accepts an offset and a count since most other methods are implemented by calling it. 

This is my first real adventure in writing a thread-safe class. With the above notes taken into account, did I screw anything up in a way that might violate my thread-safe claim or am I performing any unncessary operations? Code: 

Other comments: 5 - Rename your data context type to something more applicable. I'm sure your app isn't called ? The naming of a type should be relevant, in terms of data contexts, you might want to name it after the database name. 6 - You're not storing the plain text password in the database are you? Only ever store the hash. Importantly the changes above allow you to logically separate out the concerns of the original method, now your validate function should be more streamlined: 

Combining all of this with your original code results in something like the below; there are still some opportunities to improve things even further (for example, code duplication exists in the and methods that might be worth refactoring into a separate method (especially if one were to add more robust logic). 

There are an infinite number of ways to do this but one possible approach would be to use a dedicated hash function to compress your inputs; out of sheer laziness and convenience I chose to use the built-in for my example. To improve the performance characteristics of your code I hoisted the construction of the hashing class up a level and use so that we only have to instantiate it once per call instead of once per string. I then chose to sample the first three bytes of the hash result in order to come up with values for , , and . 

For actual method improvements, you should consider argument validation. What happens if value is ? Your current code will return in a . Behaviourly would it be correct to throw an in this case? Or is the possible value an automatic resultant value of false? You should also consider how your are comparing strings? Should you provide an overload that allows the caller to pass in an appropriate object? Or perhaps specify the ? 

These are small performance improvements, you'll appreciate them more if you are doing a lot of DOM manipulation and lookup. More simplistic applications won't have such an apparent performance improvement. 

There's a small bug in the talking_one() method, as random.randrange(0,5) gives you a number from 0 to 4, and 5 will never happen. I'd suggest using random.choice instead like this: 

and do the same sort of thing when talking with all of them. If you do all of that, your code will be much more concise, and much less dependent on repeating the critter names for everything. One last point. I found myself getting a bit confused over the variable 'fun'. In my head a bigger number for fun suggests there should be more fun, but yours seems to be the other way round. I'd suggest either renaming 'fun' to something like 'boredom' or changing it so bigger numbers = more fun. I know that's a bit tricky given the way it interacts with 'hunger', but a bit more thought about how to represent this would take away what was the only irritant in reading the code. You're making excellent progress here. Keep up the good work. 

2 - Throw an appropriate exception that represents the exceptional state. 3 - Separate out how you are creating your into its own method, so should this need to be changed, it is changed in one place: 

If you I am using a class selector, such as then the selector engine has to do a little more than it needs to. In this example, the selector engine has to walk the entire DOM to match the correct elements. We can improve this a couple of ways: 

... and the reason you should be doing that is it makes a lot of other things much easier. For example, this ... 

I'll second what Phrancis said about separating out the text descriptions into some sort of file structure. But you'll find it rapidly gets a lot more complicated than that (I know, I tried this same thing years ago). Consider, for example, what happens to the descriptions and available actions if you take that magnesium flare out of the bag and set light to it and then carry the bag to a different place. It's a huge task you've set yourself. I suggest you take a look at Graham Nelson's Inform, which is a language specifically designed for text adventures - as it comes with some really good thorough documentation about the ins and outs of writing text adventures. If you want to get a bit further under the hood, the previous version (Inform 6) is still around somewhere, and there is also a Z-machine interpreter in Java at Sourceforge which does almost exactly the sort of thing you are starting out on. I know this isn't quite in the spirit of a Code Review answer, but it will probably get you started in the right direction quicker than more specific comments will. Even if all you do is sketch out the beginning part of your adventure in Inform, you'll then have something of substance to translate back into Java. EDIT: Here's one thing I just remembered that helped me enormously. Maybe try mapping out something familiar (I did my house and family as a little text adventure) to get the code working and tidy. I found that way I wasn't distracted from the coding task by thinking what I wanted to happen next in the story. 

Along with @kingjv's suggestions, you can improve the performance of your jQuery selections by making some simply tweaks to the selectors. Consider if I have the following html: 

4 - User compiled queries where possible. If you know you might be performing a query multiple times, there is little sense in having the query provider generate the sql each time, you might as well take advantage of the type: 

I know there are already many responses to this question, but here are a few other tweaks: 1 - Refactor the method to return a boolean result.. the method shouldn't really care about how you report errors, it should care about returning a simple result... , the password's match, , they don't: