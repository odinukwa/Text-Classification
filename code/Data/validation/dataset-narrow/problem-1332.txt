takes your vertices and indices from RAM, sends them to buffers on the GPU, then draws them. That means the data is sent to the gpu every time you call this function. requires you to create and set both a vertex and index buffer before calling it, and the data will stay on the gpu until those buffers are disposed. (See MSDN's example.) So the latter takes a few extra lines to get working, but will perform at least as well as the former in every situation I can think of, and a lot better in most situations. This is true even if the vertex data changes every frame, because of dynamic buffers. If you're only going to draw something once, then the User function is just easier to use. Otherwise, I would avoid it. 

Finally, to get that gap between the tetrahedrons, just move all four vertices a small amount in the direction of vUp. 

Three vertices are easy. Just place them in the same location as the three vertices of the clicked face. For the rest of this answer, we'll call these vertices v1, v2, and v3. To position the 4th vertex, first take the cross product of v1 → v2 and v1→ v3. (If this returns a vector pointing backward, just swap v2 and v3.) 

If the player is afk and the phone goes to sleep, there is no reason to keep him connected at all. Maintaining a connection will drain the player's battery and place additional stress on your servers, both for no benefit, since the player isn't using the game anyway. This means higher costs for you and (potentially) negative reviews for your game. Instead, you should just drop the connection when the phone goes to sleep and attempt to reconnect when the phone wakes up. If you don't want to disconnect a user without him willing it to happen, you can set FLAG_KEEP_SCREEN_ON. This will keep the phone awake as long as the app is in focus while also shouting to the user, "Hey, I'm eating your battery! You should turn me off if you're really not playing anymore!" 

It should be either from the image file itself, or from a shader which rejects all perfectly white pixels, or something like that, but since the shader isn't the simplest thing to implement, I'll bet it's the image file. I'll also bet you made or found this image with a white background, then tried to delete that white to make the background transparent. Unfortunately you deleted the pixels that are perfectly white, but the edge isn't perfectly sharp, and you missed some partially white pixels. Those are the more certain bets I can make. Now I'll make another less certain bet: that you're using GIMP. If you're not, maybe you can adapt the instructions for another program. You want to experiment with the tolerance on the selection wand, as well as selection feathering, and the color erase mode of the fill tool. Find whatever works best. Maybe take your current image with the transparent background, do alpha to selection, shrink selection by 1px, invert, then color erase white. 

The trick is the fragment shader runs on every fragment in whatever you're drawing, and choosing a single texel to manipulate is generally unreasonable. If that's what you want to do, I recommend doing so outside of the shader, perhaps with glTexSubImage2D. 

The term you're looking for is Frustum Culling. The problem is this doesn't work too well on individual vertices, because a vertex may be required for a face that is inside the frustum even if the vertex itself isn't. It would be too slow to do that every frame anyway. If neither the mesh or cameras move, or they move predictably so you can precalculate everything, you can probably do the culling per-face. But then I'm not sure why you wouldn't just make renders of the thing in some 3D modelling software. So if you really need culling in real-time, I recommend splitting the mesh into multiple parts that can be culled individually. Other than that, this link can get you started, and Google should help with the rest, now that you know what it's called. 

The hotspot parameters represent the "tip" of the cursor. For example, the operating system cursor has the hotspot at the top-left corner, but a crosshair cursor might have the hotspot at its center. 

Until OpenGL 3.0, each version of OpenGL was a direct superset of the previous one, so as long as a graphics card and its drivers support the functions you use, you don't have to worry about compatibility. Also, until 3.0 was released, there was no way to choose an OpenGL version because if you got a newer version than you wanted, you just got functionality you didn't use. You were just given whatever version your driver supported, and there was nothing lost. So to answer your question, if your graphics card and drivers support OpenGL 2.0 functions and shaders, you can use them without worrying about any code that was designed for 1.1. Now when OpenGL 3.0 was released, some functions were marked deprecated, and a mechanism to choose your OpenGL version was added. Then beginning with 3.1 some functions were removed. But many people were in situations like yours and still wanted the old functions, so beginning with 3.2 a compatibility profile was added with its own, separate specification. So once you start upgrading past v3.0, then you have to worry about compatibility a little. In that case, I recommend looking at the specification for the specific version and profile you want to use. It will tell you what should be supported. 

According to the reference page for GraphicsDevice.DrawPrimitives(), it can throw one of two exceptions - ArgumentOutOfRangeException and InvalidOperationException - and only the former has anything to do with . When you say the error only says "primitiveCount", that's must be the exception's description, while the type is ArgumentOutOfRangeException. In other words, you're passing a number less than or equal to 0 as the third parameter, which means is less than or equal to 2 (probably 0), which means that .obj file with 417936 vertices probably didn't get loaded properly. Either the .obj file is corrupt, your loader doesn't support something in the file, or there's another possible exception that's not listed in the reference. I'll put my money on the broken loader.