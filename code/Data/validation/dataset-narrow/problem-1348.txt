I have two points A and B. I want to perform a smooth deceleration from A stopping at B over time t. The only thing I managed to do so far was a lerp, which isn't right of course because it's unnatural. I also tried multiplying the velocity by some factor (0.9 or similar), but then I don't know how to choose the factor such that the end point B is reached (or as near to it as some epsilon value seems reasonable). Does anyone have something relatively simple that I could use? I can read C++ and C# code. 

I tried an implementation of glFrustum (no longer available as I'm using core profile of course) as follows: 

I thought there might be something screwy with my texture coordinates too, so I hard coded them to be 0.0, 0.0 on the left and 2.0, 2.0 bottom right. I expected x 2 repeat but got a similar result to the screenshot, with the texture top left and then what looks like clamp across the rest of the image. What mistake have I made here? (Note that the screenshot isn't the 0.0, 0.0 -> 2.0, 2.0 experiment I did, it's the general case I get as I'm panning my image around). 

I want to auto-bind uniform blocks with certain named values to certain binding points when I compile a shader. For example, I have some basic, default fixed binding points that are always used for certain things like: 

But, alas I'm not sure what parameters I need to use for left, top, right and bottom when iterating across the scene, viewport or screen. Can anyone assist me? Edit: I found this example (unfortunately D3D) of someone doing something similar. The author seems to be just multiplying _11 and _22 by the width (scale up) and then modifying _31 and _32 according to the current tile position - iterating through the whole grid. I did try this but I got a black screen of doom. 

I'm trying to figure out how to perform tiled rendering of my 3d scene (OpenGL). The motivation is to cut the scene up into several textures, combining them into a single image for saving at a very high resolution, or for printing. I've done some reading on this and apparently I just need to put appropriate parameters into my projection matrix for each tile in the scene. This is where I'm failing (miserably). I can't see where or what to use for it. My perspective projection matrix is pretty standard, like this: 

The keyword you're looking for is "easing". There are lots of different easing functions that behave and look different but all of them interpolate some variable from A to B given a time T. If your ship is at A and you want it to decelerate until it hits B, you can give it a velocity by, for example, applying this function: 

Shimmering I understand shimmering in textures is caused by sub-pixel accuracy aliasing against the regular grid of pixels on the screen when drawn. I have a good example of it here, whereby I'm attempting to scroll/pan a 2d texture by modifying the texture coordinates rather than by moving some actual geometry. The texture is "wrapped" and my idea was to fill in the bit falling off the left (or right), filling it in on the other side, to effect a single scrolling/panning surface of (almost) infinite size. Unfortunately with random noise on the texture, when I'm zoomed all the way out the shimmering is kind-of horrific. When I zoom in a bit it seems OK, which is kind-of confusing to me. But anyway, is there a filter of some kind I can put into my shader to prevent this shimmering? I'm at something of a loss here. (To complicate matters my texture is actually just L16 luminance and I'm palettising it in the shader - the L16 is sampled with LINEAR, the palette texture is POINT, though I'm pretty sure this makes little difference to the shimmering). Please note that with the video, YouTube has done its absolute best to remove any detail from it, meaning it's difficult to see the shimmer under the encoding artifacts. 

OK, I fixed the problem by implementing a different way of doing it I found here. I've made this a bit quicker by doing the set-up of the incremental Gaussian in the vertex shader and passing that into the pixel shader (no point in doing it in the pixel shader when it's not dependent on anything else). It still shimmers, but it's no way near as bad as it was before. Not sure why (!). Also it's a bit quicker with the incremental, rather than the full evaluation per-pixel. 

Edit: I found the queue. And it is as I suspected. My Xbox hasn't recognized the download yet, but I think I already have the XNA Game Studio Connect app on my Xbox, so I'm not sure if it will ever (re-)download. 

Someone else with more knowledge of the subject should write a more thorough answer, but in an attempt to give you an answer (since nobody else has)... You should start by implementing pixelwise collision detection, or triangles (mesh collision) if they approximate your terrain well enough. Then, in order to accurately place your character's feet on the ground, perhaps rig your sprite with virtual bones. They could be controlled by a physics engine for best-looking results. Or, if you go the triangles way, you could also have a triangle collision mesh for your sprite, and borrow some of the techniques usually used in 3D games in order to calculate the best angle/distortion of the collision mesh onto the terrain. 

Club Penguin is an example of a MMO in Flash (wikipedia), as is DOFUS which bearcdp already mentioned (wikipedia). Adventure Quest Worlds is yet another one (wikipedia). You'll notice similar qualities in each of these games (as far as I know, from my limited experience in them): there are no "twitch" actions, combat is usually slow real-time or turn-based, and they're 2D or 2.5D. These are all artifacts of the Flash technology - it would be difficult to make a really real-time MMO or a 3D game with Flash (though this may be changing; I know recently Flash has been making headway in the 3D graphics space). If Flash/Actionscript is what you know best and the above games are the kind of quality you would want to aim for, then by all means, clearly Flash is a capable technology for multiplayer games. There's certainly nothing wrong with innovation; if you were to utilize Adobe's latest 3D technologies to make a 3D MMO in Flash, you would apparently be the first and it could mean extra publicity, along with the perks of having a game that works in the browser. But if you are just surveying technologies, then weigh your other options against this; if you specifically want a browser MMO, also consider HTML5/WebGL/WebSocket and Java (we have a good number of questions about these two technologies on the site). 

In your particular example, typically one system is more "important" than the other, or somehow the relationship is not exactly symmetric (one relies on the other more), and that's the opportunity to do something like the following: 

I am in favor of KISS: "Keep It Simple, Stupid!" I see no reason why a cron job wouldn't work, and the upside is that cheap web hosting options often don't let you directly run commands, but they do allow you to run cron commands. So there's no need for an expensive dedicated server. You can also do your update code in PHP or your language of preference, by having the cron command either or use the text browser. The instructions at Configuring cron jobs have several example commands which you could use to ping your own page at an interval. 

Essentially, all the files at JogAmp can be found at $URL$ The latest build can be found at $URL$ I can't attest to its stability, so I don't know if it is a "latest stable" build or not, but I think it is. There's not a clear definition of what they mean when they suffix something with "-next". You can browse around other builds by just exploring the folders at $URL$ 

Your need for it to run fast and have high compatibility point to writing it in regular HTML and avoiding the likes of Flash and Java (applets) for this. If you haven't written any HTML before, you're in for a long road and yes you will need to utilize a variety of languages (HTML, JavaScript, CSS). If you have the server hosting, I recently found Socket.IO which I think is really neat - it will facilitate true real-time communication between the browser and your server. Otherwise, if you want to only use your web server, then you'd need to write a system probably based on polling, and the backend would most likely be PHP pages. It wouldn't be true real time but it could be close enough. It's interesting you mention real money upfront though. That seems to raise the stakes a lot. You will then need to deal with APIs of your virtual money systems (Google Checkout, etc.), make sure your system is airtight from hackers and scams and such, design your game in such a way that seems fair to the players, eliminate cheating in every way possible... It complicates the whole thing, honestly, and I think it's much too early to rush into something with no knowledge with a goal of making money. But if you're determined, I can only stand aside and wish you the best of luck in your adventure.