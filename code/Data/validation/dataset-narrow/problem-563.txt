Is it worth it, or over-engineered? This is subjective and a matter of taste. Some find verbosity more readable, others prefer terseness/expressiveness. I would let both solutions slide in a peer review, although creating a single-use extension method () looks like a minor code smell. Another way to avoid repetitive overwriting of , which you're uncomfortable with, would be to introduce temporary variables: 

Prefixing a string with an empty string makes no sense. (I know what trick you're employing, but "/" does that for you already). 

It's simplier. Alternatively you could use a regex pattern and get rid of all the injection chars in one go (with ) rather than one by one. I'm not too fond of the name - it's actually filtering the injection characters out. Personally I'd rename it to - somewhat clearer to me - or perhaps just , which is a widely recognized synonym for this operation. 

This being said, it could be overengineering for simple cases. It's hard to say without knowing broader context. All info you've provided is that there's 5 cases, which is quite a few already, and it makes me guess there's a chance for more to come; if all I knew was that there's 2 or 3, I would say keep it simple. 

No. ViewModel - as the name itself indicates - should only model the view. Business logic, such as validating a certificate, should be extracted to another class (a service), adhering to the Single Responsibility Principle. This includes handling any errors that occur. Extract elsewhere. 

This is nitpicky now, but I would change the order of these assignments. Because If throws an exception, the object will be left in inconsistent state. Again this is a consideration for easier debugging. 

But I know that a constructor initializes a new instance of a class. This is true for C# in general, and it's in no way specific to this class. It may be a useful piece of info if I didn't know that sitting down to read this code, but it means these documentation comments become a C# tutorial for beginners now, which isn't their purpose. Or: 

Looking for an element and finding out that it's NOT present in the collection IS a successful operation. Just because an operation renderered a negative answer doesn't mean it failed. The purpose was to find this answer, and this we did. Encapsulation I don't like that is public. Wouldn't a more restrictive visibility modifier do? Rendundancies As I pointed out before, after a is always redundant. 

I'm not sure about this condition. There are other states where connection state isn't Open, and yet it should still be closed - see $URL$ I would err on the safe side and try to close it anyway. You could test it, but I don't think anything bad's going to happen if it's closed already. Or you could make it instead. Since there are other possibilities (, , , ), this is not the same thing. 

And that's it, job done. As I said, this solution may not be applicable in your case - I have no way of knowing. 

Both approaches are acceptable, but the one using a feels cleaner to me, and brings some advantages at no significant cost. 

Not always. It can also return an error. Exposing crucial request settings as public properties (rather than eg. method or constructor parameters) is questionable too, in my opinion. It doesn't enforce calling code to supply the necessary minimum of information required for the request to succeed. So it's not a particularly friendly API, if I the burden of remembering which properties need to be set is still on me. Your method doesn't even validate it explicitly - eg. if is not set, I'll just get an exception from complaining about the lack of , and you're leaving it up to me to figure out that it translates to the not being set. Same with . Such mutability also introduces an inherent lack of thread safety - what if someone changes one of these properties (from another thread) while is being executed and is half-way through? We don't always need thread safety, but it's one thing not to implement it at all, sort of ignoring the issue altogether, and another: to throw it out of the window by design, for no good reason. Other things being equal, I'd say prefer stateless/immutable objects to stateful/mutable ones. Naming: if the class is named already, there's little point in naming all its properties , , etc. (with curious omission of - why not , then?). It's known as Smurf naming convention anti-pattern. 

It's obvious that it's a class - which implements/represents this, that or the other... and it's obvious that the comment refers to this class, not some other one a mile away. This is just fluff. (I know there are APIs in Java that do the same thing - in my opinion it's not something worth mimicking). 

We're not overwriting now, but when I look at it, I feel it sacrificed too much readability just for that, and what's worse, it got error-prone in process: you now have to remember to always use the last variable so as not to skip a step. If another parameter was to be added, there's a risk of a bug slipping in: 

Do you plan to extend this class? If not, I would mark it as . Given its nature, inheritance can open a Pandora box. 

For starters, I feel inclined to go meta and question the design. One possible shortcoming of your method is that it falls back to the default value, which - for primitives - isn't null. So "blah blah" would evaluate to or , and unlike , your method won't tell me if this result actually came from the input, or whether it only reflects the inability to convert it. This could lead to issues with invalid data getting swept under the rug, and as such it's sort of buggy by design (especially when handling dates). The biggest no-no though is that you're not handling exceptions. That's quite a leap of faith when invoking a method by reflection, especially as it's only loosely identified by its signature. I wouldn't blindly trust the return type, or that the method we happened to find actually does what we hope it does. Given that the name of the method promises to fall back to default if parsing is impossible, I would say not handling an exception breaks the principle of least surprise here. 

Having said all that, I have to say this code is quite decent and promising for someone who have only been programming for a few months. There are slip-ups, but it shows you have good capability in structuring abstract concepts, and that's the core skill in programming. 

PS. Note that in C# lower-case names should be used for parameters and variables - so it would be , , etc. And I believe you don't really need . 

Agreed again. I would extract the inner part of the loop in (). Whenever there's a loop wrapped around a large block of code, it smells of violation of Single Responsibility Principle to me. Because iterating through entities seems to be sort of a responsibility in its own right, separate from doing whatever the body of the loop is doing with them. Also the code that handles in both these methods is repetitive and could be encapsulated in a separate, parameterized method. 

for reasons that I hope you can see. is always initialized to the same value (). You could use a field initializer instead, and get rid of the parameterless constructor. Same effect, less lines of code. When there is no ambiguity (like a parameter named the same as a field), and there isn't any in this code, you don't need to refer to fields by , as in . Especially since you're not consistent about it and this code sometimes does it, and sometimes not. Consistency is a highly valuable trait when it comes to code. Other concerns 

By convention, names of methods in Java should start with lower-case (so, and - just like and ). Parameter names shouldn't start with "m". There is a - controversial - naming convention that prefixes class members (or fields) with "m". I personally think it's iffy, but some people do that. This convention at least has some logic behind it though, whereas prefixing a parameter with "m" makes no sense. As of now you can pass any class to this method, which isn't as type safe as it could be. If you made it generic, you could narrow it down to subclasses, making it more typesafe: 

Some test frameworks require all test methods to be prefixed with "test", but when it's not required (and the presence of attributes clearly shows that it's not handled by reflection), there's no point in doing this. It restates the obvious, serving no other purpose than to add noise. 

This bit repeats several times. I would encapsulate it as a private method (?) to avoid code repetition. And as a side note, I don't really see any purpose in , it's just clutter. Clear the collection anyway (even if it's empty), I wouldn't expect much of a performance boost from this check :) Benchmarking This is weird to me. You're setting in : 

It's a matter of taste, but here I would ditch the "Method" suffix, as these aren't necessarily "methods". Note that you didn't name the class . Why not just and ? 

By convention, parameter names in C# should begin with a lowercase character. Name of the method is unclear to me, as it doesn't seem to actually "filter" anything. It performs more than one responsibility: asserting whether the code is valid, and providing a default, fallback value if it isn't. I'd move the "lg-3023-1335..." out of it, possibly passing it in as a parameter (, or ) 

This name is off as well, it doesn't check whether the input string is alphanumeric, it tests whether it only contains '-', '.', ' ', 'Ã', '©', '¡', '­', 'º', '³', 'Ã', '‰' or '_'. Do we need case insensitivity here, but not in ? Or is this discrepancy accidental? If it's not deliberate, then I'd implement case insensitivity in directly, and get rid of . Inconsistent parameter naming - other methods accept , but this one takes an . I'd drop the "str" suffix - it's pretty clear this is a string value, no need to revive the infamous Hungarian notation. Finally, there's some code repetition here - this bit: 

Beware of a lesser known gotcha. This may not work as expected for that's not "really" a (it's not in s inheritance tree), only has an explicit cast operator defined allowing it to be casted to . In that case while would return a instance, won't even be called because your check would prevent this from happening. Other than that, I'd have some remarks related to naming and code style (rather subjective, so treat them as suggestions or food for thought more than claims your code is incorrect) 

Naming Unlike in Java, constants in C# aren't normally named with all caps and underscores (). Methods names shouldn't be lower-case (). Names such as are way too long, and they don't describe the method well. A method should be named for what it does, not when or why it does that. A method doesn't know who calls it and in what scenario or context it happens. That's not its responsibility. A method knows what it does itself. The calling code knows when and why to use it. That's how responsibility is dealt. A pickaxe doesn't need to know it's in a coal mine. When a method's name starts with "if", it's already very suspicious. Structure is a class field, and yet methods are passing it to eachother as a parameter. This is confusing: every method has access to all class members by itself, they don't need to piggyback on other methods for that purpose. Redundant clauses 

Ad 1. Yes, it's reasonable to refactor it the way you did. It's consistent with Single Responsibility Principle, and as such it makes it easy to eg. add some new formats without having to meddle with the base routine. Ad 2. It's questionable in some places. a) No exception handling. You may prefer it to be caller's responsibility, but at the very least you should ensure that the file stream always gets closed, even if an exception is thrown (with a or ). b) The names and its derivatives are misleading. It's a ( etc.). It's obvious that it doesn't represent a file itself, it represents a way of dealing with a file whose contents are passed from outside. Ad 3. Your new implementation lacks the part that associated appropriate file processing method with a given . This could be implemented with a class taking a instance and returning an instance. Calling code doesn't need to know whether it's etc., that's the point: such nuts and bolts are something left for the factory to worry about, and caller is only concerned whether the factory returns something that matches the interface. EDIT: Here's a suggested improvement.