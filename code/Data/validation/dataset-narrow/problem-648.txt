There are many problems with your code, as others have indicated. However, my guess is that you used features which the person reviewing your code was not familiar with. Quite often the person who determines if you are hired is not an active developer, but a development manager who used to be an active developer. They are less likely to keep up to speed with the latest features of the language. Showing you are using them to solve a problem will make your code look worse to this ex-developer; they will probably feel ego-challenged (I don't understand this, I am smart, thus this is bad code) by not understanding what your code does or how it solves a problem. In this case they are right; the code demonstrated is showing off your knowledge of Java features (which could be quite useful in more complex problems) which are not appropriate for this simple task. The parts that are not showing off are not well done; copy-pasta, hard coded constants, brittle tests, undiciplined library use, etc. (Other answers cover this better than I) Finally, apparently your code fails to compile in some "modern" compilers; that could have eliminated you before they even looked at your code! So if someone doesn't understand those features, the code looks like noise and is ego-bruising. If someone does, they'll say "ok", then look at the rest. More likely, they where looking for someone with the minimium competence that would solve their problem: if they are hiring someone to write Java to move controls around in a UI, they don't want someone who likes playing with Java8. Or they found a candiate already. Or they changed their mind about hiring because they got distracted. Or you where judged acceptable at Java, but you didn't list SQL on your resume, and there was another candidate who did and was also marked as acceptable in Java, and the HR noticed that SQL was required and elminated your resume from the pool. Or the application process was a fake, and they where just gathering FizzBuzz implementations to feed to a FizzBuzz plagarism detector. Or they where gathering FizzBuzz implementations that could avoid Fizzbuzz plagarism detectors to game some other application process. Or they are someone who gathers resumes and code in order to have a stable of people, then they find contracts and try to become middlemen; if they don't get the contracts, they discard the applicants and repeat. Quite often things happen that have nothing to do with your performance, and feedback is not provided that it was nothing to do with you. Or, it is something to do with you, and they lie and say it wasn't. In the future, the thing to keep in mind with FizzBuzz style tests is that they are looking to check if you can program at all. They aren't asking you to show off. The goal of the test is "can you write a simple solution to a simple problem", and to filter out people who cannot program at all. Make your code simple, non-challenging. Try to follow "best practices" in the most conservative way. 

(The meat of the extension methods can surely be done more sophisticated than the above.) is an with a rudimentary definition like: 

When testing the algorithm against other implementations it seems to work as expected and without a thorough knowledge about calendars it is hard to comment on the details of the algorithm as is. From a computational or mathematical point of view it is possible to simplify or make the formulas a little clearer by removing unnecessary parenthesis and just rely on operator precedence: 

The first thing I notice is the somewhat misleading method name . I would call it , because it only checks if i is a factor of number - not if it is a prime factor. 

First of all I'll upvote the question for the effort. You split the problem into subproblems and you show good understanding of C# idiomatic as well as general programming skills. On the other hand I think you overcomplicate the solution, because your general analysis of the problem is a little too "chessish". Instead I would try with some kind of "mathematical" model: 

However none of the solutions are very performant if diamond size is increased (> 2000) due to the concatenation of strings. In that respect a good old iterative solution is preferable: 

Beside that, I think your naming is quite remarkable and rather hard to read because of the length: For instance it's hard to quickly distinguish between: 

From this mathematical model and analysis it is very simple to calculate the result. Some comments on the code: 

Singleton 1) It is fine to have the static context object as private and the static Method Context. But a pure singleton class should hide the contructor(s) as private in order to prevent undesired instantiation: 

It's hard to comment on it. It seems OK to me - maybe a little to much list manipulation. I'm not sure if string concat with + is acceptable practice in F# but in general it's not. For fun I've tried with my own version with use of recursion: 

Beside that I would change the flag to an too, because you can then distinguish between more levels like: 

In this way the first permutation is returned as soon as it has been computed and everything is running more smoothly. 

I assume that does not return a possible duplicate url-friendly title or else you maybe are positively redirecting to "Index" having a duplicate url-friendly title set on the model because is not checked for duplication before returning. 

It is IMO easier to understand because the index is incremented in a more "natural" place, and the Write...() functions knows where they are. If you insists on _index as a class field, you could do it like this: 

but the as you can see, this gets rid of lots of brevity. On the other hand, this continues to be data-driven: having uniform code behavior, controlled by data, is often a boon to debugging. You can validate data easier than you can validate code! Less effort was put into optimizing the C++03 version than the C++11 version, but the hit may be minimal. 

now, the above doesn't have diagnostics in it. But I hope you get the idea -- don't use a class when a function will do. I might make a a pair of tests and error message s even, with the error message optional. This would give you diagnostics as well. Or the return value could be a pair of , where a true bool means "passed with a possible warning", and false means "failed with a descriptive error". But you might not want to go this far. :) ... If you lack C++11, this is a patch on the above: 

I would add rvalue reference support with moving of temporaries. seems to be too low precidence to be practical - you end up having to everything (as demonstrated above). % at least binds tightly. I do like . Better than my . Forwarding from the operator to the function lets you forget the function behind the operator entirely: -- very Haskell. N ary infix operators that defer application of allow to run as efficiently as possible. But doing that cleanly might be hard. Not sure what is intended to do above. For an interesting test case, implement (where that lambda is a placeholder for a functor) Block some copy and move ctors to prevent persistance, and friend the approriate operators. As noted, I allowed arbitrary binary operators (chosen when you ) to bracket the named operator: the precidence of the resulting named operator exactly matches the bracketing operators. So has precidence of and has precidence of . Of the 3 first use cases (lin alg, container append, then) for two of them the named operators where variants of existing operators, and matching their precidence seemed useful. 

I would get rid of the if-else statement in operator() of Rule, and replace it with a stored functor, or move the from operator() of Rule into StartsWith and make all of your checkers have the same signature. Suppose we go with moving into StartsWith. Then stores a , which you produce once at construction (possibly through a big if-else block, but you only run that block once). Then operator() on just calls that check on the input parameter. If I was to go further, I'd work on rule-factories. A rule-factory is a function that takes a MyVariant and produces a . Then register a rule factory for each enum entry. And now your class itself goes away -- a is just any that takes a and returns true or false. The end syntax looks like: 

If I remember correctly it should contain "forward-decl" of . These are only used by the implementation: 

have inconsistent bound checking, which may cause confusion when quickly screening the code, i.e., you need to mentally switch between and , which consumes your "brain cycles". :) [added 23.04.2018, 16:36] IMHO, the preferred way would be: 

I would (incorrectly) think that it decreases some integer named by . To "decipher" it you need to find what is and the go to its implementation to figure out how is overloaded. (Remember, as I said, it could, for example, remove the 7th column, there's nothing specific about rows in a real table. ;)) Compare this with: 

Don't use -- in most cases it only clutters the code. I prefer to have some distinction between the c-tor parameter and the class' field, so I use "naming convention": becomes in a c-tor. Using prevents compiler from copying every column. 

You won't need to change your docs, when parameter name will change. Also, I don't know why people use this comment style: 

Does it really need to be ? How many rows do you need? Is it stable? Is it robust? is guaranteed to be at least 16 bits long. I would use: 

Eclipse can add this automatically. And this is also something that is useful, e.g., when your GPL-licensed code will be copy-and-pasted in some other project. If so, you'll be famous, which is what programming is about anyway. :) Headers Someone else pointed it out in the first part. But... Do you need all of: 

Having braces around the "one-liners" eases adding new code and reduces the frustration related to adding the braces after. No more "I should've added them at the first place". ;) Field visibility These: 

Do you want to pollute the global namespace with this operator? Is a part of the ConsoleTable interface? Instead do this (I avoided the "try" word on purpose): 

I also prefer to copy all includes from the header file to the implementation file. The rationale behind this is that it ensures that when interface change is made, it will not impact the implementation file. And you get the implicit-include problem solved at no cost. But I can't guarantee it is how the C++ code is written nowadays. Interface Does it really belong to the interface? 

In such a case it should be 32 bits wide. Documentation Parameter name is duplicated in the function doc. Instead of: 

(Side note: I prefer to have modifier after the type, this frees your brain from remembering how to read such things: .) Also try to have variable in capitals, and maybe name is more descriptive. If something does not change, it does not change. Instead of: