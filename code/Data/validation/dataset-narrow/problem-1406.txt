Unless you are actually playing with the Depth, you should be using . MSDN Doc Here If you are drawing everything at Depth 0, I'm pretty sure that XNA will pick a draw order for you. There are others discussing a similar issue here: $URL$ In 3D, this is usually called Z-fighting. 

The way I've always done it is to have each object draw themselves. It keeps everything in one place, you don't need to open up the internals for someone else to draw you, and therefore can increase encapsulation. This also allows you override the draw method to do something special in derived classes. 

In your library however, it doesn't seem to check if if the rectangles it's returning intersect with the query, so you'll need to add that yourself. 

I develop a pair of projects for animating sprites in a data-driven way. There's a sprite maker (not recommended), and a sprite library for XNA that I think works quite well. Here's a copy of some of the documentation. The high-level concept is quite portable: 

Do I have to say that I'm not a lawyer? I'm not a lawyer. In some/most countries, you can use a pseudonym of your choosing called a Trade Name. You just can't use "Incorporated", "Limited" or any other legal label in the name though. This type of business is called a Sole Proprietorship, and I would highly recommend it because it's easy to create (you already have), dissolve (any time), and do any taxes for (It's just personal taxes, nothing special). At any time, you can Incorporate a business by paying a bunch of money to the government and paying someone to handle the complicated taxes, but unless you're making a lot of money or have multiple employees, I'd stick with the Sole Proprietorship. I'm a sole proprietor in Canada and work under the legal name "John McDonald Consulting". Since I charge my customers GST, I have to have a GST number registered with the government where I pay them the GST that I collect each quarter. Your country of residence may be different, check their website. 

In general for large maps you can separate the map into multiple chunks and load each chunk as a quad or oct tree for LOD rendering. This might be a generic answer, but you will have to specify your target platform and more details if you want a more more specific answer. This thread might give you some ideas. 

the MsgProc will probably be called a lot of times if the mouse is moved a lot and cause mutliple WM_MOUSEMOVE events during a single tick/frame/update. the 

should not be inside the msgproc. You mixed up the GetAsyncKeyState function that might only be called once per frame, with the WM_KEYDOWN, WM_KEYUP events 

Instead of distinguishing them by different names or colors you could give the player a variety of commands with the power to distinguish. For example, if "five goblins attack you", you could invent either numbered or named commands like - "attack first goblin" or - "attach goblin 1" This approach is almost like you already suggested, but instead of naming or presenting a long boring to read list of enemies, you just tell the player the amount and the player decides how he likes to interact/type. Also, you could have a database of random names to choose from, if you really want to distinguish uniquely between enemies. 

This should ensure that the width and height of the tiles will be sufficient to cover the canvas and you'll eliminate the gaps. 

If you create these outside of the draw loop and keep them for the entire lifespan of the Square, your performance should improve greatly. 

EDIT Jimmy's result and explanation are both correct. My formula requires that you also add half of the velocity. 

There is no advantage for a low ping in games that use this method because each block of commands is executed in-order, at the same time, on all machines. You can read the article for more details on how. Only real-time games are affected by a low ping advantage, and most real-time games will fall into one of the two categories above, which leads me to conclude that extremely low pings are no better off than medium to low pings. 

I found the library that I used back in the day. Yay! $URL$ It's designed for use with .Net and XP, but the DLL works on my Win7 64-bit machine. The DLL has some quirks, but at a minimum, it's a proof of concept, and it's documented. Edit: Not sure I'd recommend using this library these days, the other answers seem to provide some more recent, and probably cleaner results. 

When I first looked at your game I immediately expected that I'd be able to hold my phone in my hand like I would a dart and make a throwing motion, in order to throw the virtual dart using the accelerometer. However, it doesn't look like you actually have that feature. I think that would be a pretty neat thing to add. Of course, not being able to see the screen when you're throwing would be something of an issue, and you might want to look into what liability you could be facing for basically encouraging people to almost throw their phones... Even so, I think it'd be a very novel and Wii-like way to play the game. 

Your formulas seem pretty complicated. I'm not sure how professional RPG developers handle this, but I'd recommend on focusing on simplicity. Try to find the simplest possible formula you can that still incorporates the range of stats you want to use. For instance, could you have stats modify each other prior to damage calculation, rather than modifying the damage during the calculation? Once you've got a formula in mind, I'd try graphing it for a wide range of possible values to see how it will behave as players level up. Obviously the fewer variables you have, them more feasible this will be. Additionally, BlueRaja provided an important explanation of why you might be seeing unexpected values at higher stat levels. Using unsigned types and checking for overflows will be important. 

With some experimentation, your angle appears to be inverted, but otherwise correct. Negating your angle works: 

Your co-workers need to have the .Net Framework 3.5 and the XNA Framework 4.0 installed. I don't think there's an easy way around that. Get them to install these first, then you can distribute the exes in a zip file with no problems. 

I would recommend writing a mod for either Unreal Tournament or Half-Life 2. They both have great communities, and great tools. Unreal uses their own well designed scripting language, while Half-Life 2 uses C++. In either game, you should be able to make your own weapons and intractable objects without having to deal with all of the lighting, bump-mapping, sky-boxes, networking, controls, UI and whatever else goes on in a 3D engine. The disadvantage to making a mod is that anyone who wants to play it has to own the game you modded. 

Note, the above may not compile, take it with a grain of salt. The concept is there though. Each section of text on a line will be drawn it its own colour, and each section is pushed over by the size of the previous section(s). Edit: As a general tip, break problems up into small chunks that make sense to you. If the big picture doesn't make sense right away, start working on some of the small helper methods and classes that you know will be used, and work up from there. The pieces usually fall into place. 

If you plan to make good looking Terrain, then using Detail Maps will improve your scene a lot, so to answer your first question, yes. Although only one question should be asked, I will go on. I don't think you should be worried about performance just yet, you will have to try out a few things to find out. Depending on the type of terrain, different games have different solutions that fit them that are balanced between use of resources and enhancing the scene. Some games might do just fine using a few pretty bigger textures (probably not), some will look ugly and blurry unless they use a combination multiple blended textures, mip-maps, bump or normal maps, detail maps or even decals. You can either test for yourself, or if you need more advice look at some more terrain tutorials. Wolfire games have a really good Youtube channel where they tell you what technique and why they used it. 

I'm currently experimenting with an adventure game setting where at some point the game is quite calm and the player has to solve puzzles and at some point there are enemies or environmental traps. I don't want to have any surprising danger events coming out of nowhere that would scare the player, so I would like to build up the players' tension before a section of the game starts which will contain multiple "player-killing" obstacles (may they be enemies, or the ground falling apart..). My sound artist made some really good music and sound effects to slowly build up the tension, but game elements during this phase are missing. It's like the player is running from a puzzle-zone to danger-zone through a boring plain section. Beside sound, what are some generic ways to build up the players' tension? Can i aid with special Visuals, or do i have to improve the story or possibly invent some pre-danger-zone easy obstacles?