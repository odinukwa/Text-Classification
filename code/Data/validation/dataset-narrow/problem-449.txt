You initialize and , then you reinitialize in the outer for loop, then do nothing with in the inner one. You don't need to write an initialization step in the for loop if you don't want to. 

You can use the comma operator, which takes the value of the last expression. It's not used very much, so may make the code less readable, but if you wanna make it one line, this is the way to do it in a single statement. You need parentheses because of operator presedence. If you omitted them, the comma would be interpreted as a separator between variable definitions. 

This is a good first attempt, but you have a couple things wrong with it. If you look at the for loops, you'll see it's adding each element to the nav in the same level (rather than nest them inside each other), but then proceeds to move it to the correct place with the inner for loop. That's the second problem. You rebuild the nested element structure each time you iterate over the array. You should eliminate all this unnecessary work, and you can do it in all plain JavaScript without using jQuery. Edit: changed function to accept any number of elements as arguments to nest (e.g., ). 

Your code grabs the from the then converts it to an , therefore treating a as an . The function you defined swaps the values in the s, effectively swapping the first bytes of your s (most likely the members). I'm not sure if this was intentional, but it certainly is pretty unintuitive and most likely unreliable. Instead, I would change your code to this, then redefine your function afterwards. 

I would add the (currently global) VM state as a parameter to the function. This will make reentrant and allows multiple VMs working in parallel. I would prefer a switch for dispatch, it reads cleaner, and there is less chance of the jump table being messed up because you miscounted. Just a stack with only a view to the top 2 elements and 3 registers is very likely not enough. It's not Turing complete in its current form. You cannot sort an array with it for example. Add bounds checks for storing and loading the registers. Add bounds checks for stack over/undeflow as well. For a VM to be useful it needs to interact with the outside world, that means opcodes for input and output from peripherals/game engine. Stack implementation is fine (except for the bounds check) though using union to bitcast between types is Undefined Behavior in C++. You will need to use a memcpy to do the bitcast: 

Don't allocate nodes until you really need to. should not expose that it has nodes. should take an int to be stored in the node and should return the value in the head node. 

Your will get called O(n log n) times. This makes it worth taking a closer look at for optimization. One thing you can do is avoid repeated calls to and and instead preallocate the tmp buffer in the root function call and pass it around or use to allocate the buffer on the stack. 

is used in several places, both as a integral value and a pointer value. Try to use more explicit values (especially the more type-safe for pointer values), as currently every time is involved, I have to double check whether the value represented is a pointer or not. 

Empty destructors The only empty destructor I'm worried about is . does acquire some resources (e.g. SDL handles), but never cleans them up properly. OTOH, the destructor of does some unnecessary stuff (could as well be empty). Comments Ideally, the best code is so clear in its naming and design that it doesn't need any comments. In practice, sometimes comments might be needed to explain why (not how!) something is done. In your current code, it feels like you wanted to label certain code sections to clarify what they do, there's a language feature for that: functions! Collision handling Other than the bug(s) mentioned above, it seems to be fine (regarding logic). Design While your current design works, there are some concerns: Many classes have multiple responsibilities. Ideally, every class has only one responsibility, i.e. only one reason to be changed. I don't feel like any of the classes in your current design adhere to this philosophy (only candidates are and maybe ). If I had to design this game, I'd probably use the following (public) interfaces: 

Correctness sets you on the fast track for undefined behavior, as the value returned by might not be inside the same allocation as (e.g. in case of a linked-list based or an iterator returning a proxy object, as does ). Operations such as comparison, addition or subtraction of pointers are only defined if they both point into the same allocation (or the first element after it) and they are both of the same type! Implementation 

I think it would be helpful to redefine your function like so below. I would strongly suggest including the function in your "LinkedList.c" file as well. It is going to do the same thing no matter what is in your , so why leave this implementation up to the user? Just define for yourself as a helper function. 

Here you throw a string. You can throw any value, but it's more helpful for debugging purposes if you throw an object. Just pass this string into the constructor to make your own error message. 

These are already available in your scope, so you do not need to reassign them to a local variable with the same name. 

Maybe use some array methods like ? This will add up all the elements, starting with an initial sum of 0 (the second argument to ), then the sum is divided by the array's length to compute the mean. 

There is a shortcut you can take to find the missing number after you've found the duplicated number. You may have come across this fact before, where the sum of the numbers 1 to is . We can leverage this along with the duplicated number to find the missing number. If you add up every number in your list and subtract that from what the expected sum would be from 1 to , most of the terms will cancel, leaving you with . You can visualize that with an example: 

You should also wrap the result of , and so accesses to them are also protected by the locks. This cascades downwards to include the iterators, streams and entries. The only thing you should ever return bare from the wrapped map is the keys or values themselves. Unlocking a LockWrapper or forgetting to lock it results in an error. 

is a helper function to create the nth power of 10. The big if-else can also be simplified and generalized a bit: 

I would also add a third variant that will create an object on the calling thread when the pool is empty. 

first issue: you hardcode as the number of bits per unit: portability says it should be which may be something else on some architectures second issue: both members of int80 are signed, only should be while can be unsigned if you can guarantee that offset is between 0 and 80 then you don't need to test for 0, and just document that exceeding the bounds is undefined behavior 

Besides that if you are using it for parsing then you will be popping and pushing nodes often. So it may be worth reducing allocation cost on that by keeping a linked list of previously allocated nodes: 

Where has time complexity of \$O(\sqrt n)\$. But because passed in is the square of the total complexity is \$O(m^2)\$ Instead given a \$i\$ you can construct a \$k\$ such that \$(i+1)(k+1)\$ is a perfect square. First you factor \$i+1\$ into prime powers. Then you take all odd prime powers and multiply them together. For example for \$60 = 2^2 * 3^1 * 5^1\$ you multiply 3 and 5 to get 15 as the start value of k and \$15*60 = 900 = 30^2\$. That is the start value of \$k+1\$ and you multiply it with squares until you go past the end of the string: 

Note: This might keep the section alive far longer than intended! (Some might also say that this is an ugly hack...) 

An old trick is to cast a pointer to an array of bytes to an pointer of a struct (POD) with the exact memory layout of the final message(s). 

However, this requires a strict memory mapping between the message struct and the serialized byte format (so in this case has to be a POD struct). Yes, this effectively bypasses the type system, but if used properly its the fastest way of parsing messages (and in case of embedded systems the reuse of the memory is a nice touch). 

Now we can go over both and and look what the best results for removing up to elements from the front and (so ) elements from the back. 

Algorithm Your algorithm uses (as you correctly stated) \$O(K^2)\$ time by calculating all possible combinations. This can be reduced to \$O(K)\$ with a bit of cleverness: As far as I understand it, the problem basically boils down to: , maximize by removing up to <= total elements. This means to maximize , one needs to find how many elements to remove from each "end" of the array, because as you correctly deduced, only those matter. Now we can step from one end up to elements in, and for each step calculate the change in if we were to remove elements up to this point. If it's the best result so far, we note it for the current position, else we note the previous better result (after all, we always can take less elements away). We do this for both ends. Then we can add the noted values for taking elements from the front and elements from the back together (so up to elements total), and find the maximum for this value. This value is the highest increase possible for . Adding this value to the previously calculated original value of gives us then the maximum value for . Step by step Let's take your example: . Let be the map . 

numbers.splice is the culprit, this will take O(n) time each time it is called. And it is called O(n) times. do a proper sieve instead: 

Your temp array is static, this immediately makes your function not thread-safe and non-reentrant. Instead add it to the parameter list. 

You have a destructor but no sign of a copy constructor or copy assign (nor of the move variant), you should implement them or mark them deleted to avoid use-after-free bugs: 

This requires that the required length of the buffer must be queryable. But having the length explicitly in code like that make it easier to avoid buffer overflow bugs. The other option is to make an int_buffer a object that requires initialization: 

Also don't worry about having to the args; you are creating a new thread, this is much more expensive than a quick call. 

you don't need the memset in the for of you just need to add a to the end when max depth has been reached: 

This needs to be synchronized so no thread can mess with the list while another is checking the length to see if one needs to be removed. 

This immediately tells the programmer that both bodies must be players. The later ones less so, You can invert the condition and put the markForDestroy call in the then clause. 

You can do the merge sort without using too much memory by reducing the initial block sizes. However with 64 bit you can just mmap the entire file into memory and sort it just like an array and let the OS deal with pulling in and flushing out blocks as you access them. If you do wish to continue with the bubble like sort then I would suggest keeping more values in memory to reduce the number of passes you need to do. You can do this by keeping a min heap of a max size: 

Algorithm You could actually skip looking up the maximum element in the range. This is because it gets cancelled anyways: $$y = {{e^{x - x_{max}}} \over {\Sigma e^{x - x_{max}}}} ={ {e^x \over e^{x_{max}}} \over {{{1} \over {e^{x_{max}}}}\Sigma e^x}} = {{e^x} \over {\Sigma e^x}} $$ Also, currently the results are stored in place, i.e. the original input data will be lost. This might not always be wanted, so maybe accept an iterator to write the results to? vs. SFINAE I personally like the SFINAE approach more in this case, because it's easier to introduce another overload if needed (e.g. for iterators over associative containers) and you get immediate error reporting. That said, if the decision is final that you won't ever need another overload, works fine. iterator Well, if the container is nicely conforming to standard library guidelines, you'll be fine with using . For custom containers, this might not be the case, though - for those cases you could use instead. 

Optimization Your current code is not structured well enough for the optimizer. Why? If it could reason about it perfectly, it would remove all the code (as there are no observable side effects), running in near 0ms! Declaring all possible variables and moving them to the smallest scope possible helps quite a bit. Even better: Refactor the code into functions (and maybe classes) with proper annotations! Just this alone allowed MSVC and GCC to recognize that the whole calculations aren't needed (as they don't cause side effects by themselves), so they removed them and run-time went down to ~24 microseconds on my machine. To get relevant results, we now need to fool the compiler a bit: Adding a little side effect ( in the code below) and taking the number of loops to run as a command line argument were enough for MSVC and GCC (and clang, though not ICC). Now runtime (with all calculations!) went down from ~14 seconds (original) to ~12.5 seconds (again on my machine).