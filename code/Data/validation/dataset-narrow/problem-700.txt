First, Welcome to code review, and a very nice question for a beginning self learner in C++. user1118321 is correct about a everything he says, I'm going to emphasis one or two items and provide some references before I mention a few other things. Use Functions: Functions allow one to break up their code into smaller, easier to understand logical blocks. When designing software it is often easier to break a complex problem into smaller problems that are easier to program. Some people use flow charts to map out their program, and high level flow charts will only contain the functions. These will be followed by lower level flow charts that map out the logic of each function. Using functions allows one to decrease the amount of code written in some cases. The function should be primarily used to set up the environment for the rest of the program, call a function to execute the rest of the program and catch any errors. If you find yourself repeating code move that code to a function so it only needs to be written and debugged once. This is actually a programming principle generally referred to as Don't Repeat Yourself and you may see it referred to here on code review as DRY. Both functions and classes should follow the Single Responsibility Principle (SRP). The Single Responsibility Principle is that a function should do one thing, and one thing only. This makes code easier to write, debug and maintain. It also makes the function easier to reuse. The Single Responsibility Principle may also be a reference to Demeter's Law (I may be wrong about them being the same principle). Another programming principle sometimes mentioned is Keep It Simple (KISS), although this isn't just for programming. You may want to look into SOLID programming as well. A more comprehensive list of programming principles can be found here. Use Existing Classes A long time ago when I started using C++ the Standard Template Library (STL), sometimes called the Standard Library, had not yet been defined or implemented. We had to create our own strings, queues, vectors, stacks and other container classes. Using the C++ container classes and the standard library requires A Lot Less Code and makes it much simpler to write correct software. Two great website to become familar with if you are going to write C++ code are CPlusPlus and the C++ reference. These websites are better than using a book as a reference because it remains up to date, and documents the C++11, C++14 and C++17 standards all in one place. The string container class provides one with much more functionality then cstrings. The follow is new content not previously mentioned. Magic Numbers The term is sometimes used for numeric constants in code that are not obvious. By I mean that it's not obvious what the number represents. Non-symbolic references to numbers should be replaced either by named constants, or enums (enumerator types). An example of a named constant is: 

The point of an interface is to abstract away the implementation details from the client. has the method which publicises exactly what the implementation is. This is called a leaky abstraction. When writing an interface, think about what other implementations might look like. One thing that you do know about all implementations is that they are going to need a file path. An alternative interface might then look something like this 

Note that I have assumed you are wrapping inside a here, however you could choose to make behave similarly to your and return an if that is what your application needs. 

To optimize the code create a copy of the array and use qsort() to sort the values in the copy. Find the dominator using the sorted array, then find the indexes using the dominator value. I don't know if this is a result of how you entered the code, but the following line of code should be 2 lines of code: 

If you use this number often, it makes it easier to change the value by just changing it where you define the constant. It also makes the code easier to read. The standard for symbolic constants in C and C++ is all caps with '_' between words. Function Names: Underscore in function names is a lot less common than it used to be, Camel Case is more common 

There is a lot of room for improvement here, both in terms of performance and readability. You should start to worry when you see code forming an arrow shape - there is almost always a nicer way. The solution below is one way of tackling this, and also offers a large performance improvement (around 19.4s to 3.2s on my machine). 

Generating Permutations In the Haskell snippet you referenced, is generating the a list of all the possible permutations of the numbers 1 through 9. I'm not aware of any nice way of doing this in C# other than hand rolling it. You can write a pretty short generic recursive function to do this. 

First it looks pretty good for a first time C program. Nice question! It is very nice to see a first C program without MAGIC Numbers. The variable could probably use a more descriptive name. The program could be more general. If the number of strings in the file increases the program will index past the end of the variable . To make it more general, not waste space if there are less strings and not produce unknown results if there are more strings, the array could be implemented as a linked list. This would perform better than reading the file twice to get the size. The code never checks the value of counter to make sure it stays below 1388. The code depends on working. There should be error checking for opening a file, reading from a file and writing to a file. Technically there is nothing wrong with the switch statement in load_data(), but it would be better to have a default case that identifies what should if line[j] is not A, T, C or G. 

is not a builder, it is a factory. It's job is to create instances of . This shouldn't be done in it's constructor because then you need a new factory, each time you want a new . 

There is an abstraction that will automatically have any config updates when injected, so you don't need . I believe it is scoped per request, so changes to the config will not affect in-flight requests (you may want to double check this). To deal with updating the , you can write a small, thread safe that will always return the same client for a particular base URL. This would be registered as a singleton, and could be reused for all the clients in your app. 

Class Versus Procedure If the target of this code is a set of library routines, it might make more sense to encapsulate it in a class. This would provide the functionality already here with a single or fewer interfaces to call to implement the compression. Inconsistent Variable Naming Conventions The code contains well named variables such as and but then it contains variables with names such as , and are harder to understand. Keep in mind that code needs to be maintained and features may need to be added in 3 to 5 years. Even the original author of the code may have a hard time maintaining code with single character variable names after such a length of time. 

EDIT What I think Mat is getting at, is that this solution is localised to this usage, and may not be suitable in an application that frequently needs to generate parallel lines. If this is the only place in your app that you create parallel lines, then keep using it (YAGNI). If however you need to create parallel lines a lot, you could make your implementation a little more general. One way of achieving this could be through extension methods. Consider the following 

Cool question! In addition to t3chb0t's great comments, I would suggest using a instead of a . It has additional support for blocking and bounding so you don't need to poll the queue manually, and you can limit the number of "in-flight" files. This could be used to make sure you don't read too many files into memory at once. 

but it is named HashMap.h in the question. Some operating systems ignore case in file names, others are quite strict. To avoid portability issues make sure the name of the included file is the same for both the operating system and in the #include. calloc() versus malloc() The function calloc(size_t n_items, size_t size_of_one_location) is meant to allocate arrays of some item. It makes the code clearer with similar results. 

Missing Header File The function is defined in stdio.h. My compiler reports as an error because stdio.h is not included. Using printf() instead of std::cout The code already uses std::cin for input (this is a good thing since the standard C++ input and output std::cin and std::cout). This is another mismatch. If using for ouput than use for input. While and are still accepted in C++ as long as the proper header files are included, they are not the standard methods for C++ input and output. Prefer std::cin and std::cout over and . Magic Numbers The term Magic Numbers is sometimes used when code contains numeric constants where a named constant is more readable and maintainable. A named constant in this case might be: 

Assuming that you do indeed want a mutable triangle class, then you could extract validation into a method and re-use it from your constructor and property setters like so. 

should almost always be avoided. Try to return from async methods so they can be awaited by the caller. A should be returned from and have it's method called. 

The equivalent C# then becomes . Equation Depending on what you are doing, you might want to consider creating an class with a method and override . Failing that, you can at least pull the equation logic out into separate methods. 

The DRY Programming Principle Ask your teacher if he was referring to the DRY programming principle. In software engineering, don't repeat yourself (DRY) is a principle of software development aimed at reducing repetition of information of all kinds, especially useful in multi-tier architectures. This code repeats almost exactly 6 times: 

Doing so makes the logic of copy_max() clearer. I'm fairly sure that you can calculate index only once. I'm not sure why it's being calculated in 3 different places in copy_max(). The title is miss leading as well, since this will copy more than just characters.