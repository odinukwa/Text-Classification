If you look at the code, you can see that two things were implemented. The update method changes the position of the GameObject according to the defined velocity. And the render method first simply calls the render method of the base class and then checks, if it has to draw the building material. Some comments to this. The entities do not manage their state themselves (besides the position), but you would handle all game objects in the game loop and depending on the state you would change the fields of the entity, for example like this: 

To make things a bit more interesting, we add the logic to spawn a static game object to the player object (this is maybe not the best solution, but it should do the work). So we add this code to the PlayerObject class: 

Like this, you do not have to care about multiple terrain types getting together, as they are rendered from lowest to highest terrain type and the transtitions only concern the higher type. I know that it is a bit complicated at first, but I currently don't have more graphics, because I'm in the middle of refactoring my source. I will add some graphics representing what I do as soon as possible (also better explaining every step). I hope this will help you. One small addition: My mapper is built, that there is a default blend texture. But you can define specific blend textures for every terrain type. So for example if you want to make smoth transitions for all mappings besides the beach to water transition, you put the smooth transition as default and only set the custom transtition for the beach tiles. Also, my mapper allows to define multiple transition tiles for each tile type (so if you have a straight edge, you can make multiple blends, so they will alternate). ** Appended ** Because I currently have no assets to show, I created a schematic drawing in paint.net. Keep in mind, I'm a programmer and not and 2d artist, so artistically it is very badly drawn, but it should show, how I tackle the problem with multiple terrain types (>2) coming together). I left out optimizations for simplicity and applying the blending is also not mentioned, as I concentrate on the problem with the multiple terrains. I will add an example with real textures and blends as soon as I find the time to do so, so this gfx is only temporary. 

Edit: What I want to achieve is that all the following objects "walk" the path the leading object in front is taking. All the other objects just move at the speed of the leading object ( this would be by passing the velocity vector to all the following objects). But how do I let all the objects move/pause over the path while maintaining their distance from each other as well. 

Seriously, Google that stuff: $URL$ There is a complete manual on unity. Took me just one google search. 

dt (delta time) is the time between each cycle/render frame (or any time stamp you desire) of your loop. With this delta time we can stretch certain values over time. Just like in the real world we measure certain physics properties over time. Let's say we run our game 60 frames a second. If we want our our player to move 5 pixels per second we do 

You can just apply A*( A-star ). Compared to a uniform square grid the only difference is the way you collect the adjacent tiles ( aka your hexagons ). Each tile should have a table of booleans representing the bridges corresponding to their direction like so 

The character moves 5 pixels over 60 frames. The longer your cycle takes the bigger delta time will get. For every framerate (1/30, 1/25, etc) the result will be the same. 

Think for a moment what happens if bSpawnSandbag is true. It will always draw the sandbag. However the only input you are using is the playerPos.X/Y for where to draw it. Of course it's going to draw it at the players position. It's continues and not a one time thing. Code isn't called once unless your structure is specified/setup as such. As long the bSpawnSandbag is true, sandbag will be drawn. I don't know what properties your sprites has. Simply keep track of the position when space is hit 

At one place in your code, you create your game container. If you followed the tutorials, that part will look something like this: 

You should take a look at quad trees. Its a common datastructure to store spatial data in cells. When you do the collision testing, you simply test against the objects in the same cell... I use the same datastructure for rendering. I pass the rect that defines the viewport into a selection method of the tree and receive a list of cells. Now i just have to render all sprites from those nodes... When the object spans over multiple cells ,you can add it to both cells. Just make sure to remove the duplicates ,when you use the results from the selection method. I'm currently on my phone, so I have no code examples here ,but a quick google for quadtree should help. 

The first two parameter define the window resolution, the third if slick should be opened in windowed or fullscreen mode (true for fullscreen mode). You should head to the slick2d wiki, as it has some beginner tutorials explaining such things. For example in this tutorial the basic things are explained step by step (also your question is answered there): Creating a Basic Game tutorial All tutorials: Slick2d Tutorials Index 

Like this you create the set of numbers you want to have in your randomized list and then always pick a random entry from the ordered list. With this technique, you can also achieve, that certain values occur multiple time in the list. I'm not sure if my code compiles against c#, as I currently do not have visual studio running here, but I think the code should be mostly correct. 

Not exactly what I'm looking for but I've opt it for another less "elegant" way of doing it. I set up a table of points and their values. The object looks like 

2: We first create a vector ( 2D in this case with component x and y ) by taking the difference from both positions ( mouse - player ). 3: We then Normalize it to create a so called " unit vector ". Which means to bring the length of our vector to 1. This is done by dividing both x and y component of the vector by the length/magnitude. We need this because this is our direction vector. It simply tells in which direction we are heading for the x and y axis. 4: Now we have the direction we just need to multiply it by a scalar ( or simply put by your speed). Since the length is 1. Any number we multiply with will result in a new vector with the length equal to your given speed. Just remember that a unit vector represents the direction of your vector. Basically the red dotted lines is how much it moves in the x direction and how much it moves in the y direction per frame. So recap: Unit vector = direction Magnitude/Length/speed = steps to move per frame on x and y axis. (The lengths in the drawing are just for visual aid, they are not meant to be accurate ) Hope this helps. 

Now you could write your keybindings to a simple text file. And just set those variables when you read them. ( havn't tried reading text/xml/json files in Unity but im sure it's possible ) The idea here is that the keys are stored in simple variables. Which you could easily change. It should be trivial then to read/write them away. So making an interface in game where you can set your keys shouldn't be a problem either. 

Basically this should be what you are looking for... You have to keep some things in mind, for example you can leave out the upper bounds check, if the screen size in that dimension is bigger than the map size ( viewport.width > map.width ). Also, if you have your map width in tiles instead of pixel, you would have to multiply the map sizes with the tile size. If your screen position marks the middle of the screen, you would need to change some of the calculations a bit, but the basic idea is the same. 

And we could also switch one of the sand tiles and the grass tile on the right to different terrain types, it would still produce correct results. 

I think I stumbled upon this link here on gamedev and I really found it enlighting. $URL$ It explains some basic methods of implementing tile based levels, but there are also some important parts about how certain mechanics work in 2d platformers. I think you should look into slopes, as they can solve many problems you come across in platformers. Good to know is, that most platformers don't even bother with implementing proper physics, but implement certain rules, that mimic some physical behavior (like gravity), but allow certain behaviors that wouldn't be allowed with proper physics (air control for example). 

As the engine is pretty well known and documented by the community I think you can will be able to find a lot of detailed information about that type of map rendering in the GemRB community. 

Funny thing is you have already been doing it with pointerPosition in a way. Look at it. You use the gamepads position to move the players position by adding to it. I suggest looking at libgdx, as it provides a sophisticated library for gamedevelopment on Android. 

If you keep iterating through each adjacent node this way the costs will logically add up. And thus also give you an easy solution for comparing open nodes with new nodes and determine whether or not to swap parents. 

Im implementing certain Camera movements in my turn based games. I'm able to place and rotate the camera between two units that attack each other. However it will always move to the same "side". Which isn't necessarily wrong, the rotation of the camera just seems to be sharp when it's on the other side of the half plane ( as of right now it always goes on one half plane). I would like the camera to move to one side relative to the cameras position. Essentially I just have to flip the Normal which gives me the direction where I have to place my camera: A and B are units. C is the current camera position T is the target position. 

You could simply queue the players in order and just dequeue the first in line. The trigger to add them to the queue totally depends on your system ( I think a state machine could be in order here ). For example; if your character order depend on various triggers like stats and timers. You should monitor their properties and add them to the queue if a certain conditions are met. I can't really give you any specific code or an example because it's specific to your system obviously. Look up how queues work if you don't know them yet. 

Store the logical screen position and the actual screen position in separate containers... The logical screen position is the position, where the screen should be, when no shaking happens... When shaking happens apply some offset to the logical screen position to get the actual screen position. I made a little example (not tested and not completly implemented, but it should show how you could make the shake effect). Below I have added some thoughts about whats currently missing in my example. 

Another solution often used to "hide" the game files is folder structure. Keep only your executables and maybe a readme in the main directory and move the game files into a sub folder "data". I don't think that it is very uncommon to do so. Many games I know store their content in such a way. 

You can see, that you have some terrain textures and an alpha map. I handle the alpha map also as tiles, but they are half sized (terrain textures are 64x64, blend textures are 32x32), this means that every terrain can have up to four blend textures (northwest, northeast, southwest, southeast). Now basically what you do, when you have a transition is this: - Draw the ground texture (blends are always applied on the higher terrain types). - Draw the alpha map with ALPHA_MAP (this only renders the alpha channel) - Draw the second texture with ALPHA_BLEND (this uses the underlying alpha channel, we rendered out before as alpha for the tile). So basically this is the theory... But you need to do some things, that it works properly. What I do is following: 

Simply put, I iterate over the points on my t line. Check if t is between any of the points and calculate the inner interpolation of two points. Using the simple linear interpolation equation: v0+(v1-v0)*t; So a table of: 

You can flip the texture like so: myTextureRegion.setFlippedHorizontal(true); or by using the sprite mySprite.setFlippedHorizontal(true); // set false to flip it back Have you looked at AnimatedSprite class? AnimatedSpriteClass You could google for examples. It's in the API 

To complete what Josh said, Convolution Matrix is what you want: Convolution in Gimp Another link What you probably are looking for: Convolution Kernels in OpenGL 

Now if we were to apply the Pythagoras theorem on our new dx and dy value you will notice that the length is 1. Meaning that we have a direction, and a magnitude of 1. To change it to our speed simply multiply each component by it. 

(Mind you the tiles near the bottom are elevated) which places the tiles correctly, but their and values are not meaningful at all. In my iteration I've assigned the and values of the array indices to the and properties. Their values don't represent the point in "3d space". But it does however correctly helps convert to screen space with the multipliers and ( tile halfwidht/height). The purple sprite in the image should overlap between tiles depending on their , and . From which depth is calculated and then used to sort my sprite. But since the and values are assigned to such a small number which does not represent the tiles actual point in "3d space" the depth of the tiles are incorrect. Q:How do I calculate the and positions for the tiles which are then used to correctly calculate screenspace? 

In the first grid you see the terrain configuration. W stands for water, S for sand and G for grass. The second grid shows, how the blend tiles are applied. Like I mentioned earlier, the width and height of the blend tiles is the half of the terrain tiles. Here now the first render action happens. The lowest terrain type is water, so we fill all the cells (and all adjacent cells) with the water tiles. So allthough the water tiles only fill the first column of our definition, we have also to fill the second column. Now we draw the next layer, but we only draw the tiles, that won't be blended. Water is a lower terrain then sand, so we do not need to expand to that side. But because the grass is higher, we have to fill the adjacent tiles with sand, where the grass blend will be rendered over. Now based on some patterns, we render the blending parts of the sand. (Now you see, why we need to also fill the adjacent tiles). Here we have repeated steps 4 and 5 (allthough step 4 wouldn't produce any output, as all grass tiles in this examples will contain a blend). 

The commandos titles look like they use prerendered backgrounds. This means that one or multiple artists design the whole wort in a 2d or 3d programm. Commandos looks like it was done in 3d and then post processed in like photoshop. The exporter of the 3d programm used a special export method, as the viewing perspective is not physically correct. Objects more to the north should be smaller, but the size doesn't change correctly according to the perspective. If I'm not mistaken this mode is called "Orthogonal Mode". Parts of the generated map are splitted into different groups. There are some graphics, that only are used as ground texture (this may be the biggest part of the exported map), there are parts that are animated or can change (a door for example can have an opened and a closed state) and there are graphics, that sometimes are drawn behind the soldiers and sometimes in front, depending on the standing position. The Baldurs Gate and Icewind Dale series used the infinity engine, which uses a similar rendering style (the setting may be fantasy, but the graphics always looked kind of realistic to me, just like commandos). There has been a strong modding community around the infinity engine and a quick look to wikipedia revealed to me, that there is an open source clone / implementation of the engine in the works.