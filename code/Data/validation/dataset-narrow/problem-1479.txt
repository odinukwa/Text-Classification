See wikipedia for a discussion and background as well as the poem itself. In programming we don't normally use the first of these four distinctions, but the others are important. The second is how we think of a variable - a name for a thing. The fourth is the thing itself. The third can be an alias or alternate name for the thing, though that analogy isn't perfect. But once the distinction between the name and the thing is made, you have a better chance of winning. But you still need to be clear. "foo" is a thing (a String thing) s = "foo" establishes s as a name for that thing. "s" is a different (String) thing. But is simultaneously a thing (String) but also a complicated name for another thing (a File). The method needs a name for the file to be opened. Note that much of the above was copied from an essay I wrote in meta. 

But this example has no semantic context. What is $x$ ? How is it related to $y$ ? How is $n$ related to $y$ . For experienced programmers this isn't an issue and if they already have good naming practice, an abstract example like this works fine, but it doesn't emphasize the larger lesson that naming is always important. You can just as well show them: 

In your discussions with students about plagiarism, be sure to include the concept of self plagiarism which many don't recognize as a problem since it doesn't violate IP rules. But does make derived research and attribution more difficult. And, like any lesson, it needs to be reinforced. Very little that you do just once will actually be learned. Active learninig is reinforcing as lecture is not. Class discussions about plagiarism and its tradeoffs (short term gain - long term pain) might be useful. 

etc for as long as you like. "Pointing" to a person is passing them the message to read (sing-act) their own script. Depending on how you talk about the exercise you can use it to reinforce lists, stacks and/or recursion. Note the base case (...take a bow). The "message" sent is recursive, though. You can also explore what happens without a base case in your follow up discussion. A bit foolish, but my University students tended to like it even if they did roll their eyes a bit. Note that such "active learning" exercises always require follow up discussion in which you point to the mapping between the elements of the game and the lesson to be learned and students get to unwind any puzzlement. 

It is a bit long, but note that, again, all of its public methods are defined in the Population interface. This class is interesting and exhibits better OO characteristics than the disease classes. It is built from composition, both of library types like set and bespoke types like Disease. This class is also a better example of "Tell, don't Ask" in, for example the immunize and spreadFrom methods. The accessors are mostly used for reporting out the results of the simulation, not for enabling computation to be done elsewhere. Finally, here is a main that can be used to run a sample of the simulation. 

The reason for a default equal grade is to have the system encourage sharing and contributing. In Agile Development, one of the key ideas is that the Team shares in the success and reward of the project. It is not up to the team's manager to pick winners and losers on a team. I extend that idea to the classroom. But I keep my eyes open, of course. However, most teams do much of their work outside my view. I seldom respond positively to complaints about team members (and get only a few), reminding the complainer that it is also their responsibility to foster team work. Also, the students need to know that the "product" I'm most interested in isn't their program (or whatever) but the learning. If the project "fails" the students can still succeed. The educational process should be a "safe zone" where you are not yet expected to perform at a professional level. 

In the first part, ignore case, punctuation, spaces, etc., which isn't sufficient in general, but should be for this use. 

This question is hard to answer and especially hard to provide a complete answer. There are a lot of things that are good to know if you work with computers, though not everyone will use everything on anyone's list of favorites. However, some sorts of discrete/finite math are especially useful as they are useful for building models, independent of computers. The models can be programmed to solve useful problems in the world. I'll mention a few here. The basic idea here is that the more ways you have to approach a problem, the more likely it is that you can provide a solution. Even an approximate solution is often enough, especially in situations of uncertainty or when there are many variables and many constraints. Markov Chains and Markov Processing. These describe dynamic systems in which changes depend on only the current state and not a history. Linear Programing, and especially Integral Linear Programming where solutions must be integers. These are used for all sorts of optimization problems where constraints must be observed. Discrete Probability and Combinatorics which has entries to many related fields (Graph Theory, Coding Theory, ...) Decision Theory and Decision Trees, often used in algorithm design. Modeling under uncertainty. Set Theory and, more generally, Mathematical Logic, used ubiquitously in programming and in Theoretical CS. Vectors and Matrices (not strictly discrete, of course) but often used in proofs and models, especially models of physical systems. Game Theory, again used in modeling and in predicting outcomes in complex situations. Number Theory used in many things, especially cryptology. 

Beware. "The One True Lecture" is an oxymoron. I have a horror story about trying to create such a lecture to teach elementary statistics. It was perfect in every way and explains sampling without ambiguity. It. Was. Perfect - for me. A generous evaluation of it would suggest I reached maybe 15% of my students. The problem was (and often is) "Your students are not like you." Recognize that even if they are bright and hard working (like yourself), they may not learn in the same way you do. Learning Modalities is the term of art. Instead of trying to find a straight and direct path from where your students are to some target/goal, plan a twisty path instead (and have the path make visits to the Active Learning shrine, I think). Many instructors have had the experience of walking out of a lecture feeling terrible about it. They said the wrong thing in the wrong way. They stumbled. They struggled with student questions. They wrote stupid-stupid code on the board and had to backtrack and patch it up. Then later they bumped into one or more of the students who thanked them for the wonderful lecture. I've been there. Part of that is learning how to get up after a fall, which is an important lesson. But you have part of the solution in your question. After your first "Statement of Principles", draw them a picture to illustrate it, even if the "picture" is a metaphor. So: 

Final Note: The biological classification of Carl Linnaeus is probably a poor analogy to use for subclassing and polymorphism. Each entry in the classification tree is a different concept and all are abstract. There is no such thing as a pure Mammal. Moreover, classes define behavior of objects (via public methods) and the Linnaeus classification system is nothing about behavior. Trying to use it to generate examples of subclassing is one of the reasons students get terrible ideas about what should be done in a subclass. 

Actually it is and that is a bit harder to finesse with language. "Everything in A and everything in B" (Union, or)is easy to confuse initially with "It is in A and it is in B." (Intersection, and) so watch out for that. The first sentence is, of course, the same as "It is in A or it is in B." Focus on whether the statement talks about an individual thing, "It..." or the set/concept as a whole "Everything..." 

Other idea, that I don't think have yet been captured as patterns are thing like having students submit questions for an upcoming exam, probably with some reward for good questions. The pedagogical patterns community has continued the work also. Especially in the assessment area. A couple of workshops have been held in Europe, for example. Christian KÃ¶ppe at the Han University in The Netherlands has been one of the drivers of the recent work. Newcomers welcome, of course. I agree, however, that a completely summative assessment has little value and gives you little guidance for improvement. But to the specifics of the question. If your class isn't too big, you could meet individually with those who need to improve. You could let students form small discussion groups (say 3 students each) to discuss answers on the exam. They need not reveal how they did, but could discuss how they approached the questions. Or you could meet with a small group rather than individuals to discuss the future and strategies for improvement. Of course, if the assessment vehicle is poor you need to work to improve that. It is possible for questions to be so bad that students are misled by them. I've written one or two of those in the past (alas). 

Let me note that there may be cultural limitations here. In some cultures it may be odd to name oneself as a top contributor. In others it might be very natural. You can modify the scheme, of course, either requiring or forbidding naming oneself as one of the top people. Use your judgement here. 

Perhaps you should first examine the goals you have for your students. Where do you want them to end up. You describe them as pretty unsophisticated in computing when they begin. The students you describe aren't completely unique, of course, but are not the typical high-school or college student. If all you want is to give them a little bit of a glimpse of programming in a more general course, then your approach seems fine to me, though I would probably do something different. If you feel that spreadsheets would be an especially useful thing for them to know more deeply, then certainly what you are doing is fine. However, if you want them to be able to use some general purpose programming language eventually, then it seems to me like you are taking a detour that isn't getting them close enough to the goal to warrant the time and effort. User ctrl-alt-delor suggested simple programming environments like snap and Scratch which offer a more standardized introduction to programming and that aim more directly toward that goal, if it is, indeed, your goal. But start with the goal and work from there. Don't take too many side trips or trips that later need to be worked back from. 

There are many ways to grade students. One is to provide a fixed body of student work and then give a percentage grade for assignments, with the overall grade representing the percentage achieved of some ideal. 90% = A, etc. The student is expected to work on each assignment. This is Grading by Percentages. Another way (Grading by Points, Cumulative Grading) is to provide a body of assignments with a point total assigned to each part, preferably with small granularity but totaling, say 1000 points. The grading is done cumulatively with, say, 900 or more points required for an A grade. The instructor evaluates each assignment and gives points based on quality, etc. perhaps giving 40 points on an assignment that is "worth" 50. Here the student can work until they have enough points to achieve a grade that is acceptable to them. After that, they no longer need to do anything and can focus on other courses or commitments. It is, of course, good to warn students who are intending to go on that learning is still required to meet their greater goals and not to be too complacent. In either case, the instructor may permit re-work on assignments. If Grading by Points the rework earns additional points, but perhaps not up to the full marks for the work, but some positive increment. The writer used Grading by Points in the latter part of his career. What advantages and disadvantages are there of each scheme. What improvements can you make to either or both of these? 

From a practical standpoint, rather than a theoretical one, there are at least two pedagogically defensible ways to do this. Spiral curriculum, and Scaffolding Use a Spiral Approach I won't assume that you never mention variables early with this approach, but you just don't teach all that needs to be known at the first introduction of variables (or any other topic). To teach like this you mention things that need to be known deeply early on, partly to introduce terminology, but partly to permit simple uses in which deep knowledge isn't needed. Then, for example, variables but without reassignment could be used in setting up some sort of selection or iteration as your lecture focuses on those ideas rather than the variables. At any given point in time students know a little about a few things and a lot about some other things. Then, in the next cycle you go a bit deeper in some topics but also introduce, very lightly, other topics. The implication is that a student never needs to completely understand any given topic the first time it is presented as it will be seen again. Everything is reviewed constantly in such a course. For purposes of this particular question, a variable could be initialized somehow and then used within a selection structure. The student need only have the idea that the variable refers to a value and can be thought of as a temporary name for that value. Teaching a course in a spiral way requires some pre-planning, of course. It isn't enough to put each important topic into the syllabus only once. Neither is it enough to expect that every student will get a lot out of the first introduction and you don't, therefore, need to obsess that everyone is on the same page before moving to the next topic. Use Scaffolding An independent way of teaching is to have students first programming experiences done within a pre-defined richly endowed virtual world. The world is constructed so that interesting things can be done early without necessarily building up everything from the beginning. Often these world are simulations. For example, in Karel the Robot and its successors, programs consist first of writing sequences of statements to direct an existing robot. The robot's capabilities are built in and the student simply invokes existing functions/methods to achieve some complex effect. Next the student learns to write methods or functions as just abstractions over some sequence of such pre-build actions and other actions already built by the student. In this way it is functional abstraction that is the first real topic of importance. You can introduce variables or not, and you will certainly do so when you want several robots acting together. But these variables are just object references and little needs to be known about them, including whether they can be reassigned or not. Selection is certainly a reasonable topic in such a world, as is iteration, polymorphism, recursion, or whatever you need to teach. However, careful thought needs to be given to the characteristics of the simulation world. How rich is the environment. It can be simple, for example, and still be Turing Complete. Some teachers might choose this path with a single simulated virtual world, and others might choose to use several worlds of increasing sophistication and, perhaps, increasing complexity. I'll note that Greenfoot was built precisely to provide an environment in which such simulations and virtual worlds would be easy to build. 

tl;dr Build the layers with appropriate scaffolding, either top-down or bottom-up. The goal is to understand an abstraction layer architecture. The teaching method is to have students build it layer by layer. Here is a suggestion that you can adapt to quite a few situations, though it takes some work as well as some consideration of tradeoffs. The basic idea is that the students implement all of the levels of the abstraction stack in sequence starting either at the top or the bottom. I'll assume you are programming in Java. It translates pretty directly into similar languages, but with more work for dissimilar languages. Envision, a three layer stack. In practice it could have any number of layers, but three is enough to show the strategy. I'll call the three layers The Abstraction Layer Model 

For a more direct answer to your question (finding resources), you can have the students assist in this. Some sort of computer mediated communication (email list, wiki,...) can be used and students can contribute helpful resources to it. You can reward them for this, also. If it is something like a wiki, you also preserve the resources for the future. You also have a handy way to toss in resources as you come across them and students will have immediate access. Students can also, perhaps, comment on the helpfulness of their peer's contributions, aiding your eventual evaluations.