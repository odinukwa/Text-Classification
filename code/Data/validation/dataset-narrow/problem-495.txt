This way you only need to process the data of each image once and then group them by the hash. A few remarks to your code: 

Your method will break the stopwatch because you create a new timer but you do not re-attach the timer tick event handler. You have a method which sets up the timer but you also do this in the constructor which is some code duplication and in fact has introduced a bug (see previous point). DRY - Don't Repeat Yourself. Make use of a common method which can get called in both places. Instead of "polling" your stopwatch in a continuous loop your should expose an event like to which any interested party can hook up to. In general this can pose problems when interacting with UI because if the callback happens on a different thread then you need to marshal UI access across to the UI thread. However you have used a which is evaluated at the top of every dispatcher loop - which means the callbacks are happening on the UI thread and it is safe to access UI elements from within the callback (see the MSDN example). So basically you can expose an event which gets fired on the timer callback and whatever code hooks up to it can update the UI. In general MVVM has established itself as a very useful pattern. Which means that rather than updating UI elements directly you would update an observable view model to which the UI is bound. This decouples the UI better from the data and decoupling is always good. The timer is guaranteed to not fire before the interval has elapsed - but there is no guarantee about how long after the interval has elapsed it will fire. This means your stopwatch will start falling behind the real time as you assume each tick is 1 second while in fact it might be 1.01 sec or so. This means after 100 seconds you could be easily 1 sec off or more. A thread time slice in windows is typically around 10ms so I'd suspect the timer to be around that accuracy. Although on Windows Phone you might get better performance (couldn't find any documentation in that regards). The way to overcome this is to take a timestamp at and compute the difference to the current time on each tick. While this will probably also give you an approx. 10ms accuracy it will be constant while your solution will accumulate an error on each tick. This will also alleviate the need to compute the seconds, minutes and hours since passing as you can get that from the . 

You mix UI and logic together. You should extract all the copy code into a separate class and pass in the parameters from the form. This will make your code more reusable (right now you can't write an automated copy program which takes file names from a config file for example). When you refactor then let your exceptions bubble up and let the caller (the UI in this case) deal with them. should probably be more something along the lines (create if not exists). Something along these lines: 

is an odd name - more generally the term is used for a connection of two nodes in a graph. I think your abstraction is a bit too leaky - the algorithm needs to know quite a bit about the internals of the nodes and links (I'm referring to things like this ). I would stipulate you could implement a object with the following public interface and still create independent graph algorithms: 

You really want to look into PDO or mysqli otherwise you leave yourself open for a world of pain (SQL injection attacks). Give your summary column names so you can easily reference them 

Don't have a C compiler handy but you might be able to make that a and still have it all work (saves you a cast). 

Not sure if that is just the case in your example but it's rather uncommon in C# to prefix classes with or . In fact the only commonly used type identifier as part of the type name is usually the prefix for interfaces. Method names in C# are usually naming convention. is used for local variables. Not entirely sure about the whole structure of your code but to me it looks like you should be able to easily move the code into a separate helper class like this: 

will create 2 strings: one from and then the new string created by appending it to the existing string. A will just keep a list of all the strings to append and create one result string at the end when you call . So instead of strings you only create strings. The has the same problem. There are some optimizations in the C# compiler which can transform sequences into calls on a but you should not really rely on this. In the end it doesn't matter too much if your strings a short. However when you hit the 85kb limit then the strings will be placed on the large object heap which can cause problems because it doesn't get compacted and you can get holes. This can lead to weird out of memory situations (you can find more with google). 

Also you are performing the twice repeating the string parts which is prone to cut-n-paste errors and/or typos. You should at least store the result in a local variable. What's the point of sleeping 5 seconds after loading the file into memory? Seems like wasting time. While it's accepted practice to name simple loop counters with single letter variables in your case for the outer loop and for the inner loop would be more appropriate as that's what their meaning is. Looks like your are putting all requests in a queue which downloads all files 1-by-1. If the server permits you could look at downloading the files in parallel to speed things up. 

A classic solution to this problem is to use a data table - in your case probably in form of a dictionary. It depends of what type your values are - I assume they are some sort of view models? I'm also going to assume they have a common base class: One time setup: 

Now the bigger picture stuff: The main issue with your solution is that your UI and logic are very tightly coupled which in general is a bad thing as it makes it hard to re-use the current game logic (try making a text console, winforms or web version for that games) and also not very easy to unit test. One very popular pattern with WPF application developers is the MVVM (Model-View-ViewModel) pattern. The basic idea is that you have a model which is completely agnostic of the UI and the UI just observes the model and it's changes. IN WPF this is supported by something called binding where the UI "binds" the controls to the model which alleviates the need to manually push the data from the model to the UI. It's a big topic so I won't spill out all the details and it would be a fair amount of work to re-work the code according to it but I would encourage you to do so (could make a great series of code reviews here). There are heaps of excellent articles on code project and lots of assisting frameworks around (although you don't need a framework to follow the MVVM pattern). 

Same in your implementations you do - assuming that the beginning of the string should represent the outermost layer (the first thing visible) then this is the wrong way around as well. Similar for . 

This alleviates the caller from having to know the internal structure. I find it quite weird that your ctor for the only takes some very specific components of individual subsystems. From the looks of it the is composed out of and with being part of the and being part of the etc. so I'm wondering why the is not being built like that but gets some very specific subcomponents instead. I would have thought the setup should look something like this (I haven't checked the code on github so the class names are purely guesswork): 

If you invert your if condition and continue with next loop entry then you can reduce your level of nesting. You will currently miss all files in the first (due do the outer condition). You should be able move the recursion further to the top. The shorted algorithm for recursively listing directories goes like this (pseudo code): 

You have already named the variable - I'd say you don't gain much by initializing it via a the way you do it. Just saying would be good enough since it's quite clear what the 60 stands for. Actually, according to MSDN the is set in milliseconds as such your code is of by a factor of 1000 regarding the timeout (why the framework designers have not consistently used everywhere is a bit of a mystery to me). 

What do you gain from it: You can now fiddle with the implementation of without having to touch the method. 

You algorithm yields the sequence A -> B, B -> C, C -> D with a total cost of 7 which is indeed the set of edges connecting all nodes with minimal cost. If you were to use Dijkstra's algorithm to compute all shortest paths from A to every other node you would get: A -> B, A -> B -> C, A -> D at cost 13 (if you do not count A -> B twice) since the path with the minimal cost from A to D is indeed the edge with cost 6. So your implementation finds the set of all edges so that all nodes are connected with the minimal cost. This, as mentioned above, is typically called a minimum spanning tree for which several algorithms exist, most notably Prim's algorithm and Kruskal's algorithm. I haven't checked it in detail but it looks like your algorithm essentially is an implementation of Kruskal's algorithm. So it's not entirely wrong - it just isn't the algorithm you set out to implement. You could rename your implementation to and try again with Dijkstra (if you need help with that then Stackoverflow would be the better place to ask since CodeReview is about reviewing existing code).