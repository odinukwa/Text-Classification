is just . is also very easy to replace. Your makes a class out of what should be a function. It can be implemented like this: 

You should embrace the builtin types Python provides for you. I will show you how you can replace every method in your class with functions based on those. First becomes: 

I'm not pasting the source for , and friends. They are all declared using the keyword for maximum performance. It should be obvious what they do if you know that they operate on a struct containing three float fields; , and . The second less known one is Segura-Feita algorithm: 

what if n is null, e.g an empty tree? How does your tree get started if you can't insert anything in it when it is empty? 

I also recommend you train your ability in converting recursive searches in bst trees to iterative ones using while loops. It is good practice. 

I'm learning Rust so as an exercise I'm trying to write a datatype wrapping the builtin to allow it to store duplicates. Like the STL multimap type. The functions I have: 

Why is this a function? You only need and nothing else if it's not a function. And you won't need the nasty . also makes no sense here. What do you want to do when opening the data file fails? 

And so on. This allows to comment the separate cases and maybe explain what they are doing. It's also easy to modify. You can also put things like in a variable to save space. 

This applies to the rest of the HTML and could be the most important remark: the image you're trying to integrate has been designed with a grid in mind. See how the A, B, C, D subsections are laid out? How "Testimonials" aligns with D? And so on. Using a grid such as Bootstrap or 960 grid will help you a lot here. 

Oops? Use exceptions! What makes your string escaping function special? Why not used a PHP function? Does your function has bugs or flaws? 

will either contain or : you then need to change your CSS to account for this minor change. What's nice here is that it's now possible to get the string you're interested in ( or ). And it's also easy to assign . We'll use jQuery for this. Here's the final untested code: 

Finally, since this is a numerically intensive problem and the list of results is not really needed (since I guess you only need to look at them one at a time and in sequential order) you might want to consider reorganizing things so that you can get away without any allocation for the results array. For, example, we could have the Runge Kutta function call a callback on each result it gets instead of storing it to an array. 

There is nothing fundamentally wrong about your class strategy, it is a matter of personal style really. The only suggestion I would have is to add Object.prototype.hasOwnProperty guards in the for-in loops, to avoid extending your classes with bogus properties if someone adds things to Object.prototype. 

I think your code is fine. I would only suggest a more complex solution only if this pattern happens more often. For example, if you want to refactor to allow for other class names you can do something like this: 

forces you to remember to free the data even though the corresponding malloc is hidden away inside the other function and couples your algorithm (the numeric calculations) with the memory management. It would be preferable if you were free to use any sort of memory instead of being forced into using malloc-free (as you currently are) One possibility is passing the result array as an argument to your function: 

It's often less confusing to use the full path to the functions you're going to call. If see in your code, I don't know what it is. But if I see , I know what it is. It's tempting to use , but don't do it, especially for the standard library. 

Think what you want about the clarity of , but those two functions complicate the code (I need to lookup what they do), while and are standard and more likely to be known by other developers. 

This should work, and there's no reason to change if you validated that it does work with tests. However it would be more Pythonic to actually try saving (without ), then catching the resulting django.db.IntegrityError exception. See EAFP to understand why this is more Pythonic. The happy path will be faster too since you only need to call the database once. 

Raising exceptions with these message would be more Pythonic and more flexible if this becomes, say an module that can be imported. You should also print to standard error. Consider using Python 3 prints (and consider using Python 3 altogether). 

Generally, it is preferrable to put the s at the end of the corresponding printf instead of relying on them being present on the next one. 

Some other properties such as "prototype" or "length" should also always be defined and there is nothing you can do about them. 

Do note that in the previous example you now need to be able to know the length of the result array beforehand. Most of the times this is trivial but in some cases you might need to package this in a subroutine. 

But... your ns variable name makes it look like you are using your object literal to define a module. If that is the case, consider instead using a more general module pattern so you are less constrained in the things you can do. 

Since Lua strings are immutable and interned, this can end up being O(N^2). Instead, put the string parts in a table and do a to join everything in the end. 

Avoiding the use of to reference other functions in your namespace also allows your functions to be passed around as callbacks, in situations where the will not point to the namespace object. 

There's no way to know that out module uses an array internally, but it's still used and allows for very fast code. Benchmarking show that it's as fast as the iterative version, and takes about 0.02s on my machine. Automatic memoization? It turns out that JavaScript: The Good Parts mentions that you can have automatic memoization and uses fibonacci as an example. It can be interesting to try to apply this to our fib_sum, but I'll leave it as an exercise. :) 

I think it's a neat idea, because you're indeed using well-tested code, which reduces the chance of errors. Looking at the API, you do need to retrieve all possibles matches using . Even that one is not a gotcha since you're naming your groups yourself. Right? I can't think of anything else. 

It feels wrong to put both versions of the code in one single function. It would make more sense to have an and function. Your code doesn't work for or . You are lucky your code doesn't segfault. For example, for "a9", temp is only two characters long, and you're writing in nine characters: you're writing outside of the allocated data! You should run throught the string once to see how much memory you're going to need.