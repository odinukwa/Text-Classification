I've been trying to create a program that split few different section of my main OpenCV program to increase fps. The first thing i ever think of is the Pipe() function from my friend. I've tried this 'default' code below in python 2.7 on Windows 10 to learn the basic first of multiprocessing: 

Currently, my system is only producing 10 FPS out of 20, which is my target. I'm barely hit 15 FPS in single grab-and-show simple code like this: 

i thought it was the 'I/O' bottleneck stuff, so i went to Multiprocessing code which is basically polling the frame whenever it is available without waiting for each time camera capture frame to complete (that is what i'm currently understand). but there were no significant different on FPS counter or i must say, only 2 FPS increase. This is my Multiprocessing code: 

After that i went to Raspberry Python 3 to do the same thing, but nothing happen in Python console when i tried to run it. the console cursor just sit there doing nothing beside blinking, but when i try to run it from terminal by typing and followed by file directory, the text just appear like nothing happen. I don't know why, but i'm definitely missing something here. can i actually run this on Python 3? and why the text are not shown in Console that called from IDLE? 

I have couple keyboards now sitting in the desk but somehow it refuse to work on raspi3 Jessie with pixel (genius kb100-holtek semiconductor and prolink usb keyboard) , both tried using powered usb hub and without it. From the list in this elinux website. Instead buying a supported keyboard, can i just install the driver or other stuff to make it work? 

Basically no, you either need a buzzer for simple BEEP stuff hooked to one of the GPIO or using HDMI adaptor that contain an audio jack. for more complex, a bit permanent solution you can build one of pwm based audio like what Bj Black already mention 

I'm currently trying to develop image tracking using color in Python 3 and OpenCV. But i am facing problem in PiCamera. At the moment, i've done some method to fix white balance, shutter speed, and other stuff. But i can't get something fixed yet. i assume it was a white balance that drift. this is my setting: 

In sort. No, you cannot modify IDLE easy enough without dismantle IDLE core code or something. Instead, you can use Geany (in raspberry or linux stuff) or Notepad++ with your own RUN-command. But with a drawback, even this is not in the scope of question. See, the Geany and Notepad++ is only for printing stuff in multiprocessing or multithreading code. It's not mean to be a debugger or some sort. 

i've changed the metering mode to 'spot' dunno if that make a different but the effect seems more predictable in this mode. i already change it to all of it's available option but the white balance? is still drifted in one or other way. 

I get the same problem but only when I shutdown and restart the program right away. I put a one second delay before getting the gpio instance. You can check for null and try again as needed, but it hasn't failed since. 

Not much of an answer but it may help and is too long for a comment. I use this one and it works fine using That's in java just run the part in quotes from the command line. I need to use -p YUYV and max I can get to work is 640x480. If I don't skip around 40 frames the image isn't adjusted for lighting. I'm not taking pics of people's bottoms, despite the name ;). 

No, here are the leds and explanation. $URL$ You could just add your own led to one of the pins. I believe they all go low on shutdown. At least all my relays shut off when the pi shuts down. Searching finds this video, I haven't tested it. $URL$ 

How can I? I want to run a program every few minutes with cron. I read a file of times that I expect pins on or off and then check the state of each pin and set them accordingly. It works fine and leaves the pins in the last set state on program exit. The problem is that it seems like opening the pin causes it to go low. Then it checks the state and goes high (or low as the case may be). This causes my relays to cycle every time. 

I can obviously just put a TimerTask in my prog and that works fine when I run from the command line but not using @reboot in the (sudo) crontab. That's because I block the exit with a loop (read 'q' from console) and I'm guessing there is no console. My last option is to figure out the daemon stuff from apache and do that, but it seems like overkill. 

Just for an update, I've tried looking through the source and it goes to a native call and I got lazy. The whole reason to use pi4j is my aversion to C. There's another problem in that you can really only have one pi4j program running as starting another one erases some .so file and breaks the running program. I've solved the problem for my specific situation by using one program that does everything and implementing a Socket. will prevent the program from exiting and I can control it much easier than using SIGHUP or other signals. Socket.accept doesn't seem to use any more clock cycles than Thread.sleep, so no electrons are harmed using this method. I was able to control everything from halfway around the world. I learned this by watching 24 so I know how to 'open a socket'. Not much coding to do in java either. If anyone needs a multi-threaded socket solution in messy, pre-alpha uncommented code, let me know.