the ObstacleAvoidanceView could be something similiar to (assuming the avoidance is done using a circle or a sphere): 

Please, resist the temptation to write your own ECS system, I've been in you and it is a no-go. But if you have to do so, do it right! 

Once you have pieces of logic, working on Components, then you finally just need one further step to link that logic togheter, and what you need is actually a ECS framework. 

but let me explain why his suggestions arepure gold. ECS pattern is about decoupling all the game logic (yet seems most articles put focus on components, the point is deocupling the logic). 

suggests me that you already spent a good amount of time digging into the topic. While your first point indicates you are on the right way, your second point gives me the impression that you have been hijacked by articles written by people that do not really use the ECS pattern or do not understand the pattern at all (Unity, Unreal and Lumberyard are NOT Using the ECS pattern, neither in its old conception). To directly address your question, I think the best suggestion comes from @Laurent La RIZZA's answer: 

This gives an overview simplified of the design process. You continuosly refine things, because you can't predict everything. I Assumed objects have a position ok, but then after I defined the first piece of logic It was obvious that the bush was missing the radius for collision avoidance. It was not so hard to add it later. This kind of continuos changes are a real pain without an ECS system. And I added a Radius, without warrying if that could interefer with other engines, just because the engines are selected by the entity view, so there is not risk that adding the Radius to bushes automatically makes the bush processed by Radius-realted systems. Bushes are only processed by Systems interested in their EntityViews. If later I want bushes to be only slowing down player, I could altogheter remove the EntityView from the descriptor, and automatically I change bushes behaviour, without having to change engines, or without having to change the Bush. Honestly I think the final syntax in C++ will be quite different from C#, but I believe it is actually possible implement the same of Svelto in C++. 

Please review the usability of this API from the point of view of a developer who uses the API and from the point of view of a developer who implements the API. 

I checked the code with latest JSLint; it is a useful tool once you know what to expect from it, e.g. by reading "JavaScript: The Good Parts" from its author Douglas Crockford. It would definitely help you to spot the missing semicolons, which can cause unexpected issues when you minify your code. 

I may be able to provide more practical suggestions if you show more of your code, especially at the "top", part of the main program. 

Stick to shared conventions for the naming of variables. Do not use all-uppercase for regular variables, only when you wish to indicate a constant value. Use a name specific to your appliation/website, organization or company instead of GLOBAL for the global variable referencing the root of your library, if any: it is no longer needed using Asynchronous Module Definition with requireJS. 

and last but not least, the i18n API part of the Scalable JavaScript Application framework, which I designed for Legal-Box :) 

Like the method in AMD API, which is very similar, the function mixes separate concerns in a single call : 

simple to declare JavaScript modules with dependencies simple to implement your own version of the library to customize its behavior 

For each dependency in the array of needs, a property of the same name is set on the context object which is provided as argument to the function: 

When you implement the API yourself, you may either create a building block on top of the scope bootstrap and other building blocks, or rewrite the function from scratch, replacing the bootstrap and all building blocks altogether. In a browser, you can load building blocks with script tags, then load your own modules: 

I am now considering ways to separate these concerns into several functions and even several independent libraries. For example, could be restricted to a single argument, to cover only the first concern: 

The ECS paradigm emerges as a tool as long as you think your logic in a modular and decoupled way. I think you should seriously take a tour into Svelto.ECS (beware, its author renamed "Systems" into "Engines", I believe to avoid confusion with c#'s namespace "System" from .NET), written in C#. To do that you have to drive away from most of ECS articles you find on the web, I'm sad to say that, because I tried to use ECS "the old way" and it simply didn't worked well, it forced use of anti-patterns and made me wasting time. Most ECS frameworks, don't scale. You start easy and when the project becomes big you enter dependency hell, but you don't realize that because the dependency is hidden by components. With Svelto you just need to start, it seems hard (well it is a change of paradigm afterall), but after you get the first 10 engines done you realize how easy and flexible it is. 

This is deeply different. Basically you can select which engines process which entities without having to resort to specialized components or without resorting to usage of Tags or groups. Basically when you spawn an entity, you have to select in advance which engines will see that entity. You can change that at any time by updating EntityViews in its descriptor, if there are missing components a nice error message will tell you that (I think you can implement that at compile time with C++, I done something similiar in past). Basically you may have X entities in your game that have a Position component, but you don't want to process your position the same, so in example static objects should not even have Systems updating them, so they could just have a method that returns the position without allowing to change it (that method does not implement any logic it just returns data). 

Use a dynamic module loader such as requireJS. You can use it to load modules dynamically using AJAX, and it features an optimization tool to combine your scripts into a single file to reduce the number of HTTP requests on production server. 

You should think about the way you wish to handle the communication between modules. The latest trend is to abstract and decouple the communication using publish/subscribe pattern. You can find more details in The Scalable JavaScript Application Architecture presentation by Nicholas C. Zakas, and you may be interested in the open-source framework that I developed based on this approach, which I presented recently in Paris JavaScript user group. 

To clarify the use of your global variable "collection" as a namespace for your library, you should assign it directly to a value returned by your Immediately Invoked Function Expression: 

I also created extra variables to hold options objects, to enhance readability, and I added comments to describe the intent and parameters of functions declared. Note that trainingDiary is now declared in the private scope as well. If you need to access it in the global scope, you will need to export it to the global object by assigning it to global this or window: 

To use the function, you can write your own or build it from building blocks available in the scope or not project. The building blocks are sorted in levels. The level 1 provides the bootstrap, it must be loaded first. One building block may be picked from each level. Building blocks from lower levels are expected to be loaded first, but they are all optional. Building blocks in higher levels use the function of the bootstrap to define a replacement function "scope", declared as a module. For example: 

You should use the JavaScript Module Pattern to create a private scope for your function declarations: 

The last two parameters and are optional. The name of a module is a string which identifies the module and allows to reference it in the list of needs of other modules: 

When you instantiate a bush you also specify which entity views it will implement, so basically this allows it to be processed by right engines. In example if you want bushes to be avoidable by avoidance algorithm 

Simply use EntityViews like in Svelto. This concept was introduced with that framework. And I really love it. Most ECS frameworks have this dull concept that Components are coupled with engines and every engine should loop all components of a certain type. They should not! Both for flexibility and performance issues! (there are even technical articles from AAA industries that use tricks like skipping updating Systems every X frames because they were basically looping too much). Everything in Svelto is decoupled. Most ECS frameworks have this concept: 

This allows you to implement entities in C++ directly (prefer always this, even though direct memory addressing of C++ allows you to do dirty things) 

Let's me make a premise, I'm actually a consultant, helping a small indie team of quitting dependency hell, I'm basically re-writing a small game (30k lines of code). Turning it into a full-fledged ECS game. And I'm using an already existing ECS framework, not a mine framework. Explaining it is the most difficult part. I'm actually learning new things with every-day problems I face, so I'm not speaking to you as "expert", but as person that is learning. Sometimes I ask questions to the author of the framework I use and he is very willingly to help me and find better solutions to certain problems. Believe me, I come from a C++ programming background, so I always struggled to make my custom engine, dealing with allocation etc. I even started a 3D engine once, I would never do that again. What you are trying to achieve already however: 

You have to write a complete parser (a simple one, but too complex for becoming a single answer) to avoid these issues. You can know if you have done everything correctly luckily: