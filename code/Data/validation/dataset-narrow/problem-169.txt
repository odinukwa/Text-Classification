I would also take this opportunity to make this easier for next time: instead of using fixed IPs for printers (or even APs) give them static DHCP assignments. That way if you ever need to change settings again (a new DNS for example) you'll have a mostly one-stop change to make. Also, if you're afraid of breaking things or forgetting something, you can configure your router such that it has the new 172 IP as its primary, and the old 169 IP as a secondary IP. That way, any device you've forgotten will still be reachable until you remove the secondary IP. The new IP has to be the primary as that's what's used for DHCP relay (on Cisco HW anyway). 

In addition to Ron Trunk's answer, I might add that there are now SaaS-style solutions that put proxy/web filtering functionality in cloud nodes distributed worldwide. This allows you to have centrally-controlled security, but decentralized access which avoids backhauling Internet traffic across your MPLS. So you would implement a cheap Internet link on each site, and use it to send traffic to the cloud node, where it is filtered (policy compliance, antimalware...) and passed on to the Internet. You send traffic either via a PAC file in the browser, via some sort of tunnel (GRE, IPSec) or a combination of both. I've deployed this in some fairly exotic countries, with no major issues so far. We can show that we log everything if need be, and I haven't encountered any places where access to these cloud nodes is wholly blocked, except sometimes in China when the Great Firewall gets grumpy. Performance is sometimes problematic though, particularly in Latin America and Africa, but way better than the alternatives. 

You can use an application called to make use of USB to serial cables. There is a 4x serial -> one USB available which would cover 4x switches. That way you get virtual USB ports like ttyUSB0, ttyUSB1, ttyUSB2, ttyUSB3. You can then map these USB ports to TCP ports like: 

When the switches receive this BPDU with TC set, they will shorten the timeout of the MAC address table to flush out stale entries. The timeout is then set to 15 seconds, so stale entries will be removed but active flows will be relearned through the now active ports. If using 802.1w then there is a synchronization process through a proposal and agreement mechanism. With RSTP, only ports moving to forwarding can create topology changes. This makes sense since only adding connectivity should be of concern. With a RSTP switch, when it detects a change it will set the TC bit in its BPDUs, the switch receiving this BPDU will then flush all MACs learned except for the port on where the BPDU was received. This will repeat throughout the network until the topology has converged. There are some more details in some of my blog posts: Topology change RSTP synchronization MST convergence STP convergence 

Using VRFs is easy but depending on the size of your topology can get messy if you only deploy VRF lite. VRF lite is the use of VRFs without using MPLS. If you don't have MPLS you need to run your IGP (OSPF) in vrf aware mode. So for every switch that you have you need to create an interface in the VRF that is used for peering OSPF with the other switches. So say that you have a topology like: 

The problem with this is that you have the router providing the byte count when it receives the poll request (and it may be counting bytes as they are queued, not necessarily as they are emitted), and the tool counting time when it sends the poll request. This allows for all sorts of fun problems with buffering in various places that can lead to unexpected spikes in the data because you end up violating the unstated assumption that time delta between byte count values is the same as between the polling requests. You can also get issues with counter resets and rollovers, though most tools are good at detecting that. 

Those are actually two separate issues with completely different types of solutions. Handling dynamic public IPs can be done with a standard OpenVPN configuration (no DynDNS). Once the VPN part is in place, you should NAT each LAN to a distinct private IP range, such that your workstation thinks it sees different remote LANs. So if all the LANs use 192.168.1.0/24, you would map the first one to (for example) 10.0.1.0/24, the second one to 10.0.2.0/24, etc... Without knowing more about the specific hardware, it's hard to say whether this is best done on your central gateway or on the remote site gateways, though. 

On the other hand, I think it's less and less clear that wifi-level encryption on a public/guest network is all that useful since most apps that really need the encryption already provide it at their own level, typically through HTTPS. The era of unencrypted passwords passing over raw POP3 or HTTP for example is (thankfully) nearly past us I think. 

3 routers sounds like overkill to me but it would be interesting to see the topology and hear him explain the reason behind it. Depending on your requirements for redundancy and/or loadbalancing a 1921/1941 could be fine for your needs. That would be only one device because it has both routing and switching if you stick a HWIC Etherswitch card in it. The high availability design would be to have two routers and two switches but then the servers should be dually connected as well. 

The first command enables Portfast on all access ports. When BPDU filter is applied globally, the difference is that it sends out 11 BPDUs before going silent. Because normally one BPDU is sent out every 2 seconds and the default MaxAge is 20 seconds that means that if there is a device at the other end that can process BPDUs, at least one BPDU would be received when the old BPDU (if there was one) has expired. If a BPDU is received inbound when BPDU filter is applied globally then the port stops filtering and it will lose its Portfast status. The BPDU guard default command will only apply to ports that are in a Portfast operational state. If you combine these three commands together then what will happen is that when a BPDU is received the port loses its BPDU filter, BPDU guard can then kick in. The port will never lose its Portfast operational state because the port is shutdown before. So you see when applied to the interface BPDU guard can never kick in but if you apply it globally it can. If you run just Portfast globally and BPDU filter globally then if a BPDU comes in, the port loses the filter and loses the Portfast operational state and will operate as a normal port. 

We use the 6001 as a small core in a context which sounds fairly similar to yours, a small datacenter where a 7k is overkill. It's turned out quite well for us in that role, however we do regret not getting the Enterprise LAN license initially, as we eventually required some more advanced routing features (BGP especially) that we did not have and adding the license after the fact turned out to be costly. I have not had a chance to investigate its capabilities in a more "up to date" SDN-style datacenter. But for basic DC L3 duty connecting server VLANs and DMZs, mostly statically, to a DC Firewall, it works just fine. 

In the Cisco world all that gets handled by the WLC, usually as a set of physical appliances, but there are other manufacturers which split this up, such as Aerohive, where the config server may be in the cloud, the radio management part is handled in peer-to-peer fashion by the APs themselves and you can get a sort of vpn gateway for tunneling traffic back to a central point. 

The output includes a section called "DFS Blocked Frequencies" which should be what you're looking for. See: $URL$ 

You might want to give RFC 2488 a look. It addresses your question and offers recommendations to alleviate the effects on satellite links. $URL$ Enhancing TCP Over Satellite Channels using Standard Mechanisms 

For that reason I have been contemplating the upcoming Catalyst 6880-X with SUP2T or even the Catalyst 6500 with SUP2T. I am a bit uncomfortable putting an "enterprise" switch as a PE device in a provider network though. 

Usually NAT will be used to translate between private to public IP address but this is not the only use case. You can also translate between any addresses you want such as private to private. The terms local and global most often refer to the inside and outside of your network but this doesn't mean that it MUST be LAN and WAN although it often is. So say that we have a webserver on our LAN with the IP 10.0.0.1. We want the webserver to be accessible from a public IP of 130.130.130.130. 

BPDU guard will never kick in because BPDU filter is filtering both the outgoing and incoming BPDUs. This also means that the port can never lose its Portfast status which it would normally do if BPDUs were received inbound. If you remove the filter then BPDU guard will kick in and shutdown the port if a BPDU is received. This is done before the port can lose its Portfast operatational state so basically the port will always operate in Porfast operational mode. If you apply the commands globally instead: 

Here the cost is 10 to reach the two ABRs. Because the cost was 11 from the ABR to the destination that should mean that R4 has a metric of 21. 

You can query the switch via SNMP to read the ifLastChange field from the standard MIB-2, which gives you the value of the sysUpTime counter when the interface last changed state. You have to read the current sysUpTime value as well to make sense of it, of course, and I recall there are some caveats if that last change is too far in the past because the field is a 32 bit counter counting hundreth-of-a-second ticks. I don't believe you can do the same directly from CLI, but you can implement object tracking on the interface state to get the same result. 

The issue is that you end up comparing unequal things when you say "I would express the range as 121.34.56.64/24 in prefix notation" The range 121.34.56.64 to 121.34.56.128 is contained in 121.34.56.64/24 (which is actually the 256 IPs from 121.34.56.0 to .255), but the two are not equivalent. The reason that 121.34.56.64-128 cannot be expressed as a single prefix is because of that last 128 IP. Up to 127, the 25th bit of the IP is a 0. At 128 it becomes a 1. As a result, a single mask covering all those IPs can only be at most 24 bits long, and that results in a longer IP range than you are looking for. So the best you can do would be 121.34.56.64/26 (from .64 to .127) and then add a .32 to cover that last .128. The other examples are similar. If you manage to find a single mask that covers all the IPs in the range, you will find that it also covers a bunch of other IPs before or after the ones you want. So to cover these ranges exactly, you need to assemble several smaller IP ranges.