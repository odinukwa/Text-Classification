Different approaches to determine the domain membership of a computer Usage of command line tools If you use command line tools you have the burden to parse the output of the process. A naive implementation to execute command line tools in windows: 

Try to separate input from processing from ouput Try to separate the datastructures from their representations Try to introduce proper abstractions (console ouput, history) Try to avoid unfavourable polymorphism that will offer concrete type information in the abstraction (Action enum) 

Maybe you have to think a little bit more about the caching scope. It's not that easy because most developers tend to simply store expensive objects near their first occurance. My advice is: NEVER cache at the first place. ALWAYS formulate your statements as they are NOT EXPENSIVE. After that you can go on with an optimization... ... that should be transparent to the existing implementation ... and has a well defined scope to match the use case requirements 

First of all MVC is not a "real" design pattern as it lacks atomicity. It's something that adresses some points of the SOLID-principles, especially the single responsibility principle. Furthermore you may use design patterns to realize MVC. If you follow the SOLID-principles carefully you will certainly come up with this 3-class struture in your usecase anyway. Secondly you apply the MVC correctly. It's good to have a starting point that is more concrete to most of the developers as the SOLID-principles. These developers will produce better code if they use this "best practise" as I would call it. This "best practise" provides a good balance between productivity and code quality even though there are many more improvements possible. One example: Currently two classes are technology dependent: Student_View and Student_Controller. Both know Swing as the UI technology. It's better to have less classes depending on technology. A naive way is to melt controller and ui to have only one class. But that violates the single responsibility principle (S in SOLID) as the class wil get MORE responsibilities as it has before. We would take a step backwards if we do so. So the task should be to preserve responsibilities AND decrease technology dependencies. How to do that: Use the listener pattern! Let the UI implement the Listener-Interface and register it in the controller so the controller does only know "Listeners". The principle applied here is "dependency inversion" (D in SOLID). What I want to say is: Yes, you did apply MVC correctly. But is this the core? No. Is it the end? No. It's something you will come up with as a intermediate result if you use the real design patterns mentioned in this book (Design Patterns: Elements of reusable Object-Oriented software) AND apply the SOLID principles and the law of demeter correctly. Some points to your code in detail: 

Conclusion You do not always need a library X or a special API. Simple language mechanics and expressive names for methods and classes will mostly do the job as well. Of course the need for the concurrency API rises by the "complexity" of your requirements. In this case I do not see any need. 

As length and/or width will mutate in the method "numberOfBlocksOfTheLargest..." a Chocolate cannot be found anymore within hash-based collections like Set or Map. Currently you aren't facing the problem because you only iterate over all elements that are within the Set and no hash-related operation is performed there. Equals and hashcode should only base on immutable values. In this easy example you may get over it. In real applications you will face serious problems. In one of the projects I was in I saw objects occasionally diappearing during a serialization process. Objects that were available on a rich-client were not available anymore once they were sent over the network through serializing and deserializing. The problem was a weak implementation of equals and hashcode. They based on mutable values. The only way your hashcode-method can be implemented without having these side-effects: return -1; (or any other constant). But this will hack the intention of hashcode as your performance of your contains()-method will be linear to the amount of objects the Set contains. Naming input1, input2, input3, ... you can do better ;-) Your task was to simulate chocolate distribution. So why not changing the class name from "CodeCandidate" to ChocolateDistribution. Multiple return statements Try to use only one return statement per method. If you do that you can easily apply refactorings on it like extract method. Code location I would pass the chocolate carton into "ChocolateDistribution" instead of creating it inside. Recursive algorithm As the problem has a recursive nature I'd prefere a recursive solution. But that's only an opinion. Privacy length and width should be private. Code Here is the code resulting on my suggestions: 

Those methods should delegate their requests to the controller and the controller should tell the UI what to do. For example: currently you will confuse a developer where to put the logic when adding a requirement that will avoid closing under special circumstances. 4. Make the controller the responsible to orchestrate The controller should be responsible for requesting the UI to put itself in a specific state. So the controller should be the constructor parameter of your UI and it should not be set by a setter. The controller lives first, then the UI. This is because it may not be necessary to show a UI through business rules of the business model the controller asked for. Remove "void addController(...);". 5. Avoid "System.exit(0);" This statement makes either no sense or it is hiding programming errors like running threads that have been forgotten to shut down. To make it clear: System.exit(1); can make sense if you want to communicate an error state to the OS. Use following to let Swing disassemble your UI when the closing request was initiated via X: 

LogService The LogService will delegate all public calls to the state pattern. It provides a queue that will buffer log messages. Initially the LogService is in the state "StateStopped". You see that we changed from a blocking queue to a normal queue that is not thread-safe. But that is ok as the LogService serves as a monitor around it beside the other two variables loggerThread and state. LogTarget may be access concurrently but this is not our responsibility AND we can only ensure the correct implementation by convention. 

You should always let hashcode and equals methods rely on IMMUTABLE values. In complex environments you will have a hard time to identify such problems. I already faced such a problem in a serialization/deserialization process as not all objects were deserialized again. Semantic of class "Contact" That relates to the previous point. Either you do not provide setters for "name" and "phone" OR you should rely on other attributes. I suggest to NOT override equals and hashcode and externalize the equality check into a separate method or class. "Contact" in business application seems to be a "business object" or a "domain object". Overriding equals and hashcode using all available fields for evaluation will implicitly make an object to a "value object" with "immutable values". Every business object has its own identity NOT depending on attributes under change. They have a unique id. If you have consistency requirements like "unique name" you have to expernalize this check as a "constraint". Most developers go too fast with hashcode and equals. And if it applicable it is not used. This is because the decision when to rely on hashcode/equals mechanisms is very difficult. Comparator Separate the concern of comparing. Prefer Comparator over Comparable as you will be more flexible to add comparison aligorithms that compare your object under a different aspect. 

Use lazy initialization You currently separate the component creation process by immediately instantiating the component at the variable declaration and configuring the component elsewhere. Component creation and configuration should be encapsulated in lazy getters like this: