Just be careful about what size characters you use (16 bit only). If you have to use a full-out string, consider the solution in this answer. I suggest this because your output code would benefit from having "concrete" values. (The rest of your code is happy with the CellType being an abstract enum.) 

You can replace with or whatever function you like. But it will make automated testing easier if loading your module doesn't automatically trigger a game. Scope You are accessing data as a slightly higher level than I'm comfortable with. I think this will make things tougher for you when you try to provide an automated opponent. For example: 

And squeeze out another lookup. But wait, there's more! Because before you start doing that "peephole" optimization stuff, you need to look at improving your code in some other ways. Take a look at this: 

Connecting to other parts of Python Finally, I'll point out that your code doesn't "connect" to other parts of Python. Python's string formatting provides extension points for this purpose. You could create your own subclass to add a conversion flag. Likewise for logging. There is no "locale" support in your code. For example, if the current language is French, what do you do? Also, there's a difference in UK vs. American English with respect to "milliards" and Large Number handling - can you switch? Should you abort, or fail, or ...? How about (im)precision? If I give you 1000000000000020, can I pass a flag that allows you to skip the 20 and just truncate it to the nearest billion? Or perhaps the nearest 10%? How about access to internal data? If I pass a number, can you give me just the largest power-of-1000 word? So I can get "trillion" and print "1.2 trillion" myself? 

You haven't provided any kind of interface for moving, nor checking moves. So I'm going to suggest a generator. Since moving is unique to the piece, this will be a subclass-specific method. The class cannot represent any actual piece, since they all have unique moves. That means is an abstract base class and should be marked as such. (Via the module.) Many of the special moves are one-use-only. That means pieces need to know when they move, and how they move, so they can track their own internal state. I suggest adding a attribute to the class since this a widespread requirement (pawn, rook, king) for special moves. I suggest that a method on the class should handle adding and removing threats. I suggest a method on the class can be used by the pieces to evaluate moves. 

I have some issues with your coding style, and possibly with the guide you are using. There's a lot of Java in your code. Consider this: 

I assume that the search conditions have been parsed into as one-token-per-string in the vector? That is, for search conditions like "a + b < 10 OR c = 1" (your example), the vector looks like . I assume that the type contains a called . You also don't specify if you expect the resulting tree to be a binary tree or not. Your code is written that way, but it doesn't seem to be a requirement. Other than the relational operators, the rest of your operators could easily handle more than two operands: , , etc. I assume that the tree must be binary, since you coded it that way. 

This is automatically wrong in almost every case. If you want to iterate over the possibles, then iterate over them! Watch the talk, and then write: 

Finally, you have interacted with the user and received a choice, so update the narrative. Maybe your iterator has a method, or maybe your narrative does: 

Count the number of times appears in the code. (Two times.) Now count the number of times appears in the code. (Three times!) Whose method is this? Your code is violating the principle of encapsulation. You are "operating on the hero" instead of "interacting with the hero." There is another maxim of OO programming: "Tell, don't ask!" Instead of asking for properties and asking for and reducing the hero's hit points, just tell the hero you hit her, and tell her how much damage to take: 

You could use a kd-tree or a space partitioning hash of your own design to access your points. This would make pandas secondary in your access, requiring you to write more python code yourself. You could take advantage of some other heuristic to determine proximity, and use this to filter your data before running your n² algorithm on it: note that 3² + 3² = 18, while (3 + 3)² = 36. Breaking your data down into smaller units can have a substantial impact on your performance. For example: in the United States, zip codes within a given state all start with a few identical 2 digit prefixes. You might build a dictionary of "adjoining" states, by hand, and then pre-filter your locations using a zip-code prefix, such that you only consider other points that have the same 2-digit prefixes, or the 2-digit prefixes of an adjacent state. If your locations were US cities, this would let you eliminate more than 90% of your data before you start your n² algorithm. There are surely some other approaches, which will tend to vary based on your application. Perhaps if you mention what problem you are trying to solve, someone will have a suggestion. 

So you're inside , passing a function as a command to a button. But inside the function, you have to look up a global variable to figure out the value of ? Try passing a bound method, or using a closure, for this kind of thing. 

In your loop, you are setting the status from the event loop, but that won't affect anything until the entire loop is completed. I'd suggest moving that code down to the bottom of the loop. Your code calls this line: 

See the difference? N is N. There are operations that can be 0 or 1. Guess which is the operation? And there are parameters A and B, clearly marked. I haven't changed how it functions, but someone reading the code can now refer to the instructions and see what's what. Adding Faster Next, let's look at your two operations. Here's your first one, counting the 1 values: 

This is because a loop would run a fixed number of times, but it's possible to win in 5 moves (xoxox) or it might take 9 moves (xoxoxoxox). Since you don't know how many, you want to "keep going until something changes." That's a while loop. In addition to that change, I'd like you to find places where code is copied, and convert those into a function. For example, all your checks of , etc. The principle is called "DRY" for Don't Repeat Yourself. It applies in a lot of ways, but this is the most basic: if you write code two times, make it a function (or a macro) and maintain it in one place. If you make those two changes, I think your code will be a lot smaller, and easier to understand, and easier to review. I'd encourage you to submit a new review with that code. 

This is an older coding style, but one that serves a useful purpose - it makes it possible to find your function definitions using . is a description, not a name. Try to use imperative phrases in your function names: or . You have these nice constants: , but you don't use them! What is "3"? and are not meaningful names. How about or or and or or ? Especially since you're not using the and constants, the only way to understand what or represent is to search for the one line in the function where they are used, and map that against the signature: 

Next, fix the name of your function. This is a function not a procedure. You aren't performing some "helper" operation and leaving your results in global variables or class members. You are performing a computation and returning the result! Pick an appropriate name: 

These functions don't "do anything." But they tell the other what their type is, by calling different methods. So when checking for a generic "collides", they respond by saying "You don't know what I am, and I don't know what you are, but I'm a circle. So I'll call your method and tell you that." Implement two methods on each class that handle colliding with the particular other class: 

Your code looks at every value, and if it's 1, adds 1 to the count, and if it's not 1, adds nothing to the count. Now, think like a programmer! Ask, "how can I get rid of any of that code?" In this case, what happens when is not equal to 1? Why, then, it's equal to 0. And what happens when you add 0 to any number? Nothing - the number doesn't change. So you could change that code to: 

First of all, ask yourself: do my conditions constitute a complete partitioning of the possible input values? In this case, no. There are two other possible input conditions: or . In the case of , all you have to do is pick one branch and execute it! In the case where neither input value matches, you need to raise an exception or provide some default values or something. Worse yet, consider that integer 0 is falsy. That is, when you have a value and you say it is going to evaluate as a falsy condition. And when you have a value and you say it is also going to evaluate as a falsy condition. This means that if, for example, someone were to compute on the fly, like: