This can be improved even more by separating out the rows that can be vectorized from those that can't. 

You can improve this further by making the column list comprehension a expression. I think this will give this a space complexity: 

Assigning a numpy array to a numpy array is faster than assigning a list to a numpy array. So is faster than . It is a little faster, and in my opinion cleaner, to use for numpy arrays instead of (or in your case versus . You can use in-place operations more. So instead of . In my opinion it would be cleaner to have two loops, one for , the other for . This will save you an indentation level, and a comparison per loop. You add, then immediately remove, from . This seems redundant. I would use another variable there. You re-do some of the math several times. I think it would be better to switch variables around. You can tell what all the idx values will be ahead of time, so you can pre-compute them. You can pre-compute the range and re-use it. 

There is no reason to keep track of all moves that result in a draw, you only ever use one so it is better to just keep the first. It is considered bad style to have one-line code blocks, such as one-line tests or loops (ignoring ternary expressions and list comprehensions, of course). For things like tests and loops, put the or on one line and the stuff after the on the next line. You convert back and forth between a and a lot, but you never use any string features. I think it would be better to just keep it a list all the time. This will also improve performance. This would also allow you to use slices for the wins. You only need to asses the player that moved last, so you can specify a player in and just test that one. I would do (on separate lines) so you can reduce the nesting level. I would split the winning test portion of into a separate function and have the recursive portion call that function. And again, you only need to check the player who moved last. An is valid in this case, but it seems a bit overkill. Everywhere else you use strings, so I would do the same. I would use a to handle the result of in . I would have just one big list, rather than three. 

and are not very big (on the order of tens of megabytes, tops). You can vectorize those and re-use the values. In fact, they are identical, so you only need one. You not only never use the other values of and besides the current one, you overwrite them repeatedly. So these are better off as scalars. You can vectorize many of the values for the two innermost loops. If you put the third loop as the outer loop, you can vectorize and . 

Rather than using lists, I would just make the variables numpy arrays. You can slice the values you want from using syntax like . Your indexing is really slices with a step size of two. So is , is , is , and is . Numpy is much faster with these sorts of slices rather than using the direct indexing you are using since with these slices numpy can avoid making a copy. Since everything is done in steps of 2, I think it would make it even easier to first reshape to a 3D array, where the last dimension determines whether it is a or variables. Then you can use unpacking to put the columns in the right place. You can use to combine all of your 1D arrays into one big 2D array. This can then be written in one step using . Better yet, you can use a slice for the last index of to end up with all 2D arrays, then just them to get one big array. This avoids having to unpack at all. I prefer the syntax of since I think it makes the flow easier to follow for people who read left-to-right. 

Some suggestions: Empty lists are , so is the same as . is also , so you can check for empty lists and values at the same time. You can use to get a value and set it to a default (in your case an empty list). if it isn't already there. You can convert an loop to with a generator expression, or better yet just a . Your last two tests are mutually exclusive, so the last can be an . The test does the same thing in the first line of both cases. I moved that out of the test, but if they are supposed to do something different you should fix that yourself. always has its value subtracted by one, so it is easier to subtract one before defining it. You always set to if is non-empty, so you can move that out of the test entirely. And if you put it at the beginning of the loop, you can avoid the test entirely. You can simplify this further by only getting it if you need it. 

Probably better to follow pep8 This isn't a method, it is a function When doing 2D indexes, you can do You don't really need a numpy array, a list of lists works just as well. Or better yet just just translate the 2D index into a linear index mathematically. This also avoids the substantial overhead of converting the list to a numpy array. You could even use to do the 2D to 1D conversion for you. 

See that index of the last dimension has all the odd columns, while dimension has all the even columns. Now let's do a in this case instead of a . The semantics are the same, but it is easier to follow in my opinion. We will take the of dimension 1, which is what used to be columns, but now is the columns split into even and odd: