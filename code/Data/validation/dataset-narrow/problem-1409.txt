iOS and Android combined are large markets, with OUYA and NVIDIA Shield around the corner, Android is definitely going to be a hot spot to consider since minimal changes can be made to support these platforms. However, don't limit yourself because you like a specific platform, put that game on anything with a screen and an input device. SDKs aside, if you want to maximize your audience then you should consider getting your game on Kongregate, Desura and if you've got something great, Steam Greenlight. You've also got console opportunities with PlayStation Mobile although I don't know how large that audience is. 

The answer is that it is probably possible with a great amount of reverse-engineering effort (but what isn't?). There was an interview with Todd Howard on this topic and he said that identical content could run on PC/Xbox 360/PS3. The problem is that there isn't a means by which you can get the modded content back onto the console. This has nothing to do with running signed vs unsigned code, this has to do with modifying the data files and stuffing them back into the game. There simply isn't a way to do this on the console. You could try installing the full game on the 360 hard disk and then grab some linux FUSE drivers for the 360 filesystem ($URL$ This would at least give you filesystem access, from there caveats are sure to abound. 

Almost, but only half of the pixel. Just subtract 0.5 from your quad vertices. E.g. you want 256x256 quad with same texture, here are your points: 

In case of simple instancing (many same objects) you will need to update per instance data and amount of instances to be drawn according to results of your occlusion test. In case of glMultiDrawIndirect, however, you may update "count" parameter (set it to = 0 if object is not visible), but driver will, most probably, still issue an empty draw call. But you may as well update the whole array of structures containing the draw parameters. You might be interested in GPU based occlusion, like one described here starting at slide 35. 

You can either work with pointers, but make sure that they were correctly allocated/destroyed. This way your Get and Remove method will be simpler. You can just return nullptr/NULL/0 instead of constructing and returning dummy object. If you do not want to use pointers than you can have dummy static object inside your scene class and return it. But you still need to make sure that your ordinary objects are not going out of scope. As an example, Get/Remove could look like this: 

I agree with petterson, but if you want to reduce amount of draw calls as well you need to use instancing. 

You may want to look at some of the common javascript game loop patterns that exist. Most folks use a timer to schedule the game loop. This resource is excellent: $URL$ If your game isn't multiplayer you can likely use what the author calls "another naive game loop". 

The standard way of doing this is to pick a class that you know should exist and then see whether it does: 

On the Apple market, your game most likely won't pass review because they have a descent legal department and they will force you to change your name unless you can prove you have rights to Guess Who. If you were actually published then the entity that owns rights to Guess Who would have the option of filing a DMCA takedown request on your app. Your app would then be shutdown permanently pending a counterfiling by yourself. See the pretty info-graphic here for the remainder of the process: $URL$ 

No. Designing a game engine will teach you how to create a game engine. You could spend a year writing a rendering engine that handles vertex and pixel lighting, refraction, reflection, lens flare etc. At the end of the year you'd probably know a whole lot about rendering but nothing new or significant about actually making a game. If you love the concept of game engines, make a game engine. If you love games, pick an engine and make games. First, figure out what you love. 

If you create it once and will not move a lot of stuff around each frame, there is nothing bad in it. It all depends on you usage. 

Also while AlignedByteOffset is optional i suggest at least use D3D11_APPEND_ALIGNED_ELEMENT to specify that data go sequentially one after another. so, setup code will look like this: 

For this you need to identity what mesh is currently being processed. If you need to draw many same meshes (say a lot of stones, or grass) you should look into Instancing (e.g.Efficiently Drawing Multiple Instances of Geometry) there you basically have one stream which has mesh data similar to all objects(vertices, tex coords etc.) and another which has per instance data (like object positions in the world). Both OpenGL and DX have support for instancing. OpenGL (since 4.3) also has very cool function glMultiDrawIndirect (or chapter 1.3 here) which allows to do what, I think, you want - draw several different objects using only one draw call. This is "more advanced" instancing, you pass array of structures describing how many instances to draw and where to get data for them in your buffers. See the description it is quite clear. However, you need to use same shader for all of the objects because you cannot pass "shaderid" in your per instance buffer. But you may write a generic shader and based on gl_DrawID (passed to your shader by OpenGL, has unique value for each instance) do stuff that you want. E.g., you may construct uniform array and index it based on gl_DrawID. You can do the same if you need different textures per instance. In this case you can create texture array and index it (note that in this case all textures have to have same size and format). You also may try to use bindless textures (OpenGL 4.4 :P). 

One reason you would want to write a game scripting engine is if you wanted your engine to run on multiple platforms. You could then separate programming concerns into the low-level platform details and the high-level game. Imagine you've written a game that supports PC, iOS and Android. Now you want to put out a major update to the game. Having all 3 platforms share a common scripting language could be the difference between copy/paste and serious programming effort. 

I am considering different game server architectures that use GAE. The types of games I am considering are turn-based where the world status would need to be updated about once per minute. I am looking for an answer that persuades me to either perform the world update on the google servers OR an authoritative server that syncs with the datastore. The main goal here would be to minimize GAE daily quotas. For some rough numbers, I am assuming 10,000 entities requiring updates. Each entity update would require: 

I'm trying to associate this with something that I understand, so I'm thinking in terms of Minecraft right now. I'm picturing a live server with players making changes in real-time while the developers are running on a test server fixing/creating new content. Your question almost seems like 2 unique questions: 

It may look like a lot of code, but this is all very simple operations and you are not dependent on light move direction (actually your light can be at any cell at any single moment). Also (as optimization) you do not need to scan all array - only in some radius around light (radius depends on how fast the light fades out). You can check out my resulting image (only case for one quadrant, other are done similar) 

Or, you may instead add half of the texel in the pixel shader ( texCoord.rg + 0.5*(1.0/texSize) ) Half pixel offset is a known fact in DX9. This and this articles may help you as well. 

As you've, probably, noticed. For quads we have 4 outer tessellation levels and 2 inner. Because, surprisingly :-), we have 4 edges and 2 dimensions to subdivide inside quad. If you calculate tessellation levels dynamically (e.g. based on distance from camera) care should be taken to set correct index in gl_TessLevelOuter/Inner. Otherwise, your mesh might not be watertight. OpenGL uses next convention (which, by the way same as DirectX uses): 

This is just one of the possible ways. Probably you don't need so many events. And I am sure you can do better knowing your data, this is only one of many ways. 

From personal experience, no it is not legal. Never ever use the name of a company or product in your product name. Examples of bad names: 

According to the book Real-Time Cinematography for Games, the fastest but least accurate way to do this is by calculating the projection of an object's bounding sphere onto the viewplane of the camera. r = f*r_w / (v . (p_w - q)) Where: f = focal length r_w = bounding sphere radius of the object v = normalized camera direction p_w = bounding center of object q = camera location . = dot product Finally, the area of the object on the screen space is: a = PI*r^2 Similarly you can project the 8 corners of the bounding box onto the screen plane and calculate the bounding box area. 

With the sale question aside, yes. Using a tool you are familiar with is always a good choice. You should make a list of all the items that you are unsure whether RPG Maker can do. Post on their forum and ask if they are possible, you will then have a list of critical issues and what their resolution is. If one of these critical issues is a deal-breaker, re-think that portion of the project. It's better to know up-front than hit a critical issue in the middle of production. I encourage you to start and finish your project. At the end you will know better than anyone what the strong/weak points of RPG Maker are and whether or not you need a better tool and/or a programmer for the next project. Also you might have an easier time attracting a programmer if you point to a finished project for them to see you are serious. Considering selling on Steam. First you need to research RPG Maker and possibly contact them to see what their distribution license is - this will guide how you use their provided assets i.e. this faq. IMO, the payoff for the first project might simply be to finish it and attract more like-minded hobbyists (just from personal xp). 

Also, I am not sure how do you iterate through your 2d array and it is hard to see what is solid on your images and what is not. I thought this was a nice effect so I did this :-) One possible way: we need to go opposite to light. there are 4 possible directions 1) right, down 2) left, down 3) right, up 4) left, up Here I show only one for right down, others are similar (just switch + for - where appropriate). I use texture of unsigned chars [0..255] 

Basically, what Xnafan told is one of the possible ways to do it right. What (I assume) he wanted to say is: 

Quad tessellation is similar to trianlges. The difference is that instead of barycentric coordinates gl_TessCoord.xyz which define point on a triangle (tcPosition) you have 2-component coordinate gl_TessCoord.xy (they also span in [0-1] range). Hull shader (or Tessellation Control Shader in OpenGL terminology) looks pretty straightforward: 

Not sure if composition will solve all the problems. Maybe can partially help. But if what you want is to decouple classes I would look into more events driven logic. This way e.g. you'll have OnLoot function which needs to have player position and info about loots available to find the closest. Then function sends event to the looted item. Looted item in its event process cycle handles this event so item only needs to know how to update itself. OnLoot function can also update player inventory or item itself may send updateInventory/*OnLootSucess* event and player/inventory will handle it in its own process events cycle. Pros: you've decoupled some of your classes Cons: added events classes, maybe unneeded code overhead. Here is one of the possible ways of how it may look: 

A Finite State Machine would seem to fit this type of flow. Users can easily understand a FSM with very little explanation. You might organize individual states such that they have entry and exit events. For instance when you enter the state, graphics/text xyz are displayed. The exit conditions for each state are simply the choices that the user can choose from. Based on the choice made, you enter a new state or possibly loop back to the existing state. 

Clients of the game would authenticate and set state directly against GAE as well as pull the latest world state from GAE. Running the update on GAE would consist of a cron job launched every minute. This would update all of the entities and save the results to the datastore. This would be more CPU intensive for GAE. Running the update on an authoritative server would consist of fetching entity data from the GAE datastore, calculating the new entity states and pushing the new state variables back to the datastore. This would be more bandwidth intensive for the datastore. 

I would try solving #1 through a temporary referencing system. For instance, when a new object is created by someone, it could be marked as volatile or temporary. I would imagine that all new content created on the test server would be marked volatile (although it may also reference non-volatile content). When you're ready to bring new content to the live server, your import process would find the volatile objects and assign them live-server object IDs that are set in stone. This is different than a straight-up import/merge because you need to be able to reference existing non-volatile objects should you need to fix or update them. For #2, it seems you really need to have some level of intermediate script transmutation that can hash the function name to a unique namespace. i.e.