I noticed that you tagged the question client-server, so I assume you're also asking how to physically distribute the patch. Depending on your budget, the easiest for users is to simply provide an HTTP download on your website, but this requires the most bandwidth from your server (patch size * games purchased), a slightly less user friendly option is to upload your content as a bittorrent and run some seeds from your servers. This reduces bandwidth requried on your server, but will be more of a pain for your users unless you are like Blizzard and have the resoruces to build a bittorrent client into your game. The bottom line is that it depends on how large (MB/GB) your patch or update will be and how much money you have to throw at a server and bandwidth to distribute your patch to end users. From a software perspective, there are many ways to distribute and install game updates, but in general you should stick with the methods used by traditional software. Have the user download an update installer, which knows how to prompt the user for adminsitrative access to their machine and copy/update files as necessary checking versions (user may have skipped v1.1 and installed v1.2 directly). 

Might I ask, do you really need a globe? Is your world small enough that the curvature would be visible? Why not approximate the globe with a bunch of rectangles? It will make your life easier, and presuming your world is large enough and if implemented well, can give the illusion of a fully connected world to boot. Think of some games which have large open worlds, for the most part, they consist of "zones" where each "zone" borders other "zones." There is typically ocean surrounding groups of these "zones" which the player cannot manually cross, but the player is free to walk from zone to zone without restriction. For example, think of WoW's two continents and the dividing ocean. 

Not sure how popular it is now, but before Counter-Strike: Source (and even somewhat after), there used to be loads of what were called "rats" maps. Basically they were maps where the scale and texture of the world was designed to make the player feel like they were a rat in a kitchen or some other environment. While the gameplay was generally still very Counter-Strike like it may not be what you're looking for, but it may help give you some ideas on general concepts of the player being in a world where every day looking objects are huge. 

Decide how many "biomes" you want and of what type Define the size of each biome Go through your world array, and pick a start point for each biome Update the world array with each biome's tile data 

Depending on your server platform there are different tools to monitor this data. The reason to monitor these, is because they directly impact performance and they are all finite resources on any given server. If you start maxing one of these out, you need do either, add more of that resource, re-write some of your application to work within the limits on your server. 

Disclaimer: my game programming experience is based around client-side single player games, but I have a background in web applications (specifically on the Microsoft stack), so that is where I'm coming from with this answer, I feel that much would apply, but without actual testing a real game server its difficult to say how it will apply, but here goes. Know this: I haven't deployed a game server, only webapps. I would suggest a two (server) tier approach. A database tier and an "application" tier; with the third (presentation) tier being your game client. Relational databases, are great at querying data, and decent at writing data. The key is to serialize your database writes into manageable size chunks that your cluster can handle. The more advanced editions (Data center/Enterprise) of SQL Server support clustering and replication. I would start by building a small cluster and running some queries against it to see how it works. In the application tier, if you're doing "zoning" or something similar, you can probably get away without setting up any clusters, and simply setup a server per zone. If your zones become to big, you could setup a cluster for each zone. You will want to build a serialization process for sending data from application tier --> database tier. The key is to have multiple levels of serialization going on. Something like this: 

The web service route is probably the best and most scalable. I also see absolutely NO problem using an MVC framework to return JSON (asp.net mvc is great at this). If your controllers only return JSON at first that is fine, you can unit test without any views. When you are ready to add your game interface, you can add views. If their plain html/css or flash/silverlight, it doesn't matter because, as you've stated, you have already built the underlying engine. I'm not sure what your development or hosting environments look like but I would not over engineer it. A simple set of php files that return JSON may be all you need. I am not familiar with the game you're building, so I am not sure how complex it will be. In my opinion, if you're new to game development, and you're going it yourself, I highly recommend that you get something that is playable as soon as possible, because it will help keep you motivated to complete the game and polish it to a good level. 

It is important to note that the DirectX API is independent of the DirectX Hardware. That is to say that a DirectX 11 video card can still be accessed through the DirectX 9 API. Much legacy code still uses the DirectX 9 API, and as I recall, Direct X is a backwards compatible API, so your code targeting DirectX 9 should run on a machine with DirectX 11 installed. To asnwer your specific questions, DirectX is an API to facilitate running high performance graphics and sound on the computer. You will still write your game logic in C/C++, as I recall DirectX has some classes for dealing with user input as well. With respect to API changes between 9, 10, and 11 I do not really know, but I cannot imagine that a good programmer would have difficulty figuring it out, given a well written book and MSDN. I should also mention here, that I don't do much native DirectX programming, so take my words about API changes with a grain of salt. 

Publish to Microsoft Store (Windows Phone Indie / Xbox Indie) Drop it on a file share somewhere and have people download it Open source it on CodePlex or Github (or whatever you prefer) 

In your map, why not just have an attribute on each tile indicating if it is a border (and if so, what edge and what color)? The benefit is that it will use less processor cycles, the drawback is that you must know at design time where the borders are. Unless you are procedurally generating your maps, this should be an easy thing to setup. Even if you are generating the map procedurally, you only need to run the processor intensive step of calculating borders one time, at design time, not every frame. If knowing at design time is not an option, you could similarly add the attributes to your tiles; and only calculate them once, upon loading the map data. That doesn't resolve the processor intensive task, but it does keep it to a minimum. In terms of the algorithm you are using, there may be more optimized way to do it, but if you can avoid making those optimizations by moving when/where the algorithm is run, I'd do that first. 

You can and you probably should. I believe that in Java (as in C#) objects are going to be passed by reference, so you should get this behavior by default without doing any extra work. Code like this: 

You need to have a collection of monsters and a MAX_MONSTERS constant. I'm not much of an Objective-C programmer, but this pseudo-code should get you going: 

Not to dodge the main title of your question, but I can offer some advice in respect to the other aspect (where should you go next, since it seems you've already decided.) C# and XNA are simply an abstraction layer above DirectX. Using C# and XNA will help you decrease time to market, and can reduce some development costs; however, that is at the expence of some performance and control. C/C++ and raw Direct X is popular because you get maximum performance and control. It really depends on your goals. Personally, I use C# and XNA because its entry level costs are basically zero (especially if you already know C#) and it only costs $99/year to be part of the Creators Club, which is only a requirement if you want to deploy your game to Xbox and or Windows Phone 7. Doing C# and XNA for Windows only is absolutly free, and can produce amazing results. At a minimum, I recommend you check it out before jumping headlong into C++ and raw Direct X. 

What might be an example of the data you're sending? I don't see any reason to do anything overly fancy. Once the data is fully loaded into the receiver's buffer, inspect the first based on its value, you then know how to process the rest of the data. So a packet that has four data parts , , , and might look like this: 

There are two types of MMO games. There are real-time games, along the lines of Eve and World of Warcraft, then there is everything else. Farmville, Mafiawars, etc. They both dictate totally different backend architectures. For games like Farmville, your standard line-of-business type architecture will really excel, because the way users interact with the data is very similar and the data can easily be stored in a traditional Relational Database System. Games that require real-time interaction between hundreds or thousands of players simply cannot be shoehorned into the line-of-business architecture. As @Patrick points out, many of the supporting elements of the game such as logging, authorization and authentication can be handled in a similar fashion to line-of-business applications. The tricky part, is handling "the world." This is where there really is no "right way" it all depends on how many players you expect to have, and what type of resources (programming and hardware) you are willing to throw at it. I would argue, that you can start with a typical dedicated server setup for an FPS, and optimize from there where you start to see issues. Probably the first thing to implement is a way to have multiple of these "servers" talking to each other. Obviously you'll want to run this on a beefy physical box with plenty of bandwidth. IMO, the reason that many FPS games keep server size small, is because they know people are going to run it on some old P4 they have lying around and they'll do it on a crappy DLS connection, not because the server software cannot keep track of hundreds of players. Though I'd bet that typical "level size" is also a reason to keep the max players lower on FPS games. The reality is that you will not have the same amount of players that World of Warcraft or Eve have overnight, and if you ever do approach those numbers where your architecture startes to show its weaknesses, I always say, that is a great problem to have because it means you're raking in the cash. 

I can only speak for myself, but XNA has a very low cost of entry, the learning curve is small if you already are familiar with C++ and/or Java. It also lets you deploy your game to Xbox, Windows Phone, and PC. As @Spooks said, 2D games that appear to be 3D are frequently called 2.5D or pseudo-3D. And is typically done with 2D sprites that appear to be 3D.