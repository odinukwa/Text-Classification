Regular expressions, when compiled down, are very high performing. I would suggest that you build a composite expression, let the Regex engine optimize it, and have just a single check... something like: 

The second issue you should consider changing is using numpy arrays for the method as well. This array is about the same size as the final array and you are incrementally allocating memory for it. Doing it with a single initializer (perhaps ) would be worth considering. 

The nice thing about channels is that they prevent deadlocks, not create them. Some style things quickly, though. Things like: 

Oh, I like challenges like this. Looking through your solution, though, you make statements that do not quite ring true, you say it 'ignores most of the data', but that's not true, it inspects all the data, scanning both arrays completely. On the other hand, that is as efficient as it can be (\$O(n)\$), so that's OK. You just need to realize that you scan it all. So, I agree, it is close to being as efficient as possible. Certainly, it is as scalable as it could be (good time complexity, and \$O(1)\$ space complexity). Bugs 

But, 27 is actually 128. At this point, I figure a vote-to-close, but, FYI: Picking apart the core method .... This is your code: 

Static initializer block As an example of a static initializer, I don't like it... it may not make sense off-hand, but static initialize blocks should appear after the declaration for the variables they declare. The order of execution of a static initializer is complicated, and the best way to ensure it works is to write it out in the same order that you would expect it to run. In your case the code works, but, in more complicated cases, your code may not work.... for example, what would you expect the following code to output? 

The synchronization. You suggest in your comments that the needs to be synchronized to avoid thread problems... but your other setter/getter methods are not synchronized.... as a result, threads all over the place can be getting stale, wrong, and otherwise incomplete populations, ages, etc. 

it is static - your code requires creating a class instance for each call, and the methods are instance methods. it is generic - it can take any form of comparable as input - your code requires that data is manually transformed in to a Comparable array it is generically type-safe - it would have no compile warnings on the usage side. 

Like, really? What value do those add? Oh, I see what those are...... right. You have created those interfaces because you don't have the generics on the Parser. I get it. You don't need them at all, you can just have: 

Note how the type assertion creates a new instance inside the scope of the . The go language guarantees that the resulting will be correctly typed in the relevant case blocks, so in this example, the case statement is referring to the field on . While on the subject of error handling. It's a very common pattern in Go to have checks for NOT-NIL errors. Checks for nil errors are uncommon, and will likely be missed. Thus, this code, even though it is right, will probably be mis-read by people on the first scan: 

(see how the class name is used as the first generic token? I have added that as a comment in the second declaration...) With the above changes, your generics are "fixed". The implementations for TicTacToe examples had to be "corrected" to have the correct return types and order for the generics as a result, though. Specifically, the Move/Action was not originally part of the generic type for the Agent, but it had to be added to correctly reference the State. Wow, that's a lot to digest, but I hope it makes sense. Cloning The use of the Cloning class is odd. I realize you think it may make cloning simpler, but the truth is, I don't think it will. When you have a need for specific style of cloning, and you also have control over the classes you are cloning, then it's simpler to just add a special clone method to the class. For example, I recommend adding to the interfaces. Note that you now have a nice generic type as well to return the value in (which clone does not): 

Initialize the first byte, and then start the loop from 1..... You may also want to do a bit-check instead of modulo, but they may be equally fast... 

The above function will give you better distribution (perhaps not perfect) even if the hash size is a power of 2 > about 16 bits. 

This changes the value that you are returning though.... but... what was the requirement? Was the requirement to get the number of steps to go from the first to the second, or the number of in-between nodes you have to visit? If it was the number of nodes you have to visit, then you have two places where the result is 0, when , and also ... In a general sense, I have never encountered a reason why there has to be a full loop-count when the Finally, what if you are going the long way around? For example, what if someone does this? 

and is not .... To get the comparisons right, you need to compare to . THat way, you won't have gaps in your buckets. Then, the select statement you are running is very inefficient. You can reduce it to a single query, with conditional values in the select. Consider the following: 

Right, that shows some familiarity with Java 8, some language structures, code discipline, and so on. What about the actual sort algorithm? 

I don't like that your query can return zero results when the value is large... and all higher ID's are handled. As a cursor / procedure, it will process much less data, and, as a consequence, it will likely be faster. The big difference is that it will terminate early (when it has found a valid answer), rather than calculating all the valid answers, and selecting one of them. It could be something like: 

Your code has a for-loop with a nested while-loop. Typically this would indicate an \$O(n^2)\$ time complexity for your solution.... but, your code is only actually \$O(n)\$... how does that happen? Because you do for-loop control variable manipulation outside the for-loop control block. This is a bad practice. A for loop has three control statements: . A for loop is designed to have those three mechanisms in one place. In your code, you have split the logic of the stepper in to two places, which makes the for-loop hard to read, and unconventional. Your variable is stepped, and also you have later in your loop. If you cannot implement a clean for-loop structure because your code demands some other mechanism, then you should instead use a while-loop, or find a different way to express your step-process. Bhushan has provided an answer which solves the problem, but does not implement a clean break-processing loop. His code implements the logic check when leaving a clump, rather than when entering the clump. If you do the check when the clump starts, the logic becomes much simpler: