You are talking about doing manually something which is already done for you automatically by 3D APIs. One of the most basic functions of any 3D engine is to handle the transition from a bunch of objects in 3D space and a camera (naturally you must always have a camera) to a 2D picture (technically a projection) on the screen. In your case, doubtless an object's representation moves more pixels per second going left or right than away from the camera, due to your angle (unless you deliberately have a fundamentally illogical physics model, like many such pseudo-3D games, and have those speeds be equal - not criticizing). This would be handled by what is known as the view matrix, which looks at where objects are in the world and says where they should be on the screen. If objects far away did not get smaller, and the road away from you looked straight if it was straight (ie did not appear to narrow due to perspective) you would have the familiar isometric game. To make far away things smaller, and a few other similar things, you apply what is known as a projection matrix which pretty much takes what the camera sees, and "distorts" to show how it would look if the camera had an arbitrary lens. An isometric game has no projection matrix and thus everything is... Well, isometric. There is usually a third kind of matrix, a world matrix, in 3D engines - because parts of 3D models are placed relative to the models origin, you need the world matrix for placing models in different points of your world. It's also like position and rotation (and scale, and skew if you have 4D matrices) of your object all in one handy mathematical entity. So what you usually do is, you multiply (matrix multiply) these three matrices, and multiply the "model" (which is a bunch of points and polygons defined with respect to a model origin) in order to place a model's image on the screen. These matrices are not invariant, of course. For instance, the world matrix is generated depending on where your object moves. I think isometric games are at the "2D threshold" - they are roughly the same amount of work Math-wise in 2D and 3D: 

Essentially, you are generating one "general" path, and then breaking it up into segments and regenerating each segment. Since you want a mathematical function: Suppose the above procedure is packaged into one function y = f(t, s) which gives you the distance at t for the function of seed s. You will need: 

I was thinking about this as well, and it occurred to me: For instance, to steal the example in your link, in an RTS game you could make every unit a game component instance. Okay. But you could also make a UnitManager component, which keeps a list of units, draws and updates them as necessary. I guess the reason you want to make your units into game components in the first place is to compartmentalize code, so would this solution adequately achieve that goal? 

I imagine you can accomplish either of these by simply supplying an array of numbers as the seed s. Alternatively, you could do something like supply one number s as seed, and then call the built-in random number generator with rand(s), rand(s+1), rand(s+2) and so on (or initialize with s and then keep calling rand.NextNumber). Note that even though the whole function f(t, s) is made up of many segments, you are only evaluating one segment for each t. You will need to repeatedly calculate the boundaries of segments with this method, because you will have to sort them to make sure no two segments overlap. You can probably optimize and get rid of this extra work and only find the endpoints of one segment for each call, but it is not obvious to me right now. Also, Bezier curves are not necessary, any suitably behaving spline will do. I created a sample Matlab implementation. The Bezier function (vectorized): 

It's quite simple: If you do not hold copyright to a work, you are not allowed to reproduce it. Since using it in class would be reproduction, you are not allowed to do it under US copyright law. The one exception is "fair use" (well, there are others, but if they applied you'd probably know about it). It is very clearly defined and there is a plethora of court cases covering specific instances. You should peruse this information and decide for yourself (better yet, ask a lawyer) whether your work is fair use or not. We cannot decide for you, and even if we wanted to, we are not supposed to give legal advice on this site. That said, your case does not sound like fair use. Speaking very broadly, fair use exists so that you can't abuse copyright to stop people from talking about your work - it is not a magic loophole that lets you ignore copyright whenever you want simply because you are doing it for "educational purposes". Yes, copyright holders can prevent you from using their work, even if you are not deriving any income - perhaps they are worried you will hurt their image, or that you will cause them to lose the copyright, or they think they can force you to pay for it - the reason is irrelevant, the point is that the law gives them the right. If this was not the case, every infringer would start claiming they are somehow doing it for educational purposes and completely sidestep the spirit of copyright law (in fact, back in the day software pirates used to claim their cracks were for "educational purposes only" - I don't believe that worked too well, since the practice hasn't persisted, while the lawsuits have). Incidentally, Wikipedia has a section on common misconceptions which include: 

Depending on how you go about things, I'd say it doesn't matter - either is good. Nethack and many roguelikes are a great example of how "fat walls" look when generating mazes/dungeons at a single height. I think it might possibly make your job easier, since all you need to store the level data is one array (as opposed to essentially two different arrays with thin walls: One for "inside-grid-cells" and one for "between-grid-cells") although Nethack is only one height. I think you should start with whichever one is less work (probably fat walls), because honestly to a gamer what matters more is that the games logic is consistent and well-implemented rather than realistic; so it doesn't matter that fat-walls seem weird so long as they work and are bug-free. 

Unless I misunderstand, you are asking how to make a 2D tile engine. This tutorial will walk you through the process, among other things. Most developers do not solve this problem. They use an existing tile engine. Several exist for XNA. If you feel compelled for some reason to make your own, I think the best option would be to have a Tileset object, then have each tile know its tile code, and have the draw method look at each tile, get its code, get that code's tile graphic from the tileset and draw. As for specifying a tileset, it should be enough for each map to specify a tileset code, and the the Tileset object can fetch the relevant tile sheet for that code. In any event, the thing you appear to ignore is: You should find a map editor you can use, and then code such that you are compatible with it, thereby saving yourself the trouble of writing your own editor later. The way the map editor does will probably immediately suggest simple answers for your questions.