it's performance hungry, especially for the memory ( RAM and CPU/memory controller ), this also means that to run a simple game you need at least a computer with medium range specs the JVM it's not standardize, especially on Mac, the first official Java version on Mac is the actual version ( Java 7, first and only one ), the previous versions are provided by Apple and are not standard, especially for the part related to the window system and the graphical appearance, also in many GNU/Linux installations the default JVM is OpenJDK and not Java from Oracle Java generates bytecode and not compiled code, even if you obfuscates the code it's really really easy to crack, sometimes it's also easy to do reverse engineer If you distribute java code you are implicitly asking the user for installing the JVM, most of the users do not have this abilities and most of the times they just expect that your program will run/install right after the download without additional software for what i know Machinarium is in Flash ( probably even worst than Java ), the original one on PC/MAC/Linux, the others are porting. if you are interested in Java and you want to code games, do yourself a favor and just use C# 

Pass Game1 as a parameter to SomeOtherClass and store it as a reference. This will allow you to modify the list by going parentGame.myList.Add(SomeClass);. This requires myList to be public. Alternatively, use wrapper methods around myList (eg parentGame.AddToList(SomeClass);) Declare myList as public static, then you can go Game1.myList.Add(SomeClass);. 

And yes, I do use Apply/Accept instead of Accept/Visit that the Wikipedia article uses in its examples. Personal preference. The advantages of this is that the game has a collection of systems (may include different rendering systems), and I can swap between them (eg swapping between Dx9 and Dx10 3d rendering systems) My components only contain data (position, visual, health, etc) and don't care about the entity they are attached to, my entities know they can apply a system which will use their components, and the systems only care about accepting entities. You might want to move the call into the system itself as part of an function, which would be added to the interface, and implemented by each system. I would do the same, except I'm slightly hesitant about diving into a true ECS (Entity Component System) implementation, and I still have different entity classes with components explicitly declared (so instead of calling I call instead. I originally had Components for drawing, receiving input, updating, etc, but then I quickly ended up with duplicated components, components subclassing other components to extend it and add extra functionality, etc, and it was a mess. Moving to this pseudo Visitor Pattern based ECS has greatly simplified by own code, and made it much more understandable, not to mention the maintainability. In the end, use what feels right for you. I was once stuck at the same place you are now, trying to decide how to implement a rendering system and what the best way was, and when I saw the Visitor Pattern, I knew that it is what I needed, and what I was going to use. You might feel the same when you spot some code or a design pattern that just seems to click and fit your requirements/needs. 

Safe? No, in theory and in practice not even the ones that you pay are safe, the fact that this images are free or not tells you nothing about their copyright and most important of all, who is the copyright holder. The real solution is more like a good suggestion: always mix and work with this textures in way that you will never use just 1 big texture alone. If you really need a complete big texture of something you better go out with your camera and take some pictures of the natures avoiding famouse places/buildings and private spaces. 

The answer to your 3 questions is subject to the laws that are applied in your country, also a trademark is a different concept if compared to a registered IP or a registered copyright, and there are also other possible options. Each country has its own law and usually its own patent office, also do not assume that a registered IP is protected worldwide, this is a political issue and can also affect your distribution strategy. 

you will be fine with a commercial solution, otherwise if you want the maximum flexibility and you have the know-how, you probably want to code your own stuff and avoid spending money and legal issues. Also all the software that you mentioned offers legal problems when it comes to using them on the job, some of them offers more complex issues, because for example the UDK, it's not really free for every use, if you are going to use it in the place where you work, you have to pay, no matter what you are producing with it. There are also nasty things like the standard Autodesk EULA allows Autodesk to basically fetch your computer for data without explicit warnings ans in "silent mode". If i was you, i would switch to Blender and Gimp, this 2 are really powerful software, with a rich set of APIs and 0 legal issues, and they are free. 

I'm currently using the Visitor Pattern ( Wikipedia link) as the basis of my rendering system for my game. Basically, I have several interfaces defined to support this: (Note, this is basically an abstract recreation of part of my games system, and most likely does not reflect current code) 

Of course, this relies on the server having the Xna game studio installed on it. If you don't have the Xna framework installed on the server, you can either download and run the installer from here or search the GAC (Global Assembly Cache) on your build computer for the Microsoft.Xna.Framework.dll file, and then drop it into the bin folder of your server program when it gets deployed, but the framework installer is (IMO) the easier and safer way to go. You can also add Xna assemblies to a project without making it an Xna project, its just that an Xna project has all the Xna framework references added by default. I currently have a Form and a Class Library project using Xna references, and they still run/compile as a Forms project and a Class Library .dll 

However, I don't recommend 2, as it goes against what statics are meant to be used for. 1 is probably the safer way to go, and more convenient and coder friendly (not to mention safer). Statics can be hard to remove later on down the line. 

The only real thing that is different is the amount of devices, Apple just sell 1-2-3 new product each year, Android offers 1 new product every day/week. The emulator it's not buggy, it's just not intended for profiling, if you want to profile an Android application you have to do the same thing that you have done for iOS: consider the lowest profile device that match your requirements and buying it. You are supposed to have at least a basic know-how about the ARM architecture, otherwise you can make a difference between all the devices on the market, begin to outline the hardware features that are important for your application and buy that device for real testing. 

There are different technologies for this, there is no standard, at least no one that i'm aware of. The multi-monitor technology from ATI is named eyefinity and it's probably the most mature technology among the ones available on the market. The eyefinity capabilities are accessible through the AMD display library SDK . Nvidia calls its multi-monitor technology nVidia Surround and there are little to none informations for the developers, there is this page that mix the surround technology with the 3D technology and i don't think that is useful at all. If you are interested in this you can try to browser and ask in the Developer Zone. 

Put simply, you only have the bare bones of a WinForms XNA based game. Your going to have to port your games code across from your XNA game project into your WinForms project. You'll have to create the MainLoop, and use it to call your MissileDisplay's Update and Invalidate Methods to simulate XNA's Update, and to call the GraphicsDeviceControl's Draw methods If you need help with this, I found this 5 step guide very helpful. I was able to get 4 different displays for a proto level editor running at the same time. 

You shouldn't be trying to ensure that all your updates happen after X milliseconds - the existing game loop does that already. Instead, what you should be doing is applying delta time correction to your updates to ensure your updates, no matter how frequent or infrequent, regular or irregular, all happen at the same rate. An example is as follows, and is rather simple to implement. 

You'll probably have to tweak this code sample so it works with your code, but it should be enough to point you on track. The parameter is a floating point value between 0f and 1f, with 0f being fully transparent, 1f being fully opaque, and 0.5f being half transparent. Some of the material settings in my model files don't seem to be exported across into XNA correctly - limitations of the basic Model/Effect in XNA I would assume. I've wound up with my own custom Model class and import pipeline so I can get the all the data I want from my raw model files into my custom Model Object. Anyway, hopefully this is enough to put you on the right track. 

Well, Game engine is a generic term, Physics engine is more specific, the "problem" is that the functionalities that a game engine provides are up to the developers that have coded that particular game engine. There are very basic game engine that have no physic support or they expect you to add to it manually, and game engine that support physics and fractures in real time. Your view shouldn't be about how they work together in the first place, just look at what a game engine offers and if you need a physics engine add it to your code. There are also some engines that mimic the physic with pre-baked collision and explosions, there are several approach to this, depending on what you have, what you want to achieve and what is your target machine, you better look to the features and how they are implemented, only the name "physics engine" can't tell you what you are dealing with. 

I think that you are approaching this on the wrong side. Question: what you need to license, the source code or a compiled software? In the first scenario you probably want to stick with something like the GPL, BSD or MIT licenses, in the second case you probably just need an EULA. You also can mix this 2 requirements but i don't think that you need to give a license for your source code in your case, the user will never see your source code; you also appear to not being interested in patents, and patents are the only way to prove that you own a particular asset of your software or you own the rights for an UI, a file format, or some other pieces of your code including the design and its own implementations. 

However, play testing and other feedback reveals some problems (looking at the numbers it should be rather obvious). Daggers/swordshorts are too weak to be used effectively, and your average medium melee weapon actually out damages your average heavy weapon, and muskets aren't being used because they don't kill stuff fast enough compared to bows. Next challenge is how to solve this. Maybe increase/decrease some weapon stats, or introduce greater variance in the damage range for the weapon so that some attacks graze or deal large amounts of damage. Maybe increase the critical chance for some weapons to improve its average dps. After a a random amount of rebalancing iterations the numbers may be declared final and that's that. Until someone decides there aren't enough weapons and we need flails and maces. 

Been reading up on various methods in the XNA framework, and found this one. I've done some Google searching, but I can't seem to find any information on how to use this particular method overload. Parameters 3-5 are easy enough to understand, since they are used in another overload, but I'm not so sure about the first two. I'm fairly sure that the first parameter is the mipmap level we are setting data to, but the second one has me completely lost. However, I'm not exactly sure what I should be passing in here. I know it can be a null object, or a valid Rectangle object, but I'm not sure whether it is being used to specify the size of the mipmap texture like this: 

I will use this as a generic reference, but the more i browser online docs and books, the less i understand about this. 

I'm starting with the programmable pipeline and the shaders in C++ for OpenGL 3.0+, i would love to be able to change some settings on the fly, for example replacing a function with another function, supposing that i have a shader with an operation like 

Only the person, the group of people, or the activity that owns the code can change its own license. If that code is yours you can change license every time you want, decide to be payed or not, you can do what you want, but if the code it's not yours you stick with the license if you want to avoid troubles; big troubles. The owner can also refuse to accept to be payed, it's a situation like the one that you have with the patents, if you can prove that you own the code doesn't mean that you are putting it on the market for money, many many times the patent or the license is supposed to force the market or the user to stay in a confined space. The answer is no and the only way to change the license is hoping that the owner will do that.