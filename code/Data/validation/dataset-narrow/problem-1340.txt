Currently in my game engine when a user selects a large number of units and commands them to a target each unit finds its own path using Jump Point Search. The performance of this is generally OK. What I dislike is that over longer distances all the paths tend to converge so that the units end up competing to reach the path's nodes. 

What I need is an algorithm that can create discrete physical groups from a larger set of units like in the image above. I'm at a loss as to where to start with this. I had thought of maybe using some sort of brushfire algorithm, adding units to the group as they're discovered and stopping at walls or too much empty space. I'd rather not reinvent the wheel though and would appreciate any help anyone can give me. 

Assuming your vertices haven't been multiplied by any matrices the tangent and bitangent will be in object space. Edit: Your vertices are in object space. A normal is a vector perpendicular to a face (usually a triangle made from 3 vertices). Because the vertices used to calculate the normal are in object space, the normal will be also. The same follows for the tangent and bitangent. 

There is no 'best' solution to this problem. Ultimately you're going to have to find by trial and error something that gives the best tradeoff between performance and believable intelligence. However if you want to use any sort of path finding algorithm you're going to need to subdivide your world in some way. Whether you go with tiles, polygonal zoning or way-point nodes, your path finding algorithm needs some sort of graph to traverse. Using simple steering behaviours without any path finding will result in your AI getting stuck behind obstacles. For seeking targets over large distances I use Jump Point Search which is considerably faster than A*, especially if your map has open areas. For localized searching, such as aggro detection I use a simple Dijkstra algorithm. Unlike A*, with Dijkstra you don't ask it to search for a specific end point, you instead describe the type of end point and it will find the closest for which there is a valid path. For example, you might have a soldier class within your game and you want it to attack any enemies that come within a certain radius of the soldier. You can simply feed the Dijkstra algorithm only the tiles that are within the radius. You then tell it that the only valid end points are tiles which contain an enemy. This will cause the soldier to always move towards an enemy if it is within aggro range. You can couple the above approach with Steering Behaviours / Boids. Do the Dijkstra scan as described, then once an enemy target is found, stop scanning and allow your soldier to follow the path. Once your soldier is quite close switch to following by Steering Behaviours. This will work most of the time but because Steering Behaviours are not a path finding algorithm your soldier will occasionally get stuck behind objects in crowded areas. To solve this you must keep track of the distance to the enemy target. If the distance increases by X amount for Y seconds you know your soldier is likely stationary and the target is moving away from it. In this case, stop following with Steering Behaviours and perform another Dijkstra scan. 

My solution to this is to group the units together and create a path from the unit closest to the centre of the group. I then use steering behaviours / flocking to sensibly navigate the group along the path to the target. The problem I am struggling with now is that the user may select many units which aren't physically grouped together. Some may be very far away from each other, others may be close but separated by walls, etc. It is not really possible to create one path for such a group. 

This will allow your enemy to move in smooth increments every frame. The enemy will also move the same distance at the same speed, regardless of frame-rate. 

Rather than move your enemy every 500ms you should define how far an enemy should move in 1 second. For example, say an enemy can move 3 distance units every second. If you know the time between the last frame in milliseconds you can simply do this: (pseudo code) 

You don't set these values in the shader. You set them in your program, generally when first creating the texture (though it can be set or changed whenever). If you've already uploaded your texture data to OpenGL then all you have to do is this: First bind the texture if it is not already. 

By authoring an audio clip with high BPM, then playing back at half speed you are effectively halving the sample rate. You can achieve a similar reduction in asset size without changing your workflow or any existing audio files by reducing the sample rate in the AudioClip inspector. Also checkout the various compression options on that page as they all have different storage / quality / CPU trade-offs. It is often best to import assets files into your unity project as they are. Unity then allows configuration of independent quality settings for each build target. 

When game starts and the method runs it calls When runs it immediately yields for one second, then after that delay it calls . This will cause to run repeatedly starting after a two second delay, and then again every second. When runs it: A) increments , B) calls (see step 2) , and then C) increments score again. 

will return true for each frame that the "button" is down. or will return true only on the frame that the button goes down or up respectively. 

I'm having trouble visualizing the problem you are describing, however I can see two issues with the implementation posted. The first issue is that you are using the updated rotation as the first parameter of the lerp function. Doing this will produce a movement that will start off quickly but then slow down towards the end. This effect is great for camera movement but would look a little off for rotating a card. Another issue is that you are using (elapsed time) as the third parameter for lerp, this will produce varying (and possibly unexpected) results for those occasions where is not equal to 1. The solution is to use as this will smoothly travel from 0 to nearly 1. At the end of the loop you can then force the final rotation to ensure a predictable final state. A smooth and complete lerp requires stable and parameters and a parameter that ranges between 0 and 1. Please try this version with these changes applied: 

An additional consideration might be to identify any heavy weight tasks that are taking too long to execute and splitting them up over a more than one frame. Frequently coroutines can be used for this purpose. 

Rigidbodies can be said to operate in two modes: Non-Kinematic has physics driven movement, the physics engine will consider any forces brought to bear on the object to calculate and apply changes to velocity, rotation and position. Kinematic lacks physics driven movement, the physics engine will not cause this object to move and any forces on the object will be disregarded. These objects can be moved through code by directly manipulating the Transform if required. One important point to be mindful of is that the physics engine is optimized such that it will not detect collisions between two Kinematic Rigidbodies. If your ball is a Non-Kinematic Rigidbody and you want the bricks to remain stationary then I recommend setting the bricks to Kinematic. 

When you perform your clamping in world coordinates it is easier to apply an offset for the object width. As the position is (often) the center of the object you will need to calculate half it's width and offset your clamp accordingly. Likewise on the y-axis. A good source of half-width and half-height values is often . 

Collision events will only be detected under specific circumstances. Each collider can be considered to have these relevant properties: 

As an aside if your score is rising unpredictably it would require that your and flags are being reset. 

Now that we have stopped the physics engine from managing the rotation we can control it ourselves by manipulating either or . 

I am working of some editor scripts for Unity but have found that it is difficult to force Unity to reload my editor scripts. My scripts are modelled on the static constructor approach and perform some manipulation of the Tag Manager. Currently the static constructor is called when either: 

I recommend Natural Earth Data as a source of public domain cultural and physical GIS data with global coverage. Vector data sets include landmasses, countries, populated places etc, while raster base layers are available with optional details like land elevation, climate, waterways and submarine elevation. This data is intended for use with GIS software, but can be manipulated and then exported as something more "game friendly" (svg, png etc.) using tools like QGIS or indiemapper with no financial outlay. The vector layers come with detailed attribute tables that might also be useful for simulations such as names, populations and GDP. Here are a couple of quick mock-up produced with this data: