While we're on the subject of overriding methods, you should consider overriding the method as well to return something reasonable. Your method should do more validation than that IMHO. You make the assumption that the input will be a comma separated pair of values. You check if you have a pair which is good, but you should explicit perform checks to make sure the values are integer numbers (i.e., digits). It's not as useful receiving a generic format exception coming from the method than if it came from your method. On a minor note, use and for the local variables and not and ... that's not what they're representing. 

I would avoid performing linear searches through this as you'd be looking at O(n*m) performance when you could be doing O(n+m). Use set operations if you can. Use if possible too. 

Otherwise use a switch statement if the mapping gets too unruly or you want to map multiple combinations to a single value (it's not necessary in this case). 

I'd be weary of solutions that builds the HTML by hand. Work with the DOM and let it write out the HTML for you. HAP can do that for you. Don't create one-time use extension methods. It appears you created an extension method for strings to encode your titles. If you can't use it anywhere else in your code, it doesn't belong as an extension. I'd argue that it should be a regular static method of your class as it might be specific to how you want your headers encoded. In this context, it is confusing to see that call there. Your logic in your headers to get the "sibling number" and TOC prefix is more complicated than it needs to be. Especially the method, the logic is very confusing to glance at. I was having a hard enough time trying to figure out what it was doing. The string reversal at the end really killed it. They both could be done simpler. In fact, they could be calculated at once on construction with some refactoring. That leads in to the critical thing that's missing in most of these methods, comments... there's not a lot of useful ones in there. Your comments should be explaining what is happening in the code that couldn't be determined at first glance. The code really should be self-documenting. When it isn't, you need to say what it's doing in comments. But no one cares that the next line will add some item to a list. You should me saying things like, "we need to ensure we don't have an empty list because..." or at least explain why some actions are needed. I did a lot more that I thought I would do but I would rewrite it more like this. p.s., I don't know what your HTML would look like so I don't know how the nesting actually worked. But this should give you an idea how it could be better implemented (IMHO). 

For this, I would not use LINQ at all here. There unfortunately aren't any methods available to make this task easier. In fact, I would say trying to use what currently is available makes it more complicated and inefficient than it has to. As you can see by all the helper methods and whatnot you had to add, you can see how complicated it can be. Just make it work for , there's no sense in restricting it to arrays. Sure HashSets and Dictionaries don't have a notion of ordering, but how else would you make this accessible to other "ordered" enumerables? You'd have to add overloads for each type you want to support since there aren't any interfaces implemented that has this distinction. It would be easier to let it work for all enumerables and leave when to use it up to the user of your code. I actually have some code that does something like this. You only really need to keep track of the previous key that was added. If the current key matches the previous one, stick it in the same group, otherwise create a new one. 

On the other hand, since your inputs are constrained to up to 50'ish, you could just use an array (and not an ) for the lookups. 

Then it's just a matter of storing only the arguments to the call rather than the functions themselves: 

I'm not sure what the point is for making a distinction between a size and the default size. But you shouldn't expose the default value as a field, use a property. That will give you much more flexibility should you decide to do other things when getting the value. No need for a backing field, it's a value type and it isn't all that complex. 

Since we know we are dealing with arrays, you won't be paying for much in terms of performance in the LINQ calls. If that bothers you, it is simple to write the equivalent without using LINQ. 

Your code attempts to fetch the values of all keys when it probably only really needs one. You do not want to be doing this. I think it would be better to create a list representing the priorities of what values you wish to retrieve and attempt to retrieve them. 

A better solution in this particular case IMHO, rather than defining multiple functions with varying number of arguments, you could just define one function accepting variable arguments to achieve the same thing. 

Suppose you kept track of your balance at the bank for every day in the month. You'd have data such as this:How would you determine how much money you earned/lost between day 1 and day 2? How about day 2 and day 4? Is there a way to represent this problem in a similar fashion? Think about what representation of your information is really important here. Your code stores a collection of points. Whenever you need to perform the count, you would have to determine what quadrant the point belongs and increment to the appropriate counter. But do you really need to keep track of the coordinates for each point? If you represented the data in another way, would you still be able to perform the three operations that are required while still maintaining the information you need? What would that representation be? 

Then use regular bit manipulation to set/clear the flags. Do take care in using this if you have values that represent multiple values 

If you know for sure that the types that are used here can be converted from a , then you could convert back using . 

You have the right idea, but you didn't quite know how to get there. You don't need that function to operate on the left or right lists. Just bind them to separate variables through a simple expression and you can add the items to each of the lists. 

Throwing the contents into a dictionary will lose any sorting you may have had. Dictionaries are unordered collections. The cleanest way to deal with this really is to implement your own custom comparer to compare the columns and reset their order based on the ordering. I believe this would be more or less logically equivalent: 

It should be pointed out that there are methods to retrieve custom attributes in the framework now as of .Net 4.5. See the CustomAttributeExtensions class. This should simplify the extension method a bit. It might be worth changing the name of the extension to as well since it will always be a custom attribute. 

If you can answer these, I'll expand more on my answer and we'll probably work out a nice solution together. I'll probably share my answer too (though I haven't actually run it against their tests). 

Your code appears to be a simple naive implementation to perform these operations and that alone isn't necessarily bad. However if you're taking too much time for their test cases, you need to reconsider your algorithm, how you represent the data and how you perform the calculations if the naive implementation is too slow. Every operation is an one. Count will suffer the most since you're trying to figure out which quadrant each point belongs to as you come up with the counts. Profiling your code against your test cases will not be very effective as you can bet they will have a lot more to throw at you. You need to find out how you can reduce these algorithms somehow to pass their tests. In fact, you can reduce Count to be with the algorithms I have in mind (the other two will have the same complexity however). Rather than just giving you the answer, I'll provide some pointers. 

Consider changing your algorithm to perform the task. Every operation that you need to do takes some calculation to perform the operation. Not necessarily cheap as far as the test cases thrown at you are concerned. 

You are representing some state using 3 individual boolean variables. It may be better to represent such a state using an enum with flags. Then this complicated test to figure what state you're in wouldn't have to be done. You could then combine flags to represent each of the separate states then switch off of that. 

I find it easier when working with hierarchical data structures that the functions you write should be written recursively to make your job as simple as possible. These types lends themselves well for such methods. The typical structure for such methods will usually have this form: 

You've defined some method so you could rearrange some things and add additional levels of indirection to run slower and more inefficient than if you had just written the standard way using the and blocks. What did you gain here? I'll tell you, nothing. Any half-decent C# programmer should know what the and blocks do. There should be no question about it. Seeing your block of code, it's not so clear... we'd have to figure out what you're doing here. What if someone saw your block of code and wanted to know what is going on? I look at that and see ... "With" what? What the heck is that supposed to mean? If anything, it is only more confusing to people who are familiar with VB.NET's keyword (which does something completely different). The name isn't very great. You should have given it a more descriptive name. might have been a better choice or something along those lines. Don't even get me started on the ToList/ForEach combo... You can never go right doing this instead of using a simple loop. Why would to take a perfectly good collection, copy that collection into another list, just so you can call some method to do stuff with the added overhead of calling another method to do something on each item? The method has it's place and that's if and only if you start out with a list in the beginning. The overhead of the delegate is more forgivable here since that's what it was designed for. I understand that this particular usage is just a "hack" just to make this loop work, but this should never be the answer. If you must, write an extension at least. See reason number two of Eric Lippert's "foreach" vs "ForEach". The same can be said here twofold, both for the method and your use of . What happens if you need to do more than one statement in each of the blocks: 

Otherwise if you don't want to take the performance hit LINQ will give you and use a loop, here's the equivalent: 

Any time you override the equals method, you must override the method too. Use an implementation something like this: 

For operations that alter the structure (i.e., add or remove items), it will accept an object to modify and return the modified item. The modified item may or may not be the same exact object that was passed in, depending on the operation you're doing and the state of the object (more on that later). You might be thinking your function does something like this: search through a list to remove an object. Instead, you should be thinking of your functions like this: given a list, return a list that has an object removed from the list. They will be recursive usually doing some operation on the first object in the collection and recursively be called on the rest. The recursion is what drives the code so you generally would not have loops going through the collection. That's not to say you will never have loops, you might have loops going through a subset of the collection, just not the whole collection. Being recursive, the function will perform different actions depending on the state of the object so you'll usually have a set of / statements (or if possible, ). Ideally there'd be only 2-4 different conditions at most. The key is that the conditions should be as general as possible. i.e., have cases for an empty collection, one item and more than one item; don't have cases for an empty collection, one item, two items, three items, four, five, etc. 

You could change it to just store the functions and the arguments. Then use the argument unpacking to fill in the correct arguments to the function call. 

It seems the only two unique things about the blocks of code are the Tables that you are searching/adding to and how the s are obtained (from different types). You could just make your method accept two additional parameters, the table that is being searched and a lambda which selects the . You'll just have to rewrite some expressions. 

That is a great start. It's almost perfect logically. First thing that caught my eye however is the lack of indentation. It could just be that something got lost in the transition between your code and your post here, I don't know. But you should indent whenever starting a new block. You indented the bodies, that's good, but you missed the function body of , the block. Had you done this, you would have been able to identify the following problem in your code. The body of the while loop consists only of the first statement that is counting newlines. You are effectively counting only newlines and not counting the blanks or tabs. This is how you have your code written but let's include some correct indentation: 

As this is EF code, assuming you have all the associations set up correctly, you should be able to write it something like this: 

So after our little discussion, I hope you see that you're missing some key cases here, when the given is . Some things that should be pointed out, when comparing to , you should be checking if it or . Don't use (in)equality here, it is just not correct. Assuming this is a method on your tree node objects, I'd rewrite this to make use of . That way we don't even need to worry about the case when is , that just shouldn't happen. 

My experience with Javascript isn't quite as developed as it is for other languages, but here's what I have to say about the code. Why use and ? You'd use those methods if you wanted to call a function repeatedly. Since all you do is set it and immediately clear it, there's no point in really using it. Better to use instead. I'd consider rearranging your parameters so the was last. That way you can make the delay optional, possibly provide a default delay instead. Also consider making optional too. It could be possible that you don't need the callback so you're forcing yourself to have to provide one. I don't think you'd want to put a delay of the first invocation on the first item. So probably should remove that initial timeout and just call the directly. 

As a side note, you should have separate functions defined to perform the different node manipulations. e.g., functions to create/initialize a new node, to destroy a node, etc. You will need to perform these operations a lot so there you should minimize the amount of copy/pasting to do these. Though this is C, you should follow C naming conventions. You shouldn't use , but rather (I don't know if there's a name for this convention). I'd recommend naming functions in this form: . Personally, I'd create s for your types rather than using raw s, makes things easier to use and cleaner IMHO. To rewrite your remove function to follow this form, it would look more like this: