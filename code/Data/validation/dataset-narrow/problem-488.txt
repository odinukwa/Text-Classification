In your evaluate function, it is fine but not efficient doe to the call of std::string constructor in every iteration along with deleting un-palindrome elements. it is better to create another container for palindrome elements and check the main container elements if it has palindrome element. possible implementation: 

Based on previous question i implemented most of suggestions. also, i have added Alpha-Beta pruning to minimize the calls. and making the game more generic to accept the board to be any value like 4x4 or 5x5 etc, every thing looks working fine for 3x3 board but it becomes so slow if i choose the board to be 4x4. how can i improve it further? 

i inspired of @MAG alternative solution, i re-implemented it in recursive way by providing template parameters. as following: 

Your code looks so good, it is quite impressive of you were learning c++ few days ago. i'm sure you will get a decent code-review but here my humble attempt. It always preferred to pass the by const reference if you don't modify it. also, std::vector is preferred over std::list. here link for more details In your read function. It redirects all input into this container until EOF is received. However, the used container might need to reallocate memory too often, or you will end with a exception when your system gets out of memory. In order to solve these problems, you could reserve a fixed amount N of elements and process these amount of elements. here an alternative example to your read function by using and like so, 

Factory basics If we talking about MVC then we have an object oriented system which contains a lot of objects. Factory methods and classes mainly exists to help instantiate other orbjects. Look at your code; is your factory do what it have to? No. Your factory only loading a file in a strict way, you need a class loader as Wouter J suggested. Learn how PHP namespaces work ControllerFactory If you have a class loader then you can build a real ControllerFactory. What should it do? Get the controller name (namespace + controller name, not file becouse the actual controller is a class!) from the input parameters (route data) handling all namespace and naming issues (for example not only in your controllers "folder" (namespace) can contain controllers). If we have the controller (full name and the class exists) then we have to instantiate it. A ControllerFactory can handle some kind of dependency injection container to allow controller classes to have parametered constructors. If there is no DI container available, then the instantiation can be really simple: new $namespacedName() The ControllerFactory it self should not be static becouse it will be hard to test, the implementation could not be replaced if it would required and we could not pass anything to it's constructor (it wouldn't have a ctor). Ofcourse it can have static methods to set the default ControllerFactory, like: 

The final clause is where all the interesting work occurs. It first calls with a default value of to check if the value tuple is present. If it's not, the default value of is returned, and the case clause for creates a new list of value tuples based on the incoming values of , , , and and passes it to a new call, setting the initial sum value to 0 and passing the current cache. This call returns a 2-tuple comprising the sum for that value tuple and a new cache. The final line in this case clause inserts the sum for the value tuple into the cache. The case clause for when finds the value tuple just returns the cached sum and the current cache. The result of the case expression is stored into , and then is called recursively with , which is the tail of the value tuple list, a new sum which is , and the new cache . We can run the code in a list comprehension to calculate the running times for values from 1 to 12 using like this: 

Svick is right Use the AggregateException class to collect all exceptions you need. With AggregateException everyone can prepare it's own code to handle the multiple exception situation but with your original solution they have to handle a huge string in a stock exception class. How can be this usefull? Storing exception.Message It's bad. If you store only the exceptions' messages you will loose a lot of information and the types of the exceptions. How would you handle an exception if only the Message is what you have? Parsing it? And we havent talked about the specific properties of specific exceptions like some validation exception which can contain the unvalid property name and value for an object. 

Now the controller expects a bookisticsEntities instance as constructor parameter but the default controller factory in the MVC framework only can use a parameterless constructor so you need a solution for this; use a dependency injection container like Ninject! It's easy to use available through Nuget. N-tier It seams to me your application missing one or two (maybe three) application level becouse currently you managing the database directly which is not a best practise. You have to build at leas one level between the MVC and the dataaccess tier which is called business layer (or two: a service layer and under that a business layer). In this way you controller will expect one or more different type of object instances but not your database model! If you are done whith this you can use simplified models in your application, for example in the Books action method you can use a model which can contain the author's name, identifier and the books also (books can be simplified also). Learn Entity Framework Read a lot about how EF works. :) 

We execute the function twice for each value and time only the second call â€” this is a non-rigorous attempt to prime caches and such to get a more accurate measurement. Some results for your original code are: 

Caching is definitely appropriate here as well. You can carry a cache through the calculations using an Erlang map. I took your original code and made the following modifications: 

I created an input file containing 9000 entries to be stored and used it to measure this solution to be about 150 times faster than solutions that read the input line by line, as measured by running the solution on the command line in a bash shell like this: 

On my machine, this overhead is ~1.20s. The original solution for input with 9000 entries and 3 lookups takes ~6.25s, while the solution I've posted here runs in ~1.23s, which means it imposes hardly any overhead over that of the VM startup and shutdown. 

The first value is , the second value the execution time in microseconds, and the third value the result of the function for that value. For values greater than 2, there is roughly a 6x increase in run time at each step. For of 12, the execution time is just over 75 seconds. Here are the results for the revised code: