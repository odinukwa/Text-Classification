Some editors may even help you by showing the type of the alias, rather than the underlying type. Extracting code to functions to improve singularity of purpose Finally, as has been mentioned before, it's helpful to extract each level of nesting into a little function. Not only is it easier on the eye, you can give each extracted piece of code it's own name. That helps to reason about what each step in an algorithm is doing as well. For example the first for loop is really just initializing a big old vector. I would move that whole loop into a function called or something and then move the second big loop into a function called or something a little snappier. And then maybe even have it return a new list or perhaps update its input and extract the printing section () to a different function as well. I know that its not quite as compact and also slightly (but not in a big OhO sort of way) inefficient, but it separates each section of code into what is logically doing. Some pseudo code to illustrate: 

Your code could do with some formatting. As it stands, it sure is short, but we have minifiers for that sort of thing. I have to spend a lot of effort to read certain parts because it is filled with clever tricks. 

I'm assuming you have some way to handle other image formats, like .bmp or .gif; if not to actually handle them, at least a way to tell the user "this service does not support that image type" or something of the sort. 

Split it up into "showWebView" and "hideWebView". Right now you're doing multiple things in the same function and they're completely unrelated. 

It is then up to MainPresenter (or more appropriately, other classes MainPresenter uses) to figure out how to handle threading. MainForm itself never has to know or care that you are using separate threads. 

Checking for changes is just a matter of comparing with . Note: this will be preferable to a collections object if you are transmitting your data between a client and a server, since the bitmask will be stored as a single int or long. 

Personally, I would use large string literals for your and values, as they are more visually alike to their expected output: 

Reduce Duplication There appears to be some significant code duplication between the encrypt and decrypt methods. Method Overloads The first and most obvious spots we can refactor are the overloads for your decrypt and encrypt functions: 

Board Whenever I look at code, I first look at the shape and the color. When I look at the code for , I find a lot of mixed colors in my color scheme. This suggests to me that maybe you are mixing data with logic. There are also a lot literals in there. Perhaps you can extract these and replace them with named constants or methods? Are you following the SRP? For instance, what does have to do with the board? Perhaps this is a little more ambiguous, but what about ? For , you are using a 9-element array which seems okay. You might consider making it a 2d-array to make the public interface a little nicer, but I suppose it's fine. But why initialize them with the numbers 1 through 9? It seems to me that the board should be agnostic regarding it's contents. The indices already indicate the positions and having the contents be more clearly indicates that it is empty IMHO. Are you happy with the argument name for ? What about or ? Later in the code you use the term mark, so what about ? What about the method name? Is supposed to know anything about the rules of the game? The local variable is really a constant. Consider extracting it. You might also want to break it up into rows, columns and diagonals: 

There is still duplication in the handling of A and B when it comes to . I think they're "groups", so I'll name the function : 

You should try making static. You create a new object with each request, when all you use it for is a a database handler. It doesn't have any internal state it keeps track of, except for the Connection and the PreparedStatement, which are overwritten inside of the method anyway. You close the connection at the end of the query, and as such, you could easily make static. It'd help with multi-threading as well, if two threads get a hold of the same and both do , they'd interfere pretty badly. 

Probably the names are a bit too verbose* and your algorithm may not make them quite as appropriate, but I hope you get the idea. * I don't mind long names for top level functions you call only once. 

Loops and Enumerators Loops should generally be avoided in ruby. The one exception is maybe a / loop. A loop should be avoided since it has different scoping rules from using an enumerator + block. Instead, try to use enumerators. They are shorter, simpler, safer (extra scope, usually hide loop counters, reduce mutable state, often remove the need for conditionals), and more explicit (e.g. what does this code do ). Stlye Guide The community style guide is an excellent guide. It doesn't just tell you what to do, but also why. And despite the name, it isn't merely about style either. You'll want to read it. The style guide comes with a great gem that does a lot of checking automatically (but do read the guide): Rubocop 

If you want them to retain the same organizational hierarchy they started with, you can do something similar to the following: 

You could simply make GameState a Flags enum, which is merely a more compact version of the decision table palacsint proposed. 

An alternative to @svick's answer is to use an extension method which only takes in two functions, and then chain them together, as follows: 

Object Disposal The most glaring thing I notice is that you aren't disposing of everything you need to. There's a statement for your reader, but both IDbConnection and IDbCommand (implemented by OracleConnection and OracleCommand, respectively) extend . The upside is that with connection disposal, you don't have to worry about explicitly closing it, so the try/catch wrapping your code in both functions can go away. Another fun catch: if you are using Oracle's ODP.NET or their managed provider library, OracleParameter is , too. End result, only addressing disposal (full disclosure - I rarely touch VB): 

I always find that the literals , and are code smells in ruby. This is because ruby expressions are always implicitly truthy or falsey and either or not . This means that the expression can almost always be written more succinctly and more efficiently as just (the exception being when you really need and not just truthy). Game I found this rather complex to read. A first suggestion would be to use attributes. That will get rid of all those signs :). In you are calling . But start screen has nothing to do with initializing. It is already running the game. Why not move it to the method? Should all methods be ? What methods do you want clients to call? You are setting up the player defaults in start_screen, only to then potentially change them later. Why not set them once and only once? The method is a predicate, so should be named . The method is not a predicate, so should be named or perhaps something else like . I like the name of the method , but should it be responsible for drawing the board and checking the result as well? You might be better of using a plain old instead of a case statement in Example code Here are some mostly complete examples. I feel that there is more room to move stuff around, but they should indicate the things I touched upon. I feel that the example class still has to much conditions and to much raw data. 

In an interface you NEED to define the semantics. If you define the semantics in function names and argument names then it is much easier to verify implementations. 

Poor ekans. Jokes aside, you should come up with something for this case. Some snake games I played would give me an instant gameover, and some snake games I played wouldn't allow me to move backwards (because snake cannot move backwards). Not allowing the player to move backwards might be more friendly to the player, because if the player presses the wrong button they might ekans by accident. 

More... table... stuff. Unclear what it does. It's separated from the other table setup, but it seems like it belongs with the column adding. Possibly wrap the table setup in a method anyway? 

Typedefs as an alternative to new types As others have mentioned, single letter variables are a detriment to readability. One way to help this is of course to add new types. As Corbin mentioned, adding a class or struct to hold just two ints can be a bit overkill (personally I don't mind). I'm not sure if this is considered good practice, but what I do in these situations is to create an alias: 

I can't comment yet, so I'll just respond here... I completely agree with @200_success that putting all these different problems together is not a great idea. It seems to violate the Single Responsiblity Problem even before your starting. Hash The common way to write a hash with symbols is to use the name-colon-value not colon-name-arrow-value: