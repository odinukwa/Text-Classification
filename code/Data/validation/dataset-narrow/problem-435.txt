As you can see, some methods used the modifier since their class does not hold any particular state. You do not need to stick to an array of integer but can use a Map instead. Your domain object should be immutable (which is not in this implementation: this is a design flaw. The object should copy the map provided to the constructor to ensure immutability). Avoid magic number (always prefer constants to literals when the inference of their meaning from the context is not straightforward). 

In OOP, you need rather to think in term of components which you can see as black boxes with a limited responsibility and which share well-established relationships with other objects. Other objects should not rely on the concrete implementation of these black boxes but only on the contract which describes how to use them and for which intent. With this in mind, we can extract a couple of conceptual objects for your purpose: 

Some context I've been tasked with supplying an escaping function to arbitrary CSS values that are entered through a form. The goals and caveats are: 

Also, if you're trying to move to the top or bottom layers, your method will never reach. You should add a check against to not be undefined. 

If it doesn't match, prompt the user with an error message and tell him to try again. Your job isn't to try to extract a good category from a bad one. At most you could just correct the case with if you want. 

And have the PHP handle the serving of the requested file. Getting Fancy You can even use and to rewrite URLs like this: 

Yes, it is safe. No, it is not a good idea. Don't mix application logic and configuration with the database, the database is used for permanent storage of data. Use a file (json, ini, xml, whatever) which is named the same but has different contents in production/dev environments. Then, it's as simple as: 

Ask the user how many dice rolls to do Create an Roll dice as many time as expected Print the result 

All of this is rather overdesigned for this particular program, but I hope it will help you to build your own insights about OOP design. 

With this separation of concern, you can see that it is not that important where the number of times to roll dice is taken from : be it from the keyboard input, from a file, from a program argument, a text field in a GUI or whatever. Where you print the result can also be abstracted. What emerges also from this design is the state object which purpose is to hold the computation result. It is an example of what we could call a domain object, which here contains the value-added by your business logic and is designed on purpose. It is used to convey information between the different components of your architecture : the producer (which computes the result) and the consumer (which prints the result or do whatever else). To make it more concrete, we could end up with the following objects: 

In the above example the nonBusinessDays of the week are SATURDAY and FRIDAY, and 1st and 2nd of June are holidays. In that case, 3 business days from now is June 5th. This can probably be improved further, let your imagination run wild :P 

Indeed there is! Use prepared statements instead of manually escaping and inserting into your query! 

In your case, the context is a MySQL query, you're trying to prevent SQL injection. The solution to SQL injection is not validation. It's prepared statements. So: 

As for drawbacks, the only one I can think of is having to do it yourself instead of having the language do it for you (Like, in example, in Java, which is where I guess this is coming from). So you'll need to remember to do it every time you have a rethrown exception. Personally, I wouldn't find this acceptable, as I would surely forget. 

An object which state will represent the result of the computation (=the dice rolls). An object which will produce the computation result (the "computer" object) An object which will provide the computer with the number of times it should roll dice. An object which will consume the computation result. 

Your code is clear and readable. You are asking about how much your code fit with OOP and this is a good mindset. I won't be writing here abstract and theoretical concepts about OOP or design patterns, but just the first ideas which came up to my mind while I read your code. 1) First, about naming In Java, method, variable and parameter names all start with a lower case letter (as opposed of methods in C++ for instance). You need to change the variable name and the method names and accordingly. Also, you should provide a better name for the integer variable which stores the number of dice rolls, like, for instance, instead of . The same remark applies for code wihtin the object. 2) About design Separation of concern and specialization of objects is one of the core concept in OOP. Here, your code is showing a rather procedural approach: 

Also, what's the need for here? How does it do things better than just making a new object and working with that? A few WTFs when going over your code: 

And that last snippet the only thing that's specific to your current DOM, so when your DOM changes, you don't need to change all of your code, just the bit that interacts with it. Additional notes for future snippets (just general things I've noticed): 

See the fetch API for more details. I need jQuery for collection iteration No, you do not. Mapping over arrays is easy. Mapping over objects is also quite easy. I need jQuery for this other thing No, you do not. Unless you need older browser support (Older = IE8 and below), you almost certainly do not need jQuery as a hard dependency. 

Your current abstractions don't really add value to an application. Why would I use your class over plain 'ol PDO? Yes, it should, and I'll explain. When you create an object, it should do one thing and one thing only. Your user object should be responsible for keeping track of data about the user. It's an object that represents a single user in your data model. Your user should not be aware of its own means of storage. A user specifically can come from many places. It can come from a register form, it can come from a database, it can come from a migration CSV file containing hundreds of users to be inserted at bulk. As a result, your user should be storage agnostic, it should not care where the data came from, it should just accept it in the constructor, and work with what it's got.