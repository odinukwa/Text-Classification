I'm looking for all-round feedback and criticism, suggestions for features, and any correctness concerns that may be present. Suggestions for an automatic way of determining and are also welcome. I'm also curious about what extra assertions I could be making to make the code fail in clearer ways when used with unreasonable s and s. EDIT: I found some significant bugs, so the code has been updated. 

First of all: names starting with an underscore followed by a capital letter are reserved for the implementation. You may not use them. Ever. You might also want to specify whether you're interested in all advice, or only that relevant to C++03; I don't see much C++11 could do here, but it's generally an important distinction. Now, comments: 

The way you're implementing a read-only object looks fine, except for being mutable. Are you sure you want it that way? It seems counter-intuitive with the rest of the class. Seeing as it is a private member anyway, why not make it just like ? Other comments: 

Yes, people can access things in , but you can't get around that sanely. Obscuring namespace names is only going to hurt compatibility (when a namespace gets renamed after you insert a new one, which will happen eventually). If people want to access your internals, they will. 

Now, as for creating several rows in the database. It creates one additional field per post in the table, because you are storing your value in a post meta. This is ok behavior, and shouldn't have any adverse performance effects on your website. Now what you want is to automatically delete this post meta, if the same is set on a different post. The first thing that comes to my mind is a custom SQL query placed on save. First you'd need to check to see if any of the posts have this field 

This query will return array of all posts that have your set to 1. You'll have to check if the current post id is the same as the one in this query, if it is, you can continue to save, and if it isn't you'd remove (with SQL query) this entry from the postmeta table. Also you could only check if the meta key exists, and if the post id is different, remove it. This will ensure the deletion of the database entry even if the value is 0 (unchecked checkbox). The other thing that comes to mind is . But I think you'd still need to sieve through posts with this post meta key, see if the key exists and the post id's are different, and then delete it with . 

Thus, for ultimate portability, and to satisfy pedantic compilers / analyzers, use types/casts with bitwise operators. Providing more information (return value) If you have the leeway to change the specification, you could make a couple changes to the function to increase the information it provides to the caller: 

Not only does this tell us if any "bit columns" are all , it also tells us which bit column is all (any bits that are in all of the input variables are set in ). Note that there are no logical operators here (i.e., , , ). This is important for algorithmic optimization because logical operations can "stall" pipelining or cause branch mispredictions, which can kill performance. For checking for "bit columns" of all , we could use the same concept (but with inverted inputs) as such: . But that's not taking advantage of our knowledge of Boolean logic. Recall from De Morgan's laws that (that is, "(not A) and (not B)" is equivalent to "not (A or B)". Thus, we can calculate as: 

Let's compare your implementation of to my functionally equivalent implementation. For testing, I created 2 datasets for input. One dataset ("Permutations") is just all the permutations of a, b, c, d (non- inputs, values ) (that's 164 = 65,536). The other dataset ("Randomization") is 65,536 randomly-generated sets of {a, b, c, d}, about 50% of numbers are , the rest are more-or-less evenly distributed between 0 and 16. I ran these datasets through our implementations 10,000 times. Here are the process's CPU times (in seconds): 

While C++11 does allow it. You are also missing overloads for comparison operators. A simple workaround would be to remove the overload and add a macro: 

It's hard to say whether the solution is proper when there isn't a problem to solve. How a class should be designed depends on how it will be used; a class in isolation is hard to judge. Even if you want to focus on some specific aspect, try to fit it into the context of a larger problem. Back to the code: I suspect should be a function. I don't see why printing a would change it. You probably also meant to pass your constructor a . Finally, are you sure a member function is really what you want -- why not an overload? Moving on to the function specifically, I don't think such a function is meaningful. An overload or a free function sound significantly more sensible to me. More specifically, the usage: 

When there's only one function that calls the function, the added benefit is significantly less; we end up obscuring what exception is thrown and losing the ability to rethrow if necessary. If this is all insignificant, a try function may be worthwhile; however, I'd use it in reaction to a common pattern, not in anticipation of one. 

Because everything you want is under the subdictionary, I would just reference it () at the end of the call). Here are the combined suggested modifications (using the list that returns, and using ): 

When the data doesn't have any values, my algorithm appears to be about 15% faster. When the data has lots of values, there is not an appreciable difference. This makes sense, because most of the time, every set of {a, b, c, d} statistically should contain two values. This shortcuts the differences between our algorithms, leaving only (in those cases), just checking for . 

All of the masking with individual bits and logically comparing values really eats up your performance on the randomized data. For the ordered permutation runs, it's likely that some compiler optimizations in conjunction with branch prediction helped out your times (because every group of 16 calls to had a, b, and c identical, varying d. This is evident because for the randomized data runs, your original algorithm suffers a 3x performance penalty compared to my implementation. The Takeaway This is probably one of those cases where, if performance is really important because you're operating on a lot of data, or you need hard real-time performance, that it pays to take a step back, and reconsider the data flow. If at all possible, removing the cases where you're checking the inputs {, , , } for will yield 2x-3x improvement in the algorithm computations. Alternately, if there's another way to handle those cases (mathematically, instead of conditional-logically), then you can just operate around the issue. 

Yay, you know about how to initialise objects that don't have a default constructor. That's a handy thing to know, and less common than I'd like to see it. Notice that we don't need the cast any more -- in fact, we don't even need to explicitly call s constructor. That's because can be constructed from a , which converts to. (If you're curious, isn't itself -- it's .) You used here, but there's no need for that. You can just output a newline character, and it'll get printed eventually -- makes sure it gets printed immediately, but unless the program crashes, it'll be outputted equally soon without it as far as the user can tell. 

That'll do the same thing, and describes the intent more clearly. As an aside: you say that didn't work. That is indeed something that won't work, partly because C++ doesn't provide an all-that-easy way of joining a string together with something else. Your best bet would be , unless you wanted to go through the trouble of explicitly creating a . There are also functions like and , but those are generally less safe or harder to use. 

is undoing the work did for you (which is the entire reason for using ). Instead, you should do this: 

This is one of those happy instances where optimization will increase performance, maintainability, and readability. But first, Analyzing your specification With what you have described, the example outputs you have provided, and the code submitted, if I had to back-derive specifications for , this is the best I could do: 

Use the returned by Edit: my original response directed the OP to use library to parse JSON-formatted text. That was incorrect, as the returned data was already parsed by library. The returned from your function is a of the key-value data shown in your "Results for from " section. Thus, you just need to access the appropriate key of the (specifically, the keys in the of the returned data). To access the and fields you were looking for, they are under the key: 

Edit: Original code masked with , which was erroneous. Mask (corrected above) should be . Note: I have use casts because per the C11 standard, ยง6.5, para. 4 (emphasis mine): 

I created a function that will tell me how many times a number is divisible by another number and what the remainder of it is: 

If you're on a single post or a page, you'll get the post meta, and if you're anywhere else, you'll get blog description. And then output it only if it's set and not empty. My advice is to see all the cases that can come up with conditional tags and set your description accordingly ;) 

What if your variable is empty? You are only checking if you're on the front page, or home page, and set it to blog description from wordpress, and if you're not, you're setting it to your post meta value. What about categories? Tags? other archive pages? The 

If the variable is set and not empty string you'll get a true as a value that will pass the test. I'd do it like this: 

Can this code be optimized somehow? I tried to use directly, but couldn't find out the count that way. The only thing I could think is to create am array of numbers and go through each one. I mean this does the trick, but optimization is important, and I was wondering if there is any other way of doing it? 

As for optimisations -- you could convert it into a list of numbers yourself, thereby skipping some error check that str() may be doing (however, as Winston Ewert has pointed out, this is unlikely to be faster). You could also try not creating a string at all like this: 

First of all, please make sure that your indentation is correct, especially when posting Python code. Also, take a look at PEP 8. You are violating it in at least the following places: 

As others have said, use . As others have not said: definitely use . You cannot sanely mix raw C strings and exceptions without smart pointers. In fact, mixing any dynamic allocation with exceptions without smart pointers is a great way to drive yourself insane, but in this case it's not even remotely justified as there's a class that does exactly what you want. Now, let's see how can be rewritten: 

This is an okay base, but you're missing a great number of features that I would expect a smart pointer to have now: in particular, you don't support custom deleters or array types. Also, on a purely stylistic choice: I would define the member functions of such a simple class template inline. You can't hide the implementation anyway, and when the overhead is so small I don't expect it to matter for readability. (I presume that for getting a list of functions you use your IDE's features, or something like Doxygen.) 

Return if any of the inputs are . Let the output value tell you which "bit columns" were found identical. Even if you don't need that knowledge currently, calls to the function like such, 

provide the same logical information as calling as you originally posted it like: . But with this suggestion, the following information is available: 

This cleanly separates the business logic of the game from the mechanics of running the game multiple times. Also, it frees up to return the number the number of guesses the user took, so that (or other calling code, in the future) can collect statistics about gameplay. 

Now maybe your use case does not care about which bit(s) is/are common. But one of the nice things about C's design, and most idioms in C, is that truth is reduced not to and ; but to and anything but . I will come back to this point in my suggestion. Recognize the opportunity to work in parallel C's bitwise operators are just parallel 1-bit logic functions, so there's no need to check for individual bit positions one at a time; bitwise operations do not "interact with" neighboring bits (unlike mathematical operators, which have carry / overflow). So, to check if any of the "bit columns" in {, , , } are all : 

One thing Loki Astari hasn't covered is const correctness, which your code is sorely lacking. You should make anything that isn't going to change , and mark all non-static member functions that don't modify the object they operate on as , too. For example, the declaration should actually be , and the definition should be . Further, I'm not sure making private is all that good an idea. Are these nodes going to be used by one class, or many? If only one class needs to be aware of them, you could choose to make them a nested class and expose more of them. It probably won't matter for performance after inlining, though. On the other hand, I see no reason at all to keep around, as it is only ever set to 0 when an instance is created, and then never touched again (until the destructor, but that's mostly redundant). You should also watch out for variables that start with an underscore: if the underscore is followed by a copital letter, the name is reserved, and you should not use it. If you insist on marking your member variables somehow, consider a prefix or an underscore suffix.