It's good you have --innodb-read-only set to InnoDB handle read-only situations. You also need to make sure innodb_change_buffering is 0. You also needed to make sure that crash recovery never happens. Here is how to set it up. First, with the database on a writeable media, login to MySQL and run this: 

These counts match your output for the Without introducing another subquery, this is my suggested query. SUMMARY The output would have to be used as follows 

My Windows version works ? I say you definitely have a bug in the Ubuntu version. I reran it again, this time running 

When doing this, please do not move the grants by dumping the mysql schema. The number of columns have changes between versions : 

You could run against all your InnoDB table to provide some shrinkage. See my 5 year old post Why does InnoDB store all databases in one file? for ideas on how to shrink your tables. Unfortunately, you cannot do that in you present state. See this YouTube Video. As for your not being able to list your databases, please note this: 

OK, all well and good. But, why doesn't get to receive anything? Because is not enabled, does not save the and the original server_id posting the into its own binary logs. If was enabled on , now follow along your example and let's see what should happen: 

This should make a significant difference Give it a Try !!! UPDATE 2012-02-28 12:51 EDT I refactored the query a little deeper to try to get a hold of the posts with 88 and 5 tag_ids a little differently 

If all your database use InnoDB only, I have some good news. You should be to dump all the database in parallel from a slave. In fact, you can force all the databases into the same point-in-time. First thing to remember about a the Slave is that it is not not required to have binary logging enabled if it is not a Master for other Slaves. You cannot use option for parallel dumps because each dump will have a different position written at line 22 of each dump file. It is better to record the Master's last log file and position the Slave executed using . That way, all the databases have the same point-in-time position. You can collect all databases and script the parallel dump of all the database. 

Using the different password, this may provide the restriction. Make sure you have both and are defined in . Check by doing: 

InnoDB Your status for the Buffer Pool says Buffer pool size 1310719 That's your Buffer Size in Pages. Each page is 16K. That turns out 20G - 16K. Please note the the following: You pushed data into the InnoDB Buffer Pool. What changed ? 

The documentation is not as clear as it should be, but I would say no, mysqlhotcopy does not block SELECT queries. Here is why REASON #1 : MySQL Docs on 'mysqlhotcopy' 

Indexes on each separate column may yield index merges. This compound index will bypass that. Please try instead of 

You can gather keys only (in stages), then join the keys with the table. Here is my new proposed query 

SUGGESTION Run on the Master See if the movement triggers a response from the SQL threads. If it does not, go ahead and remove slave_parallel_workers from and restart mysql. Since you started MySQL up and master and slave and got , that means you are trying to establish replication from an impossible position. In the context of GTID and error message you got, the binary logs needed to fully identify a set of queries within a GTID set no longer exists, Look back at your 

Since the short_url is a keyword, maybe refactoring the query could be a game changer Start with getting the top 10 keywords whose count > 50 Then, join the 10 words to the other tables 

The default for group_concat_max_len is 1024 (1K). I set it to 100M in case the list is long. This query will work faster if you have a comound index on If you do not have such an index, then create one: 

to make sure the table structures match. GOTCHA #2 : You cannot read any data anymore from the Master You must do all writes to the Master and all reads from the Slave GOTCHA #3 : Heavy Network Latency can still introduce some Replication Lag Even though writing data is much faster this way, network problems may prevent needed data from showing up on the Slave in time to read. SUGGESTION : Try using a crossover cable on a separate NIC, assigning it the 192.168.0.x netblock to replicate over in order to prevent replicating through switches, firewalls, long routes, etc. GOTCHA #4 : There is still diskspace for Binary Logs being piled up SUGGESTION : Set expire_logs_days to a small number, like 2 or 3. I would not use 1 because you need to fix the Master in less then 24 hours. Having a 1 or 2 day cushion will help. First, add this to 

You would essentially have data that grows quadratically (even exponentially) just in MVCC alone. The process of managing the rollback of SQL with triggers that can be non-DETERMINISTIC would be ungodly complex, to say the least. In light of these two aspects, I'm sure MySQL Developers thought of these things and quickly dismissed them by imposing restrictions. So, why lift the restriction for Procedures? Simply put, there is no concern over DETERMINISTIC properties or Rollback. 

Notice column #8 : . Its data type is . Also, notice column #12 : What do these settings tell me about the stored procedure's usage? 

You can only do that on the Slave. That will create the table to hold manifested data again on the Master, which you need to avoid. As for any other , if you 

You are better off dropping and recreating. Why ? ANALYSIS Let's take the hypothetical example from your question 

This is how mysqld expects user privileges to be organized and distributed in the grant tables. If you update all the privileges in mysql.user for to 'Y' and run , you will elevate to a global superuser. This is why you are better off doing GRANT and REVOKE and trusting mysqld to get it right. 

The WHERE should not have a function on both sides of the equal sign. Having date on the left side of the equals sign makes it easier for the Query Optimizer to use an index against it. SUGGESTION #2 : Supporting Index I would also suggest a different index 

You shouldn't be relying on the OS processlist to display mysqld options in the events other versions of the OS do not display them (as your questions points out) What other methods can you use that are OS-independent ??? METHOD #1 If you enabled show_compatibility_56, then login to MySQL and run 

This one line query can replace a trigger and a stored procedure. Optionally, you can place this one query in a stored procedure and call it if you so desire. 

I am not sure if the the user's per-hour connection limits are per thread or per user. You could answer that quickly by connecting to the DB aggressively using 2 or 3 DB connecitons at the same time and the error message should manifest itself. It is up you how to count the number of connections, perhaps "SHOW STATUS LIKE 'Connections';" It should reach either the max limits of the connection within the one connections or it could be the sum of all connections' connection status value. Please also check the wait_timeout and interactive_timeout values. The default is 28800 in a standalone server. They may be set already. You cannot set them within a current connection. You must be able to set them as follows: (for new conenctions coming) 

DISCLAIMER : Not a MacOS user That is an alternative way. This shutdown method can be done in MacOS, Linux, Windows, any platform MySQL is supported in. I actually prefer your mysqladmin method for a reason... In Linux, I have seen the (the socket file) file just up and disappear without warning. The standard way to shutdown mysql in Linux is . Whenever the socket file disappears, the mysqld_safe program cannot shutdown without first seeing in the socket file. Such a standard shutdown would just hang. I usually connect using TCP/IP