Your new approach is much better than the previous one. Instead of deriving from and using to hide the base class implementations you create a wrapper around a implementing - this is a much more robust way. However there are a few oddities: 

Overall Your header doesn't include any function declarations so I'm not sure what your "public interface" will be but only few of your functions are so I have to assume you intend to make all others available in which case I have to say I don't like the interface into your structure. From the looks of it your should only be manipulated through the appropriate functions yet your return the pointer to the internal storage from various functions which has the potential for the programmer screwing it up easily. So consider carefully defining the interface into your structure and how you intend it to be used. Most of you functions should either return or an result indicating whether or not the operation was successfully executed. When dealing with memory allocation you should always check the result. I'd probably even go as far as making opaque. Suggested interface in your header file: 

I always find that the literals , and are code smells in ruby. This is because ruby expressions are always implicitly truthy or falsey and either or not . This means that the expression can almost always be written more succinctly and more efficiently as just (the exception being when you really need and not just truthy). Game I found this rather complex to read. A first suggestion would be to use attributes. That will get rid of all those signs :). In you are calling . But start screen has nothing to do with initializing. It is already running the game. Why not move it to the method? Should all methods be ? What methods do you want clients to call? You are setting up the player defaults in start_screen, only to then potentially change them later. Why not set them once and only once? The method is a predicate, so should be named . The method is not a predicate, so should be named or perhaps something else like . I like the name of the method , but should it be responsible for drawing the board and checking the result as well? You might be better of using a plain old instead of a case statement in Example code Here are some mostly complete examples. I feel that there is more room to move stuff around, but they should indicate the things I touched upon. I feel that the example class still has to much conditions and to much raw data. 

Apparently your solution is quite over-engineered for a problem like this so I just assume you did it for the lack of a proper example (to be honest I usually find it quite difficult to come up with simple, comprehensive examples where the application of more complex designs doesn't seem over-engineered so fair enough :)). Your should not be static. This for example prevents running multiple FizzBuzz games simultaneously. Just create an instance with the specific multipliers as a member and store it as an additional member of your iterator. Static classes which hold states are evil (there are probably sensible applications for it but in general terms they are bad) as they create problems with unit testing, parallelization, re-use, modularity, etc. You have hidden the actual business logic in the class as a static method. A more central place to have that function would be the as it is the one which effectively decides which to create. The most common definition of the FizzBuzz game I know of is this: 

Loops and Enumerators Loops should generally be avoided in ruby. The one exception is maybe a / loop. A loop should be avoided since it has different scoping rules from using an enumerator + block. Instead, try to use enumerators. They are shorter, simpler, safer (extra scope, usually hide loop counters, reduce mutable state, often remove the need for conditionals), and more explicit (e.g. what does this code do ). Stlye Guide The community style guide is an excellent guide. It doesn't just tell you what to do, but also why. And despite the name, it isn't merely about style either. You'll want to read it. The style guide comes with a great gem that does a lot of checking automatically (but do read the guide): Rubocop 

I can't comment yet, so I'll just respond here... I completely agree with @200_success that putting all these different problems together is not a great idea. It seems to violate the Single Responsiblity Problem even before your starting. Hash The common way to write a hash with symbols is to use the name-colon-value not colon-name-arrow-value: 

Style Standard C# naming convention for methods is . For static and instance members there are more variants around but often they are prefixed with and/or area also so they can be easily distinguished from local variables and parameters. Following standard naming conventions makes your code look more familiar to other C# developers. Structure It is all methods and global variables which seriously hurts maintenance and makes testing the code real painful as you probably have already discovered (I guess you have managed with a lot of commenting in and out code). The easiest way to simplify this is to provide an abstract base class which the various implementations can derive from an implement. You should also pass the buffer size and values to produce/consume as parameters to break dependencies on global variables. Something along these lines: 

Typedefs as an alternative to new types As others have mentioned, single letter variables are a detriment to readability. One way to help this is of course to add new types. As Corbin mentioned, adding a class or struct to hold just two ints can be a bit overkill (personally I don't mind). I'm not sure if this is considered good practice, but what I do in these situations is to create an alias: 

Board Whenever I look at code, I first look at the shape and the color. When I look at the code for , I find a lot of mixed colors in my color scheme. This suggests to me that maybe you are mixing data with logic. There are also a lot literals in there. Perhaps you can extract these and replace them with named constants or methods? Are you following the SRP? For instance, what does have to do with the board? Perhaps this is a little more ambiguous, but what about ? For , you are using a 9-element array which seems okay. You might consider making it a 2d-array to make the public interface a little nicer, but I suppose it's fine. But why initialize them with the numbers 1 through 9? It seems to me that the board should be agnostic regarding it's contents. The indices already indicate the positions and having the contents be more clearly indicates that it is empty IMHO. Are you happy with the argument name for ? What about or ? Later in the code you use the term mark, so what about ? What about the method name? Is supposed to know anything about the rules of the game? The local variable is really a constant. Consider extracting it. You might also want to break it up into rows, columns and diagonals: 

Instead you should be able to store the compiled delegate when setting up the mapping. Similarly it might be an option to pre-create the instance - either per (becomes a singleton) or per mapping. Given that these filter instances seem like they should be stateless anyway having them as per-type singleton might be a viable approach. In should be restricted with or else your may throw a Since in you currently can't deal with being you should not use but a direct cast instead. 

Alternatively to the you can use and ignore the line if it returns for any of the 3 entries. Update: Version with . 

The code is much easier to read and has probably less bugs than your self implemented one. It's also fast. I can pump 10,000,000 items (I tested with ) through a channel (buffer size 100) with single producer single consumer in 5sec. That's 0.5ns per item. 

Probably the names are a bit too verbose* and your algorithm may not make them quite as appropriate, but I hope you get the idea. * I don't mind long names for top level functions you call only once. 

Some editors may even help you by showing the type of the alias, rather than the underlying type. Extracting code to functions to improve singularity of purpose Finally, as has been mentioned before, it's helpful to extract each level of nesting into a little function. Not only is it easier on the eye, you can give each extracted piece of code it's own name. That helps to reason about what each step in an algorithm is doing as well. For example the first for loop is really just initializing a big old vector. I would move that whole loop into a function called or something and then move the second big loop into a function called or something a little snappier. And then maybe even have it return a new list or perhaps update its input and extract the printing section () to a different function as well. I know that its not quite as compact and also slightly (but not in a big OhO sort of way) inefficient, but it separates each section of code into what is logically doing. Some pseudo code to illustrate: 

In this case there is not much code and it's not terribly complicated but you should get into the habit of choosing good names. is not a good name for the as it doesn't represent a dictionary in itself - it's a reader which reads lines from a file. All your code is in the method. You should get into the habit of building reusable pieces of code - in the case of Java this means creating reusable classes. So I'd suggest your create a dedicated class which holds your lookup structure and provide as well defined interface for adding valid words and looking up a word. Something like this: 

A better alternative to the busy wait loop would be to use a Semaphore - in this case a would probably be the most appropriate. Semaphores are not reentrant. This would simplify the implementation to: