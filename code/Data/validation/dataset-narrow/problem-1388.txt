Are you accidentally firing more than one missile at a time? Is it possible that your code creates two missiles at the same point in time and it's the second one that's hitting the asteroids? Edit: To solve the problem of removing asteroids and missiles, you create 'to remove' lists. Using your code: 

I would use the built-in methods. Much less hassle. ;) If you want to specify directions at arbitrary angles, the easiest way to do this is using trigonometry: 

Comment as answer: In that case, how does your ray picker check against the bounding spheres? My thought is that, if worldBox is the only thing you're changing, it must co-incide somewhere with the picker algorithm. Two possible problems: 1) does the ray picker use the worldBox matrix? 2) If not, are world and worldBox created at the same time? Have you inadvertently got two references to the same matrix? 

Storing maps as tiles is useful for allowing you to re-use assets and re-designing the map. Realistically though it doesn't really offer much benefit to the player. Plus, you're then re-drawing every single tile each time. Here's what I would do: Store the whole map as one big array. There's no point having maps and submaps, as well as potentially sub-sub-maps (if you're entering buildings, for instance). You're loading it all anyway and this keeps everything nice and simple. Render the map all at once. Have an off-screen canvas that you render the map to and then use this in your game. This page shows you how to do it with a simple javascript function: 

You'll find that your first value is moving about 1.4 times as fast as the second, based on the lengths of the vectors: 

and then plug your back in to the line equation to get the crossing point. From this we can intuitively read a couple of simple properties: If the line's direction and the plane's normal are perpendicular there is no crossing. is zero, which would be a divide by zero. describes how 'far' is from the plane in the direction of the plane's normal. N.Q then describes the ratio between the direction of the plane and the direction of the line - the more parallel the direction and normal, the faster it will intersect. 

If you want to protect your source, don't write it in HTML/Javascript? Part of the really nice things about the web as it's all human-readable. This makes it an excellent learning resource. If you're telling me that you've never looked at the source of a website to learn how it does something, then feel free to tell me I'm wrong. I'm all bout sharing the love with code, otherwise I wouldn't answer questions on a website about offering help, all for free, would I? Edit: I've said what I think of it, is there a way to make it non-readable? No, not in pure JS/HTML. The reason for this is simple: Somewhere down the line, it becomes readable. If you obfuscate it then a deobfuscator gets you. If you use a cipher or translate it somehow, at some point you have to translate it back into javascript (and the code to translate it back needs to be in your source too!). The best you can do is to protect against bandwidth theft and obfuscate if you really feel the need, but it's not going to stop people if they're really determined. 

It's very difficult to move an object independently to match an animation. The standard method is to attach the object to the skeleton of the mesh. Otherwise, you would need know the precise dimensions of both meshes (character/hand and object) and the movements of the animation at every frame if you want it to look right, which can be pretty resource heavy. Alternately you would need to do some rather complex computations based on the key-frames of the animation and you would still need to know the precise dimensions of the mesh. You don't want to have to rely on 'magic numbers' like mesh dimension or else when you change the mesh, you need to change your code too and that is bad practice in programming. This is also rather computationally expensive for little gain, especially if you are trying to get the dimensions of the mesh on the fly. The animator handles all of this complexity for you if you attach your object to the skeleton. Though not perfect, it will almost always be good enough. Your attached object may still penetrate the mesh at some points, since the animator doesn't track the dimensions of the mesh either, just the skeleton. You might get more accuracy if you animate the object separately from the character mesh so you can make slight adjustments in your object animation to account for variances in how the object should move compared to the hand, but that is usually overkill and that kind of accuracy is rarely needed in a game. 

Another way that is probably more common, is to just set the instead. This doesn't quite interact with the physics in the same way though, so it's up to you and what you need from the jumping behaviour. You should try both. If you want the player to jump a specific height or distance, then is probably going to be easier for you. It's trickier to calculate how a force is going to affect your jump compared to using velocity. Here is a question on the Unity site that talks about your specific issue. 

I also had to add an OnDisable event to the FirstPersonCam script. (I changed the code a bit, but other than the OnDisable() and the addition of support for Roll), it is the same. Roll is not actually used, since the roll speed is 0.0f; FirstPersonCam.cs 

As Menno Gouw mentioned, you could use a noise function although you can actually use any PRNG. You will need to seed it every frame though, based off some predictable, relative value, such as the player position. If the player only moves horizontally, then this is simple. seed = player.x I don't suggest a noise algorithm in this case, since the implementation is rudimentary and a noise function is relatively expensive for no real gain. If the player moves in more than one direction then you will have to construct the seed value by combining the positions on each axis since most PRNG's only accept a single value for the seed. This is not very complicated either but I won't go into detail. If you need to generate a seed from a vector, then you may want to consider using a noise algorithm, though it is still overkill. 

Quite a common thing to do with some matrices is to cache the value and only update it when it's changed. There's two ways to manage this scheme, push or pull. Pushing matrices would involve, at the point of a matrix changing, letting child nodes know that the matrix has changed. These nodes will then have to let their children know, and so on. The upside is that it only requires storing the extra matrix, but you re-compute it every time it changes - if you change matrices within the hierarchy a lot then the matrices at the bottom will change an awful lot during the frame. The reverse it to pull matrix changes - when a value is changed, it sets a boolean value which says that the matrix has changed since it was last read. This is commonly referred to as a dirty matrix (programmers are weird.) Upon requiring a matrix, you check if it is dirty (or its parents). If it is, you recalculate the matrix. The downside of this is that you need to check if things are dirty all the time. When I said there was only two methods, I lied: you can go for a hybrid approach somewhere in the middle. Push the dirty flag down the tree, and let children know that at least one of the parents' matrices are dirty. At the same time, calculate the matrix only when needed. If your only ever process the tree in a downward fashion (from the root to the leaves) then you can get away with only one matrix multiplication per node as a maximum. 

It probably doesn't look so good since interpolating between them relies on always having the next set of data to interpolate to. This means that, if there's a short lag spike, everything has to wait to catch up. There's an old article on GameDev about using cubic splines to predict the position of an object past the point where you last had data for it. What you then do is use that position and then adjust the spline when you get new data to account for its new position. It's also probably much cheaper than running a second physics simulation, and it means that you don't have to decide about who you trust, since you've explicitly implemented the client making it up as it goes along. :) 

A vector is data. The functions are more like utility functions - they're not specific to that instance of the data, they can be applied to all vectors independently. A nice way of thinking about it is: Can these functions be rewritten as static methods? If so, it's just utility. 

To rotate a polygon around its centre like this, you need to draw it around the origin. Currently you're drawing it off-centre: 

There is no event handlers for touch inputs. You can make them if you want. It's not very difficult but I don't recommend doing it like you have described anyway. Input events should map to the actions to take, rather than the specific input method used to implement that action. Consider if you are making a game for both desktop and mobile. OnTouch doesn't make sense on the desktop and OnClick doesn't make sense on mobile. It's better to have something like an OnSelect event that is called when either a touch or a mouseclick occurs. Also consider if you might want to allow the user to remap the inputs or even if you decide to change the input mapping yourself during development. OnTouch or OnClick events would create complications and require reworking lots of code, rather than just having OnSelect and changing how it's triggered. To make your own event handlers, investigate the GameObject.SendMessage() method. Basically, what you would do is perform your tests for touch or left-click in the method and trigger your OnSelect event when one or the other is detected by using SendMessage. 

Use the inspector to allow the user (you, or other developers) to be able to easily define the Component themselves without having to modify your code. Use the GetComponent() method if there is no need to be able to change it from the way you designed your script. Efficiency doesn't have to do with it. If you use GetComponent() in your script, you will generally store the component in a variable so that it is cached for reuse in your script, so it works out to be the same thing in terms of efficiency. Where GetComponent() is slow, is if you are calling it as you need it to look up the component every update or something. Store it in a variable and then it's just fine. Same goes for the FindObject methods. Cache it when your script starts, then it has no impact during runtime. 

Have you tested if the child objects really are active in game? The behavior has changed from Unity3 when SetActiveRecursively was needed. Since Unity4, setting the parent to inactive should also deactivate the child objects (in game) even though it still shows them as active in the inspector. See the documentation for GameObject.SetActive() 

In C++, you can get the path of the binary with the parameter that is passed to the function. You will need to define as... 

By default is applied over time, not in an instant (which is what you want). You can change that though by using the second parameter, such as... 

I'm assuming you are using two different cameras (as you probably should). If so, then the script below should work for what you want. Attach this script to the player (or any gameobject that is always active in your scene). Then be sure to assign the cameras to the script from the inspector. When you are switching cameras, particularly from the other cam to the first-person cam, the FirstPersonCam script is already active so it is going to react to mouse movements immediately. It has to be deactivated, then slerp, then activated when the interpolation is completed. Also, when the script is deactivated, the angles need to be reset so it transitions to a clean state looking straight ahead. SwitchCamera.cs 

This will give you a unit vector in the direction of from your left example, going counter-clockwise. If this sounds complicated, think of it as a clock hand that starts at 3 and goes counter-clockwise as the angle increases, and reaches back to 3 at 2*PI radians, or 360 degrees. To get extra-fancy, multiply these by a 'speed' value to get a velocity vector: 

This will draw a small portion of the map centred around . This will offer you smooth scrolling around the entire of the map, as well as sub-tile movement - you can store the player position as 1/32ths of a tile, so you can get smooth movement across the map (Clearly if you want to move tile-by-tile as a stylistic choice, you can just increment in chunks of 32). You can still chunk up your map if you like, or if your world is huge and wouldn't fit in memory on your target systems (bear in mind that even for 1 byte per pixel, a 512x352 map is 176 KB) but by pre-rendering your map like this you'll see a large performance gain in most browsers. What this gives you is the flexibility of reusing tiles across the world without the headache of editing one big image, but also allowing you to run this quickly and easily and only consider one 'map' (or as many 'maps' as you like). 

Do you ever move the bounds? If not, then all the rectangles are always at 0, 0, 60, 60 and always intersecting. You need to move the bounds to the location of your ship/asteroid: 

Clearly again here the top-left corner in both is the same. If we want the middle of each square to be in the same place (and generally you do since it's the easiest way of thinking about it), we draw our square so the middle of it is initially at zero: $URL$ 

What do you get if you try and swap the order you draw them in? Transparent pixels still create depth buffer entries. If you're drawing the back one after the first it's not processing the pixels behind the front image, making it look like there's no alpha. For reference, take a look at the Painter's alogrithm. 

If you're not sure of this (i.e, you might have caves or overhangs or similar features) then the way to do it is slices. Slices are all the same size (the whole of your map) and you would have one for each and every Z level possible. You would also require a new tile type of 'Nothing', which means you just don't draw anything. This way is more expensive, but if you need the flexibility it's the way to do it.