If you have not done anything with linux then don't even include the header files. This gives a user a false sense that this is correct which is unknowable until you test it. 

It expresses intent more clearly and also will remove all the casting issues that you are going to have in the rest of your code. Never use C casts. Always use a C++ cast. They are easier to spot in the code and express intent much better. 

This is better if used in the correct context. BUT you can never do this in a header file. If you ever want to write code for a shared project (or a project with two or more people) then this will eventually cause a breakage. This is because including your header file can potentially change the meaning of my code. You never want your code to change the behavior of other peoples code. This will get your code banned from projects and your hand slapped. Now I know the next thing you say will be. But this is my project and nobody will ever use this code. First never say never (stranger things have happened). But the main point is that this leads to bad habits. You may do it here because you are trying to be lazy and cut down typing. Then it will become the normal thing you do then when you work on other projects you will do it without thinking (muscle memory). So it is best to break the habit early. Now you can use the above in a source file (but I would advice against it). Use the clause in as tight as scope as possible. The exception to the rule. As always there are exceptions to the rule. When writing your code. When you declare your types in a namespace declaration in the header file there is no prefixes. But when you then start to define your types in the source file you end up adding all the prefixes. 

Any object that uses this method not becomes very tightly bound to this interface. I would question the need for this functionality. I prefer to expose methods that manipulate the object as a whole. An alternative is to expose the iterators. Iterators are a much looser coupling. As a result I would make a private type. While the and would be public. Edit: 

This is because rand() returns a number from [0,RAND_MAX) or [0,32767) which is not exactly divisible by 6. So you get: 

Never use C-Casts C casts are hard to spot (in general). But also using C++ casts you can mark dangerious casts by uisng the appropriate cast. 

Should you return a ? The function says min value. SO why not return the minimum value. Also you don't want to expose the implementation details and returning a node exposes these. But is recursion the best way to handle this? Since you are simply traversing along a chain a simple loop seems much more effecient: 

Does not guarantee that it will write everything you asked for. Personally I would use a lower level write function so I can accurately check the error state and compensate accordingly. 

Technically you only need to call factorial once. If you calculate factorial for 'n' you need to calculate the factorial for 'n-1' (its how it is defined). If you store the numbers then you only need to look up the values to print it once they have been calculated. It seems like you calculate this value each time. 

You define the and but the other two you don't define. So the compiler will generate the other two for you. Usually these work fine. BUT if your class contains an owned RAW pointer then the default versions don't work as you would expect. So you should look up the rule of three. If you have to define one of Copy Constructor/Copy Assignment or destructor you probably need to do all three. If your class only uses objects that obey the rule of three already then your class will obey the rule of zero automatically (look them up). Design Review Asking user to provide a large set of hash functions is unreasonable. Hash functions are hard to define in the first place and even harder to get a good distribution with over a set of them. You need to define some way that in most cases the hash is provided (though being able to provide your own is a nice touch). 

What @user2675345 said. Also don't force a on your users. There is already a concept of a queue in C++. $URL$ Use the same technique and default to but allow other types. 

Iterators in C++ are well defined. They are objects that respond to ++ and * (de-reference). Return an object like this. Otherwise your list can only support one iterator. 

Getting close to a release of generic server. Nisse Server: Part 1 Helper Functions Nisse Server: Part 2 Socket Layer Nisse Server: Part 3 Stream Layer Here is the server. The basic usage should be very simple: 

But this is all done much tidier when you use the copy and swap Idiom. The constructor/destructor of the temp object handles or the resource management for you. 

No. Because you have a new in a constructor and delete in the destructor. You MUST also define the copy and assignment operators as well. Look up the . But I would skip all that and use a and let the vector do the memory management for you. There is a concept called . This basically states that a class should either do resource management or business(game) logic. A single class should never do both. Unfortunately you are doing both in . By using to handle your resource management (memory management of the Tiles) you can make sure that Level only needs to handle business logic. 

ServerInfo Object that controls all threads. Keeps a map of QueInfo objects. Each one represents a running thread. Only the main thread sees this data so no locking needed. 

Since C++11 (and it is now 2016 (so that is 5 years ago) and we are on the verge of releasing C++17) the ifstream can also take a string for the file name. So we can update the function again. 

I like this better as we do not need to guess that maps to or maps to as we can explicitly get the type we want: 

Only virtual methods can be abstract. If you forget to define a method the compiler will not complain (as you may define it in another compilation unit). The linker will only complain if somebody tries to call the method and can't find a definition. So if you don't call it then there will be no error (but if you don't call it then it does not matter). When you implement a virtual function in a derived class it is probably best to mark it as virtual to show a subsequent maintainer that it is virtual function (but it is not required by the language). You should also note that C++11 introduces they keyword . Which is an indicator that this method overrides a virtual method in a base class. If there is not such method in the base class it is a compilation error. Other Notes Your code passes all parameters by value. This is probably not what you want (as a copy will be made). If it is a derived type the base parameter type will be sliced out and passed to the method. So pass by reference. 

The node is a random place in memory it has no relationship to the order in the list. Giving your iterator this ability will result in it being misused. The should return the same as (but a pointer rather than a reference). For integer types (of T) this will make no sense (but will generate a compiler error). But when T is an object type it allows accesses to the members of that object. 

Coding wise there is nothing really interesting to comment on. It looks pretty bog standard simple code. I don't see any clear performance killers. 

The problem here is that you loose control of leveling up. With this technique anybody can write an alternative way of leveling up. Then if things change you need to find and modify all the techniques when you change how leveling up is done. This should all be part of the player class that way leveling up is controlled as part of the player. It is done in one place (and only one place): 

BUT There is no actual need to cast a char to an integer. This will happen automatically (as a char is an integer type the conversion is automatic) with no loss in precision. Is there a need to put the largest first. I don't see you taking advantage of this in the function above! 

I only return a value if there is a potential for failure and I want to be able to indicate the possible failure states. 

This pragma is basically useless as it is non portable. Use the appropriate include guards unless you want to be locked into your current compiler only. Not sure why you need to make isVisitied a member. 

You don't need these as a class member. It should be local to the member functions where they are used. If I was you I would add another member though. 

The number of elements currently in the vector. The amount of space allocated. This is space allocated but currently unused. Normally when creating arrays you allocate slightly more space than you need. So you can use it without having to reallocate the whole data segment and copy it just for adding a single value (or when deleting a value you just reduce the size and can safely re-use it). 

You don't need to read the whole program into memory. You use a stream to represent the program. Reading a character automatically moves you to the next location. If you need additional control of the stream you can use seekg() to move around the stream a bit more. Rather than multiple . This is the perfect situation for a : If there is an error you should return 1 rather than 0 so that the inclosing shell notices there was an error. There is a small bug in your back seek: If you have code like this: 

Another thing I like about the C++ way is that it basically does all the work at compile time rather than run time. Run time parsing of the format string seems a bad idea when we could do it at compile time. Not sure how to solve that, but my thought. Also I don't like that you build a string and return that as the result. This means we are doing extra work. Why not use the string to simply apply the correct output formatters to the stream. 

This just gives you the opportunity to misuse in the code. If you declare and initialize in the same statement then no misuse. Also C++ code should never contain a (especially when you are learning). It should have very few calls (if any calls) to . Dynamic memory management should be controled via an object. This is usually a smart pointer or a container depending on your usage. Thirdly why use the C-String API. C++ has its own string that handles memory management for you and does a better job. Currently your code is not exception safe. An exception thrown in your code will result in leaked memory. Thirdly you actually did it wrong and did not allocate enough space (you forgot to allocate space for the character that terminates a C-String). I know you used the to compensate for this. But all the other string functions are expecting it so something is likely to go wrong. Forgot to check the result of a string function.