ELinux lists two options to directly access GPIO pins from the command line interface and other libraries exist: 

So unless there are more really power hungry peripheral devices connected to the other 8 ports it should be possible to drive two Pi. The FAQ at raspberrypi.org states a "recommended PSU current capacity" of 1.8 A for the Pi2B. This includes 1.2A to downstream USB peripherals connected to the Pi. So if no power hungry devices are connected to the USB ports of the Pi the 900 mA should suffice to power each. Because this power consumption statistics have been brought up in another question. Their measurements suggest a current of 800-1100 mA (~4W) for the Pi2B under full load. Well that should make one at least think twice. As always this boils down to how reliably the hub limits the current on its ports (many don't do a good job in sticking to the spec). 

No there's not - a fact that a quick look on the rather short list of models of the Raspberry Pi would reveal. I'd also assume that the intended audience of the Pi and the targeted cost structure of the board are prohibitive to this approach. Interchangeable however are all the "non-essential" peripherals given the variety of modules provided by the RPi Foundation and third parties. 

I don't understand what is doing? It's typically used after a . Writing to stdout puts something in a buffer and flushing stdout takes the contents of that buffer and prints it to screen. I don't think you need it here. If you insist on doing this in python, here's an edited version of your script (but there's a simpler way below the script). 

It sounds like the power supply is failing to regulate and dropping out momentarily. The answer below seems to describe a similar scenario and the rpi wiki also mentions that the blinking PWR LED indicates an issue with the power supply. From this question: 

If the data-sheet for the model B+ is correct, the APX803 is hooked up to the red PWR LED as the wiki states. I can't account for the blinking (could it be caused by C6? Is it actually the raw input power drops you're seeing? Is it a feature of the APX803?) but it certainly shows that the APX803 can make or break the ground connection of D1 (red LED) via Q1 (depletion-mode n-channel MOSFET): 

At first let's consider the typical use case of the Pi (and nod to the fact that its processor is more or less comming from the mobile world). So both the design of the Pi and how most of the users are probably going to use it justify the constraints the current Pi imposes on its GPIO pins. If a higher current needs to be controlled there are always options to do so, e.g. line drivers or switching transistors, such as the darlington transistor array ULN2803. Those of course come at additional cost and required board footprint. If optocouplers are desired in the design, it's worth looking into low-current optocoupler as a way to overcome this issue. The use of low-current opto-isolators, operating at say 0.5 mA to 1 mA, would put it well within safe margins even when using all GPIO pins of the Pi. E.g. 

The main issue is the fact that the RaspberryPi's hardware design actually does not offer a power-off circuitry. So the answer is that without additional hardware it is not possible to power the RaspberryPi down using that keyboard button. While the keyboard event could certainly be used to the system that would do no good as power consumption is only barely reduced and furthermore there is no inherent way to turn it back on again (without additional hardware that is). 

Linux/Unix also has the scheduler which will run scripts and commands at specific times/intervals. It wakes up at the start of every minute and checks if there are jobs to do. This is perfect in your case. Instead of using python, you can type in your terminal and copy/paste the line below to the bottom of the file. I'm assuming that your username is - if not, change the line below accordingly. 

This might be caused by some missing environment variables; namely the variable. It would explain why a command that doesn't use the display, e.g. , works while doesn't. Assuming that your display is numbered 0 (default), try adding this at the top of your python script: 

Sorry about your Pi - hope you got a new one :) You've probably seen the discussion between goldilocks♦ and I in the comments and have a pretty good idea about what my "post mortem" will say. However, we both missed the fact that the Pi wasn't powered which changes the scenario a bit. How was the screen powered anyway if it's meant to get juice via the Pi pin header? Since we're dealing with 26 * 2 pins that might also be inter-connected via the screen's internal circuitry, there's an awful lot of complexity here. However, important factors always are: 

If you intend to process the image in Python right after capturing you can also skip saving it to file and use a file-like object, such as an io-stream or a numpy array instead. See the last part of my answer here. You will, however, need to drop the call of an external process and do the whole capturing in Python itself (not that that would be a bad thing). 

Setup: Raspberry Pi, type B, running with Arch Linux 3.18.5-3-ARCH #1 PREEMT, connected to a local ethernet switch by the standard ethernet port, no wifi set up or used. A static configuration according to is set up for and not running. After reboot is coming up just fine and connection to LAN is established. Other than that a flash drive and a FTDI RS-485 converter are attached to the USB ports. Problems: Every now and then USB disconnects (which could be contributed to power glitches - according to the forum at raspberrypi.org - but that is not certain). All USB devices come back after re-enumeration but does not. Journals tell us: 

How it could/should look (with back-EMF protection in the form of a flyback diode. The term "flyback" only refers to the application, not the diode itself. For your low current setup, use any regular diode capable of handling hundreds of volts. Eg. a 1N4001) Check the schematic above... Here you see a circuit with voltage spike/back-EMF protection added in the form of a diode. There's a DC power source (Vs) on the left, a coil (L1) at the top that could be your relay, a resistance (R1), a switch (SW1) and a diode (D) placed across the coil. See how the diode is "pointing towards" the positive terminal on the power supply? This means that no current can flow through it during normal DC operation. However, as soon as you turn off the relay the diode will ensure that the power stored in the coil will loop around in the coil itself until the resistance in the copper windings has "eaten up" all the energy; thus sparing your controlling circuit (SW1) from a nasty shock. The same solenoid setup as before but this time WITH a flyback diode across the load. See that nice, horisontal line? That's safety. $URL$ But wait, there's more! Instead of mucking about with individual transistors and diodes, I suggest you buy 10 trusty old ULN2803 ICs for ~£1 on ebay including free shipping. (I'm not affiliated with any vendors. I simply picked the cheapest product). The ULN2803 is a so-called Darlington transistor array. A single chip effectively gives you 8 individual NPN transistors in one small package (it actually contains 16 transistors but that's hidden away in the chip). They are perfect for your application since they have built-in flyback-diodes and each output can handle up to 500mA (~300mA when controlled from 3v3). They even have built-in input resistors of 2.7 K so you can and should connect them directly to the Pi's 3v3 GPIO. If you get these ICs, you can safely connect up to 8 relays/motors/whatever and control them via 8 GPIO pins. Providing that all the relays are powered from an external supply - not straight from the Pi - this is a safe, cheap and stable solution. It could be done like this. "Do you know of a way to trigger a "power cycle" for the pin without having to physically unplug the ground connection?" Yes! Let a semiconductor do the dirty work! Simply connect GND from your sensor to one of the outputs of your newest investment - the ULN2803 :) To reset your sensor, you simply write a low/0 to the GPIO pin, wait a few seconds and then write a high/1. 

Parsing through the list that contains the parameters passed to the script. contains the name (and path) of the script. is the first parameter, and so on. 

While I understand to premise that the transmission cannot be faked I think that the "build an artifical finger" to press the button is the most complicated way to go. I would like to propose to modify the remote control but in a way that the manual use of the device as a fallback is still possible. Despite it requiring to open the remote control I strongly believe that this significantly simpler to to. 

Using simple logic gates to kill SCLK for any unselected slave on the bus is exactly the way to go. Turning SCLK flat should suffice, no need to also flatten MOSI. Since Slave Select (SS) is active low an OR gate, e.g. 74HCT32 (a quad 2-input OR gate) should do the trick to or SS with SCLK. HCT should allow for 3V3 supply voltage and logic levels (please check the AC/ACT, HC/HCT families). 

It is attached to the BCM CPU/GPU, the Ethernet/USB controller, and the power regulator, as these are the components that generate the most heat. In this particular use case (vacuum) it is however necessary to consider vapour pressure of the tubing material depending on the required quality of the vacuum. (Assuming the coolant does not leak of course.) Another approach could be to entirely rely on thermal conduction, i.e. find a way to contact these three chips to the metal housing. This will likely require a set of height adjusted spacers or one spacer milled to fit all three components of a thermal conductor such as copper or aluminum. 

Since OP was getting an rather than an , something was clearly being imported correctly but simply didn't have the method . By calling from a script, not in IDLE, to get a list of all available module methods, we found out that he was actually importing a different, home-made script with the same name as the module (). It probably worked in IDLE because it runs from a different folder. So... Use when you get an and avoid using module names for your home-made scripts - it'll make things less confusing. 

Basically your current relay setup (No back-EMF protection) To mitigate the problem, it's common practice to add a flyback diode across the terminals of the inductive load (in parallel from GND to the positive terminal). You have to insert it so the little ring/stripe on one end of the diode is closer to the positive terminal than GND. Be careful with the orientation of the diode; put it in the wrong way and you've created a very good connection (low resistance path) from the positive to the negative terminal, also referred to as a short circuit. 

As suggested by @joan's comment the minimum load of such a power supply could be an issue. Back in the olden days when people used PC power supplies as simple and cheap yet powerful lab power sources they connected high-power resistors and even light bulbs to provide a base load. The issue at hand is the fact that not all switching-type power supplies regulate properly without a load - the open circuit voltage could differ greatly from the values to safely operate any connected devices. Tomshardware states that the issues of no-load operation range from shutting down of the supply to destruction. No-load operation includes operating at currents below a certain minimum load - and 1A for the RPi could be too low for some power supplies out there. It might also be necessary to apply a certain load to not just the +5V rail but also the +3V3 and +12V. So if going for this kind of an ATX power supply definitely make sure that "No minimum load" is explicitly specified for the selected supply or that the minimum load requirements are met. 

Given that this is the Raspberry Pi forum, there's a big chance you're accessing GPIOs in your Python script - correct me if I'm wrong and I'll shamefully hit the delete button :P Anyway, if I'm right try adding your script to root's crontab via and keep the absolute path like you're doing here: As @joan mentioned in the comments, you need to have an empty line / newline after a cron entry so make sure you hit Enter once after entering/pasting the line into the crontab. 

"I suspect that my issue could be that I am drawing too much current from the pi." Whether or not that's the case, I'm not a fan of the "modern" practice of sourcing relatively high currents from the Pi. In all my setups, I only source power from a PSU - if not to avoid overloading then simply to avoid introducing ripple and noise in the Pi's power rail that might disturb digital signalling. Instead of sourcing from the Pi, use a 12 volt supply or a laptop PSU and get some cheap switching regulators for producing the voltages you need. Rule of thumb in case you're going to do it anyway: never go above 80% capacity in any circuit. Ever. About the relays... Whenever you're powering coils and other inductive loads (motors, solenoids and relays being the most common examples), you're effectively creating a magnetic field that resists sudden current changes as long as the coil is powered (in practical terms, think of the powered coil as an energy storage area). When you suddenly cut the power, i.e. turn off your relay, the magnetic field collapses and this energy is converted to a huge voltage spike. This phenomenon is typically referred to as "back electromotive force" or "back-EMF" for short. Since the energy can't just disappear, it'll have to travel down the supply line where it hits your controlling circuit. This means that your NPN transistor might be taking a beating whenever you turn your relay off. Transistors and digital logic don't like that one bit! Oscilloscope output showing the voltage spike in a solenoid being turned off: $URL$ 

Since it features the composite video it is neither OMTP nor CTIA as those would include a microphone instead. Besides that the pin ordering of the audio and GND pins follow the CTIA system. From the official schematics of the Raspberrypi Foundation (3B_V1.2 and B+_V1.2) we find that both the Pi 3 (upper figure) and the B+ (lower figure) share the same configuration. 

Again, to no avail. Kodi just does not care. As per @goldilocks comment that udev rule makes little sense since it mixes udisks and udisks2 notations. Trying a rule for udisks however (setting aside the issue of changing block device names for the moment) did not change a thing either. 

So it is hardly conceivable that the power consumption of those three devices is too high for the respective supply. Checking and explanation of the wiring and the setting of the GPIO ports is required to solve the issue. 

I understand that link-only answers are really not the way of StackExchange, but this page is too good a fit to this question to not point to it. This tutorial completely covers all aspects of relevance to capture the image and use OpenCV on a Pi process the image to read the value of the electricity meter.