Improved application of Single Responsibility Principle, encapsulation, and domain modeling. Start With Good Data Structures 

is fuzzy Looking at the original code as just the method parameters together w/ the overall control logic, it is not at all clear what I'm seeing. Also, the seeming nested-repeated logic is making me wonder about flawed logic or poorly structured logic. I wonder if you get the outlier conditions out of the way first thing then all the logic is clearer. 

Why is no one suggesting to use the Queue Class? It is designed as a first in first out (FIFO) queue. I don't know if there would be a need for ae temporary lists to move folks around, but waiting in line is still a FIFO thing... Hey, no cuts! 

Assumption: We take the next person - or group - in line and put them on the coaster if there is room. If no room just wait for next time. No group can be larger than the coaster capacity. For now, just ignore them. Use the class Write a single method (sub-methods as needed!) to fill the waiting line. Prompt the user or hard code it. If a 10-person group shows up. WaitingLine.Enqueue(10). If 1 person shows up. WaitingLine.Enqueue(1). WaitingLine.Dequeue() to get next in line. Add that value to a DailyRiderCount. When the day is done, multiply the DailyRiderCount by the cost of a ticket. 2/3 of the original code now goes away. Now it is running faster too. 

Changing the where to a let allows you to skip passing the secret. Passing guesses in and messages out purifies the control flow part of the program. zip [1..] makes clear: The number of tries during each step does not depend on the control flow. interact, lines and foldr replace the recursion. (Recursion is too powerful for brains to handle in general, so we should avoid it when we have a simpler tool.) Your mileage may vary on any of these suggestions. 

Here's how to use to brighten the day a little. You may have hoped for a way to do only once after combining the s with ... but I also don't know how to do that. If went to arbitrary MonadError instances, could have been more concise. 

Library functions, particularly Maybe's Applicative/Alternative instances, can make your code more consise: 

Let's use from that comment and inline the once-used (imo if you're only giving a name to explain what something does, use comments) 

You can make nonpartial by using . Then it turns out that already implements that and calls it . Using it, you can eliminate another case from pull. 

Your example would then look like . By the way, whereever you're using the Eq instance of Tank, consider pattern matching instead. 

Have some rewrite rules applied, combinators used and helpers inlined while I think about your algorithmic question. And make a . 

Your strings are no longer than 80 characters. Do you mean your lines of code? You don't need , you can pass the do block directly to . The conceptual no-op should be replaced with , but in this case captures it more precisely. The next-player arithmetic is wrong - if a player is removed, you skip over the original p+1 which is now p to the new p+1 which was originally p+2. Make sure to set echoing to False, so people can't see what the others put in. Since is only used in one place, I'd inline it. 

Below is not the Abstract Factory Pattern per se. We are not creating factories of factories. The point of a factory is to separate "complex construction (code)" from the using class. The more complex the constructions "the more factory we need". Simple? then a static (or not) method w/in the client class is ok. Longish & somewhat complex? a separate class. Use the Factory in many places? a separate class might be best. Many variations of each class-type? Perhaps a full-blown abstract factory design. etc., etc, and etc. IMHO, making the class an instance, static, or singleton is your call. 

IS A so a client could do all kinds of sorting dynamically using LINQ. Call the above, then, "default sorting." Future OO Refactoring I think and should merge into one. 

Reference by Table Name and Remove more If-ing I'm guessing that your code is handling at least 2 different tables. If this is true then based on the name call "thisTable" code or "thatTable" code. Then you can eliminate all that checking for column names because you know they are there. And it eliminates another layer of 

Catching specific exceptions is good. But this code is not catching any of the exceptions that opening/reading a stream may cause. Catching a specific exception is good because there is context to capture specific information relevant to that exception type; which can really help troubleshooting. 

Communicating through design How would I interpret - make an initial guess about - design, intent, and use from what I see here? 

This piece of code is, incidentally, the epitome of order confusion and what wouldn't happen if there was a way to bundle API updates with automatic patchers to old code. 

In general, I'd go for the second sort of approach. It scales better. I'd eliminate four names and the hack like so, at the cost of and : 

I would separate the looping queue logic from the rest. A general implementation of necessitates a state monad here. 

I would inline, eta-reduce and use more library functions to make the code short enough that adding another command is trivial. Perhaps give the fields names so adding another can't mess up numbering, and you need less comments because the code describes itself. Edit: I'll use non, making the map not add a value for new users until they want to change it. This way we don't need to initialize with on logging in, and we can get rid of the Just returned by the "get" action without needing to promise we already initialized. (Which we don't necessarily have, as the initial ""!) 

Edit: Second: Shuffle arguments around so eta reduction is feasible. Also inline most stuff that's only used once. 

is just . Aeson provides ways to derive , not sure whether they're applicable. If you're desperate, you can throw TemplateHaskell at the rest and generate the code yourself. 

If you used , would be Using , is , except that the list is the right way round. Replacing with allows you to remove the last line, and thus the recursion, in loop's definition. Prepending to allows you to remove the . skips getting system time. 's allows you to require ability to generate random numbers in exactly the upwards call hierarchy of if you use mtl-style type signatures. You won't even need to specify that it is actually provided by (except in ), giving type level gurantees that you aren't using IO except for random numbers. Then you can wholly reduce to . 

Put space around control structures & label some closing braces, IMO if > 2 consecutive closing braces then start labeling - about every 3rd one. 

Lots of internal coupling: also fusses with requests and administrators. also adds members. removes member(s). DB code is intertwined. As a matter of code structure and organization I don't have confidence in correct member/admin/request CRUDing. A cursory code skim looks like all administrators are members and vice versa, and there are separate lists for these. Perhaps the member class should have a IsAdmin property. Synchronizing (partially) redundant lists is problematic. Even if the DB has separate entities the domain model should expose the "a member may also be an admin" concept coherently. 

limit the body of to the code that you really need to cover. This also means you get specific about the exceptions caught there. catch exceptions as close as practical to the likely source; and database calls is a likely source. Then you can capture lots of good information about your , , etc. objects, parameters passed, etc. and put that stuff in the property. 1 & 2 go hand-in-hand still have an exception catch higher up as suggested by svik. 

Once refactored, put around the database code. Catch specific exceptions thrown by your database engine. P.S.DTO mis-application leads to bad code: property-only classes manipulated by massive "manager" classes containing complex/nested control structures in every method; with a sense of redundant repetition everywhere. 

Cast-Aways Make your constants double at compile time. , , etc. Well, is already a , but what the heck. is used as a value in the matrix. Declare it as and pass it as a . Guessing At Performance Not this: 

There doesn't seem to be a reason to filter out the s. List comprehensions neatly let us skip the empty tail, and get rid of . 

<- You want . implements some of your stuff already. I wouldn't introduce the types and in the first place. They just introduce wrapping without extra type-level structural info. 

Successive elements of the list returned by genPositions and xs are zipped together; captures this pattern. i is now not needed in its non-rooted form and I recommend changing the interface to take N as an argument instead. Non-square arguments can currently crash !! anyway. genPositions is only used once, therefore I inline it. 

Edit: Since we've already silently been passing into the last case, we might as well get rid of , which can also be handled silently, for: 

When you need to reverse afterwards, that's a hint you should have folded the other way. But this can even be written in terms of : 

Ignoring what kind of error messages you get, you don't need to handle error cases yourself: (!!) already does that. 

And just for fun, this should only traverse the counts result once. (Requires that indices is sorted, though.) 

The "intermediate array" takes no extra space due to lazy evaluation. is . Yes, swapping the parameters makes sense. Inline and once more. I wouldn't worry so much about constant factors - have you compiled it with -O2 and tested (eg with criterion)? import Data.List (minimumOn) 

This goes to the idea of catching specific exceptions. Here, each can be specific to the exceptions thrown by stream and then PDF.Document. And the "gaps" between the multiple try/catch blocks gives the code flexibility for recovering from the 1st try and then execute the next block. The general rule, make narrowly scoped try blocks. 

That is generally true but inside loops... Well, for compiled languages there is valid reasoning not doing this but a brief browse is telling me it's not an issue in JS. And when creating closures in that loop/block-scope (not applicable here) you need to do this. end Edit 

The await looks like a leaky abstraction. Could your generator naturally behave synchronously? A quote from Exploring ES6 

I see a class. Your diagram inspired the thought. The diagram directly suggests the class would have an array (of hands) each element of which holds the final score for both players. This data structure, then, maps clearly to your UI concept. I see it as a separate class because it keeps score for both players, so it is inappropriate to be inside the (individual) Player class. A Player might have his score (hand) for the current game, but not past games, and certainly not the past games of a different player. *Your Other classes * 

I'd throw an exception instead of returning null. If a given is not implemented that's a show stopper for sure. Now, if you have a default vehicle type that's a different story. - HINT, HINT.