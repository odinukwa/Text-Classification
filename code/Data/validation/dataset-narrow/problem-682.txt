Overall not bad code. I don't agree with your comments on how would be inappropriate there, but it's far from the end of the world. In general, I'd try and be more careful to validate user input, but it may be that you do not need to worry about that. 

Yes, that function terminate (unless the semantics of are stranger than expected and is an infinite generator). One thing to be concerned about might be that, should your query take a very long time, you would not delete a single blob before a is thrown, and so schedule another task without doing any work. This is a bad thing, as you may end up with many jobs that simply get half way through a query, give up and then schedule themselves to run again. The worst part is that your only indication would be that your log would be full of level messages (i.e. messages that will be ignored), giving you no idea that this travesty was unfolding in your task queue. I would recommend you add some kind of limit to make sure you are decreasing the number of blobs towards zero each time. You could think of it as an inductive proof almost; see Burstall's 69 paper on structural induction if you feel like formulating a mathematical proof. However, that is probably not necessary in this case. My suggested rewrite would be something like: 

I'll give some general comments now Application You currently hard code your urls, which could lead to a very brittle structure, and make extensibility a pain. Have you considered using class decorators to register route handlers? They'd look something like this: 

If you're trying to create an optional parameter, you should check if it is undefined using , rather than just , otherwise you'll have trouble setting falsy values such as , , and . One of the things that allows this code to be much shorter is the observation that in javascript, is the same as - that is to say, array lookup using an integer is no different from array lookup using a string that contains a number. This avoids the need to parse the numbers like you do. The other major saver is the use of split rather than indexing, which makes it easy to loop over the parts of the key. 

As a completely untested micro-optimisation, I would suspect is going to be marginally quicker than . It does, however, round up on 0.5 instead of rounding down, which may not be what you want. 

Leaving aside the problem of deeply nested code for now, I think readability is greatly improved by the use of LINQ syntax: 

If you don't include the parenthesis, it's taken to mean a reference to the function rather than a function invocation. It's a bad idea to try and manually keep track of keyboard modifiers. For instance, if your website looses focus while the key is held down, it will think it's still down when you return focus, even if it isn't. The keyboard event has a property which will be if the control key is being held down. It's also probably a good idea to put the key code into a variable which describes which key it is, as having to remember what maps to can be tricky. 

I'm not 100% sure there is a particularly elegant way to write this. If the code did not have a different body for each statement, one could rewrite it like this 

This is known as a guard statement, and they are very nice. Avoid using without specifying the type of the exception you wish to catch. In this case, it's particularly bad as you are not even logging the error; someone could come along, shoot a bullet through the hard drive of the machine you were running this on, and your service wouldn't note that anything of interest had happened. I'd suggest that when a request fails, you return a non-200 status code; at the moment, your bullet ridden hard drive will not cause a single non-200 status code. Download If the file exists in Mongo, but not in the FS, currently you say . However, due to the statement which doesn't specify exception types, your code also says that no matter what else goes wrong (recall the hard drive with a gun wound). I'd find out what class of errors come under the file not found category, and then treat them differently to others. Currently, if the user looks up a file that doesn't exist, you return , which I think bottle will complain about. It'd probably be better to add a guard clause along the lines of 

MainHandler The name tells me nothing. Due to your routes being defined in a different place, maybe naming it something like would be better (though I still don't like that). An oft advised idiom on this site is the use of guard clauses. I'd recommend using that here; instead of 

The use of dictionaries makes it easy to add new properties and actions. The extension methods then make it a lot easier to use those dictionaries in a way that reads well. Another solution you may find easier is to make FilterAction generic: 

My code is based off glebm's, but I've changed it so that array lookups must always use the syntax. I made a few other tweaks such as creating an object chain if assigning to a nested key that doesn't yet exist. 

For me, this makes the SelectMany a lot easier to follow. There are some other tweaks to the queries too: 

I'm not too happy about the way the loop works though. It seems a little awkward to sometimes increment i, and other times not. 

FillTreeNodes looks pretty much OK to me, I can't see any major ways to improve it. I would suggest, though, that the StringBuilder can be replaced with a simple . I'n not convinced preprocessing the list is going to give you much. That said, we can remove the need to sort the list by removing any leaves we come across when trying to add the path to the list. Notice that by breaking the logic out into a separate function, we avoid the need for "found" flags. 

I don't like how they will convert a null into an empty string. Seems like a good way to hide errors until they pop up later. I would do something like: 

Q0Handler Numbers in class names make me feel slightly sick, and I have no idea what means; question 0? Because this view seems to handle all questions, not just question 0. We've already discussed the bug. There are a couple of other bugs; if I delete my cookie, I'll end up causing a bug when you try to do ; (same problem exists for ). When you do to increment the score, I think you could be vulnerable to a race condition, but that's not too big a problem (I think Mongo supports an atomic increment, use that instead). Python convention when passing named parameters is to use spacing not , but that's just stylistic. 

With that said, I would praise you for your style. For every problem your code may have semantically, it is formatted very well (hooray for PEP8) 

Note that this does not explicitly address the lack of an inductive variable, though it does limit any damage done. Another thing to note is that you have a race condition on the . Should the method be called concurrently, say by process A and B, then the call to could return the same set of bobs to each. They would then attempt to delete the elements twice, which would raise an error on the call, leading to fewer blob deletions than expected. This problem gets a lot worse when we consider more processes and things like unspecified ordering. The correct way to handle this is to treat any exceptions thrown by the in a more nuanced way than you are currently, and accommodate multiple attempted deletes without prejudice. Your current code will work fine at the moment, the problems will manifest themselves when things get more complicated. While I am sure Google's infrastructure can handle these upsets, your bottom line may be less flexible.