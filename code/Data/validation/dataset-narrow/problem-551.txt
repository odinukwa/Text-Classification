The name of your class is a generic name, yet it is used for a specific kind of request being that the and parameters are hard coded. I think what you want is a class that encapsulates specific AJAX calls. For this, the Repository Pattern would work well: 

This breaks the relationship between and because we assume is the document object that contains . Instead, we want to create delegate properties for and so we can maintain that relationship: 

This allows you to centralize all your AJAX calls, yet keep things strongly typed enough to make your code easy to follow. Edit: This pseudo code uses the Promise/A+ API, which browsers have native support for now in ECMA Script 6. Related pollyfill: $URL$ 

It's fairly obvious what .call() is doing in context. I recently came across some articles that went into depth on abstracting the .call() function. The premise is along these lines (this code is verging on pseudo code as I have stripped it down for ease of reading) : 

The logic is really confusing me, I understand how call() and apply() work in the simple example above but I have no idea how or why the prototypes of the object are extended when I call . Could anyone help me shed some light on this? 

Make your code scalable By this I mean using techniques that allow you to do some relatively advanced things without the need for re-writes / re-factors in the future. One of these is to bind events to a lower level element with rather than or . If in the future you modify the menu for some reason with jQuery/JS and DOM elements are removed / re-added, event bindings will be lost. Using avoids this problem. Refactoring your code I've deliberately not included any CSS changes in this code as you can and should include these in your CSS rather than dynamically with jQuery / JS. I have however added and removed a class, this should contain all the style changes required for the mouseenter and mouseleave events. 

This seems pretty clean to me. It's very testable, which is a definite must-have. It also decouples the reformatting of user input from the view-model. Looser coupling between layers is a positive thing. The downside is that you'd need to create a service for each view model. I'm going back and forth in my head whether this approach is best, or if defining some custom class and property attributes might be more worth while, and then use the service to process any object in a generic manor by looking at the attributes associated with a view-model property. Some pseudo code: RegisterViewModel.cs 

Really, all of my objections are related to this tenet of software engineering, and especially object oriented programming: Do one thing, and do it well. Putting validations into your domain objects means they are serving a dual purpose: Hold data from a storage medium AND ensuring it is valid. Do one thing and do it well. The domain object should hold data. The validation layer should ensure things are valid. Putting validations into your storage manager means it is serving a dual purpose in the same manor. You should be able to swap out one layer for another with minimal refactoring. If you have to copy and paste of rewrite lots of code, then your application needs additional layers with looser coupling. 

This is really very open ended and is open to many forms of interpretation. The code format below is strictly the way I like to make my code legible. 

Going into the nuances of having a single Cat that can bark out of a set of possibly hundreds of Cat instances is beyond what you're trying to learn but I'm hoping you get the gist of where I'm going with this, behaviour as interfaces generally work better than types and give you a lot more flexibility when actually determining what your classes do. I'm making general statements a lot here, but you will see that your interfaces become very specific to actions. As such they are smaller and make more sense. I have found it much easier to have a class that implements 5 smaller interfaces than 1 or 2 monolithic interfaces due to the increased flexibility available and it keeps things DRY. 

When you change anything with categories, you need to refresh the category list. Same thing with bookmarks. For this you can use events. Controllers would publish an event, say "category:updated". The would subscribe to "category:updated" and refresh the category list. Same idea with . Now the AJAX functionality is currently all global. I usually go for the Repository Pattern to encapsulate AJAX calls. For that you would have two more classes: 

There is absolutely no difference between and . The and properties created using are superfluous, and only serve to add weight to your JavaScript code. There is no logic behind the getting and setting of those values. On the contrary, consider a case where you do want some special logic around setting a value. In the code below, the property is a reference to a DOM node. When setting the DOM node we also want to set properties for the and to which the DOM node belongs: 

within a class scope, the Extension object seems to extend the calling objects prototypes allowing me to bind a callback within the class scope. And then attach a handler after I have instantiated the class. 

There is nothing wrong with this approach at all. Rather than say you should or shouldn't do it any other way I'm going to give you an alternative approach that allows you to write less code in your file. I've noticed that your deals with a lot of different types of requests. This can get very hard to manage when your application grows. It's a good idea to separate out your controllers into manageable classes that deal with one area or feature of your application. The example below would ideally be in a class for example. Taking this chunk: 

The form would need to instantiate the user permissions service with the proper user object before the method gets called. 

If the only purpose is to provide a simple wrapper around the body of the HTTP response, this isn't so bad. Things break down when you need to access things like the request and response headers. Error handling is another thing entirely. I would recommend catching all errors, and rethrowing the exceptions wrapped in your own exception classes to make error handling for client code easier: 

This way all AJAX is centralized and abstracted away. None of the rest of the application even needs to know AJAX is at work. You could rewrite your repository layer to use asynchronous calls to the browser's IndexedDB for an offline application and you wouldn't need to refactor any of your other code. Controllers Over the years I keep coming back to this basic pattern when creating controllers in JavaScript. Controllers: 

Example of the chaser and chasable interfaces in action: First lets make our interfaces a little more rounded 

Don't use jQuery to... Modify CSS unless it is absolutely required (ie CSS alone can't achieve what you want). In this case CSS can handle you're requirements easily. If you find you need to change a lot of CSS and would like this CSS to change due to a jQuery or javascript event. use and . Applying the styles in CSS rather than in jQuery. This is far more efficient in terms of code and your eyes. :) Cache your jQuery objects 

I would say that there isn't a correct or incorrect way of achieving this. Everyones requirements differ. You probably want to expand this out, there's a lot going on in the one static method you have in that class. Whilst I don't have anything against mediator patterns, I would probably combine a number of patterns to build a powerful caching class, as well as utilising magic methods (I know some people are averse to this). I need to note the below is a lot more complicated and would benefit from some refactoring to be stored against the actual method rather than a key.