I already added the link to a good implementation of the hash code method above, so I won't go into detail about the algorithm. But what you are doing in the above two lines before the addition is just calculating what could simply be a constant. The compiler will probably even precompute the part. Multiplying the hash code with a prime number (like 23 or 31) should happen before every addition of another value. 

Sharon Ben Asher has a good answer using streams. I'd like to add some suggestions for the original code, since beginners are often not familiar with streams in Java. You have some redundancy in your code, meaning code that is executed multiple times, which can hurt readability, decrease performance and introduce bugs. To tackle the issue, you can save results from method calls in variables and just access the variables multiple times. This also allows you to give the result a new name, and although it might make the code slightly longer in terms of lines of code, it can also make it a lot cleaner, and the individual lines shorter. The most important example is calling and multiple times. Instead, do that at the beginning of the loop, and save the results in variables. 

Scoping : In your controllers are all your services default scoped. In mine humble oppinion make them private, if you wish to have the default scope make getters and setters default scope. Why: You easily can forget the private before a global variable but getters/setters are mostly autogenerated public so normally when these are not public it's ment to be. Final's : What is looking odd is that in you don't have the marked as final as you do that in your other controllers. Error handling : 

This is completely safe in your pojo, nobody could even acces the object. And outside the package no one will ever see this method. The advantage is when you refactor or the method name, your test is automatically updated. 

The intendation is correct but always use braces for if's. A lot of mistakes with if's comes from this. Example : 

Method names do not start with a capital. starting with a capital is for classes. Fourth : You rely on users of your class that they close your connection. You will have memory leaks cause they will forget to close your connection. There are 2 possibilities what you can do. First : 

Next, there's this regex, and two others like it. I have added spaces so you can see the repetition: 

The first capture group was equal to the entire matched group, so you just use (which you appear to be doing already, except for the one line). Now the same thing applies to this regex too, but you can also remove one set of s: 

This cuts it down to 391 steps, but it is still getting hung up in the portion. Looking further into your code, it seems that you just want to get the two values after it: . Your other regex already does that, so you can just use it here, instead. The other thing I would suggest is using , which ensures that there's a word boundary (so the following will not match something starting with "penthouse"): 

You should probably stick to one language. (Although I suspect you may have translated all the comments, but just forgot this one.) The other thing I suggest is that you remove some of the commented out code, and also remove some of the excessive blank lines (like the ones towards the end of the first class). 

Here we have the same, but even worse: The functions change global state, which can make it much harder to find bugs. Try to avoid that whenever possible. Furthermore, and already tell you that the speed is increased/decreased, and they tell you how much they are changed, which is valuable information. If your only reason for defining these functions is that you can easily change how much the speed is increased/decreased, define variables instead and do . Writing it in uppercase later reminds you not to change it. 

Do you really need a ? It seems like you always use as value and actually just want the keys. Use in that case. Call it or similar, instead of table. Use a name that tells you what you use it for. 

That comment adds no information to the method name. The method name is already very explicit. The comment rather even adds wrong information, because you don't actually split the string. You could consider ing the return values, so that you can iterate over them without needing the complete list in memory. 

We start with that tab disabled. As the subscriber is created you can set the disabled to false and set the source of the include, so the tab will unlock. Another option, what I use in mine application is using the "visible" attribute. 

Isn't it better to call them and ? It helps you when you are programming. Take in mind that you get this code and must find a little bug. You are getting a headache just by always thinking what and are Check for your own faults : 

Code should be self explaining, so if you need to put comment behind a variable name to explain it, there is something wrong. Mine suggestion is : 

It's clear that this String need's to hold todays day formatted. The thing what you could improve is making the static. Like this you don't have an instantiation each time you create an instantiation of the 

You are inside a char class, so most of the normal meta characters loose their meaning. You could use: 

I can give you some feedback on your regexes. There are a number of times in Java regex, where you cannot avoid using the "evil escaped escape", but you can refactor most of them out in your case. First of all, you don't need any backslashes in these three: 

I have no clue why you escaped the . Of course it doesn't need escaping, since you didn't escape the other one! 

It can be further shrunk if you use character ranges, but this is not very legible when it comes to special characters: 

I can give you some feedback on your regexes. First of all, you don't need the parenthesis in some of these. These two: 

As it is written, the regex takes 427 steps to find a match in your example string (according to regex101.com). There's no compelling reason to be using look aheads for "house-" here, either. It will just be eaten by by the , so you might as well just extract it: 

All over : Nice readable code, as an outstander, who doesn't know the things the other classes need to do I still understand what this class has to do. 

You can do it a little more generic but I'm afraid you still have to test each. I don't know if your case is always changing to green or not. If not I suggest the following enum : 

You are declaring this synchronised. So if 2 threads are calling this method, the second one has to wait until the first one is finished. Because you don't have an input variable, the output will always be the same, setting false. In this case there are no race conditions what could affect the outcome of this method, so I wouldn't make it synchronised. private static final : You are making a great use of the fields. What I'm not liking is the next step : 

This name is not good, because it does not tell you what kind of answer is being checked, and what a positive result means. A better name would be , or just if the parameter names are explicit enough (which I would say here they are). Considering that the method just does a simple logical comparison with values that are all provided as parameters, you might just remove the method and replace its calls with the comparison. As already hinted by kyrill in a comment, the method should not return strings (which are even very inconsistent here), but or boolean values. Then you can handle printing out the strings where you call the method depending on its result. And the does not do anything, actually it never does anything, but everything that comes after a will not be reached. 

Just returning from the method if the is already running hides potential bugs. Since the bot is not started by user input, but by creating and starting it, you might throw an exception, because calling twice is a mistake of the code that is worth finding. In normal circumstances, it shouldn't be called twice anyway, and if you want to be sure you can expose the bot's running state with a method so the caller can check first whether to call or not. The name tells you that you just made that method to make your method shorter, but not the intent of the method. To see what it does, you need to read the code, and to do that you have to jump through your sorce code. A better name would be for example , if that is what it is doing. 

I was working on refactoring your code. When I was finished I saw that @tim already posted an answer. He address the most what I also wanted to point out, but in mine opinion he forget 1 thing. 

Or something like that. Let the method return the actionlistener, but in the creation of your actionlistener use also at least 2-3 methods. Edit : Your problem : Use instead of with your eventlistener. looks for multiple button clicks, so it will merge some events. 

Default value of a is . Default value of a is . Take care, default of and is . Defensive programming 

for the same result. Naming : While you have not many var's to call => I like that you already point to the bottle. Still I'm thinking could be a better var name. While loop : Well it doesn't make a big difference but for your own sake, use a for-loop. You don't forget to substract one then. 

Variables should never be public (and rarely static), but lets assume these are just normal (private) variables (static or not). They should be written in . names are used for constants, which are declared using . That prevents them from being changed, so when seeing a name like you should be able to trust in it not being changed. 

The input is not the user. You could call it , but even that seems redundant. Since the intent of that line is to ask the user whether to play again or not, you could just call the variable , then check whether Pythonic code Code is considered pythonic, if it uses the language's features appropriately and thus is more readible to people familiar with Python. For example 

The same applies here, however that is even confusing, as it is not obvious to me what it is supposed to tell about the code, and the comment in a comment is also weird. Maybe it was on a different line before. In general I recommend writing comments in plain english on their own line before the code they are refering to.