One of the advantages of lambdas is that you can now pass functions without having to define an interface yourself, and that you can pass implementations with little writing overhead. For example, your code could look like this: 

I don't have a solution better than yours (you can google for to find some examples), but I have some small comments on your code: While loops I would remove all the loops. They make your code harder to read and don't really speed it up (in my tests, they actually slowed it down). Minor performance improvements 

But you still have a separate case for the last insert which is a bit ugly. You should be able to get rid of it with something like this: 

Your constructor also defined etc without using it. If you want to stay with your approach, the assignments should look like this: Input Checking Right now, you just accept anything the user passes. For example: 

No, it's not vulnerable to SQL Injection, as you use prepared statements, and you use them correctly. If you don't have any CSRF protection it is however vulnerable to XSS because of the echo (and of course CSRF), but I'm assuming that that's more of a debug statements. Misc 

It's not the prettiest code in the world (and depending on what you use it for, this might cause performance problems because of the many functions calls, eg in an AI), but it should work. You could also create two general methods, one that checks horizontal/vertical and one that checks diagonally. Those will have less differences, and thus would need less parameters than the generalized method I posted above. Also, as your code is a bit complex, you should definitely add unit tests (either test the public overall check method, or check all the private check methods via reflection). This would have caught the bug vnp found, and it makes changing your code a lot easier (you just run the tests afterwards and can be sure that you didn't break anything). 

Again, I didn't check conformance to the specs. I also already mentioned to you how most of the explicit instantiations aren't needed. I'd also write for computing the various sizes that you need rather than subtracting from the total size. I'd do that for clarity and I don't think it's a correctness issue however. 

Do you have a specific reason (e.g. protocol requirements?) that this be signed? Bit-level stuff usually involves unsigned types. The protocol specs also explicity mention the size of the message type field: a single byte. So I recommend here. 

Deduction can't work here. C++03-style code uses at the return type, or when there is no return type (e.g. constructors) as a default argument. Maybe you tried to 'collapse' the default argument with the actual, interesting parameter, but you can't do that. C++0x-style code can put as a defaulted template parameters but that's moot since you really want (credit to CatPlusPlus): 

If only the specializations are meant to be used (I couldn't tell from looking at your code), I usually 'forbid' the base template to catch mistakes early. Errors about how has no member are confusing and not necessarily near the code that instantiated the template. The simplest way to do it is to leave the template undefined but lately I've been using a trick: , where is always but won't trigger the assert until instantiation (whereas always triggers and won't let you compile, ever.) 

I noticed the first two are intervals, was that a mistake? If it was, you can start the loop at 0 (and a smaller timeout). If it wasn't you can can create a similar function for intervals. Also, consider using queued animations. We want all our animations to occur 300 mili-seconds (after each other) right? 

Speaking of which, every time you have an anonymous function that handles considerable amount of code, you should consider extracting it to a named method. 

By using immutable objects we also don't create a new copy for each element. I can pretty up the code using ES2015 if you'd like. Here is a modern version of the above code for Status minus allowing usage with (per your request): 

What you are doing seems pretty much the standard way to do this sort of thing with Javascript and jQuery . A few pointers: Often, you wrap functions with other anonymous functions, for example: 

As requested by tomdemuyt. I'm posting my comments as an answeR: You usually only use in very specific cases. (let's say you wanted validation on age?) - in your case - I would not use it. Op then asked: 

One simple solution would be to extract your common functionality into a method. We'll also cache the selector for speed (don't do this if the elements change). 

But: Do you really need ? I would guess not. And with a decent IDE, is it really slower to write HTML yourself? I wouldn't think so, so is out as well. And : You can just use a minifier, which will probably be better at what it does. And allows you the option of turning it off for debug purposes. Point is the only one I would consider to be a real advantage (but then you would have to make it a priority to produce valid HTML). Disadvantages: 

JunctionRule is way too complex. A first step to fixing this would be to extract some logic to functions (for example parsing of neither-nor, parsing of the other case). Dublicate Code Try to avoid duplicate code. For example: 

First of all, I generally like your code. It is generally readable, and your use of functions is great. Just a list of small stuff that I noticed: 

Variable Names There is no good reason to abbreviate variable and method names, but it does make your code a lot harder to read. 

You would need to profile it (it will probably depend on the virtual machine used). But regarding readability, boolean makes a lot more sense. A number is either prime, or it is not (there is no "maybe prime" here). has a real meaning here (is prime? true), while does not; it is only understandable via comments or convention. Using boolean also makes your s nicer. is quite nice to read and easy to understand, while is not. Misc 

Lately I've been making my traits more convenient to use by adding forwarding specializations: , and another one for . They help with perfect forwarding because if you have e.g. then might be for some . Since you're not doing that in your code I don't think you need it -- just a head's up. 

I don't see the need to copy the final message into a buffer. Why not use two calls to ? You could replace the members (which you already dislike) with a member like the fixed-length messages. 

Final remarks on the general design: I think you're somewhat abusing specializations here: there's is no need (IMO) for a catch-all template since the three kinds of messages are not similar in use. This really shows I think with the constructors that aren't compatible: you can't write a generic . Personally I'd have used overloaded function templates to return those three types. Also I personally typically use for binary stuff rather than but I don't think that really matters (plus you may have a use for some -specific stuff that is not in the code you presented). 

Again, following protocol specs, I'd make a . The unofficial spec use as the length, I'm not sure what you're computing here. Minor note: I always write to future-proof (unlikely to matter here but still). 

View: Possible Bug / Security Issue The method of the class sets arbitrary fields. The problem here is that you already have a field - - which is later passed to . This means if you ever assign something with the name , you will overwrite this field. If this is done accidentally, you will get buggy code, if is ever user-supplied, you will have a security issue. For example: 

is obviously dangerous, as an attacker could update arbitrary profiles. It should be remove to avoid that someone uncomments it later for some reason. Input Validation While input validation shouldn't be a primary solution to any vulnerabilities, it is very good to have it as defense in depth. You validate the uid (although as @Ron mentioned, you later use the unclean version), but nothing else. It would be good to also validate other values, such as the email id (probably an integer?), etc. 

Yes, the original code is awful. It is 200 lines of spaghetti code; I have no idea what it does, it is impossible to reuse and extremely difficult to test, debug, or change. 

These problems also occur in other parts of your code. None of the methods have comments, and , , , , , etc are all bad names. Even some of the longer names are not all that expressive. and what of what? what? 

This is Bluebird, but it's very similar to Q in syntax. Note the automatic promisification and utility methods: 

If I may ask, why are your display items in a directive in the first place and not in the DOM? You could use an in the DOM to repeat the items instead and drop the directive altogether. Directives are useful for code reuse, are you reusing this spefici component in a lot of other places through out your code? Behaviors affecting your models and not just your presentation logic should probably not be in the directive to begin with (like in your example), a directive should encompass presentational behavior and not business logic. 

There are a lot of good use cases - they're just not very common in the web because of IE8 yet. In your case (age) I would not use . 

Here is what I'd do. I'd split it into two actions - adding a single property and assigning them all. Adding a single property is just adding a function if it's something like , and it's adding a property to a sub-object if it's something like . So let's use recursion and break it up into those two use cases: 

Yes, it is. Generally your event listeners when writing this sort of code 'control' the flow of events. That area (like in your code) is in charge of negotiating between your data and user/presentation, letting the logic layer know when the change happened. It is generally cleaner to register all such handlers in a specific place. 

Foreach You have two statements which do not do anything. but their side-effect is that your are always only working on the last entry retrieved by the query. Instead of returning all matching entries, you should only retrieve this one entry and remove your loops (you can use (if needed in combination with and )). Misc 

The first is obviously the name, but after that, I would need to look at the documentation or code of the food constructor. There are multiple solutions for this. You could use the builder pattern, you could combine parameters into objects (min and max cap for example might be a range, and beginList and describeAmount also seem to belong together), or you could just reduce the number of parameters by removing unnecessary ones (is there really a reason to pass rand in? Should the name of a burger ever not be burger?). Is there a reason that the Food class doesn't build the behavior? It seems to be an action that is common to all foods. Your play method is a bit long for my taste, and does a bit too much. I would move all the printing into their own methods (like displayIntro, displayWin, displayInput). The logic could likely also be improved. Is there a need to check foods for removal for invalid input? It doesn't seem like it, so your code may look like this: