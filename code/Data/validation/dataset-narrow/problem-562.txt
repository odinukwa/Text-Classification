Using a function that "does things right" This pattern seems to hold. You always use the elements in the first list twice, and the once in the second list only, well, once. This sound like it should be possible to the first elements with themselves somehow. If we were able to pattern match on the last element, this would be 

I've also added some whitespace. Keep in mind: you write code both for the machine and the human who's going to read that code later. That human might be you or your supervisor. Make sure that it's easy to read. 

and we really want to keep the number of low. Luckily, unless you want to allow for some , there is no need to use a layer of indirection. Just use 

And we're done. By the way, you can use to get rid of . But that, again, is left as an exercise. Further remarks The type annotations in your bindings are not necessary. I would get rid of them, since they may get out of sync with your top-level function (but you will at least get a type-error). can be written as , if you're up for a challenge. Your overall complexity stemmed from . It's a great function, but only if it's used for the right job. Not everything is a nail, just because you have a hammer at hand. Instead of trying to get everything else in place to use a specific function, ask yourself what you want to do, and whether there's an easy way. Unfortunately, there is no -like function in the standard library (unless you count stateful accumulators such as ). 

We can now check the functor law easily for many combinations. The more rigorous approach The more rigorous approach with functor laws is to proof them by hand. So let us assume that functor laws hold for the functor in . Then we have to show that 

That's not very user friendly. More on that in the next section. The ugly While I don't concur with @Gurkenglas that recursion is too powerful for brains, there are some weird things going on with : 

Profile You can only improve what you can measure. So first of all let us run to check where we spent most of our time: 

We have three s here. Two of them are function arguments, but the first one is 's function. That's misleading. Use or another name that's not already in use. Alternatively, import qualified or to show the difference more clearly. Use the standard library We stay at . isn't that clear to someone who doesn't know instances or well. But shows its intend very well. It's provided by : 

However, you should try to make all your functions pure. That way, you can easily test them later. Also, you can try to generate passwords that contain at least one digit. It's not possible with random by default, but you can probably achieve something similar to a modified . 

Either way, if you're striving for performance, you want to keep the number of function calls low, so consider an output buffer if your current variant isn't fast enough for your liking. But first measure your program before you change it. Goals Let's revisit your goals and check them now. 

Wow. For 4000 elements, we have 1813869 checks. That's almost \$4000^{1.8}\$. Each of those checks is linear. While the size of the list decreases, at worst case it has size \$\mathcal O(n) \$. We end up with \$\mathcal O(n^{2.8})\$ complexity from our empirical point of view, which is really close to our real behaviour. Prime time for efficiency Now that we now that the checks destroy our runtime, and the creation of eats the other half of your RAM, let's get back to the drawing board and remember what Eratosthenes' Sieve is supposed to do: 

This would fix the problem shown above in the example. You have to decrease the variable of course if you use , and you need to add it to your member variables. But both of them are left as an exercise. Naming Your naming was fine, however, if you prefix or postfix your member variables, you can drop . That way, you can also simply call for example. But that's personal preference. The only real naming-nitpick I had was instead of in the destructor. We know that it's a pointer due to its type, it's much more interesting what it points to. Other You should add a copy constructor, copy assignment operator, move constructor and move assignment operator or forbid those operations explicitly with . 

This compiles fine, even though we've used , not . So our s arent' really the same. This behaviour can be changed with , but it's something to keep in mind. For example, if you had checked that none of the elements were the same as the first, you would have gotten a type error: 

The point-free version of is perfectly fine. It's also the most natural one to do by hand, since is , and follows exactly that style. Defining new functions by combinatiing old ones is great if you have that style of function, e.g. 

When you write a program, you try to express your ideas in a way that the compiler underÂ­stands it and builds you an executable, that works as you intended. However, the compiler is a second-hand consumer. They will gladly take any code that is valid C++ and create a binary. The human, however, might not. As humans, it comes naturally that we organize the material we work with. Clockmakers will have their screws and drivers sorted, plumbers their wrenches and helpers. Mechanics have their bolts, nuts and gears ready in bins and cans, just a handful away. And we programmers, coders, C++ magicians? We can do what they cannot do that easily: we order our work itself. We partition it with functions and methods, we bundle our variables into single structures, we split our code in files, each meaningful on its own. We model our ideas into the very code in such a way that their interesting, clear, and not too repeating. Now, let us delve head-first into your fantasy world and see how we can improve it. Enable compiler warnings I don't know which compiler you use, but the compiler already tells you what might be wrong with your code: 

Now that you can see all cases, it should be obvious that your missing at least one, namely the one for the empty list . Also note that using and isn't very efficient, since you need to traverse the list twice. You could write a function like 

We see that most of the work is done in . That's nothing new, though. We would like to see where the additional work happens. Remember that I said that we usually have to add profiling annotations (also called cost centers)? Now it's time to add them: 

I think the last lines in both functions showed why I moved to be the last argument. You're off course free to change back to your pattern matching variant. Time for some exercises Now that we have something that's easier to read, it would be time to refactor. So here are some exercises: 

Provide to add single characters This will make a lot simpler. Use a capacity Your is \$\mathcal O(n^2)\$ since you have to realloc for every single char. Instead, allocate more memory than you actually need. Or use for your internal memory instead, it will take care of that automatically. 

So maybe tone it down a little bit. Display the string every th iteration. However, even the use of a string to compare the numbers is slightly weird. Transforming a number to base10 is usually slow compared to other artihmetic operations, and it doesn't cover your original intend. Instead, write a function that does exactly what you want: check whether your value is close to your previous: 

Same holds for your . Prefer to C-style casts Instead of use . Or use floating point literals. By the way, your is already a , so a cast isn't necessary. Using Only use in toy programs, and never in headers. 

Great. Now we're getting somewhere. We have now two paths we can choose to continue. Either we take our new approach, which is essentially , or we inline . Let us follow both. Mapping with a state In the code above, we essentially mapped over the list of factors with a state: the current value of , or rather . It turns out that there is already a function for that kind of operation, namely . We can incorporate into our function: 

In this case we've dumped the plumbing into , added type signatures and made the functions non-partial. Now, let's step back to your smart-constructor: 

I will show how I did the latter, so it gets easier to understand. First, if we do nothing in an , but everything in an , it makes sense to exchange those, e.g. go from 

has a worst- case \$\mathcal O(nkm)\$ complexity due to the matrix-matrix multiplication. If possible, you never actually want to use matrix-matrix multiplication, only matrix-vector ones, since the asymptotic time complexity is a lot better. If we have $$ A B x $$ with \$A \in \mathbb K^{n\times k} \$, \$B \in \mathbb K^{k\times m} \$, \$x \in \mathbb K^{m} \$, we end up with $$ \mathcal O(apply(mult(AB),x)) = \mathcal O(nkm+nm) = \mathcal O(nkm), $$ a cubic algorithm, dominated by the matrix-matrix multiplication. On the other hand, if we use , we end up with $$ \mathcal O(seq(mult(AB),x)) = \mathcal O(A(Bx)) = \mathcal O(nk + km), $$ two matrix-vector multiplications. For small , or that's not a huge difference, but if you start to use your type-safe matrices and vectors for numerical simulation, we end up in trouble. Also, matrix-matrix multiplication can create a dense matrix from two sparse ones, but that's going to far at this point. By the way, does not need . Overall I like the general approach. The ideas hold, but for ease of use we need a way to create matrices and vectors easily: 

The key to getting succinct here is still to split the code into another function. You can provide the code inline, but that's hardly readable anymore. 

Use Eq1 to implement Eq, Show1 to implement Show While it's a very recent addition, you should implement via and via . That removes the pragma from your code: 

Therefore, this behaves just as yours. Atbash This variant of can be used to implement . Don't believe me? Well, there's a cipher called Atbash. It doesn't need a key, and we could simply implement it like this: 

looks exactly how you'd imagine it. It doesn't need to be in , as it does not inspect the state, but let's keep it there for simplicity, again: 

all structs share a common initial part of the members, namely the value, so as long as has been properly initialized, we can use or to inspect (not change) the value. In order to update a field, we need to use the active member, e.g. 

While this only uses the given strings from the exercise, it already tells us that there is something amiss if we run the tests with :