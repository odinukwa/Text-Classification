Also, it may be important to note a texture atlas often contains character skins (character textures) and that the actual animation is (stating the obvious) not stored as 2d imagery as the animation in such cases is generally based on deformation of the mesh with tools like bones. 

You could use an "event/task buffer/queue" to produce this behavior. tl;dr: think of a main loop and a task array; the first task is initializing the menu which in turn will allow the user to activate a task that initializes the game. When a task is over, you return to this main loop, so all the resources that were used by the task, could be safely destroyed and freed from memory. The new task is queued by the menu before the menu is destroyed and then started when you get back to the main loop. You may also wish to use threads if you need to run the menu and the game simultaneously in the future. In the main() allocate the "event buffer/task queue" and fire the starting event , then go into the main loop that"ll check if there is a pending or currently active event, if not, then end the loop and the process. Since there is an event, the loop calls the and the menu starts up. You are now running the menu in it's own thread or in the main thread; when someone chooses an option, the menu adds the correct event/task to the buffer, in this case . The menu task removes itself from the active events buffer,exits it's loop and terminates, freeing all resources. The main loop is now active and it checks if there is a pending event as usual, it then activates the event and the game starts. 

This issue with frame rate should not influence your game design. Why not adjust the movement of units in your game to compensate for the varying speeds? If you mean that it is running at 140~ FPS in Windows and 120~FPS in Linux it is beyond optimization imho. You should normally stick with a lower than max fps cap, for the game to run smoothly at a steady speed. For instance if you think your game could run on speeds of 60 - 80 fps on the average user's computer, cap it at 60. Generally I try to calculate to the optimal fps for each machine my game runs on or decide, it should cap at a certain speed where anything lower means the machine is outdated. Optimal fps is in most cases, the lowest fps during the game. Anything higher, makes the game appear less fluid. 

Answer to original question (Do I need a main loop): It all boils down to the program counter. If you are making a game that will run more than a predetermined amount of time and will not generate code as it goes then you will need to kindly request your user's pc to repeat some instructions that it has already processed and what will possibly change in the meantime is the state (the values stored in the game's objects and globals). Since you know you will need to repeat instructions, there are several ways to complete this task and continually process the same instructions. All these methods involve moving the program counter back to the currently relevant instruction. The most common control flow statements that cause code to be repeated are called loops, another is the statement which is rarely used in modern code and has a similar effect in this case (completely not relevant to you). So to answer your previous question, do you need a loop? Yes, you do. 

1 You can either user or a big number library. Doing computations with large numbers (like in clicking / idle games often relies on such big number libraries). In your case, the numbers are relatively small so using 64-bit floating point will allow the needed flexibility. 2 How do you want the game to behave? some examples: 

You could use the Marching Squares algorithm to generate the 2d-mesh you want. After using the marching squares to outline the object, you could use this library to do the triangulation. 

To find the closest point on the bezier to the ball, you need to derive and find all the points where the derivative equals zero (the roots). It is a polynomial of the third degree so you could use a closed formula but it could be unreliable since the precision of the computer floating point represented fractions may not be sufficient. It is far better to use Newton or something of that nature. The derivative you need to find the roots for is: Assuming: a = start b = control c = end d = cirlce center point 

I did some research and checked and benchmarked some methods. I found this library which could be easily used with a navigation mesh to create a fluid motion. $URL$ 

Compute the points closest to on each of the lines (containing the segments) on the other OBB. If these points are withing the segments then compute the distance and store it if it's the shortest distance so far. Otherwise: Go to 3: Check on which side of the segment the closest point is an and compute the distance from the corner on that side. Again, if it's the shortest distance so far, store it and overwrite the previous best. 

I think they definitely use bone animation. They also either use high-res sprites(to prevent jagginess) or they use some form of vector graphics. It is entirely possible, they pre-rendered vector graphics into high res sprites. They definitely did not use pixel art for this one. :) 

I personally prefer to avoid subtracting multiple individual timers and user one internal clock to save on processing time and complexity. It is really up to preference(It doesn't affect performance that much). 

Same with y. Remember to bound speed so it's between zero and the max speed. If the enemy has a very slow speed at some point and it"s trying to stop, it may begin to move in the opposite direction. Do not allow it. Stop it if it's slowing down and its speed is under 1 * Acc. Long version: If there are no obstacles, movement on y-axis is completely irrelevant to (and does not affect) movement on x-axis. So the question you describe can be broken into two separate questions. 

Shorten the last part of the path by the radius of the area the units will occupy when they stop moving. You can guesstimate this based on the 2d size of the units and their number. Increase this approximation by 1.4-1.7x to prevent overlapping. Randomize n points that do not overlap around in the destination where they will stand. Sort the points by their distance from the last point on the path. When the nth unit arrives at the end of the path, move it in a linear path to the nth most distant point in the collection you randomized and stop them. ie : The first will stand at the most distant point, the second at the 2nd most distant. You should now have them standing scattered around the destination. 

Run DFS from the newly added bubble with same color condition to see which bubbles to drop. Run DFS from the top with no color condition and drop all bubbles that are hanging in the air. 

Now record the players input during the game and once the game is over send the recording if the score is high enough to warrant being checked. Play the recording on the server in a checker and see if the official game constraints are broken. This does not prevent them from creating something like a "TAS" (tool assisted speedrun) with some hacks on the machine. For additional measures you may want to have form of control over the seed of the game like seed is reasonable if the game was started at time . If you want to prevents players from cheating offline: that's impossible. If it were possible then people would have found ways to prevent users from cracking games in the first place. If you want to add some measures to make it more difficult to cheat offline and then publish that as an achievement online then there might be some more things you can do but this really deserves it's own question. BTW, encrypting the data and then decryption it during run-time is just a form of obfuscation and isn't considered a real measure of protection. 

Is there any method more effective than quad-trees for storing and searching sets of points that are not spread uniformly on the plane? I need to be able to add, remove and search for points that are within a specified range. I am currently testing with quad-tree but it seems the results are less than optimal when the points are not spread uniformly enough. The points are mostly clustered in specific areas: 

You seem to need to read the ActionScript 3 bible. This is not the way to do it. A slightly more reasonable way to do this is: 

If the character is less wide than one tile and is positioned around the center of the current tile, you simply check if there is a tile directly underneath it. 

2D - You need to load images and understand the image format. 3D - You need to load 3D textured animated models. Often times with bone animation. 

Using delta time(milliseconds that passed since the last frame) may not be sufficient to slow enemies down. Things like attack rate might be implemented based on the last attack time. While it will slow down movement if it is time based, it will neglect to slow attack rate, spell casting and other effects (Health regeneration, spell effects duration).. and such If you want to slow down a large group of game elements in a single player game, you could create a second internal clock for each creature, the clock starts at the current time when the creature appears. When a slow spell is cast, each frame, the clock is incremented by x% of the time that actually passed. All monster behavior is then determined by it's internal clock. If various monsters have resistance to slow, they can use their own clock, it is basically an integer that does not require a lot of space or computation. When the slow effect stops, the clocks are still being used and get incremented by 100% of the time that actually passed. This could also work for hasten spells. @Sidar : I see two choice, 

Now create three constants: public static final float acceleration = 0.1; public static final float maxSpeed = 5.0; public static final float rotationRate = Math.Pi / 50; For starters, get your controls somewhat right: Do this every frame: 

Pick one room at random. Add it to the (currently empty) list of rooms. Iterate over some data-structure that contain all rooms and find the closest room. If the distance between them is smaller than the sum of their radiuses then there is probably no reason to connect them but at any case "draw" a corridor with one non-straight line between their centers(I will describe the algorithm later). Reiterate over all and find the one closest to one of the ones. 

Much like Bane said, a "Multiplayer(network) physics engine" is a physic engine running on the server side. Much like any game logic running on a server side(to prevent cheating). To prevent lag, you can have a physics engine running per-frame on each client for fluid motion between server updates. Another engine instance running on the server updating the players less frequently for correctness and cheat prevention. Note on latency or LAG: There is no magic cure for lag, you simply have to optimize your code as much as possible and wait for technology to do the rest. Most latency isn't due to the amount of data you sent each sec. It actually has to do with number of milliseconds it takes that data to travel (could be distance related/ technology* related). Sending more data should not affect latency much with today's tech, because you will likely still be able to send data as frequently. In the old days, the bandwidth and the amount of data transferred were the bottleneck as far as latency goes, the connection was so slow (4Kb), it actually needed more time to send slightly more data. That is still true today only in cases where the amounts of data transferred is very large (streaming HD content on Netflix 2.3Gig per hour). The modern connection speed can handle game data pretty well, 10-40 physical objects moving around are not going to noticeably affect performance. For instance, if for some reason we switched from Ethernet to InfiniBand, the latency would decrease dramatically even though, it may or may not affect bandwidth. $URL$