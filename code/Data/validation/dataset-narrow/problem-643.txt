Your syntax: As an outsider to your syntax process (and perhaps a useful perspective of a "potential user" that wasn't part of that process): 

Ignore whitespace (although this has it's limits, we probably don't want to become --instead we probably want to error that we can't have two sequential numbers, we'll leave this to the parser so for now let's say the scanner will just emit two tokens for that and ) Turn symbols into single tokens (ex ) Parse numbers (may be multiple characters, can be ill formatted as in ) 

I think you shouldn't do regex matching on the arguments. I'm assuming the plugin API doesn't give an error to the user if the arguments don't match the regex. I think you want to be more informative to users when the issue an invalid command. Also with my suggestions above, all commands now have space separated arguments so you can just use the last param from . I've only included one doc comment as an example to make the example shorter. The rest are your job! is just a helper that turns an array into a comma separated list with "and" (ex. it handles two elements just being "x and y", but also 3 being "x, y, and z") I'm still undecided on whether this use of a decorator is worth it. On one had, it removes a lot of duplicate code (used in all but one command). But on the other, it's only two lines of trivial code per method, so maybe the indirection isn't worth it. 

Without getting too caught up in some of the more advanced python patterns I've used, the core idea is in (the only public method) . It is a generator. While we still have things in the input string to parse, it does exactly what we discussed: (1) ignores whitespace (2) returns (yield in generator parlance, which loosely means it can return many) tokens for math operators and then (3) yields a number if it encounters one. In case you're interested, earlier when I said Python is not well suited out of the box for this, those concerns manifests themselves in the above code: 

In compiler design these two are called the scanner and the parser, respectively (I'm using parser loosely here, since in a real compiler a parser produces an AST, but in the case of a calculator it's more ergonomic just to do the math in the parser). Their jobs are: 

There are a few strange things about your code. You are using SHA like a KDF, which is a function that generates randomness from a limited source of entropy. The strange thing is, you have a (virtually) unlimited source of randomness in either or . And you are asking for a random hex in a way that to me distinguishes it from random bytes. So let's clear up a few points: 

There's a bit to unpack here. But the idea is that you'd use it like this: . behaves exactly like . It has all of the same properties and methods. However, whenever you call one of the methods, the method is invoked afterwards. For example: 

Note that this code is only loosely tested. You should write tests for each component. As I've needed to loosely test, I've fully implemented everything and will put it in a gist in case you get stuck connecting the dots (but really the only thing I left out was exceptions): $URL$ 

Python doesn't make this pattern as easy as it could be (see Ruby's ), but the ugliness is contained to this class. If used this approach in production in a few places, and for simple cases like this is works just fine. To use our new decorator we must wrap any polls we create. Since we want to keep the nice, expressive syntax, the logical place would be to make that a computed property of that handles the wrapping: 

Notice how each of these concerns cordons off a specific part of your application. And, critically, each only interfaces with one component. (1) doesn't interact with redis or do any bookkeeping, it delegates that to (2) and (3). (2) doesn't have to concern itself with redis things. (3) doesn't have to concern itself with what user command caused it to be invoked. Now unfortunately, because of the way the plugin API works, it's not possible to completely separate these, but we can get pretty close, and in the process produce code that is easier to maintain and understand. Let's first look at the itself to inform what kinds of APIs we need from the other concerns. It needs to handle , , , , and any message containing a (and emojis) vote. That would probably look something like (inline references are of the form ): 

This is the exact code from the module, so I'd contend it's python-endorsed way to generate the randomness you're looking for. 

And in fact, we can just remove the method at this point. It only had one use and it was mainly a placeholder while we worked out the specifics of the Poll API. We'll just replace it's callsite with : 

And we're done! Hopefully that's given you an overview of how parsers are designed and how you can use parser patterns to make your calculator a lot easier to reason about. Because of this design you should be able to do the following as an exercise fairly easily: 

We want to be able to handle lots of arbitrary spacing (ie. is the same as is the same as ) and ensure that there are no invalid characters (or bad numbers like ) Once we have valid characters and extraneous spaces removed, we want to make sure that the expression is well formed (parens are balanced and every operator has something that evaluates to a number before an after it) and then evaluate it 

Big takeaways: Notice how each of the commands is now significantly simpler. They only attempt to handle parsing commands and formatting output. Their behavior is immediately apparent from a quick glance, as are their edge cases. It should be easy to modify a command's output or behavior or maybe add another command without having to understand the specifics of serialization or the poll's business logic. This deferral to the other components is also done in the most pythonic way possible. We call out to a , which if one isn't ongoing is . A current poll can be cleared by setting to . Also note how our use of a as the return of formally codifies a contract between the and the about how to exchange information. Additionally, we have completely removed the idea of the "changed since tally" flag. That is now entirely handled in the poll, so it is impossible to make a mistake where we don't set this flag inside the . Another thing that you mentioned was your were unhappy with regexes. I removed most of them, because I believe the commands should error when given the wrong arguments. The only regex is the one for checking if a or precedes a message (indicating it may be a vote) for . We have significantly simplified the regex and that method since all polling logic has been extracted. Now let's look at creating this object that we've been using. For now we'll skip serialization and and focus on implementing the class. 

I continue into the meat of my analysis assuming you take all of the above recommendations. As you'll see, I think this greatly simplifies the code and also makes the system easier to use and understand from a users' perspective. The Meat You identify yourself that the code is "very long [...] and [your] main concern is readability and abstraction." So it seems like you're on the right path. Let's motivate that a tad. One of the first observations I made when reading your code was that it looked really good until I reached the class. It contains about 98% of your logic, and while the separate commands are somewhat separated, the concerns address by each of these commands are interwoven and duplicated in many places. Just skimming over , these concerns are easily identified, mainly because you've done a good job of phrasing your code with whitespace. So perhaps, you are even aware of these separate concerns. For example, most of the commands are responsible for a series of things: 

With specific comments about your code done. Let's think generally about calculators and talk about useful patterns for building them (and compilers for programming languages, to some extent). The end product here will likely be a lot longer than the code you've written, but it will be a lot easier to reason about and extend! As a result of it being long and me becoming hungry, I'll omit many uninteresting parts of it (such as exceptions, which I'll just assume exist). You likely didn't realize, but your code is actually already divided into the right parts! You just named them a little differently (and they don't behave exactly the way the patterns proscribe). Intrinsically, we have two different concerns here: 

There's a lot to unpack here! First, take a look at . It just parses an expression and returns the result of evaluating it (remember how the first production in the EBNF is the "main" one?). To parse an we parse a term , collect any number of that follow it, and evaluate out that math. We do something similar for . For we either try to parse a number (just a ) or a (subexpression) and if we can't find that we raise an error. Notice how the actual work of doing the math in done in and . But, critically, note that the former should only be given lists of floats (must already be evaluated, the parser handles this via recursion) separated by operators of the same precedence. This means intentionally cannot handle . The parser handles this. It would first parse a and call . This would be returned and then it could finish parsing the and call . For a simple calculator example, this code is decent. But you can see how things quickly get out of hand for more complicated EBNFs. This is what I was alluding to earlier. This code needs the following helper: 

You'll noticed I've omitted the docstrings, because this answer has gotten really long. You should include them. Notice how this class only concerns itself with tracking support and opposition for options and abstaining votes? No mention of any commands or serialization! You should be able to test this in isolation to make sure you voting mechanics work (and you should, because I haven't!). The class method may look a little strange. I'm a big believer in logicless constructors for testability. Users of should never create a new one on their own. They should invoke . But for tests, you can create one at will with some state already setup to see how it behaves. This also acts as a nice entry point for our serialization methods that we'll add later. Some wins for this separation are that the logic for finding the option a user meant is centralized, as is the logic for ensuring a user hasn't voted for anything else. All of the vote logic is now close to each other, so making changes to voting mechanisms should be easier (because a change's impact can only affect the surrounding code). One thing to note is that in designing the API, we've exposed an exception that we need to handle and tweaked how the param to the and methods work. Namely, can be none (in the case of a binary poll) or a string (the possibly partial name of the option). Updating our is easy: 

I won't dig into the details of these (the doc comments should make their behavior obvious), but the need for them is a good demonstration of why Python isn't quite fit for this task out of the box. Now we have a working scanner that we can use like so: 

Grumble, grumble. Browser tab crashed and SO didn't save my draft apparently. I'll try to recreate everything I remember writing: First off, your question is fantastically written. Often one of the most important skills in writing good code is being able to communicate your intent and any problems you face clearly. You've done an excellent job of this. I'll start with the good: 

That's a lot of responsibility for a single method. What's more, a lot of these points are duplicated code between the methods (especially the storage/retrieval/serialization/deserialization of the state). What's bad about this? For one, copying and pasting is bound to produce errors eventually. Also, to modify how data is serialized, you need to modify code in many locations. Someone who isn't as familiar with the code as you may miss one. Finally it makes the code difficult to test. As you've seen the only tests that you can reasonably do are integration tests. While this may be sufficient for a plugin, I believe testable code is maintainable code. What is a better way to structure this? It's all about separating concerns. Each class should optimally have a single responsibility. Here are the concerns I can identify in your context: 

Watch out for the recursion. Python's recursion limit could bite you depending on the size of an island. To avoid this, it's pretty easy to rewrite the removal iteratively using a set. 

Nice job with your calculator. Overall it's pretty clean, and you have decent use of functions to break behaviors up. But, I'm very nit picky and am going to recommend some really aggressive refactoring, so don't take anything too personally :) 

Note: This assumes that returns for a key that doesn't exist. Assuming retrieve just returns the command result from Redis, I believe this is the default behavior for most redis clients. If not, it's easy enough to modify this to handle how behaves. Now without making any other changes, we have a poll that serializes as we update it. This is a really elegant concept. Should we want to swap out the persistence layer or remove it entirely, we only need to modify this property. We also note that on first access, we try to read the poll from the persistence layer. This is a little jagged of an edge, although since we extracted the decorator, I content this is still rather clean. Since the Plugin is the only object that has access to and , we are somewhat forced to somewhat handle persistent within it. But we've successfully extracted it away to a small corner of the object. The whole code is in this gist, in case you want to see it all together. Separation of concerns also has the benefit that we can separate this behavior into three more-manageable files. So, I think that's about it. I was pretty aggressive and opinionated with my refactorings and I skipped a few steps, because this is answer already way too long. But that should be the gist. tl;dr Separation of concerns/SRP is your friend; it makes code easy to maintain/read/test 

See how it gives us a list of tokens we need? Now, we can move onto the parser (without having to worry about things like bad whitespace, or numbers for which will raise errors). It's at this point that typing would make things a lot safer (notice how our list is of floats and strings--which we trust are operators), but I've chosen to omit it to not overwhelm. Now, let's talk about the parser. The reason why we are going to reuse is because, in effect, is a parser that takes an iterable (specifically a string—an iterable of characters) and produces something (tokens). Our parser will also take an iterable (the tokens produced by the Scanner) and produce output (for the calculator this is a single float—or it will raise an exception). Now before we do this, we need to understand a little bit about EBNFs. It's a good way of representing regular languages (the input to our calculator is). For your calculator, it would look something like this: 

If you're on Python 3.6, you can use to get cryptographically secure random bytes or to get hex-encoded cryptographically secure random bytes. If you aren't on Python 3.6, you can achieve what does with the following: