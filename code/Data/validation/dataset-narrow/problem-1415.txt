As an alternative to navigating the registry PDFs. The quickest/easiest way I have found is to do a search in the raw gl.spec file. It's the file from which the other stuff is generated, not designed to be human readable but isn't bad. Just remove the leading prefixes, gl or GL_ from the name. The entries have a deprecated property as well as adding them to a deprecated category. It also tells you at what version it was introduced so you know when it's been made available. You could also process them using a simple script to extract the information and put it into a list. 

I don't think forbidding real world money trading is likely to stay the norm. The reality is if you are able to trade an item in game there is nothing a MMORPG company can do to stop it. They can maybe take down the more obvious traders where a single account/IP is moving large amounts (or spamming in game) but if its an open market place (ie the ebay or MMORPGs) where anyone can sell and anyone can buy then there is little they can do apart from set up sting operations and try to catch a small percentage of people and that means they are wasting lots of time and resources that could be better spent on improving the game. Maybe they can waste more time trying to come up with a more complex solution. But if your economy isn't build to resist it and people can bypass it then you economy is going to suffer. Personally I think the best solution is to either totally stop in-game trading or fully embrace real world money trading and sell it yourself (maybe it would be enough to keep the game free), keep watch on any other markets that popup and undersell them (you are making your own money after all). Games seem to be heading in these directions. If you look at Planet Side 2, Hawken, Warframe and so on they don't have in-game money, but they do have XP that can also be earned in game or brought with real world money to speed up the process. Those aren't fantasy RPGs though, trying to wean players off GP could take a little finagling (RPGs are often about immersion in a fantasy world, if you make it impossible for characters to buy and sell then it seems very artificial). Perhaps gold still exists but can only be used to purchase 'standard' items but you have supernatural enchantment points that can turn those items into magical ones. That way GP is basically made useless provided you have enough to enchant stuff. Then there is the soul bound items like in WoW. Other wise maybe "Your character doesn't want to give 10,000 GP to Larry the Dwarf, you don't know him that well. Maybe if you adventure together you will become friends.". You would have a small amount that characters can give to anyone. You could monitor the amount of time characters spend in proximity to each other and the activities (it not just idling). But that still leaves you with botting and complex trading networks (if I can only trade 100GP, I just need to setup 10 proxy accounts to move 1000GP. Or maybe you can only trade after reaching a specific level to prevent dummy accounts. But all that stuff will just waste resources and add odd rules. 

You could also make a more advanced one with templates that's generic for any type. Boost has them also if you are ok with using a library. 

Might I suggest looking into free alternatives. There is plenty of Creative Commons licensed content. You can find ones that are licensed without the NC (No Commercial Use) clause. For example CC-BY just requires credit to be given. I'm not sure if the SA, Share Alike license is usable with a commercial game (it might require the game to be under the same license which basically would stop it being commercial, or maybe the license only applies to the song and any changes you make to that song). Also there are public domain songs available. Most of them will be really outdated (ie older that 75 years), or educational type stuff. They could be used for certain styles of games. Check out: $URL$ Archive.org should have stuff for both CC and PD (although I can't get the search to return results for any decent queries related to licensed music). I have also noticed that indie gamedevs have licensed content from some well known (well for the genre) ambient/trance music producers. Jon Hopkins was used in Vessel and Capsized used music from Solar Fields (They did the Mirror's Edge theme too). Might be worth looking into how the indie devs go about that, maybe a producers have a indie game friendly licensing system. 

I think games modern should have been able to ditch loading screens. I'm guessing the real reason that we still have loading screens is that most games are designed to run on Xbox 360 hardware. As such they will be limited in the amount of ram they can load stuff into and how much threading they can do. If you don't have enough ram then you will need to be dropping a lot of stuff out of memory and then reloading it from disk. Also it's just easier to load everything at once. There are also times when things like the harddrive might stall. What happens if the user is running antivirus in the background. If your not preloading stuff then you might have to have the game pause while it waits for that mesh to load or having things spontaneously appear. Games like Skyrim can provide you with a wide open world that you can run across as much as you want but as soon as you open a door to load a relatively small dungeon you get stuck with a loading screen. About the only reason I could see the dungeon load screen being needed is if they use some extra heavy prebaked lighting used for indoor scenes which if fairly large to load (made from 1 giant mesh or has detailed lightmaps) or needs some calculations to be done at runtime. I believe the Skyrim dungeons are just built from modular meshes rather than one giant mesh (at least I think Oblivion's where). There's no real reason to load more than the stuff you can actually see when entering the level. The same way games don't render stuff you can see, you can cull what you actually need to be loaded straight away. You can also stick in a lot of dummy place-holder objects. Then you can use threading to asynchronously load objects in surrounding areas, their meshes, the textures and so on as the player moves around the environment. The way I would ditch loading screens is as follows: 

This could also be a reference to an object in a 3rd party physics engines. Or it could be an offset coordinates with a reference to another location (for a tracking camera or an attached object or example). With polymorphism it could be either depending on if it's a static or dynamic object. By keeping a reference to the spacial index here when the coordinates are updated the spacial index can be too. If you are worried about dynamic memory allocation, use a memory pool. 2) A binding/linking between your object, its location and the scene graph. 

As for making things 'aware' of each other. That's collision detection. It would be implemented in the Octree probably. You would need to provide some callback in your main object. This stuff is best handled by a proper physics engine such as Bullet. In that case just replace Octree with PhysicsScene and Position with a link to something like CollisionMesh.getPosition(). 

If your trying to make stuff run on multiple OpenGL versions. I recommend that you make a class that deals with all your shaders in one place. That way you can just call shaders.usePhong(), shaders.setPrimaryColor(glm::vec4(1.0f, 0.0f, 0.0f, 1.0f)); That will allow you to take advantage of things like: 

Personally I recommend keeping the draw function out of the Object class itself. I even recommend keeping the Objects location/coordinates out of the Object itself. That draw() method is going to be dealing with low level rendering API of either OpenGL, OpenGL ES, Direct3D, your wrapping layer on those APIs or an engines API. It might be that you have to swap between then (If you wanted to support OpenGL + OpenGL ES + Direct3D for example. That GameObject should just contain the basic information about it's visual appearance such as a Mesh or maybe a bigger bundle including shader inputs, animation state and so on. Also you are going to want a flexible graphics pipeline. What happens if you want to order objects based on their distance to the camera. Or their material type. What happens if you want to draw a 'selected' object a different color. What about if instead of actually rending as soo as you call a draw function on an object, instead it puts it into a command list of actions for the render to take (might be needed for threading). You can do that kind of thing with the other system but it's a PITA. What I recommend is instead of drawing directly, you bind all the objects you want to another data structure. That binding only really need to have a reference to the objects location and the rendering information. Your levels/chunks/areas/maps/hubs/wholeworld/whatever get given a spacial index, this contains the objects and returns them based on coordinate queries and could be a simple list or something like an Octree. It could also be a wrapper to something implemented by a 3rd party physics engine as a physics scene. It allows for you to do things like "Query all objects that are in the view of the camera with some extra area around them", or for simpler games where you can just render everything grab the whole list. Spacial Indexes don't have to contain the actual positioning information. They work by storing objects in tree structures in relation to the location of other objects. They can be though of as a kind of lossy cache allowing a quick lookup of an object based on its position. There's no real need to duplicate your actual X, Y, Z coordinates. Having said that you could if you wanted to keep In fact your game objects don't even need to contain their own location information. For example an object that hasn't been put into a level shouldn't have x,y,z coordinates, that makes no sense. You can contain that in the special index. If you need to lookup the coordinates of the object based on its actual reference then you will want to have a binding between the object and the scene graph (scene graphs are for returning objects based on coordinates but are slow at returning coordinates based on objects). When you add an Object to a Level. It will do the following: 1) Create a Location Structure: