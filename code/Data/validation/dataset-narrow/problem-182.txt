Ran into a similar issue with Cisco WS-3850 switches connected to both Aruba and Aerohive systems. Wireless stations roamed between WAPs ( and because the director of IT didn't believe in site surveys, even stationary clients fast roamed ) and the switches threw errors and warnings about "MAC-ADDRESS-FLAP xxxx.xxxx.xxxx". Wasn't really able to resolve this, but potentially one solution - at least for Enterprise WAPs that have a controller appliance or controller server - would be to switch the WAPs from "bridge mode" in which traffic is directly bridged to your wired network and into "tunnel mode" in which traffic is routed either IP in IP or in GRE tunnels back to your controller appliance/server. If you have a campus type network setup or you're in a single building this is not so bad, but the amount of overhead you incur depends greatly on the location of your controller relative to your WAPs. If your clients access internal resources that are not in a centralized location then the overhead is higher. I think Cisco APs will work with a controller feature built into the WS-3850 switches that will alleviate this problem. I "resolved" it by disabling ip device tracking on the switches, but this was not an ideal solution. 

I'm troubleshooting a problem with my site-to-site VPN at one location. I've narrowed it down to the link being up, but traffic dropping due to routing problems. I'm running ospf with over ipsec protected gre tunnels on two Ubiquiti routers. I'm using tcpdump to try and capture bfd packets with a non-zero diagnostic field. I'm using the BFD header described in RFC 5880 found here 

You might be able to do this using OpenVPN instead, although you'd end up needing to install client software. Assuming that the need is for something more secure than PPTP on the client end... 

The reason this is so important is because using a pair of wires twisted together to carry a signal utilizes the electrical properties of the wire to improve signal strength, reduce attenuation and destructive interference - it's a great trick to make crosstalk work to our advantage! ( $URL$ ) The difference between CAT5 and CAT3 is the number of twists per inch ( three vs. five, unsurprisingly ). CAT3 is not rated for speeds over 10Mbps and as a result is mostly seen as legacy POTS/PBX cable, whereas CAT5 is rated up to 100Mbps ( and years ago replaced CAT3 for pretty much all uses ). CAT5e has a plastic core that keeps the pairs twisted evenly in the cable related to one another and is rated up to 1000Mbps. ( @YLearn pointed out this is not the case -- CAT5e and CAT6 do NOT require a spline, however some manufacturers used this as a strategy in production of cables ) You can see that the same basic electrical wiring sees an order of magnitude performance improvement just based increasing the twist of each pair and another order of magnitude based on the way the pairs are twisted together. Another poster ( @Jordan Head ) correctly pointed out that while this is a great learning exercise or as an emergency short-term production fix, it's very important to follow standards - no one wants to have to troubleshoot random wiring pinouts in the middle of the night when there is an outage. It's an added difficulty that should be avoided in production environments. 

So I think it's important here to get the terminology correct, even though it's VERY common that people use the wrong terms. Properly, an access point allows wireless clients to connect to the existing network (which is usually, but not exclusively, a wired ethernet network). This is distinct from a router, which forwards packets from one computer network to another, and often includes functionality such as network address and/or port translation. The confusion arises because many very common devices, especially home "wifi routers" put all of this functionality into a single device. The "power" of a router can mean a lot of things, and it's not at all clear what's being asked here. At least one important distinction would be whether we're talking about "how good is this system at sending and receiving wireless signals" but another might be "how good is this device at doing packet forwarding?" - these might well be very different things for a given device. In large deployments, you can have lots of access points that cover a large area (think about a large commercial building) but none of these access points are actually doing the routing or NAT/PAT functionality. So... all that said, it will really help us answer the question if you describe in better detail what you're asking and use the terminology most appropriate. I briefly looked over the relevant wikipedia pages and they seem to be reasonably well written: [1] $URL$ [2] $URL$ [3] $URL$ 

Access points can be configured to broadcast their SSIDs, or they can be configured to only listen for connections from devices that know a given SSID exists. Virtually all wifi client devices (laptops, mobile phones, tablets, etc) will broadcast at least some information on a periodic basis. This is the information that a listening access point (or maybe more generally called an analytics gathering station) will hear and use to build maps and data sets of which devices are in the area. How much or how little (or how often) any given device is broadcasting information or attempting to access the network is highly dependent on the individual device. For a reasonably good introduction to how this stuff works, may I suggest: $URL$ $URL$ $URL$ 

The NCS6k is designed to operate as both a stand-alone chassis, as well as connect to a separate chassis that holds only switch fabric cards. As a standalone system, the switch fabric still interconnects all the linecards, but the fabric cards are on the "back" of the chassis and have only internal-facing interfaces. In a multi-chassis system you have a set of "linecard chassis" that all interconnect through a different set of fabric cards to the "fabric chassis". Essentially, the fabric chassis allows you to build an even larger system than you could with a single chassis of 8 linecards. 

There are 3 real ways to fix this, all of which are fairly simple. Automated Storage Cleanup Juniper has a system cleanup tool for handling this automatically. It operates almost exclusively under the directory structure; meaning it isn’t all that critical, unless you care about your log files (which you should!). Below is a on multiple FPCs. 

If was the only device pruning, all other downstream switches would be needlessly spammed when expected not to. 

I think it would be resonable to assume the collector () is misconfigured or something is preventing connections inbound to it. 

1Although ntop is still available in every Linux repo, development has ceased and continued with ntopng. 

This sounds like a case study for sFlow. The best way for you to figure out what's going wrong is to figure out who's talking to who - and how much. Just spin up your favorite sFlow analyzer and start tracking the bandwidth consumption of individual users. Here's an example sFlow configuration pulled from sflow.com that you'd put on your WAN interface: 

It is absolutely possible to communicate through a TCP connection, and as jwbensley mentioned, Scapy is an excellent tool for packet manipulation. However, in your instance, I would stick with something like netcat. Netcat is a low overhead tool that allows you to read/write data over the network. A simple implementation of a TCP connection might look a lot like this. 

Without saying it, you have the right notion, it all comes down to speed and flexibility. This is directly related to the amount of runtime operations and parameters you must check against. I’m not an expert on Windows file system ACLs, but conceptually the facts remain the same. One look at the extensibility of Windows file system ACLs and can you can see that you have a lot of different options for a wide array of attributes and security levels. Each of these options comes with a level of memory and CPU penalties. The goal is to provide a flexible, seamless permissions structure that still offers granular control. This includes capabilities on different file systems, account types and environments. It was built to serve a specific purpose, file control, which doesn’t necessarily need to operate at over 100 million events per second, like a 6509 would. At the opposite end of the spectrum, you have network ACLs that were designed with speed in mind. When you create an ACL you not only have a hardware-optimized platform performing these comparisons, but you also have a strict set of bit-wise operations that are happening1. With standard ACLs, you only look at source and destination addresses; indiscriminate of any other TCP/IP variable. Take the below test results from the European Advanced Network Test Center (EANTC). They stress test a 6500 with 32, 10Gb ports at 90% line rate with a packet size of 64 bytes (most stressful) from totally unique addresses and then compare it with a 10,000 line ACL that matches at the 10,001th entry. It yields a minimal drop in line rate and zero loss. 

Okay, so I found this link which had an interesting example of how to build a tcpdump filter to match SMTP packets beginning with the string 'MAIL' in the segment data. It looks like my biggest error was in forgetting that the UDP packet nested inside the IP packet is what I wanted to filter. Using that, I came up with 

You can enable lldp while leaving cdp disabled, globally and per interface. Don't know if lldp will include TLV with IOS version. 

which seems to do what I want and show packets with diagnostic bits only. The correct filter for the version would then be ( in this filter the diagnostics bits are filtered to be absent ): 

Try this. $URL$ It looks like you'd need to use snmp-server enable traps snmp cluster According to $URL$ that should give you notifications for cold start, warm start and cluster change - possible changes in the cluster commander or member availability would let you know that you'd lost a switch prior to the warm-start alert. Don't know if the whyReboot object is included in the trap or if you'd need to poll that in response to the trap being sent. 

Adding ip[24] &31 == 0 still shows packets, confusingly displaying even packets with a diagnostic field set. I also tried ip[24]&192>>5=1 to get protocol version 1 but that did not behave as expected either. I've tried adding ((ip[24]&0x1f)!=0) without any luck either. The session drops without showing that packet that I normally see containing ( Diagnostic:Control Detection Time Expired (0x01) ). I feel like I'm missing something really basic. 

The colors are just there as an ease-of-use tool. What really matters from a functional standpoint is what cable is connected in the jack in what position. Electrically the colors of the wires make no difference. It will require care, but you can identify the wires per pair by "ringing" them out with a multi-meter with a continutiy check ( the symbol looks like an arrow pointing at a vertical line or a plus sign ). $URL$ Pick a pair and check with test leads on the meter to match them up (holding both ends of the cable together, put one test lead on one wire and one test lead on the other end, testing each wire in turn until you get a reading). It's a little bit more work, but you can identify a each wire this way and place them in the appropriate postion. Two issues with my original post addressed pointed out by comments below: You must keep the pairs in the proper relationship to one another and conforming to wiring standards and good practice. @Ron has pointed out this answer was unclear (Thanks!). It's VITALLY important to keep the pairs together as per standard. 

As others have said, you'll want to utilize VRRP to get one ready for the transition. Since you're using the vlan subinterface as the gateway for your vlan, you'll want a configuration similar to below. Here are sample configurations for the master that I stood up. 

You only need to keep in mind how clients are going to access the file server; I’m assuming this is done by direct IP. If that is the case, and your only real objective is to get clients to connect to the file server by it’s shortest path, then your easiest setup is to setup an IP address on each interface and point clients to their closest connection. With this simple of a setup, I can’t imagine a scenario where your connection will be your bottleneck. Have you done any benchmarks or taken any baselines on how that connection is currently used? Give that a go before you invest too much time into a solution that isn’t entirely necessary. 

I don’t believe Juniper platforms have any compatible outputs that allow access to that information and it doesn’t look like fits the bill quite right. They do, however, have some appealing logging options within the stanza that log to directory. Although I can’t confirm the configuration below gives you exactly what you’re used to receiving with , I’m confident it will provide more. I would test this myself, but my organization might frown on me self-initiating BGP route updates for thousands of routes (event soft resets). Give this a try: 

Juniper also has a note for changing the engine-id that needs to be done before it will work. It effectively means once you commit a new engine-id, you must also commit another username/password. 

Dry-Run and Locate File This way is a little more arguous, since you have to look through everything and make sure not to mistake any s for s. Run the with the option and look through it. 

I suppose this is theoretically possible, although what you are trying to accomplish is exactly what VLAN separation sets out to resolve, layer 2 separation. 

In your test bed scenario, you basically had a client and a server connected into 2 different access ports; one a trusted DHCP port. This is the simplest way to setup DHCP-snooping. Had this of gone wrong, I would suspect there is another, underlying issue/configuration mistake. 

You've assigned the network address (where all the bits not masked are zero) which is not allowed. For your subnet, the interface address can be anything OTHER than zero (the last 8 bits are all zero) or 255 (the last 8 bits are all ones). The most common convention is to have the router be the lowest numbered address of the IP block. Try this: 

So in the strictest sense, "IP over Ethernet" is exactly what it sounds like, it's the encapsulation of IP packets (datagrams, formally) in standard ethernet frames. For much of the networking universe this is just "normal" IP as so much of the transport has migrated to Ethernet nowadays. Somewhat more specifically speaking, IPoE is often used in comparison to PPPoE when discussing how services such as residential broadband are delivered to the end user. This can be a little confusing as PPPoE would more accurately be described as "IP packets encapsulated in PPP, which is in turn encapsulated in Ethernet"... but it's just broadly known as "PPPoE". The use of either "PPPoE" or "IPoE" in the context of residential broadband also almost always implies other components of the service delivery system, such as address allocation, authentication, accounting, etc. Authentication is normally a RADIUS server or sometimes Diameter. The exact rules on how authentication is performed and what devices can/can't connect are usually set up by the specific service provider. Broadly speaking, "IPoE" is more common in cable access networks, and "PPPoE" is more common in DSL and dialup access networks: although this is by no means cast in stone. I found the document below to be relatively useful: $URL$ 

(it might actually be "input" or "output" instead of "ingress" or "egress" but with a little question-mark magic you'll be able to find it. You'll have a whole bunch of output that shows you all the policer rates, actions, and token bucket depths. It's actually a very useful little command. ;-) 

This is correct: the pseudowire switching path does NOT do mac learning, so there's no way to populate that information. One possible workaround is to build a VFI that only has two ports. You will effectively end up with the same behavior (frames will just get bridged from one side to the other) but since you've now enabled the mac learning part, the system will store the MAC addresses learned from each side. One word of caution here: make sure you have enough resources on the system to learn all the MAC addresses. Most pseudowires don't actually have all that many MAC addresses, but some can/do.