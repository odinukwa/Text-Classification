Note that you might also want to consider which lets you append any HTML element by its reference, such as the reference obtained when you create an element using . That approach is more versatile (you can retain references to the elements in code and attach event handlers to the elements programmatically) but will be slightly slower than . 

You'll find that although there's a small performance penalty resulting from the need to sort the array, you'll be able to look up the indices of elements much faster this way. Check out the code snippet embedded below for some dramatic proof! 

Now I can understand why the above code might give you heartburn. It's essentially a nested decision tree instead of a sequence of straightforward (and readable) function calls. But it's much easier for me to trace the execution chain and understand what the code is doing at a glance, and there are no variables attached to the object (...well, except for the containing function, but you could avoid even that by converting it to an immediately executing function expression (IEFE)). Notice that within the scope of their containing functions, the calls to are always the last lines of code to be executed, reflecting the pattern I discussed way back at the beginning of this post. 

Appending to To append to innerHTML without forcing the DOM to reload with every change, you can use . For example, instead of use : 

getUserInput() You're missing the keyword before defining the variable . There's no reason to define variables for , , , , and , since you never reference those values by name. You can just populate your array directly. 

If you know there'll only be one element with the class, you could improve its efficiency a step further by using the native method. 

Performance Considerations As the code stands now, every time the function is invoked (that is, every 80 milliseconds) the code will parse the DOM looking for any elements with the class. You can improve the code's efficiency by moving that expensive operation outside the function. 

Note that in the above example, each time the bot talks is represented by an object with a string property and array property, and each object in the array is formatted as with representing a new question from the bot. This is recursively traversable so that you'd only need one common function to read a question, write it to the chat history, and display the possible responses. One benefit of this is that the data (your questions/responses) is separated logically from the view (directly updating the DOM with HTML and text). You can change or improve the way the questions are displayed without having to reformat your data. Here's a barebones proof of concept: 

This is useful if there are multiple entry points for the function, such as if you were to invoke it from the window's event. 

Side Notes is functionally equivalent to but takes up less space; that's a personal preference rather than a recommendation. If you prefer then stick with it. Similarly, I used the ternary operator () syntax a few times to keep the code concise, but you may prefer If/Else statements for readability. Working Example Here's a code snippet to see it in action: 

I'm not sure about ways to improve performance, but I did notice a couple things. Guaranteed Returns If the specified key is already set to the specified value, your function does not return anything. Maybe this is the expected behavior, but I could see it being a problem if you used the function to directly update the URL. 

I did change your variable named to to make it more clear that it represents an element in the DOM tree that we're climbing. You could improve this further by executing the relevant query selectors at or before the time the event listener is being attached, caching the results so that you don't have to requery the DOM every time an event is triggered. 

This gives us a few nice advantages. Remember how earlier I said you could store the current day of the sale in a variable? Well, you could use that to access the corresponding day and list elements without having to create a bunch of statements. Your final method might end up looking like this: 

How and Why to Avoid setInterval In general, it's best to avoid if you can help it. The primary reason is that has the potential to keep issuing more calls to the specified function while the function code itself is being executed during a preceding execution. An extreme example would be a case where the specified function takes a full second to run, but the interval is set to execute every 100 milliseconds; in such a case, by the time the first execution is complete, ten further calls would waiting execution. This isn't an obvious problem when you're working with large enough intervals and synchronous code, but long-running functions (especially asynchronous or looping functions) could lead to unexpected behavior, so it's best to break out of the habit before it bites you. A decent alternative to is to use . Within the function passed to , you can decide whether or not to repeat; if you want to repeat, just call again. Here's an amended version of your function, with an additional function to be used in the call. 

If you need to have the output in an array format for other reasons, such as sorting or mapping, that might outweight the benefits of the hash key object. Here's a snippet demonstrating using an object with hash keys instead of an array of objects: 

Overall, your code's fine. The only thing that really jumps out to me is that it clutters the global namespace with some variables; I'm not sure if that was intentional (such as if other code is then referencing those variables), but I'd try to avoid that if you can. I understand your unease with the way the code is written, so I'm going to use the rest of this answer to (hopefully) address that concern, and then I'm going to offer some suggestions for making your code more concise and arguably more readable ...but that's admittedly a matter of personal preference. Patterns for Asynchronous JavaScript After working with any programming language for a while you'll start to recognize certain patterns for the "right" way to accomplish something. This is especially true of asynchronous JavaScript, which doesn't immediately mesh with the single-threaded synchronous coding mindset we programmers usually start with. The biggest eye opener for me was to recognize that as soon as you've made your code dependent on the execution of an asynchronous function call, you should stop adding code to the current function, because when the asynchronous function actually executes, the current function will no longer be within the execution context. 

Selecting elements by ID When obtaining a reference to an element by its ID, it's more efficient to use than . Instead of: 

Since you're already looping through the elements in the and creating each span element one at a time, you might as well just tuck away a reference to each span as you create it. 

Consider More Specific Function Names I can see what you were going for with , but and are a bit abstract. In general, try to make your function names into verbs or verb phrases that indicate what the functions do. I'd suggest renaming to something like , and to something like . The extra effort of going back and renaming your functions pays off in the long run by making it easier for others (and your future self) to understand what the code is doing at a glance. 

To generate those nested, nearly identical calls, instead of coding them all manually you could have a recursive function that builds and returns a function for you. Something like this would work: 

Since JavaScript variables are function-scoped, this essentially creates a new scope in which your code and functions can refer to variables defined within. Code outside the scope (such as elsewhere on the page) can then use the same variable and function names without running into any collisions. 

Some variable naming conventions use ALL_CAPS for constants, which I've shown in the code above, but internal consistency is more important than external convention. Eliminating unnecessary variables You are only using the variable once, for the one-time assignment of the event handler. You can therefore bypass storing it in a variable altogether and just directly assign the event handler to the reference returned by . Similarly, and are each used only once after being defined in the event handler; you can eliminate them altogether. ( can be replaced with or .) 

If your main concern is making it more human-readable, one approach may be to use the bitwise OR assignment operator like so: 

Note for Old Browsers: Above code only works in IE9 and up. I've noticed that works only on DOM elements in Internet Explorer 8, so to work around that I can wrap the above in a try/catch and if it throws an exception just use my old key-polluting method of calling directly. Also note that this code will start to behave incorrectly when the array length exceeds 4294967290. Alas! Such is the price I pay for using the more efficient instead of the more reliable 

For the sake of completion, here are some analogous dummy functions used to generate a biased but still pseudorandom array: 

Note that you'd have good reason to reinstate the extra intermediary variables if any of them were being used more than once. Note also that I'm not suggesting that you eliminate the and variables and replace them with their literal numerical values, even though they're each only used once. In their case the intermediary constants serve to eliminate "magic numbers" and make the code easier to maintain. You could similarly endeavor to eliminate "magic strings" and convert your element IDs into constants. 

We divide it by 86,400,000 just to convert milliseconds to days. The bitwise operation just truncates off any decimals for us, converting the number to an integer. If the sale hasn't started yet, will be a negative number; otherwise it well tell us which day of the sale we're currently on (using array index notation, so for the first day, for the second day, and so on). Hopefully that's got you thinking about neat ways to programmatically determine which elements to show or hide. Try not to repeat yourself, especially when it comes to strings It's not much fun to have to go through your code and update a bunch of strings when something changes nine months down the road. You can make it easier on yourself by storing repeated strings of text into variables. 

Then you could set up a function for creating objects and attaching the event listener to fade in the given elements. 

Storing your dialog tree as a monolithic traversable object is probably a good starting point so that you can arrange the rest of your code around that model, but in the long run you might want to break it up into discrete, reusable chunks. This would give you the benefit of allowing you to return to previously traversed bits of dialog without needing to repeat yourself in the code. You could, for example, convert the questions to reusable functions. 

In the CAML query that we pass to SharePoint, we can specify filter conditions to retrieve only the items we want, so that SharePoint can efficiently give us that one item we're interested in. We already performed that query; this code is even inside an block that verified that we found the item that matches the desired 

I made a few improvements to this based both on Konijn's suggestions and my own observations, although I never was quite able to reconcile the simulation design with any sort of MVC approach. The most significant improvement is to the velocity algorithm. Improving Readability (Variable and Function Names) Only used ALL_CAPS for primitive and string constants, changing the canvas and the canvas context variable names to lowercase. Changed most anonymous in-line functions (such as the event listeners attached to HTML controls) to named functions. Renamed the ambiguous function to Changed the field to to reflect its expected Boolean type value. Removed some unnecessary intermediary variables pointed out by Konijn. Improving Calculation Accuracy (Verlet Integration) I incorporated the velocity verlet algorithm into the function to produce a more accurate simulation than that achieved through the original Euler algorithm. This required me to track the acceleration of each object, rather than just its velocity, and incorporate a variable. The updated algorithm more accurately simulates stable orbits, and doesn't produce the wildly inaccurate results that the old algorithm does when objects are under high gravitational acceleration. It's still an imperfect simulation of gravity, but the stability is more natural. Updated Simulation: 

Of course, to make the code more readable, you could mess with the structure of the parameters, such as by using objects with named properties... 

This brings me to my next point... Date objects can be compared directly Instead of comparing hours to hours, years to years, months to months, and so on, you can compare two date objects directly to see which one comes earlier or later. You can even subtract one date object from the other to find the time (in milliseconds) between the two dates. The code below will populate the variable with a number representing the number of days since the sale started (assuming is the sale's start date and is the current date). 

consider objects with named properties as alternatives to arrays In general, I think your code is over-using arrays to store values that are not inherently suited to that data structure. A good example of this is the use of the array and array in . You're populating with values from the text boxes, then looping through those values to check whether they're blank, and if not, you're then pushing those values into the array to represent your actual item. Consider instead capturing those values directly into an object, as below. 

You'd just need to be sure you remove the prefix from the element IDs. Do you need jQuery? At this point, you might want to consider whether you need jQuery at all. Odds are good that there are other things on the page that are using jQuery, so eliminating it entirely may be unfeasible. But there can be a benefit to minimizing your use of jQuery even on pages where it's being loaded regardless. The native, underlying JavaScript methods that are invoked by jQuery wrapper functions will always be more efficient (in terms of how quickly the browser executes them), at the expense of being slightly more verbose. 

Eliminating functional differences between Vanilla JS and jQuery versions Your vanilla script and your jQuery script are not functionally equivalent. Your vanilla is selecting the container by its ID, while the jQuery is selecting the container by its class and then selecting the images. Your vanilla script would more closely resemble the jQuery by using and/or . e.g.: Making it work for multiple containers Your code will function strangely if more than one image rotator container is on the page: the jQuery will grab image elements from all the containers and only set one to active at a time, while the vanilla javascript will only change elements in the first container it grabs. (EDIT: As you noted in the comments, you can work around this by selecting the different containers by ID before passing them to your function, but that approach requires manually specifying IDs both in the HTML and in the JavaScript. Ideally, you'd be able to just add more elements with the appropriate classes in the HTML to take advantage of the existing image rotator functionality.) With a little tweaking, you can ensure your code processes each container separately (allowing each container to have its own active image). 

Readability In general, readability is improved if your function names are all verbs or verb phrases. Contrariwise, readability is hampered if non-function variables are given verb names. Following these rules of thumb can help "make wrong code look wrong". In your case, you've named the buttons to clear the tables , , and . When I see a variable named my assumption is that I can invoke that method to clear the "done" table, but that's not the case at all... is not a method but an HTML button. I suggest making those variables more descriptive, much like you did in your function by appending to each of the variable names representing buttons. Efficiency When selecting HTML elements by their ID property, browsers are always more efficient using the dedicated method than using the more generic/flexible method. Other Thoughts First, in my experience it's usually best to avoid altogether in favor of . The function you pass to can decide whether or not it needs to keep executing and, if so call on itself again, and otherwise do nothing. This saves you from having to keep track of an interval ID externally and later call on it to stop the process from repeating. Second (!), rather than attempting to add a second to a counter with every passing second, you can keep a more accurate record of passing time by tracking the exact timestamps when the start and stop buttons are pressed, then calculating the difference as needed. That way, if there is ever a delay in the execution of your JavaScript, your recorded times are still accurate (or at least as accurate as the system clock on the computer executing the JavaScript). The pseudocode for that logic would be something like this: