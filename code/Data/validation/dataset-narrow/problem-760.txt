Provide a constructor that directly initializes the matrix Currently, you have to call , which simply allocates and default constructs the number of specified elements. This is inefficient unless you want a default-initialized matrix. Provide a constructor that allows you initialize the matrix directly: 

Replace long conditions with type traits. In order to promote from a smaller type to a larger type, you currently enable certain conversion operators based on on your type . These quickly become hard to maintain and are error-prone: you might forget to add a type, you might forget to update something, etc. In order to solve this problem, you can take a type traits approach. It will require some boiler-plate, but not much more than what you've already got with those long enable-if conditions. Traits based approach: 

Makes an type where is the values in the range \$[ 0, n - 1 )\$ when \$n >= 0\$. The template performs \$log(n)\$ recursions to generate the sequence. 

Do we really need and ? No. Here is an alternative solution: You currently allocate bytes. This is wasteful. You can use exactly as much space as you need by declaring your storage any of these two ways: 

Although C11 introduced , there is no support for aligned reallocation (AFAIK). The structure that follows and its related functions provide such functionality. I wanted to provide something with as little overhead as possible, which is why there's close to no error checking done. I envisioned this structure being wrapped in another structure that does do safety checks if that is required. Is this reasonable design? features: 

Performs the set union of two integer packs. The output set is sorted. The output set will have the integer type returned by applying to the integer types of the left and right integer packs. 

We can see that this is much more concise and easy to read. I believe that it is worth the extra layer because it automatises the pattern and conforms to DRY; it is used in the remaining types. 

Mark non-modifying functions as . functions of yours include , and a few more. Member functions that don't modify any of the class data members should be marked as so that they can be used in the appropriate scenario (accessed through a ). 

The variadic template is not a pack forwarding references, it is an rvalue reference pack. For it to be a forwarding reference variadic template, the variadic template must be a function template parameter: 

Review goals The full implementation (with iterators and a -like interface is omitted because of the amount of boilerplate code involved. This question is already long. A sample toy implementation is provided in the demo below to demonstrate minimal usage. I would like a review that focuses on: 

We need to test whether a certain door is openable by a certain key. Using the previous building blocks, that's easy to implement: 

This change requires that we also perfect-forward these universal references wherever they may be used: 

Use when you're finished with rvalue arguments. In , argument is actually used as an (which calls the copy constructor) because you forget to call . The fix is simple: 

Now that you are using static memory, you can provide two private functions to avoid having to use ugly casts everywhere: 

Unaligned memory Your storage is aligned for , which will lead to performance issues in most architectures and in others it just won't work (crash). Replace: 

Performs the set intersection of two integer packs. The output set is sorted. The output set will have the same integer type as the integer pack specified as the left template argument. Tests 

Refresher on the simple selection sort This is a simple implementation of a selection sort on which the template-meta-programming version is based: 

That'll do the same thing, and describes the intent more clearly. As an aside: you say that didn't work. That is indeed something that won't work, partly because C++ doesn't provide an all-that-easy way of joining a string together with something else. Your best bet would be , unless you wanted to go through the trouble of explicitly creating a . There are also functions like and , but those are generally less safe or harder to use. 

I don't see how wrapping a single identifier into parentheses is ever going to make things clearer. On the other hand, I also don't see myself immediately understanding how parses for every possible operator , or what will evaluate to. There's also plenty of cases between that, especially when you add operators with (imho) unexpected precedence, like bitwise . All in all, I advise to allow your coworkers to decide which form to use where, and to spend code reviews checking code for correctness, not for compliance to formatting standards. 

One thing Loki Astari hasn't covered is const correctness, which your code is sorely lacking. You should make anything that isn't going to change , and mark all non-static member functions that don't modify the object they operate on as , too. For example, the declaration should actually be , and the definition should be . Further, I'm not sure making private is all that good an idea. Are these nodes going to be used by one class, or many? If only one class needs to be aware of them, you could choose to make them a nested class and expose more of them. It probably won't matter for performance after inlining, though. On the other hand, I see no reason at all to keep around, as it is only ever set to 0 when an instance is created, and then never touched again (until the destructor, but that's mostly redundant). You should also watch out for variables that start with an underscore: if the underscore is followed by a copital letter, the name is reserved, and you should not use it. If you insist on marking your member variables somehow, consider a prefix or an underscore suffix. 

When there's only one function that calls the function, the added benefit is significantly less; we end up obscuring what exception is thrown and losing the ability to rethrow if necessary. If this is all insignificant, a try function may be worthwhile; however, I'd use it in reaction to a common pattern, not in anticipation of one. 

At the very least, you should place the second statement in a block. As things stand, the code is not generally correct from a purely mechanical perspective. I would also phrase it as: 

Indentation is generally done in powers of two, and should in any case be consistent. I'm switching to four-space indent everywhere, as you don't seem to be following any style. This is also a great chance to use pointer containers. Each node owns all of its children, so use something that will enforce that. (In some cases, an of s would make more sense.) You do not need any of the globals you've defined, and are definitely bad practice. You should also strive to be more const-correct. 

While C++11 does allow it. You are also missing overloads for comparison operators. A simple workaround would be to remove the overload and add a macro: 

While this is recursive, it entirely misses the point. As the while loop will only ever execute once (because the function it calls only returns when it could just as well have been an if, and thus all you've got is tail-recursion. What you have is equivalent to the following, but impossible to call twice and maybe less efficient: 

This is easily handled with a simple function that checks for a potential error instead of triggering an error. Code first, and then an explanation: 

This allows me to convert a range to an array, and then use those values more efficiently. Variants do have their place when used properly, but they shouldn't be used out of laziness. For example, in your code, (which should be ) and (which should be ) are used as numerics (and as such, should be Longs) but are declared as Variants. I assume, it is because they are then implicitly (without explicit direction) converted to strings, but even this doesn't justify the use of variants. You could do something like: 

Know I know **exactly* what my code is doing, and I can debug it much faster if something breaks. Indentation This is a pet peeve of mine, and it is a pet peeve of the community as well. Always indent your code (properly) and never post code on SO that is not indented. We will be cursing your name as we indent it ourselves (or, even more frequently, we just refuse to help). A lack of indentation will make bad code even harder to read. Shameless Plug For Rubberduck Mat's Mug and his team have a tool called 'Rubberduck' that goes a long way towards enabling you to fix these problems. Everything from indentation, to variable naming and variable use, even to Function and Subroutine calls. I highly suggest checking it out: $URL$ . In Closing Whatever you do, don't simply copy and paste my code, throw it into your module, and just go on your merry way. I spent time on this to help you learn, and my hope is that six months from now you will be in my shoes. If you do decide to forego the learning opportunity here, you will miss out on all of the things VBA can really offer. Best of luck! 

We get rid of all of those counter variables (opting instead for i and j which are pretty standard). Our other variables are quite clearly named, and everything is what you would expect. As a result if you (however many years from now) come back to the function to add something new, or if it breaks, you can quickly find the source instead of trying to remember what and were and why you set or to and so on so forth. Again, highly recommend picking up a copy of . The idea of levels of abstraction, functions, classes, etc all can be difficult to understand at first but once you get going your code will become much easier to read. 

Aside from the couple of instances of a single ratio being matched to two different aspects, they are fairly consistent. So then I checked each of the original aspects and their results: 

Initial Notes The first thing that struck me about your code was that you literally have no variable declarations. Lines like : 

Admittedly, this is uglier than Mat's Mug's approach, but this is the approach I use because it suits my style and needs a bit more. The benefit here is that you can choose your approach to handling the error. So, for example, handling an error in the routine can be different than handling an error in the routine. I also avoid statements as much as a possibly can. There isn't anything wrong with them when used well, but I try to anticipate errors if I can. On that note, and as others have noted, some of your subroutines need some cleanup. Someone in the RD group recently reminded me of the 'Single Responsibility Principle'. Everything should be responsible for one thing, and in turn, that thing should align with it's own intent. Along these lines, I would argue, that one unique thing should only ever be returned by one owner of sorts. For example: