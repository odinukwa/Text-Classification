Other possible changes: I didn't make any of the changes below because you said your code was working, and I don't know those programs enough to guarantee the changes are an improvement. A) I don't see why you run WinSCP via START. I believe you could simply use: 

Use FOR /L to iterate a range of numbers - much faster than SET /A with GOTO loop. Use SETLOCAL to localize variables so no need to undefine them. The EnableDelayedExpansion option does just that so that you can use within a FOR loop. A minor optimization - it is faster to combine multiple math computations into one SET /A. 

You can use a FOR /F to parse out the command from the arguments. I would define a variable containing a delimited list of all valid commands. Then you can use simple search and replace to validate whether the user entered command is valid. Addition of a new command is as easy as adding the command to the list, and creating a labeled subroutine for the new command. I would use CALL instead of GOTO so that each routine can easily parse the arguments. The only disadvantage is CALL will double up quoted carets ( becomes ) Here is a basic framework that can easily be extended. Note that user entered will be corrupted (or expanded) because of delayed expansion. There are simple ways to get around this limitation with additional code. 

The four if statements inside and seem to be the same, so you could move them to a seperate function. However, you currently have set to a fixed value and you don't change it. So as it is, the if statements are unnecessary. Some variable names are rather cryptic: , , etc. There are unused variables: e.g. The browser identification and the "calculation" of seem to be good candidates for a seperate function. 

Update Added 8. - 11. If you are feeling confident or want to try static code analysis, you might want to look into something like $URL$ or $URL$ . They can warn you about global variables, unused variables and more. ad 4) As Schism mentioned, this advices may lead to unwanted global variables if you mix up and . So for example: 

Mixing of PHP/HTML This is probably the problem, that will annoy you the most in the future. As it will make dealing with outputting stuff way more complicated than it needs to be. I highly encourage you to use some kind of templating system to render templates and display html. Don't ever output or print html code in a php file. Take a look at twig (used in eg. Symfony). Something like that will extremely improve your codebase. Your problem with printing will vanish and you can use common parts of html code without any problems. Advice #10: Use some kind of templating mechanism to output HTML. 

related jsperf $URL$ Well this is a really bad idea. Objects are always considered having different class if they don't have exactly the same set of properties in the same order. So a function that accepts these objects will in best case be polymorphic and in worst case megamorphic all the while you are thinking you are passing it same class of objects. This is fundamental to all JS engines although the specifics that follow focus on V8. Consider: 

So the same function body ran 15 times faster because the object passed to it always had the same class. It is also hard to predict if you will actually save memory if all those 10000 objects allocate a different class for instance. It is also complicated to really look at all the downsides but having optional properties is one of those things that it is easy to say is very bad. 

That actually looks a lot like code that loads properties from objects that are in hash table mode. Is it fast? Unfortunately jsperf is down now so you have to run it yourself with code here: 

Now the function must consider 2 different classes of objects. The classes are different but similar enough that the client code can stay as it is as both classes contain a field . Let's see: 

Define all your error types globally in some file for convenience, like the built-in errors are defined. Mixing promises and callbacks is a big anti-pattern, just think in promises and let .nodeify handle the mapping to callback equivalent at the end. 

The use of global objects is generally discouraged, but migh be okay given your current experience. Another (slightly) better option is to instantiate the database once and pass it to the method that needs the database. The imho best option is to use dependency injection. However, this is pretty advanced stuff and something you want to look into in the future. Advice #7: Use dependency injection if possible. Globals might be okay for now, but lead to trouble in the future. You say, that you have posts and comments. However, in your code you only deal with assoc arrays. Why don't you create classes for Post and Comment? This is the perfect place to use a class. Advice #8: Use classes for entites (Post/Comment) and not assoc arrays. If you use classes for Post/Comment, you might wonder how to write them to json. PHPs jsonSerialize will help you there. However, you probably have to convert json -> Post/Comment yourself. Advice #9: Use jsonSerialize or something similar to serialize objects to json. 

I suggest splitting HTML/CSS/JS into different files Your use of indention and whitespaces is inconsistent 

Source Code Structure As already mentioned, only define one class per file. I like it, that you encapsulate the fields of your classes. However, you have many static functions, which basically degrades your classes to some kind of namespaces. There is nothing wrong with static functions, but be careful not to overuse them. Advice #6: Don't overuse static functions (and statics in general) As you mentioned, and is suboptimal. You have pretty much three options: 

I can almost guarantee it is not doing what you think. The most it can do is set the ERRORLEVEL. However, The EXIT command expects a numeric argument, but you pass . The EXIT command returns 0 if it does not receive a numeric argument. I doubt you have a variable with a name of "0", so the EXIT command sees a string literal value of , which is non-numeric. It consequently returns 0 every time. Your very next command (FINDSTR), is an external command, so it will set the ERRORLEVEL anyway. There is no need to initialize it. 2) It is generally a good idea to enclose SET assignments in quotes. This guards against poison characters, and inadvertent trailing spaces. (There are some exceptions, but it is a good rule of thumb). 3) It is generally a good idea to always enclose file paths in quotes if a portion is a variable. You never know if the variable may contain spaces or poison characters. The value normally does not have spaces, but it certainly could. 4) There is no need to delete "%temp%\rdcto.txt" when you immediately turn around and recreate it. You can simply redirect using overwrite mode () instead of append mode (). This will guarantee you start out with a fresh file each time. 5) Why do you write the value of %MailDst% using a FOR statement? You can simply echo the value directly. 

Project Structure Currently, you have a few php files in your root directory and a few php files in your PHP directory. On a first glance, it seems, that the PHP directory contains your framework and the root folder contains the views, which use this framework. If that's the case, make it obvious. Advice #1: Give your framework a name and rename the folder accordingly. That way, you will have an easier time to find the place you are looking for. Which leads to the next problem: Your core.php contains multiple class definitions. If you continue doing this, your file will grow exponentially and it will take you a long time to find the line you want to modify. Advice #2: Put each php class in a separate file. The next step is to use namespaces to further structure your classes and files. It might be more difficult to begin with, but will help you in the long run. Additionally you might want to look into autoload. Used correctly, this should solve your troubles with and . Advice #3: Use Namespaces and autoload Another possible improvement are the files in your root directory. Currently you probably access each file directly via www.whatev.er/viewPost.php or www.whatev.er/createPost.php. I highly recommend to take a look at something like a controller/routing mechanism and only use ONE file (index.php) to access your website. Take a look at .htaccess and URL Rewriting. This is actually a pretty powerful and extensive technique. So just a short explanation: Every (nearly every) call to your website is redirected to your index.php. So www.whatev.er/blub/bla/1234 or www.whatev.er/post/create all call your index.php. In the index file, you can parse the requested uri and call the appropriate actions. Advice #4: Use .htaccess and URL Rewriting and only one file as an entry point to your website. Advice #5: Use some kind of controller/routing mechanism to handle actions depending on your route. 

Notice what happened here, V8 saw that we always pass the same class of object to the function and generated really tight code that assumes we will always get that class of object in the future as well. Now let's do: 

Ok so the situation is still pretty good but here we are relying on the fact that properties are in same order and that there are only 2 different classes. Let's do the same in different order so that V8 can't use the same instruction () for both objects: 

In a good implementation you pay for a lot of functionality only if you are actually using that functionality - so a lot of functionality doesn't necessarily mean slow. In fact, more often than not, implementations with small amount of functionality are very sloppy and not fast. Consider underscore using a -statement. This slows down performance unspeakably but is done because it takes no effort from the implementer. Implementing variable referencing properly without using would take a lot more code. Overall an optimized library will always have a lot of more code than an unoptimized one. It's a simple physical law. 

Ok just as expected, just using different offsets depending on the class. So you can see where this is going, if you end up with 10 different classes then you will just get 30 instructions (instead of 3) whenever a function will need to lookup a property. Which is still much better than a hash table (100s of instructions?) lookup. Well no, turns out there is a limit of 4 different classes and then you go into megamorphic mode. So with this, we should see radically different code output if we use 5 or more different classes: 

Method names are inconsistent , , . Consider writing constants in uppercase to differentiate them from variables you intend to modify: instead of or in this case something like is more appriopriate You declare and assign your variable the first time somewhere between all the functions, although you have a method There are several magic numbers, that you could/should turn into variables Some parameter names are rather cryptic: You could use objects instead of arrays for some variables. E.g.: is an array with 2 elements (probably x/y pos). You could turn this into an object . That might improve readability in some places. Currently your update logic seems to be mixed with your draw logic. It is probably better (and easier to maintain), if you seperate these. Also, you check for game over inside your draw call... 

There are some magic numbers in your code, that you might want to extract into variables. Since JavaScript doesn't have variables (afaik), consider marking them via naming conventions. For example: 

First of all, it's good that you try to implement something like a blog/forum on your own. It will teach you a lot of good/bad practices. In one comment you said, that you are trying to understand how these frameworks could be impemented, so it would be very good, if you take a look at them. Check out their APIs and see what they did. Im used to Symfony ($URL$ so my advice will mostly use their architecture as an example. However, be sure to remember that there are many ways to success and the things I describe are my current point of view. Your major problems (maybe not now, but in a few days/weeks/months) are the structure of your project, the structure of your source code and the mixing of php/html.