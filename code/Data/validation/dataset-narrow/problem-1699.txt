You won't save much space that way, a few MB here and there. But: glancing through output from on the raspbian 2013-12-20 image, I notice a whopping 422 MB in . Google that yourself to find out what it is; in any case, it's not necessary. I don't know when or why raspbian added this to the base image (I doubt very much it is in the normal debian, or any other normal distro base...go figure). Since only names one package, that's probably what you want to pull. Try: 

It will not physically harm the pi, no, just beware "data loss" could extend to "useless card" which needs to be completely reformatted. However, I'd say the chance of that if you are doing it with the green ACT light off are very low. 

It is a multi-tasking system, and a bit of latency is possible. You could try upping the priority of the process (see ), and trying to keep the system as inactive as possible otherwise. The latency may be slipping in where you are coming in and out of system calls. E.g.: 

This is probably a Realtek RTL 8188EE chipset. You can usually find enough clues about stuff like this simply by searching online for "linux 0bda:8179". Once it is clear there is an in-tree driver, you can find it in the kernel source tree by poking around in the right place...from the top level: 

Init services run as root. Do not include in service files run by init, regardless of whether it is SysV or systemd. I would try [but please see comments, this is a bit personal preference]: 

As per this, there are two commonplace ways of conceiving of the board pin numbers. Based on your photograph, you are assuming the numbering scheme, but you have not actually specified one way or the other. While it says there setting that is mandatory, it could be importing the module under an alias () sets it for you (or there actually is a default and setting it isn't so "mandatory"). I do not use python so don't know. You should try an if/else clause to test the value of against , , or to see which it is. If it is that is not pin 11, that is pin 18 (or perhaps 17, if you started counting from 1, it is hard to tell which row that connection is on). 

Buildroot itself doesn't have a package manager because it isn't a distribution, although it could be used to create one, as appears to be the case here. I don't see anything on the IPE website to indicate that they do use a package manager (their own, or someone else's), however, I do notice they have a contact email and surely your best bet is to ask them directly. If it turns out that they do, please come back and provide a better answer to your question! The goal of producing a read-only system for use in embedded contexts where that level of (uber-paranoid) robustness is required might imply that casual network installation of software isn't desirable, so don't be surprised if you are on your own with that. If I were working on something like this, I'd get a prototype working using something more general purpose first (raspbian, etc.) so that I knew exactly what I needed, and then implement it with the IPE SDK. With regard to updating production systems via a network, it should not be too hard to come up with something custom for exactly that. 

It seems to me that #2 is unlikely if the trigger is you clicking a button. In any case, it is easy to verify if you check memory use (e.g., with ). 

So, there's a bit of work. It requires you understand how networking is configured on the pi, and are able to create a simple server app which fulfils the above requirements. 

My favorite analogies to computer technology are auto mechanics and surgery. I am sure there are many surgeries that are much simpler, require less skill, time, and resources, than many engine repairs, and vice versa. What you are talking about doing it not something you are very likely to set up and have working one weekend. That's not to say given the right luck and instructions it would be impossible, just that it would most likely lead to a lot frustration. There are no doubt true stories of non-medical people taking out their own appendix in the field following the right guide lines. I know a nurse that did it once simply having seen it done enough times. But for every story like this, there could be hundreds that ended in fatalities. Make sense? Something broke on your car and you don't have the money to pay someone to fix it. Maybe you buy some tools and a manual and it is finished in a few hours >_> Or maybe your car is up on blocks for the next three weeks. So you should think very hard about what problem you are trying to solve and whether it is really solvable in the way you think. And a raspberry pi is very unlikely to play the central role in it. 

In order for this new permission to work, you have to log in again. If you use a GUI desktop, just log out and back in. If you are on a console, use until you get back to a login prompt. If you use ssh, just exit and ssh in again (you can also use ) -- but note actually running tshark via ssh on the same interface that ssh is using will produce an endless circle of output. You could also just run tshark as root/sudo, but it will warn you this is a bad idea, which it is. There is a complication on encrypted wifi networks -- you will only be able to read packets involving nodes that connect after you do. So if you want to monitor a WLAN you have control over, you'll have to kick everyone off, shut down the network, start it up again, connect the system with the sniffer and start sniffing, then allow whoever else to connect back on. 

I have not tried it, but there is a package "used to manipulate binary and object files that may have been created on other architectures". It includes an which from the looks of things will replace the existing one. The other files are listed here. So, worth trying: 

Which is more than just changes to -- and note it overwrote that instead of appending whatever was necessary. Appending would override any previous duplicate directives in the file without erasing the rest of your configuration (it might be the other way around, i.e., later directives override, so they should have been appended). A point to take from that is whoever wrote this either didn't know (== did not bother to research) or did not care about doing things in a more responsible way. Also note that is atavistic and no longer used (unless you have not upgraded from Raspbian wheezy). The major problem may have been the overwriting of . 

Price. Here's an example of somewhere you can buy 100 of them @ $5 each. Form factor. You may remember the Raspberry Pi being marketed or tech blogged about as "a credit card sized computer" or "a computer which fits in the palm of your hand", not, "yet another mini-ITX system", or "a computer that will fit under a large hat", etc. Power. Glancing at the first page of the data sheet (accessible through the Microchip link) "implements reduced power operating modes" is mentioned as one of the "Features". You'd have to dig deeper to find out what that really means in comparative terms but, on the surface at least, it makes conceivable sense. 

An ISA is more than just an instruction/address size. ARMv8, aka. aarch64, is not the same as x86-64, which is what the TeamSpeak binaries will be for (tangential to this, the system libraries on almost all Pi distros are 32-bit anyway, with which the Pi 3 is backward compatible, but it means you will not be able to run dynamically linked 64-bit binaries). The fact that it seems to start is simply indicative of the fact that a start-up script is used. I had a peek in the linux download from the page you linked. 

Again, USER_HZ and HZ are probably irrelevant to your purposes. The normative way to time an event is via (or the newer , see below) or , which also has microsecond resolution. It should be pretty accurate; although the latency of system calls on a multitasking OS may be a factor, you should still at least get a precise measurement in milliseconds. Latency for sleep operations is greater, so despite the existence of , don't bother with anything finer than milliseconds and don't expect that to always be bang on either (I believe this is the point where HZ comes into play, as it determines the granularity of the scheduler). You can experiment with this by arranging sleeps and measuring the actual time elapsed. Here's an example using , which uses the nanosecond resolution clock on the pi. Note this may have to be compiled: 

That certainly isn't because of Chrome. If it rebooted once when you opened Chrome, it might be, but it could not cause it to repeat the process unless you opened it again. 

I don't know much about these, but if it works by connecting to large WLANs in urban areas (something tells me that's not actually "most of Norway" although it may be "a lot of places where most people live"), it is going to be a hassle for you to get an external IP that can be reached from outside whatever WLAN the pi is on. If your phone uses a data plan, it will be outside that network. I know that there are "dynamic DNS" services around which manage the IP associated with a domain name dynamically, but for that you'd first need a domain name. I also don't know if they will work with your subscription service. If it doesn't work that way -- i.e., if it actually uses a mobile network like a phone does, things may be a bit easier, but you will still not likely have a stable IP (it will change periodically), meaning you still have an issue with finding an address to reach the pi from outside. One solution to that is, again, a dynamic DNS service. If you have a third server somewhere that does have a stable IP (e.g., a VPS), you could keep that updated with the pi's current IP and check it from the phone, or relay traffic directly to the pi.