First of all, thanks for the feedback. I answer my post myself, because I have to describe my decisions. First of all, here the current code. 

You are running into undefined behavior here, because you are reading from a union property without writing to it first. Unions should not be used to convert types to each other. It is not safe! I am sure, the code doesn't do what you expect. Your code says, you are converting a uint8_t pointer to uint16_t integer. You are not accessing the data, just the address! 

tl;dr Sort the , remove the duplicates and use a binary search instead of your linear approach and you will discover a huge performance benefit. 

Use C++ not C First of all, you are making a lot usage of C, not C++. In C++ you either use the keyword class or struct to declare a class/struct, not together with the keyword typedef. You are using uint32_t a lot. This is also C style, the proper C++ style is the std::unit32_t type. But most of the times you don't really need to specify the width of your integer directly. This only makes sense if you want to serialize/deserialize them. Use new and delete instead of malloc and free. Better: use smartpointers like std::unique_ptr and std::shared_ptr. declare properties private (encapsulate them) The problem here is, you are using public available objects inside of the IMAGE_STRUCT struct, which can be modified from the outside. split-up your functions Your atImageEvent function is huge! Split it up into smaller parts. name conventions There are no explicit name conventions at all, but you should not declare your classes/structs with only capital characters (like IMAGE_STRUCT). Most of the times words with only capital characters are macros. It's not a mistake rather than a bit of taste. if I am not totally wrong names beginning with _ are reserved by the standard and should not be used for custom code. To be honest, I am using them by myself, but I think its worth to mention this. undefined behaviour 

In the end I did not review the correctness of your code, I just stepped over the obviously mistakes you made in your code. 

To bring 's last lines closer in method with the rest of your code, you could do and put another to the right of . (Or , because the repeats everything anyway, but that's kinda incidental.) When you implement a transformation of a simple partial algorithm into a safe one, chances are 's already got something, here . in its prefix form allows me to not close each option with a multi-line closing bracket, and shuddup indentation blocks split code into units just as well as names do, and then you don't need to choose names for everything. Each option even already lists a description of what it does! 

Here's a version of your list of lists version using list comprehension and no !! and no explicit recursion: 

I would separate the looping queue logic from the rest. A general implementation of necessitates a state monad here. 

The explicit recursion in can be averted by using library functions that specialize in particular recursive patterns: 

Edit: Since we've already silently been passing into the last case, we might as well get rid of , which can also be handled silently, for: 

Ignoring what kind of error messages you get, you don't need to handle error cases yourself: (!!) already does that. 

This piece of code is, incidentally, the epitome of order confusion and what wouldn't happen if there was a way to bundle API updates with automatic patchers to old code. 

is just . Aeson provides ways to derive , not sure whether they're applicable. If you're desperate, you can throw TemplateHaskell at the rest and generate the code yourself. 

One property that comes to mind is that applying any permutation before does not change the result. But what is a permutation? I'd say it's a function that doesn't exploit properties of the element type, has a left inverse and preserves the length. (The first ensures that only input elements are used. The second ensures that no elements can be dropped. The third ensures that there is no space for duplicated elements.) 

I don't see the definition for , and your first code paragraph doesn't look like Haskell to me. You have one more place where you could use your . Both uses are for , so you could instead wrap in your name for it which returns a . Assuming a lens into the content field of : (note that ) The source of $URL$ seems to want to give you the attributes in s too. Maybe they have reason for this - should you also retrieve that in ? If so: 

Most of the points are already mentioned by others, thus I will only tell you my opinion about the missing ones. I don't really like your function. You obviously know how to use , why don't you simply use them for your purpose? It all boils down to something like that: 

You make your code more self-descriptive. your Socket class Your class suggests an other meaning, than it provides. It should handle the sending and receiving without the need, to specify the explicit. The user shouldn't be forced to pass the themselves. That's up to the class, to provide the correct socket (at least you are holding a socket as private member). Think about that, perhaps your class has simply the wrong name for its purpose. use instead of heap array You are using a heap array as a read buffer. This yields exception errors, and it isn't totally clear (at least for the user of the Socket class) who is responsible for the cleanup () of this buffer. It is never a good idea, to hand back a pointer, and let the user cleanup the stuff by themselves. Instead, you should simply return a . That's clean, smart and has no hidden traps. If the user decides, he doesn't need the buffer anymore, he can simply let it go out of scope and it will be deleted automatically. The problems are even bigger, when an is thrown by any part of your framework, the users code or any other part of the program. If you want to pass ownership, use the provided classes. For strings it's , for every other point it is or . When you think, "returning a char* has better performance than returning a ", that's not totally true. Most of modern compilers can optimize that. You should google for "" (). In it is guaranteed, but in or it might fail. But even in that cases, a simple move of the happens, which is not as bad as it sounds. 

don't use You should not use because it eliminates some important information, which may lead to some conflicts with your classes or classes of other libraries. It is not uncommon to have a class, which has a totally other meaning than the . And to be honest, it isn't that much more work, to type in front of the classes/functions, is it? use You do everything with for loops, which is bloated and error prone. Use the algorithms of the namespace instead. I provide you with a short an clean example, how you could do the above task (and more) with less lines. your algorithm itself You should think about logical improvements. Is it necessary to store every score in a vector, when equal scores produce the same rankings, and the following scores just increments by one? Therefore I took the algorithm, which returns a . doesn't erase anything itself. It just moves duplicates to the end of the range (our ); you have to them manually. But, before you can use you have to order your elements. I don't know if it's guaranteed to get the score input in a descending order; thus I simply use to ensure this. After that, it's a simple (which is a binary search instead a linear search) to get the first iterator to an element, which is not less than the provided score (ok, I had to pass an other function object, because we want to check for greater and not for less). starts with a zero index. This means, we have to add 1 to our index, to get the official ranking. Easy, huh? 

I would inline, eta-reduce and use more library functions to make the code short enough that adding another command is trivial. Perhaps give the fields names so adding another can't mess up numbering, and you need less comments because the code describes itself. Edit: I'll use non, making the map not add a value for new users until they want to change it. This way we don't need to initialize with on logging in, and we can get rid of the Just returned by the "get" action without needing to promise we already initialized. (Which we don't necessarily have, as the initial ""!) 

In general, I'd go for the second sort of approach. It scales better. I'd eliminate four names and the hack like so, at the cost of and : 

You can make nonpartial by using . Then it turns out that already implements that and calls it . Using it, you can eliminate another case from pull. 

Another thing that comes to mind is that k*k might be faster than k^2 for obvious reasons. looks it up Oh hey maybe you want to look at $URL$ 

The general idea is to use library code, particularly to eliminate explicit recursion, and inline things used only once. abstracts computations that can fail and abort at some point, and allows you to bind into pattern matches that fail the computation if they don't match. abstracts retrying them until they work, using s instance. abstracts computations that carry around a piece of state to read and write to. defeats the need for to manually loop. Contrary to that comment, abstraction is kinda Haskell's thing. 

Try to put configuration-like parameters to the left and data-like parameters to the right, it composes better. condenses much conversion. lets me improvise a query language so I don't need to unpack the tuple everywhere. You already wrote and then you didn't use it. 

The "intermediate array" takes no extra space due to lazy evaluation. is . Yes, swapping the parameters makes sense. Inline and once more. I wouldn't worry so much about constant factors - have you compiled it with -O2 and tested (eg with criterion)? import Data.List (minimumOn) 

It would be nice to get an explanation of what your "needs" are. But either way, here are some recommendations for your coding style and other simple stuff. enums You are using an , but instead of using it as a parameter, you are using ? In the comments above, you are explicit defining the values. That isn't necessary, when you accept a parameter of an type. You should also use the more strict type. This prevents users, to accidentally passing any other values than the types. That means, your enum would look like this: 

I prefer over , because it enables the possibility to create the objects inside the vector in place instead of copying. use the parallel std algorithms In the end you could simply use the std::transform overloading for ExecutionPolicies rather than writing the stuff yourself on the base of threads. Have a look here. 

Be aware of the fact, that you have to take care for the cases, where your vector size isn't a multiplication of thread count. There will be some elements left untouched, but I let this job as a task for you ;) 

As you can see, I renamed my class to SynchronizedValue, because I find it more descriptive than LockedValue. The behaviour of the class stays unchanged, I only did some minor changes and I want to describe why. In every state of this class, only one mutex gets locked. Even in the move parts, I only had to lock one at the same time. This prevents me from getting into a deadlock. The real important part is in the function. In the last state of this class I returned a rvalue reference, which was bad, because when I really started to move the value from other, outside of the function, the mutex already was getting unlocked. This means a race-condition could occur, which is absolutely bad. To fix this, my only change here is to return a real object instead of a rvalue reference. The second important change is no code change at all. It is also closely related to the function. I am talking about the move assignment operator. While I had to check the self assign in the previous version, I can now just take the value and store it safely. The cleanup, which is the bad thing of a self-move, already happened inside of the function. Thus, it should be absolutely safe to deal with the self-moving problem. Why no noexcept The lock functions of a might throw, this means I am not able to make a guarantee for exception safety, unless I would write the whole function inside of a block, which is never a good idea to deal with exceptions. It is not a mistake to declare a move-assign not ; it just makes some optimizations for some classes impossible. why a and copy ctor That's a good question. While I know, that usually a copy ctor is enough, unless you have to modify the original object, it is here required to make the templated ctor possible. If I delete the non-const version of the copy ctor, everything works fine, unless I try to copy from a non-const SynchronizedValue object. A conversion from to is required; and a templated overloading always has a closer match than an overloading which requires a conversation; even when it's just the to a reference. I played a little bit around with SFINAE, but I got no nice solution for that (there might be a solution; but I wasn't able to make it work), thus I used this easy way to deal with this issue. The problem is, I can't SFINAE the copy ctor, this is the wrong way. I have to remove the templated ctor from the match list when I want to copy; and that's the real issue here. The idea, which someone came up with, was to try this one: 

provides a matching instance for , but we want to modify the number of s to one, so we'll need an . Let's submit that. Usually could have done our job, but we don't want to target the arguments of the and constructors. 

fires when returns an empty list; we'd expect to be able to ask that question only once. and do not deserve names - if you want the reader to be able to tell what the value means, comments are more appropriate. Most of the rest of is about descending into a nested data structure and changing a small part, which specializes in: descends into the board, then each of its elements, then each of their cells. gives you, roughly speaking, the positions of the targets in the original board - it separates the board into a and a for each target. lets you forget there was an . 

Calling a monadic action a given number of times doesn't need manual recursion, and thus also doesn't need to give the repeated action a name: 

is from Control.Monad.Random. Stuff that you only ever plan to use once and in one place should usually be inlined. allows us to abstract away the passing around of the blacklist. replaces this recursion. Your into an if is subject to Boolean Blindness and should instead be done via a uniformMay combinator. It's a shame it doesn't exist. Let's make a pull request to MonadRandom and pretend it does. reduces naming further. 

Your example would then look like . By the way, whereever you're using the Eq instance of Tank, consider pattern matching instead. 

Let's use from that comment and inline the once-used (imo if you're only giving a name to explain what something does, use comments) 

Library functions, particularly Maybe's Applicative/Alternative instances, can make your code more consise: 

In fact, we don't need to generate the index and pass it to if all we do with it is put it into later: 

(I don't understand the part of your post that talks about an .) is superfluous, right? No sentence contains anything that has children, right? It appears that to me that