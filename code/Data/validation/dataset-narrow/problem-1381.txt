With all that information you can re-create the physics for a particular character. Sounds like a lot of work, but that's because it is. Good luck! 

Javascript doesn't have access to the filesystem. This is for security purposes. However, HTML5 does allow access to a sandbox filesystem. Cocos2D has an implementation of this sandbox access, but it doesn't appear to be official support. It's not too likely that utilizing this sandbox will be something that's cross platform. In this situation, you'll likely have to create platform specific code. 

Remember the documentation is always an excellent place to start with questions like this, and Stencyl appears to have great documentation. 

Create a grid in code, and overlay the image on it Using the color of your path, assign the grid spaces that match "path color" as walkable. Use A* to find a path from start to finish. 

They should use the same movement component for both, if the movement component is velocity. However, the systems that modify the velocity will be different. The ball will use the physics component to bounce off the paddles and walls, where the paddles will use the mouse/keyboard input component to move. So the physics system will be modifying the movement component of the ball, and the input system will be modifying the movement component of the paddles. The paddles won't use the x-axis for movement, but that's OK. The will both use the movement system. The movement system will take their movement components and update their position components. 

Consider how you can remove ambiguity in your design. A combination of the two choices or the second choice would do that well. For example, you can also send back an enum letting the client know bit more information, something like or . Of course enums would be converted into a byte or two to simplify the data transfer. Simply returning or is ambiguous because it doesn't really give you much information. Returning an enum, along with the updated item information would give you all the information you need. I don't think it's necessary to inform other players who purchased the item, but you could push an update on item availability to other players also viewing the store when an item is purchased. Your untied example is the same as your tied example, it just contains more information (it's trivial to extract true/false from the supplied information). So there aren't edge cases added. 

Yes! Take them out of the race. Enemy vehicles should have all the same penalties as your car. You should be able to side swipe them to make the crash into other cars or trees. 

Where time is the time elapsed since the texture was placed and is stored in milliseconds. This will start fading the texture after 10 seconds (10,000 milliseconds), and fade for 10 seconds until it's completely faded. I'm not sure it's that what you're looking for :/ This page seems like it has good information on texture painting and alpha. And a video here. 

I should also mention that a program like Excel is great for things like this. You can test out formula changes pretty quickly and either graph them or use conditional rules for changing the color of a cell. 

You should be able to get by with a simple collision check before placing the object. The basic steps of which you'll find below: 

Like many things in software, it's a balancing act. Fewer texture swaps is good, but getting textures that are too large can also hurt performance. Additionally, sprite sheets with a large number of sprites can be difficult to manage logistically. To help manage larger sprite sheets, it's recommended that you keep your sprites separate, then join them into a sprite sheet for use in your game. You can use tools (both of which have very clever names) like: 

When I was tracking down graphics performance issues early in the development of my game, I utilized a program called dDEBugger. From their site: 

The answer is: it depends. Unfortunately that's probably the best you're going to get. While a level designer isn't as likely to be using Java (but it's possible), they're commonly going to implement some form of scripting language. Depending on the type of level design you're doing, scripting may be all you do. It's good that you have the skills in art and language, and you may find a job that's all about using only those talents. Wasting your time? No, you're pursuing what you want to do, that's not a waste of time. However, you should continue to pursue your programming. Since, while you may be able to find work only doing the tasks you're good at, it narrows your opportunities quite a bit. Keep at the programming. If a tutor is not helping you understand the basics, then you probably need a new tutor. If you're still struggling there are a lot of programming resources for young children that may be useful for you to crack the barrier that's keeping you from understanding the process. 

can run faster or slower than depending on your settings. That'll depend on load (how fast is running) and speed you have set for (found in Edit->Project Settings->Time). Ideally, since is run once per frame, this is where you want to capture input. If you need to act on input in the method (like controlling physics bodies), set flags in then handle them in : 

Your code appears to work fine, though it's a bit messy. I tested your code and read it, both showed that the sprite continued to move when jumping. I do see that you're setting the scale of the sprite instead of changing the y value when it's jumping. You're changing the X scale at the same time, so this may give the illusion of your sprite not moving forward. Try moving the sprite up instead of changing its scale, or just change the scale in the Y axis. That'll make it easier to see what's happening. Additionally, this cleaned up code is a bit easier to follow: 

As discussed in the comments, it appears that your texture coordinates were mirrored and not your terrain. When building the mesh from your data structure, it's a good idea to build the the texture coordinates at the same time. This makes the code a bit more readable and helps prevent issues like this. 

Yes, you need Unity Pro to do reflections. In this case, the waves are an effect applied to the reflections, not the mesh. So you'll need Pro to do the waves too. 

If this is for a Windows Phone project, you won't have access to that namespace. You'll want to use System.IO.IsolatedStorage for Windows Phone applications. See this tutorial on how to do that. Further, ensure your target framework and the project match. The project and the references need to be the same version. If you're using XNA 4.0, you need to have created an XNA 4.0 project. If the project was created as a 3.1, you can't use the 4.0 references. 

The object you're colliding with does not have the Ladder component. If you try to get a component from an object that doesn't have it, will return null. You should check to make the sure component isn't before doing anything with it, but you should probably make sure the object you're trying to latch on to is a ladder in the first place. You can do that by checking to see if it has the ladder component. Before you call , perform a check similar to: 

But, look at that, it's failing. What could this mean? I would posit a guess that it really wants to be but it turns out that is , so it's failing. Now I've never used Box2D, but I'm guessing that means the body you're trying to destroy is locked. It's locked when it shouldn't be. How can you remedy this? Honestly if you haven't figured it out by now, you may want to take a step back and work on some more basic programming before coming back to this. 

The completeness of the work depends on the publisher, the game, you and the relationship you have with that publisher. Each publisher will have their own standards for what's complete enough. Further, those standards could be tighter or less restrictive depending on the relationship you have with them. If you've never spoken to them, and they don't know you, it's likely you'll need something a bit more complete than if you were taking another game to them after you'd already had one success with them. And it depends on the game. If it's mostly complete, but critical/technically challenging components are missing, that's more risk to the publisher. The genre is also important, if your puzzle game is mostly complete, but adding additional levels is very difficult or has the potential to break other things, that's more risk to the publisher. Additionally, it depends on you and what you've produced before. If you have a portfolio of completed games, the publisher may feel more comfortable accepting something that isn't entirely complete, because they "know you're good for it". This situation is like a job interview. If you can convince them you can do the job, and you'll do it well, they're more likely to hire you. Your job is to convince them that the risk of taking your game is low. You can do that either by proving that the game is complete enough to be of very low risk on its own, or that the work that still needs to be done can be completed easily by you. Your sales skills will come into play here. You need to sell yourself along with the game. If the game is incomplete, this increases the importance of selling yourself. If the game is totally done, this reduces the importance of selling yourself. It's up to you to decide how well you'll sell, and therefore how complete the game needs to be. 

You could try looking though the ludum dare site. Many of those games are basic, work with multiple OSes and are open source. Additionally, it's a regular thing to share what you already have prepared before the competition starts. That's a good place to look for boilerplate code. 

The red lines point from the solid voxels towards the empty voxels. The black lines represent the faces being drawn. The red lines are the surface normals for the solid voxels. 

If it's a good idea or not is up to you. And the success of the strategy depends on what your actual goal is. No Time to Explain did this way back in 2011. They uploaded a special version of the game to Pirate Bay that had all the characters wearing pirate hats. 

Basically you are noting the last time your character shot, then ensuring that enough time has passed before shooting again. As for adding multiple bullets to the array list, it's doing this because you likely can't press the space bar fast enough to only have the space bar pressed for one frame. Each update you're adding one bullet. Add the delay like above will likely solve that problem. If you want to have a longer delay before you start repeating shots, you can doing something like: 

Since TORCS is an open source project, yes, of course it's possible to implement traffic. You can implement anything you like by changing the code entirely. If it's reasonable or not is another question entirely. And, it's one only you have the best answer for. It sounds like your project is more research oriented. And thus, doesn't need to have fancy graphics like a racing simulator provides (yes TORCS does more, I'm speaking more about other simulators). Ideally, if you want something that's more deterministic, you'd have your simulation able to run without any interface whatsoever. If you'd like to have an interface, it can be a very simple one. As simple as having each car represented by a single pixel. Get your part of the simulation working before worrying about how pretty it looks. It's certainly worth looking further into TORCS to see how difficult it would be to modify for this purpose, to give you more robust simulations, but you might want to get something simple working first. 

Your ideas are good, but I think with a little bit of math and empirical testing, you can figure out how to make these levels dynamically. You have a few factors that effect the placement of the blocks: 

Try setting your textures to clamp to the size of your quad and ensure that you're not setting the textures to linear interpolation. When initializing your OpenGL code, do something like this: 

Contact Apple tech support. Submit a TSI and request that they terminate the active games. Additionally you can see if your question has been answered already, or ask your question on the Apple developer forums. 

You can't make your enum anything other than public if you want to be public too. See Restrictions on Using Accessibility Levels (C# Reference). If you don't want to use an enum, and just want a selection in the inspector, you can use a property drawer to show a selection of strings in the inspector. 

In addition, the page the link resides on contains numerous other lists of words that are free to use. EDIT You found in your update, what I'd already said in my answer. Additionally, the SE link you've posted has plenty of alternative answers. For example: The English Open Word List, has more words that the OSPD and it's restriction free. Beyond that, the Enable list, as I said in my answer, seems to be a very good choice and is in the public domain. 

This is where I will use a 3D painting program. I primarily use Blender for my modeling, and it has a 3D painter built in. Being able to paint directly on the model in a 3D environment, makes the strokes continue across seams. I don't find the paint tools in Blender to be great, so I'll usually switch to something like GIMP once I've got a rough idea. Then I add details in GIMP. Though, your 3D paint program may be different. The program you use will depend on your work flow, but here's a tutorial (and another) for using Blender's 3D painting capability. 

This can easily be done just with the bounds of the screen and the position of the sprite. The screen bounds can be stored in two variables, and , where contains the minimum X position of the screen and the minimum Y position of the screen, does likewise with the maximums. 

I haven't tested it, but I would likely implement something where any attempts to change the text simply don't change the text. For example, there's an event for the . Attaching to this event and simply setting the text to its initial value will revert any changes made by the user. This simple script achieves the desired effect: