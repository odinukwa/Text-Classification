I'll give an intuitive idea of the reason in this answer. Once this intuitive idea is grasped, it can be easier to absorb the mathematical descriptions. Other people find it easier the other way around, so look at all the answers and see which approach works for you personally. 

Note that the approach you appear to be taking will only work for lines with a slope in a single octant. For the other seven octants the algorithm requires changing the approach, for example by changing the roles of x and y. Wikipedia gives a table of cases that can be used for this conversion. For this answer I will assume you are simply trying to get the code working for the first octant. 

A straight line through colour space Looking at the code, it appears you first convert from RGB to HSB then create a linear gradient, and convert it back to RGB. A linear gradient is a straight line through the colour space, so you can use an integer based straight line algorithm to generate it without the need for floating point arithmetic. For example, the integer based version of Bresenham's algorithm. H, S, and B are being treated independently, so you can calculate each one separately. For example, the H component can be calculated by treating the line as a straight line from (x0, H0) to (x1, H1), instead of the usual (x0, y0) to (x1, y1). If the range of y values along the line is greater than the range of x values along the line then Bresenham's algorithm will step along integer y values instead of x values. The algorithm can still be applied in exactly the same way, just using (y0, H0) to (y1, H1). You can also combine all 4 calculations into a single loop, keeping track of a parameter each for determining y value, H value, S value and B value. The only difference from plotting a line on the screen (using x and y) is that not every value of H, S, and B needs to be taken. If the x range is greater than the y range, the algorithm steps through each of the x values checking whether to increment y. If the y range is greater then it instead steps through the values of y checking whether to increment x. However, if the range of H is greater than the range of x, it makes no sense to step through H values, as many of them will correspond to the same x value, wasting calculations. If the range of H is smaller than the range of x then the algorithm can proceed as usual. If the range of H is often going to be larger than the range of x then it is worth considering a different approach. Similarly for S and B. Fitting the colour space to your line One way to eliminate this problem is to tailor your colour space to the x (or y if greater) range required for this specific line. Since your input colours and final output colours are in RGB, you are not constrained to a particular range for the HSB colours. You are free to convert from 256 levels of R, G, and B to 1000 levels of H, S, and B (or 1000000, or whatever you choose). If you choose to use a colour space where the range of H values used is the same integer as the range of x values used, then you won't even need to use a line drawing algorithm for the colours. Simply store the required values for converting back to RGB, and each of the H, S, and B values will be x plus a constant. This will require modifying your conversion function, but this will probably be necessary anyway, as it currently uses radians, which are not going to help with keeping things integer. More accurate colour spaces Note that using a colour space like HSB will not give gradients which look as even as if using a more perceptually uniform color space such as Lab. However, since such spaces require calculating roots and you are looking to keep to integer arithmetic as much as possible, I'm assuming you are happy with HSB. If you did want to use something like Lab, you could still potentially keep to integers by using look up tables. What inputs does this need to work for? You also mention having to make decisions in the code which also takes up time. I would question how much difference this makes since the decisions are outside the loops and therefore only performed once. If you really want to eliminate them, ask yourself which inputs the code needs to work for. Currently the code checks the start and end values of the hue and decides whether to change the hue clockwise or anticlockwise. If you eliminate this check the code will still work, but it may not always give the colour direction the user intended. Deciding this automatically also may not give the direction the user intended (since different users have different expectations, and the requirement may change from one use to the next). You could simply take the direction as an additional parameter, which would avoid having to make the decision. Code review Meaningful variable names The use of "hue" in the naming of variables that store all three of hue, saturation and brightness makes the code less intuitive to read, potentially causing the reader to wonder whether saturation and brightness have been overlooked. It also makes the code difficult to reason about, since is a hue, while is a saturation, which is not only not a hue, but also presumably not in radians. In addition to making the code more accessible to others, you may also find it easier to work with it yourself if the naming is consistent, especially if you look back at the code after a few months. A potential bug If one end of the colour gradient is at hue zero (red), the code checks whether the other end is greater than or equal to two thirds of the way around the hue circle. This corresponds to blue. If it is less than blue, then the gradient proceeds from zero upwards (anticlockwise), otherwise it proceeds from 2 pi downwards (clockwise). This means that a gradient from red to a colour with hue just above blue will go from red to magenta to blue. A gradient from red to a colour with hue just below blue will go from red to yellow to green to cyan to blue, which may not be what is expected. Intuitively, I would expect the cut off to be half way around the circle rather than two thirds, so that the gradient always includes the fewest colours (taking the shorter, more direct route). If you did intend to have this asymmetry, note that choosing a similar red with hue just above or just below zero will override this behaviour, forcing the long route or the short route respectively. If you want the gradient to consistently take the shorter route, then the code will need to check which route to take for all values, not just zero. For example, currently choosing the start hue just above zero and the finish hue just below zero will give start and finish colours that both look red, but the gradient will pass through red, yellow, green, cyan, blue, magenta and back to red, rather than just fading subtly from one hue of red to another. 

This is a recursive function (it calls itself). Each time it calls itself it does so with instead of . When it is called with , it simply returns rather than call itself again. This ensures that the function will eventually stop recursing and return a value. It is the colour equivalent of returning zero. You can visualise this as a light ray reflecting from multiple surfaces successively. Each time the ray reflects from a surface the same function is used to calculate the colour of the light in that direction. If you set to 0, there will be no reflections in your resulting image. If you set to 2, there will be reflections of reflections which will look more realistic, but take longer to calculate. Intuitively, MAX is the number of surfaces the ray will bounce off before it is decided what colour should be displayed. 

While this makes the format very easy to work with for small examples, it will also make the file size much larger than other formats which use bytes to represent colour components instead of writing out the human readable numbers. Many formats also include compression (either lossless or lossy). Once you are accustomed to writing PPM files in ASCII characters, indicated by the file starting with "P3", you can move on to PPM files using bytes, indicated by the file starting with "P6". This is a similar format to what many programs use internally, but is no longer human readable in a text editor as not every byte will correspond to a printable ASCII character. 

Note that as Nero points out, the functions are using only s (integer variables and return values). The distance between a point and the origin is not in general an integer value, even if the coordinates of the point are all integers. The distance squared returned by will be accurate, but the distance itself returned by will be accurate only to the nearest integer. 

Quick answers to your individual questions What do you do if your image is not the same size on each axis though? The paper uses square images with side lengths that are a power of 2. This is for ease of explanation, but is not necessary for the algorithm to work. See section 3.1: 

As you are taking the mean of a number of sine waves, your colour values will range from -1 to 1. From your example image, it looks like only the top half of this range of values (from 0 to 1) is resulting in colour, with everywhere else remaining black. If whatever you are using to display the result can only handle positive values, then you will need to convert the result to the correct range of values. For example, to convert from the range [-1 to 1] into the range [0 to 1], you would add 1 and divide by 2. In the context of your example code, this could be by following the line 

Forking defeats Russian Roulette A key difference between path tracing and ray tracing is that unlike ray tracing, which can have a branching tree of rays splitting at each intersection, path tracing follows a single path with no recursive branching. Russian Roulette requires that only one recursive function call be made each time through the function. However, the code currently branches at each function call, so each call triggers several more calls. This prevents the roulette process from killing the recursion. New recursive function calls are being introduced faster than they can be killed off. The problem is similar to a fork bomb, growing exponentially, so that the killing cannot keep up. The clue that led me to look for this problem was that you said that it works fine when the number of Monte Carlo samples is set to 1. In this case the function is only called once each time, so the recursion can only maintain the same number of rays, not introduce new ones. So there is no forking and when the recursion is killed that is the end of it. If you want more than one Monte Carlo sample per pixel, you will need to move that loop out of the recursive function so that the number of samples does not grow. Pseudocode examples Approach 1 

As joojaa points out, there isn't an easy way to describe a prism (including a cube) in just a single parametrisation. You will need to describe each face with a separate set of parametric equations. For example, using parameters u and v, you could describe one of the faces as follows. $$ x=u \\ y=v \\ z=1 \\ 0 \leq u \leq 1 \\ 0 \leq v \leq 1 $$ 

The missing step If you already understand how to generate a secondary ray, then you have already grasped the difficult part. All you need to do now is find the colour that this secondary ray results in. This is exactly the same process as using the primary ray to find a colour, in basic ray tracing. After repeating this for a large number of secondary rays, the average of all those colours is the colour you assign to the pixel in question (you don't use the primary ray - its only purpose is generating the secondary rays). This is the only difference from basic ray tracing. Why it works My personal difficulty when trying to understand this was that I was trying to understand how the light gets from the different points on the lens back to the eye/camera. The thing to understand is that this is only an approximation of a lens, and the rays don't need to consider the eye/camera at all. The lens is being approximated by a disc. All these different secondary rays show you what you would see from different points on that disc, if you looked directly towards a certain point (the focal point). 

That is, this assumption is not required in order for the algorithm to work. Is it possible to run JFA on each axis separately and still get decent results? Running on each axis separately is likely to give more incorrect pixel results, and take longer to run in most cases. In extreme cases where one of the image side lengths is less than 8 (the number of jump directions), it may be faster as the algorithm treats those 8 directions sequentially, but for any wider image, separating the axes loses the advantage of treating them in parallel. In my situation ideally I'm looking to support both single point seeds, as well as arbitrary shaped seeds The paper mentions arbitrary shaped seeds in section 6 under the subheading "Generalized Voronoi Diagram": 

If a playing card exactly fills the near plane, then you will be able to fit 4 playing cards on the far plane. This reflects the fact that when a playing card is twice as far from the camera, it appears to have half the height and width. Think of the near plane and the far plane as simply the area that will fit on your screen. The further away you point your camera, the more will fit on the screen. This matches up with the fact that things look smaller in the distance - this means you can fit bigger things on the screen if they are further away. 

Clipping a convex polygon Think about how many times the polygon can cross each edge of the rectangle. In general, a polygon can cross one of the edges of the rectangle an arbitrarily large number of times. How is this number reduced if the polygon is convex? This will give you the maximal number of new angles that can be added per rectangle edge, which should lead you to the answer. Clipping a non-convex polygon As for your guess of 2n, even for a non-convex polygon it may not be able to reach this high. If one vertex is outside the rectangle, then in order to create 2 new vertices both of its neighbouring vertices must be inside the rectangle. This means you cannot create 2n new vertices this way. The exception is when an edge of the polygon crosses 2 edges of the rectangle, for example at a corner of the rectangle. This allows creating two new vertices from a single edge. So for small enough n, it is possible to clip to a polygon with 2n vertices, but for larger n this is not possible.