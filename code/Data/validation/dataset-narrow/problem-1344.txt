Specializations: "professional software developers looking for great places to work" (developers who browse Stack Overflow) I have no experiences using it, sorry. 

Just because your question doesn't really belong here, doesn't mean I won't try to give you an answer! :) If you are set on hacking this thing and adding a battery, that's fine. But might I suggest obtaining an alternative instead? The everything2 post on SNES Backup Units lists several others, some of which do retain their memory through a poweroff: 

I like RuneScape's method (at least, the old method back when the wilderness was PvP). Most of the game world is only PvE, but up north there is a huge desolate area called the Wilderness; it's PvP. When you first cross the clearly-marked border into the wilderness, you see an icon in the corner of your screen and it reads "Level: 1". So you're in level 1 wilderness; you can attack people +/- 1 combat level from yours (combat level being your character's overall level, determined by a formula from your more specific combat-related skills). As you keep walking further north, deeper into the wilderness, the level keeps incrementing, and at any place in the wilderness you can attack other players who are +/- the wilderness level from your combat level. This introduces some interesting dynamics. First, a lot of wimpy people sat at the border of the wilderness, hoping to find other people that were just +/- 1 or 2 levels and then attacking and stunning them (so they can't move). Second, you have something of an incline; someone who is not so brave can stay in the lower levels of the wilderness and try to find people near their level. There were some good resources near the back of the wilderness (around level-40 wilderness); some rare mining rocks and high-level monsters for training. But of course, by going that far, you are risking that someone 40 levels higher than you can come and beat you down in a few hits. And of course, when someone does attack you, you can try to run south and retreat to a level of wilderness that is outside the "range" of your attacker's combat level. Nowadays, they switched it so that the wilderness is also PvE, but there are dedicated PvP servers in which the entire world is PvP. The only danger in the wilderness now are ghosts which are supposed to imitate the old PKers (player killers), but most players agree that the ghosts are much more powerful and have much worse rewards than PKers, so many people were upset by the change. I think this level system would work well in an all-PvP game, if the "wilderness level" was implemented as the distance from the nearest city's borders. So the no-man's land between cities is PvP, but cities are safe zones except for structured, agreed-upon duels in the streets. Then you can also introduce some cash sinks, by having transportation NPCs which will take you from one city to another for a price (for those players that wish to avoid PvP entirely). There should also be plenty of training zones where players can fight NPCs without the danger of PvP, again for those who don't want to participate in PvP. But really, at some point you must draw the line between players who never PvP (like myself) and players who only find fun out of PvP. 

The main reason Direct3D10 Map methods were moved to Direct3D11 DeviceContext is to support multithreading. They were previously attached to each resource (thus implicitly, a single device), but with Direct3D11, It is now possible to update the same resource from different deffered context. Concerning your issue with MapSubresource, you need to check this documentation on Resource Usage. You will see that it is not possible to use Map method with Usage.Default, as it is only working with dynamic texture. Usage.Default is suitable if you are only using UpdateSubresource. The correct way to use Map is to declare the texture with Usage.Dynamic and Map with WriteDiscard. It is not possible to keep the content of the dynamic texture (update partially) as a race condition between the GPU and CPU would arise. 

If your is pointing to the same texture, you should have the same performance, but if not, then you are just hitting a design restriction of SpriteBatch. Most implems of SpriteBatch I'm aware of (at least, XNA, SharpDX, Paradox, DirectXTk... though, don't know for sure about MonoGame...) are trying to batch draws with the same consecutive texture (see for example here, DirectXtk the C++ equivalent of SpriteBatch is assuming the same here - look at method ). If you switch between textures, the code path is much slower so this is not recommended to use SpriteBatch in this way. As suggested by @Shiro, SpriteBatch is usually more efficient if you have packed all your sprites in a sprite sheet and use this same texture in your whole batch between Begin/End. 

Yes, this behavior changed from DX9 to DX10+, don't know much about the real story behind it, but I suspect that DX9 had to remap registers between VS and PS at runtime anyway (when linking shaders) which is inefficient. In DX10+, when you compile a VertexShader and a PixelShader, you can see which register will be affected to a particular semantic (see output of fx.exe compiler), and these registers (which will almost map to an hardware register) should match between the output of a stage to the input of the next stage. Note that the input of a stage could have less semantics mapped, as long as the order is the same and there is no gap in the mapping. If you are using some legacy FX file (techniques/passes) with DX10+, the compiler will check input/output signatures for you. But if you are compiling separately VS and PS, you will have to double check any signature mismatch (or you can use D3DCompiler API to verify this yourself). There is one exception for the input of the VertexShader that is coming from the VertexBuffer and the InputLayout. The InputLayout is able to specify the byte offsets of each vertex elements and how it maps to the semantic in the VS shader, so you can have a "sparsed" mapping, the input layout can have more vertex elements/semantic bindings than the VS input, as long as all semantics from the VS are covered by the InputLayout declaration. This is handy when you have a model that has several vertex elements, and want to use the same vertex buffers for several vertex shaders that are expecting different input layouts: you can map the layout of the vertex buffer to the layout of the vertex shaders (as long as the mapping is covering all the input of the VS shader). 

I'm a college student, and I have a really boring class every Tuesday that's 2 hours and 45 minutes long. It's an interesting situation... attendance is required and checked, and electronic devices aren't allowed, but discussion isn't required and the lectures don't really matter to the exams. So I sit there in the back of the room either dozing off, doing Sudoku, doodling on my paper, pen-spinning, or trying to secretly use my phone without getting caught. I find myself wishing I could use the time productively. Just like when one sits down with paper and crayons and can't think of anything to draw, I find myself wanting to do something to further my game development skills (e.g. work on the design of a game) but as I sit there with a pen and paper and the professor droning on, nothing comes to mind. Help me get through this tedious class! What are some things I could think through or work on, or how can I figure out things to think/work on? Or even things I could print out in advance and read or solve during class. Remember the constraint is that I have no access to technology... And I'm not sure a book would be appropriate. Though now that I think of it, I should probably just read game dev books from the library. Why didn't I think of that before? Anyway I still want to hear suggestions! What would you do with this time, if you were in this situation? 

The big problem is that many people don't enjoy programming enough to warrant learning to use DirectX or OpenGL. Also you shouldn't (always) reinvent the wheel; even when using something like Ogre3D, you're a long way from having the basics of Unity implemented. It's easier to start with Unity and introduce them to Unity scripting, and they will have more fun with it. I am of the opinion that something like Unity or Game Maker should be taught first. Game programming is basically segregated into several sub-categories: game scripting (possibly including AI scripting), engine programming, tools programming. The easiest and most fun of these is game scripting, which would be what you do in Unity, Game Maker, etc. You are obviously more interested in engine programming (or just low-level game development, whatever category that fits in - all of them?) but I don't believe that's the universal way to teach game programming. So to directly answer your question, teach game programming by starting with game scripting in an existing engine and toolkit such as Unity, because this will appeal to the most people. Those that want to dive deeper (lower-level) can then be introduced to DirectX/OpenGL/Ogre3D. 

Using this format when declaring a depth stencil buffer, you should be able to copy the depth buffer to another R16_FLOAT/R32_FLOAT...etc. texture. On a side note, it is often not recommended to read back data on the CPU because of the latency that will be introduced. Current techniques - on Windows Direct3D11 - tend to perform typical CPU computation on the GPU with DirectCompute. 

If you are creating a Texture2D with an initial DataRectangle, the Pitch must be set to the number of bytes per row and is theoretically equal to TextureWidth * SharpDX.DXGI.FormatHelper.SizeOfInBytes(Format.XXX), unless you are laying out your data differently in memory. If your are using DeviceContext.MapSubresource, you can't determine in advance what would be the stride and you need to use the Pitch returned by the DataBox.RowPitch. The stride could be hardware dependent, depending on the layout on the GPU memory. 

Use Device.UpdateSubresource (requires texture to be declared with Usage.Default) or Map/UnMap (requires texture to be declared Usage.Dynamic).In the case of the swapchain, I guess that only UpdateSubresource will work. Keep in mind that you are refering to the low level Direct3D11 API in SharpDX, so there can't be any high level methods like "SetData". If you want to have XNA equivalent API, you have to use the Toolkit which is available from the 2.5 dev package. If you want to stick with plain Direct3D11, you will have to dig into all the details about how Direct3D11 is working. 

Not exactly: texture arrays are declared in HLSL as for Texture2D and not as an array of texture, so it is quite different. They are almost acting as a 3D texture, where the z is a slice of the 2D Texture (in terms of uv, it is the w dimension). The difference with 3D texture is that they are not supporting trilinear interpolation between the 2D slices but you can still select dynamically a Texture2D slice with a z/w component (unlike an array of texture), the z/w component is rounded to the nearest integer to select the z/w slice. Concerning the memory, I believe this is equivalent, for performance, not sure they give a huge boost even accessing a set of Texture2D compare to an array of texture (but they support dynamic indexing). Using is also easier as you only need to bind it to a single slot. 

If the output bitmap matches the look of the font (the typeface) then it essentially IS the font, and yes you would be violating the license. 

Ludum Dare 18 is coming up and I'll be participating in it. I've done a couple other short-term game competitions in the past but this is my first big one (and my first solo one). I am REALLY excited for it, but I'm wondering if there are any tricks to preparing for this sort of thing, and any advice on what to do while in the competition. So... How do you best prepare for, or participate in, a short-term game competition? Your answer can be specific to Ludum Dare but I'm really talking about any game competition, as long as it's short-term -- not the month-long ones where you casually develop your game and release it; I'm talking high-pressure, finish-in-time, pull-an-all-nighter type competitions. The Global Game Jam fits here as well, if you participated in that earlier this year. Also any tips in the context of a group of people (each working on their own solo game) would be great; I will be with the game development club at my school for most of the 48 hours (only a few other people, not a huge group). 

This is entirely a matter of preference. However, I personally believe it is best to err on the side of more files. Java requires one class per file, with the filename the same as the class name, for example; they do this by policy to enforce this good practice (though you can have subclasses which basically get around this). Also, source control systems are pretty good at merging changes in a file, but it's less of a hassle if you're just working in totally separate files. You can also easier see who changed which class. Let's say another developer makes a change to the file AllEntities.h; you have no clue exactly what entity (or entities) he changed until you open the file and look at the diff output. It's great to group small structs and enums related to class within one class's file, though. If you have an enum that's only used by a single class, why split it into its own file? Just put them together. But if it's used by another class (i.e. another class member is of this enum's type), that's when it is time to give it its own file.