is legal because both 's are in different scopes. This scoping issue is why we have the statement above wrapped in extra 's, since the belongs in that scope. loops can omit parts Might seem weird at first glance, but 

Follow the rabbit hole down as far as you can go without losing sight of the light of day. Understand where you've ended up, and build a solid foundation there. Build back up 'til you're out of the rabbit hole, standing on more solid ground. Rinse and repeat, iteratively falling down further and building back up more. The more you do this, the greater your understanding grows. 

The peaks look more pronounced for women; presumably if we had a graph of just men, we'd see their enrollment had a milder response. I'd speculate that this implies that women cared more about the optimism/pessimism about Computer Science happening at the time than men did. This is, optimism had a stronger pull to get women in, then pessimism also pushed them out harder. This push/pull effect can be seen in the relative CS degree obtainment plot: 

I am mostly in agreement with @kevinWorkman on this (I don't disagree with anything, there is just one thing he was silent on, that I think is very important). 

The ideas in your question are far too difficult, for a one hour introduction. Yesterday I had a look at Haskell and learnt some. I have over 30 years programming experience (20 years professional). Have experience with functional programming. Yet it took me several hours, and did not get far enough to be able to do your suggestions. Mathematics You say that your students have a maths background. Take advantage of this. Choose some math problems. That Haskell is ideally suited to solve. And explain why you are doing this. Ensure that you have more than you think you will need, as some students will be much faster than you expect, but don't expect to use them all. There are some good ideas here $URL$ also some of the other answers, to the same question: sort, search, interpreter (this one may take too long), factorial. Avoid bad examples Don't do problems that are more difficult in a functional language than in a procedural one (Reversing a list, using procedural techniques, in $O(n)$, is easy. If by using functional they will probably get a $O(n^2)$ solution, and $O(n)$ is hard, then you are teaching a disadvantage on day one.) Fibonacci is, I think $O(2^n)$, for simple recursive implementations. 

The first peak, around 1985, is before my time. However it's my impression that there was a major loss of momentum around those years. The term "AI winter" was coined in 1984, suggesting that pessimism was prevalent enough to assign it a name in discussion. Presumably this pessimism dissuaded incoming college students from selecting CS, causing the drop a few years later when they graduated. That second peak looks like it's centered around 2004/2005, suggesting that students were really optimistic about Computer Science around 2000/2001. And those years were the peak of the dot-com bubble, which started its clear burst in late-2000. It seems probable that the dot-com bubble bursting dissuaded incoming students from going into CS then, too. Females in specific also followed this trend, and had the same peaks: 

tl;dr- That peak around 1986 looks pretty difficult to explain in terms of interest. After searching a bit, I found a paper that attempts to explain it in terms of teaching capacity. This paper argues that the rapid rise in student interest in the early 1980's flooded Computer Science departments, forcing them to raise entrance standards to avoid being overwhelmed. I'm not 100% sure if this line of reasoning is entirely solid, but presenting it here as a partial answer. If nothing else, the idea that departments had logistical troubles accommodating a rapid rise in CS students seems to make sense as a contributing factor. 

How to teach students, how to ask for help. I think the question is the same as “How do I teach students, how to ask for help?”. I would get them to practice in class, with pen and paper. Some exercises could include: Practice answering Teacher collects some good questions from SO, that are relevant to what pupils have been learning, and prints them out, without answers. To explain in own words what the question is asking. Ask pupils to produce good answers to the questions. Peer review answers, produce a 2nd draft. etc. Judge questions Teacher collects some good and bad questions from SO. Students have go group into good and bad. Students have to explain what is wrong. etc. Create questions Students are given a task that they can not do, and have to produce a question so that they can learn how to complete the task. Optionally the class can be split into 2 each half learns a different thing, then get a task that only the other half can do. Tips for writing questions Be clear, proof read (if you can not be bothered to read it, then how can you expect any one else to). Remember context. People can not read minds over the internet. The person reading your question is probably not in your class. They have no idea what it is that you are trying to do. 

Avoid relying on third-party solutions whenever you can't easily-and-reliably convert away from them at any time without losing the prior content. 

is actually perfectly legal code! Since it omits a condition and doesn't do anything, it's basically an infinite loop that runs forever without doing anything. In C#, it doesn't consume CPU time, but it also blocks the thread from progressing. For example, 

Absorb non-electronic notes If you do have non-electronic note materials; e.g., hand-written notes, images, lab book notes, or handouts from a class; if they're potentially important, try to get them on the computer. Scanning them or snapping a picture with your phone can be better-than-nothing. Optical character recognition (OCR) can help make some hand-written notes into electronic copies. It's not particularly reliable or stress-free just yet, but as long as you have something for future OCR to work on, it remains an increasingly useful tool. 

Optimal note-taking depends on the goal. For example, if all you want is to pass a quiz next week, then a quick, flimsy style's more appropriate. Here, I'll write about taking notes that a life-long learner intends to keep-and-extend into life as a researcher. Always typed; never written Electronic notes are vastly superior to hand-written notes because: 

When teaching I often have pupils struggle in the first few minutes. When they are setting the computer up, ready to start work. They often have to follow lengthy instructions, that I print on paper, of mostly screen snips (So this also takes a long time to prepare). What can I do to make this easier for pupils? For example I have had a lesson where I have had detailed instructions on setting up Python/Idle: Starting the editor, finding starter code, they contain many screen shots. This took me a long time to prepare, and is not easy for the pupils. They are not productive at the start of the lesson, and get demotivated. They need to get to: 

In like languages (C, C++, Java, C#, …), always use in the form (there may be some exceptions, but rare). So you are using to construct a foreach, as the language does not have the higher level structure. (C# has ; C++ has library implementations; Java has foreach, but uses keyword ) 

From a systems approach, capacity issues do make some sense for explaining a peak like the one here. The rapid inflow of students could be allowed since they were filling available capacity; then, once that capacity was taxed and admissions was allowing too many students into the classroom, they'd have had to cut back on allowing new students in. Helps explain the difference in interest-vs.-achievement The mid-1980's peak is the basically one place where Freshman interest is higher than degree completion. 

Date everything Everything should be dated; ideally, you'd prefix all filenames with a time stamp of when they were created (originally - not just when the actual file was transferred/copied/downloaded/etc.). As always, use ISO 8601 for time stamps and other dates. 

They never are. Whenever you read a textbook - even the best-known ones in well-developed fields, e.g. introductory Calculus - never just trust it. Put each word on trial, and absorb only the ones that you can't tear down. You often need to memorize large amounts of content without first thoroughly scrutinizing it. All of this content should carry a red flag in your head that labels it as unscrutinized claims. If there should come a time where you really need that information, or want to build upon it, you should really scrutinize it first. 

As a step toward learning binary or hexadecimal. Show that we use many number bases everyday: base 24 and 60 in a clock; base 7 and base 30ish in a calender; base 16 and 14 in weights (in US); base 12 and 3 in distance (US); etc. Then introduce octal. Octal has an advantage that it is not too different to Denary (Decimal), and that it dose not introduce new symbols (like hexadecimal). After octal, head toward binary, maybe brefly explore the idea of other bases, and ask how low can we go? Binary is the limit. Then binary to octal, but look at how this does not fit will in to 8 bit bytes. What can we do about this. Base 4 or base 16. Base 4 does not help us much, but is used by DNA. Base 16 helps us reduce number of digits, but we need 6 more symbols (a-f). 

That is, in pursuit of the items on the left we have found the items on the right to be indispensable. 

Try to keep the formatting future-proof You want your notes to endure, so avoid systems that might break in a few years as best you can. Sometimes document formats like PDF make sense despite being proprietary, though it's best to avoid relying on them as much as possible. Tips: 

Seems like a developing field is a discussion that a community of researchers engages in. To participate, you'd need to: 

Once you have some basis for understanding the discussion, then you focus on getting your own ideas straight. In the end, it's really all about you; sharing research results really isn't a goal so much as a duty to be performed when/if you become the foremost authority on some particular understanding. If you're a younger student, you've probably got a lot to learn and develop before you can really enter that arena. But, if you're interested in it anyway, it seems like you could do two things: 

As shown, women chose CS relatively more often until the peaks, then relatively chose other majors after the peaks. Not a bad thing So women like being medical professionals more than programmers - awesome! As long as people are freely choosing what they want to do, then that's exactly what we should be striving for. 

I often see people mixing up files and filename in variable naming. It will result in mixed up thinking. I think it is important to come up with clear names. I like to start with giving them lots of code. They then read the code, analyse, modify. In my code I use clear names. We discuss naming, and how this affects readability. Also to discuss with class: I have included some questions about some statement. Use your discretion as when to ask them. I am not suggesting you ask them in a sequence as presented. When you call a subroutine it takes a thing or a name of a thing. e.g. takes a string [or the name of a string]. Is `/dev/null' a string? Why is it not a string? Is it the name of a string? Why is it not the name of a string? When you define a subroutine it takes a name of a thing. Why does it not take a thing, why only a name of a thing? Is that a name of a thing?