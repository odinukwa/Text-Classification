What is the point of ? According to Java naming conventions, your use of camel cases is inverted. Variable and method names should start with a lower case, and classes (e.g. ) should start with an upper case. The for can be replaced by one line for brevity, although there are still a couple more ways to optimize this part: 

I think it may be better to do a check before you construct your array. Also, I am using the utility class instead of to copy part of the array. Extracting the from a MIME message You can make use of for both your and instances, and I suppose this is where we can employ a bit of Stream trickery... 

You should also think about edge cases, like how to reject (e.g. a new value like for ?). One nice thing about this approach is that it's quite easy to generate the lookup using the new stream-based processing: 

Streams are a little harder to understand, but I don't think that means the effort shouldn't be put in ;). There is a slightly shorter, and therefore maybe easier to understand, solution that relies on Java 8's new method to do the entry value comparison for us too. 

There is no way around it, but is too lengthy... you should consider breaking it down. For example, you can consolidate your UI elements in the following manner: 

Can simplified to just . Also, (and this leads to the next section), you need to be more careful about how you apply negation via your , e.g. when you values, you are -ing both and also values. and While your and is a step in the right direction, you should attempt to model it as a for an . Then, you should consider adding some helper methods on your to nicely parse the values to the required types, e.g. in most cases. So, assuming you end up with an similar to the following interface: 

edit: As you have rightly pointed out/discovered, is not a generified (?) class, so the closest approximation (in terms of reading code) is to use checks and then call the appropriate constructor. Some people frown on it, but the option exists... 

This is ripe for SQL injection attacks, so let the underlying database driver handle parameters for you directly! Furthermore, comparing your and statements, it looks like the positioning of your prepared statement is different from the actual table schema returned by . This makes the code look slightly confusing initially: the user type is ed via but stored as . Standardization will help eliminate these kinds of false bugs. This has a decent example of using with a query. Reduce your scope Somewhat related to the next point, but having a shorter scope makes it clearer what methods can throw what kinds of checked s, which will facilitate understanding. Not recommended (roughly putting it in your context): 

The -loop is slightly unconventional in the sense that it terminates when during the loop. A terminal condition doesn't work as cleanly here, as far as I know, since will either keep getting smaller or larger than . That is why the 'middle' part reads . We then either increment or decrement based on the condition . Finally, we remove the last tab character with a call. Java 8 features ahead... Going above and beyond the question, if you can also consider using Java 8's and a ... 

Hmms... why do you need this and the complicated statement? It will be much shorter, and likely more efficient if you simply have this: 

edit: I just realized there is no type declaration for ... does that mean it is actually a class variable? If so, I will suggest scoping it down to within the method (or within the block, even), as I don't think there is a need for each object to be referenced outside of the method it is created. edit #2: Looking at these two lines: 

Copying collections and checking for emptiness An alternative - and often recommended - way of copying a collection (props for doing that!) is to use the constructor, if available. 

The other thing I want to highlight is that your seems to be over-engineered. You use an to identify the different arithmetic expressions, which is nice and fine, but they are only used in a statement, with the actual calculations done in methods, which are themselves called through methods with the relevant value... That just sounds like too many steps to perform a calculation. It might be easier if your can aid in doing the calculations too, e.g. knows how to add two values together to return a value. In Java 8, that would be an implementation of either (using the wrapper) or (using the primitive). In that case, you wouldn't require the methods in . One small note for : 

Please be consistent. :) Java 8? If you happen to be on Java 8, some of your -loops can be simplified using the -based processing, or even to use the new method. For example, in : 

Rationale: Consider when you have \$n\$ products and a result for each of them. Your current solution will effectively be iterating through them, and iterate through the \$n\$ results for the one matching product. Therefore, you should start with grouping your results first by the product ID, so that the retrieval later via the interface will potentially be more efficient. Process the product list as the final step With the above map, it's just a matter of looping through your products and creating an instance of with the customer details, if present: 

is used often, consider putting that as a script variable, if it's not already present as an environment variable provided by your shell user profile? Let's assume , for the suggestions below. You are invoking three times, the problem being that new files created during each invocation will be missed by the subsequent one. This may be less of a problem between the first two, but will be for the second and third loops that are separated by a user prompt. The other question is ask is whether your renaming of files should be done as part of the copying (i.e. later) process, or do you always want to rename the files regardless of whether the copying is done. If it's the former, then you should only construct the new name within the final loop, for example: 

In fact you'll probably want to keep this as a simple method itself (similar to your , and have an outside method to get the user input (following scott_fakename's suggestion) to do the comparison. 

Mutability After getting the missing numbers, Numeros has a new problem now: most of the original lists of numbers are gone! You should not be calling or on the incoming arguments, as that modifies their state (which can be really bad if the caller isn't expecting such a behavior), or throws a when immutable instances are passed in (which isn't bad, but you have to deal with exception handling now). Validation 

With this, you eliminate the reliance on accessing the array elements, and you get the bonus of calling the values as they are 'known', e.g. instead of . The two methods above simply replaces the current and methods. 

Using the appropriate types Your are repeatedly casting into a , the first suggestion I will make is to cast it once first to make subsequent references easier to read: 

-iteration conditions Somewhat along the same lines as the previous point, you can consider counting up in your whitespace -loops using the same style as you do for the numbers: