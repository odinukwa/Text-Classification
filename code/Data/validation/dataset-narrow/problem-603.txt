Finally, you say you have read about the factory pattern, that is ultimately what you are playing with here. Note. I think Enum naming should use the singular (Type) rather than the plural (Types), you are not selecting an Object of type Types as your Object (Types.DOUBLE) represents just one type. 

The main difference here is that you have deferred the creation of the random value to the callers end. The calling code will also be required to either use generics too: 

Firstly if you are going to be passing objects of type around I guess you best be prepared to do a few casts here and there. You can achieve this using a simple interface and templates quite easily. Interface: 

By using an enum you clearly enumerate all the supported cases and encapsulate your data without resorting to data structures that do not fit your purpose. If your data is not clearly defined, or is dynamic or extensible in anyway then the enum approach will not work. At this point I would need to understand the relationship between the key and value in your map. If the key describes the parameter and the two values encapsulate the behavior then the key should be a part of the object (if this is the case you are using as a tuple). In this case you should begin by modifying to include a parameterName member variable and then override and so that you can use in a set. How you chose to override the methods will depend on whether you can have multiple instances of a parameter with different values or whether each parameter name should be unique. If your data is hardcoded today, but might not be tomorrow, don't worry about it. If your data is hardcoded today and won't be tomorrow you could define an interface, say . This interface can expose whatever maethods might be useful to you - size, iterator, next... Create a single implementation for today say or - whatever accurately describes the data you will be feeding back. This means that in the future you could add a or or whatever. Now, inside your you could create an enum as described above. If you need to iterate over the values to convert them into another structure you can use the method: 

Shouldn't this be a , or ? And why is it defined in ? It feels wrong if a parent class knows about its child class. 

We've cut on verbosity, but it's debatable to me whether it improves readability. It's harder to achieve the same thing for , although you could pull it through if you added a helper extension: 

Who would have thunk! Not too informative... In contrast, this code doesn't comment the non-obvious stuff. For instance, now your class has a certain policy regarding nullability - which, as I said, is by itself an improvement over the previous code, where this policy was sort of accidental. But is it obvious that throws an exception whereas is ignored? I wouldn't have guessed that correctly, and yet the documentation doesn't say a word about it. It's too busy telling me that element is element. By the way, it's not just a question of documentation - I'm not sure I like this asymmetry in principle. And it isn't the only inconsistency lurking in the implementation, either. For example won't crash when the list is empty - but will if there are already elements in it. What's the rationale for that? :) That's not predictable behaviour in my book. Speaking of , this comment is just plain wrong: 

And again this is subjective, but I see these as a (common) anti-pattern. It's code, not a painting or a poem ;) We've got version control systems for that. 

Indeed, did you test how it behaves for very large (or very small) values, nevermind the performance? What will happen if I multiply by another one? What is supposed to happen? 

Now you can't call eg. . Other than removing the "m" prefix from the parameter name, I wouldn't also keep it named "activity". It's an class, not an (instance object) itself. I'd rename it to . 

from (minus the case sensitivity discrepancy). Unless there are some good reasons not to do so, I'd stick to only one implementation and reuse it in both methods. 

That's probably not a practical problem, but for what it's worth it wouldn't work properly if prefix and suffix overlapped. I'd use a regex... I would also include and the expected (but not matching) prefix or suffix in your messages. The more contextual info in an exception message, the better. Otherwise if you don't catch it red-handed, you'd be wondering what exactly went wrong. 

If you cannot rely on a selector (like I used above) to find the elements that you are interested in, or if you cannot add classes to the elements when the page is assembled then you could add the class in code: 

For reference you can also check this excellent article from Smashing Magazine (check the author) and related GitHub repository. 

So, if you're clever about getting an index in there you could write the algorithm (without validation) in just 3 lines and you'd have done a bit of functional programming which sets you up nicely for playing with a new language. 

Then onwards. Arguably this is borderline procedural but with these few steps I think that is acceptable. Edit: Less readable, more old school 

Firstly, underneath everything Javascript is an event driven language so I do not think that there is anything wrong with using an event driven design pattern if you are comfortable with it. Events are a great way to be able to interlink different components of your system without exposing the inner workings of them (loose coupling) and they add queuing by default. However they are more complex, they make it hard to trace behavior which in turn can make them hard to debug. I think that you would get a cleaner interface by developing using something called the revealing module pattern, there is an excellent resource on various design patterns by a guy called Addy Osmani at adyosmanio.com and the revealing module pattern specifically here. This (or a flavor of it) is commonly used in jQuery plugin development which you can see on the jQuery advanced plugin development page (see Keep private functions private). By following these principles you can keep the private stuff private and only expose the functions that you want the calling code to have access to. You mentioned specifically , and so a quick example of how that might look. 

-. When you are coding your method start thinking in templates. Sure it's not necessary now, but it costs nothing to write and you've got a utility function you can use forever. One thing that would concern me about this method is the Cyclomatic Complexity due to the number of loops and conditionals. Consider how you could break things down, e.g The content of your loop can be broken out into code which finds/verifies the rectangle is complete. As a rule each method should have a role as discrete as possible, again this makes things more testable and more readable (when coupled with sensible naming). 

It doesn't have to be static, although there are conflicting schools of thought here. On one hand, making a method static sort of stresses the fact that it's stateless - and for instance the popular code quality tool for C#, ReSharper, suggests this by default. On the other hand, making a method static has certain consequences, such as an inability to override the method. I don't think it's a big deal either way in this case, anyhow it's a little controversial whether statics should be used by default. As for other remarks: Overall design The class is called , but it knows some other tricks beyond notifying (by sending emails. By the way, I would consider renaming it to to resolve any possible ambiguity, since there are various types of notifications in this world, but I'm not hellbent on it). What it also does is that it searches personnel members by their ID - that doesn't qualify as "notifying" in my book? I would expect retrieving a manager by ID to be implemented on - let every object take care of itself (aka Law of Demeter). Naming 

We're kind of emulating Java's enums here (one of few features where Java actually happens to be superior to C#). And a little bit of help (so that we don't use reflection etc.): 

As explained in comments (in which I pointed out a few possible edge cases), even though it's not optimized in terms of performance, this is about as clear as it gets. A more clever algorithm - calculating the number of weekdays without iterating through all of them - is probably possible, but I bet it would be much less readable. If performance isn't a concern at this point, I'd leave it. You could maybe replace the loop with a LINQ-based solution. 

the else-return bloc doesn't serve any purpose. The same with calls at the end of methods (, , , , ): redundant. These methods are exited anyway. You don't need to use both and clauses. It's one too many. Eg.: 

It compiles, since á’¿ != 2. But it won't work for every digit - see $URL$ if you want to try. Even if it did, I wouldn't recommend doing this in production code :) All in all it's a fun thought exercise, trying to find a workaround and kind of trick C# into doing something it's designed not to. But the truly elegant way is to embrace the language the way it is, and not try to hammer square pegs into round holes. If you were hell-bent on using extension methods, at the cost of being unable to rule out illegal values in compile-time, here's make take on it - more heavy-weight, but providing type and conversion safety. I did it for the heck of it, I know it's not the perfect solution. It resembles @radarbob's answer in that it puts extension methods to use. Let's define the basics (it can all go into one static class): 

Caveat: I've never written a line of C#, nor do I know anything about its compiler. I think that the approach taken in your code could be considered the more modern approach. It is definitely more suitable for human consumption, and it makes it more easy to test individual parts of the algorithm. With luck it will compile down to very similar byte code too. But, your code is inelegant in that you loop twice skipping alternate elements. You also have a bit of smell where you have the code . I'm not sure what the accepted usage of Tuples is in C# but for internal use I'd have thought a single function that returns you an (insides, outsides) would be acceptable - if not a little helper class with two elements. This would modify you code to begin (pseudo-ish): 

Your iterations would need to evolve to use the SortedSet#tailSet or SortedSet#subSet methods. Both of these are just new views on the same data so they are cheap operations. A pseudo approach: 

Next, don't try to return every type of Object from the one Switch statement, it will always be ugly. In order to work out the next step maybe you could elaborate on what is happening outside the blackbox, e.g. if the calling code wants a Double you could add that into your enum: 

On the whole it's not at all bad, I find it readable and I'm sure that it does the job (one caveat to this is how does it handle cases where you have multiple instances of the same point e.g. {{1,1},{1,1},{1,2},{2,1}}), a few things that you could do to improve it.. 

If there is other code and you need all the features of a TreeSet great, otherwise delegate to a TreeSet member variable. Your code is somewhat superfluous because of the next test 

Now what you really want to do of course is collapse down that loop. I found that if you have LINQ (which I see you do not) you can use the operator, very simple e.g: 

Are you changing the fields that you expose from your objects depending on certain conditions? On the whole it would be best to use reflection only as a last gasp. Gson works fine with collections in general see the documentation over at Google. If you want to exclude some fields from serialization then you can use the annotation, as documented here. This requires you to annotate all fields that you want to serialize with the annotation, and to use a builder to instantiate your Gson Object like so: