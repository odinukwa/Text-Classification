Well, the documentation is apparently non-existent at this point, but searching the source yields the following: 

Use the unit test framework 'Unit Test Tools' provided by Unity. You're right you can't create new MonoBehaviours on their own, but why not use an empty GameObject and use and then run your tests? Alternatively you can create the bulk of your logic inside your own classes. Then your MonoBehaviour scripts will just use composition to have a local instance of the class that represents their functionality. Your unit testing can also just make a local instance of the class. Though, this sounds more messy than the Humble Object pattern suggested in the blog post. Yes, creating a testing framework and implementing unit tests can be complex. But once you have things in place, adding additional unit tests is fairly trivial. 

Ideally you'd have some parent class that all these classes inherit from. For example, if all of your planes inherited from , then you could easily create a list of those different classes with something like: 

One way to do this is to create a physics tick callback. This will be called every time bullet ticks internally. In this call back you can set the Y velocity to 0, effectively disabling Y movement. It would look something like this: 

This can all be gleaned from the position of the ball relative to the position of the brick it collided with. Once you have detected a collision: 

There are pros and cons to both, but the decision is ultimately yours. You'll have to decide based on the style of your game and the type of game. 

The byte code for the above tile is 00000000. Then your tile that goes from left to right (or right to left) is like this: 

This is frequently referred to as flocking or a boids simulation. It's an algorithm that combines three behaviors to simulate the motion of a group: Separation: steer to avoid crowding local flockmates Alignment: steer towards the average heading of local flockmates Cohesion: steer to move toward the average position of local flockmates The combination of those three will create a good approximation of a group moving together. These behaviors are described well in the GDC99 paper Steering Behaviors For Autonomous Characters (Craig W. Reynolds). Additionally there's a few Java demos of flocking and some other steering behaviors in action here. The other behaviors include a path following steering behavior and a follow the leader behavior that can be useful to you for having a group move along a path. 

Server mods are just a sub classification of game mod. It's a modification to the way the server processes data. This could be anything from extra logging to a text file to changing the core mechanics of the game being played. The client side requirements depend on what the mod does and the game the mod is applied to. Depending on the game, the server may have lots of control over the client or very little. The more control the server has the less likely it is you'll need to install the mod on the client too. This would include the client getting resources from the server like new maps, textures and sprites or 3D models. The less control the server has (i.e. clients do all the simulation and the server syncs it, there is no transfer of content from server to client), you'd likely need to install the mod on the clients as well. Further, the above also depends on the extend of the modification. The more the mod changes the more likely you'll need to install it on the client too and vise versa. 

Where you'll need to define an and the . If you're not sure how to use layer masks you can learn more about them in this video I made. 

Where are the width,height of the old buffer and are the width,height of the new buffer. So copying the data in I would get the old buffered data with getRGB then place that in the new buffer with setRGB. 

It seems like a backwards step to use inheritance for a entity system. Check out the Artemis framework created by Arni Arent and Tiago Costa. It's in Java, but someone has been porting it to C# (I believe they are a user here too). I can't speak for the quality of the conversion to C# since I haven't looked at it. However, the original is very nice. It uses s to keep track of which entities have which components and belong to which systems (that means a maximum of 64, one for each bit). It's a pretty nice system and I learned a lot from reading the code when I was implementing my own entity/component framework. With this system it's easy to add and remove components, but as Jeremiah said, it would be better to have a solid component which can change states. That's a far better option that adding or removing components. Further, the Artemis framework supports groups and tags. This means you can make a "Player" group or tag and treat it specially depending on the situation. There is a sample game that has its source available as well. 

From the looks of it, you have some other texture layer that's adding "wear and tear" to your model (for example the corners of the ammo cartridge). You should poke around for decals or other layers being applied to the model. I'd be particularly interested in the slider at the bottom: 

The reason you're only finding third party options is because Unity doesn't have any built in support for Bluetooth. 

When everything is set up in the parent/child fashion as I said above, you can easily create a generic script to handle the orbits. Then just drop that script onto the bodies you want to orbit their parents. Update the orbit by adding the rotation for that step: 

The typical solution for jittery movement is to use linear interpolation to between movements. Also, you don't want to set the position directly, only update it based off of velocity (and you can go further and only set the velocity based off of realistic acceleration, and even further and only change the acceleration at realistic jerk. Or just make sure you don't change the velocity too much :)). Here where you're setting the position directly: 

Red is the back layer, blue is the forward layer. I imagine you can set a zone at the transition point to send your cars back a layer when they pass through that zone. Likewise, at the exit you switch back to the forward layer. When an object is in the forward layer, it ignores collision objects in the back layer and vice versa. For this reason, you'll want to have overlap at the transition points, to ensure you don't have objects falling through the terrain. Alternatively, you can create a collision object that cares about the angle of incoming objects. 

A combination of both methods is what I've used in the past. Essentially your character is still moving around in the world with a set number of chunks following them. Each axis of the chunk array is like a conveyor belt of chunks, shifted when new chunks are loaded and old chunks unloaded. Make sure you're not reloading chunk data when shifting it, just changing the references. Only the leading edge of the grid of chunks should be loading new. However, if you wanted to move everything around the player, it's not so bad. If you have the entire world all children of one object transform, and the player outside that world, all you have to do is move the world transform to move everything in the world. 

Generate a quick check to see if a sprite is close enough to the player and check the player against each sprite. This distance check could be something like: 

(I have no idea why the floor isn't flat, I only realized that after I posted it...) Black lines are faces, red lines are normals. The surfaces wrap around. This allows you to have different hull thicknesses, blocking off interiors where the engines are, stuff like that. The doors are easy to place as separate parts (since you'll probably want to be able to move them anyway). 

So, starting with the blue circle, you'd process your paths, ending up with the purple circle. Then you can use those points with a center point on the unit to make the red triangles required to display the shape. (Just making that image makes me realize that that shape is not correct, but it'll be interesting to see what's actually correct) 

Basically, the way you're doing things now is fine, and the results are expected. You just need to add some additional functionality to get the results you want. 

You don't need to use recursion for this (and without a base case, you'll get an infinite loop, like you are). Just change your method to: 

Add another layer of noise to control the amplitude. Scale the noise up (on the X axis) to make the changes in amplitude gradual. Further, you can apply the amplitude changes in a exponential fashion. By applying them in this way, the difference in the noise values of .3 to .4 are not nearly as significant as the difference in the values .9 to 1. This strategy ensures that you do get some deep trenches, but you don't get them frequently. Note that this method can easily be applied to also cause high mountains if desired. 

All in all, this is going to be a play testing issue to find out what a good distance is. You can also experiment with other random distribution methods. For example, you can have each enemy placed 100 units apart, and that position is randomized by +- 40 units. With basic questions like this is good to just experiment and find something that works for you. Ideally starting with something static and then making it random. 

You can actually do this without any of your own servers at all. It would be a bit more work for your users however. One user can act as the server (with a separate server application or built into your game) or you can implement a peer-to-peer architecture. Consider, for example, Minecraft, there's no public server hosting games. Users create their own servers and their friends connect directly to it. Or back in the old days of Warcraft 2, users would use their modem to call the other player's modem and have a direct connection over the phone. However, if you wanted to have a lobby system, that lists available servers, you'd need to invest in your own hardware. Learn more about the options and decide what kind of structure you want to setup. 

Typically I've seen the mouse used for both. Where a key on the keyboard or button on the mouse is held to change the modes. For example, the mouse without any other keys being held will control the player. Holding the right mouse button and moving the mouse controls the camera. When the camera is not being directly controlled, it will follow the player in a typical hover/follow camera, common in other 3rd person games. 

This whole thing involves creating a custom parser, some kind of structure to hold the entity definitions (I call mine the Lexicon!) and a factory for taking those entity definitions and generating new entities. For me this system is still in its early stages, but it's turning out really, really well. It's a pretty powerful system for quickly defining entities and allows you to make any entity you want using the components you've created. If you're not comfortable creating your own parser, I think XML will work just fine. I converted mine from a pushback recursive parser I wrote for a little made up programming language. As you can see this defines the entity. I mentioned that it doesn't directly define behavior. It can, however, easily define such things as hated enemies and how aggressively to react to said enemies. This would be as simple as defining whatever component you use to control such behavior. My entities also have a intelligence component (not shown) that defines things like: 

That's called a Boolean operation. You can find a video tutorial here for almost the exact situation you're asking about. Essentially, it looks like you create a new object with your two objects selected. You'll likely need to make your circle a cylinder first. The new object is a Compound Object of type Boolean. Then in the operations you select A-B (where A is your rectangle and B is your cylinder). It's still a boolean operation. It's just done with splines that share a common plane. Check the Boolean heading on this page.