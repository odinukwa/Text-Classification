You shouldn't be doing things in a loop that don't depend on things changing in the loop. , , and all depend on n, which is constant throughout your loop. Also, if you store your primes, you just have to loop through the primes until you get to sqrt(n), rather than checking every number. There are further tricks to speed up the algorithm, such as checking n only if n mod 60 is in [7,11,13,17,23,29,31,37,41,43,47,49,53,59]; that reduces the number of n to check by more than 3/4. Is tail recursion an option? How large is your stack size? You can break recursion into subrecursion. For instance, suppose you have a function that recursively finds the nth to n+100th primes. Then you can have a recursive function than, when asked to find k primes, calls itself on k-101, then appends the k-100 to kth primes. You can then add another layer, and have something that does 10 primes at a time. Do this in binary rather than base 10, and you'll need 14 layers to get 10001 primes. 

There was a previous question that I answered regarding Tic-Tac-Toe that I'm too lazy to look up, but this is a common enough subject (as you are apparently aware, there's even a tag for it) that you might want to take a look at other questions and see what applies to your program. Taking a broader look than the other answers to your question, why are you even checking for a win in the first place? If your program is running this function after every move, that's horribly wasteful. All you have to do is check whether the new move creates a win. You only have to check the lines the new move is in, and you only have to check two locations for each line (you know that wherever the current player just moved has their symbol in it, by definition). Also, any time you have , you don't need an ; if the first is satisfied you won't reach the rest anyway. 

You don't use any of the properties of . You do not need to know that it is a . I would specify the argument as and leave the invoking class to decide on an implementation. Brackets There are two styles of using curly brackets in Java, and either are valid: 

I'm happy with this code - it's pretty clear and I'm not worried about its speed and memory usage as the file is small. Using the created I now need to process many tweets. Lets say I have 1GB of then in JSON format - from the live stream. What I need to do is: 

So we create a to communicate between the clock and the main . We place a sleep in the clock thread that sleeps for seconds, if the thread is interrupted before waking, it simply exits. This is much more efficient than your busy wait as it doesn't tie up an entire CPU core for absolutely no reason. Never busy wait! We can now modify the game loop to: 

Iterators Kudos for correctly using an to from a while iterating. But, as described above, this is not the correct approach to implementing a Sieve. Programming to the I don't link this method declaration: 

Also note that if none of the words are "long", then the loop method will go into an infinite loop, while the other methods will return an error. 

Generate an array of n percentages. Calculate the average percentage. Subtract the average from each element. Do a for-loop of i from 0 to n-1 and set 

Don't rely on users following your instruction to enter in lower case. Do . Instead of doing , check each possibility separately, and ask again if it's neither (you might want to do rather than `'wet' == conditions in case they put an extra space at the end or something). Since you're going to divide by a non-integer, you're going to end up with float anyway, so it's probably better to cast as a float to begin with, and avoid rounding if they don't enter an integer. You should also do a block to catch people entering non-numbers. 

What is your desired output? Your function has no return statements (other the one commented out), and the only print statement is in the block. Have you run this function? Unless I'm missing something, it won't do anything if you input 0. And when you strip out the last digit, you don't actually store it anywhere, so it's just gone. You seem to be doing double tabs for your indents, which makes it hard to read once you get several levels deep. Also, you can save yourself an indent level after the block; since you have nothing but an block after this, you can put a return at the end of the block. Then you won't ever get to the block unless the condition is false, making the redundant. So you can get rid of that and move everything in an indent level. You don't show what face_value is, so it's hard to evaluate your code when it comes to that part. Also, unless I'm misunderstanding, the block should be something like this: 

So now you can easily add new "transformations" to the list. In order to transform an to the correct in Scala we would simple use as is also a collection. No such luck in Java. I came up with this thing, it's a little ugly but I think it's clear: 

This way they are outside of the running code and clearly constants. Similarly should (almost) always by an instance or class variable as having more than one is (almost) never useful. Use for outputting formatted messages: 

I would also suggest that you always use brackets for your statements. It's generally accepted common practice and with good reason - the few lines that you save by not doing so lead to some very insidious bugs. On an algorithmic note: why reverse the at all? Use one loop and read the both forwards and backwards simultaneously. For further improvement, walk through a comparison manually: 

The other comments cover the code quite well, I have a few points to add. First, obviously this is a critical error: 

Firstly because of the scope of and also because loop indicies should be incremented inside a declaration unless you have a good reason not to. I would prefer the following construct as it show that I have two variables used in the loop, that the termination condition is and that I increment every iteration. 

If something is called "RiemannSum", then it should return a sum. If you want summation to be a separate method, a better term would be "partition"; you could do RiemannPartition.sum(), for instance. Several other variable names are bit unintuitive to me (e.g. rectangles, index). You can eliminate several lines by doing: 

Most of your code is just repeating the same instructions over and over again. Define arrays newStats, deltas, and statMinimums, and your entire LOSSES block can be collapsed into one line of code: However, before you try to figure out how to implement what you want, you need to clearly define what it is that you want. What exactly do you want as far as the distribution of stat changes? There are several different methods, depending on what distribution you want. For instance, if there are n stats, you can: 

Your function is incredibly inefficient; you can calculate the number of divisors from the prime factorization rather than checking whether each number is a factor (and even if you were brute forcing, you could improve by a factor of two by realizing that the only divisor greater than half the number is the number itself). Consider the number 24 = 2^3 * 3. Since the only prime factors of 24 are 2 and 3, a factor of 24 can't have any prime factors other than 2 or 3. So a factor of 24 will be in the form of n = 2^a * 3^b. But if a >3, then n will not divide 24. So the allowable values of a are 0,1,2, and 3. Notice that there are four allowable values of a, and this is one more than the power of 2 (the power of 2 in 24 is 3). Similarly, there two allowable values of b. So the total number of combinations of a and b is 4*2 = 8. Thus, there are 8 factors of 24: 1,2,3,4,6,8,12,24. So you should break into two functions. One should find the prime factorization of n, and the other should multiply together one more than the powers of the prime factorization. You can improve the prime factorization function by maintaining a dictionary of numbers that you've factored. Then once you've found a prime factor p of n, you can use the prime factorization of n/p. And since prime factorization uses prime numbers, you should keep track of what numbers are prime. You can also use the fact that the nth triangle number is equal to (n+1)n/2, so you just have to check the number of factors of those two numbers. I recommend checking two numbers at a time, so you don't have to deal with checking which number is even. That is, if you check 3 and 4 in the first iteration, then 5 and 6, etc., then you know that you can divide the second number by two. Also, you can get rid of the "magic number" of 500 by setting a constant . 

As runs in a separate , we need to consider visibility and atomicity of any variables used to communicate. So an seems the natural choice: 

I have some code that calculates the "sentiment" of a Tweet. The task starts with an AFINN file, that is a tab-separated list of around 2500 key-value pairs. I read this into a using the following function: 

read a tweet file, with a JSON tweet on each line parse each tweet to a using extract the field from the tweet - giving the content of the tweet for each word in the content, check it if has a sentiment for each sentiment word in the tweet, calculate it's value (from the AFINN ) and sum across the tweet store that number 

So we check whether the game is over after reading a new value from the user. In the winning condition we call which interrupts the clock thread and causes it to exit. 

Are horrible! If you need to label a variable declaration with what that variable is, you have picked the wrong name. Further, if you are going to use inline comments, avoid the case where the comment makes the line so long that it's illegible. 

In your first thing, you're checking each character one by one to see whether it's a decimal point. Using string functions, you can just do: 

So .. you're repeatedly subtracting a number from another number, and seeing how many times you can do that without going negative? There's a word for that: division. EDIT: Since you want the actual code 

if you're having trouble understanding , consider the case of generating the 7th number. This is going to be 4+7+13. But 13 was calculated by 13 = 2+4+7. So the 7th number is 4+7+(2+4+7) = 2*(2+4+7)-2, which is 2*(6th number) - 3rd number. So the nth number is 2*(n-1)th number - (n-4)th number. This does require handling the first few rows separately. One way is to manually create them, and then if you don't want them, you can delete them afterwards. Note that if you're deleting them, then you don't have to fill in the ratio column for those rows. You will also have to initialize to the proper value. 

You don't really need a method. You can simply have a object with a method that randomly picks a card from the deck. Whenever you need a card, a card from the , and part of the method is removing the appropriate card from the . If you have eight players, you'll need to draw 21 cards. I suppose conceptually it's nice to "shuffle" the 21 cards you need before dealing any out, and to include the other 31 cards in the "shuffle", but I personally don't see much value in doing all that work just to imitate more closely how "real world" poker is implemented. You seem to be using for both the position and the value. You should distinguish between the two, e.g. versus . The line is really weird. Apparently you're initializing the pot with the blinds, but are you removing the blinds from anyone's chip stack? You should have a bet method, and "force" the two blind players to call that method. Also, having a method named "Shuffle" that does a bunch of stuff other than shuffling, such as initializing the pot, is bad naming. I think that betting order should be an attribute of the table rather than the players. There's no need for a player object to know what its betting order is; if a player wants that sort of information, you can just pass them the entire table configuration (that is, I can see a player asking "What's the betting order", but I can't see a player asking just "What's my betting order?"). The table should have a blind method that adjusts chip totals for bb and sb, and it should have a method that asks the current player to act. Both of those methods should know what the betting order is, and be telling players when it's their turn to act. If the player objects know who is sitting to their left and right, then you can just have the table ask for a player to act, and then ask for the next player to act, etc. Instead of doing , you can do , and then you don't have to do . Under the hood, this is more complicated, but conceptually it's simpler; the button just moves to the left. Other things such as the betting action can move similarly. Adding 2*cnt to a number and then taking the result mod cnt is a bit odd; should give x for every k. 

You're close to a sieve, but you're missing some points. First and foremost your is incorrect - this should step though the range in steps of ; this very fact precludes the use of a . The usual approach uses a , on which you carry out the following steps: 

And yet you continue with your program knowing that it cannot possibly work. Either throw an exception (which will be reported to the user, and be ugly) or simply to exit and terminate the program: 

it's recursive - Java doesn't handle tail optimisation and recursion is slow It makes a rather large number of copies - copies the underlying it's very long 

So whilst I have a lot of tweet data, I only need a list of integers. This is obviously much smaller. I want to be able to stream the data from the file and convert each line to its sentiment value in the most efficient way possible. Here's what I came up with: 

So I am using a for-comprehension over the tweetsfile to each line in the file to its corresponding number. So my question is, how would you rewrite the above the maximise speed and minimise memory usage. Any other comments on the Python would be welcome too. I realise that I can use a single-producer -> multiple-consumer pattern to speed up the processing of the file, but I would for now like to stick with a single thread.