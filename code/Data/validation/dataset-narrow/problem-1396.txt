3D objects still have an X and Z coordinate. The only thing you have to do to make it isometric in 3D settings is to ensure the Y value for all the tile objects are the same. Generally we set this to 0. Put your camera wherever you like the angle, and voila! I hope this clears things up. 

There's a trick to this: Selecting Areas: As you move the mouse, the only tiles you need to check for new impassable tiles are the newly highlighted tiles. If the mouse is dragged from X=25 to X=26, then you only need to iterate over the tiles at the X=26 column from the Y of the starting tile to the Y of the tile the mouse is over. The worst case scenario is you cross both X and Y axis, in which case you will only iterate over L+W-1 tiles. Deselecting Areas: The catch is if the player selects a large valid area, crosses an invalid tile, then backs off of it to go back to the large valid area he had a moment before. To keep from having to check the entire space when your area shrinks, keep track of how many impassable tiles were crossed as you cross them. Then when bounds change, subtract the number of impassables that were in the column or row that was deselected. As soon as your impassable count is 0, you no longer need to check so long as the selected area is shrinking. This still ensures you never iterate over more than L+W-1 tiles at any time. Highlighting: While Selecting areas, as you iterate over, spawn a red rectangle at the location of the impassable tile you are currently looking at. Store them in a 2D array for when you need to remove them. You could do some magic and scale a single rectangle for contiguous blocks of impassables with a little thought. While Deselecting areas, iterate over the column or row in the 2D array mentioned above and remove any object found in the row or column. this will be fast, as you know the column or row you're looking at, and since most will be empty, they will more or less be skipped. 

I understand the concept but applying it is another thing entirely for me. And to clarify, I'm not wanting an animation, I simply want to create an icosahedron from the vertices of a tetrahedron. EDIT: So I now have an alternative way to create an icosahedron using golden rectangles. That's fine for the purposes of my particular project. However, I'd like to leave the question open for solutions to the original problem, i.e. mathematically converting a tetrahedron in Cartesian co-ords into an icosahedron (not vice-versa). 

Using a single quadtree with boolean checks for collision between the different types of objects. Using three quadtrees at once (player, enemy, environment), only testing the player and enemy trees against each other while testing both the player and enemy trees against the environment tree. 

I have no clue what I'm doing with regards to events. I know how to use them but creating them myself is another matter entirely. I've also made buttons without using events that work on a case-by-case basis. So basically, I want to be able to attach methods to the OnClick EventHandler that will fire when the Button is clicked (i.e., the mouse intersects Rec and the left mouse button is clicked). 

One thing to think about here is that you are updating the entire mesh UV state for each tile you modify. I'd be sure to check and make sure it's not refreshing the mesh after each tile. you might return the UV updated array one level up and marge them all at once. Basically restructure so you calculate all, then apply the changes to the chunk/mesh. I also notice you're searching for the chunk index once for every tile you update. Do this outside of the tile loop, and pass the result to the SetTile() so you only do this search once per chunk instead of once per tile. 

So theoretically speaking, with boolean assignment, it's actually slower to try to avoid assignment, than to assign it each frame. The method declaration for the C# call is :: public void SetBool(int id, bool value); :: the id lookup is an O(1) operation off the heap from a hashtable, and the value assignment is an O(1) assignment. 

One thing I would be careful about is using the correct input callback. I would suggest one of two things, read the API's on the input methods available, and choose the one appropriate to your desired behavior. Some callbacks only fire if the key is held down, and others fire on a tap. Secondly, your architecture should change a little bit. The callback should only set the Target transformation. When you click on a pot, copy the transform from the pot to the target of the move script. The move script should be changed to automatically strive to achieve it's current target transformation until it reaches it, at which point it will wait until it receives a new target. This is best done by having your movement code in the Update() method within the script. For a small game, this will achieve your goal, and not cause much overhead. (Bigger games with many moving entities need to approach the problem a little differently) These changes will mean when you click a pot, the target will be set, and on each frame the movement script will adjust the chef's position if it doesn't match the target. The beauty is that you can reuse the "moveto" script for any other objects, with either a fixed, random, or controlled target transformation to add a little extra to your game. (a rat, or an assistant for instance) 

I was able to solve my issue. The second revision of my gist has the solution. In a nutshell, this was what I did: 

Create a camera Set the view matrix of the camera to identity so that there are no view transforms made to the children Set the projection matrix of the camera to be of an orthogonal matrix with width and height equal to 1 Set resize policy on projection matrix to be fixed Set render order to be (I previously had this as and that didn't work. I still have to dig into why). Create a textured quad with width and height of 1 unit Add the textured quad to an instance of and add that geode to the camera Extract the first window from the camera. Set the graphics-context and viewport of the camera Add the camera to the scene and you have a background image 

I know that the image is getting loaded because the logs says so The log says that it managed to add the camera as slave to the viewer 

If I were you, I would question myself about 'What do I enjoy doing for a game?'. Do you want to be a graphics programmer or a game programmer? Do you enjoy fixing those odd pixel in the screen that doesn't fit with the rest of the screen or do you enjoy building the game and don't want to be really bothered by the graphics implementation? If you're more into graphics, learn a high-level graphics API first, like Ogre3D, Irrlicht, Horde3D, etc. Once you grasp high-level concepts, take your time and dive into details. If you're looking to game development, learn to use game engines like Unity3D, Unreal3D, etc. They've done the hardwork of getting the engine implementation right and you can concentrate on the building the game itself. 

Ray casting is a very fast and efficient way to determine line-of-sight. It basically involves sending a ray (think of it like an infinite laser that can't be redirected) from a certain position in a certain direction. Using this ray, you can determine things like which point(s) it intersects and how far away from the origin it was when it crossed a certain point. So for example, in a player/enemy scenario, the ray could originate from the enemy with the direction being the location of the player. If the ray collides with a solid tile, the enemy can't see the player. If it doesn't, the enemy can see the player. Here is an excellent tutorial that will should help. You can also consider Bresenham's line algorithm (summed up, it creates lines) for something that might be more easily scaled to tiles. 

I've created a tetrahedron by creating a BoundingBox and building the faces of the tetrahedron within the bounding box as follows (see image as well): 

Going off this information and the fact that were will likely be several hundred objects rendering on-screen at any given time, my question is as follows: Which method is likely to be the most efficient/optimised and why: 

This question falls into the subject of Runtime Analysis. Assignments are, by nature, constant time operations. From a performance standpoint, you generally don't need to worry about constant time operations. Since you asked: Any primitive operation(assignment, logical evaluation, etc) are generally considered to take one flop from a runtime standpoint. Occasionally there may be more cycles for other overhead, but as a general rule they are considered to take one flop. Lets compare pseudocode: 

In a nutshell, what makes a shallow water equation a shallow water equation is that the water height is not zero and it assumes no variation in the seafloor. Note: No fluid dynamics equation will allow for a water depth of 0, as that would mean you have no fluid. You should read the Wikipedia article on the shallow water equation. Basically, in shallow water, the vertical velocity is ignored because the value is so small and has minor impact to the wave propagation. To quote the section in case of modification of the source page: 

From your example I can tell you're making a "connect the pipes" type game. You have two possible approaches here: 

I think the issue is that the input is being polled every frame as part of the Update(). I would suggest pulling the input from the Update() and using input callbacks instead. That way the input is only polled when fired, and not every frame. That should cause the direction to only update with input changes, and the Update() will continue to render the same direction until the value is changed the next time the callback fires. Unity doesn't have callbacks, I forgot that I emulate them. This is going to take some more thought on my part. I will update soon. If your game is a top down on an 8 point compass this gets a lot easier, but I'm trying to come up with a generalized solution. 

From my experience, mass is either: a) A global value that applies to all spatial objects equally (or no mass scalar at all). or... b) An individual scalar value (e.g., pounds, kilograms) directly associated with each individual object. This approach obviously doesn't scale well. or... c) Defined by a base "type" (e.g., wood, rock, water, flesh, weightless...) with a scalar value associated with the type. That value could be used on its own or it could be used in conjunction with the size of the object to determine the final scalar, depending on the accuracy required. Not sure about the Frostbite engine but I would assume it uses something similar to c). 

I'm working on a strategy game. It's turn-based and card-based (think Dominion-style), done in a client, with eventual AI in the works. I've already implemented almost all of the game logic (methods for calculations and suchlike) and I'm starting to work on the actual game loop. What is the "best" way to implement a game loop in such a game? Should I use a simple "while gameActive" loop that keeps running until gameActive is False, with sections that wait for player input? Or should it be managed through the UI with player actions determining what happens and when? Any help is appreciated. I'm doing it in Python (for now at least) to get my Python skills up a bit, although the language shouldn't matter for this question. 

To make it clear. Use can use Photoshop or any other image-manipulation or image-editor for 'mock-ups'. This helps you decide the color of each element of your GUI and the look-n-feel of it. To actually design your UI, you will need a custom application, i.e. not Photoshop, to create your GUI and save the 'layout' (and associated images or sprites) to a file, which can be loaded by the game you're targeting the UI for. 

I know you've already accepted Zhen's answer but I'd like to put another out there just in case it helps anyone else. To reiterate the problem, the OP wants the ability to keep the rendering code separate from the logic and data. My solution is to use a different class all together to render the component, which is separate from the and the logic class. There first needs to be a interface that has a function and the class uses the visitor pattern to retrieve all instances, given the list of s and renders those objects that have a instance. This way, Renderer doesn't need to know of each every object-type out there and it's still the responsibility of each object-type to inform it's via the function. Or alternatively, you could create a class that visits all GameObjects and based on individual condition they can choose to add/not-to-add their renderable to the visitor. Either way, the main gist is that the calls are all outside of the object itself and reside in a class that knows intimate details of the object itself, instead of that being part of . DISCLAIMER: I hand-wrote these classes in the editor so there's a good chance that I've missed something in code, but hopefully, you'll get the idea. To show a (partial) example: interface 

Seeing as javamonk has already linked some good technical articles, I'll try to approach this from more of a theoretical angle. 

I'm creating a highly flexible 2D tile-based map editor in XNA to make some of my future projects easier (will work for side-scrollers and top-down games). This editor can work with any sized tile. This editor is based on a standard system. It has pre-determined layers such as Base, Fringe, and Collision. However, I've run into a bit of a problem. I don't know how many Fringe layers to use. I'll be working with fairly detailed tilesets and will want enough Fringe layers to be able to render a wide variety of fairly complex scenes (e.g., forests with lots of trees overlapping). I'm also considering having multiple Base layers to enable things like a player walking both over and under a bridge. So my question is this: Is there a "right way" to approach this situation, and if so, what is it? Just lots of Fringe and Base layers? If you were a map editor, how would you expect/want this situation to be approached? Also, while I have this question here, is storing layered maps in 3D arrays a good way to go about things? Meaning the first level is an array of layers, the second is an array of tile columns within the layer, and the third is the array of tile rows within the column.