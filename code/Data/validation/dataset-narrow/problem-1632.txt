The Arduberry communicates with the RPi over a simple serial line (as would any arduino), there is no direct access to the RPi filesystem. However, you can write a sketch for the Arduberry to communicate with a process on the RPi that stores data on the RPi filesystem. To my knowledge there is no readymade solution for this. 

In Panel Preferences, you can select your panel in "Currently loaded plugins", and move it "up" or "down", which means left or right if you have a horisontal panel. 

The splash screen is shown before the kernel is booted, so you cannot ssh or do anything really. Take a look at this description 

At work, we have used the Behringer UCA202 with the Raspberry Pi, (Pi 2 and Pi 3) with JACK, similar to what you'd set up for sound recording. It is powered from the Pi's USB ports. Yes, it "should" be safe to assume that a compliant card should not draw more than the 500 mA specified for USB. If you have other stuff hooked up to USB it is always better to use external power, so that's yes to your first question too. I have tested different external USB sound cards with the Pi, and the not-so-positive answer is that they sometimes work and sometimes not. That cards are USB compliant is no guarantee that they will work with Linux. I have not tried the cards you mention and the difference seems to be design and the pre-amp chip. That may or may not be important for Linux compatibility. If you buy the card from a good dealer, ask them if you can check if it works and get an option to select another card if it doesn't (or get a refund). We've done that in our local shop, they tend to be helpful. Another thing, the Pi does not like hot plugging USB powered devices. If you know you will do that, get a powered hub. 

The second one always being HDMI. Maybe it is possible to configure this to be the default output device for the system and use device 0 for the shairport. 

This should switch to french azerty layout. You can put this command into your if it works. There are also many other keyboard layouts available (like for Belgian azerty). Edit: If you want to make this permanent, you need to make sure the still starts the default WM and desktop. So put these lines into your , if it does not exist yet: 

I want to turn off auto white balance for my raspivid stream. However, when doing that, the image turns completely black. Why? And how do I fix this? 

The way to go would probably to use Qt embedded. It is small enough to run reasonably well on the Pi, I would guess. It can use the Linux framebuffer directly, without X11. If the kernel has acceleration in the framebuffer, it will use that, too. But this may not be the case on the Pi right now. The Qt embedded can also be built with QtWebKit support. There are some Qt blog posts about deploying Qt embedded on the Pi. You should begin there. There's also cross compilation instructions on the same blog to get you started. 

It seems the problem was caused by me. I was using tmpfs for several directories under /var, to prevend Plex Media Server from spamming my SD-card full of useless logs. After commenting out the tmpfs sections in my /etc/fstab, everything was fine again. 

Here is the source of which automatically outputs and to temp files in and checks to see if a previous copy of the script is still running and tries to kill it if it is. The python program outputs its PID to file . The script can also be disabled by creating a file called in : 

You get a message that you try to install a virtual package and you have to install a concrete package. You find a list of concrete packages. Install the concrete package 

Even though the PIR device should assert a voltage or ground depending on the state of the device, you should try to add to your call as does one of the examples I found using Python. In fact, the C code you link to appears to also do this (although the C code sets ): 

UPDATE: 2017-02-27 The link above to SourceForge no longer exists. According to this article you can install using the following command: 

There are many remote control quadcopter, drone, etc, projects that use the Arduino family of single board computers. Here are three links to one that has fairly detailed instructions and parts lists. You should be able to get ideas from this and other projects to help you develop your project. $URL$ $URL$ $URL$ One comment, since you say that your electronics experience is limited you may want to consider following some more simple Arduino or Pi interfacing projects such as interfacing to distance sensors. Here's a link to some simple interfacing projects from SainSmart that helped me. One challenge you may have is that the Raspberry Pi GPIO pins are strictly 3.3 v while many of the sensors and relays may not support. You may also want to consider using a Raspberry Pi and Arduino in combination, with the Arduino handling all of the interfacing and the Pi doing all the CPU intensive work. There is a GertDuino board design by Gert van Loo to be an Arduino board designed specifically to interface with a Raspberry Pi. 

Is there an error in my /etc/modules file? How can I debug this, and/or how does one correctly load modules on system startup? By the way: I can modprobe those above lines just fine, which enables the LCD and I see a nice blinking cursor on that display (since there is not getty running). 

Where has to be replaced by the MIDI sequencer that you see after running . On the Python side, I cannot give you much advice, except reading the docs for the package. There you also have to connect to the ALSA sequencer device from above and send your MIDI events to that port. 

Instead of , you should put your PCM device there. You can list all devices by typing . Then pick your headset as the slave device. Add the new device as your default device in : 

On the official forums I got the answer. I need to set red and blue gains in the awbg parameter: . The parameters of course can be tweaked to give the desired appearance. The answer is actually hidden in the official documentation: $URL$ 

I haven't tried this, but I think these are the most important steps from the above tutorial. In your case, I would also use dmix as well, but that is described in the tutorial in more detail. Hopefully, the above lines will get you started. 

Okay, got inspired and checked omxplayer out. I've worked some with VLC, but not omxplayer. It turns out that omxplayer has a DBUS interface with which it can be controlled. But I also discovered that there is a option that can be useful. If I don't kill the omxplayers already running, starting the new player in a higher layer (higher ) puts that video on top, pretty much instantaneous. Then I kill of the previously started videos in the background. A big improvement. My quick and dirty code: 

The standard Jack package is not meant to run headless, and among other things requires dbus. You can build your own Jack to fix this. I suggest you read up on this page on how to install a patched Jack. 

There are bridges that do this available. Arduberry springs to mind. Try googling for "rpi arduino shields" and you will get some options. Don't count on all shields to be supported, though. 

Yes, there certainly are such lcd screens, both with and without touchscreen. Adafruit is one supplier with a large selection, there are others too. They usually have a step-by-step tutorial for their products. 

Okay, whats going on here is probably that your ISP is using NAT, and the IP address your router has is in the private range. The only way to get it to work without a VPN or some other tunneling*, is to ask your ISP to assign you a public IP address. Some ISPs do this for an extra fee, some for free and some just don't. *ngrok is one such provider, there are others, and may or may not suit your purposes. 

I have an old rev.2 (I think) model B. It already has the 000 Fuses, but still only 256 MB of RAM. I wanted to use it for some small projects, but it does not run very stable. I tested TP1 and TP2 and measured only about 4V. This is obviously too low. I was using different power supplies: Apple 5W and 12W adapters, a 1.5A adapter I am using with my RasPi2 and also tried powering via my MacBook Pro's USB port. All the same, I always get around 4V. Could it be some component on the RasPi board? Can I fix this? I have attached a picture of the RasPi in question to aid the discussion. 

This is for my Linux PC, but the Raspberry Pi will show something similar. Then tell you TTS tool to output to stdout, which is easy for . Pipe the output through aplay, with the specified device: 

This is for my WiFi dongle, which uses the 8192cu driver. If yours uses a different one, you need to adjust the above script. You need to adjust the to an IP of your liking (e.g. your Router), and you need to provide . An example config looks like this: 

However, when you have one of those screens attached, you won't be able to output to your TV as well. You could use one of the small touch screens as an input device, and output to your TV via HDMI. There are several options for small Pi touch screens, for example: 

As stated in @Kenneth's comment you need to compile your C program and you can then execute it using a CGI script. Here's an example of running the command from a CGI script from $URL$ 

Without any additional work this may result in the file system being mounted read-only which may not be a problem is you are just interested in reading the existing files. From what I've read the Linux software for HFS+ doesn't support writing to a journaled HFS+ file system and journaling needs to be disabled using MacOS. Once you have the file system mounted read-only you should be able to use Samba to share out the drive to your Windows PCs. Here's a article that describes how to do that. You will need to perform the Samba installation and configuration steps described in this article beginning with: 

In your case instead of calling the program you can just call your program, such as You can compile your C program by placing the source into a file such as myCprogram.c and then use the command to compile and link it into an executable called . 

According to this article you can add support for HFS+ (Apple's proprietary file system for MacOS) by executing the following command on Raspbian: 

I vaguely recall getting errors when trying to run an exectable that was built for a different processing environment. 

Follow this guide. The only things you need are a pi zero, standard usb cable, and a mac/pc. I tested the quick way on both my mac and a windows pc. On a mac i use the OSX terminal to ssh into the pi zero, and i can enable internet sharing for the zero (done in the mac settings). On the windows pc i had to install bonjour. Works great! 

None of the Raspberry Pi's are listed in the ECOS supported hardware list. And by that I mean you are probably out of luck. To get ECOS running on the ARM11, you will need to port it. 

This would be a great (in several ways) project, but I think that a passive AF system using contrast measurement is not feasible with the kind of focus system possible with the Raspberry Pi camera. So, in theory it could be done, but I'd say at a considerable development cost. Look for an USB camera with autofokus. 

I don't have much experience from bare metal programming on the Pi, but I do know that is much like working with a MCU. You should think of it as if the Pi is an Arduino and your programming environment is a computer with cross compiler, kind of like the Arduino IDE. (just not an IDE in this case). Following that analogy, there are no drivers to "install". Instead you need include libraries that support the hardware you intend to use. I guess you are aware of that as ethernet is not supported out-of-the-box for bare metal Pi, it is supported by the USPi library. The documentation for a library/driver should tell you how to use it. Or you'll need to read the source code and possible examples. And all configuration for WiFi must be done when writing the code. Or code must be written to allow configuration, like when using an ESP8266 with the Arduino IDE, in which case you must also provide a user interface to do the actual configuration. As of February 2018 I'm not aware of any WiFi library/driver for bare metal Pi, any pointers or links are welcome! An obvious solution for bare metal gurus would be to port an existing library for ARM. For RPi 3 and Pi Zero W users that want to take advantage of the internal WiFi, there is a complicating factor: the Broadcom chip is not exactly well documented.. Now, I'm ramblin', but it seems to me you are crossing the creek to get water.... If you just want synchronized multi-room audio, there are other solutions that can take latency into account. Just google for it. Some of these work on the RPi too, and does not require you going bare metal. On the other hand; if you want to educate yourself, you're up for an adventure! 

As @lenik's answer says, your TV needs to support CEC. I installed a compiled version of libcec which included the command line utility from SourceForge using the following commands: 

Your original problem is that you are using Python version 3 and according to this posting the module has been renamed in Python 3. After correcting that issue you state in your comments that the program still doesn't work. I suspect that is because you never execute the line of code because the previous block of code is an infinite loop, will run the subsequent block of code forever and the thread.start will never get executed. I recommend that you move the line of code before the block. I also recommend that you put some sort of into your routine otherwise your will continuously output either "on" or "off" very quickly. I would try: 

I followed these instructions from HowToGeek on how to turn your Raspberry Pi into a low power network storage device. Those instructions worked perfectly for me, however, I did change the external drive formatting from NTFS to ext4 due to the very high CPU utilization used by ntfs-3g. I was getting less than 5 MB/s write throughput to the Pi using NTFS. By switching to ext4 my throughput increased to 10 MB/s write throughput to the Pi. I still hit 100% CPU utilization on the Pi, but my 100 Mb Ethernet was running close to 80 % utilization so I figured that this was going to be as good as it gets on the existing Pi hardware. I also use two external USB drives as the article suggests and use rsync to copy from the primary drive to the backup drive. I get about 5 MB/sec throughput when copying data from one external drive to the other. 

This will check every five minutes if the connection is still up, and restart it, if the router cannot be pinged. If you dislike all the syslog messages, you can comment them out in the script. My corresponding looks like this (I uninstalled all the network managers): 

My Pi2 is not booting anymore after upgrade to Jessie (using the standard apt-get route). During boot I get a bunch of messages, the first one is the "A start job is running for dev-mmcpblk01p1.device", which takes about 90 seconds. Then I get messages like 

There is an experimental release of an accelerated X server available here: $URL$ Sources are available over at github: $URL$ The whole thing is supposed to be still somewhat buggy, and there are warnings about possible data loss etc. But still I think it would be good if some people would test drive it. 

Is it possible to have (the same) audio going through HDMI and the line out on the Pi2 board at the same time? I want to use my Pi2 as a RetroPie station, using HDMI for gaming, so video/audio are in sync, and as a ShairPort for when the TV is off. Alternatively it would be ok if I could detect if the HDMI device is on, and switch accordingly. I don't need the two outputs to be bound to the same device. If ALSA represents them as different devices that would be ok as well. The Shairport should only use the Stereo jack.