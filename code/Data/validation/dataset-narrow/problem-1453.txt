Whatever code examines the mesh components can check to see what values were provided and based on them, decide how to decode the component data for rendering. In our engine, we have the ability to specify a list of skins that a mesh can use. By selecting a particular skin, the appropriate mesh is rendered. For mesh components where there is only one skin, the list simply has a single value. If we need something specialized, we have a choice: new component or modify an existing component if it makes sense to do so. 

It isn't uncommon to do some loading of resources, creating textures that may be needed later and keeping those in memory for use when needed. If you think about any console game, there is usually this "Loading" game state where a lot of this activity happens. The nature of consoles often require such management of resources and memory since background loading of assets isn't optimal as it may be on a PC for example. In our case, we use a single TextureManager across all scenes. Our rule is that two scenes can't expect to use the same texture name if they're expected to be actually be different. Such a design imposes the responsibility on the scene loader to handle the cases as needed but allows the sharing of texture resources across multiple scenes if the need existed. In the cases where the textures need to be different, the loader just loads the textures in the manager with a name scenename.texturename so that they are allocated uniquely per scene. 

Another approach is to register your subsystems with the game object system. During registration, they provide component configuration parameters that identify what components must exist to consider an entity of interest during it's update pass. Now you simply create your entities and associate components to them. These entities by default are inactive and not in the world simulation. Once they've been created with all their settings, you ask the game object system to activate the entity. During activation, the system registration configuration is compared to that of the entity and if a system's component needs are met, the entity is added to that system's view. You can send out events during this phase to inform systems of new entities so they can create internal resources for their update tick when it gets called. Now during the update pass for each system, the system is presented with a list of entities to operate upon. The beauty of this is that components do not know of systems and the systems simply don't care how the components came into existence, just that they exist. One of the main things I have come to like is keeping components and systems separate, particularly around lifetime management. Naturally systems need to know when they come and go for various reasons, but because components are often of interest to more than one system, it makes sense that their construction/destruction and storage be handled independently from systems. 

The very first thing you need to determine is what is your target audience. Your target audience will help you determine the range of what is considered common versus uncommon type questions. The broader the audience, the more generalized common becomes because the questions will have to span larger age groups of where educational boundaries vary significantly. For example, what kids learn today in school is drastically harder than what our grandparents were taught. The next thing is to try and categorize your questions based on their commonality. For example, "Who was the first US President?" is a fairly easy and common question that most anyone with any exposure to US history should know. It is far more common than asking "What President gave the Gettysburg Address?". The next factor to consider is that your questions are being given with multiple choice answers. This obviously can make more difficult answers much easier because of deduction to reason the valid versus invalid choices. This would make questions like my former far easier even for people who may not have had exposure to US History, but also could make the latter question even easier for those whom may not be overly familar depending on your choices. -- listing Lincoln with other names which were not even US Presidents but perhaps Presidents of other countries. So yes, it can be subjective but there are ways you can rate your questions in a way that can be labeled as easy to difficult but the key factor is your audience. 

What I have generally seen to handle logic/render thread communication is to triple buffer your data. This way the render thread has say bucket 0 it reads from. The logic thread uses bucket 1 as it's input source for the next frame and writes the frame data to bucket 2. At sync points, the indices of what each of the three buckets mean are swapped so that the next frame's data is given to the render thread and the logic thread can continue forward. But there isn't necessarily a reason to split rendering & logic into their respective threads. You can in fact keep the game loop serial and decoupling your render frame rate from the logic step using interpolation. To take advantage of multi-core processors using this kind of setup is where you would have a thread pool that operates on groups of tasks. These tasks can be simply things such as rather than iterate a list of objects from 0 to 100, you iterate the list in 5 buckets of 20 across 5 threads effectively increasing your performance but not over complicating the main loop. 

The benefit to pushing your rendering to its own thread separate from the game logic is to give the player the illusion that they are getting higher FPS but reality is that in most cases, you're really just drawing the same state over and over more often by doing so since you should be batching rendering commands to the rendering thread through a set interval of your logic thread's fixed time-step. For File IO and even Network IO, I would consider using asynchronous IO. Whether you opt to use a library for this or not, there is serious advantages to using Asyncronous IO. I wouldn't offload this to another thread however, I'd make use of OS-centric constructs to perform non-blocking IO. This provides you the means to swap between blocking & non-blocking where appropriate for IO without having to concern oneself with threading. For game logic, I use the notion where I update logical systems in sequential/serial order but the update loop itself operates in a batched parallel_for() manor where I operate on small buckets of components for a given operation across multiple threads. 

Any object that now wants to be informed about keyboard events can simply be derived from this listener contract and your input system simply needs to allow a way to register these dependencies. 

What's important here is that you have a solid basis for core game logic that is independent of what your scene logic may be. This class could hold a list of active rendered game objects, it might hold a reference to your camera, graphics context, etc. Now your class looks somewhat like what you've described. 

The only time when a mesh collider may be appropriate would be for terrain surfaces that are often not flat and it's important to give a more realistic feel to walking on the ground surface as possible. 

The best way to solve your concerns for flexibility and comfort of the user is to certainly allow them to define their bindings as you have described. Whether you opt to do this through a configuration file they manually edit or an in-game screen that allows them to select the action and then press the key configurations for said binding is entirely up to you. If it were me, I would prefer the latter mainly because it avoids human error in creating the file and reusing a lot of the existing logic you'll need to decode the file into some internal representation as well (aka text to actual keys). 

The event couples behavior to an event. This causes tight coupling and could be why you're having trouble deciding how to handle these use cases. Instead I would concentrate on the fact you want to perform some behavior when a collision occurs, therefore it makes logical sense to expose some way to know when a collision has happened. Since collision data is often useful to numerous logic systems, your detects collisions, resolves them, and stores the resolved data in some queriable list. Then there is any number of logic systems that store a list of entities that contain a specific marker component and use the 's resolved data to determine whether entities with the special marker component has a collision and perform specific behavior. 

Our ES implementation basically uses an unsigned integer to assign a unique ID to each entity that gets created. The entity ID is essentially an index offset to various subsystem vectors where component data is stored. When an entity is destroyed at the end of the frame, those IDs are placed into a free list and simply reused later. In other simulations & in networked games, I've often resorted to some 64-bit ID which we referred to internally as a GUID that identified a few characteristics about the entity by simply doing some bitwise math. As for editor friendly names or possibly encounter-specific names that make scripting easy, we generally associate a TagComponent to those entities. It allows us to query entities by some human readable name such as "General of Death" or some system-defined name such as "Target", "Player", "TargetTarget", "Leader", etc.