Blender does not have "x right y up -z into the scene", as you can see in your example image, the blue arrow in Blender represents the Z axis. It's pointing up. You need to either rotate the object in Blender before exporting, or rotate the object as part of your import process. Blender uses a Z up, Y into the scene coordinates system. You need to change it to match the Y up, Z into the scene coordinates system of OpenGL. 

Where these shortcuts will be used will depend on the developer and what problem they're trying to solve. If you're making a decision for what size to make the chunks, and it doesn't matter in any other aspects, you may as well use something that is familiar and has benefits you're used to using. 

Where is the time before holding the space bar causes repeated shots and is the time between each repeated shot thereafter. This is similar to the keyboard input for many text editors, holding a key for a certain amount of time will cause that key to repeat at a (often shorter) delay rate. 

Use the organization of the data to your benefit. You can always be expect the data in the same order, so you know what the next bytes belong to. For example (not specific to your data), when reading in the data, always expect two bytes for tile type, two bytes for lighting information and then two bytes for extra info. So it knows that after 6 bytes, it's time to move onto the next tile. Don't store strings for your tile types, with two bytes you have many thousands of different types. It can take two bytes just to store one character depending on the format. Don't store position information, it should be implied in the tile order. Always store the tile information in chunks, one column at a time (or one row at a time). This allows you to know the position of the next tile, without needing to read it from the byte stream. You read the starting position of the chunk, then the first tile is placed at that position. Then you know the second tile will be placed at the chunk position plus one in the Y direction (if sending column per column). If your goal is to make the file smaller, you are probably going to have to give up the human readable feature (which is what your current formatting looks like it was designed for). As for defining tiles as numbers. You just create a "conversion chart" in your code: 

A* should be plenty fast enough. Each time a tower is placed you should calculate a new path for each spawn point, and assign that path to each unit that is spawned there. You should also calculate a new path for the units "in the field". Units in the field can have their paths calculated as the shortest path to get back on track, as in a path to the new path. Or the units can have their path calculated from their current position to the destination. You can likely save calculations by grouping units in the field and calculate a common path for them all. For example if you have a group of units in tile (4,7), they can all use the same path, so you just have to calculate it once. Additionally (depending on what your rules are) you should consider doing these calculations as a check before the tower is placed. This will disallow the player from placing towers that block all paths. Or as some tower defense games work, if the play blocks all paths, the units just ignore towers when path finding. 

If you're looking at this for the benefit of the player, allow the player to decide, indirectly, via the difficulty setting. Checkpoints Pros/Cons: 

I'm not so sure hand drawing is the way to go. I've found that I'm much better at art with the mouse than I am with hand drawn art. I think the key point is practice. If you're going to practice something a lot, it should be using the tools that you're likely going to be using: a mouse and keyboard. I'm not an artist, but I think I'm getting better. I've been going through tutorials and modifying existing art. Both develop your knowledge of the tools. Recently when I was creating a texture for a 3D model, I neglected to save the texture file before closing Blender, textures and models are different save operations :(. Anyway, I had to re-create the entire texture from a blank canvas. I think this ended up being a good thing, it gave me practice. Based on that I'm likely going to create multiple versions of every texture, every time. Starting from scratch each time. Good luck with your art! 

Use QuadTrees to limit the number of sprites you need to check against the player. There is a balance here between keeping the minimum quad size low and keeping the traversal short. Play around with it before deciding you want to try something more complex. 

According to the Unity forums, Unity will not work with Virtual Box. It does however work with VMWare with the "Accelerate 3D graphics" option checked. 

I downloaded the gDEBugger from gremedy over a year ago, with their one year free license. The license has since expired and their site says that I'll be presented with the option for 1 year free license the first time I run it after install. This doesn't happen when re-installing, it just tells me the license has expired. How do I get a new license? I use this regularly for debugging shader problems and performance testing my game. 

This is a very difficult task. Primarily because you're dealing with the perceptions of others. What one person sees as busy work, another will see as a fun side quest. RPGs (online or otherwise) are notable for this "busywork" or "grind" because of the XP systems and leveling. If you need X experience points to get to level Y, and you know that killing monster Z gives you N experience points, etc, etc. Grind ensues. The primary way to solve this is to abstract away the XP system and leveling, and make the progress of them game story driven instead of XP/level driven. Giving each required quest a true purpose in the game is important. Advancing the story should be more important that leveling up your character. This is the hard part, the story has to be interesting for this to work. Like a good book, your story should be a page turner. It's a role playing game after all, if the player really feels like the role they're playing is important, it won't feel like a grind. Player skills and abilities develop as the story progresses. It depends on the skills/abilities system you're implementing for how this will work. Perhaps it's a Skyrim style system (I'm a fan of this one), that improves the skills you use, as you use them. Or some type of XP pool system that allows you to spend XP in their pool on the skills they want. Whatever way you go, it should be secondary to the story. Maybe the story unlocks a larger pool of XP, opens up more skills or increases the rate you improve skills/gain XP. Side quests are still important for players that want to spend more time with the game and explore more of the world. These quests should add to the story of the world. Play testing will be critical for determining the "grindy-ness" of quests/tasks. Play test it yourself and get friends (gamedevSE colleagues?) to test your game. Implement a information gathering GUI that can pop-up after each quest to ask the player to rate the quest for fun/grind/rewards/difficulty/etc. 

My laptop has an "integrated" Nvidia 5400M. It plays most games with ease. Make sure your laptop is not using the Intel 4400 graphics GPU and is actually using the AMD 7520G. (Many newer laptops have two graphics options these days). To answer your question, it doesn't make much sense to test for integrated or not, you need to know the capabilities of the GPU, not if it's user replaceable. You can do that by compiling a list of the most common graphics cards and creating pre-configured settings for them based on how powerful they are. Or you can a very short simulation and ask the user to check their settings if you find the simulation isn't running well, or continue with the standard settings if no problems are detected. 

Noise along any of the axes will be consistent noise. Just imagine you're flying through a cloud of noise sampling a single line of data. So yes, is exactly like traveling along a single line of noise inside a cloud of noise. You'll be traveling along the line that represents the x axis. You could even do and travel diagonally through the noise if you wanted to. The point being, as long as you're moving linearly through the noise you'll get consistent noise with consistent values of . 

will be null if you don't have a camera in your scene with the tag . If you don't want to tag the camera, you can't use but you can specify the script you want to use. Something like: 

Portfolios are not unique to game development. Commonly called portfolios, or more technically "career portfolio", see this definition from wikipedia: 

You could also try keeping a running total of work, so each step of your simulation, calculate . Where is the distance traveled since the last update. This will give you the total work (effort) that the agent exerted. 

The editing tool state changes (including the cursor) are not placed on the undo stack. That's intended behavior. Some one tried to file a bug about it, not too long ago, and it was closed as intentional behavior. You can brush up on cursor behavior here. If you really want to keep the cursor in one place, you can create an object at the position, hide it, then you'll have something to snap-to the position if you ever lose cursor placement. Additionally, there are plugins that you might like. Specifically for this situation: Enhanced 3D Cursor Which provides: 

It's a noob mistake, but that's OK. Finally, make sure you put the apple at the top of the screen, so it has somewhere to fall. And Jimmy suggested, you can also turn the monitor upside down if the apple is on the wrong side, since you're just starting, this is likely to happen. As a side bonus, since you're using Windows, if you wanted to make an apple pie chart in Microsoft Excel, you could easily simulate a window to cool it on. 

If you want to have it rotate at a constant speed, there's no reason to use a physics engine. Simply draw the line rotating one way then the other. However, if you're actually interested in a swinging motion, constant speed is not going to give a very realistic interpretation. Check out pendulum motion to see the math behind the motion of a swinging object. Even with a pendulum, you shouldn't need the physics library to simulate it. You don't mention you'll have anything interacting with it, so just use a simple harmonic motion formula for movement. 

There's not really a standard procedure for this. It's just something experience gives you. You're not going to immediately understand a large code base. Everyone has their own coding style and strategies for structuring their code. Likely what's happening is you're trying to understand too much, too fast. Start slow. Pick something you want to learn more about, like what the character class looks like or how the mouse picking works. Find one thing and focus on it. Trace the usage of those classes throughout the code, see where they're used and how. Build your knowledge of the code base little by little. Soon you'll be understanding how the designer likes to structure things, and finding features and examining the code will get easier. 

Of course you'll be more detailed. You can also keep track of the faces in a separate array, perhaps using a byte with bit positions 0 through 5 indicating whether a face is set or not. Eventually you'll probably want to improve upon this with special checks for "short cubes", transparent but solid cubes and so on. EDIT I've updated the code to show that you run this on a per chunk basis. This only address the issue of faces that are invisible because they are adjacent to a solid cube. Sending the vertices for all the cubes and "letting the GPU do the culling" would be a bad idea. I assume you may know that already since you asked this question. The above code is only run when the chunk is dirty, as in, something has changed. It's not to be run every frame. You'll see significant performance improvements with the above change. I know because I've gone through the process before. You may also find performance improvements with spacial partitioning, but the improvements are unlikely to be as significant as drastically reducing the number of vertices sent to the GPU (as you will do when you implement the above). 

Like in "real life" physics to make it speed up faster (higher acceleration), increase the force or decrease the mass. You may be familiar with the common physics equation , you can also look at that as: . So lowering the mass or increasing the force will change the acceleration. Where acceleration, of course, is the change in velocity over time, which is exactly what you're interested in. 

Alternatively (and more difficult to implement), use a circle to scale them all. Take a circle of radius X, and ensure that each generated shape has the same surface area inside the circle. For example, below, the star is scaled so that its surface area within the circle is the same surface area as the square has inside the circle: 

It will vary from game to game. Some games will have this information easily accessible in human readable data files, other games will have it stored in binary data packages. This is something you'll just have to poke around and find yourself depending on which game you're interested in. Either by looking through the data files yourself, or searching online for someone that's found the information already. There are likely easier ways to get transcripts in multiple languages. For example, movie subtitles are frequently available in multiple languages. 

This also means you always know where your mouse is, and your widgets know if they were the ones currently under the mouse when it was pressed. 

Yes, you're thinking too complicated. It sounds like a lot of your problems could be solved with a messaging system and some additional attributes that allow you to specify some filters, and finally not worrying about being so strict with entities/components. Messaging will help you with some aspects like triggering particles, powerups, and so on. For example, you could have a world object that subscribes to particle events and creates particles at the position described in the event. Filters will help you a lot in collisions. Filters can define if an object collides with another, and what response it will have. You add some attributes to your physics component that defines what type of physics body it is, what other types of physics bodies it collides with and what the response should be. For example, a ball physics object collides with a paddle physics object and responds with reflection and particles. Finally, don't be so strict about your implementation. If you can find a way to make it work, but it's not really EC system, do it. Like in my example above, the particles to not need to be managed by a system or part of the EC system at all. It's more important to finish the game than it is to strictly follow a method that's already pretty poorly defined.