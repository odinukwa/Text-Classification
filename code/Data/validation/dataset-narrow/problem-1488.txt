Just out of curiosity, when is ever a necessity? I can't think of a single case. As far as I'm aware, is merely shorthand, not an actual technical benefit. 

You're using the example of stacks and queues as an exercise, because stacks and queues are relatively simple concepts that are easy to grasp. You're not using the example of stack and queues as an exercise because the industry is relying on these students developing a solution to an ongoing problem. Let me put you in the role of the students, and teach you something about my company: 

Without me explicitly telling you so, you're likely already assuming that the [censored] parts were supposed to tell you that the accountants and the janitorial staff are paid a salary. You expect this, because you extrapolated a global idea from a collection of examples. This is what you're trying to get your students to do. You're showing them examples of understanding a problem, accurately defining it, and working towards a solution. Given enough examples, your studens will learn to distill a generalized approach. With this approach, they will be able to create tools (that do not yet exist!) on their own, without relying on what has already been created. 

This is a contradiction. If you don't think the students are capable of handling a problem of this complexity, then you shouldn't be trying to teach them the solution (to a problem that they can't grasp). In other words, if you want to teach them something, of course you're going to have to show them a situation where it is relevant to use the solution! 

There are of course countless ways to respond, but you should always try to find a compromise that both confirms the student's vague suspicion, suggests that it only works in particular cases, and it avoids creating confusion for the other students. Specifically for this example, my response would be: 

The thing about abstract fields such as programming and mathematics is that people will find what works for them. Not everyone sees it the same way. I may be biased because me and the student apparently see it the same way; but I'm actually having a hard time poking holes into his argument, without having to resort to fairly avanced event handling (and even then, the analogy sort of works). 

Your conclusion does not match your observation. Suppose the community is split 50/50 between either using freely, or not using it at all. That means that either choice is equally correct. Standards and conventions are, unsurprisingly, decided by convention. The only things you should be telling your students to not do are the things that a majority of the community agrees are bad approaches (such as hard casting for no good reason). 

Anecdotally: A simple example for math applies to me. When considering the average of two numbers, most people think to themselves: 

This goes even further. may actually be the solution to your -focused students. In all likelihood, they are choosing the blanket use of because they find it unnecessarily hard to always write the correct type. solves that problem by having the compiler (not the developer) figure out the types that are trivial to look up. You're seeing this as two similar issues, but it's much more likely that one () is a consequence of your reluctance to allow the other (). 

This is again a matter of convention. If students are predominantly exposed to "StackOverflow code quality", then it makes sense for them to adapt "StackOverflow code quality". Being better than your surrounding is not always objectively better. The first company I worked in was comprised of self-taught developers and one university graduate. His solutions were much more theoretical than ours. But he couldn't make those solutions work in our company, because everyone else disagreed with him. While I'm not in any way arguing that CS theory is bad; you do need to realize that pretty much every argument of code quality rests on convention, not objectively provable superiority. If something were actually illogical or inferior, then no one would keep advocating its use, thus eventually rendering it outdated. What you're trying to do, with the best of intentions, can also be construed to be bordering on requiring students to adhere to your preferred standard as opposed to the average community standard. 

Note that A is always the smallest number. This looks a lot more contrived. I agree. But to me personally, it was easier to do it like that. I'm someone who uses number forms to visualize numbers in my head, which means I do simple calculations visually (sort of, it's hard to explain). When you ask me to calculate the average of 45 and 51, what I see in my head is: 

"Just because it works, does not mean it works well." is what my teacher used to tell me. And I was the kind of student who needed to repeatedly be told that. 

Somewhat offtopic, you can actually see this principle at play for a lot of clich√© action movies. The hero at one point loses access to [advanced thing] and is forced to use [basic thing]. In the end, he masters [basic thing] to a degree where he can outclass those who use [advanced thing] but don't know anyting about [basic thing]. The Karate Kid is one such example that argues the importance of mastering the seemingly unnecessary and outdated basics. This is essentially what you're teaching your students. While they may be equivalent to their colleagues who use the existing .NET framework; they will leave their colleagues in the dust once they reach uncharted territory and have to create their own data structures. Funnily enough, I had written the above Karate Kid example before looking up if it was defined as a trope. It is, and it's called "Wax On, Wax Off" in reference to the Karate Kid.. 

A very simple example is an application that builds a list of names (supplied by the user, one at a time) until the user says "stop", at which point the program generates a sorted comma-separated list of names. I don't see a way to do easily solve this with an array. Since you can't know how many names will be supplied, you can't definitively declare your array (you'd have to constantly recast your array to a bigger size). If they use a massive array to begin with, then they should be docked points for irresponsible memory management (for the same reason that you'd dock points for memory leaks). While continually recasting the array is not impossible to do, it is contrived and it will take more time and effort to develop compared to using a list. If some students use the lists; the hardheaded others will see that their peers find the task much easier than they do, which will naturally incentivize to do the same. 

They'll probably use a hard cast, at which point the issue is no longer that they use object, but that they are losing out on type safety. The problem here is that an adequately skilled student who is ahead of the curve will always be able to work around simple pitfalls. If he is overskilled for the example, he has more than enough brainpower to ensure that his hard casts always work. The only way to force them to make mistakes is to give them a sufficiently complex example, where they're struggling with the core intention so much that having to manage hard casts on top of that just makes everything so much worse. But you may have to single them out for this complex task; which can in and of itself signal that they don't need to complete this hard task (since you can't just make tests harder for a particular student). The only guaranteed solution is to explicitly disallow hard casting in the problem statement. Any other (more implicit) approach is liable to be a cause for complaints when the student loses grades over this. 

The problem here is that every loop can be written as a loop. There is no real benefit to using a over a , the only benefit is the ease of reading/typing. A similar example would be LINQ, which is mostly used as shorthand for a foreach loop. In essence, every (in-memory) LINQ query can be written as a manually developed loop. That's technically not wrong (it only affects readability and increases effort required; it doesn't functionally matter). Currently, your students prefer to use a loop because it takes them less time to use something they know, compared to something they don't yet know (). I would temporarily ban the use of the loop (or force them to use , same thing), to force your students to familiarize themselves with the . After a few (iteration heavy) assignments, they should be familiar with how to use a . In the future, when they are familiar with both the and , it's up to them to decide what to use. Most likely, most will pick because it's easier and less prone to developer error. But the traditionalists who revert to using loops are not really wrong (though they may be docked some points for readability, if you grade readability too). 

Assuming they will have a career in C#, you're right to assume that your students will likely never have to make their own queue or stack. However, that's not the point of the lesson. The point of the lesson is to learn how to make a tool. 

As a teacher, it is your prerogative to be selective about what you consider a correct answer. However, if you are requiring a particular standard to be upheld, then you should explicitly mention this. If you ask your students for "an application that does [thing]", then you're implying that any working code is a correct answer to the question (which deserves full marks). If you ask your student for "an application that does [thing] and avoids string concatenation ()", then you've made it clear that working code that uses string concatenation is not a correct answer to the question. If you want to force a particular answer, you must phrase your question accordingly. Do not punish students for an implicit convention, because most students expect questions that reveal how their answer will be graded. 

The concrete example: Your student is right. At least, I agree with him, because I think of event listeners in the same way. When multiple callers register for the same event, and the event triggers, it "calls everyone back". Functionally, it's similar to how an array or list is processed, e.g. : 

So when you respond, make it clear that you understand what the student means, but it's not exactly the same in every way. For example: 

When you look back at "my" formula, maybe you'll see that the order of operations is the same as this visual example. Take the difference, split it in two, find what's in the middle. To me, it makes perfect sense, and I am considerably faster when calculating averages (of 2 numbers) this way. I reverted to using the more standard approach when math classes started requiring us to calculate the average of more than 2 numbers. But for finding the average of two numbers, I still use my own method to this very day.