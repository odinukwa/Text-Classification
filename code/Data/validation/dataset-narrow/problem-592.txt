Putting in s everywhere makes your code look somewhat cluttered. Instead, use Python's support for raw strings, in the form . Note the prefix before the double quotes. That's what designates the string as a raw string. In raw strings, each character is stored WYSIWYG, which means that linebreaks in the string are preserved. Avoid the burden on the user of the script for choosing the correct clear-screen command. It is possible to detect the OS in Python via: 

Type Coercion is not readable! Don't use implicit Boolean coercion of numbers in code which you claim to be "readable" - it isn't. Use proper comparisons in readable code, and leave the cool weak-typing hackery for the golfed version. How much does writing out the actual condition improve the readability of the code? Everything else seems to be fine - naming, indentation, and all. 

For , an algorithm is to do it the normal, C (pointer-based way). Traverse the list maintaining references to 2 elements, the current element and it's previous element. At the element to be removed, set the field of the previous reference to refer to the element following the current element. This would work far better with loops than and . Again, imperative and functional don't really mix well in the same part of the program. Take a look here for a reasonable functional singly linked list in Scala. 

Omit and keyword from interfaces, it is implicit. Be consistent with spacing out your syntax. You for example have , whereas it should be , some strings in your program also could have spacing fixed. Don't start instance variables with , perhaps this is common practice from another background, but not in Java. You seem to adhere camelCasing elsewhere though. Make parameters where possible. It gives compiler errors if you accidentally change the primitive or the reference to an object. Use generics, in you specify as , you want to use generics. If all types of objects can be stored, then use . I see that you have forgotten to declare the type of the variable, using Java 7's Diamond Operator, it would be , also notice that I define only as type, as you always want to use interfaces to declare types if possible. Give variables descrptive names, and are not descriptive. Lastly, I would consider using a for the in , the name implies that you want a queue implementation, yet you are using a list implemention. 

I wrote this code to parse dates from the output of the OCR, which means that the obtained date can be literally anything, so I put some restrictions in place: 

For every provided regex it creates a pattern and matches and replaces the occurences with the replacement. It is also important to look into now: 

Type-alias to and import it to reduce some visual clutter. Also do the same with by aliasing it to to reduce visual clutter even more. 

Style You have inconsistent indentation and spacing. If you are using some very simple text editor like Notepad for writing your programs, you might one check out editors with auto-formatting of code, or use an IDE. Also, you don't have proper whitespace surrounding binary operators. Finally, your variable names are somewhat nondescriptive, but in this case it would have been OK if you had properly documented your methods. 

ing source files A very big issue - especially if you're planning on writing a library: You include a C source file to use . You shouldn't do that to avoid possible name collisions between the ing file and the d file, as all of the advantages you had from the header guards are absent when you import the source file itself instead of the header. The header represents the public interface of the code, so always include that to avoid name collision issues and not depend on implementation details, like internal functions (not that you do that now, but for the future). The problem with doing this right now would be that you have not put your function declarations in the header. Declare in the header (I guess you already know how to do this, as you've already done it for ), and you're ready to use it from your main source - just include instead of . Weird and missing s What is that doing in ? as far as I could find out, it's for the compression library , which you don't seem to be using. Also, you should in to get standards-compliant behavior and compiler portability for the macros you use in . You should in your main file too, as you're using . The header guard is in to save you from the multiple-include problem. Style and Convention 

So, I'd suggest it'd end up looking something like (it's been awhile since I've written straight ADO.NET, so there may be some minor issues here): 

Now that we can see that we're looping over all the rows for each , we can change to traversing once and pick up any along the way. This effectively flips the order of iteration (I'm assuming there's more rows than query strings). To get rid of the nested loops altogether, we'll switch to using to find any matches. We'll also drop the check on each iteration for a single call at the end. That should keep us from iterating multiple times. 

If you're familiar with inheritance, hopefully you can see how you could add that functionality into a 'PersistentInventory' subclass. Hopefully, you can see by splitting the functionality out cohesively both readability and maintainability. Think through adding the following functionality in v2 of your app with the various designs: 

Well, you can certainly make it easier to read by cleaning it up a little bit and getting rid of the extra () loop, and substituting a and for the inner () loop's concatenation: 

Well, the calculator one at least could be simplified since you're always adding/subtracting the same: 

From a high level, I have to disagree with your class design and names - they're really modeled after your implementation (, , etc.) instead of your problem domain. I would've expected to see some classes such as , , etc. I won't attempt a straight refactoring - though there's isolated areas of code that could be improved on, the main thing that jumps out at me is the mix of concerns spread across all your classes. Currently, your classes all know way too much about and user input - you need to centralize that logic, and split into dedicated layers: UI, business, storage. Here's an attempt to walk through a design - which should hopefully give you enough to tweak the specifics to meet your needs. Any compile errors or bugs are intentional and intended for learning purposes. Just kidding - though I will take some shortcuts since MarkDown isn't the best IDE. Let's first extract out a class so we'll have something to work with: 

Via this mechanism it is possible to make a type implement a wrapper interface without writing boilerplate. It is more common in the form of than in this form though. Final words Lastly your code formatting is in need for some improvements with respect to indenting the anonymous classes, but it may be an oversight and the rest of the code looks great. When I have some time I'd be eager to show you a pure Java 8 solution as I strongly believe that Apache Spark is making a mess of your code currently. I do understand however that you need to operate with Apache Spark at some point and for that you may be forced to use Apache Spark's classes. My method using Java 8 As addendum I'll show how I would identify your problem in question and show you how I would do it. Input: An input file, consisting of words. Output: A list of the words sorted by frequency in which they occur. 

I decided to implement it using an is-subset-of approach, leading to the following stored procedures and functions as solution (I know about the 'missing' delimiter calls, but I think HeidiSQL silently inserts them): : The main stored procedure in question 

Now we have the , and here we decide to collect it into a . Here we continue with your old logic of having a counter attached to it. 

And why restrict yourself to arrays of ints? With generics, you could have the following modifications and make this rotation routine work with all types of arrays of objects (note that is not an object, it is a primitive type, you'll need to use , which is the object-oriented wrapper type for , instead of . Same goes for and other primitive types, you'll need to use arrays of their wrapper types, look this up). 

The relevant JavaDocs are here: a. Files b. FileSystems c. FileSystem d. StandardCharsets e. Paths in If you aren't using Java 7 and above, the recommendation is to put all calls inside the statement after all the es (the "Ye Olde" way). For this, your IO streams should be declared outside the try-catch-finally block. It could look like this: 

You have an unrolled loop, which is good for performance (especially because in Java the size of an is fixed to be 32 bits). However, you could consider turning it into a loop if this performance is not required, that would reduce code duplication. Which means that you could also try: 

You should handle the case of in if you're using s. All these gotchas are the reason why you should use for financial calculations. 

Suggestions I guess you are coming from a C/C++ background. Java arrays have a property called , which gives its size, so you don't need the parameter . Just use wherever you have used . I actually once thought that swapping the first element with every other element times was an original algorithm for rotating an array I had thought up myself, and it's in-place but this has a time complexity of . There exists a better algorithm working in time, which uses the idea: Instead of moving one by one, divide the array into different sets where the number of sets is equal to the GCD of and and move the elements within the sets. In Java, the code would look like this (note: This only does a left rotation): 

In reality there can be many pages, areas, paragraphs, lines and words. I have only showed one of each here for simplicity and because I cannot disclose full files, also note that the content of the word shown here is " ", a string of one space. A minor defect is that there are still some TODO comments which I need to transform to actual loggers. First the structure: 

The user script can be seen in action below, where it adds the "OLog Settings" menu and shows that settings menu. 

The code in general looks quite good, although it may be slightly over-complicated for the problem it is trying to solve! You can improve though by using a rather than directly adding two strings together: 

I am aware that the with a as argument is obviously much nicer, however for convienience the single-argument version with only a function is much better. 

Your code and Java 8 usage looks fine in general to me. I do see an issue with the class, it looks like you are intending it to be an immutable class, if so, then you should also enforce it. You need to ensure that the and fields can never be changed, you can do this by adding to them. Your code currently seems to be safe, but it is not. I can extend and offer a method there to change the and fields, which violates the assumed variant of that those fields in are immutable. Simply changing it to the following will do: 

I think a plugin architecture would be a little overkill unless you're interested in versioning or deploying the sub-modules separately. You haven't shown the sub-modules (the actual solvers) but I'd probably define an interface for them and then use a instead of the statement. Really, it's pretty minor, but I see a couple of advantages of the : 

Your unit tests for now only need to be concerned with the results of - which verifies the was constructed properly (an important bit to test, since it's weakly typed). You can dress it up with generics, extension methods, builder patterns, etc. - but that's the basic pattern. 

You can over the directly, getting a . Or you can over and just get the . Either would be preferable to going over the just to get to the (and you don't check the return of ). I'd also change the name of your variable since the trailing implies that it's multiple dictionaries (FWIW, I'd probably go with just just so I didn't have to ever read a potentially offensive word over the phone; but that's just me!) 

From there, any further optimizations would be heavily dependent on your data and would need some example data of the correct relative sizes to profile and test. 

That's not going to do a whole lot for performance (basically get rid of a rows iteration), but everything else I see is really context specific that may end up with worse performance assuming your data looks like I expect it does (< 10 , < 50 and thousands of rows). A couple of additional thoughts you can try, though, depending on your data: 

When an item succeeds to 7, it can be converted to a "32DR crystal", which can be sold. When an item fails, it will produce 1~15 Dazzling Ores and a Level 100 Chip. If the upgrade that failed was from 6 to 7, it will produce 2 Level 100 Chips. Upon failure the item is lost. To increase upgrade success, you can add 500 Shiny Crystals from upgrade from 4 to 5 onwards, which will double your success chance. My goal is to calculate the most profitable method (possibly negative profit, also called loss) given the price of the 29 DR item. Implementation-wise, I have decided for now to let it run on the console for ease of use and with a few variable parameters hard-coded. they resemble the price/value of an item in the game and that, because it is dependent upon players, may vary from day to day. It's just for personal use, so I do not think it is bad to recompile it every day. In the future I want to support multiple types of items and goals (upgrade levels) though, where the following details are variable: 

The usage: Note that the is not complete (but working) yet, I will put convienience methods in there once I need them. 

I would recommend all your classes to implement a static inner classes called and implement the Proxy Serialization Pattern on the classes. Some other ad-hoc review points of your current code: