The "NIC" Hardware just sends ethernet-frames onto the wire and recieves them. The operation-system has a "driver" to programm the NIC since that is a hardware-specific task. Then there is software in the Operation-system (modules in the kernel) which handles common "ethernet" tasks. It sends ethernet-frames of know type to "customers" which have an abonnement for it. The helper-protocol ARP is one of them, IP is the popular used one. TCP and UDP Modules are customers of IP. ICMP is also customer of IP (but IP also uses it as a "client" of icmp, that is a little bit confusing). All of them have programming-interfaces from the kernal to the user-application-level ( often the "socket-library" ). A Programms like a "webserver" runs as an background-application and connectes to the tcp-module asking for every ip-paket with Destination TCP-Port 80. A Programm like an Internet-Browser usese the tcp-module to connect to remote servers with TCP-Port 80, local Port does not matter here. When TCP/IP was created, the OSI-Model was non-existing, so the relations beetween the OSI-layers are not so clear as in newer Networkprotocols (appletalk, for example :-) 

The router is using proxy ARP. This is a feature enabled by default. Since the router knows how to reach the destination address, it will respond on the host's behalf with its own MAC address and all frames from the source will be sent to the router which can then route to the destination. Cisco Proxy ARP 

Yes you can, you just have to classify the traffic. Here is an example where we classify iSCSI into its own class. The class-default class will match any other traffic. 

QoS will apply policies to different traffic classes as it passes through the device, such as giving priority to certain traffic. But it does not signal to the transmitter to pause. Flow control operates at the interface level and will send a Pause to an upstream transmitter telling them to pause transmission (assuming they also are set up to honor flow control messages). This can affect all traffic passing over the interface. There is an enhancement called priority flow control which applies flow control based on CoS class. The devices negotiate this using LLDP DCBX and exchange their QoS configurations, if they match, then they can successfully use priority flow control between them. Overview of PFC 

You may use the following protocol (inspired by PPP over Asynchronous Links RFC), with two special characters IDLE and ESC. You will need about 2 bytes of RAM at the Transmitter and 2 bytes at the Receiver to maintain state information (plus two more bytes for CRC computation). Payload data are arbitrary, from 0x00 to 0xFF. Say IDLE is 0x7E, ESC (for Escape) is 0x7D. IDLEs MAY be sent by Transmitter at any time when it has no payload data to Transmit. When Transmitter wants to send a frame/packet, it MUST send IDLE, then the escaped (see below) payload data, then IDLE. As IDLE should not appear in frame data, we define a second special character ESC that will be used by Transmitter when it wants to escape data. IDLE and ESC itself will be escaped, at a minimum. When the Transmitter wants to send payload byte: - 0x7E (IDLE), it transmits two bytes: ESC followed by (IDLE ^ 0x40) [IDLE XOR 0x40] - 0x7D (ESC), it transmits two bytes: ESC followed by (ESC ^ 0x40) - other byte, it transmits the byte unchanged. Alternatively this byte MAY be escaped by ESC followed by (byte ^ 0x40), provided that (byte ^ 0x40) does not result in IDLE or ESC. The escaping formula (byte ^ 0x40) is not magic, it can be replaced by another. The important thing if that the result of the escaping formula is never ESC or IDLE. From the Receiver point of view, any data received between two IDLE makes a frame/packet. Receiver has to unESCape these data in order to get the initial payload data. It is of course strongly advised to add a (2-byte) CRC at the end of the frame/packet, just before the closing IDLE. This CRC has also to be ESCaped. CRC can be computed on-the fly, on a byte-by-byte basis. I have implemented this kind of protocol (precisely: encapsulation) numerous times, it's very simple, reliable and efficient. 

Now you can create a default route in the global routing table without interfering with the tunnel establishment. 

You can't route based on layer 7 application using only BGP. BGP features will only allow you to tweak the actual prefix advertisements/preference, not anything at layer 7. For active application inspection and policy routing you would need an external service provider to act as a reverse proxy for your public subnet. Then you would build a GRE tunnel from each of your ISP connections to this provider and they forward you the traffic down these tunnels. I haven't heard of anyone offering this type of application load balancing service, but it doesn't seem unrealistic since there are security services that operate in this same manner in order to "scrub" malicious traffic before sending it to your site. 

You have to at least create static host routes pointing to the endpoint IPs of your tunnel to make sure they remain established. Front door vrf is handy if your endpoint is using a dynamic IP address, forcing you to have a default route pointing out the internet circuit. Splitting it into different vrfs allows you create a second default route pointing down a tunnel. Edit: When you create a tunnel, you will have a source IP and destination IP for the tunnel. 

ACKs are useful in sliding window protocols, they allow Transmitter A to be aware that data sent has been received by remote B. Transmitter A can then proceed to send next data - until its transmit window is full (of data sent to remote but not yet acknowledged). ACKs may be considered more essential than NAKs. NAKs simply allow for faster recovery, in the case where a packet/block sent by A is not received by B, and B detects by some way that a packet/block is missing. It is perfectly feasible to design a protocol supporting reliable transfer and flow control only with ACK, without NAK (with retransmission by Transmitter in case Transmitter does not receive an ACK, retransmission mechanism that is needed in any case). 

Because the concepts defined by OSI model are useful for understanding real-world networks. OSI defines 7 layers, these layers (especially layer 5/Session and 6/Presentation) don't match well with the now dominant well-known telecom protocols (above and around IP) - the model should not be blamed for this. After all we can't say that the IP protocol stack is particularly well designed. The model defines a lot of very useful concepts, and distinctions to be made, in the analysis/understanding/design of any complex telecom system. For example: the notions of service and protocol; the notion of primitive (request, confirm, indication, response, signal); the notion of protocol entity and Service Access Point; the notion of connection vs. association; the notions of SDU (Service Data Unit), PDU (Protocol Data Unit), IDU (Interface Data Unit); etc. These concepts are extremely useful. Also, OSI model is still used heavily to define current protocols. For example ISO 11073-20601 and friends (Point-of-care medical device communication), used in medical devices (typically over Bluetooth) heavily use OSI modelling of Application Layer. Or the IEEE 802.xxx lower layer protocols (e.g. 802.15.4, radio protocol) - these use the ISO modelling of the lower layers. These protocols are recently designed and in use today.