Of course I didn't include the numbers in the description... I am sure there is a better way to do this. I just did a simple solution, where I add all the numbers and take the first 10 digits. 

I wouldn't create a new temporary map for each loop. Instead, I would create one outside the loop, and dump the contents of the temporary map into the map at the end: 

Your solution seems generally sound. I would make a few changes: You are surrounding your whole code in a try-catch block. Instead, surround the area where the has a chance of being thrown (Also, use to print for errors): 

Note that this is not the final result. There are a lot more to add before it's good. Now to the actual code... First of all... In the main method, there is this: 

always returns so it won't help you in parsing different line endings. If your task is to count the number of lines then it would be much easier just to do smth. like: 

Cache the instance of and objects so that you don't need to create them each time you measure the length of string. I've created a small test to see which part takes most of the time: 

Instead of sleeping for short periods or using it's better to use waithandles, in your case. I don't have Visual Studio at hand, but the following example should give you the basic idea (most of the complexity will be gone if you start using .NET 4 or 4.5, in particular ): 

You are still using the UI thread to do the project parsing , because will return the execution back to UI thread. If this call may take significant time, I would suggest to replace it with . It looks like you should get exceptions in , as you're updating the UI from non-UI thread. See the fix below. What you do with event is actually reporting progress. .NET has a built-in support for asynchronous progress reporting via and , which properly handles the synchronization with UI thread. See description of how to use them here: Enabling Progress and Cancellation in Async APIs Instead of and then you can just use the method to create and run the task. Don't use as it blocks the thread until all tasks complete. Use instead. 

I don't think creating a object is necessary. Instead, there is a method that returns a object, which stores all the necessary solution information. is now the overrided in . It seems slightly faster (2000 miliseconds -> 1500 miliseconds) 

And add your method in another class in another file called . That would look like (if you want to time it): 

The colour of your font, as well as the font itself (which has already been mentioned), makes the text hard to read. Try something more simple with the font coloured as black: 

This is just a short answer about the use of . It is almost always a poor option, as it is pretty much an array with helper functions. If you have an of 10000 integers, and then add another integer, will (if its current array it's storing the values in is of size 10000) create a new array, move all the values of the old array in the new array, then add the integer to the end. Sounds inefficient? Certainly does. My opinion is to use . is faster, because it works like this: 

This code is simple because it doesn't shut down the worker thread in case when there are no tasks. If you do need this functionality you'll need to add some more thread management code: 

What you have implemented is a sort of Active Record where the record itself knows how to communicate with the storage. What is bad about your design is that this kind of code will be extremely hard to unit test. Imagine that you need to write a unit test for a class that uses objects. How can you prevent it from calling ? The proper solution for your problem depends on use cases. 

You have put too many responsibilities in a single interface and class. Your interface knows not only about graph itself, but also about all the possible methods of traversing this graph. It breaks Single-responsibility principle, Open/closed principle (as you'll have to edit if you want to add more search methods) and Interface segregation principle. What you should do is refactor your interface and implementation so that: 

Even though it saves a lot of lines and typing, it's at the cost of performance and readability. Import each class individually. 

At first glance, this makes no sense. These numbers are more like magic numbers: make them a constant: 

The conventions say that each line is a maximum of 80 characters. You exceed that many times, especially because of a large amount of arguments to a method, or calling a method with a lot of arguments, or maybe some other reason. After formatting: 

This code seems to be a specific BucketSort made for a specific program. I would instead create a more generic BucketSort: 

where n is how many false you have. generates a number between 1 and n, and checks if it is one. It has a 1 in chance of returning true, just like what you have. This increases the efficiency and is much less of a pain to type. 

The program below is just for fun. Since the program asks for recursion, then in principle, recursion should be the sole iteration technique. Assuming that the requirement is to only implement a single function, and that is terminated, the following program illustrates how this is possible. Basically, the technique is to use the value of control the mode of the function. There are three modes: initial call, reverse each word, and reverse string. A positive signals the initial call, and represents the length of the string. On initial call, the program follows the algorithm recipe of: first reverse the input string, then reverse each word in the input string. A value of zero causes the function to find the beginning and end of the first word in the string, reverse it, and recursively repeat the process beginning after the just reversed word. A negative causes the function to reverse the string assuming its length is . The off by one length is used to make sure the string reversal case does not run into the word reversal case. Thus, a count represents an empty string. 

It is safe, but can be refactored using .NET built-in class. There can be several solutions depending on whether results of the execution can be cached. Simplest solution is when you can cache the results of the execution for the lifetime of your parent object. In this case the code can be as simple as (move initialization to constructor if is not static): 

Nice thing in participating/answering in forums like this is that you learn while you answer questions. I haven't heard about SpecsFor framework. Looks a bit tricky, but will definitely have a look later. Ok, back to your question :) About your first question, setting up the mock - you can definitely do that, there are a number of overloaded methods accepting delegate/lambda, depending on the number of parameters in the method being setup (here I setup the method to always return the same query regardless of the query passed: