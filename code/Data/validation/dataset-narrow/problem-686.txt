Although I do typically have a parameter on the script that lets me override the log file path if I want. And finally, I set a default value for the Path parameter of the function: 

You may have noticed that there may be problems if your CSV file happens to have duplicate usernames since isn't being updated. You should be able to avoid that pretty easily with either this: 

However, even then, isn't going to work here when files move within the directory structure. Example: 

Frankly, is such a good tool for this job and has been a part of the base Windows install since Vista/2008 that I would just use that instead of reinventing the wheel (especially when you're replacing a top fuel dragster wrinkle slick with an iron-shod wooden wagon wheel). Yes, robocopy only uses datetime (LastWriteTime) and file size (Length) to detect changes, but if that doesn't work you're doing something rather strange. That and the fact that is an awful command to work with because extremely unclear exactly what it's doing. However, from a quick look: 

In my experience providing or on strings is a mistake. Instead, strings should be constructed via one of: 

If you're using , you shouldn't have the shebang in the second script. If you're using the shebang, you shouldn't use . But rather than use directly, I would the script once at startup, and in it define a function that was called at the later times. You should use instead of to avoid forcing a separate subshell to spawn. I would provide a default instead of exiting if no argument is passed. Something like . Also, I always use named variables as early as possible. Note that if you were using a function (with or without ), you should use to avoid leakage. 

That said, your short-circuit if the lengths mismatch is a good idea no matter which implementation you use. There are some style issues that jump out with your implementation: 

This is great because this is a script-wide variable, so no matter where I call , the parameter is going to be correct. My try/catch blocks in scripts that I want a lot of detail in tend to look like this: 

And that's why I hate . You can't just specify or either, since it's got the root part of the path in the properties. You'll need to do something like this: 

This takes a few seconds to pull the data, but it's much faster for your script and much easier for your domain controller. Now when you test, you can just look in the to see if it's there instead of asking AD: 

Next, you can use the option with , which will make the command return the user object back so you don't have to ask for it later: 

Note that it does not return indirect subclasses, only immediate ones. You might also consider what happens if some subclass of is itself abstract. Speaking of which, you should be using and . 

Other answers have handled specific issues, mine will handle larger design issues. Some of my later advice is highly opinionated, but it is motivated by real design problems; be sure to understand the problem before dismissing it. 

Likewise, it is exceptionally rare that allowing mutation of a string after construction/assignment is actually useful. This makes the constructor nearly completely useless. 

Any memory that you read/write from multiple processes (or threads) must be protected either by some sort of mutex or by atomic operations with an appropriate memory order. It would not be enough to . So the following line may be optimized to be an infinite loop: 

After you create the user. Which you use will depend on exactly what properties actually returns. Most commands return both and , however. 

Your poor domain controller. If you're creating users with 2 groups per user, this is going to cause 6 individual queries to Active Directory for every new user and 1 query for every existing user. First, fetch your list of users first and save them to a hashtable for quick lookup: 

As far as I'm aware the above only compares file name. At the very least, you'll want to specify the parameters you're comparing with . It does not compare all properties like you might expect. You've got to specify them: 

PowerShell arrays are fixed in size. When you append an item to an existing array, PowerShell will create a new array, copy all the items over with the new item, and then delete the old array. This will work fine up to a few hundred small items, but it becomes a noticeable problem as the size of increases. It gets exponentially worse as set size increases. What you want to do instead is something like: 

The point being that you should be setting the variable in advance of the loop, not resetting it afterwards (that being a pointless operation on the final iteration). I would probably also move into a class member, calculated in the constructor. 

Note also that now that the loops are the other way around there's no need to pre-create the objects that make up the array - it's initialised with an empty object in the first line of the outer loop. 

I tried using the identity to remove one trig call (by replacing it with a call) but it was slightly slower. Using this loop instead, based on an idea from @alpehzero using the two following trigonometric identities: 

only extract the length of the arrays once per loop, instead of per iteration deference deeply nested structures earlier, and as infrequently as possible 

By the way, \$O(2n)\$ is equivalent \$O(n)\$. However, the bound is actually tighter: \$O(n + m)\$, where is the number of distinct elements. This is, however, an average bound, because it relies on a . If the worst case hash collisions happen, you get \$O(m(n+m))\$ 

There are a lot of functions that aren't safe to call in a signal handler. For the few that are allowed, look at the Async-signal-safe functions section of the signal(7) man page. Your current signal handler is almost okay, but any variable that might be changed from a signal handler needs to be declared . Officially it must also be instead of , though I'm not sure how important that is on real-world platforms. You should be checking the return value of and . They will return (which is usually but could theoretically be any negative number) with set to if the signal has been delivered during the underlying system call. That said, there is nothing to prevent the signal from being delivered before or after the syscall itself (before is the nasty case, and doing the syscall yourself won't help unless the signal is blocked around the call). If you want to handle signals in any sort of sane way, you need to them, at least some of the time. Either then unblock them during "safe" runs of code and check the flag periodically or else leave them blocked call (which will not invoke the handler).