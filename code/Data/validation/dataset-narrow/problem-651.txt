This will cause the loop to terminate when a 0 is entered in the input. This behaviour does no match the assignment, and hence it represents a bug. Based on the assignment, you should only terminate when input ends, which will be correctly caught by the loop. The line should therefore be removed. Related, your after-loop test for is incorrect. If the loop is (correctly) terminated by being unable to read more numbers because the file has ended, both and will be set on . The condition will therefore fail. You might want to augment the condition to check for EOF: 

Also note that I added a call to into the waiting loop. Your previous code was leaking the threads. You're writing C++. Don't use (type unsafe!) C I/O. Do this instead: 

Loop logic There's definitely something strange going on with your looping. Why do you have so many checks on equalling zero? Why do you ask for account number in multiple places? As it is, it's hard to even answer that by eyeballing the code, because it's so bulky. So let's start by pulling some things into methods: 

Let's address these one by one. Seconds As you can see from the description above. Seconds are really simple. We really only need to decide whether they're greater than or equal to 30, then we can forget about them. But look at how much complexity they have in the code: 

This is a generally good solution. Pretty good adherence to naming conventions, and generally quite easy to read. It's probably just fine as it is, but if you do want to make it better, there are some improvements that can be made: Extracting the outermost method First off, we have: 

When printing this message, you should consider returning 1 (or ) from , instead of allowing fallback to the default success. The outer could be removed. If the file is not open, will fail, and you would at least print an error message instead of failing silently. is a very non-portable and extremely cumbersome solution looking for a problem. You're calling an external program just to wait for a key press. You should get rid of it altogether: your program is not interactive at all, it could run just fine as part of a script. Requesting input like this ruins that. Just drop that line altogether. 

One thing I am aware of is that the code does not handle trigraphs; they are somewhere near the end of the to-do list. 

So, looking through those options, you'll probably see that in your case, generally the best one will be the last. This will actually have the opposite effect to what you were worried about. Not ing means that your (for example) won't silently fail and return , instead it will cease operating and the exception will keep bubbling on up. On the other hand, if you do surround it in a block and leave the empty, that would silently gobble up the exception, and that's where you're at risk of getting weird, hard to debug behaviour. 

Okay, hopefully that's convincing. So the change is simple, as I suggested, just delete the , and fields, and the constructor overload which sets , and change the signature of . Static? You're now left with just two members: a parameterless constructor and the new method. In fact, an empty parameterless constructor isn't needed now that the other one is gone, so that can be removed too. And at this point you might think that perhaps you should make the method- or in fact the class- static. There is, after all, no preserved state, and nothing instance-specific that's required. Well, this is often a judgement call. Here are a few things you can't do if it's static: 

As far as performance is concerned, there are no problems in this code. It's using C++ streams in the idiomatic way, which is good. If you're experiencing performance issues, you could try detaching from C streams at the start of your program: 

The names and don't say anything about the variables' use. I had to read through most of your code to figure out what means. Always use descriptive names for your variables, at least for those whose value is supposed to persist for extended periods of time. I would be willing to accept the , as it is basically one-shot, but should be renamed at least to or or something more descriptive. Your looping and termination logic seems odd. You are using the correct construct , looping while there's valid input left. But then you have this block: 

Logic Since this is a bit unusual, a quick overview of what's happening. There are three main states the trampoline can be in, corresponding to the three methods that can get called from : 

Note that now I've removed from the name- it's now the responsibility of the passed in to decide if it's unique or not. I'll leave implementing for your 'color offset' version as an exercise, it should be straightforward. 

Then you can just call at the top of methods which need that validation. Using Exceptions Your approach, using an exception in the case of trying to perform an action between points of different dimensions, is good. But what you've written about it is actually a little contradictory. So trying not to move too far outside the realm of a code review, here's some advice about how should use exceptions. As a basic review of exceptions, when an exception is thrown from a method, that method immediately terminates and it is passed up to the next method in the call chain (the one that called it), and continues being passed up until it is caught. So let's say I write a method which calls , and I know that can throw a particular exception. My options are more or less as follows: 

Indentation in the post-loop conditional is inconsistent with the rest of the program, and should be fixed. The same holds for the block (unless that was just screw-up of the code formatter here on Stack Exchange). The return value of is interpreted by the operating system as the return code of the program. On all OSes I know, 0 indicates success, non-zero indicates failure. You should therefore return 0 on successful program termination. Or just omit the altogether, is implied in the function in C++. Or, if you want to be really beyond reproach, and comaptible even with OSes where 0 does not necessarily mean success, you can change it to ; this requires . Error output (such as your message) should be sent to (standard error stream, usually file descriptor 2), not to (standard output stream, usually file descriptor 1). A more helpful error message would be in order as well. Something like 

See how we've separated out this question from any concern of what exactly the seconds are, or- even more irrelevant- what the hours are. Hours And finally, the hours! In your code, you try to do things in a very mixed-up way, in which AM and PM checking is all jumbled up with subtracting 12, rounding minutes, and so on. There are a few steps here, but actually we can address them quite separately as long as we do them in the right order. Here's what we need to do, and note how each task may be dependent on tasks before it, but not after it: 

I'm a bit confused as to how you're getting 83%. is giving you the minimum value of , whereas from your problem statement you are supposed to be returning the index that gives you that value. Generally, with that and the improvements from Daniel Mann's answer in mind, your approach is good. With a question like this, there's not much "clever" you can do to improve performance in even the average case. Divide-and-conquer type techniques won't really work because you can't evaluate how useful a segment of the array is without just iterating over it, and by then you haven't saved any time. For example, you could terminate your loop early if the difference between your current result and your best result so far is greater than (1000*the numer of remaining items in the list), but it's highly questionable whether that situation would arise often and early enough to actually improve performance on average. 

You don't need to convert an object pointer to , a is sufficient for that. Don't use stronger casts than necessary. You can simplify the assignment to and make it more obvious by assigning the result of the placement-new into it: 

Here's the first functional version of my Python 2 script for processing comments in C++ source files. It's a personal project, I expect to expand it later with more advanced options (mainly about replacing comments with whitespace or marking their original positions in the comment-only output). It's also intended as a learning excercise. I am self-learned in Python, my primary language is C++. So the core of my question is whether the code is "Pythonic" and if not, how to improve on that. I don't want to "write C++ with a different syntax," I want to (learn to) write proper Python. I will of course also welcome any other comments (general style, efficiency, safety).