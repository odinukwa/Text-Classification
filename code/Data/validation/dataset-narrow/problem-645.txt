Not every method has a self-describing name : What does it return? Object Length, Current Line Length, ...? I recommend to rename the method to what it does - . 

Variable definition You sometimes define variables in camelCase and sometimes with underscores. I recommend to use one spelling type only. PHP If function is not part of a class consider developing a database class that handles it. Another option is to add a function to each of your Model classes. This makes your code easier to read. For more details check mvc pattern. In the function you establish a new database connection with each call. You can avoid it by promoting the function to a proper class and define a global attribute holding your database connection. JS In your javascript you have html code. I recommend to either load it with rest of the dom and hide it by default or load it using ajax. I personally compare it with inline css. HTML In html form you have an attribute . It should be in a javascript file. I compare it with inline css as well. "QUOTES" Also see CodeX answer. As tim mentioned and other variables not provided by yourself have to be validated and parsed by htmlspecialchars e.g. to avoid XSS. A bit about security I've added this section due to mentioned XSS. Security is a very complex topic and must not be underestimated. There are a lot of options to implement and grant security. What kind of options you choose depends on your time/budget but also kind of project and data that are going to be stored in your database. I kindly ask you to think wise about the data that will be saved in the database and make researches about proper security measures. There are a lot of PHP Frameworks. I recommend to take a look into some of them as those provide security standards. 

Sample usage: This function is called, when I set a value in a field. It goes through all fields, that would possibly be influenced by this field (same row, col or block) 

I'm a few years out of RoR, but worked for a company that was heavy on testing an we used RSpec. In a case like this we would have tested some additional points, mainly about the content of the response. A few lines like (syntax may be totally wrong, as said I'm out of this): test the amount of records @programs.should.have(30).records then there was a command to test if certain records are in the result @programs.should.contain(...) this requires fixtures of course. The idea behind this was to make sure we could replace a certain plugin against a new one and be sure it doesn't break anything or contains bugs. (For example the acts_as_taggable plugin had a bug that made it impossible to delete tags, thing was running into an infinite loop) And of course to avoid programmers to make changes while testing in the browser or similar. With will_paginate a typical bug would be to set the pagination to 10 to see several pages in the browser (because there are only 20 records in the fixtures...) and forget to set this value back to 30. And if it's not the programmer, then maybe the guy working on the HTML/CSS. We made sure every of those details were tested More tests would make sure that the right file would be used for rendering. something like response.should.render_template(name) This seems to be a lot of work. But on the positive side: When my first web site for a customer went online, after six weeks of programming and my humble 3 months of knowing about Ruby on Rails, it had no bugs at all and stood 1.000 hits/minute without a single line of code to be changed. 

Do nullptr checks In some functions (e.g. ) you pass a pointer while you're never checking if that pointer is actually valid. If the pointer cannot be invalid, pass a reference instead. If the pointer can be invalid, get some logging (use some form of asserts). Watch out for integer divisions 

has lower precedence than , so in this case it is correct, but it may become wrong if you use another operator (such as bitwise operators) and it is confusing to read. So just add them! 

The comments from the other answers are valid as well - try to avoid copy pasting. If you ever have to copy paste something try to think if it can't be made into a function, macro, class, ... 

I want to be sure my parameters and base object will not be modified. (If calculating if two rectangles intersect requires non-const parameters (so possibly changing that rectangle), something fishy is going on). The general rule should be to mark everything as const unless it is inpossible: 

Script is terminated in the constructor The script should not be terminated in a random class but by an . The type of the exception decides wether the script has to be terminated. Commonly a leads to a termination. Possible Route class 

Each class belongs in an own file It seems to be overhead but remember: Each class has one task to solve and the same goes for files. In small projects it does not matter that much but as soon as a project grows it helps a lot. My namespaces are similiar to the path of the class location. As of this I know where every class is located - everytime I instantiate a class. Namespaces If you have not read yourself into namespaces I recommend it. Namespaces combined with an autoloader are a great way to make your daily developer life a lot easier. When using an autoloader you have another reason for having one class in one file. further aspects 

If you don't, the destructor of the subclass may not get executed if you're working on the interface. Be consistent in naming conventions It seems that you use the prefix for members and prefix for parameters. That's probably a good idea but be consistent 

Another tip is to use lowerCamelCase for variable names. Try to avoid useless comments Comments such as inside of a constructor don't say much - the syntax of the language and/or name of the function should be good enough to describe simple actions. Comments are very valuable, so feel free them on places where they are useful (in complex methods), but don't add any that add nothing. Use nullptr over NULL NULL is defined as a zero, which can also be considered as an integer by the compiler. This can get some weird issues when you have a pointer and integer overloaded function. Pass arguments by const reference where possible If an argument has a complicated copy constructor (e.g. if it has to copy memory (such as ) or has to do atomic operations (such as increasing a refcount)) 

So please tell me, if something like this would be "acceptable" (not to mention "best practices"), even if it somehow takes a very free view on the iterator concept. And of course every idea how this could be improved is welcome. PS: I tried to add a tag "iterator" but I'm not allowed for too few reputation. 

Please have a look at these iterators which I use for my Sudoku solver. They behave slightly different from STL iterators and don't implement all functionality that would be needed to use them in a stl context. But the basic idea behind them was to clean up the code in the Sudoku program that makes heavy use of the three access patterns (row, col, block) that I implemented. The most "important" iterator is the BlockIterator, since without that iterating over all nine fields in a block looked quite ugly. Iterating rows and columns wasn't that bad, but since I started writing the stuff I decided to create a complete set. Some technical details: The grid class holds an (evil) array of pointers to Field objects, that's one dimensional (I could have used a two dimensional array as well, but I often do it this way and feel quite comfortable with modulo operations). Maybe I will replace this with a vector later. The grid class adds a few static functions to calculate offsets in the array based on row, col or block positions. 

Description: This section describes missing setter, multiple returns and if-conditions. In the constructor of the class Route are multiple returns. This makes the code less maintainable. Having more than one return means there are multiple scenarios when the constructor can be stopped. In case of a bug one need to debug through the whole method to figure out the return-point. So, at this point a switch to if-else-if-else should be performed. Below you see a minimalistic sample. 

There are multiple returns in one method This makes the code less maintainable. Having more than one return means there are multiple scenarios when the method can be stopped. In case of a bug one need to debug through the whole method to figure out the return-point. 

Classes are included manually Instead of including classes manually it is recommended to make usage of the autoloader function ($URL$ The advantage is that you don't have to worry about including a class.