There has been a lot of work put into low-latency audio frameworks - for example Windows' ASIO, and Linux's JACK. These typically involve removing layers of abstraction, reducing buffer sizes, etc... Media playback is just about synchronising the audio and video elements, the buffers can be huge so long as the playout is coordinated correctly. Gaming and Pro Audio Recording require streams to be built on-the-fly depending on external factors like user input. 

"Is it safe?" (i.e: will it burst into flames?) - no, it shouldn't "Is it safe?" (i.e: is it a safe (sensible) place to store a BIOS password?) - no 

This implies that to be "fully compliant", the connector must be mounted with the "empty side" (as you put it) at the bottom... in relation to the PCB's top/bottom. I say implies because I can't see any specific claim that to be compliant, you must use these orientations, and in fact the USB 2.0 spec omits the example PCB footprints entirely. 

Things will still probably go wrong if the process tries to from , so if you explicitly want to disconnect a running process, then either make sure that is pointing at or similar, or use ahead of time. 

If instead you are concerned that the NAS enclosure is dying, but are happy that the disk is okay, then follow along below. It looks like your NAS was using the first 6 partitions to store information (possibly OS / configuration / etc...). These are likely superfluous, so don't get too concerned by them. The last partition (929.6 GB) is likely where your data is. You could try right-clicking on the last partition, clicking and then Adding a drive letter (mounting the filesystem) - it sounds like you've tried this. If this doesn't work, then it is highly likely that the filesystem is not supported by Windows - quite possibly . It is possible to mount filesystems on Windows, using the project - latest installer here. NOTE: The MBR/GPT will identify the Partition's "Type", which in the Microsoft world tends to identify the filesystem... the Linux world tends to use magic to identify data types, so most/all filesystems are marked as . I don't know of a good way to identify which filesystem is in use from Windows. 

Bond wires within the chips - connecting the packaging to the die Chip on the PCBs PCB traces Sockets on the PCBs Connectors on the wires The wire inbetween 

If you have a look at the datasheets for devices that interface with high speed signals you'll see information on the trace lengths from the chip's pin to the die - matched length signal paths and matched impedance throughout are also very important to assure the signal's integrity. 

(aka Hang-Up) is a signal that is given to a process to inform it that the other end has 'hung up'. I appreciate that this may be an arcane concept... but in this usage, it informs the process that the SSH client has disconnected, or informs a child of that has quit, etc... If a process does not explicitly handle , then the default action is to terminate it. Thus asking not to send a to one of it's children will effectively allow it to run after the shell has gone away. 

My phone will merrily scan the network (using Fing), discover the host, and ping it... as mentioned before, PC 1 will not. I've tried adding PC 2's address information to PC 1's ARP table by hand: 

The bottom of this bracket should fit into a slot in the chassis to further ensure correct alignment. This side-view graphic, courtesy of Samtec shows the spring-loaded pins (I've colored the pins): 

Here, and need to be swapped for the relevant disks - e.g: or . Additionally, needs to be replaced with the IP of the first computer. This will transfer the data directly between the two M.2 drives. 

To poke further issues at your question and setup, is reserved for multicast addressing. If you are using this for any other purpose, then you may (will) run into odd / unexpected behaviour. 

Many commonly used filesystems such as FAT, NTFS, ext2/3/4 do not ensure the integrity of the file data (for example with checksums)... this coupled with the real threat of bit-rot can lead to the situation you find yourself in... Data is returned from the hard disk without error, but it isn't correct. There is a useful wiki page comparing filesystem features here - for your use-case, we are interested in the "Data Checksums" column of the "File Capabilities" table, here. At the time of writing, the list of filesystems that checksum the data (and that you may plausibly have access to) is: ZFS, Brtfs, ReFS. Using a more modern filesystem such as these allows better resiliency against bit-rot. I can't comment on the others, but use ZFS extensively myself, so that's where the rest of my answer will focus (specifically on the assurance of data, ignoring many other useful features). Single Disk / Stripe Using ZFS with a or pool (many disks with no dedicated parity disk) provides you with the peace of mind that if data is returned, it is correct. If the data cannot be read correctly, then you will see an error. This is achieved by storing a checksum of the data as well as the data itself. Note, that even with such a pool, the ZFS property may help with simply assuring data integrity - however it provides no benefit with regard to device failure, so I would advise against its use. 

On Windows you can drag the monitors around in "Display Settings" to arrange them as appropriate... You can even offset them along an edge: 

If the Root Hub has the bandwidth between it and the processor, then the total bandwidth on the ports will be able to exceed the USB 3.0 bandwidth. However, if you have a Root Hub connected via a single PCIe lane, then the bandwidth would be constrained by the PCIe link (still only 3.9GB/s for a single lane gen 5 link), and thus the two ports would only have ~3.9Gb/s to play with. A similar effect may be in play due to the H110's DMI2 link (5 GT/s) to the CPU vs. the Z170's DMI3 link (8 GT/s). 

I've never seen anything to 'fill' the remaining space, and I would advise you to avoid this so that you don't damage the pins. There are other design features that should ensure a good and accurate fit. Remember, a "tight" fit does not necessarily mean a "good" fit. In this case the pins are spring loaded to provide a good contact with the card-edge connector, and it doesn't typically feel "tight" - especially with the lower pin-count cards. The key in the connector should ensure correct horizontal alignment, such that the pins and pads aren't misaligned: