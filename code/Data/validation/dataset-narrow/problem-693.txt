The result is the same because you're truncating anyway. Model View Controller (non-)separation Your class mixes all three of model, view and controller. It is very desirable to keep these separate. What I would do is to separate everything that has to do with the game simulation: , , the etc and put into a new class . Next I would separate the UI design from the class and put it into an FXML document that describes the UI. Then I would have a separate controller class for the FXML document and leave the application class just as a pretty basic launcher. If what I just said sounds like gibberish, have a look here: Model View Controller. Using FXML would allow you to create your event handlers as member functions in the controller instead. So you would have: 

For almost all places where you might consider you can probably do something better by fixing your design or using the other functionality of . 

Although it may look a bit funky, one of the key ideas is that once the is constructed, will never change for that instance as the address of will not change, this guarantees alignment. In other words, not assigning in the assignment operator is intentional. 

Oops I realize after writing all this that the above example code misses some functionality that OP's macros have. But it solves the motivational example that was given to get the index and value during the iteration of a range based for loop. 

Okay, first off. Please post the whole code, preferably in a runnable example. There are many things you can do to improve performance. Prefer Contiguous Arrays Defining a 2D array as is not optimal as it is "arrays inside of arrays" (i.e. the outer array is an array of pointers to the inner rows/columns) meaning that you will get an extra indirection and possibly a cache miss on each element access. You should create one contiguous 1D array and index into it based on x,y. Like this: 

As you said yourself, this is syntactic sugar. But your sugar may be my vinegar as I'm not a python developer. In any case, these are largely my personal opinions. Take with a grain of salt. Without macros First of, I'm aware of the fact that this is not a typical review response so feel free to mod me into the ground. However based on a comment by op, I felt compelled to give this a shot without macros. 

I don't have much time to give right now but I can offer one comment on the API. I would replace this: 

Use Guard Expressions The proper way to do this is to use Guard expressions. If you have a number of conditions that need to be true before you take an action. You don't check them all in a nested manner but instead check their negations one and one and return/break if you find any condition that is not met. Example Instead of having: 

Don't preemptively optimise Have you measured your application and have hard evidence that this command queue is the bottleneck of your application? If not you're just wasting time and creating bugs trying to write this complex class. I recommend that you take a simpler approach using standard library algorithms and functions and model the behaviour you want. If at a later point you get profiling data that points out this class as a bottle neck, then you can optimise. In summary I see that you are trying a lot of tricks that you think will improve performance. In reality these do no improve your performance, in fact I'd be willing to wager that you are in fact hurting your performance instead. Not only that but they are making the code hard to read and hard to work with. Stop trying to be clever, you are hurting yourself. Write clean, maintainable code instead. The compilers today are pretty darn good when it comes to generating good code. Most likely they are way better than you are. 

Turning my comment into an answer by request. You should be able to do what you want by simply using the functionality already built into LibGDX. Caveat: I have not tried this, I just know that the class exists and it should be possible to extract the data you want from it, so: some assembly may be required on your part. LibGDX has functionality for loading and dealing with bitmapped fonts. See the documentation here. You can use the class to load the font data. It supports AngelCode BMFont formats. Hiero which you are using can output to BMFont. Create a new instance of the : 

You should never specify which specific implementation of you want but rather that you want a "list" or even a "collection" of positions. See Liskov Substitution Principle. This is better: 

The raw array is actually faster as this code only performs \$O(n+m)\$ work which is less than \$O(nlogm)\$. Yes it's not as "generic" as the template method and won't work for all . But it doesn't need to be able to do that for the task. One could solve this using as well, and the big O time is the same: 

Hard points and maximum weight is defined by a chassis. Each chassis has different characteristics when it comes to movement, hard points, and other constraints. Upgrades A mech can have so called "upgrades" which affect global properties of the mech. For example the internal structure can be "standard" or "endo-steel" where endo steel is a space/mass trade off. Similarily other upgrades for mech's cooling, armor and missile guidance can be installed that will affect the performance of the mech. Modifiers and weapon groups It is worth noting that many attributes of items and the mech can be altered by modifiers. These may be anything from special equipment that enhances some properties of other equipment, to player level (called Efficiencies) based. Weapons can also be grouped and fired in groups. This is a vital part of game play and effective piloting, these weapon groups are modeled and statistics are calculated per group. All of the above, weapon groups, player skill levels (efficiencies), upgrades, equipment, armor distribution, modifiers and chassis make up the loadout. Problem with the code The class I have for representing the loadout has grown organically over several years from what started as a small class to something that is turning into quite a beast. It has been complicated by the fact that there are two types of chassis with slightly different rules for the loadouts: Omni Mechs and Standard Mechs. Which was not originally thought of when the class was designed but has been added in as an after-the-fact. Omni Mechs have fixed equipment that can't be moved and fixed engine and upgrades, but they allow you to change between several "omnipods" per component that alters the set of hardpoints the component supports, giving more freedom in design. I'm happy for any feedback, but I'm mostly interested in suggestions for how I can manage this unwieldy beast. If you need to see the rest of the code, it is available in the github repository linked at the top. 

I'm not that great with php but to me this looks like you're blacklisting tags. This is not an approach I would recommend as it is easy to miss some tags or combinations of attributes. Instead I would recommend to use a white list of tags that you allow and block everything else. This is more secure as if you miss to white list something, your users will complain and you can fix it. Xss attackers typically won't inform you if you forget to blacklist a tag and have a vulnerability ;) And you are also automatically protected from new tags and attribute combinations. Or you could simply strip ALL tags or html escape the entire body. 

Express your intent as clearly as possible, and let the compiler worry about generating high performance code. Compilers are pretty smart... Always, always, always measure. 

Calling will result in at most recursive calls, which is still a lot, but less than your code. But here is the catch, is very simple in structure and the compiler can expand the function in a way similar to loop-unrolling which removes a lot of iteration and overhead. This is a case of K.I.S.Silly. One way that both of the solutions can be speed up dramatically is by using Dynamic Programming, like this: 

I have also encountered the lack of magic statics for MSVC < 2015. I initially used a similar solution (using and a ) but it encountered a bug in MSVC 2013. When contained a that was not joined and the is destroyed on program shutdown, then the destructor of will hang waiting to join the thread which will never happen and the program remains alive. This is a known bug: std::thread::join() hangs if called after main() exits when using VS2012 RC My solution to this was to simply leak the instance as there was no way of safely destructing it and just let the OS deal with it. As for your code, it's spelled "Singleton" not "Single Ton". Also use a class instead of a struct and make the members private. Otherwise can be used instead of which you intend. I would also make static so that you just need to call .