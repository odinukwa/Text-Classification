The quick answer is: Both. The human brain is very good at recognizing axis aligned repeating patterns.. Very very good.. however, rotate a textures repeating edges 30-60 degrees and you will find it hides the repeating edges very well. Now this is more of a discussion for 3D environments than 2D but the same basic principals apply. If you can make it so your the repeating edges of your Texture are NOT the same edges as the repeating edges of your tiles, it will make them a bit nicer. Another way that this is accomplished in the realm of 3D is multi-texturing. Now this is a much easier thing to do in a 2D environment. Adding in multiple 'tile layers' that render on top of each other would achieve a more varied set of tiles with out requiring a significant amount of new tiles to be created. You would want around 5 layers or so total, 3 layers that are completely behind the player and then 2-3 layers that would render on top of the player, or objects in the scene in general. The farthest back layer would be the most repetitious and would be the generic surface you are walking on (I am assuming from what your question said that you are a top down or angle down view of the environment like Diablo or so). The next layer would still be commonly repeating but would make each area a bit 'different'. This could be collections of loose rubble, piles of bones, monster tracks and things like this that would be on top of the floor. The third background layer may or may not be needed and would be mostly for specialized tile sets, like a trickle of water or the like. The foreground layers would be used to add a bit more uniqueness to your view. You could have a character walk behind hanging lamps down the corridors, cobwebs that hint at a large number of spiders in the area or even a completely obscuring object such as a roof brace or the like. Now the answer is both in that as soon as you have adapted your tile engine to allow multiple layers like this, you will need the artwork to fill both of the layers.. And the key for the artist will to be to create the basic patters and the unique patterns that can be used together in multiple combinations and still look good (and not completely suck up all the memory you have to work with :)) EDIT: From the comment given this gives an entirely new approach, hehe. What is said above still applies, but since we are dealing with large heights (perception wise if we are flying :)) you might benefit from a bit of parallax scrolling (where the tile layers do not scroll at the same rate as each other). This would potentially give you the ability to do deep crevices, or a break through the cloudy sky you are flying through to see the world below. As for the complication implied, its really just a repetition of what you are currently doing.. Instead of rendering a single set of tiles at a time you will do it a few times.. It should not be too much of a stretch from where it sounds like your current game and engine are :) Anywho, hope this was enough of an answer to help you progress or at the least have new questions to ask. Enjoy! 

It sounds like you have every component type potentially in a single list. I would suggest that you split the lists up so that like components are in their own list and potentially within their own management system. This would then allow your manager to do any sort of global prep work, like call .Begin() before then processing (OnUpdate()) all of its components. Also, remember that just because everything is a component it does not mean every component has Only the component interface to its data and/or logic. The Update call to a Rendering component for example might just simply update animations if need be before the draw calls are done. 

I then just fwrite/fread the data to and from a file using the basic File IO values. The inventoryCount is the number of Item structures that are saved after the main SaveGameData structure in the file so I know how many of those to read after fetching that data. The key here is that when I want to save something new, unless its a list of items or the like, all I have ever have to do is add a value to the structure some where. If its a list of items then I will have to add a read pass like I have already implied for the Item objects, a counter in the main header and then the entries. This does have the downside of making different versions of a save file incompatible with each other with out special handling (even if it is just default values for each entry in the main structure). But overall this makes the system easy to extend just by adding in a new data value and putting a value into it when needed. Again, quite a few ways to do this and this might lead more towards C than C++, but it has gotten the job done! 

The simple answer to your first question is Yes, you are over engineering the design. The 'How far do I break things down?' question is very common when the next step is taken and the central object (usually called an Entity) is removed. When you are breaking down the objects to such a detailed level as to have size on its own then the design has gone too far. A data value on its own is not a component. It is a built in data type and can often be called exactly what you have started calling them, a property. A property is not a component, but a component does contain properties. So, here are a few guide lines I try and follow when developing in a component system: 

I am not 100% sure what you are asking, but from this post and the other one here is my guess: It sounds like you were selecting which type of NPC the NPC should be during the update for the object. This would be why it constantly changes every frame. What you need to do is find a place where you can set that value where it will only be set one time. This is probably what your friend meant by 'outside of the loop'. If you can more clearly describe what you are seeing as opposed to trying to explain what you are doing, it might help be able to refine this answer more. 

There are probably a large number of ways to do this, but the simplest that I always found and have used both personally and professionally is to make a structure that contains all of the values I want saved. 

Correct me if I am wrong, but I believe what you are asking is that you have a bullet moving in a game with a fixed timestep and that when the bullet collides with something, the time step usually makes the bullet go Past where it would have actually hit making it look like the bullets hit some where beyond where it actually hit. Assuming that is correct, this is quite easy to fix then. All you have to do is move the bullet back to where it actually hit instead of leaving where the timestep would have placed it if the path had been unobstructed. There might be easier ways to accomplish this but basically what you are looking for is where the line the bullet is traveling down intersects the 'face' of whatever it hit.. IE: You want to find out where your ray intersects the line of the object it collided with. Note that this is a calculation that should only be done after the impact has been confirmed. 

While I have not heard the 'do not use templates on a console', I can maybe give a personal experience as to why people may say this. Working on a very memory limited console, you of course want the compiler to strip out unused code to compact the exe as small as possible. This actually gave us issues on one platform where the compiler would improperly strip out (or just never compile to begin with) pieces of the templates used for the objects. It did not naturally see that those methods were needed so when the run time would execute, it would crash. We fixed the issue, but this did cause us a bit of code bloat as we had to forcibly declare the template classes. This added a bit more to the code but it ensured that the code we did need would still be there but allow us to still run code stripping as a compilation option. Hope this helps. 

TCP and UDP would be the two choices for this and you will want to go with UDP. As for the Why part of your question, TCP is a 'guaranteed delivery' system, but its slow. For video games and where up to date information is a priority over ensuring the data gets there, UDP fits the bill. You will generally want to have an incremented Packet ID so you can ignore outdated packets to take care of them showing up in the wrong order, but this will suit your needs. EDIT: A bit more information on the incremented packet IDs. With TCP, you are not only guaranteed that the data is sent, but that it is sent in the right order. It will not try to send a new piece of data along the same TCP connection until the current one has been confirmed to be sent. UDP does not guarantee delivery order. So if you have an incrementing ID in the packet data and you keep track of that value, you will know that incoming data with an ID lower than what you have already processed is old data. In that way you can safely ignore that packet and just wait for the next one. Hope this helps.