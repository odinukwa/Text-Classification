Having as a beautified interface to seems kind of ugly to me. Is there a way to clean this up and join the two functions? Or is this a common pattern? How readable is this code? As its author, I find it hard to judge how (un-)pleasant this code is to the eye of a third person, especially since I have next to no experience in reading and writing Haskell code. What can I do to improve readability? seems very verbose to me. Is there a more concise way to implement it? 

This answer turned out to be kind of a massive wall of words. Most points I mentioned are opinion-based to a certain degree, so please take most of these as a 'Please consider...' instead of a 'Do!'. However, there is a single point which does have this imperative nature, the first point mentioned under Includes. If there is only a single thing you consider from this answer as a whole, please make it that point, since it severely endangers the validity of your program. 

These numbers have no, I repeat, no business to be where they are right now. This kind of one-class-does-everything scheme that your code follows is going to fall on your feet sooner or later, but rather sooner. Let us just imagine you keep working on the game and add more and more functionality. As of right now, you have about two separate default values per functionality, i.e. pairs such as and , and etc. Now imagine you add some functionality to your game that adds about five different new entities. That means about 10 new constants on average, just in this class! I hope you realize that this is not sustainable. Even now, there is no way to tell which constant belongs to which actual class besides guessing by name. In a year from now, will you still know what class corresponds to, or ? Maybe, but it is more than likely that you will forget some of these. Furthermore, if someone else ever has to or wants to read your source code, they will first be massively stumped, then irritated. So what can you do about it? Take a serializer-based approach. Usually, when you are writing simple game data, you will have objects corresponding to the current state you want to save. The solution I propose is to approach the classes of those objects and insert a method that writes an object's contents to an . To actually save, you just call serialize in order on all objects that need to be preserved. The second step is, of course, to add a similar method that takes an and creates an object from the values read. You then have a file parser read in the file, determine the block sizes, and call those deserializer methods. The big upside of this solution is that it is relatively easy to implement while allowing you to encapsulate functionality away where it belongs, not in a monster class like you currently have. The downside is that the separation of concerns is still somewhat suboptimal, since you now have what are basically parser methods in game state classes. This can be somewhat mitigated through use of the factory design pattern, for example. Furthermore, this method can become messy if the complexity of the savefile and the game as a whole grows too large, but I am assuming that that is not the case for your project (and if it is, you will have to put a lot of thought in how to handle this well, anyway). Other Tips and Tricks 

Fix your includes. Now. You need for both and , otherwise your code might not compile. Adhere to the rule of five. defines a copy and a move constructor as well as a copy assignment operator, so it should define a move assignment operator and a destructor as well. The same is true for , if you want to follow my suggestion for question 3. If not, you should remove the special member functions altogether. Related to point 2: Since you are not defining a destructor, you are leaking memory everywhere. Fix this immediately. Copy assignment operators should take their argument by const reference. If you take the other object by value, you incur an unnecessary copy, which is quite costly for a container class. Instead of manually writing out the default constructor for , you should add a member initializer to (i.e. ) and just the default constructor. When writing single chars to , use instead of (in particular, this applies to your use of ). The latter is likely to cause performance degradation. 

There is really no reason to save the whitespace, neither around the operators nor after the ; it only makes your code less readable. Prefer the C++ equivalents to standard C functions. There is no reason to use when does the job equally well but safer (what if you made a mistake in the format string?). There are times when is indeed the right choice, but simply printing a string usually isn't. Use your s. Why make a type called if you still pass a (instead of a ) to ? Declare variables in the smallest scope they are used in. Concretely, do not define variables in file scope unless there is a good reason to do so. , for example, should live inside . Having be an is overkill. There are only 10 distinct digits, so the smallest type that can take 10 different values should suffice (usually, that would be or ). Single-character variable names are terrible. , for example, should be called something like or . You state that you want your program to be able to work with "a generic target number, operators, and number of input". Currently, your program can do none of that, because you hardcode everything. You should read your numbers and targets at least from standard input. You can omit in ; the compiler adds it automatically. Do not use float for integer calculations (see Toby Speight's answer). 

Possible Optimizations Although generally your code appears to work well, there are some things that you could easily implement to improve performance, mostly to avoid unnecessary copies. While it is good practice to implement operators in terms of other operators, the way that you implemented your operation + assignment-operators incurs making additional copies of your input. For example, let's consider and : 

Making your Code more C++-y As you remarked yourself, your current code is not very much C++-like, but we're going to change that by making good use of the standard library. As you know, checking whether a string is a palindrome is equal to checking the to halves of the string for equality, only that the latter half is traversed in reverse order. Luckily for us, checking ranges of elements for equality is one of the things that are needed quite frequently by a lot of people, so C++ offers the very useful . , in its most basic form, takes three iterators: one to the beginning of a range of elements, one to its end, and another one that points to the beginning of the range the elements should be compared with. The only problem here is that we actually need our second range to be iterated in reverse. Again, the STL comes to our rescue. There is , which, who would have guessed, allows iterating in reverse order, and also , which is a member function of that returns a reverse iterator from the end of the string. Combining these, we get 

You have no guarantee that this code will terminate soon. You could be spending a lot of cycles here just guessing at the right answer. Again, I do not know where your class comes from, but doing big integer arithmetic fast can be kind of tricky. Should one of the slowdowns come from your use of this class, I would suggest you switch to a well-tested and well-acclaimed multi-precision library instead (such as GMP, for example). 

Where are your includes? Your first file is missing the includes for and , your second file for , , whatever header belongs to, the header for , for and so on and so forth. It's a miracle that your code even compiles successfully. Everything from standard headers must be prefixed with . This applies to all the types as well as to , , etc. is superfluous; will do fine. This is not C. Why do you bother with , and the like? This is C++, and it has a standard library that offers a great range of very handy tools for such things, such as and . Don't reinvent the wheel. Again, this is not C. Don't use , use . This is not C. Why does have a followed by nothing? Remove that. Why are all of 's member variables public? This violates data encapsulation. Instead, provide getters and setters for data that should be accessible to the public. To answer the second question of yours: Yes, it is perfectly possible here to use and you should definitely opt to do so. First of all, provides a method named which allows access to the underlying array. Secondly, there is also , which you should prefer in almost all cases. 

These are the pitfalls and dangers I spotted. There is a lot more to say about your code, however, but I will leave this to somebody else. 

Fix your includes. You're missing (for ), (for ) and or similar (for ). Don't rely on C legacy types being defined in the global namespace. may not exist; use instead. should be . The latter is arguably more correct here and expresses your intents better. Why do you take an as argument for ? This limits your dereference to the size of , whereas the underlying container can have a size of . It appears you have typo'ed "difference" in . 

: Why are you using here? You only care if an element exists or not, so you can terminate your search as soon as you have found a matching element, which is exactly how behaves. Depending on how much you love the STL, you could consider replacing most of your -loops with . However, this is a disputable refactoring; many people are going to disagree with that style. Ultimately, it's a matter of personal taste. 

is terrible, because all 16 parameters have the same type and are unnamed. If you wanted to call this function correctly, you would likely have to look it up in its corresponding implementation file every single time, because remembering 16 different parameters and their correct order is nearly impossible (unless you waste the time and effort to memorize them, that is). Having the method take two as arguments would have been the much more readable and logical choice. 

Depends on what you mean by "general style". If you mean correct indentation, variable names etc. I'd say yes. If you mean use of the STL and standard algorithms, I'd say there's still work to do. 

when you should write because that is what your code is actually doing. There's no need to be overly clever and assign from a location whose value is known; please don't confuse us and yourself and write out the value. It might be beneficial to have a member to track the length of your list so that you don't have to recalculate it every time is called. 

What does any of those numbers mean? Are they immutable? If yes, they should probably be constants with an own name and description. If not, they should probably be passed to the constructor as their own named parameters. Do you know about SOLID? Especially the S (which stands for the Single Responsibility Principle) is important in your case. Concretely, you should split up the functionality of interacting with the user (getting/printing information) and game structure. For example, a should not query information by means of from the user in its constructor, because that is not what the purpose of the class is. Instead, you should encapsulate the idea of a with all its attributes and actions that are important to you in it and leave the input to another class (whose sole purpose it is to fetch information from the user, ideally). This makes it easy to make changes to one part of the program only (for example, replacing the text interface with a graphical interface) while also unambiguously defining where what kind of function/method/attribute should live. If you have a function taking a lot of parameters (usually more than four or five), chances are you are missing an abstraction (read the corresponding paragraph of the C++ core guidelines). For example, 

Since does not modify its inputs, it has to make a copy which is then modified and returned. However, does modify one of its inputs, in this case , so making a copy, modifying it and reassigning it to is unnecessary. Instead, you could approach the problem the other way around: First, implement , then implement in terms of it: 

I assume you meant "Precision" here. In general, I would like to appeal to you to make more use of commas and punctuation in general throughout your comments. For example: 

Prefer over . It is easier to read and generally more C++-like. Do not include C headers directly, and do not use quotation marks for system and standard library headers (looking at ). Use the headers that the C++ standard library provides (in this case, ), and remember to put before the types and functions you use (i.e. => ). all necessary headers. Your code uses , but you never (and even then, you code should use ). headers in the order: 

A Serious Bug I am sorry to be the bearer of bad message, but your whole programs behavior is currently undefined. You have stepped into the C++ reference-lifetime-trap. Lets take a look at this piece of code: 

and the answer to that is yes. The main idea of your current implementation is to use a stack with your numbers binary digits, which is wasteful (and probably slow) in comparison to just doing the operation in place using bitshifting. The algorithm that I would propose works like this: 

Avoid magic numbers. In particular, when checking the result of , check whether the result is equal to , not -1. There even are some places in the code where you are already doing this, so please adopt it for the remaining places as well. Prefer early on failure. Concretely, in you return an empty string only after you have checked for and possibly returned a valid result. Although this is quite minor, I would have expected the method to work the other way around, i. e. 

Edit: As TobySpeight mentioned in the comments, the bit length of is not dictated by the standard, so assuming each byte has eight bits is not portable. Instead, the standard library offers instead, which is now used in the updated code. 

However, as you might have already noticed, we're wasting something here. In particular, we iterate through the whole string although we actually only need to check up to the middle. Thus, we adapt our code accordingly: 

Do not use because it always forces a flush in addition to a new line, which can degrade output performance. Prefer over wherever possible. For example, in you use instead of . The reason this is detrimental is that performs a bounds check (and possibly throws an exception if the bounds are violated) while does not. Since only ever takes values smaller than , you do not need . Prefer for iteration variables. may be to small to hold all indices for very large strings. Don't use in a loop head, because may be executed every iteration. If you know that it value does not change throughout, store its value before the loop into a variable. can be optimized. Since you only return whether or not the difference between characters is one or less, you can return false as soon as you have found more than one mismatch. Although you do not give the definition of , it can be assumed that it is of type because of the iterator you are using. I would recommend replacing it with a if you are not doing a lot of insertion and deletion at random positions, because profits from cache coherency. 

While you say that your container is a simple clone of , its behavior differs gravely from the standard container when it comes to allocating and managing elements. The issue is that your container cannot reserve any memory without (default -) constructing elements. However, if you take a look at , you will find that it offers a interface that lets you allocate memory in advance without actually constructing any elements. This kind of behavior is a little more difficult to realize in code, though, so you might want to stick with your current version if you're still in the process of getting a good hold of C++, especially if you don't feel safe working with low-level memory routines. Although I tend to iterate on this point again and again, int is not the right type for index and iteration variables. First of all, it is a signed type, which allows it to take negative values (a fact which your dereference methods brace against). Secondly, on a modern x86_64 system (which happens to be what most desktop users are running), is likely to only be a 32bit data type, which means that you are limiting yourself to about 4 gigabytes of memory for your vector, and running into the risks of overflows with high indices. Instead, C++ offers the type , which lends itself very well to size- and index-variables, as the name suggests. It is unsigned, and, on a typical 64bit platform, is usually 64 bits in size. It's a bad practice to force exceptions on users. One reason for this is that exceptions are really slow when they happen. Another reason is that exceptions are not readily available on all systems, especially not in the embedded development sector. My suggestion for you is to kind of follow the design pattern: Make unchecked and have undefined behavior on out-of-bounds access, and provide a method which does bounds checking and throws on out-of-bounds. This may also lead to increased performance, as the index validation can no be avoided if the index is known to be in bounds. As I already mentioned in the answer to question four, there is some potential to use standard algorithms, in particular and in places where you are copying/moving data from one array to another. In general, if you have a simple for loop over a range of elements that does nothing too complicated in its body, it is possible to replace the loop with a function call to something from or . Avoid magic numbers. For example, in , what does the 10 mean? Why 10? Every time you find yourself writing a magic number, refactor it to a constant and give it a name. In this case, or something of the sort would be fitting. Although this might partly be because this is a code review question, the interface your class offers is kind of meager. What I find especially lacking is support for iterators, i.e. and . In the case of your vector, those would not be hard to implement at all, since every raw pointer automatically meets the requirements for a . Speaking of raw pointers, the way your class is currently implemented it lends itself very well to the use of . This will have the added benefit that you don't really need to worry about move constructor and destructor any more, because those will be automatically be taken care of by the unique pointer. In general, you should try to avoid raw pointers as much as possible, since they have no ownership semantics and are prone to mbe misused.