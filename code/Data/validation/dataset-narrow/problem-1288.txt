Update Unlimited Detail recently released a new YouTube video. I'm not any more convinced. I wrote a blog post about it, as did Notch (he thinks it's a scam). 

At any point in the game the amount of possible moves for a player is quite low* (around 5) this means that thinking a few moves ahead, evaluating every possible move and selecting the best move is doable. This approach is called minimax (wikipedia). To implement minimax you'll need a evaluation function that returns a score for a given board layout and player. For draughts a naive implementation would be a function that returns one point for every piece the player has alive. 

In addition to using the code you have above you need to configure the axis in the input manager and name it correctly. The accepted answer here may be of help: $URL$ 

All files in the Resources folder exist in your built application (regardless of if they are used). This allows you to load them as needed with . I believe Unity made the decision to prevent files in Resources being built into sprite-sheets because there would be two copies of the same sprite in the built app (which is wasteful). This answer on the Unity forums uses the same explanation: $URL$ 

I noticed this happens frequently in MMOs so I thought this would be worth answering for this particular genre. In particular for each update the old content becomes easier while the new content takes a considerable amount of time to complete. So. Why would developers make their games easier with each new update in MMOs? 

If you know how far you want the sprite to travel, and you know the angle. You can calculate the x and y distances using the formulas from the picture. Hope this helps! 

I've tried both pure approaches in the past and, not surprisingly, I've found a hybrid approach is best. I tend to create a lot of custom components for individual entities and use a FSM when I need to change a lot of entities at once. Almost always, the FSM really only cares about one common aspect of the collection of entities. For example, if the components are locked or not, or if they are in their start position, or some heighten state position. So, mostly, the FSM is implemented by adding an abstraction to each of the custom components that handles that aspect and then using the abstraction in the FSM. In the door example, I would build a custom component that handles the door logic. Imagine the size of it (tiny), and it will do exactly what you want. Now imagine some generic component that will work for your door as well as a toaster. This case is certainly more complicated than the first component and probably doesn't do what you want and is impossible to change. 

This will create a copy of the current game object and point the next stop to this one. The last line will make sure that the new object gets focus in the editor. Hope it helps! 

The boards representation in memory will be probably one of the first things you will consider. This link presents one way to represent the board and may be useful in general. In most cases it is not so important as to the specific board storage mechanism used as it can be abstracted away. One way to do AI would be to use the minimax algorithm to look a few moves ahead. You'll benefit here if you kept your worldstate separate to rendering, input etc. 

CmapTools was used to create this image, which is a visualization of a Choose Your Own Adventure book. This might fit your needs, even though it's not specialized for story-writing. 

I'd like to point out that none of the terms you mentioned are mutually exclusive with each other - you could even have a voxel based game that used heightmaps and rendered using polygons. 

I would suggest doing this manually in software like Photoshop. In Photoshop there's a filter called offset which scrolls the image by the given amount of pixels. If you offset by half the images width and half the images height you'll see the seams in the middle of the image. You can then alter the image until the seams are no longer visible. When you've done that, use offset again to make sure you haven't created any new seams. This tutorial may be of help. 

Databases are designed to handle vast amounts of data. There are many types, with different ideas behind them; but in general they are for A LOT of data. Because of this, databases do require at least some complicated set up and a fair amount of knowledge. However, they are not what you need right now. If you are saving the data of just one player locally, there is no need for a database. There are plenty of other solutions out there that will work fine and not require extensive set up. Here is a good tutorial for Unity: $URL$ 

I changed the multiplier to 10 here, because 50 seemed too fast, but you could make it 50 still if you wanted. Hope this helps. 

In unity, a vector is implemented as a struct as opposed to a class. One thing this means is that you can not change individual values in a vector by assigning directly as you have done. You need to replace the entire vector with a new one. So: 

In those two sentences, the nouns are "player", "skill", and "condition". If you already have the player object, then you need to create skill and condition. Then, you need to have player possess a set of skills and a skill posses a set of conditions. Let's start with conditions: 

Here is an example program that draws a line to a window using the cross platform library Qt. Includes have been omitted. 

Any modern Mac that runs Snow Leopard is adequate for 2D games development. There's nothing particularly hardware intensive about 2D game development for iOS. The most intensive things you will be doing is compiling your code and running the emulator and debugging tools - my Mac Mini did all of these tasks with ease. The iPod touch is sufficient for testing games destined for the iPhone. The devices have the same screen resolutions, CPUs and iOS versions. The latest iPod Touch does have less memory than the latest iPhone (256MB as opposed to 512MB) so this is something you should be aware of. 

I agree with Daniels answer, in that iterating through large amounts of boxes is the most likely cause, and that by using spacial partitioning you could speed the game up a lot - but the problem could also be elsewhere, and you could be wasting your time. In order to increase the speed of your game significantly you need to profile your code. Identify where the bottleneck is, this will allow you to make the biggest improvements. There are lots of ways to profile your code, you could roll your own performance analysis class (which could make use of the Stopwatch class (MSDN)), or you could use PIX to get a general idea of how busy the CPU/GPU is. You can also put PIX event markers in your code, which will show up as colored regions in PIX's readouts. There isn't an official C# interface to these functions, but this thread shows how you can make a C# interface yourself. 

Then, in the inspector panel, you can right click on the rails component and select "Copy and Point." 

Edit to address comment If you want to keep the same position in the jump as the target moves, then you are no longer talking about a step-wise physics solution, at least not while the jump is happening. It is easily achieved, however, with a coroutine to handle the jump. 

Here is some example code to expand on my comment above. A true multi threaded solution would be faster than this, but susceptible to many more problems and edge cases. Unity's model for concurrency is coroutines, and thus using them aligns your code with what is expected in the unity space. Unless you have a real need for ultra fast file processing, this solution should work. 

You aren't over complicating it at all. This is a great way to think about a game. It keeps the game flexible for any changes you want to add in the future (say a stats screen). The first place I would look is using the Strategy Pattern: Wikipedia Determine what input triggers you would need and add them to an abstract interface. Then, implement the interface for each game state. Keep track of what your current state is and forward any of those input triggers to the current state to handle what ever it is you want to handle. 

This is all highly theoretical but you may be able to use categories (Mac Developer Tips) to override NSObjects (Apple Developer) alloc and dealloc methods. 

I recognise that you've probably got the gist from other answers, but it was a fun question and I felt like doing a little Python coding. This is my object-oriented approach. Indentation defines scope. Graph Representation The graph can easily be stored as a key, value dictionary where the key is the room id, and the value is an array of the rooms it leads to. 

It looks like you're missing a separator character in your dependency options, glut32.lib and kernel32.lib are separate libraries. If you open the additional dependencies window, every entry should be on a new line. 

There are many ways to achieve this. Here's one way, which should be easy to make work with your existing code. Create a Transform and make it a child of your player character. Position it where the attack lands and then add it as a public Transform of the PlayerAttack script. Let's call it attackPositionTransform. Now in your MeleeAttack function, you can compare the position of the attackPositionTransform with the target. 

If the problem isn't the one described by Byte56 and you only have the script attached to a single object, then check to make sure you have at least one camera that has Clear Flags set to 'Solid Color' or 'Skybox' (as opposed to 'Don't clear' or 'Depth Only'). 

and then, I assumed the target position would be relative to the start position, so p0 drops out. Rearraging to find v0, I got: 

At this point, there are two things to solve for, v0, and t. This makes sense, you can throw a baseball right at your friend or way up high and still have it land at your friends location, even though it will take longer. So, I took this and created the following two classes that have the desired effect. 

As Editor code goes, this is pretty straight forward, so don't worry. I would do it as a context menu for the component. 

Great Question! In general, you should start with your high level objects and then think about what they do. So, I'm not sure about your specific use case, but I'll assume it is the following: 

I can't help you exactly with code because I'm not sure where all your variables are coming from. If you provide some context to this code, I can help more specifically. In the meantime, take a look at this picture: 

Finally, you need to add a list of skills in the player object and provide a way for that class to choose and use one of those skills to attack another player. Hope this helps! 

This ended up being simpler than I expected. Here is the process I followed so you can follow a similar process in the future: I started writing the basic physics 101 equations with some values in 2d space because it's easier to think about: 

It seems to me that it would be easier to bypass this and simply consider data sent to the vertex shader/pixel shader as a block of floats and allow the vertex or pixel shader to interpret it as it wants. My question is this: 

Each state needs to check if any relevant events have occurred. Typically this is done with if statements. 

Generally, you go for the smallest filesize that still provides an acceptable quality of image. Additionally, png supports alpha so you don't need to deal with additional images to handle an alpha layer. What/when to use png for (generally speaking): 

Keep the naming of the axes consistent between 2D and 3D. Conversion between 2D and 3D can be done with a simple function. If you're interfacing a lot with a library that has a different convention then either use the convention the library is using or make conversion functions. The conversion functions could look something like this: 

(iCols - 1) would be 9, so it's not going to address the last vertex (10). I think to fix the problem with columns you should remove the -1. To fix the problem with the amount of rows change 

and then you would only use Vector in your code. This would only work if you weren't planning on switching Vector classes at runtime. If you did need to switch between them at runtime you could use a factory, which would create the required class and return a pointer/reference to the base abstract class. In practice for performance reasons I'd rather rely on refactoring tools (e.g. Visual Assist) to rename functions and classes unless I'm working on a massive project or there's a legitimate reason why the classes would need to frequently change.