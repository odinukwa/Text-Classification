Technically a "trunk" does not include the branches, etc. so "TrunkWidth" and "Trunk" are kind of confusing names for this. You might consider "LayerWidth" and "Layer". I see very little point to all these classes as they do not serve much purpose. A class with a single method to define its single behavior might as well be a method. If , , , etc. will be used by methods other than then it might make sense to have these as classes. If they are simply to build a string representation then I would drop them in favor of inline calculations (OOP does not mean that "every thing is a small object"; e.g. "height" and "width" may be attributes of objects but are not necessarily objects themselves). This entire collection of classes can be reduced to the following (assuming no other code is using , , etc.): 

Why is slower than ? Is there any way to optimize the regex in so the performance is comparable to the first two? Is there any other way to speed up this code? 

Zirak's answer is all the advice you need, but since he didn't actually write any code, here's how I might re-write it. 

Note that this code is optimized for arrays with at least 1 element; if the majority of its uses are on 0-length arrays, you'd see a performance boost if you added a short return. Alternatively you can use Array.prototype.reduce. I highly recommend that you not use this method - while it is more "unique", it is also much harder to understand and much less efficient. And good code strives to be readable and efficient (and robust), not unique. 

In some languages variable names like are common and expected but in Kotlin (and Java) I find it more common and expected to have variables names avoid abbreviations, use camel casing, etc. I recommend using instead of . You are returning a . This is fine but data classes are so much better and Kotlin makes it so easy to define and use them. I recommend creating your own type to return. e.g.: 

Personally I prefer "row/column" instead of "y/x". Thinking "y" before "x" is unnatural. You can always define your own methods too which can improve readability. e.g.: 

The performance doesn't make any sense to me - does the same thing as , except it doesn't create any unnecessary strings or arrays. Is with a start position just really slow, or is there some optimization only the first method is picking up on? Finally, here's one more method, which is much slower in every browser I've tested, but beautifully concise: 

The solution you edited into your question can be improved upon (shortened and sped up) by using an object for instead of an array. After all, you're just using it as a lookup now - and an array is one of the worst ways to store a simple lookup. Here's a complete implementation. 

And you can even pre-compute the required capacity to avoid unnecessary array copying while building the string: 

You can still use a enum if you'd like but this function is very similar to so would seem to suffice. Every enum class has a function implementing (Enum Classes - Kotlin Programming Language). As such, would declare both and which seems confusing to me. I suggest defining superior and inferior check functions instead of but this may not be practical depending on how you are using : 

You're method is not transitive (e.g. and but . See Any.equals - stdlib - Kotlin Programming Language for more details on the requirements for . You might also consider using from for testing your own implementations of . If you define your own method instead of defining a custom, non-transitive implementation than your existing solution can become much simpler: 

It is impossible to know the variable name without passing it separately because the name is not part of the object itself, but only one (of potentially many) signs pointing to that object. Expecting the object to know that variable name is like expecting a building to know which road you drove in on. Besides, specifying the localStorage key separately is a good thing - it allows you to refer to the same key using different names in different parts of the program. You can get around having your methods show up in for-in loops by using getters instead of properties or prototypes. If you're concerned about compatibility, you can fallback to . Here's what I came up with. 

I wouldn't use or because it makes it appear that can be greater than which is not true. I recommend using . 

This also prevents printing a trailing space. You don't need to re-read "dict.txt" as it doesn't change with each word. 

will return . will return . If you want both to return then replace the with in . Marking as is purely optional but it seems to me like a good fit. 

Kotlin already guarantees that and are not as you've used for their type instead of . As such, the statements are unnecessary. I do not believe you gain much from and . and read clearly and are read in constant time so the additional variables seem unnecessary to me. You can place the last lambda argument in a function call into parentheses as you have done but I personally find moving it out of the parentheses easier to read and more idiomatic: 

While the above solution works, it is somewhat inefficient and messy. This stems from the fact that you're trying to get javascript to work the way you want, when what you should be doing is trying to understand how javascript wants to work. Each language has a style, even a personality, and if you're flexible enough to go with it then your code will be shorter, faster, and cleaner. Here's how I would abstract away my JSONification. 

This looks like something you'd want to do server-side, mainly because you can cache the result. So for every request but the first one you're essentially just downloading a file. If you can't do it server-side, here are a few improvements: 

"args" is more common and descriptive than "a" in a function signature "\n" is system-dependent; I recommend using instead can be used with a instead of first mapping an using a and then calling . e.g.: 

Using returns a new object but such isn't necessary in this case. You can use directly on the . You can reduce duplicated code by using classes and/or extension functions. e.g.: 

You might want to take a look at Delegates.observable - stdlib - Kotlin Programming Language which you may be able to reuse to improve and reduce your code. 

Instead of using you might check to see if the given product is greater than the currently known maximum product and then assign it if it is. This is minor but personally I prefer to avoid unnecessary assignments. I wouldn't worry about trying to do all of this in one pass. Each directional slice has different row/column bounds so I think four separate loops is the clearest/cleanest. You can remove some duplicated code when it comes to calculating the product and updating the maximum. 

The switch statement might be more legibly written as a series of if else-if statements (with nesting), but that's mostly a stylistic choice. 

I am writing a script to count the number of rows in a textarea, and as it will be called on every keypress I want to make sure it runs as fast as possible. I'm not aiming for a general solution: we can assume that the textarea has a monospace font and enough horizontal space for exactly 80 characters. I've probably solved this problem in 20 different ways, and this is by far the fastest solution I've come up with: 

You can use the slightly shorter instead of . You can also move trailing lambda arguments out of parentheses: 

However, the "problem" specified in LeetCode does not use arrays which are very different from linked lists. If you convert the Java code it provides you would get the following: 

For determining correctness of your implementation I recommend referring to an existing implementation such as Apache commons-lang or the newer commons-text: 

I recommend removing as "Neutral" is not an Element Type, it is the lack of an element and therefore makes element.type not applicable. With removed you can greatly simplify your solution: