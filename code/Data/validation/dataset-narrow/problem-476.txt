Update: sucks, and that means your format is inconsistent and not parseable without horrid hacks. In that case your code seems OK, although I'd probably do it differently. I would most likely use a regexp to find all cases of commas that are NOT preceded by > and followed by a space to something else, say chr(128) or something like that. I'd then parse the code with my code above, extract the email from withing the brackets, strip all quotes and brackets from the remander, and replace back chr(128) with commas. And the lastly write that to the outfile. The difference there is that I don't try to handle a horrid format, I first try to fix the problems. It makes for cleaner code, IMO. Update 2: I instead replaced the commas that should be split on, making it simpler, like so: 

I'm doing my first major jQuery development. It's a Widget for recurring events, and is as such a fairly complex beast. The full code is available at $URL$ for those who want to check it out. I appreciate any kind of feedback about any part of the code, so anyone who wants to take a look at it, that would be awesome. I have a couple of specific questions, and it seems best to put them as separate posts, and here is the second one: I have several big snippets of HTML and I'm using jQuery templating for this. My question is on the best way to include these templates. Currently I'm using two different ways, and none of them are obviously better than any other. In one case I use a string literal: 

It's more than okay, it is nicely readable, has no problems and involves no abuse whatsoever. I sometimes do the same. 

This is neat and simple, but the result is a lot of HTML inline. One of the templates is 219 lines long... :-) The other technique I use is to include the template as if it is a script in the HTML: 

As you expect, the lambda specified in the select block will be called for each element in the list. But because of how LINQ methods are designed (using yield return), this will happen as the aggregate method process them. This is because the list of items that Select returns is built only as new items are requested by the bottom most foreach loop which runs inside the Aggregate method. Basically, you will see this behavior: 

The idea around this solution is to make sure that only one pass through the list will ever happen. This is an solution, as opposed to Juraszek's one which is an solution where n is the amount of inputs and m is the amount of matching keys. This solution also adds a safety around keys that does not have at least elements. For now, it simply skips it, but it is trivial to check for the value of SkipCounter before resting it if an exception needs to be thrown. Once we find a match for our first parameter, we set a skip counter based on a distance parameter. We then proceed on decrementing the counter until it reaches zero. If the counter reaches zero, we have a found an item at distance items of the parameter so we save it. If it never reaches zero it means that we are looking for an item further than there is in the list. Providing a negative distance to this algorithm will never yield any results as it is a forward only algorithm. When the final value is returned, we simply trash the counter and only keep the values we saved in our temporary object. EDIT As requested in the comment, the question author is wondering how to trigger updates to a progress bar in a solution like this. Since this code is using LINQ which works wonders with yield return, you can simply call it like this: 

Basically, what you are trying to accomplish can easily be done through the use of the Aggregate method but I would stay away from it for performance reasons. You cannot early return from an Aggregate process so you would have to continue looping for all items in the list even though you found a valid result. I would instead use a variant of the TakeWhile method to scan through the list until the interesting element is found. The issue with TakeWhile is that it tests for the predicate before returning the value. This causes the returned index to always be one iteration off. This is where the TakeUntil method comes into play. Basically, where TakeWhile acts like a while loop, TakeUntil acts like a do while loop. This method tracks two values, the final index to return and a score of the best value found so far. 

Rule 1. When I add the same identifier twice, does it may sense to throw an exception saying that the cannot be added? Is there any harm in 'doing nothing' here? Rule 2. Trying to add a list id to the included lists throws an error if it's already belongs to the excluded. Does it make sense to introduce some helping methods like or ? Does it make sense to throw an if an empty is provided? 

Also, you have to create an instance of the wrapper in the production code, haven't you? So, what is the purpose of the static class then? Static classes are inconvenient for unit testing. Instead of introducing wrappers that mimics the original class, you can simply get rid of statics at all and go with simple 'injectable' abstraction and implementation: 

Does it make sense in declaring 'Add' methods as and 'Remove' methods returning ? (similar to .NET collections). Does it make sense in adding other collection-specific methods like or ? 

I need to define an entity () that contains and manages two collections of identifiers ( and ) that are ids of some other entities (). The business rules are the following: 1. The collections must contain only unique identifiers. 2. The same identifier cannot belong to both and . 3. Identifiers can be added or removed (performing the checks above). Note: Adding an identifier to the is not opposite to removing it from the . For instance, there is a list A that contains included lists B and C and excluded list D. That means that . An attempt to add list C to the leads to an error while C is in the . If the list C is removed from the , the list A will be the following: . I introduced two properties to get the collections and four methods to manage them. There are few areas I'd like to hear some feedback about. Which variant is better? Property naming