Don't try to shortcut the insertion of data into your tables at the expense of making data retrieval faster. As a rule of thumb, data is read many more times than it is written. That means you should keep your data and your code as simple as possible for reading and if you need a bit of extra code for inserts (or updates or deletes) then that's where you should prefer to have it. This doesn't necessarily mean that you don't want to have a flag on that indicates that new websites should be linked automatically. Here's why: One question you need to ask yourself is what happens when you add new entries at either end of your many-to-many relationship. You can think of your intersection table as being a snapshot of the current state of relationships between existing partners and websites. Could it not be the case that one partner happens to (coincidentally) be related to all current websites, but that a new website would not be related automatically? If this is conceivable then you need to distinguish between who's related to who right now and what happens when a new entry is added? You can't necessarily infer one from the other. Having a "goes with everyone" flag will tell you that when you insert a website, that it needs to relate to the flagged partners automatically. It also tells you that if you insert a new partner with this flag on, you need to insert a relationship record for each existing website to go with the new partner! - So it goes both ways. You should therefore consider fully populating your table and at the same time, consider adding a flag that tells you how to handle inserting both new websites and new partners. 

Compounding Taxes To handle the situation where some taxes compound and some don't, I've used a calculation_order attribute, which is just a number that indicates when to apply the tax. Taxes with the same calculation_order value get applied to the same base. Taxes with a higher calculation_order get applied to the net amount of the product and all taxes with lower calculation_order values. 

Note that you want to avoid reserved words for table names, so don't name your tables exactly as shown in the diagram. The way it works is that your groups or Roles have not only a list of users assigned to them but also a list of permissions assigned to them. This allows you to table-drive both who can do what, but also what it is they can do, if you follow me. 

In the past I have found it useful to maintain two sets of date ranges in a history table. The first date range is the "applies to period of time" range. This would indicate when, for your example, the linkage between a customer service and domain is made. You would use this range to determine what gets billed to who and for when. This range is set by your application probably based on some kind of direct action by your users. The second date range is the "when did it look like this" range. This range would indicate when the database actually held the values indicated in the rest of the record. You use this range to show what was the state of data population as of a given point in time. This range is set automatically using defaults/triggers, etc. It is this range that gives you the history. 

One other important aspect of audit tables that hasn't been highlighted thus far, is that in addition to keeping track of who did what to which record (often including before and after snapshots) audit tables are write-once. Records in an audit table may not be updated or deleted (see note), only inserted. This is sometimes imposed using triggers or maybe just application logic, but it's important in practice because it gives you "proof" that nothing's been tampered with in a way which is difficult to detect. Note: Cleaning out old records from an audit table requires special processes which often have to be approved by management or auditors. 

Your "Idea 1" is the best approach as it most naturally and accurately enforces the cardinality between SITE and CLAN/GAME/TEAM. Your other rule that SITE must be only one of CLAN, GAME or TEAM would have to be enforced with a partitioning attribute on SITE, e.g.: SITE.subtype_code. You would need either application logic or a trigger to enforce consistency between the partitioning attribute and the existence of a record in either CLAN, GAME or TEAM. 

Are there likely to be other attributes that depend on the category? In other words, should category be normalized out of posts? Is it possible that categories could exist that have zero posts? In other words, is the category list something that needs to be managed by an administrator or someone other than the person who creates posts? 

There isn't any way to reset autoincrement such that it goes back to the beginning and just overwrites existing data. Autoincrement isn't built that way. What you could do is rather than . You'd have to either pre-populate every record with blank data so that every entry is always an update, or you could write a procedure which tries to read the next ID first and then either inserts or updates accordingly. Either way, you will need to track the next ID yourself instead of letting the database handle it for you (with autoincrement). When you get to the maximum value, reset the next ID to 1 and keep going. Thinking Practically: The largest value for UNSIGNED BIGINT is 18,446,744,073,709,551,615. Depending on what is in your record you are looking at thousands (even millions) of petabytes of data. Are you sure you aren't going to have space constraints with that much data? You may find that what you need to do is purge out data that is old enough to be discarded as you go just to make room in your database. If you do that, then you can avoid the prepopulation and just insert every time. If you purge periodically, say every night, then you just need to wait until the gap between where your remaining data is and ID=1 is big enough that you don't have to worry about ID collisions. When that happens, reseed your ID and start inserting from ID=1 again. If you do this, then you can go back to using autoincrement. Edit: Additional Information about reseeding... OP mentioned in a comment that the command for reseeding an autoincrement column in mysql is of interest. This command will reset the starting autoincrement value: