I have a set of PIs that I control remotely. I am going to update them to set the the root of the filesystem as read-only (to avoid SDACRD corruption problems). However, occasionally I will need to put the root back to read-write mode to apply updates etc. So I will use commands or etc. However I cant figure out how to unmount the root filesystem. If I run I get the error . I used to figure out what processes are using root. I killed them all except for the last one - its called and if I kill it my terminal dies (I'm using SSH with PuTTY). Is there a way to remotely change the root to read-write mode? 

The gui will allow you to see and enable/disable - graphically - all of the modules associated with OpenCV. When configuring on the RPi, make sure you uncheck any references to . This is the only REQUIRED step for you to take to get the library compiled. But there are lots of other things you can add on. NOTE: when you run It will take FOREVER on your PI. I would suggest running: So that you run the compilation using 3 cores instead of 1. This will cut down the compilation from about 3-4 hours down to around 1-2. I hope this helps... 

I had the same issue - most of the standard ways of doing this didnt seem to work on the raspberry. My situation was a bit different - I have a Raspberry PI B where the ethernet chip has died and so I used a usb-ethernet adpater. The adapter is maybe not the highest quality as it didnt have a unique MAC address. The adapter is assigned to I found the answer by enzorik here... $URL$ worked for me. Essentially... Create a new script: 

I believe you can change the drive strengths of the GPIO outputs. I need to drive one LED at 16mA. However I cant find anywhere where you can do this. I am using the RPI.GPIO python module so it would be handy if this could be done in python. 

I'd use Wifi and sockets. It's relatively simple to use Qt (or even plain C++) to implement a multi-connection client/server. There are lots of tutorials on the net. 

Is it absolutely necessary that you run OpenCV algorithms on the video stream? The raspberry pi is only capable of so much, and much of OpenCV's manipulations of intensive on the system. You may consider taking pictures and processing those. In a lot of cases, taking a few shots every second is sufficient to get an idea as to what is happening in the frame. Is this an option for you? If it was, you could use raspistill to get the high quality pics. If this is not an option for you, I have heard very little for solutions to this problem. The only other thing I would suggest to you is to try: $URL$ But I have heard that it has degraded picture quality, which I imagine is not what your wanting. 

If your Pi is set up to boot to the desktop, it will start X even if no display is connected. You can run this command to run the config utility: 

You also need to check the permissions of the directory /var/www/test to see if that is accessible for everyone: 

and then try the previous command again. Also, change public to 'no' and restart Samba. When you connect from your Windows machine, you'll be prompted for pi's username and password. Setting it up this way means Samba knows you're not an anonymous user, so it gives you the access rights of user pi. 

Maybe rc.local launches at a different time to autostart? Any ideas why I get the error message "CANT OPEN DISPLAY"? 

I have a tightVNC server running on rasbian on the raspberry Pi and I have a vnc viewer running on windows 7, 64 bit. I wish to easily copy a file from the pi to my PC, but the 'Transfer Files' option on the toolbar on the viewer is disabled. I wonder why that is. 

I need to run Midori automatically on power on. If I run it via: it launches OK but seems to get launched twice So I then tried launching it from However if I do this I get the error message: 

A Pi isn't a powerful web server, but many personal sites don't get that much traffic. A Pi can be viable as a home server I haven't tried serving video from a Pi server, but I suspect that would be quite slow, and you wouldn't be able to stream video to many people simultaneously. You might be better off uploading images to imgur, upload your videos to Youtube, and embed them in pages on your site. This will massively increase the amount of traffic your server can handle. If your site is made from static HTML pages you might be able to serve around 100 pages per second (based on these tests). If your site is built using a large CMS like Wordpress, your Pi will struggle to serve one page in around 6 seconds. If you use Wordpress, you can improve page load time using caching plugins, but it will still be much slower than using static HTML pages. You could use a CMS that generates static HTML files like Pyplate. Or you could use a Javascript solution like Ghost. 

Did the adapter board shown in the picture on amazon come with it? It will be required for it to work. From I'm seeing it seems that you need to connect the ribbon cable from the adaptor board to your DSI port on the raspberry pi. Look on your raspberry pi and just below the DSI port it will say "display". This is the port you want to connect the ribbon cable to. For powering the monitor you have three options. Using two separate uUSB power supplies, daisy chaining USB from the adapter board to the PI. Or jumping power off of your PI VIA the GPIO pins. I'm assuming you do not have any spare uUSB cables so I would suggest jumping off of the GPIO pins (Option 3). You will need two female to female jumper wires. You can get a pack of them on Amazon for about 5 bucks. Connect the ground pin on your PI to the ground pin on the adapter, and connect the 5V pin from the pi to the 5V pin on the adapter (As shown in the picture in the link you posted). Then run the suggested commands and reboot. 

If you are using gcc, try using the -O0 option to disable optimisation. It's possible that the compiler decides that the tim variable isn't really needed when it's declared locally, so it produces executable code that skips the loops. When tim is declared globaly, the compiler uses different optimization rules, so the loop is included in the executable file. 

You need to change the permissions of the files you uploaded. Try using this command to make your files accessible: 

You need to add a line to /etc/fstab. Linux uses this file to see what drives to mount when it boots. Try adding something like this at the end of /etc/fstab: