Best tool to debug JS is, in my opinion chromes web developer tools. - And you can break and debug Script with breakpoints. 

That is a basic plan and obviously I cannot go into any details. That is why it is important to ask a precise questions so the right person can give you the right info. We need to know exactly what the problem is and in what environment. 

The gstreamer tells you the stream is unsupported. FFMPEG is on like you said. I had a look at the camera specifications- it comes out of laptop and is intended to work with Microsoft Windows mostly and not really supported for Linux but they say it will work on Redhat 2.+ That camera returns video in on of these codecs 

The easiest way to start of would be to use RasPBX $URL$ It is a Raspbian Jessie base OS with Asterisk and FreePBX installed and preconfiugred with all the goodies. (Trust me, the pre confiugraion of all these applciations takes allot of time) Since it is Debian OS, you can install Python on it (probably is already installed) and write your scripts as you need. To use Raspbian just SSH into it with the WebGUI password. If you want root you may need to enable it by using There is more information here at the documentation 

No. The Raspberry Pi can only use one output. This is by hardware design and is to do with DMA (Direct Memory Access) You can plug in a USB audio device then you can use two output sounds at the same time. The next best thing could be to play a sound out on HDMI, switch to Analog and play a sound there. But not at the same time and switching could make strange noises on both sources. 

Yes and No. I agree with Kolbans analogy with to the degree of "translations". So first question is, is the exe compiled for x86 or ARMv7? This not a foreign issue even on Linux, as you cant just take a Debian Desktop package and run it on Debian ARM. It has to be compiled to a binary (assembler) that the processor can execute. x86 & ARMv6 & ARMv7 & ARMv8 all have specific instruction sets. Secondly what are the dependencies of the executable file? If it is windows forms Application then it wont run because IoT does not support "Forms" but instead the Universal App XAML or DirectX - So it may try to access parts of the .NET CLI that is not supported (after trying to run) If you create a console application that does a simple task like generate random numbers and write it to file, that will work when executed from PowerShell. As these are the CORE .NET capabilities. You cant autostart exe files on IoT though but on Enterprise you can (Intel boards) IoT Core - Is a basic prototyping sandbox OS. You create Universal Apps using libraries supported on IoT Core with Visual Sutdio 2015 Community or better - Its does not have an amazing range of libraries at the moment but you get hardware rendered GUI, basic I/O and can even access DirectX if you wanted to. MONO - You can install this on Debian (Raspbian) and this is much richer experience since you are not sandboxed like on IoT. When in an X windows manager, you can even run Windows Forms Application using or console apps, or webservers. .NET has evolved over the years, and Universal Apps is Microsoft way of trying to unify everything. So you can kind of forget about running files as a traditional Windows user on IoT Core - Because the name core, implies its a very basic OS. These below require paid for licenses to run... You can get Intel MinnowBoard MAX and instead of core use Windows 10 IoT Enterprise (Industry)... which is the same as Windows 10 for Tablet but only runs on x86 architecture, like the Atom. Support for ARM based Windows 10 is on the way and is called Windows IoT Mobile, but its not clear if we will be able to run this on the Pi 2, with a full Windows 10 desktop or not... 

As far as i know, you can't run OpenCV, nor GTK, in graphical mode from console mode. GTK needs to be run on X11 or Wayland. OpenCV can work with other display manager, but no one of them will be windowsed when launched from console. For python : you can use pygame, pythonic bindings of SDL1.2, able to display graphics and manage user events in console mode. A simple conversion from openCV frame to pygame surface will allow you to manage and display OpenCV frames on screen : 

About point 1: You will need a RTC if your Rasperry can't rely on an internet connection to get synchronized. I suppose you want your alarm-clock to be "disconnection-proof", unless you want to explain your boss you are late because of an ISP failure conjugated with your DIY-addiction :) So yes, an alarm clock definitively needs some hardware RTC, some are GPIO compatible, in order to improve the native Raspberry system clock. 

Raw image data can be edited with Gimp, as long as you respect original image format and resolution, or can be computed on-the-fly, using some usual graphic functions. I use this trick to get a boot splashscreen before plymouth launch, it may be enough for a simple UI. 

Seen your project, I would advice you to work with the OpenMax display system. Pros : - It will give you draw and display functions - It allow you to use GPU instead of CPU - It is lightweight - It can manage multiple display layers with transparency Cons : - Don't provide user input management - It lacks documentation - It lacks community I had good result with OMX, to replace SDL, being a total newbie in C. You can find code samples here 

Indeed, your calculus seems legitimate. Of course, it doesn't care about the fact that the RPi power consumption is not linear, as it depends of the CPU and external device usage, but your result will be enough to estimate how long your RPi will run on different batteries. 

You may want to use . easily implement camera control and webRTC streaming, in a very efficient way, and quite easily. So your RPi will stream the camera on the network, while the computer will acquire frames from the RPI via opencv videoCapture class, as if it was a classic video file or camera, in order to analyse them. More information about uv4l here : $URL$ 

Using you will see the current resolution and pixel Format for your camera. To define another resolution and/or pixelFormat, use this command : 

I never used compute module with dual camera, but I can show you how to get your missing .dtb file. First download the dt-blob-dualcam.dts file in our home directory. 

A peculiar little device. You cannot really find anywhere how it works internally but what i can tell you is that its a normal flash drive. No setting files are stores on the flash memory it self! The special part it that the S6 chip also acts as a MCU and and communicates with the Wifi chip using it UART :-) When you use the "utility" it actually communicates with the SoC via a 1SPI line? i suspect/ which is used to setup your WiFi settings. The settings are likely stored in the S6 flash- its only a bit of text. Then, on power up the independent firmware on the S6 polls the SD Card and uses it own code to send them over your wifi to their service.(2I think it will support major file formats,except NTFS because of copyright limitations) I can bet you 10quid that the web service address is hard codded and un-hackable (unless you got the source code and re flashed it)(or reverse engineer the HEX and find the service in unencrypted plaint text string un re upload it without bricking it) End of the day. NO You cannot use this to do traditional WiFi communications because there is another micro system that runs independently of everything. If you designed your own SD card and exposed an API for basic TCP communications. Who knows- everything is possible. 

So yea.. should be OK. You could go for I2C Extenders though. That means you can add as many GPIO boards onto the I2C bus as you like. I2C is like a very simple network so you can controll any I2C device by working with the node names (yes you can mix and match various things on the same bus) It also works better than multiplexers as multiplexers have speed limits on PWN. An interesting video with 128 GPIO's using two I2C channels 

Wiring up the button is very simple. You just need to a button, a 10k resistor and some wires. You select a GPIO, add the 10k resistor, connect to the button. And the other side off the button to GND. In what ever flavour of program you like you just wait until the GPIO state changes and run a command line. For video I would recommend as its Hardware GPU and can play back 1080p 30fps with little strain to the power system. Best format is h264 using a baseline encodding. 

The Pi have built in resistors but it's good practise to put at least a 10k resistor on input anyway. That protects from over current peaks I suppose. Another safe guard is to use a diode just in front of the transistor. Just in case the transistor goes faulty you won't get 12 volt coming back down to the Pi's. Resistors won't protect you to from that. Or optocoupler gives 100% safety instead of transistor. 

(Posting a self-answer with my results so far, since nobody has answered yet). Firstly there's no simple way to turn a single-boot NOOBS into a dual boot. You had to have selected the dualboot when first installing. I decided to save my data, wipe the SD card, and download berryboot which allows you to add new OSs at any time, and then reinstall Raspbian via berryboot. Secondly: on the Raspberry Pi, the firmware is a part of the boot loader (It's not flashed into BIOS like on a PC). RasPlex is a complete solution; RasPlex and Berryboot each have their own firmware module. It turns out that the RasPlex development team often make their own firmware improvements, to fix playback glitches. So for the best experience you have to use RasPlex in a single-boot scenario, i.e. if you want two boot types then get two SD cards and manually swap out. The posts on the RasPlex official forum all assume that you won't be dual-booting. Nevertheless I did manage to set up dualboot of Raspbian and RasPlex and have not had any issues so far. It wasn't straightforward - I had to mount the RasPlex image and run some preprocessing on the contents to produce a file that is the right format to be accepted as a BerryBoot boot image. I found those instructions by googling. I'll write another Q/A here on that soon. 

I currently have a version of berryboot dated Mar 14 2016 installed and running succesfully with 2 OSs. I would like to update firmware. Is it safe to just replace that berryboot installation with the latest one (by writing files to the SD card from Windows) -- i.e. that will not lose my existing OS installs? 

I have an 8GB SD card with NOOBS 1.4 and Raspbian. Is it possible to add RasPlex on the same SD card and dual boot? If so, how? Preferably without erasing what I already have installed. The NOOBS boot menu has the option for OpenELEC_RPi2 but not RasPlex as such. I read a forum post that said RasPlex is OpenELEC with a special build of Plex client, but I couldn't find anywhere to download that Plex client by itself. 

I'm following the tutorial here for using Python2 to interact with Minecraft Pi. Everything is fine up until the "Blocks as Variables" section. Here is my code: 

I found that pressing (backslash) key produces the character which is sufficient to enable editing the config file. (Don't ask me how to type backslash...) 

Yes this is fine. I copied the new files over, including config.txt, after backing up the old files to my PC. On reboot it prompted me to "install the OS" which was a bit scary; but I left it on the default option of "Use existing files". It completed this and rebooted; and I was successfully able to see and boot into the two pre-existing OSs I had before 

When you made your script in , did you followed the syntax shown in the example file ? Did you set a correct file permissison ? 

as described here : $URL$ Other implementation can be found here : $URL$ Note : it may be easier to revert this signal directly in the code, rather than soldering extra components ;) 

I'm trying to setup plymouth, launched via initramfs, on Rasbian Jessie. But I faced some ironic situation on my research, as plymouth is loading at boot (a bit late), even when I disable initramfs in config.txt, even when I disable the plymouth service with : It's obvious I missed something somewhere ... Did you see a reason why plymouth is still loading ? Thank you ! 

Using the RPi GPIO, you can access many communication protocols and use them to transfer raw data : Serial Communication You can send datas from the RPi with the serial protocol to the android USB port. Transfert rate will be at best around 250kbps. Here is a sample of implementation : Android side : $URL$ RPi side : $URL$ I2C communication If your android device has a I2C interface, you can use also use this protocol, wich allows a transfert rate up to 3.2Mbits/s. As this protocol is not specially designed for data transfer, you may face some unexpected hardware limitation. Here a sample implementation : Android side : $URL$ Rpi side : $URL$ SPI communication If your android device has an SPI interface, this may be your best option. This protocol will work only with short cable in order to enjoy the very high transfer rate, from 25 to 50 Mbps. Here is the sample implementation : Android side : $URL$ RPi side : $URL$ 

About the software part, i strongly recommand the tiny program . Basically, it copies everything going through the HDMI output, /dev/fb0 (even disconnected) to one internal display, i.e. a touchscreen on /dev/fb1, via GPU. $URL$ Just launch it and stop it via a tiny GPIO interface and you have your switch :) Provided you found some wireless HDMI system, this should fit your needs. 

About the amperage, a circuit will draw what it needs. The rule is to keep the voltage matching with the source, and to have a bigger amperage on the power source than the need of the device. If your first intuition was true (devices are breaking), a lot of electronical devices wouldn't work ! I.e. consider a speaker amplifier. It's consumption varies over time, depending 1) on the gain setting : more volume, more consumption 2) on the sound given as input : amplifying a silence consume less that amplifying a sound. Obvisouly, sound engineers don't change their power supply when they raise or lower the volume button, nor at each drum kick ! Instead, they use a power supply big enough (in ampers) to work at high volume.