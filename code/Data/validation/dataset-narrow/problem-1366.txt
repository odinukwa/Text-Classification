I've added the aura effect. Also the image has transparent background, if you are interested to see it on different color backgrounds. 

First, when are you calling the method? Make sure it really gets called, maybe by using a log message. Second, instead of 

I am working with AndEngine with Box2d extension, but general answer or a concept idea will be appreciated too. I have feather-like objects in a 2D side view world that I want to be part of the physics simulation. I am using linear damping to make the "feather" fall slowly. This might not be a good idea, maybe I should rather apply force in each update, but nevertheless, this works and it makes the object look "light" and it feels like there is air with resistance. Now how can I make the objects actually look like feathers falling through air? Specifically I am looking for two types of objects: Long with low density, that should move down in a slow swinging motion and square objects that would just randomly change trajectory. It would be great if this could be one simulation and length would be a parameter - the longer the object is, the more it would swing. Right now I want to simulate feathers, leaves and snowflakes in a cartoon world. 

Create your own thread that will be checking the array of enemies and adding them to the game. Also sort the enemies by time they are supposed to arrive and stop on the first enemy that in not supposed to arrive yet - then you don't need to check all of them. You can implement this by using stack. Push the enemies to the stack in the opposite order and pop() them when needed. How to do this in cocos2d, I don't know, but this should be the general idea. 

Because Android phones work with very limited resources, especially the older and low-end devices, there is not enough memory to hold multiple contexts with all the textures. The easiest way is to unload everything onPause and reload back onResume. This is partly handled by AndEngine and partly by Android. If this is causing you issues, starting from Android 3.0, you can actually preserve the context. See for more information. Note that AndEngine might not count with this option and behave unexpectedly. Also note that as of now, about 30% devices still run Android 2.x where this is not available. 

Image is a basic structure holding the texture data (GLuint) and then two integers to hold width & height. 

Can that be done? Or is it only the "Asset" element that can have the Type definition? Currently this is what my new data layout looks like: $URL$ But currently, it seems to start reading it but i get this error by the first "Tile" Element. So the only difference i see between his & my layouts are that he has the Asset containing the List definition whereas i have "Animated_Tiles". So i'm unsure can any element can have the "Type=Blah" definition? 

The SDL2 version is currently not slated to replace the Linux, Mac & GL solutions but when i asked the Dev he replied with "I hope so." I also asked him about shader versions; 

so just to be more specific this question isn't in regards to how to target enemies or anything like that rather its purposed towards a specific targeting issue i have with me enemies in its current state. So the issue im having is that if i fire a bullet towards an enemy and then before that bullet hits the desired enemy it was initially set too, if my tower changes its target then suddenly my bullet does a u-turn and then targets this new enemy. Which isn't what i want. I'm using C++. I know this is a pointer issue, that my pointer's memory address changes to point at the new enemy which the tower would be facing, the problem is i just don't know how to solve this, personally for me i don't use pointers that much and unfortunately im just not very good at using them it seems :/. Any help on this issue is greatly appreciated, its been annoying me now for the better part of a few hours, and if anyone could explain what I'm doing wrong here as-well that would be great! So here's my targeting code 

I have my units that i move around my map with path finding. The units can move in 8 directions, currently i have the units moving around the map with a extremely basic check against the unit's current position vs. the next target destination in an array of Vector2s (the path). However, the movement is rather jagged and not very fluid. Current code (I know its not very good, i did this just to test out the pathfinding really); 

Without knowing what are you actually making, it's hard to say how you should pace it. From your description I'd guess it's a Desktop Tower Defense type of game. There's plenty of them out there... 

Blue body is moved using MouseJoint (yellow) towards the Red body. Red body has another MouseJoint - Blue can push Red, but Red will try to return to the start point thanks to the MouseJoint - this works just fine. Both bodies correctly rotate along the middle. This is still as I want. I change the MouseJoint to move the Blue away. What I need is both bodies return to their initial rotation (green arrows) Desired positions and rotations 

But personaly I'd let the users pick the wheel areas for me. Simply load the image, display it and let the user click on the picture twice to set the positions (and size) of wheels. A lot of image reconginiton/manipulation software does it this way to detect eyes in faces etc. 

Well, why does the things you said feel awkward? It's the way to go. You can create the assets for the closest zoom level for the best quality. When zooming out, you will see scaling (down), but that usually looks ok. In my game I simply create full HD textures and thanks to that, my game looks ok on all mobile devices. You can also use LOD (level-of-detail) techniques to change the graphics when the zoom level reaches certain threshold. This is not implemented in AndEngine, but you should be able to write the code yourself. The LOD techniques can involve blending between the high detail and low detail graphics, so you won't see a "jump" in the quality. 

The complete answer to make this fully automatic FOR ONE BODY is a combination of efforts of Byte56, NauticalMile and me. You will need: 

In a simple platformer game I want to rate the player's performance in a level based on score. Very common in a lot of mobile games is "three star rating", probably the most notorious example being Angry Birds. My question is: Should I use the same type of rating or use something else? Is it better to be original or use something the players are used to? If three stars, should I avoid 0 star rating? (i.e. give player at least a star for finishing the level). 

So i'm not quite sure exactly what "glow textures" are. For my implementation of a "lightning" effect, according to the comments on the article; $URL$ They guy uses "glow textures". To achieve the really cool effects on his beams. I'm trying to-do the same thing, except that i'm not 100% sure what a glow texture is, currently the texture i'm using produces this output *I'm also using a simple shader to adjust the color value the lightning is rendered at; $URL$ Which isn't very good, it has the shape of the lightning but it doesn't have the sorta "flare" of it. This is a screenshot of my current texture that i'm using: $URL$ So essentially what i'd like to ask is mainly what is a glow texture? And perhaps to see an example of one would be really appreicated. Edit: Taking the advice of kaoD, i'm now rendering the using Additive Blending, I've also got the Max Blending working, yet, still the bolt's do not produce the required effect that i'd like. Here's another video of them in action with the current code; $URL$ And here's specifically how i'm rendering them; 

Yes, that should be fine for your needs. Simple all you are doing would be some form of parallax scrolling methods alongside your basic tile-map with X amount of layers. Unlikely to cause you any issues on its own. Really it will depend on what else you have going on, usually things like physics, any other render intensive calls and how many enemies you will have in your game. Like eBusiness said, testing is key to your performance, in regards you should every now and again when you've implemented something new look at "stress testing". How many of X can i have along with X & X before i start losing performance? Really quite simple things, so shouldn't be too hard. As for simple optimization, remember to: 

There you see target is then a pointer to an enemy address, the cEnemy (currentEnemy). What my desired effect would be to have my Projectile store the enemy that I pass into it which then until it hits that enemy, the targeted enemy will forever stay focused on the enemy passed in when the projectile was first created. Again any help greatly appreciated! For reference Enemies = Class Name. enemies = vector array of active Enemies. cEnemy = (Pointer to Enemies Object)/Enemies* cEnemy. 

I am looking for 4-6 color schemes for three factions, good, evil and neutral (in a space strategy if that matters). I'd like the player to choose which side they want to play and each side will have an optional ally. Each team can have one or two colors (major/minor), if that makes the problem easier. EDIT: I know that color perception can be subjective, context sensitive and influenced by culture. I am looking for a scheme that majority of players would see as a traditional fight between Good and Evil (Blue and Red comes to mind when having only two colours, two factions). 

AndEngine exploits this by defining a 2D sprite that is a representation of the region. It uses ortographic projection to show textured quads. It is certainly not suited for drawing on "canvas". Using Line object is not recommended, because it is up to the OpenGL ES implementer how the line will look like in the end. Each implementation has to follow certain rules, but still the lines can look different. So your best bet is to: 

I'll assume that is of type . You are changing the sprite size and center of the scaling. That has no effect on the physics body. You can try using the method from the class. Not sure if that works for every , but it does work for circle shapes. If you are creating circle bodies like this: 

You can use method from the Entity class. The whole Scene is an entity and you attach all objects to it, so if you call all attached children will stop updating. Of course, you can selectively call this method only on Entities that you wish to pause. onTouch events should still work. 

I am working with AndEngine (2D, based on OpenGL) and AndEngine's approach to animation is to have one tiled texture where each tile is a frame. You can have 12 frames in a texture 1x12, 2x6 or 3x4. Because graphics hardware is very capable when dealing with textures, showing a region of the texture is very fast. Based on what engine do you use, or whether you make everything from scratch, you can probably use similar approach. This is actualy the SpriteSheet that @Katana314 is talking about, but I am not sure why he/she says it's not a good idea here.