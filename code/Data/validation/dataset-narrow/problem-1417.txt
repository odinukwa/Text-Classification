Unity also has a big and organized asset store with many free plugins available, that cover a lot of frequent requirements like AI or procedural content generation. 

You should not put render code into your update method. If you can break your code into parts where you would call Render(), you can also easily just exit for this frame and let the render function do its job. I'm assuming all resources that you want to load share a common interface that defines methods like and (and a few more for unloading). Given a list of these resources to load you have the option to simply load one and be done, like 

In addition to Martin Sojkas answer, for static objects (or sprites) you can get away with something simpler. You can save the same sprite but with the outline into your texture atlas or another texture entirely, which makes switching easy. This will also allow you to do custom outlines that are more visually appealing or just look different. The other method is to save the sprite as a one color shape that is slightly larger and render that just before the sprite itself is rendered. This will give you the ability to easily change the color of the selection, and you might not need as much different color shapes as you would need outline sprites with method #1. Both will increase your memory footprint though. 

Using SAT collision with rotated rectangular bodies on the mummy and the bridge. I tried having the mummy walk up the bridge by adding 3 mini-hitboxes on the bottom-left, bottom-mid, and bottom-right to him. I had a hard time trying to get this to look right and trying to stick all of the hitboxes onto the bridge and the floor (especially when I rotated the mummy to that of the bridge). Using Box2D Flash port library. Just doing something simple as this is seeming like an uphill battle with this physics engine. It looks as if it will be troublesome to get a predictable movement with a constant speed especially when going up the bridge. I've tried their 'conveyor' example, but for some reason, the classes that were used for it are missing in the Flash port. I've also tried disabling the physics and just using it for collision detection, however I dislike it entirely. I also don't receive any contact information for collision on the sensors (like distance, normal, point of collision, etc.). I'm better off with using my own SAT implementation for this task. I've also tried placing nodes above each end point and when a bridge is connected, the mummy will know to go from one node to the other when he collides with the starting node itself. This has drawbacks of needing to offset the nodes perfectly so the mummy's feet will always be on the bridge, so I'd have to make sure to never change the size of the character and the bridge. Also, I'd need two nodes per end point, since going down and up a bridge will need different offsets. 

I'm guessing each object has it's own System.Random object initialized with the same seed? Try making it static for now and see if that fixes the problem. Note: System.Random is not thread-safe see Getting random numbers in a thread-safe way for a solution, should you need it. 

For a small amount of voxels you could try cube maps with one texture per voxel. This is however quite wasteful and wasteful, and will not scale. Alternatively, if each face has its own texture coordinates you can create a texture atlas and modify the texture coordinates of each mesh. The next best thing would be to create a mesh where each is one face of your cube. Then you can set the texture for each face individually. This will however still not scale very well, but should fast enough for 750 cubes. 

You can easily use OpenID, there are a great number of libraries available. However users might have to create an account there just for your application. Integrating facebook/google/yahoo authentication is also easy, but I find requiring an account in a service I don't use/like, just to use an application extremely obnoxious. If you want to implement something yourself it is as easy as distributing a key with your application. Since that key is unique, random and only known by one user you can use it to log the user in, optionally requiring a password. You should store the key so that it is recoverable, like in the distributors cloud, on the receipt, or have the option of mailing it to the user. You can also require a machine-based authentication (like steam) where you generate a unique key from the machine your app is running on, register it together with the application-key to your server and mail the user a confirmation key he has to type into his app once. The machine can now safely authenticate without requiring a password from the user. The process has to be repeated every time the hardware changes though. Now that the user is logged in, you can store additional details about him, that you get from the platform he is using (steam, windows live, ...) or a contact form in your application, or data from the receipt, etc. If you give the users the ability to name themselves you should make the username unique, to allow search and friend requests. If you don't want real uniqueness, you can go the blizzard way and use GenericUser#1234. 

I'm trying to construct an editor in C# that exposes game components to IronPython, so it may create the game object definitions to be used within the editor: 

I'm currently trying to create a 2D platformer puzzle game like Mario vs. Donkey Kong: Mini-land Mayhem! within Flash. My issues reside in the bridge collision with the walking AI. The game allows the player to create a bridge from one end point to another at any angle. Then the player's AI mummies (in this case) walk across the bridge to reach another platform. Now, seeing that the bridge can be constructed at any angle, I'm only going to have a rotated rectangle to represent the body of it.I obviously can't use the typical AABB to check collision against this, instead it looks like I'm going to need to do a SAT or pixel perfect check. The AI mummy must always stick to the platform or bridge as it walks across it (not to mention rotate to the bridge's angle). Therefore, I suppose I'm going to need some gravity and sliding collision? The walking speed should also be the same on both the platform and bridge. Lastly, since I'm using a grid for my platform tiles (including the end points) connecting a bridge to them isn't going to be perfect. Going up and down the bridge may need some offsetting with floor in order to make a smooth transition from or two the bridge. An example Some things I have tried in the past week or two: 

If you do not want to create your own motion capture data, then there are several motion capture databases available, some of them completely free. 

If that is your first project, use Unity. It is easy to learn and will get your project done much faster. Compared to Unity, XNA is little more than a managed wrapper for DirectX. With XNA you have to do everything yourself, what Unity already implements seamlessly, there are of course libraries for almost everything specifically targeting XNA, but integrating that together is not always easy. For a complete list see the Unity webpage, but some things you would have to implement from scratch or find libraries for: 

Whether your functions block or not, depends on the specific implementation (library/language). It is however safe to assume that the function will block at least as long as it takes to fetch/write the data. The simplest solution is a second thread that does nothing but reading/writing. Instead of working with that data immediately, push it into a queue so it can be consumed by another thread(like your main game loop). Writing works the same way in the other direction. If the function call is blocking, call it with a small timeout, so you can switch between read/write fast and with minimal delay. Depending on what you are doing you should really think of using TCP instead of UDP. Unless you really need the speed and a lost packet does not need to be resent, TCP is usually the better choice. 

As a starting hypothesis (for simplification), I could make modification on any library/source as required. 

Event system is superior to Polling. The polling is a old technic that use innecesary CPU to test inputs. the event mechanism is better but more complex and require special hardware. As all game platforms have support for events, you should use them always. You may transform the input state to a "state" variable value to test if you really require to poll it. Events: 

As a recursive solution, each block should reduce a bit the energy, never increase it. The source of power can set a fixed value, but never increase based on inputs. That should not be an issue as all "real" system work in this way. 

So supposing you implement the addSibling and removeSibling, the most important part is the propagate function: 

For my application, there are several elements drawing: An user interface elements, and several libraries for rendering part of the content of the window. Lets imagine some kind of Google Earth where a library render the earth geoid and several buttons and texts on top (possibly with transparency). Something like that seem trivial, but it is not, cause OpenGL rendering on double-buffer at ~60fps and GUI elements are redrawn only on demand/changes for small portion of the window. One is by GPU and the other by CPU. One use a endless main loop that peek event, the other stay blocked until some event happens. The idea is to draw the 3D elements on an internal buffer (in Thread A) and from the QT user interface (Thread B) just take the picture and put it at its correct place. Thread A and B could also have some mutex/signal to synchronize. Questions are: 

Instead of path finding, you can also prioritize your steering components. Instead of weighting them 50:50 make it 40:60 with prioritizing obstacle avoidance. That will let you end up in wall some time however. You can also alter your steering output. If obstacle avoidance has nothing to avoid, use the other vectors(weighted or not), but if obstacle avoidance has something it needs to avoid, only use that. This however might give you jittery movement when you alternate between collision avoidance and not. A good solution I have found is to compute the other vectors first and then use them to influence the obstacle avoidance. The avoidance vector sets the lower bounds (right and left) needed to not collide and with the vector from the rest of the input, you can choose which vector is better(smallest angle). Add hysteresis, so you don't change from one direction to the other and you will get mostly smooth movement, without path finding. It is however still difficult getting the avoidance bounds right for concave objects. 

The Python script is loaded with all of the game object definitions. Tools are updated with the new objects (availability for painting). 

When saving, I use C# to serialize all of the constructed game objects (including the game object definitions generated from python) to a file. When opening, I use C# to deserialize the data. - Since the Python script is not synchronized with the serialized components, I will run into a big problem when I change anything in the script. 

One solution I had was to only serialize the definition name of a game object, therefore when I deserialize my data I will have to do a lookup for the target definition (created by the script) and simply clone it. But, it still will not be entirely in sync with the editor data (some data will be changed on each game object like for example the position (note when I say game object I do not mean the definition)). Another solution might be to use a database and save out all of my editor data to it (perhaps using the entity database in C#). I'm not entirely sure if this will solve my problem. Any help would be appreciated, thanks! 

That will render a frame after every resource loaded. As long as you can guarantee that not one resource will take longer than ~33ms - render time(=30fps) you will have a smooth animation. Alternatively you can load as many as possible while keeping track of a high precision timer until you reach ~33ms (render time should be close to non existent and since the scene will be most likely static you could go even further up) If you are loading huge resources that take long to load but absolutely must maintain a smooth animation you need to chunk your loading process further, or use another thread. For loading chunks you could consider giving the interface a function and load everything recursively before you load the parent resource. To actually get chunks of data to load you would need to prepare your data that way, like splitting a huge texture into smaller parts and have the parent resource assemble that together. Although I guess at this point a threaded solution should be much simpler.