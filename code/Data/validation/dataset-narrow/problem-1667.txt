What you are looking for is an address. If the device has no address, it's not on a network. I think hostapd can also work with inet6 addresses, beware if this if it may apply BUT: Note that current versions of will show the version of the (v4) address regardless, which is probably irrelevant to you you.1 It's only a genuine-ipv6-only address if there's no plain address. Beware interface will always have an inet address, 127.0.0.1, but this is not a true external network connection. The same information is shown for , etc. The first time you look at output you may want to use for some color but don't use that if you are machine parsing the output. There's also stuff in and (in fact I'd guess that's where gets its info from) but again, this is probably the simplest way. 

The distro has sources, but these are either the same as or slightly patched versions of the original sources -- a distro does not really contain any original software per se (discounting the package manager), it is just an original configuration of such. So there are the original sources and the probably mostly very similiar .src packages that are available via the package manager. I have never heard of someone rebuilding a particular distro from source, as this would be somewhat pointless, unless it is for use on a platform for which those sources have not been previously compiled (such as raspbian is to debian). Bluntly then, it does sound a little insane. I would not consider compiling everything over again from source a very direct route toward "modify[ing] the distro according to my needs". To a certain extent, compile time options are useful, but I think only in a small minority of cases (for which you can source build without having to do the whole rest of the system). The kernel is a little more straightforward, although unless there are specific things that you know you want from a kernel, rolling your own is a largely academic exercise (it won't make any real difference). I have cross compiled the raspbian 3.6.11+ kernel following the elinux guide using a crosstool-ng toolchain and it works, although there is a little bit of weirdness that followed from converting the 3.2.27+ /proc/config.gz to 3.6.11 -- eg, the ipt_LOG module was not built, which many people probably use in their iptables rules..that took a bit of tracking down. I think your best is to first decide specifically what "your needs" are and then get opinions about how to address those specifics, rather than starting off down the "start from scratch" path. Customizing an install doesn't generally require a lot of re-compiling, whereas building one all over again will take you months (if ever) to sort out and probably end with you realizing the same thing (it was mostly a waste of time). 

I need to configure my network connection using some low level commands, but I believe the autoconfiguration in Raspbian is complicating this. How can I disable it? And if I do, can I easily restore it again? 

My invocation may be a bit off there, but whatever you normally use should work. If there are spaces in the command, enclose it in quotes as above. If the script daemonized itself or otherwise goes to the background, it will be detached from the terminal which spawned it and that terminal will then exit. Your process may still be running (look with ), but if you want to keep the terminal up, try using a shell wrapper: 

The normative approach to Pi oriented development is to work remotely with files on the pi mounted over a network, using, for example, Samba, NFS, or SSHFS: Development on Raspberry Pi With regard to your IDE, you may want to look into something MinGW oriented, as this will use the same compiler (GCC) as used on the pi for things like code completion and error checking. You probably want to configure things to use the include path on the Pi (, ), also accessed remotely. 

You could probably implement virtual memory with or without hardware support, but in any case, the processor has an integrated MMU, etc. to make things easier and/or more efficient. I think the major advantage to using the pi here would be that it is small and cheap. If you wanted to do the work on one machine (a desktop or laptop) and apply it on another, which would probably make things easier, not using a full size system for the latter would be convenient. You could take this project to a coffee shop easily, etc. Of course, it's probably even more practical to just use a simulator in the first place, in which case you might as well write for x86. 

Quick Background The current version of Raspbian is 8, aka. jessie. Raspbian is Debian compiled for the Pi,1 with some configuration tweaks and an appropriately customized kernel. The current version of Debian is also 8, and a major difference between it and previous versions (Debian has been around for several decades) is that the init system, formerly a spin on the venerable SysV init (which is older than Debian itself) was replaced with systemd. GNU/Linux, like other unix derived operating systems such as Mac OS X, relies on an init system of one form or another. Systemd is a fairly new one first adopted by Fedora a number of years ago, and since then it has been gradually picked up by other distros (winning favor over Canonical/Ubuntu's upstart). 

The best connection you are going to get from a pi to anything is via USB, but that does not include normative peer-to-peer network connections (unless you get, e.g., a gigabit ethernet adapter). As Darth Vader points out, the USB and the ethernet jack share a bus, but the top speed of the USB side of things is much higher than the top speed of the ethernet side of things. The ethernet jack is the second fastest and is capable of a normal, network connection. In theory most wifi adapters are potentially faster, but in practice this is unlikely to be the case. However, connection via wifi on a LAN can be roughly on par with connection via ethernet on a LAN. A direct connection using an ethernet cable may be faster, but I do not think substantially so -- it may simply be more convenient, since you don't need a LAN, intermediate router, etc. After two or threes years using B/B+/2B models, in practice I would say the USB tops out around 30 MB/s and the ethernet may do 10 MB/s in bursts but is more likely to sustain 6-8 on average, given no other bottlenecks. 

PCM is the standard way that uncompressed digital audio is encoded for playback. It may colloquially refer to a source/sink of such a signal ("PCM interface" might be clearer), which usually requires a hardware clock to work, hence they cannot be created arbitrarily. Some sound cards and devices may have multiple PCMs available. Conversely, you may have a PCM available to the system which isn't really local. There's still a clock involved with the timing, but in this case it would be the clock for the transmitter/receiver, which isn't actually a "digital audio device". This explanation is conjectural on my part, but fits the facts. 

Login, and . It's there. isn't actually sourced by the shell, it's used by the authentication system (PAM) to set an environment before your login shell is executed. The idea here is to allow for setting env variables in a shell agnostic way -- while bash and other POSIX shells will source stuff like , other shells may not. However, the environment is actually part of, and inherited by, all processes (not just shells), so by setting it before any shell is executed, PAM guarantees those variables will be set. Of course, they can then be overridden and presumably this is what is happening with . If you are using bash, it is probably more hassle than it is worth to figure out what by, but very likely it is , since on Raspbian that contains: 

You do not mention which model of pi it is. If it is an earlier one (A or B, but not "2 B" or "3 B"), you cannot power an external drive and need a hub as already suggested. If it is a Pi 3, and you have a decent, 2+ amp power supply, this should just work, so something fishy is up. If it is a Pi 2 or a + (A+/B+) or zero model, you need to edit and add: 

No. There isn't much of a kernel driver for the pi's GPIO pins. I'm surprised someone hasn't gotten around to writing one, but there you go. 

Should leave you with that maximum. leaves the timeout as 0, so you could try that too (or just ...). 

1. Why that was necessary I don't know -- pidora does not do this, all the libraries are arranged normally. 

Etc. Here's the problem: a GUI display manager logs you in, but it's not a shell, so is not automatically sourced. And once you're logged in, the shells you start are not login shells. Most display managers compensate for this by sourcing anyway, but the designers of lightdm made the strange decision not to do this, you can find their justification here. Note they have a suggested solution involving X session files, which will work, but I'm going to suggest something a little more thorough. Now you're aware of this (look in , you'll see the addition made by the RonR installer), you can either use , meaning your access to rails will be limited to that shell and its children, or you can apply a trick in to append to path only when /foo/bar/whatever is not already there. Here's two bash functions, the first will prepend a string if it's not in already, the second appends: 

Note that the problem cannot be that is not running, because that will not cause a timeout. It will cause the OS to reply immediately with a message that the service is unreachable. So even if isn't running, that is not the cause of the timeout. 

Strongly implying we are out of luck WRT a raspbian package. Searching online for "libsgfpamx.so" and "sgfpamx" returns...nothing. Almost certainly these are esoteric or internal things that were built along with , and if you have them somewhere already you are in luck, otherwise you'll have to inquire with the people responsible for "mylib.so". 

and will show attached devices. I've noticed I often have to run this twice to get correct results for the latter and that sometimes the output is otherwise odd, however, I've been using both buses for a while now without any further issues. 

Configuring the network itself might be easier, but the program you have to write will be exactly the same either way, meaning, you could use either ethernet or wifi with it. The program itself doesn't know or care which one is in use. To explain more clearly: you should not have any code for configuring the network in your application code. Applications attempt to make connections assuming the system is on a network; they do not set up the system network themselves.1 Getting the network up and running may require a separate shell script of some sort, but ideally you should be able to configure the existing services and they will take care of that for you. 

I presume that the kernel accesses actual physical addresses on the Pi and always installs itself in the same place. If the exception log you get running the same kernel is always the same (or, using different kernels, always seems to involve the same addresses), this is a pretty good clue that it is bad RAM. Outside of really digging into the kernel code though, you can't really prove this isn't a hardware defect (including something other than the RAM), so it is up to you how far you want to go. 

The last two points in particular imply this device requires a lot of software, which has exactly zero chance of being usable in any way, on any model of Pi, using any operating system. Since the connector is USB and not a normal 3.5mm stereo jack, it could not be used as a normal set of headphones with the Pi's built-in sound system either. 

Because it can't do that properly. ARM cross compiler packages for various mainstream linux distros are, as far as I am aware, all ARMv7+. Something that gets confusing here is the "hard float" bit. This can distinguish arm1176jzf from earlier ARMv6 implementations; it's the last version of it. After that you have ARMv7, which I believe by definition is hard float, and so that is how Debian chooses to identify it. Note that page is linked from the SUNXI wiki page you posted, and includes further qualifications: