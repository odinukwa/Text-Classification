Now, it doesn't seem obvious but the two statements in the outter can be but in the other order. Then, we can again, move the common code out of the structure. Then, we, have an with a single inside, it calls for an to be used here : 

Before anything : your code looks nice and seems to be properly commented which is a good point. It could have been a good idea to give a pointer to some reference (wikipedia or anything else) as your implementation does not seem to rely on the usual sieve but on some kind of optimisation of it. This being said, from my point of view, a bit too long as you are using too many blank lines and too many lines for comment. There is only so much text I can fit on my screens, I'd rather read this : 

In both cases, we could generate the sequence [1, 2, 3, 4, 5, 6, 7] of length 7. However, the code returned 6. If you want to go further from that part, the code with additional tests and performance indicators is available here: $URL$ . 

Your code looks nice, is nicely formatted (10/10 according to , nothing wrong according to , etc), is properly documented, properly tested. I'd like to start by congratulating you for this. I still have a few things to say. 

takes a linear time in the length of the string. Thus, will call it times and the result will be quadratic. Changing this and a few other details (moving stuff to the smallest possible scope) and you get this : 

In , you are using to add elements one by one by replacing with . However, the pythonic way to write this is to use a list comprehension: 

g) It would probably be worth defining a method taking a string as an argument, prompting it to the user and asking him for a y/n answer until a proper value is given and return a boolean. 

Reusing code Now that we've played a bit with , we notice that they look very similar. It might be worth writing a more generic function to handle this : 

This is better but as I said previously, even having these methods in a first place seems to be against the basic principle of object programming. You should not need to care about the type of an object, the behavior of the object itself should be defined properly. For instance, instead of having a function checking the model class, you could have a abstract method, overriden in each subclass to have the behavior you need. This applies to . This needs quite a lot of changes, at this stage, the code looks like $URL$ . Then, the same principle applies to but it is trickier - work in progress in $URL$ . Index out of bound error I had a feeling that the boundary check in ithe loop was weird and indeed, giving an input ending with 2 (or more) digits, en end up going too far in the input and throwing an exception. I guess a better (but far from perfect) solution would be: 

Problem in your code (and in mine) : trying to make the test case a bit more interesting (at the moment, your example does not encounter any problem), I've discovered a problem. Indeed, I was adding Queensland as a neighboor of Victoria (which is still possible in a planar graph if the Sunshine State decided to invade the West Coast of NSW) and I got the following error : 

The right data structure The way you build , it might contain the same value multiple times. It is something we might want to avoid because it will not bring anything except performance issues. Instead of using list, you should use sets. 

Here, 'len' is called only a few times. I'll keep on working on the "slow" versions because it is a better starting point for your investigations but you know what you can do when it works. Rewrite interval checks Computing is slow because we'll compare to many values. What you want to know if just if i is bigger than 100 and (stricly) smaller than 1000. Python has a cool way to write this (you won't find this in all programming languages) : . 

More function Given the way you check if a number is prime or not, it probably make sense to define a function for this : 

As resolved will be False if and only if an element verifies the property . Also, this can be rewritten using builtin all/any : 

this does not correspond to the pythonic way of looping over a container. There's a cleaner way that doesn't involve indices. 

Also, as suggested in the other excellent answer, the names of the functions could be improved to be more explicit. The same comments applies to . Handling user input You perform check like: to handle the user input. You could simplify the logic here in 2 different ways: or . Then, a few details could be improved to make the interactions with the user clearer. It could be nicer to ask again if the user gives an invalid answer rather than taking a default decision (an empty input could be considered as valid if the prompts says so explicitely). If you do so, it is a good idea to define a new functions wrapping to handle user interactions and validation of input retrieved instead of having your input validation logic and your game logic mixed up. I'll try to continue this later... Bug in the distribution of the cards As far as I can understand, whenever a new card is given, you just pick a value at random. Then you'll get a behaviour which is not quite the one you'd have with a deck of cards. Indeed, in your case, events are independent. With a deck of cards, the probability of getting a given card depends on previous cards given (for an extreme example, once you've drawn 4 aces, the probability to pick a fifth is zero). 

Bug I've found a bug in your code : the number of elements in is not , it is . If you want elements, you should use which can be more concisely written . Tiny improvements In your class, you do not need to have and . It is not needed and will only bring confusion. You do not need to convert the return for in . Boolean are integers with value 0 and 1 so everything will work just fine. doesn't need to be a float number, you could give it as an initial value (and not ). I guess you did this only to be able to perform a floatint point division. The best way to do so is to use because this is the default behavior for divisions in Python 3. This brings me to the fact that if you have no good reason to use Python 2 (dependencies on libraries using Python 2 only), you should try to use Python 3 to take the good habits. You have different methods to format strings which are all better than string concatenation. You'll find a lot of documentation about this. The plural for "try" is "tries", not "trys". At this stage, the code looks like: from future import division import math import random class RandPoint: def init(self): self.x = random.uniform(-1, 1) self.y = random.uniform(-1, 1) 

How nice is this ? Pretty much everytime you initialise a variable at 0 to use it as an index in a loop you are doing it wrong. If you really need to know what is the current index, enumerate is what you are looking for. 

Simplify The best data structure for the logic you want to perform is a dictionnary mapping operators to functions. 

Less verbose computing functions All the small functions have a similar logic: keep trying to apply an operator to 2 values if they are not None. Because of how things are implemented, it is easy to get wrong (you can copy-paste someting and update the check or not the operations). It is also tedious to add a conversion because of the amount of boilerplate. This can be written in a more concise way with a minimal amount of magic. With: 

(I've used as a variable name because this is the convention for unused variables in Python). Split the logic into smaller functions At the moment, the logic related to input/output is mixed with the logic related to the actual algorithm. It would make things clearer to write proper functions to handle this properly. 

Style Python has a style guide called PEP 8 which is definitly worth reading and and worth following if you do not have good reasons not to. In you case, your function name for instance is not compliant to PEP8. You'll find tools online to check your code compliancy to PEP8 in a automated way if you want to. API / Function signature Your function signature is a bit unclear. This situation often happens when recursive solutions are applied. A good way to solve this would be to define another function calling the complicated function with the right arguments or to use default arguments. If I understood everything properly, the point if to get the n-th performutation from a list. A simple way to do so would be to have a function taking the and the as an argument. Testing In order to keep things simple, it is a good option to write a simple (even if inefficient) solution to be able to see patterns and/or write tests to ensure that your more efficient works and is indeed more efficient. A very simple solution could be written like this : 

and shouldn't be considered as primes. Again, fixing this is simple : initialising as being in the basic function and setting in the optimised function. Improving the code for the optimised version In , you can factorise code by writing : 

The difference is that one operates in place and the other one returns a new list. Your code does both which is likely to be confusing. Other various comments You could (and probably should) pass the sorting function as a parameter to your testing function. You'd have something like : 

Algorithm This is probably where it gets interesting : you have not properly implemented the sieve. At the moment, you apply the logic (from wikipedia) for being the in but you should (or you can depending on the point of view) restrict yourself to prime values of . This corresponds to adding . This should have a huge impact from a performance point of view. A tiny problem There is a variation of the quote above that goes like this : 

You don't need a class In your current version of the code, it is hard to see what is stored in an instance and how the data flows around the different methods. If you do write a class, I find it clearer to have an init to define the different members but in your case, you could stop writing classes. Removing the class, you get something like : 

Count like a native Title borrowed from Ned Batchelder's excellent talk called "Loop Like A Native" which deals with the point I am about to make. You don't need to keep track of as you iterate over the tags. You could use the builtin function. to write : 

Simplifying operations Instead of divising by a fraction, it may be easier to perform a multiplication and a division: 

Edit : An attempt to correctness Here what I have written , it seems to work fine but I won't promise anything. 

Loop with the proper tools Instead of using a convoluted loop to perform iterations, you could use a simple loop. Taking this chance to have initialised at the beginning of the loop, we'd have something like: 

User interface Instead of having a user input the number of the tile to move, a different idea could be to input the direction to slide (up, down, left, right). Then it could be played with the arrows of the keyboard. Also, this may simplify parts of your logic. 

Simimarly, the divisibility by 9 does not need to be checked because of the following rule (and the fact that the sum of the first 10 numbers is divisible by 9) : remove that check and you have yet another performance gain. However, for an actual gain, you could go the other wat round : trying to build number by looking at the different candidates of length 1, 2, and so on. Here is how I did it and it seems to be really fast :