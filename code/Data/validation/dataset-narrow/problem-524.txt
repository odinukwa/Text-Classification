Here's a working snippet that demonstrates another method of using closures to maintain live references to HTML elements. 

I find that the native equivalents to jQuery wrappers tend to be more explicitly and precisely named, making it easier for me to recognize mistakes and intentions and making my code more maintainable in the long run. 

It looks like your code is essentially converting military time in number format to 12-hour time. Suggestions 

Here's a working example of the function, along with the function that I use to attach it to the mouseup event on row elements. 

is not supported by Internet Explorer. If you don't care about supporting such browsers, then don't worry about, but if you're coding for a public website it's worth noting that IE still represents about 4% of the global browser market share at the time of this response. Despite not being an array, the HtmlCollection object returned from will still have a length property, so consider instead using a normal loop or loop to access the set of elements. For example, instead of this... 

Improving performance by using native methods whenever possible Another thing you'll want to consider if you're worried about code performance is whether you can replace any of the jQuery shortcut functions with the analogous native methods. For example, will always outperform , and assuming they're supported by the browser and will always outperform . and can be called on any element (not just ) so you can also replace jQuery's method for similar performance gains. The native methods will also increase the verbosity of your code (and thus the number of bytes that must be downloaded), so take that advice with a grain of salt; personally, I find that the dedicated native methods also make the code more readable and thus maintainable. 

Edit: even better, as you noted in your followup comment, just update directly and you won't have to deal with ! 

code layout For code cleanliness, I recommend rearranging your code so that the function definitions are all together at the end, after the imperative commands. 

It works its way down from \$n\$ to 1, adding \$2^n\$ along the way, and returning the sum as a final result. 

Efficient Looping in JavaScript Many browsers will see a performance improvement if you make a slight modification to your for loops. Take a look at your for loop in the function: That loop requires that the browser check the length of the array after every iteration. Since you know the array's length isn't changing, you can cache that length at the same time that you initialize your iteration variable. 

Note that there are also native JavaScript equivalents for manipulating HTML within HTML elements (such as and ). Table elements in particular have their own special properties and methods for manipulating their layout and presentation, as documented here. Cache reused HTML elements and collections to limit DOM queries If you have code that queries the DOM using any of the selector methods I mentioned in the above section, you can save the results to a variable that you can access at will. That way you don't need to re-query the DOM for those elements if you need them later in the code. The exception to this is when the DOM may have changed and you want to get the latest version, in which case you generally need to re-query the DOM. Avoid polluting the global namespace You can avoid creating global variables by simply wrapping all your code in an immediately-invoked function expression (IIFE). 

Using the 'const' modern language feature If you don't need to support older versions of Internet Explorer, you can take advantage of the keyword (introduced in ECMAScript 2015) for any variable whose value never changes. This not only makes it easier for you to detect any inadvertent logic errors introduced by overwriting those variable values, but it allows the browser's JavaScript engine to optimize its handling of those variables since it knows they'll never change. Your and variables could be defined as constants at the beginning of your IIFE, as could your references to HTML elements. 

The above code first grabs all the elements with the container class, then sets the interval to run on each of them. Minor nitpick(s) You don't need that semicolon at the end of your statement in your vanilla js example. Supporting older browsers (if you have to) IE9 and below do not support , so if you want to support them you'll have to use the property. To remove a class, something like this would work: 

If you find yourself using and want to be more angular, check out the service in the AngularJS API. In addition, for your purposes, you might be better off using . waits for at least one digest cycle before executing the expression, which might be enough for the DOM to have the new elements added (though not yet rendered). This can prevent the "flicker" that you otherwise get from waiting for elements to render before manipulating them. The only reason to not use would be if you're dependent on the DOM rendering for accuracy. 

Using Function Expressions Now with all that being said, sometimes having to define multiple functions just to insert logic farther down the execution chain actually hinders readability. A function that's only ever referenced once, and only because you need to pass it as a callback, isn't doing anything to keep your code DRY (Don't Repeat Yourself), and can make it more tedious to debug or map out the chain of execution events. For these reasons I'll often use inline function expressions instead of defined functions for callbacks. Inline function expressions can replace your globally defined callback functions, such as , and . I mentioned at the beginning of this answer that I dislike polluting the global namespace with variables. Using function expressions, I can refer to variables defined in the containing function without needing to attach them to the object. (Read about closures in JavaScript to understand how this works.) This is definitely a matter of personal preference, but I prefer the code reformatted into a single function with nested function expressions for the callbacks, like so: 

This ensures that is invoked every 80 milliseconds while typing out the search text, and then every 10-seconds between search texts. Another option is to use the method to make sure you don't have duplicate timeouts for the same function call running in parallel. 

Timeout/Interval Overlap This one's not a biggie, but it's good to be aware of when working with and . Your interval function is running every 10 seconds to invoke , while within the function a timeout is running every 80 milliseconds to invoke again (until the end of the search text short circuits that behavior). If the code happens to be in the middle of writing out some search text when the 10-interval kicks in, you'll see some unusual behavior: multiple characters will be written within 80 milliseconds. For something like this, that's probably not a major issue (you'll only see it happen when the search text is abnormally long or the interval time is abnormally short), but if you want to account for it, you can eliminate altogether. Instead, you can put a 10-second timeout in the "dead end" branch of the function (the block that short-circuits the 80-ms timeout upon reaching the end of the search text), just before the statement. 

This can be corrected by replacing with in this instance. Note that the primary difference between and is that is block-scoped, while is function-scoped. Since the block containing this variable declaration is a function anyway, you don't gain any advantage by using . IE11 also does not yet support arrow (=>) syntax for lambda functions, but if you don't have to support such users you can ignore that problem. Avoid modifying directly Direct modification of an element's property should be avoided whenever possible. It has performance drawbacks (forcing the browser to re-evaluate the DOM with each modification) and it can create memory leaks (when code retains references to elements that have been destroyed by overwriting their HTML). Instead, consider these approaches: Clearing To clear the innerHTML without creating memory leaks, instead of you can use a loop to remove all child nodes: 

To use that in your code, you'd need to change the string to an array and sort it, as in the code below. 

One way to fix that would be to simply remove the If statement . Without that check, regardless of whether the parameter is already set to the specified value, it'll be overwritten with the desired value and the URL string will be returned. Original Sin does not exist in older versions of Internet Explorer (9 and down). If your user base doesn't overlap with those poor souls still using IE9, feel free to ignore this one, but otherwise you could do something like this: 

I'll also second James's suggestion to rename those arrays to and to reflect their plurality. Capture Element IDs and Min/Max Values in a Data Structure Currently, you have the min/max values and element IDs directly in the code wherever they're needed. You can make the code easier to maintain by moving those values to a separate, dedicated data structure. I recommend using an array of objects. Then you can loop through the array to perform the necessary operations, which makes adding more elements/images/links almost trivial. 

In the SharePoint Static Class: I would recommend against naming your simple class since that sounds awfully similar to the namespace. I'd also rename the method from that class to be more descriptive of what it truly does. makes me think it would be creating a list in SharePoint, but it's not really building anything, it's just returning the list item collection. would be much more explicit. In the MMTreeBuilder Class: I find code is more readable when all method names are verb phrases rather than nouns. Each method name should describe what the method does. You've done this for all of your methods except one. The method name sounds like a class; I'd rename it to something like . 

Von Neumann extraction is a technique to remove bias from a source of entropy. You extract an unbiased array of bits from a biased one by comparing pairs of consecutive bits in the array and returning the first one when they are different, or nothing when they are the same. The extracted array will be smaller than the source array, but will be more balanced in terms of overall 0s and 1s. To accomplish this in JavaScript I ended up writing two extraction methods: one for extracting a bit (given an array and an index) and one for extracting an entire array (given an array). The code appears to work as desired, but I'd love to hear any insights or suggestions related to best practices, naming conventions, performance concerns, or problematic edge cases. Here's my bit-extraction method: 

This way your script is almost good to go if you decide to have another sale that spans a different number of days. You'd just need to update the array to reflect the elements on the page (and update the of course). 

This also eliminates some repetition from your original code, which is always a good sign. Note that for improved DOM-query efficiency, you could use the native JavaScript instead of the generic jQuery selector function. 

Cleaning up the Arrays I second JamesBodgan's suggestion to store only the image attributes and link attributes in your arrays instead of storing string representations of the HTML. This will change the way you consume the values from the arrays. You might want to create a couple functions that create the actual HTML elements from the given attributes for you.