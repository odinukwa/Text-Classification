I think your problem is the fact that SDL_SetPaletteColors wants an array of s as an argument instead of pointer to a single color. I cannot guarantee that this is the problem as you didn't post the code where you initialize the code, and you haven't told if returns an error message. Otherwise, make sure to always check what returns on a SDL function you think might be the cause of the problem. 

You forgot to initialize your pointer. Currently you only declare the pointer with , so there is actually no memory allocated for the event. You need to either change the line to and change the while-loop to , or you can manually allocate space for the event by calling 

The easiest way to do this is to use String.split to find out the different parts of the date. The following is pseudo-java but it should give you the idea. 

You are referencing in your document.ready-function, even though it's not defined at that scope. You should switch that line to . 

Basically the idea is to split the string at each "." character and parse the data between each dot. You can also take different order formats (MM.DD.YYYY instead of DD.MM.YYYY) into account by just swapping some indices around. We use the sequence to match the single character "." because the method wants a regexp pattern. 

As for simplification via merging individuals into groups, the nearest thing I can think of is Stochastic Simplification, used for foliage and hair/fur mainly - it was used by Pixar in Cars for the bushes and Ratatouille for the fur. Check out these slides which get the general ideas across: 

In virtually all shooting games that use ammo, there is also a maximum ammo limit, which often varies between different ammo types. One obvious advantage of using ammo limits is to control the scarcity of ammo, so that players cannot excessively hoard it and drastically affect the game's difficulty. What factors affect the size of ammo limits? An obvious factor would be the rate of consumption; if an ammo type is used by rapid fire weapons, the limit for this ammo type should be higher. But it should be obvious that there are many other factors, since some types of ammo quickly run out and others never seem to. As a designer, what factors should guide my decision for ammo limits, and when/why would I deliberately constrain or expand an ammo type's limit? 

The caveat is that on very steep slopes, you often end up jumping backwards. No jumping on slopes Maybe you decide that slopes are kind of special and it doesn't make sense to jump on them. For example, stairs are a special kind of slope, which in some games you can't jump on at all. 

Sorry for the complicated (?) example, but that should outline clearly what the important trick here actually is. This might not be the most effecient way, but already the fact that the level "geometry" is laid out in a grid makes the code a lot faster and simpler, as you don't need to actually go to look for collisions, you can just check a couple of positions. 

The answer at $URL$ suggests that you are using a version of OSX or XCode that is not currently supported by Unreal Engine. I don't know the version you are using, but you should check the UE documentation and make sure you have the correct versions. Otherwise you could just try to edit the method declaration in the error to . See $URL$ for reference. 

Take a look at Awesomium. I have integrated it to SDL before and the process was fast. The biggest thing you have to deal with is translating SDL events to Awesomium. Otherwise the rendering is really easy, you can just query pixel data from Awesomium into an SDL surface IIRC, and then render that to your game. 

You need to add an event loop for your window. The following code is directly from a pyglet quickstart tutorial. You basically need a function that gets called periodically. After that you can then just ask pyglet to run the application. Here's a basic draw function: 

You can play around with the number of iterations (it's set to 1000) to see what results you prefer. Note that for platformers (you mentioned terraria) you would want to make sure players can't get stuck, that is there are no platforms for the player to jump out of. Platformers also prefer caves that are flatter than they are deep; you can modify the random walk to bias horizontal movements more than vertical for instance. 

There is no need to ping if you are using TCP. TCP has built in mechanisms for detecting disconnects, congestion, or easily deriving latency. To elaborate: 

You are right that directly coupling input handlers with actors introduces messy situations: for example, what happens if the actor dies - do you add alive checks in your input handler, or do you go through all your input handlers and invalidate their actor references? What if you are in a different context, like a modal menu? I'm reminded of the MVC pattern which deals with a similar problem: by introducing an intermediary controller between the models (your actors) and views (your input handlers), you can interchange different views and models without affecting the other, and you get a lot of flexibility. Therefore I think you should have some intermediary between your input handlers and actors. A common solution is to, yes, use the Observer pattern. One of your actors and input handlers agree to observe/notify on a common subject: movements for player number 1, so any time the input handler notifies about player 1 movement, the observing actor will move in reaction. The neat thing about this little bit of indirection is the flexibility you get: 

It means that all existing textures are freed. I checked the SDL source and inside the function they do this: 

So the main point is the line inside the function, which I suppose updates the tweening time. Also make sure to use a small speed, or tweak the time calculation otherwise. A speed of 2 seems to look nice to me. 

Remove the from the other conditions, as only the first condition triggers. That is because something greater than or equal to three is also greater than two. 

For some reason the tween library requires you to update the tween inside your function, and calculate the time using something like the following: 

The problem is that you are passing the flag to your window in , but then you are using the for rendering. You need to remove the flag for to function properly. 

This assumes that you already have created an called with the correct viewport size. Awesomium then offers an utility method that you can use to put the pixel data to the texture. You're right on the fact that the texture needs to be created with the flag. I also used the flag on the texture. Anyways I find that this approach is somewhat cleaner atleast for someone who's not familiar with Awesomium's class design, as it's mostly using SDL calls and then just a simple call to an Awesomium method. After that you're just free to render your texture to the screen. Oh, and if you would like to use the Awesomium custom class structure, I'm sure you can figure out how to adapt this example code to put into use there. 

There are many ways to skin this cat, but the easiest may be to create a doppelganger sprite, constrained to the discrete coordinate space. That is, make your actual sprite invisible, and set a second sprite that follows the main sprite with discrete movement. 

There are also other handy features in Tiled; the trees you see in the tileset will be loaded as separate tiles, but you can use Tiled's Brush features to draw those trees in one go. There's also the Terrain Tool which helps you paint tile transitions, after you've defined the border tiles. From there, it's best to treat the tile maps as a whole, via the frameworks that support TMX maps, rather than individual tiles. For example, you would load and render tile layers, or draw all your "wall" tiles in the same layer and perform a layer collision. There is usually no need to split a properly-authored tile set into individual tiles. 

Now we have our first solution: 8 bars. Going back to the matrix, since any set of values that satisfies those row equations work, we can also try 5 cakes, which forces us to choose 1 pizza: 

It may seem that guessing and checking repeatedly like this is inefficient, but most games have very complex rules for whether a spawn point is valid. Your game rule may dictate that players can't intersect each other, or over certain objects. Your map may have inaccessible areas. You may want to spawn close to some things, or further away from others. It doesn't take many of these rules to create quite a complex function, and certainly one that is too complex to guarantee your guesses are successful. Therefore unless you are spawning hundreds and thousands of players per game tick, this sort of loop should be ok, even if you iterate hundreds of times in this spawning loop (just make sure the loop terminates). Another advantage with this approach is that it's very easy to make; your game probably already has routines to check whether spawn points are valid, as part of your normal gameplay. can be as simple as creating a random point. Just be careful that it makes a good enough guess, such that the guess has a reasonably good chance of being valid. For instance, avoid using a completely random guess over your entire world dimensions if your map is very sparse. Your idea of using a spiral is good because points next to existing players are more likely to be valid spawn points; just be aware that your suggested algorithm will tend to spawn players close to others than further. Finally, the reason why we should handle the extraordinary case where we don't manage to find a valid guess is that, for non-trivial game rules and map layouts, it's hard to guarantee that we'll find a valid point, in all cases. For example, you may (inadvertently) specify game rules that players should not spawn in sight of any existing players, but apply it on a wide-open small map (where every point is in sight). Therefore you should think about what should be done if you cannot find a valid spawn point - is it ok to try spawning again later, or spawning in a position that breaks some of the rules, or not spawning at all? These are the general issues you should be keeping in mind. 

Now, you should also note that modifying textures in code is relatively expensive. Also the code is not very clean, as editing C++ int pointer arrays and translating colours into different formats can cause problems, as what goes on where might not be as clear as needed. However doing this only when absolutely necessary shouldn't cause too much problems. You also might want to consider using and modifying the texture by rendering to it. However for some tasks, rendering primitives to the texture might not be an option, and that's a case when modifying the pixels like this might be come handy. 

According to this thread it seems that creating OpenGL contexts from foreign windows isn't currently supported in SDL. 

Colouring SDL textures might be a little tricky. The following code should outline the main points of colouring a texture. The key is to fetch all required data from SDL before starting to alter the texture. 

I didn't go with the way of implementing a custom Awesomium class for this. Instead I just updated data of a single texture by querying the surface from Awesomium. 

According to various different threads it seems that there is no OpenGL initialization code in , so OpenGL context initialization won't work with that method. If you are building your own SDL binaries, you might want to consider modifying the function by adding the correct flag to the correct place in that method. It seems to be what people experiencing this same problem have done. Why are you not using SDL for window creation? Letting SDL handle the windowing makes it easier for you to develop, and it will also make your project more cross-platform. When you create the window using , just remember to pass in the flag to the creation, and then you should be able to create your OpenGL context just fine. 

I think there's your problem; your game should only have one timeline (for gameplay-affecting things). You say that certain things grow at a rate of X per second; find out how many game steps are in a second and convert that to a rate of X per Y game steps. Then even though the game may slow down, everything stays deterministic. Having the game run independently to real time has other advantages: 

There's another tip here and that's to make the tutorial text as unobtrusive as possible. A text bubble that floats over everything is distracting. If it's in the background, or is something that could be brought up at will (e.g. signs that can be read, or NPCs that can be talked to): 

Phaser doesn't have built-in support for any fancier gravity, so you'll have to roll your own. Fortunately it's fairly easy to understand, so you just calculate your own gravity in the game's function, which is simply a (properly scaled) vector from your player to the planet's center of gravity, and set your player's property, or you can manually add the gravity vector to the property. Here's an example of the first approach: $URL$ 

I'm not aware of this ever being used, and I suspect it's because it has very limited benefit for greatly increased complexity and bandwidth use. It might make an interesting experiment, but it seems impractical. Consider that to support such a scheme, and assuming that most traffic is generated from player actions, you would need to double the downstream traffic and multiply the upstream traffic for all clients, not to mention opening a large amount of new connections. Double downstream because now you are receiving player commands from the peers as well as the server. Multiple upstream because clients need to send their commands to all peers as well as the server. But perhaps the biggest cost is that you run into tricky situations when you now have three points of reference. With a traditional client-server architecture, there are two: the client and the server (technically the other clients have their own points of reference but the server multiplexes them into a consistent, single one using techniques under the latency compensation umbrella). Now you have three (or more): client, server, and peer. Consider this scenario: 

Here's a small pseudocode example of something kinda similar to the system I'm using for my game. Basically the important trick here is to check both the topleft of your player, and the bottomright of your player, which is enough as your player is rectangular and of the fitting size. If the player character would be bigger than two tiles, you would have to check more tiles. 

You need to set the size of your destination rectangle. Currently you're rendering a 0x0 portion of the texture. So change your code to also include the size of the preferred result. See $URL$ for more info. Assuming your image you're trying to render is 32 wide and 32 tall, you would need to set the size of the rect like this: . Then as you're using as the source rectangle, SDL will stretch the texture to the size you want. 

You close your font with at the end of your constructor. Remove that, and then the rendering should work. You want to move the closing code to the destructor. Also, you release your first at the end of the -classes constructor, and then you do that again in the beginning of . You're essentially trying to delete already deleted memory, which obviously is something that might crash. You don't really even need the -member, it could just be replaced with a locally scoped variable. 

Now compare this with a typical Perlin noise generator, and you can see how it's much better at resembling mountain ranges. This just looks like blobs to me: 

Well according to the rules of the game, the AI is doing the right thing - moving towards the player every time! It's only due to a quirky situation that the player can "trap" the AI in a loop: 

I highly recommend you implement it using the gettext system. It is widely ported and very well supported, for example having lots of tools that support its workflow. One workflow is to add gettext calls in your code like this: 

It depends on what you want to do, whether it's GUI-like or game-like. Most game situations only care about where the mouse is right now, so you go through all the mouse move events and simply act on the last one. This would be per-frame. One example is using the mouse to look. However, there are some GUI-like situations where the intermediate mouse positions are all important. Consider drawing freehand curves using the mouse - your player could have fast hands and a high-frequency mouse, compared to your slow frame rate. If you only used the per-frame mouse positions, the output would be very jagged. This would be per-event (or what you call "per-update"). It's rare in games, but those using mouse gestures might be a good example. So unless you have a GUI-like situation where freehand curves are drawn, stick with per-frame, except for press/release events, where: