Most of your code is just repeating the same instructions over and over again. Define arrays newStats, deltas, and statMinimums, and your entire LOSSES block can be collapsed into one line of code: However, before you try to figure out how to implement what you want, you need to clearly define what it is that you want. What exactly do you want as far as the distribution of stat changes? There are several different methods, depending on what distribution you want. For instance, if there are n stats, you can: 

What is your desired output? Your function has no return statements (other the one commented out), and the only print statement is in the block. Have you run this function? Unless I'm missing something, it won't do anything if you input 0. And when you strip out the last digit, you don't actually store it anywhere, so it's just gone. You seem to be doing double tabs for your indents, which makes it hard to read once you get several levels deep. Also, you can save yourself an indent level after the block; since you have nothing but an block after this, you can put a return at the end of the block. Then you won't ever get to the block unless the condition is false, making the redundant. So you can get rid of that and move everything in an indent level. You don't show what face_value is, so it's hard to evaluate your code when it comes to that part. Also, unless I'm misunderstanding, the block should be something like this: 

Enhancements: You might want to listen to the "blur" event and deactivate the dropdown when its focus is transferred to an outside element. 

Of course, you might want to encapsulate above code in a function or even more versatile, a generator function and replace with . However, since you only have four different step-sizes of 1, 10, 100, and 1000 you can encode them manually and come up with an even simpler generator function as follows: 

Also, it is not clear how strong the given assumptions are and whether or not violations of those assumptions can occur and should be dealt with. 

Especially the last two changes are subject to personal preferences - some prefer the declarative style, some stick to everywhere - it's your (team's) choice. 

I recommend removing the inline event handlers from your HTML document for a cleaner separation of markup and logic / JavaScript similarly to how you separate markup and style / CSS. You can then add all event handlers with a few lines of code as follows: 

Edit: You could move the declaration of both event listeners out of the loop body. However, the dropdown toggle's 'click' event listener needs access to the dropdown element it belongs to. So you would still need a closure or alternatively bind the event listener's to the dropdown: 

if you're having trouble understanding , consider the case of generating the 7th number. This is going to be 4+7+13. But 13 was calculated by 13 = 2+4+7. So the 7th number is 4+7+(2+4+7) = 2*(2+4+7)-2, which is 2*(6th number) - 3rd number. So the nth number is 2*(n-1)th number - (n-4)th number. This does require handling the first few rows separately. One way is to manually create them, and then if you don't want them, you can delete them afterwards. Note that if you're deleting them, then you don't have to fill in the ratio column for those rows. You will also have to initialize to the proper value. 

Your variable names should be more explicit. Most of them are a single character, and even the multicharacter names are rather opaque. , for instace, would be more clear if named something else, such as . You're using integers for values, but it's not really being used as an integer. Your code would be more readable if you assigned it strings describing what each state consists of, such as . You're using conditionals where a case statement would be more appropriate. Your last case sets to 2, but I don't see how you get to that unless is already 2. However, since you're progressing through each of the values of , the whole structure of the while loop is inappropriate. You have three things you want to do, and the second always happens after the first, and the third after the first and second. The natural things to do is: 

In addition to the remarks given by Blindman67, I'd like to suggest the following: Passing options: The first few lines of your function are some kind of configuration block: 

returns an array. So don't bind the result to a variable called . Or better, since you can't have multiple array entries with the same name, replace with : 

Now, when the number of pages changes, you need to touch your code and modify the initialization. So you will probably want to introduce function arguments with default values: 

It is not obvious to me why the arguments and are given as instance properties and defined within the constructor function. By doing so, you create a stateful object which is more difficult to understand and test than e.g. a simple 'pure' function. Also, by setting the flag, the semantics of your method are no longer compatible to the meaning of . How about two methods and ? The suffix indicates that the return value is a complex object containing index and value, comparable to e.g. or . Those established methods iterate or return arrays instead of objects, so you might want to consider following this established pattern, too. Instead of passing an flag and relying on instance properties and I suggest a method signature such as and passing (or not passing) a delta argument. I would replace the many for-loops with a single . You would then have to lookup and and return either one depending on the given flags. Don't forget to test for the corner case when and consider handling it appropriately. If you had to handle more than 20 values, I'd implement a binary search and - if the number of queries for a given array of values is large, built a binary search tree first. This would improve runtime complexity from linear to logarithmic. But for just up to 20 values, the built-in or even an explicit for-loop is surely faster. 

These lines seem to be based on the assumption that all numbers eventually reach 1. While this has been verified for numbers you are likely to come across, it hasn't been proven for all numbers. You might want to instead check whether you've entered a loop. Also I think it's better to explicitly return whether than relying on Python returning the last line executed by default, so you should have . And get rid of the semicolon. Also, you're repeating a lot of code. The only difference between the odd and even case is that in the former case you have and in the latter case you have . The and statements are the same. So you can simplify your code to the following: 

You could do this treating the number as a object rather than a , but I don't see that treating it as a is all that unnatural. 

You don't really need a method. You can simply have a object with a method that randomly picks a card from the deck. Whenever you need a card, a card from the , and part of the method is removing the appropriate card from the . If you have eight players, you'll need to draw 21 cards. I suppose conceptually it's nice to "shuffle" the 21 cards you need before dealing any out, and to include the other 31 cards in the "shuffle", but I personally don't see much value in doing all that work just to imitate more closely how "real world" poker is implemented. You seem to be using for both the position and the value. You should distinguish between the two, e.g. versus . The line is really weird. Apparently you're initializing the pot with the blinds, but are you removing the blinds from anyone's chip stack? You should have a bet method, and "force" the two blind players to call that method. Also, having a method named "Shuffle" that does a bunch of stuff other than shuffling, such as initializing the pot, is bad naming. I think that betting order should be an attribute of the table rather than the players. There's no need for a player object to know what its betting order is; if a player wants that sort of information, you can just pass them the entire table configuration (that is, I can see a player asking "What's the betting order", but I can't see a player asking just "What's my betting order?"). The table should have a blind method that adjusts chip totals for bb and sb, and it should have a method that asks the current player to act. Both of those methods should know what the betting order is, and be telling players when it's their turn to act. If the player objects know who is sitting to their left and right, then you can just have the table ask for a player to act, and then ask for the next player to act, etc. Instead of doing , you can do , and then you don't have to do . Under the hood, this is more complicated, but conceptually it's simpler; the button just moves to the left. Other things such as the betting action can move similarly. Adding 2*cnt to a number and then taking the result mod cnt is a bit odd; should give x for every k. 

First of all, your given sample features zero-padded 2-digit months and milliseconds which you currently don't reproduce. The mentioned 'smell' is probably caused by 

I recommend to follow this 'natural' structure and solve these two tasks independently. Generator functions are a great tool for untangling your seemingly interwoven code and pushing individual functionality into their own reusable, testable functions. They are especially useful when you are not interested in storing intermediate results but rather want to directly process (e.g. print) them: 

Also, I use inline comments to help the reader and my future self to understand complex statements such as 

Replacing above regular expression with e.g. a much more refined allows you to capture floating point numbers, negative numbers and whitespace. To support more operations, simply append them to the object literal, e.g. and add to the operator capture group within the regular expression. 

Encapsulation When your projects get bigger, a clear separation between individual parts of your code becomes more important. Reduce interdependency, limit the scope of your variables, keep things local and well contained. All this facilitates reasoning about and understanding of your code as well as debugging, testing individual parts, reuse and more. The properties and methods needed to store and update a custom date are a good fit for a custom object type, a . You would start with modeling a simple date. A concise representation of a date is given by the seconds passed since 1888, similar to a Unix timestamp which counts the seconds passed since 1970. All other variables such as minute, hour, day, month or year can be computed from that timestamp, given we know how many seconds there are in a minute, hour, day and so on. To incrementing such a date by one second, you would simply increment the timestamp. It is a good idea to hide the logic which derives these dependent variables from the timestamp behind getter and setter methods. This would allow you to e.g. introduce leap seconds later on without having to substantially change the interface of your date class and thereby the code which interacts with these dates. It is equally helpful to separate your model from the way it will later be represented on the screen. Formatting a date depends on the user's language and locale. Integrating a formatted date string into the user interface should be part of the view layer of your application. Here is one possible way of encapsulating a custom date within a class and some formatting functions: 

One strategy: Do binary split of , and for each split, keep track of the smallest number of that is greater than or equal to the largest element of each branch and the largest number of smaller than the smallest element of the branch. Once those two numbers are adjacent, don't split that branch any more. So, taking your example . I'll split , with scores in brackets surrounding each branch in bold. At iteration 0, I have {[120]( 100 100 50 40 40 20 10 )[5]} That is, I haven't done any splits, so everything is in the same branch. The largest number of the branch is 100, and the smallest number of larger than that is 120, so 120 goes on the left of the branch. The smallest number of the branch is 10, and the largest number smaller than that is 5, so 5 goes on the right. In iteration 1, I have: {[120](100 100 50 40)[25]} {[50](40 20 10)[5]} iteration 2: {[120](100 100)[50]}{[50](50 40)[25]} {[50](40 20 10)[5]} Since there are no numbers in between 120 and 50, the first branch is done splitting. Since there are no numbers between 50 and 25, the second branch is also done. So the next iteration moves on to the third branch: {[120](100 100)[50]}{[50](50 40)[25]} {[50](40 20)[5]} {[25](10)[5]} Iteration 4: {[120](100 100)[50]}{[50](50 40)[25]} ]} {[50](40)[25]}{[25](20)[5]} {[25](10)[5]} At this point, Iâ€™ve done all the splits I can, and I can just read off the ranks; each rank of a number from is the count of distinct members from to the left of the first instance of it, plus one. 120 is all the way to the left, so its rank is 1. The first instance of 50 has one distinct element of to the left of it, so its score is 2. And so on. The dense ranking requirement means that you'll have to get rid of duplicate members, but other than that this algorithm should be logarithmic time, rather than linear time for your algorithm. 

PS: Above code should translate pretty easily to coffeescript, but as I am not very well versed in that language, I chose to give code samples in vanilla JS. Edit: Instead of you probably want to use . 

I recommend building the filter in steps, starting with an empty object . You then add attributes according to the selected city, category and date. And finally, you convert it to a JSON string via : 

The native is fast, but comes with a certain constant setup cost that makes it slower than your implementation for very small strings. As soon as the input strings get longer however the built-in outperforms any other solution: Small strings: 

See also Is JavaScript a pass-by-reference or pass-by-value language? Now, if we look again at your implementation, we note that you already perform a regex test. We could perform a regex matching instead and get rid of all those redundant calls. I wrapped this new implementation in a documented function and ended up with: 

A better design would probably have the attributes on the colored buttons and not on hidden elements, introduce a mapping between pad and audio source and leverage the web audio API instead. Using shapes instead of heavily styled s for the UI might further simplify your markup.