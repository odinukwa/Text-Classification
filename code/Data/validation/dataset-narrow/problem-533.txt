Portability: is great, but assumes consecutive . So if you want to work with those rare non-ASCII machines ... 

files are best for define and declarations. It is non-standard practice to put code in a file. does not include needed files. files should not depend on the code that includes them to have included certain files. This file should include them. 

Variation on @JS1 fine answer. Walk the list with a previous pointer. This is something of a hybrid between OP's and JS1 code. Make a temporary top node. Only its member is important. 

Portability is not defined in the C standard Function at 0 Minor: Both and fail with a size of 0. I would expect code to tolerate this edge case and not cause undefined behavior. display() Minor: I'd expect code to use to match or a cast to a wide unsigned type to maintain same sign-ness. Also --> and use or . A goal of is diagnostic. It should avoid data truncation. 

With using a sub-range of , then does not look like a proper test. I'd recommend a review and tolerate mine fields as small as 1x1. Ah, I now see which handle most of this concern. As is no longer the mine field height, use of a different variable name would add clarity. maybe? Either way, is likely incorrect. Perhaps Non-standard code My compile reported: "ISO C forbids omitting the middle term of a ?: expression". 

Not much left to review given the other good answers. Some additional ideas: Lopping off a Certainly OP meant to lop off the usual trailing . The below lops off the last character from a line of input, regardless if it is a or not. 

Minor side issue: Rather than use "rounding" with integer truncation caused by integer division, or using floating point math just to do an integer round, consider a simple solution. Round to nearest with math can simple occur by adding half the denominator, then dividing. 

IAC, the buffer size needed is not the number of character used to print a double into a string, but the number of characters needed when reading. Depending on coding goals, this could be as small as about 400 (extras characters will not likely make a difference) or pedantically: unlimited. 

Good use of to insure output. Something often missed. Minor: is not explicitly allowed per the standard. Better to use Minor: Naked physical quantity. Values like height, weight, time, should have units made clear feet vs meter $327.6 million mistake 

Silently failing due to OOM is a concern. should do similar OOM protection as . Even though it sounds silly that reducing memory usage should ever fail. Consider putting all memory allocation into one helper function. (BTW: did not free . 

Code alternate: Use 64-bit or better integer math. See in Modular exponentiation without range restriction. Good for at least 19 decimal digit integers vs. 12 here. fmod() correctness. Note: The specification of does not require the result to be the best possible answer, yet with IEEE Standard 754 adherence, it is. A good library would implement an exact result. Ref: Is fmod() exact when y is an integer? . 

Break the needed input into 2 groups: required and optional. An optional parameter may be the format to print the result another way - it is not required to run the core function of code. A required one is the hours. Minutes could go in either group. If none of the required parameters are supplied, use interactive mode. If all of the required parameters are supplied, proceed without asking. If partial required parameters are supplied, error out. 

No functional implementation problem found. Lots of review-able issues (format, lack of supporting code, etc.), but OP did not ask for that. 

Design: "I also put in effort to make the functions as concise as possible." is a worthy goal, but the conciseness and cohesiveness of the functions/type declarations in the .h file trumps the implementation details - that is good OOP. Hash performance. I see value in widening the pre-hash function to at little cost. If is a high cost, then code should use , rather than . Suggest rather than . Let the compiler optimize. 

Missing files. I'd expect at least something for and the the optional types . A sample usage (commented) of the entry function would be helpful. As it is, it is unclear how to use the function set. 

With , consider passing , of the error source to aid in debugging. Or at least create unique error messages. 

Should code trust that the string will convert to a valid number of hours? Look to or if in doubt (or experienced). 

Although in and exists in different name spaces, having one as a and the other a pointer is far from clear. Suggest: 

Indicate failure. If does not have anything in the queue to copy to , there is no indication of that here. Perhaps return indicating success. Same for . For debugging, zero filling memory before I have found useful. Errant code tends to fail faster with a 0 pointer/data than with its original data still potentially intact. Faster failing code is easier to debug. YMMV. Opinion: Storing the queue size is of dubious value, unless of course that is the reason for the type - one with a quick report. Alternative, drop the field and calculate when needed. More often, I have found the need for sufficient than needing a quick and prefer to drop the ever present field. 

A style issue, yet declaring and initializing is a nice coding style to consider. Avoids uninitialized variables and keeps them closer to use. 

Why the comment? Seems unneeded No provision for input - but then is not a valid string. For an interview question, I'd at least suggest that inputs may need sanitizing before use. Style: Even single are easier to debug/maintain with 

The is only possible when . But this is minor. In a more complex code having this stand alone may be preferable. 

Error handling is indeed an issue in C with a multitude of potential handling mechanisms. Good to see your take on it. 

The above code also has trouble when: 1) is some character with values even greater than 2) When is signed and has a negative value. A simple solution is to create an array that is sized to all and to access that array offset by the minimum value. 

Check I/O results. Robust check for errors, especially I/O. Code does use , which is good. Consider checking other file I/O. 

Array sizes are best typed as as that is the type return by and work for indexing all arrays. Otherwise, why use ? It may be too narrow (once 32,000 is eliminated). 

Unclear why is in the .C file and not the .h. No need to keep secret from other users. Recommend to keep variable closer to their use 

Naming problem or design issue. The first thing does is to re-order the data. I'd expect to not alter , base on its name - it is a check. Alternatively just re-name it . Yet later code make a copy in . Better to copy into and then sort , leaving alone. 

Small idea concerning allocation: Rather than allocate to the size of a structure, consider allocating to the size of the de-referenced pointer. It is easier to code, less chance for error, easier to review and maintain. 

What other functions apart from the four currently installed, would you recommend to implement as an exercise? 

Functional error (possible part of your "One small problem." comment). If returns , code should only dispose of the buffer if this is the first in . Or: if the reason for is due to and not . Functional corner case: searches the buffer and can get fooled by reading a null charter and then a end-of-line such as . No true way to solve this and still use . 

should include files like and not count on to have included them. Consider simpler code, as below and in other places. 

looks very bad to have at global scope. Certainly should have limited file scope with Same for The state space is 128 bit, yet users with are limited to 264 combinations. I'd expect a that allows 2128 or an auxiliary . 64-bit may seem sufficient today. Similar thinking years ago thought was good enough too. Code uses which is not part of the Standard C library. favors 1 bits. Use . There is no difference with as a count of microseconds, yet it would be a weakness should become derived otherwise. 

Tidbits Consider avoiding when things work. This is a small style issue - I find a or more aligns with failure than success. 

Unclear why functions return type . The C standard uses as the Goldilocks type (not too narrow, not too wide) for array indexing and size. 

The code below is listed as one file for code review convenience, yet would usually would be is separate .h, .c files. 

Not a fan of using the same name for a type and . Although these exist in different name spaces in C, they readily collide in a reviewers understanding. Suggest or drop the typedef and only use . Pedantic: Not portable when < 24 bit. 

Note: The method rounds half-way cases away from 0, but those do not occur here as the denominator is odd. 

Why read a line if is true? Certainly this is surprising functionality. Given 3 stopping conditions, it appears to me that the combination of them occurring in groups, the side effects of , and the short-circuit nature of led to weak function flow. 

Code should check the return value from and Mixing types for finding the maximum is very questionable. Suggest re-write 

Recommend to avoid declaring variables of different types on the same line. Instead consider initializing as part of the declaration 

A subtle good aspect about this sort is that elements of the same value do not change order. This property is useful in more complicated data types and compares. An important weakness to this sort in that is in rather than a . Yet it does minimize the movement of elements. A weakness to this sort, is that the source and destination array cannot be the same array. Not an in-place sort. I found the description imprecise "It basically works by comparing each number with all the other numbers once" should be "It basically works by comparing each number with all subsequent numbers once" 

A comment that applies to C, unsure about C++: bit fields are well defined for integer types , and maybe . So a bit field of type may lack portability. Higher portable code would use shifts and masks rather than bit fields to control endian, range and padding issues. only exercises . Recommend adding a example. Also compare values that are both about or . The test set is much to small. 

Perhaps some of these corner case result in a "don't care" or UB as the contract does not specify a behavior. Yet consider a production task with the loose requirements. Customers expect code to behave well is "all" situations. Although every conceivable issue is a worthy goal and not truly attainable, as an implementor, code should be resilient to many situations. These include ones that are not considered by the customer, yet reasonably possible. For corner cases that significantly reduce performance, greater coding goal detail is needed. 

Bugs, so not quite 100% functional. Bug 1: Consider . The following attempts to de-reference . appears to rely on the list having a prior insertion. 

Constants Alternatives to declaring a global object. There are various pros and cons to these. What is best is to code to your group's coding standards. In doubt, go with the last, simplest one. 

Consider redefining the angle measurement. It appears is 0.36 degrees. A natural choice would be 1024 to 1 revolution. Now the problem becomes one using a binary angle measure. Not only does this simplify small things like scaling, it opens up coding choices as there are many trig function code bases designed withs BAMS, Binary Angular Measurement System. Code uses constants and so makes for likely slower computation on an embedded system. If all that is needed is , uses constants and math. 

is a weak little endian check as it tests only 1 byte. The opposite of little endian is not big endian as there are more than 2 (although the others are rare). Recommend Use so code may call 

NAN As can take on a value of not-a-number. Code's use of and does not clearly push the is a proscribed manner. When NANs are involved, is not the opposite of . If code was amended to deal with a growing array during the first calls of , consider a to have the effect of shortening the queue and not saving the NAN. Naming The .c file (assume to match ) name, the type names and function names would be more uniform if they all began with the same prefix and case rather than , and . This is manifested in the minor code error in 

Small review and could be rolled into one. would benefit clear size==0 functionality. Pedantic: lacks overflow protection. 

Other issues Range and precision needs more functional explanation about range and precision. It seems to attempt an about linear distribution between ( included). A range of ( excluded) is quite common. So detailing the coding goal is important. The code fails to provide a full precision random number. Simple example: typically has about 253 different values in the [1.0...2.0) range and this code only supplies 232 different values. With , perhaps sometimes 2 calls to are needed. To provide a linear distribution with is trickier given the change in absolute precision between [1.0...2.0) and [2.0...4.0). is even tricker. Initialization Code passes in only a 32-bit initialization whereas the state is 128-bit. I'd expect at least a 64-bit initialization if not a full 128-bit one. 

The approach may have merit in select circumstances yet do not see that called for here. I would opt for the style as it matches the scant coding requirements. 

Why 31? Why not 15 or 63 or 42? If code is to handle 32-bit integers, then use as that type is at least 32-bit, rather than , which can be as small as 16. Alternatives , . Even better: re-code for the largest integer type . 

A more advance code would code some means to pass in a variable rather than a fixed tab stop of 8. Very good initial post. 

What is ? The name maybe should be FT_ten_millionths_per_second or better documented. Per the original line of code and its comment, it appears to have the value of 10,000,000. Why? It seems arbitrary. The reason for this value needs to be made more clear. The comment says but the code uses a rounded value with . Better to do with simple math. Explaining why a scaling of 10,000 would be useful. Likely . 

What is the actual or practical complete list of types I would need to do this with to determine universal alignment? 

Variable names , convey little meaning unless standard for the encryption algorithm's notation. Cast serves no purpose here in C 

is used, but not defined in . The file needs to 1) not depend on other non-included declarations or defines or 2) should error intelligently. 

Mis-statement: This code does not generate "1.000.000.000 prime numbers in" so many seconds. Instead it generate primes with values less than 1.000.000.000. is interesting. Yet since the type is used as an array index, any type wider that is a problem and may be wider than Consider a comment near the definition to that effect or some compile time test. 

Defeat of data abstraction. does not imply size, bit of some size. implies valuable is 32-bit. I'd expect either 1) to be if it is always going to be 32-bit or 2) if is abstract, have a name without an implied size. 

C2. Allocate to the size of the reference type. Less error prone. No need to code the matching type. 

The is not the best type. returns typically 257 different values and . To properly distinguish them, save the result in an .