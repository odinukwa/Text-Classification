Router - Which is the component which takes a URI (or if you're really fancy, a object), and spits out an object that represents the matched route. Route - is an object that represents a single route. It contains information about the URI pattern, the controller and action, and the variables that need to be passed into them. 

Better approach It isn't the Router's job to dispatch your request, or initialize the controller. So we will make a total of 2 classes: 

PHP already has a function for escaping HTML characters. . In order to completely and absolutely prevent XSS, all you need to do is pass anything that's about to be ed on a page through that function. So for example: 

Yes, there are several things I can see with your implementation, from most critical to less critical: 

According to your definition file, I'm assuming there's a global class called If that's the case, I have the following improvements: 

All in all, you must improve your code-style. Your code is extremely unreadable and will be hard to maintain in the future. Aside from that one XSS vulnerability, it looks good to me, but again, it's hard to tell just with the code you've given. 

Note that this way the User has no knowledge of where the data in it came from, could have been files, could have been a session or even a REST api. 

Cosmetically speaking, you can use the ES6 destructuring operator to make your arguments a bit more readable: 

Well, it is unlikely for the countries to change much, and even if they do, you might as well change it in HTML rather than in PHP. It really doesn't matter much, there's no point in abstracting these. I'd go with making this static HTML, and save some performance (although probably negligible). 

What you should be doing when receiving your input, and as early as possible, is validating the input, i.e. making sure the input matched what you expect in format, and in business logic. Format means "This is a valid email address", and business logic means "This comment that the user is trying to edit, really belongs to him". 

Better approach Your User shouldn't be responsible to save/fetch itself. In fact, if you have a User which doesn't care where it came from, you have a perfectly reusable object, a User that can come from a database, a file, a session, a form, whatever, and work the same. You should have two objects: the and the , the is responsible for fetching information about users and fill them into objects, as well as saving information from the object back into the database. The idea of OOP is separation of responsibilities. 

A prepared statement costs about 50 times a normal statement. However, that cost is on the database server's side (i.e. on MySQL's side), preparing a statement A, then clearing the statement object on PHP, then preparing the same statement A (with different parameters) will not incur a penalty, because the query is cached by mysql. A dependency injection container has advantages and disadvantages. It simplifies the dependency wiring process at the cost of magic. A dependency injection container is completely optional, don't sweat about it (especially in small projects). What are you abstracting? That's a question that you should ask yourself every time you create a class or a layer (which is a bunch of classes that have the same purpose). You seem to trying to abstract the PDO object, hiding it from the user. But why? PDO is an abstraction on its own, you don't really need to abstract it. What you should abstract is either 

This looks straightforward and solid under ES5. I have no comments or criticism for that. However, under ES6, there's the spread operator (which is relatively well supported in most modern browsers, and in Babel), with which you can effectively oneline the whole thing like so: 

Where each has its own job and responsibilities, its own set of objects, and its own role in the application. I propose you start with learning about OOP, avoid PHP frameworks, and once you grasp OOP, start looking at MVC. 

Figure out the unique entries (aside from name_alt) Iterate over each "group" of unique entries, and each to a single object push each newly created object into a new array. 

Your solution works, and is perfectly functional, but it's bad practice. What you're describing is the service locator anti-pattern, it means that instead of passing what you need to a function, you pass a magic box that holds what you need and many other things, and it's the responsibility of your consuming class to know this magic box (called a service locator), and be tightly coupled with it, to get the object it really needs. It's a redundant layer of abstraction that only makes things harder instead of easier. Do you have a class? Pass it a with a method. Have a class? Pass it a with a method. This way, your actual classes don't need to know anything about their validators, they only see an object with a method, and the method gets implemented differently for each validator. That's called polymorphism, and it's a powerful tool in your OO arsenal. Additionally, dynamically adding methods to constructors (a.k.a. classes) is frowned upon, because it makes it hard to read. With the polymorphism method, all of your methods are known at write time, and nothing is added in runtime, which is good for both readability and performance. Now, you might ask, "who will determine which Validator instance to inject to each of my classes", that would be "the entity that creates your instances", normally, that would be a factory of some sort, otherwise, look up Dependency Injection for a good pattern to follow. 

You would want to use PHP however, if you need extra functionality like "Apply on the country the user is GeoIP detected from". That is best handled with PHP. 

I got it down to \$O(n)\$; complexity. I'm not fluent in Python, so this solution is in JavaScript, but it's reads fairly easily (especially if you're familiar with C-like syntax) 

The current function looks overly bloated and inefficient (with \$O(n\times m)\$ at best, and \$O(n\times m^2)\$ at worst). While this is going to be used for test code only, and to small objects only (no more than 10 keys), I would still want to find a way to make it prettier and more efficient. Would appreciate any and all help. 

Instead of trying to purify the category for the user, which may or may not have unexpected results, you should simply reject everything that does not conform to your level of standard, and let the user fix it: 

Sanitizing (or more accurately named, Escaping), contrary to popular belief should not be done when you receive your input. It should be done right before you output it. Because at the time you receive your input, you have no idea where it's going to be used. It could be outputted to HTML (in which case it needs ), it could be outputted to JSON for an AJAX response (in which case it needs ), it could be stored in the database (in which case it needs prepared statements). The general rule is: You escape as late as possible. HTML strings should be escaped right before they get echoed onto an HTML page. 

Coding-wise it looks pretty good. Consistent naming convention and code style, no apparent security vulnerabilities (assuming your Rule classes do what I expect them to do). Let's talk about approach and scale. Scale It doesn't really make sense for you to write a validator for each Domain Object you create! What if you have 50 Domain Objects, will you write an extra 50 classes just for validation? Approach As a result of the above, your class is very highly tightly coupled with the object, it knows about the structure of the object, making it useless for reuse (Unless, of course, you find another project with the exact same object). A better approach? For starters, you should ask yourself what are you validating? Let's differentiate between two possible "validations": 

It's perfectly fine to not reject if there's no error. Yes, there was an error loading the image, but it isn't an exceptional situation, it's not something you'd because of. Your function is actually there to check if the image loaded fine or not. 

Yes, you are most certainly on the right path, and as a first step, it's very good. Some pointers for the future. 

This is assuming that your original data is in that variable. Please tell me if there's something you don't understand, and I'll try my best to explain. Notice how I'm chaining my calls to map, filter and reduce. Both and return an array, so the chained call is performed on that newly processed array. A fancier way of writing this would be factoring everything out into functions, and then having a oneliner: 

This code can be improved even further with functions that return functions and whatnot, but take the first example as reference to learn from. 

All of the above were reported by my IDE as soon as I pasted your code. Consider using a linter to ensure high code quality. A few other things I spot by reading: 

Why does the method do more work? It's the problem of the object constructing your Rules, which is not necessarily the . Isn't that already a part of the entity? Why do you need to inject yet another dependency. If the server's address isn't in the entity, why the hell the server's address isn't in the entity?! Your architecture is fine. Easily separated, don't know about the . Yes. Since querying all the servers to get their downloads count, it makes sense to remember the best server in the the first time is called, and then just reference it from the cache. 

Well, you normally don't want to use the constructor in your higher level code, you want to Promisify as low as possible. So let's create a function that checks for a single image, and resolves whenever you know the status of that image: 

An even better option would be to use Promises. I use bluebird in my projects, but we'll soon have native Promise support (bluebird will probably still be better). 

How to improve This code, contrary to popular belief, is not MVC. MVC stems from good OOP practices, and the separation of concerns. The idea is to separate your application into three major layers: 

Business rule validation belongs in the Domain Object itself. (i.e. the object directly). While your data-integrity checks should be done by the RDBM. More often than not, the RDBM (which is usually MySQL when talking about PHP) is not capable of doing all of that (which is why moving away to a better RDBM is encouraged), in which case those things also need to happen at the Domain Object level. TL;DR It's the job of the domain object to validate itself. It's the job of the storage manager (the database) to make sure the data is correct from the constraints point of view. The validator class ends up (usually) as a utility class, which is nice to have, but unneeded for an actual project. 

Note that in the above, the User is unaware of the database, which means it's perfectly reusable across applications with different storage systems. 

MVC is a concept that stems from good OOP practices. It's about seperating your application to three different parts: InputControllers, ProcessingModel and OutputView. What you are describing is the bootstrap page, which, at least from my perspective should not be a class. Here's my approach to this: index.php 

should only be a property if it's shared between all the methods. You should ask yourself Does it makes sense for this object to remember ? Passing around is perfectly fine. If your function needs a string to do work, it should ask for it in the signature. 

Slightly longer version: Don't be a smartass You don't need to dynamically call , it's pointless and unreadable. Just call and when you need it. It's unlikely for the function names to change. 

You are tying yourself to a specific environment, that's not good. A better approach would be to make sure that the class file sits under the path you expect it to, relatively to a file you know where it is relatively to the project. 

You want two classes. They . and , you instantiate whichever you need, and inject whichever you need. That way you can even have the same signature in the constructor in both types. If you don't have a preference, you just need a database connection in a function, just ask for , and either will fit. Also 

What if you want to run this function in a different DOM? You can't, you're bound to elements with specific IDs. What if you want just the result? You can't, because your function doesn't return anything but explicitly mutates the DOM. It's unclear from the signature what your function needs to work (i.e. available DOM with elements with specific IDs). Functions normally declare what they need in the form of parameters. 

Also, please don't globalize configuration. Pass whichever config option you need (just that config option, not the whole configuration array) into whatever function/object that needs it. 

JavaScript already has a number parser. This will allow values like , , , , etc. All valid Numbers. And it passes your test suite better than the original: $URL$ and $URL$ 

There are a few things I would have done differently, I'll say those before showing my own solution: 

So you see, it's nice to have a FileHandler helper to do some tasks, but it all comes down to how things work together in your general application sense. 

The class in on itself seems fine to me, but the question you should be asking is what problem am I solving here?. OOP design works well on the big picture. Let's say you have a simple application where you want to CRUD a user's contacts. And let's say that you decided for some reason not to use a database but to use plain 'ol files. In that case, it makes sense for your application to work with and objects, where each object contains a bunch of objects. Have you noticed what the application doesn't know? That's right, the application has no idea where the data came from, and that's part of SOLID. In that sense, you would have and to connect the User and Contact respectively to the files. Note that even the User or Contact objects don't know where the data they hold came from. Example: