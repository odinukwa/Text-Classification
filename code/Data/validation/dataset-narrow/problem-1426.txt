When I think of people I've interviewed that have done games courses, the one that sticks in my mind is Abertay (in Scotland). That said, I have to agree with U62. Doing a games course doesn't mean you'll come out the other side and fall into a job in games. I've interviewed people (and the odd lecturer) who's been on games courses from various institutions and the quality seems to vary wildly. I would expect good games "people" to be good no matter what course they do. I don't think many people I've interviewed and then been offered a job have come from games courses, the majority have done other courses and have a strong love of playing and writing games, with them being able to demonstrate this love via some sort of game related demo. 

I've not played it myself, it might also be a bit more complex than you want, but I've a friend who likes $URL$ 

Check if you can manually set your 3D TV to the type of 3D input it's receiving. A quick look at one Sony 3D TV manual showed it could be manually set to generate the 3D image from either side-by-side or over-under images, where the content for the two eyes are provided in one extra wide or extra tall image. It's possible if you can create a frontbuffer of the right size then you can just render two images in this way and set your TV to look for it (seem to recall this might be how Avatar the game did it on the 360). Your content would then potentially be rendered correctly, but the 360 guide or pop-ups that get overlaid by the system would be displayed incorrectly until XNA officially supported 3D. 

You could research frustum culling. Ideally done as coarsely as possible (say on a whole object - with maybe a bounding sphere), from this you know if it's completely inside (and all visible), part-in, or completely outside and therefore no rendering needed. Depending on what you're trying to achieve, it's possibly faster for the GPU to render some of these primitives than to try and determine their visibility first. The GPU is very good at discarding triangles that are completely outside the screen. So it might be good enough to just throw away objects that are definitely not visible and render the rest. You could cull individual polygons against the frustum too, but I'd profile this to see if it's actually faster or slowing you down. 

I'm not a Flash/ActionScript developer, but as this is a hobby, what is do you want to work on most? If you first and foremost want to makes games, then by all means use a framework to do all the other stuff you don't care about too much at the moment. You'll get yourself up and running much faster and you'll have something on the screen quickly. You can worry about how all the other stuff happens another day when that becomes interesting. If you care more about how the whole thing works, plus love getting your hands dirty with all the behind the scenes stuff, then start from scratch and learn about it all as you go. 

As this has recently been resurrected, your question (and therefore all answers so far) only seems to deal with the file loading, which is only as secure as the executable that wants to load it. On the PC there's nothing that's really secure (you just delay people), you can check against stuff on servers, but even that check can be removed so modded exe's can be run no matter what. The consoles are still "pretty" secures so in most cases there I generate a hash of important files, then sign the hash with a private key, embed the public key in the code and verify the secure hash against the file. I thought I'd throw another attack into the conversation, something I only came across last year as I don't tend to ship much on the PC. Cheat Engine is a very tidy little program that almost automates making your own hacks (which means anyone can use it). It's pretty advanced in what it can do, a lot of hacks/cheats that I've seen people sell are made by this or something very much like it from what I've seen (all the mass market ones). With some work you can protect against stuff like this again, I guess it all depends on how popular the game is and if someone cares enough to bother. Opps, forgot to mention a good lib for encryption (in C++) is LibTomCrypt. 

You seem to be throwing away the alpha channel each time you try and play with multiplying the colour part of the texture. You should be able to get to it through either "a" or "w" and then copy it through unchanged. 

From experience you have two options: Licence the vehicle(s): This will be either from the manufacturer directly or someone who already holds the licence (such as another developer that already has an exclusive licence for their use - they may choose to sub-licence). They're under no obligation to licence anything to you and will only do so if they're happy in the way in which their product is being portrayed and the context in which it appears. Depending on the manufacturer and prestige of the product the licensing costs can range from nothing right up to ridiculous amounts of money. They also like to have final approval on the finished in-game assets, etc, to ensure you're not degrading the appearance of the brand. Don't licence the vehicles: This is the route Grand Theft Auto IV used in their last game. I highly doubt car manufacturers would want their brands associated with the type of gameplay in GTA, they worked around this by making a number of changes to the physical representation and names of the models such that it met certain legal requirements (yet you could still tell pretty much what they were meant to be). In most of the major markets I would expect you to require a licence to do what you want, consulting a lawyer is always a fantastic idea if you're unsure of where the line falls. Update: Some extra info on photo's from the World Intellectual Property Organization - 'Legal Pitfalls in Taking or Using Photographs of Copyright Material, Trademarks and People'. 

You've got the two quads joined by the tri-strip. You could either do two separate glDrawArrays with the first being (0,4) and the 2nd being (4,4) to split the two quads up, or as you say, do triangles instead. If you switch to triangles then you'll need to either duplicate up vertices, or if you use indices to index, you'll need to specify the 3 corners of each triangle. Tri-strips work by taking the first 2 vertices specified then draw a triangle to the 3rd. Subsequently every extra vertex results in another triangle where it makes a triangle using the last 2 vertices and the new vertex. Some platforms support providing an index value allowing you to "reset" the tri-strip and effectively allowing you to split a sequence into multiple tri-strips with a single call. 

The only part of the FAQ I could see that came close to answering this is here. It states: Who owns the IP rights to the game I create? Can I distribute my game on non-Microsoft services? You own the complete IP rights to your game, and you're free to distribute through any service of your choosing. However, we may provide incentives for exclusive distribution through Microsoft services. Looking through the App Hub community forums it seems others have asked the same question and consensus seems to be it won't be a problem. For example, one person is already giving away the code for their game here. As others have said, if you're still not sure on reading all of this then stay on the side of caution or consult a lawyer. 

Thought I'd throw Real-time Rendering out there as it covers a lot of topics, including quite a lot on different lighting techniques. 

I'd recommend either using the debugger (to set a breakpoint on the 'set' function) or add some debug output (in the 'set' function and a few other places), to see what's going on. To get '9#5#5#5#5#5#5#5' the three lines of code you have to modify the existing value (and add on '#' plus the new value) must be getting called 7 times. The debugger should be the easiest method of finding out what's going on. 

I've worked on a few games that have been described as photorealistic and I'd have to say it's purely subjective, especially as what we might describe as photorealistic today won't in a few years (as hardware improves, rendering gets closed to perfection and people's expectations of games goes up). You can apply the term to anything that is rendered, I would take it to mean that what your describing looks as real as you can make it (be that the shading, textures, lighting, etc). In an ideal world, a screenshot would look just like a photo taken on a camera. 

2 things that might be up. 1) When you remove the particles, that loop is going to skip the "next" particle after one that's been removed in the loop that processes them. This is because you iterate through the list using "i", but during that loop you also remove items from the array, shifting future entries down, but then also increment "i" which then skips what was effectively the one after the one you just deleted (that's now in our slot). 2) I might have missed it, but I didn't see the code when I had a quick look above that handled the actual "how far inside a block" test. What I'm wondering is that based off the depth inside you decide which way to push the colliding object out. You don't seem to take into consideration the velocity of the player at the time (i.e. was he moving down and is now colliding) which you could then also use to judge if he should be pushed back upwards when colliding. Instead I'm guessing you decide which direction to move the player based on which edge it's closest to of the tile. If the player is moving fast enough then you might get so far inside a tile that you think he should be pushed out the bottom.