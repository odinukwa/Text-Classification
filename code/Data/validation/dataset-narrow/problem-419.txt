Some style comments: First, you don't need to put in a class, you can simply declare it and use it directly. Additionally, the ruby preferred style is to use snake_case and if the function is a predicate (a function that takes a value and returns true/false) you should add a question mark to the end: 

The reason is that transform is a instance method of , which is why you need to convert back into an image before calling it. There are a couple of way this can be handled. I've chosen to make a static method that only works on arrays. The instance methods and call the static method as needed 

Function Wrapping Here is an alternative implementation, just for contrast with the other solutions. It needs a little work to be more robust, but the concept is clear. This version wraps the target method with a new method that checks the arguments. If all are nil then the default value is returned, otherwise the arguments are passed to the inner method. This approach's benefits include being purely functional and not being limited to just mapping; it could be used on any method. The disadvantage is that usage is somewhat ugly and not as ruby-like as one might wish. 

There are more sophisticated ways to handle the bytes and endianess, but I've deliberately kept it simple here. 

For each word you process, get the unique/distinct list of characters (for example, by throwing it into a set). When checking for matches, you will now be checking against a much smaller list of corpas, which should speed things up a little 

I would break out the parameter fetch from the setupConfiguration constructor. Also, in MaximumDemandConfiguration, you are declaring two variable that you never reference. While I have left them in, you could remove the variable names or declare the parameters just like all the others and then use the variable names in the constructor. Finally, you can use a namespace alias to shorten the amount of text in the namespace: . You can do this for other namespaces as well. 

definitely looks having a lot of responsibilities. Have you ever consider implementing here? It is an inverted IEnumerable, "push" instead of "pull", so it works really well for event sources and they filtering/handling in a time sensitive manner. Reactive Extensions (Rx) for .NET provides you with some kind of LINQ for observable sources. There is a free downloadable book Intoduction to Rx - you will just need a part of it to grasp the idea. 

I would define API a little bit different. Let’s go with couple types: SizeUnit and DataSize, so they can be used as: 

There are a lot of numerical properties to be invoked many times with an expensive calculation. Let’s say for the sake of example, they expose a Factorial: 

And all the API with multiple overloads will come as two sets of extension methods – I really like this trick :) 

But it mixes multiple version translation in a single piece of code and will look ugly after introducing of more versions. What is the best way to deal with versioning generally speaking then? I would prefer a single sectioned query to deal with all versions in a unified way instead of running stored procedure with multiple queries if possible. P.S. I just think that is a must feature here... 

OK, it is going to be a long answer :) UPDATE Actually, marking for deletion is not necessary, see Little-known gems: Atomic conditional removals from ConcurrentDictionary. I would still consider the rest of the answer as an approach to structure the task. END OF UPDATE - when you about to remove from it - first to get rid of racing conditions. I defined this helper class to assist with this task: 

While implementing things like repositories we often can see that reading and writing parts can be done totally independently. The same time client side will win from the single reference (who wants to inject two parameters instead of one in many places). What do you think about a little bit of IL magic? Let's say we have: 

Now what I would do if this was for someone new to programming is relay on something else then abstraction of the init and abstract in something like biology: 

Now to the suggestion If with any number that is even, it has a number of factors 2. So remove the factors 2 and do you algorithm on that number. Like this: 

It might not be a complete solution, i can't test it, but it reduces the numbers of cases that are checked. But i should give some pointers. 

Encapsulation: You are not working with kwargs and args, so don't name them as such, in the same sense that you should not name your variable i, it is very confusing. You are dealing with three different args and kwargs, namely the job, the executing process and the classes, and args and kwargs in the class, should belong to the class if needed or not. 

Your calculation function s for one loop in 100 iterations. The my solution s for one loop in 100 iterations. 

That being said, they problem statement seems foggy. The MD5 function does not yield the same hash for two different sets of data, when concerned with these kinda problems. That is way it is called a hash function or a one way function. If the hashes is identical the content is identical. The last thing I will say, is that even the very fast hash function MD5, is slower then a efficient comparing of the content. So I criticize the problem not your solution. Thanks! Good work. 

Well, you have your code in a function, but it is still top down. It makes it harder to read, and much harder to improve. If you instead break the code down into separate functions you'll have an easier time improving code. You'll also not repeat your self. 

Well. Actually it's much slower to approach this problem in this way. Instead you could simply generate the palindromes, from max 999999 down to 100001 and the largest you find, will be the sought number. that would look something inline with: 

Defines a merge of JObject field content to object, creating one if missing. As shown, there are the following permutations of mapping declarations: 

How do you handle ? It is really useful in many TPL or business scenarios, but handling is a real pain. I defined the following three extensions to help myself a little bit. They can be used this way: 

Trying to figure out how to efficiently cache property calculations with dependency tracking to invalidate the cache. Here is the syntax I have at the moment (one instance supports multiple object properties): 

I would not put dependency on singleton in this class – it means two responsibility for - format properties and orchestrate AD API. Let’s define this helper class to be more explicit on your validation scenarios: 

This type of functionality does not require whole document to be loaded in to the memory. It might be easily done as a set of improvements over which provide better scaling possibilities: 

What do you think about this file system manipulation helper? There is an utility class Folder which I can use to define directory structure of my app: 

What do you think about the following syntax for some very simple and intensively reusable validations? Does this: 

It does not sound like creation for me… We are not generating code at run time here. What we deal here with is just a set of converters, which is solvable though the composite pattern. Let’s define an abstraction (you could extend it with ): 

Should your object know if it is captured? Probably not. So we can factor out that responsibility. Let’s define: 

Unfortunatly, Reference Types (classes – heap allocated) are very bad choice for the Math. Using them untolerabably slow downs calculations and significantly increases resource consumtions. We could define our own struct type, but it looks like a some kind of trade off – it is not 100% type safe. Let’s define an algorithm using a generic struct : 

I like your code! But some styling notes and then a suggestion. I think the usual way to check if a number is a perfect square is: 

I ended up with this, and I don't claim that it is any better then yours. But I'll show it anyway for completeness. 

If you put a statement like this as is in a function, you are repeating your self. In the same sense that 

For big numbers and for many numbers checking for divisibility with prime numbers under the sqrt will give a big speed increase, you could still use the same method. But there are many ways to optimize factorization, many many ways. 

Instead of choosing a random chore, you could just shuffle them all beforehand, that way the randomness task is done. 

which is prettier. There is a better way to find the current seconds, minutes and hours of current time, 

Your labels variables does not contain anything, you can not chain very much in python. It's a design choice from the developers. So the variable of the labels is unnecessary. This: 

give you the ability to import the timer class into another file. If you try to import your code into another file, you'll start your program and not complete the import. 

I thought I might as well summit a answer. It will first contain some styling points, and then a async approach to the question. 

I'm into async right now, so I'll offer up a async solution. I tried to follow your structure but instead used only three Labels. And I think it's justifiable to use async in gui programs. 

that is the fastest way I know of to solve this first problem. For bigger n:s the execution time is pretty much unaffected. Instead of creating the numbers, add the all at the same time :). 

the obscurity magically disappears. This method of commenting your code is called annotations and is commonly used in python, I like them a lot. 

I would not personally put LoggingService implementation inside factory, as it reduces testability and usually needed to play some tricks with generics type parameters only. To have a predictable behavior according to your design it might look like: 

DDD How often have you heard from your domain expert manually managing room booking in his/her Excel all those terms like , , ? I bet that never. This stuff does not belong to the domain, does not solve any business problems, and probably should not exist. Having names like that clearly indicates the problem - those words are not in the Ubiquitous Language. Domain logic is way too corrupted with technicalities. Sure, no database related code should be allowed in domain. P.S. It depends on the task, but I could probably load all the data in memory and run here easily. Design What is the Software Design? All the things helping you to keep your project maintainable and that you cannot change latter easily. What helps keep project maintainable? Placing dependencies in a way where volatile components depend on a minimum amount of stable abstractions using Dependency Inversion where necessary. There are too many concrete tech elements in your code to follow “minimum amount of stable abstractions” criteria to keep things maintainable, so design misses its goal here. P.S. It is not a responsibility of the Controller to decide on room/combined room booking priorities – it belongs to the business logic – to the place where you actually implement the logic – repository in your case, as you do not need DDD here at all. I would have the following models in the Core project without dependencies on anything else: 

Updated Here is a little bit of cleanup. Now you can get back reference to before blocking starts: is a non blocking call. It also works with and in the view. 

What do you use for refactoring away from exceptions while programming functional in C#? I defined this class to hold function outcome: 

It will scale better since we are never checking what we don't have to check, the only thing we have to check is if there is a corresponding index in the other list (now dict). 

My personal belief is that if you don't need the try catch, don't use it. However the above code is analogues to yours. 

you save yourself possible future headaches if you pick up this habit. When python imports a file, it will run the code in it, if not protected like this. 

Comments In python there is something called annotations, they are very use full. The let you define for yourself and other readers of the code what in parameters and return parameters function has. Example 

It's confusing that you use a manager, I get the impression that you are going to use the result to handle interchange of data between processes, this is not the case. You are just retrieving a result from from a child process. It is dangerous because you are always overwriting the same key "result" in the manager dict. Think of it. Every time you return from the manager.dict, there can be leakage, i.e. if it is over written before you return the wrong result is return. You should use a Queue that is unique to every 

Instead of working with the objects in people_data i suggest you work with data structures. It becomes easier to manipulate that way. The data you care about can be represented with: 

There is always a better way, then to use a global list, your t list is a global list. You are on the right track when defining a very clear is_palindrome function, but instead: 

You could call max on to variables directly and put the if statements in line and avoid the try catch by checking if the user input is digits. 

I'll go for the styling of your code. Firstly, python uses docstrings. There are one line docstrings and multiple lines docstring.