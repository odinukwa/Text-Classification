At the end of running this script it asked me if I wanted to test it, (yes), and it successfully played the sounds through the headphones I had attached. Running gives me the same output as you: 

It depends on the distance between the Raspbery Pi and the Arduino... If it is a very short distance (up to 5-10m) you could consider Bluetooth For longer ranges you could consider RF (your NRF24L01), or Wi-Fi. Any of these three will be variable based on the immediate location and the antenna being used. Here is a link to some range testing of various NRF24L01 modules. For very long distances, you might be better having each end connect to a Wi-Fi access point and send the data over the internet. You might also want to look at the FIRMATA and MQTT, each have libraries for most languages (including Arduino and Raspberry Pi), and they simplify the transfer of (sensor) data between the devices. 

Basically you want a that is keyed on the serial input string and has values of the scripts to run. That allows you to take the serial input and look up the to get the script name to run. Code would look something like this: 

NOTE: if you are using a +5v I2C expander you do need to check/verify the I2C pin voltages - as the Pi SDA and CLK work at 3.3v levels, and you might need to use a level shifter... 

There should be plenty of tutorials for each of these steps. Note: If you specifically want to server the page on a different port ($URL$ instead of $URL$ then you could do a 301 redirect from the the site running on the default port. 

Generally when you get a new router it is configured to dish out DHCP addresses. Part of the DHCP configuration that is handed out is the DNS server, which is normally pointing to the router itself. For example, you connect to the router wifi, and get an IP address in the range 192.168.1.2-100, a gateway address of 192.168.1.1 and a dns server address of 192.168.1.1. You can check this on linux with and on windows with Whenever you browse to the given static url (e.g. $URL$ your machine sends a DNS lookup to the DNS server (running on the router) which returns it's own address (192.168.1.1). The router will also have a web server running, serving the configuration management pages. If you do a you'll find it canot be resolved publicly (because it is only defined in the router). So, what you'd need to do to achieve this on a Raspberry Pi is:- 

I happen to have grabbed a snapshot from an install I did on Oct 24, 2015, so here is the full list of 129 packages that were the default on a Raspberry Pi2 as of that date: 

You say "When i try to install a new osmc in another sd card, it freezes at 20% estimated". What freezes? If the install is freezing, then it seems your sd card is suspect. If the install runs fine and pi freezes on boot, then we're troubleshooting a problem with the pi. While it would seem unlikely two sd cards would go bad simultaneously, this is not impossible. It's possible the osmc sd card is horked. The raspbian one is in an unknown state so that one not booting doesn't really tell us anything. If there's nothing important on the raspbian sd card, I would suggest reinstalling raspbian and see where that gets you. If you do have important data, try a 3rd sd card, preferably a known good one, or perhaps order a new one, a smaller 8g card is pretty cheap ($3-6) to help rule out problems with the two you have. Personally, I have always purchased two boards: two pis, two Pi2s, two Beagles, etc. They are relatively cheap, so that's a great way to test for problems related to the board itself. Although for what it's worth, I've never had a pi die on me, it's always been something else. Most recently, a power supply that had been working fine a year just stopped working one morning, with the symptoms being similar to what you describe: it would boot partway and then freeze. A 2nd supply I tried also didn't work, but having tried two power supplies I thought I'd ruled out that possibility and spent hours chasing other dead ends. It wasn't until I pulled a working supply from another running pi that I discovered power was the problem. 

Check/replace your power supply. I'm not sure if either of your 2 HDD are USB-powered, but that certainly would increase power draw from the Pi and cause freezes if your power supply was not fully up to the power draw. Each USB port can draw 500mA and the Pi itself draws ~500mA (depending on which Pi you have), so with two USB devices you'd want at least a 1.8A power supply. If you have a Pi3, the Pi foundation even recommends 2.5A. Certainly possible there is other stuff going on, but 9 times out of 10 when I've had Pi freezing problems, swapping out the power supply with a higher quality and/or higher amp power supply has solved the problem. 

That looks like a micro-switch rather than a relay. I'd guess that the micro-controller is starting the motor at set times (or has some other way of initiating the event) and the motor runs until the micro-switch closes (which is done by the knobbly bits turning and pushing the arm of the micro-switch in). C is and NO is (meaning the switch is normally open but when the arm is pushed in it closes. You will want to check the voltage on the NO wire both when the switch is activated and when it's not to ensure it is within the range of the GPIO pins (0v-3.3v). I'd start by driving the motor from one of the Rapberry Pi GPIO pins (via a motor driver circuit or a transistor, as the GPIO will not supply enough power). Next I'd use the micro-switch to signal to a GPIO pin (possibly via a voltage divider circuit to get the voltage in the correct range) that we have reached the desired point and stop the motor. Good luck!! 

Your description of 'press button pin goes high, stop pressing other pin goes low' sounds odd - you might also want to post your pin connections / circuit diagram so we can check that is correct too. 

So, to get down to (max 3.3v) on Vout you need around a ratio of 5:1 I'd look at around 100K for R1 and 20K for R2. Meaning that if the input was 18v you'd get: 18 * (20k / (20k + 100k) = 3v. ... and if it drops to say 12v, you'd get: 12 * (20k / (20k + 100k) = 2v. Some testing of the ADC values for known source voltages will be required (i.e. calibration) to account for resistor tolerances (and I'm not sure if the performance of the MCP3008 is completely linear). 

SSHelper is an SSH server for Android, so I would simply set up a cron job on the Pi to run an - making the ssh connetion to SSHelper can all be handled by the rsync command line option 

There are two types of pins on the GPIO header. The predominant type is for digital signal processing. These are I/O pins and operate at 3.3V. The second type of pin is a power pin. There are power pins for 5V and 3.3V. These pins typically supply external devices or sensors requiring an analog power source, but they do not support 5V digital signal processing. It might have been a cleaner design to designate all the GPIO pins exclusively to digital signal processing and provide separate terminal headers on the Pi board for the 5V and 3.3V power taps. Perhaps this would require board space they didn't have to work with. The Pi's power network has multiple levels. The input power to the Pi is 5V so that explains why a 5V power pin is provided. The SoC and signal processing operates on the 3.3V power rail. And there is a third power rail at a lower voltage of 1.8V that supplies the Ethernet controller chip. I can't imagine a scenario where you would damage the GPIO by using the 5V power pin. The only limitation is the current draw and that will vary by Pi model and any other current consumers (e.g., connected USB devices) running on the Pi at the same time. I wrote a blog article about the supply of power from the 3.3V rail if you're interested in a deeper dive on that topic. 

The two 5V power pins on the GPIO header are not ports in the sense that ports may be isolated from each other. These power pins are part of a common power bus. There is more than one pin simply as a convenience for multiple plug-in connections (same is true for the 3.3V pins). As you suggested, you can connect one or more 5V lines to each pin. So two or even three of your chips can connect to a single 5V power pin. When connecting to the power pins on the GPIO header, you must ensure your current draw is within the available supply of power without causing an adverse voltage drop that might impact other power consumers. Based on the comments above, you are only powering the chips themselves which is not a heavy load so you should be fine as long as your power supply is sufficient. 

Post processing In order to get the star trail effect i use from the package which allows you to stack the images on top of one another and thus create the star trail effect. The script looks like this ... 

.. which is the desired output. So it worked ? The rest of the output just seems to be the usual info when starting a debug build. There are a bunch of warning about not being able to locate files, but I don't believe that will stop the app from running, you just wont be able to inspect code if you set breakpoints. 

So the data you are trying to read should end up in . I would spend some more time looking at wiringPiSPI and some of the questions/comments here. 

When you call it is trying to do an on the file descriptor without having done an to get a valid file descriptor first. So, I think it may work if you change your code like so (add the line): 

I suspect the error you are getting is because the build failed (because of the jpeg library). Just install and try the steps from there again. If it still fails then please edit the question and add the output of and the exact output you get from the final command. 

The limits of what your power supply (batteries, mains, charger etc) can provide The gauge of wire you are using for connecting them (draw too much current through thin wires and they'll begin to melt) 

I have a Pi NoIR camera and have been trying to timelapse film the night sky. I'm looking for the kind of effect you see where the stars all rotate across the screen in a half moon shape. I have all the timelapse still and encoding the stills into a video working no problem. However the results are poor at best. So, my question is; is the Pi NoIR suitable for this type of project, and if so is there a particular package (raspicam ?) that I should be using and, are there particular settings (exposure etc) that I should be experimenting for best results. 

If this shows different output indicating systemd-timesyncd isn't responsible for your NTP, then try searching the journal for what is: 

So the first thing to note is that netctl and systemd-networkd are two different systems for managing your network. Things get confusing when trying to use both. I've completely switched to just using systemd and I've found it keeps things much easier when it comes to configuring and troubleshooting problems. YMMV. You state in the comments that systemd-timesyncd isn't running, you can confirm this by running: 

You ask 'if the procedures are different' but don't specify different from what? In the comments you clarify you have experience with Raspbian, you should update your question to be more specific. pacman is the command you need. Here is how you search for software in Arch: 

This sounds like you are logging in to a terminal via ssh, running something and you want to be able to disconnect from ssh and then come back later to see it still running? If so, the tool you want is screen. An example usage would be: 

In my case, systemd-timesyncd is controlling NTP so that shows up here. If netctl is doing it in your case, you might see that show up instead. As to the original question of what are the default servers, assuming you are using systemd-timesyncd (the default in Arch), the NTP defaults will be the commented out line you linked, which I'll repeat here: 

The confirmation of these being the defaults is seen in the manpage for timesyncd.conf, which states: 

One thread suggests that disabling updatedb.mlocate from cron was a big help. Another thread suggest small writes to the Linux NTFS FUSE driver are particularly CPU intensive, and that would be exactly what a BitTorrent client would be doing. One option might be to look into increasing cache sizes in Transmission to have less frequent writes. Additional reading suggests more fragmentation makes the CPU utilization worse, and certainly a larger filesystem with lots of small writes (ie. BitTorrent) is likely to have high fragmentation. So the short answer to your question of "is this a common occurrence" is: yes, high CPU is a known problem with NTFS drivers doing writes on Linux. There are any number of things you might be able to do to help tune to make it better, but you've got a lot of trial and error testing ahead of you, there doesn't seem to be any consistent "fix all" answer for the performance issues you are seeing.