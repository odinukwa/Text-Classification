If your heart is absolutely set on making an action-RPG, the simplest one I can think of is the original arcade version of Gauntlet. Overhead 2d view, simple mazes, a limited selection of stat-boost and single-use items, and less than ten enemy types. It's also fairly modular, so you can at least start with a single level and movement, then add walls, then add a monster type, and so on, adding one new feature at a time. $URL$ But as others have said, the point of "emulate something you know" is to build your programming skills, which means you want to keep it to very simple projects and not necessarily games that you like, so much as games that will teach you how to program. 

Is there a reason you can't combine them? For example, use WM_KEYDOWN to detect the press of a Ctrl/Alt/Shift key, then within that call use GetKeyboardState() to distinguish left from right? 

As a teacher, I see a lot of student hobby projects that fail. Invariably, the single highest reason for failure is overscope: the project starts out as this grand vision of a huge thing that's too big to possibly complete, more and more people are brought on until it collapses under the weight of its own design, and everyone leaves feeling frustrated and demoralized. The best remedy for this is to constrain your scope ruthlessly. Instead of saying "how do I keep my energy up enough to finish a long project?" you should instead be saying "how do I design a project that's short enough that I can finish it before I get bored with it?" "Game jam" events (make-a-game-in-a-weekend sorts of things) are a great way to get started, and they're great for building good habits when making rapid prototypes. At WORST, you spend a weekend making a lousy game... you probably learned something in the process... AND you saved yourself months of working on an idea that ended up not being as cool as you originally thought. At best, you find that you have something really special, and can start adding small features one at a time until you have a full-featured project. On my own small hobby projects, the other thing I've found that helps is to start with a complete list of all known development tasks that need to be done, ordered, and scaled down so that each individual task is doable and testable in maybe 30 to 60 minutes, tops. It is very energizing to do a small task, see it working in the game, and crossing it off the list... which then just makes it that much more likely I'll do the next thing on the list since the last one was so easy, and then the next... sort of like eating potato chips. Another hint: whenever you successfully implement a new feature, make a backup (or use source-code control, which is basically the same thing, but not everyone uses source control if it's just them working on their own personal project). That way if you totally screw up the code at 2am and can't figure out how to get it back in a working state, the project isn't dead and doesn't have to be restarted from scratch; instead, you just roll back to the last completed and working milestone, and try again. 

As Zorba says, most retro games didn't do this specifically because you would need (with sprites) to have multi-frame animations for every single piece of equipment. Some "lazy" alternatives: 

The biggest disadvantage of a game engine is that you have to learn it. If you're new to programming in general, that may still be faster than learning to write code to do all the stuff that an engine handles for you out of the box, but if you're experienced then it costs you no time to sit down and start coding, but a fair amount of up-front time to learn your way around an unfamiliar engine. Biggest thing to look for is support, because game engines are not perfect and they do not read your mind, and you WILL get stuck on SOMETHING at some point. So: 

Normally the term is "expansion" not "extension", FYI. Best way to do this is to understand the cost curve for your game. If you know that all of the cards (or units, or whatever) in your game have the same cost/benefit ratio, and that it is balanced, then you can theoretically come up with as many other things as you want, and as long as they fall along the same cost curve they will (theoretically) be balanced with what has come before. This isn't how Magic does it, but most other CCGs I've worked on have done something like that. As a bonus, knowing the curve significantly reduces the required time it takes to playtest for balance in future sets, so it saves you development time/money. Here's the down side: it's really hard to know the cost curve up front. Usually this is something best discovered after the release of the base set and maybe another set or two after that... at which point, you've already got a bunch of (unintentionally) unbalanced stuff. With computer games you can always release a patch that balances the old stuff later, provided you can handle the fallout from the player community (they tend to get uppity over any change to their beloved game, even if it's a positive change, unless they are carefully managed). Of course, this won't get you ALL of the way there. Sometimes you make cards or other effects that are just so far out there that they can't really be directly compared or balanced with anything else, so you just have to go by feel with your instincts. But if there's only a few of those, you can spend the bulk of your time working on balancing those by hand, and leave the rest to the automated math. There is one other problem you will run into eventually which is not balance related, and I think this (and not balance) is the main reason why Magic started using "Type 2" and other limited formats: eventually the card pool just gets too large to manage. Sure, players who have been there from the beginning who are incrementally adding one set at a time to their knowledge of the game, they can manage indefinitely... but for NEW players, coming into a new game and suddenly realizing you need to memorize a thousand cards is a massive barrier to entry, and you'll find that without some kind of restricted card pool to draw from, your game is effectively closed to new players entirely. So have a plan in advance for how you're going to handle that, irrespective of balance issues. If you're interested in cost curve balance, I've written up a tutorial here: $URL$ (The rest of that blog is devoted to other topics on game balance that you might find interesting as well, but this particular post is directly relevant to CCGs.) 

There are tons of interesting mechanics you can integrate into a static board. For a positional-based game like Chess or Checkers, you could add terrain or interesting shapes. Note for example how much more interesting the Stratego board is because it has those two lakes in the middle, creating three major choke points. For a territory-control game like Risk, structuring the territories to form interesting shapes or clusters and unique landmarks on the board is more interesting than something purely symmetric. In Risk, both South America and Australia are easy to defend but give only a minor bonus, making them natural areas of early-game contention. In Pandemic, South America is an interesting region because it has the only dead-end location that's hard to get to, while Eurasia is also interesting because it has a lot of interconnected cities that lend themselves to major outbreak problems. For a roll-and-move game like Monopoly or Life, make the spaces you land on interesting by having them give the players meaningful choices. This is one of the major reasons why the board game Talisman is marginally more palatable than Chutes & Ladders. You can also, of course, include mechanics that change the nature of the board over time. Maybe you have some tokens that get placed on the board that make certain spaces temporarily (or permanently) impassable, or adding some additional effect to visiting those spaces. That keeps the board dynamic, even if the original starting game state is always the same. 

You didn't say what kind of game. I'd say the easiest usability solution is, find a similar game that has similar mechanics, something your players might be familiar with, and use the same keys. So, if your game is an action-RPG like Diablo, making the default keybindings work an awful lot like Diablo is not a horrible way to start. See: $URL$