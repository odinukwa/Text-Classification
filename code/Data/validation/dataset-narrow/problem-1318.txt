Personally, I'd expect it to be cheaper to test if the entity has moved into/out of a spatial grid, and only do some recalculation at that time. I know for my QuadTree, it's way quicker to test a moving object before removing and re-adding it. Also... don't re-calc the position of every object in the spatial hash. When the object moves, it should set a flag (or something) then and only then should it re-calculate its position in the spatial hash. 

I would recommend using a Quad Tree. They allow you quickly and efficiently look up all objects in an arbitrary rectangular area. Here's the wiki article on them: $URL$ And a shameless link to my own XNA Quad Tree project on SourceForge: $URL$ I would also maintain a list of all the large objects so that they can interact with everything regardless of distance. 

You need to also check the orthogonal tiles: (x+0, y+1), (x+1, y+0), (x+0, y-1), (x-1, y+0). In addition, the loop variable isn't reset. It should be reset at the top of the main loop so that you always grab a new node from the open list each time. This should happen around your comment: 

What you've described is correct and commonplace. Ping times can vary widely though, so to get a more accurate result you can repeat the process a few times and take the average ping time as described on wikipedia. 

Where x is a floating point variable (float or double), unitsPerSecond is how fast you want your characters to move per second, and deltaTime is in fractional seconds. Having your position as a floating-point value is key. 

Use VAC or PunkBuster Don't trust anything the client says, ever, and store sensitive information on a server, and actually run the game on the server (like any MMO, BF*, and D2/3). If the server is running the game, the clients can only send commands like "attack this thing" or "move here". The server inputs these commands into the game, and the game hands out XP and money and all of that other good stuff. Put your game on a locked-down hardware device knowing that most users won't have access to your precious files, but those people who have unlocked their device will be the same group of people who are able and willing to hack your game. 

Here is a quick video on how it behaves using the second method while trying to maintain a firing distance of 350: $URL$ The white line and number indicate the Ship->Station vector and distance, and red circles are the weapon ranges. How do I make my AI ship circle its prey convincingly? 

Timing. The other answers don't mention the timing of events on the server and the different clients. Depending on the game, this could be something to watch out for. Latency (aka Lag) introduces a variable delay between when a packet is sent and when it is received. Time can be tricky, but I'll try to explain the potential issues as best I can. There are some games that can get by without worrying about this, but here's a simple example of where it can cause problems. Assume that everyone acts on packets as soon as they arrive. 

Normally, lighting in 2D games is done by having a Normal Map for all of your sprites, then calculate the 3D lighting effects on your 2D sprites. This is known loosely as "2.5D". I would however not recommend doing this in your first game as it is complex. Here's an awesome video of someone who has done this in XNA: $URL$ That said, there are probably ways to cheat and get a pseudo-lighting system that could work with various assumptions. 

For one, your node should be based on the total estimated distance from start to end: . You want to pick the nodes that have best likely outcome. For two, the priorityQueue documentation reads , which means that your compare will want to return smaller values for more desirable choices, a subtraction should suffice: Before these changes, your algorithm was selecting nodes that were furthest from the destination to calculate next, which would result in flood-filling the entire world before settling on a result. That could take a while, especially if you re-calculate the "shortest" distance to every node from every adjacent node. 

If you, as a game designer, know when the opportune moment arises (eg. boss battle), I would give a cue to the player. This could be a character saying "Sure could use that BFG right about now", or even a tool-tip reminding you that the weapon is awesome. Sometimes, players will just forget that the weapon is there, so a little reminder at the right time can help. 

should tell you how many seconds it will take to get from where you are, to where you want to be. Call it tells us how long each frame should be displayed for. Call it Now you just need to have a that accumulates the delta times: 

If you're already doing something like that, it could be worth looking into other spatial index methods like Spatial Hashing. 

I think that layering is the way to go. Layer 0 would be the ground, then layer 1 would include everything that is on the ground, and finally layer 2 would be anything above the ground (blimps, clouds, etc.). Add/remove layers as needed. Each layer would be painted in order, and a painting algorithm would be used to order the entities within each layer. Randomly generated levels or not, it shouldn't really affect the layering system. 

You need to use multiple render targets. You need to create an off-screen texture where you will draw the text-box area, then draw that to the main render target. Here's a post on the MSDN forum about this: $URL$ 

As a temporary measure, I have created a component that I have added to all of the targetable entities, then I added to the missile. My AI now targets only entities, and my UI can listen to the death events for my . This feels like a half-measure. The next entity that comes along and is able to be selected and deleted will also need to have , which could be wrong. Perhaps in the long term, I need an Entity class that can store this? Or maybe every Component should have a death event. 

This way, everyone will get their fair share of the resources. I also plan to implement an additional queue to be used as a priority queue so that the user can select certain structures to have resource priority. The priority queue will always be served before the standard queue. Make sure that all producers are updated first, then consume all resources second, otherwise the queue will break down when you produce resources part way through a tick and some consumers have already been starved. So to recap: Update the producers, then the priority queue, moving fed consumers to the end of the priority queue, then update the standard queue, moving fed consumers to the end of the standard queue. 

Encrypting the client's files will only stop people from using a text editor, but so will simply compressing the data in a zip file. I would simply recommend that you store your data files in a binary file, maybe compress it or use a simple encryption algorithm to fend off casual tinkerers. It would still be harder to crack open that file than it would be to open up TSearch and give myself a million dollars. 

If you are on a memory constrained device, or are using an engine that supports variable sprite sizes out of the box, I would do that. Otherwise, it's a minor issue and I would recommend using fixed sprite sizes until you have proven that you need the additional video memory. 

Often, sprites like this surfer come with some kind of meta-data that describes the varying frame sizes, and hopefully the feet positions. If you can't find this meta-data, I would recommend either making it, or following Joe's suggestion to make the frames all a standard width and height, and try to place the surfer's feet in the same (x,y) offset from the upper left corner of the frame. 

Note that your current solution will likely start both timers within 1 second of eachother, probably even within a few hundred milliseconds. Getting this more accurate is a difficult problem to solve with certainty, but you can get it "close enough" for games, although it's still not easy. I would also note that timing mechanisms on two different machines may not always match, so either read up on that, or experiment with your method. I had problems where one machine's Timer object would run faster than the exact same code on a slower machine. To sync the start-time of timers on two different machines, I would go about this in a few steps: 

In this example, I have left the circle in place (x and y in example code), and compared it against your squiggle of colours in all 9 possible configurations listed above. As a visual demonstration, I've drawn all 9 possibilities. This should get you pointed in the right direction. Other torus-world tips I can provide are: 

Facebook's strategy has been to Grow First, include Ads Later. For mobile games, is there any evidence that ads hinder popularity, or that people are more likely to share games without ads? Or as mentioned by angarg12, is there evidence that introducing ads part-way through a game's life cycle affects how people feel toward your game? 

I'm pretty sure that the Source Engine is the only engine that will support this out of the box. You can read about some of the technical issues in an article I found on Gamasutra, copied here for future readers: 

As described on the XNA Community Forum, you can get the host and listen to the event, which allows you to cancel the event. The example code from the community form reads: 

I would rank people by their net worth, starting credits and all. If the value of the player's stocks have gone down, so be it. It's still useful to know if you're doing better than players that have just started. 

Pretty long question, but if I read it correctly: could change after you've check it? So check it again: 

As others have mentioned: Immediately after you set the gamestate to paused, it enters the following if-block and sets the state back to playing. Sure, the simple fix is to include an between the two states, but that will cause yet an other problem because will return in sequential updates, and since updates happen 40+ times per second, you will temporarily unpause for one frame, then pause the very next, and back and forth until the key is released. The real solution is to detect the moment when the key is released (or pressed if you want to do it backwards). This can be done by storing the previous keyboard state, and comparing that to the current keyboard state. Something like: 

I agree with Katana, making a GUI system is harder than it may appear. I was working on one until I found that I was spending more time writing & fixing the GUI library than working on my game. Alternatives that I looked at were Ruminate XNA, and Awesomium (more specifically Awesomium .NET). I ended up picking Awesomium, and MindWorX and I built an Awesomium component for XNA. Personally, I love it. Working with HTML, CSS, and JavaScript libraries like jQuery, jQueryUI, and AngularJS have really made UI development much nicer for me. If you really want to develop your own GUI for personal reasons, I'd take a quick peek at my abandoned project on BitBucket, just to get a sense of what you're getting in to. It has buttons, panels that can be moved around, list boxes (partially implemented), text boxes (wow hard), and the concept of screens that you can transition between. Your code above looks like a good start. 

Notice how the server doesn't do anything about the battle until someone (you) logs in. I'm pretty sure Travian uses a system similar to this, although there's no way to be sure. 

I know your question is specifically asking about cron jobs, but I think a lot of web-based mmos are written using "completeTime" logic as opposed to lots of crons. When you start a long-running action, like building a granary that takes 5 hours to complete. The server will just mark the granary's completion time as and store that in the database, that's it. The client will see constant progress if they stay online, but that's only simulated on the client side. If the client logs out and back in before the 5 hours is up, when they connect, the server will tell the client when the granary is expected to be complete, and the client continues the simulation with no further server interaction. If the client logs back in and the granary should have been completed days ago, on connect, the server looks at the date and figures this out and not only completes the granary on the spot, but provides the user with the ability of the granary (let's say +2 food/hour) for all the time the user has been away for with the simple calculation: