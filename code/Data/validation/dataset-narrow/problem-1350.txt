if it's important for you to only mark points with a valid straight line to the player you can use an algorithm like the following (it's a c++ code), it consumes more than than normal floodfill. there may be some minor bugs (I'll be glad if anyone corrects them) since i didn't test the code myself but you'll get the idea. 

Each rigid body has an attribute indicating if it's affected by gravity or not. You can just mark that attribute as true, whenever player enters the spaceship, and later turn it false, when he exits. But that'll limit you with a big limitation. The gravity itself in unity is something global, meaning all entities are affected by same gravity force (if any). This means, even if two spaceships have different rotation, players in both of them, will be affected by same gravity, and they are both pulled towards same direction. This might not be that much of a problem on it's own, but it depends on your design. For example you might limit all the spaceships so that they all have same rotation (they all share same up vector). In that case you can easily use the built-in gravity function, and get away with it. But in case you don't want that to happen, and want to leave different ships to have different ups, You should consider applying the gravity yourself. Just note that Gravity is an acceleration, not a force. Meaning when applying you should use "ForceMode.Acceleration". That acceleration could simply be the exact opposite of up direction of current spaceship. I'm talking about "-transform.up" of spaceship. You can also use same Up vector, to rotate player so that gravity actually feels right, aka. player feet are pointing towards gravity. 

if you are going with a* algorithm there is no need for enemy to reach to exactly center of the cell, just check if it is near the center remove that cell from it's list. you can easily check that : . you can also change velocity at every frame to move directly toward the center and if you are realy close, just set velocity to or jump your character directly to the center. and as maik said having another variable as direction is wrong, since velocity already contains direction (it can be negetive or positive). 

This does not necessarily have to be as computationally expensive as you imagine. First of all, as you hinted at, you don't have to check every entity; just the ones that are moving. As such it might be wiser to have individual entities update their grid cell in their update method. As for checking coordinates, there are a few optimizations you could make. For example, say your grid is made up of cells that are 64x64. To figure the coordinates of which cell an entity is in, all you have to do is and (try it). This is faster than, say, a grid with cells that are 100x100, where to find out the cell coordinates you would need to do and and floor the result (or cast into if it's not already). Thus it's more efficient on a larger scale to pick cell sizes that are powers of 2 for example. Although I doubt that this will be a bottleneck (remember premature optimization is the root of all evil), you could also update zones less frequently than on every game tick and maybe even make the rate depend on the maximum/expected speed of any given entity. 

Yes, step 1 and 2 are correct. Here's proof. Step 3 and 4 can be done in a couple of ways. Following your steps to the letter, you can convert the RGB color to HSV, modify the values, and convert back to RGB. The first conversion is unnecessary though, since the image is grayscale, so we know the only thing that is affected is the "V" in HSV. So you can use your image as V, and use those constant H and S values to get something similar to what you want. Subject to tweaking and experimentation of course. Converting back and forth between RGB and HSV isn't the best idea for something like this though; perhaps in this case - if all you want is a slight blue/cyan tint - then you could instead just slightly tweak the blue and green channels and get the same result. 

AFAIK legally not, no one can access that directory, other than application itself. But if the device is jail-broken you can easily access and even change everyfile anywhere on iPhone. So if it's some critical data, you don't want any one to access it's contents, I suggest using some encryption before saving it. 

The whole path finding stuff is just a search for shortest path over a graph. to solve your problem the only change you need to apply is to add some extra edges (representing the path boat can take), and do a simple path find algorithm. it doesn't matter whether you use BFS, Dijkstra or A*, just implement a normal path finding algorithm with some extra edges. for more information about path finding in a graph check wiki page 

You can easily list all the files inside a folder and then load them one by one. By default all content files are stored in a folder right beside your main application so you just need to check for the contents of that direction. You can also use a recursive function if you want to load all files from all the directories. here is a little sample: 

I'm going to implement network features for the game I'm currently working on, now I'm wondering if I need to implement IPv6 support or just having support for IPv4 is enough? 

I've found one other online graph tool named grapholite. it's based on silverlight. It's easy to use and has a very easy to use sharing system (just like the one google docs provide). I think I'm going with this one. 

note that should point at cocos2dx root folder change it if it is not correct and in the second file this line should do the trick 

I think the best Idea is to go with the real time generation since there are always some nerds who break every limit you put for yuor game. for example if you go with 5000 nodes there will be some people to player far past it just like what happen to pacman, none of the developers never tought of someone go beyond level 255, but there were geeks to break that limit! so you need realtime generation. Now how to generate levels in realtime: you are saying you are developing your game for IOS and as your sample shows you are going to create a landscape game so you have 480px screen to draw you game, considering your terrain is create by 30px pieces you need piece ready at each frame. since there are always atleast 480/30 pieces inside screen and just by a little movement a part of another piece will come in your viewport. lets say we store one extra piece as reserved. some games doesn't have a feature that player can go back in levels (just like super mario bros) in these cases you can remove every tile that goes out of screen to free unused memmory, but if your game let's player to move freely inside levels you need to keep whatever was generated. just ignore them in drawing phase. to store the levels you may use both arrays and linked lists. since you usualy don't need a direct access to any of the pieces, linked lists doesn't slow your code down. in my case I usually try using queues to store my level information. if you know how many pieces are in your levels you can easily use an array and keep your all your data inside it, you may either shift data as new pieces are generated or you can keep head and tail of queu and use that array like a queue (circular buffer as maik suggested). then you need to draw them, ccDrawPoly is a good choice by I prefer to use ccSprite or ccTMXTileMap since you can't apply texture to what you are drawing. don't worry about your object may be out of screen since cocos2d handles these situations and draws only visible parts. I think for objects that are completely out of scene it even ignores drawing but it's better to remove objects that move outside. it help you organise your game better. 

However, you don't need to check for all of these. What you have is a decision tree; all you need to check are if the orange ones match your center tile. If they do, then you proceed to check the secondary ones. Here's a diagram that connects the orange tiles to their secondary tiles (notice how you only need to do four checks for the green matches and not 8 since the other 4 are the same): 

Of course you can simplify a lot of things and play around much more with the variables and constants. Here's a live demo of me doing just that: $URL$ Edit: If you want to do this with different colors, fortunately there's an easy solution! Pass in your colors as uniforms (or hardcode them in the actual fragment shader) and change the last line to this: 

When I hear game designer, I think of somebody who thinks up game mechanics, freedoms and constraints, level designs, balance etc. The may well have no part in actually programming the game. What you are is a game artist. That doesn't mean that you can't have more than one role in creating a game, and at the same time each role influences every other role significantly. At any rate, you are a game developer, as are programmers, testers, sound engineers, etc. 

The next step is animation. To do this, you just need to play around with the "r" value and change the radius. You don't need to worry about clamping color values between 0.0 and 1.0 because that happens automatically anyway. All together it would look something like this: 

What you've described (Painter's Algorithm) is indeed the way it's usually done. There are however maybe a few things to consider in addition: 

As others have already explained, your question is based on a false premise: that most 3D games don't allow you to move. I think what you actually meant is "Why do you control movement in most VR-first games with a controller, rather than with your body?". The answer is not to do with technical limitations, but human factors. For most games, it's completely unnecessary - and indeed makes for frustrating gameplay - to control your character with your body rather than a controller. Nobody wants to clear out their room to play a VR FPS only to get annoyed with wires and obstacles. There would be too many compromises needed (unless you literally had a huge hall to play in) to make it so that the controls don't interfere with the game. That doesn't mean that there aren't games where you can at least move a bit by actually moving your body. The controller is your primary mode of ambulation, but you can still look around corners by moving your head etc. On that front, the commenters on your question are right; most games actually do let you do that. Regardless, your reasoning is still wrong. Think of a VR headset as just a set of double monitors; anything that can be done on your actual screen can be done here too. IMU input from a headset is equivalent to WASD + mouse or a controller. It has nothing to do with caching a scene in VRAM or limitations of your graphics card or anything of the sort. The actual UX pitfalls with VR headsets are resolution, FOV, and latency. People might decide to limit how you control your player based on those for example, to prevent motion sickness among other things. 

you can't set a callback function for or any other Label class, yet there is CCMenuItemLabel you can use. you first need to create an instance of class. then you need to allocate instance, using . just check how helloworld sample handled it, although it's using CCMenuItemImage, but the base idea is just same in both. 

To conclude his answer you might use any of those three methods but you need to be careful not to over use either of them since as I said all those designs are really dangerous and might easily result in a unmaintainable code. 

note that some boids may be a part of more than one group, but this pattern gives you a more accurate results. you may also create as many groups as you want using this pattern it's just a number you have to find for how many boids and the screen which screen size, what's is the best number of groups you need to create. --edit-- there is another idea about segmentation which is described in the paper @LarsViklund sugested, this way there is far fewer double checkings and there is no need to increase/decrease number of threads between steps: 

If you don't have any idea how one can win the game, you can go with minmax. But there are too many other complicated algorithms you can implement. Here is an small list: 

By reading your quesiton it seems you can take benefit of quad trees, create a quad tree and run simulation for each segment on a diffrent processing unit. This will cause checking only happen to objects near to each other. but you'll need to sync you threads every cycle. Which means to transfer some of those boids from one processing group to another. in general every cycle will consist of 3 steps : 

for each line (represented by ax+by+c = 0) and each object(which moved from x0,y0 to x1 y1) you have to check if the result of this product is negetive . negetive value means there is a collision somewhere(it may be after the both end of line) and the possitive value means there are no collisions. if there realy was a collision then you have to calculate collision point using these formulas and check if that's somewhere between two ends of your line. we want to calculate the collision point of these 2 lines : 

If you're using world coords or fragment coords, you can still scale and translate to normalize to (0,0) -> (1, 1), but we're going to need to scale and translate again anyway so you can skip that step. Make your coords instead range from (-1.0, -1.0) to (1.0, 1.0) to make the next steps easier, like so: Now before we go any further, let's make a super plain radial gradient. Recall that the equation of a circle is x² + y² = r². So using the transformed UVs as a coordinate system, a unit circle (r = 1) can be made with and will look something like: 

Another way would be to check the surrounding tiles without simulating anything in the background. The best way to do that would be as follows. Say you have a tile that just moved (center). Focus only on its color and the tiles that are occupied in this diagram: 

First of all, when you say "creating" a tileset, I presume you mean that you want all these tile transitions pre-baked into textures. I'd recommend against that as the number of transitions you need increases quadratically as your number of tile types increases, and isn't worth any extra efficiency usually. What you want to look into is Texture Splatting and do this all runtime. I can't think of anything in particular that would give you extra efficiency when it comes to cell types, except the usual voxel optimizations like storing voxels in an octree and optimizing that, occlusion culling, frustum culling, LOD, optimal mesh generation etc. On that last one, as the saying goes, premature optimization is the root of all evil, but if you end up having some extra FPS, you could try rendering your cells to look more "detailed" with algorithms like marching cubes / marching diamonds (think the 3D Worms games' destructible terrain). Edit: Here's a good read on voxel terrain meshing. 

Here's how I would do this. First, make sure you have the object's UVs or world coords (which you can pass through from your vertex shader) available to you. If it's just a background, you could also just use fragment coords (). For instance, let's say we're using UV coords. A fragment shader with only: will look something like: