I'm using the current latest version of Eclipse and have the latest version of Java installed. I have a simple project I'm working on, just a JOGL based 3D application. The first step says, "1. Install the project into your Maven repository". This is where I'm most confused.. I've never used Maven before, I don't know how to use it. After some googling, I unzipped the project into my Eclipse workspace and tried going to File > Import > Maven > Existing Maven Projects and imported the project. Next the instructions refer to Maven dependency. I tried setting the dependency on the maven project, but I'm not sure if I was even in the right place for that. The 3rd instruction refers to natives included in a Jar file, but after much searching I can't find a Jar file inside of any of the files provided by the library. After that I tried to follow the rest of the instructions but obviously nothing has worked. I've fiddled with many settings and tried what I can all night to make this work but I can't see what it is I'm meant to do. Can anyone give me any hints? Has anyone done this before who can give me a quick howto on this? I just don't know what I'm meant to do, any help would be greatly appreciated. 

Well, points I imagine would be just a counter really? If there is only one score, a total "Points" count, then just KISS and use an int, add points to it. If you want to show maybe the amount of points received at the end of the level, add up the different sub type of points and then add them to the total score at the end of the level in some fancy animation to make it more "fun(tm)". As for knowing how much an enemy or puzzle is worth depends on how you represent those things in your game. If they are classes or loadable files, then just store inside of them how many points they're worth and again, add the values when those events occur such as "completed puzzle" or "enemy dead", grab the point value, add it. As for powerups, you could define your player to have certain attributes, such as "speed 5" "jump height 10" "can fly? no", then each powerup could just have modifier values which increases or decreases those values. Like: 

Basically the same as JasonD's answer, except using bitwise operations instead of absolute value function. This is assuming you have 16-bit short integers! 

The Pannini projection, for example, can capture wide fields of view in nice ways. (totally just my opinion) I think implementation details would be beyond the scope of this specific question. 

One reasonable approach would be to use a loop to update your X and Y, and draw again repeatedly. This would involve computing delta time, and using it to animate your coordinates. Here's an example jsfiddle: 

Which appears to be right on target, crossing 4 times to achieve a peak value of 0.01, after 5 seconds of simulated time. 

The texture sampling function expects texture coordinates to be normalized into the [0 - 1] range. You can divide by the size of the DuDv map in pixels, to normalize your texture coordinate into the [0 - 1] scale. For the sake of efficiency, I prefer to evaluate on the CPU, and use multiplication instead of division in your shader. 

Step 1: Load your color and alpha images into two different OpenGL textures. Step 2: Use glActiveTexture to switch to between and bind both color and alpha to GL_TEXTURE0 and GL_TEXTURE1. Step 3: In your fragment shader, define texture samplers for color and alpha, and use the right one to get the right channels in your shader. Step 4: Set "color" and "alpha" uniform variables using glUniform1i to 0 and 1, for textures 0 and 1. This will let you pick different memory layouts for color and alpha, and should still save memory over a standard 32-bit, while providing perfect alpha gradients. 

There is no canonical "correct way" to approximate general functions. Sorry. With that said, the very source you linked to has suggested the Lafortune representation. This representation has been described as "...compact and works well for hardware rendering..." in chapter 18 of GPU Gems. Implementation details appear to be out of scope for this question. 

But in order to retain flexibility in situations where multiple handlers may need to observe the event, "Bubbling" can be applied so that all handlers get to see the event: 

Which is our answer, notice that time is still unknown in this system. This means there are infinite trajectories that will land on the purple rectangle. You have to decide how long it should take. 

You should not shadow the polygons that are back faced from the light. I changed your fragment shader to below code. 

I recommend you use lock step peer to peer architecture. You start by counting your game frames after the game starts. One client render the 1st frame then send the ready message to other clients and wait to receive ready message from other clients. Now all clients can go for 2nd frame. Render the frame, send and receive commands, update world, update physics and ... after that sending ready message to each other. This solution is very good for LAN games and all of your clients will be in sync. with this type of networking you can be sure all of your clients are in sync so you can test the best way that suits your need. 1st way is only send the inputs to others and each client simulate running, firing , collision detection and etc the 2nd way is each client send the information about his character to others like position, rotation, state, animation frame and etc so other clients only calculates their stuff and send them over network but first way is more secure. 

I like the way Level Up author uses to write his game design documents with drawing many cute shapes, characters and etc. I highly recommend you take a look at this book Level Up!: The Guide to Great Video Game Design With adding little drawings to your documents the others will pay attention to you more and you can be sure they will read your design documents 

I want to add PSM (Prespective shadow map) to my engine but I have problems with that. I think the problem is somewhere in my math code so I want debug Nvidia PracticalPSM sample and compare the math result in the sample and in my engine so maybe I could find the bug When I want to compile the sample with VS2005 I get some linker error with DXUT functions maybe it is due to that the static lib DXUT.lib that included is compiled with VS2003 and dose not work probably with VS2005 then I added DXUT source codes from SDK 9.5 to the solution and the sample compiles this time. When I hit F5 to run the sample it complains about nv_nvb.dll but only release version of nv_nvb.dll is included in the sample and I copied that to debug folder when the program starts it crashes in NVBscene9.cpp line 283. I don't know why it crashes here. you can download the sample code from here 

Ugly. But we have a closed form solution in time :) Before we can solve for the parameters you're interested in, we have to address one small ambiguity: The damped harmonic oscillator never stops, only decays. I will use a threshold where we consider motion "stopped", and solve for the peak which attains this amplitude. Now, from the solution above, I have obtained that the set of peaks are generated by: 

Lazy loading! Add a method to SpriteComponent to let it store the name of the new sprite to load, then let the SpriteSystem load the actual data whenever it comes into play. To smooth out the loading laggies, preload. 

And for good measure, here's the tool I wrote to generate those images. Using SDL and plain C, I called it "hbm2tnm.c" (Height Bump Map to Tangent Normal Map) 

This answer will focus on statement #3 in the original post, and is meant to supplement ToddersLegrande's answer 

Which conveniently brings the n-th peak into the relationship. Since you've specified both the decay time, and the number of crossings, we can derive a relationship between the two constants we are trying to compute: 

It looked logarithmic to me so I went ahead and fitted the natural logarithm to your points, then plotted to verify (and adjust coefficients). 

I didn't check thoroughly, but one major problem I see here is that you aren't following the OpenGL manual: This line of code is never valid: 

Since I get the idea that you have rolled your own custom game software, you might as well roll your own shader tool. If you show the GLSL compile errors you are halfway there. To bring the experience up to something realistically usable, integrate inotify into your shader loader, and trigger your engine to re-compile shaders when a change happens on disk. This will give you a truly What-You-See-Is-What-You-Get interface for developing GLSL code without wasting massive effort. You can then use any code editor and your own engine will provide live preview. (Works great with always-on-top or multi-monitor) EDIT: For windows you can use FindFirstChangeNotification 

I arrived at my assumptions because your offsetting code in the vertex shader seems to indicate that your variable is measured in pixels, not normalized: