Re-think your logic (ter) Nothing happens in the loop if as and are not changed. If this is really the case, we might as well just break out of the loop. However, things are even better than this : once again we are in a situation that cannot happen. This can be seen in two different ways : 

Refactoring is best done one code at least slightly understood. This is not the case here so I may have introduced new issues. Because I had no idea what I was doing, I just applied some usual recipes (assuming the objects you are using are well behaved): Avoid the unnecessary You have statements all over the place which serve no purpose whatsoever. Most of the parenthesis you've used are useless. You are retrieving the different parameters in many different places. It could be a good idea to retrieve them once and for all at the beginning. This is particularly useful because you are using strings are keys and I don't want to bother about having to check the string used as I am reading or writing the code. Do not repeat yourself If you look at your code, it is quite obvious that there are many similarities all over the place. The best way to get rid of it is to write your code in such a way that it is easy to detect it : see what is similar and see what changes. In your case, that means taking into account the comments above but also reformating your code so that statements are on a single line (this is not a good thing to do usually but it helps the eye to detect similarities ; also long lines might be the sign there is something to improve). When you've seen that only a few detail are changed from one call to another, you can try to change your code so that everything goes in the same logic with a different pre-processing and/or post-processing. This technique is really useful in code like yours where you have many nested : the number of blocks grows as 2^number_of_levels but you may reduce this to a single block with only number_of_levels preprocessing logics. Also, reordering the order in which conditions are checked sometimes makes things more concise. In your case, I think your code can be rewritten : 

Your code looks nice and seems to be fully PEP 8 compliant indeed. The fact that you have 1 blank line between functions except in one place where you have 2 puzzles me a bit but that's not a huge issue. You can actually make your code much easier. Here are a individual steps, you'll find the final code at the end. 

Your code is simple and just works. For that reason, you can be happy and there is not much comment to give. However, being very picky just for the sake of learning, one could say various things. statements You are using without parenthesis. This is the one and only reason why your code wouldn't work on Python 3. Just to be future (well, actually Python 3 is not the future, it is the present) proof, you might as well add the 2 parenthesis. String formatting Instead of using the format, you could use the method. You'll find more information online. Also using named place holder makes things easier to read and avoid duplicated values. You'd get something like : 

things should be much faster already. Strange loop I must confess that really surprised me. What are you expecting from this loop? 

(The constructor needs to be updated accordingly to set to ). is_curr_winner This could simply be : . Also, maybe you should add a method on the Player. play_game You shouldn't compare to and . I am not sure if there's a point in returning a string. I don't know enough about the logic of your game but is there a point in checking if the player has won before he plays if we do it after he plays anyway ? 

Also, sub-expressions are computed more than once (even if this is probably optimised out by a decent compiler): The right data structure You go through 2 vectors to get points coordinates. It would be clearer to have a single vector of Points. You can use a typedef to make your code easier to understand. Also, you can take this chance to pass data using const references to avoid copying it - see miscco's comment. Reorder your loop Your , , loops are independant and can be re-ordered. This is great because, you can iterate over and , build a Point(j, k) and only then iterate over . Then, it becomes clearer that all the logic around the variable can be done out of the loop as well. At this stage, after changing the data type and the loop order, the code looks like: 

Do less (again) From the code above, it is clear that elements from are already string but we have still calling on them. I expect this to be useless. Also, I expect the and tuples not to be useful. You could simply write: 

? Also, just some food for thought as I haven't studied the issue in depth : how do you handle parameters that don't need to be in quotes such as numbers ? 

Warnings It is usually a good idea to compile your code with all warnings enabled to see if anything is wrong. In your case, nothing really worrying but we may as well fix it. 

This is known as the LEGB Rule (Local Enclosing Global Builtin). It is hard to tell whether this is relevant to the problem you are trying to solve but if you do, and would interest you (I haven't found a way to access the variables in enclosing scope). I've played with this as part of one of my pet project. Here's the parts that could be more relevant to you: 

An easier way to find changes At the moment, you use many loops, a vector and a flag to detect changes. First, we can move the declaration and the initialisation of in a smaller scope and get rid of the "resetting" logic. Then, you can get rid of the initialisation loop by writing: 

Even better, this looks a lot like what you did for "new game" or "load game". Did someone say "reusable components" ? 

Maybe your function could be a simple function returning a score for a list of throws (code will maybe arrive later). 

Handle the prev, not the next This is mostly a matter of personal preference but you could make you do not need to handle indices by working with the previous character instead of the next. You'd get something like: 

This is better but we still have calling and calling . Maybe should be used to play a single game and shouldn't call at all. This can be done by removing the call to in and moving it after the call to in . That way, we'd just have calling itself. You'd have something like : 

Note that I used a bit of a hack to have floating number division. In Python 3, this is the default behavior for division and you can have it easily with . 

Don't use complicated non-required logic Converting your tuple in a string you perform logic in in way too complicated on top of not being efficient. You could just do something like (using what we call "tuple unpacking"): 

Very last detail : in , the value of is not used afterward. The convention is to use for throw-away values. 

In order to to this properly, you could/should a proper test framework. Also , it would be worth adding tests for invalid inputs... Back to Now that I have tests to protect me, I can mess with the function a bit more. It looks like the bit I did not get can be replaced by: 

Also, for your string slicing, 0 is the default value so you can write : Final code At the end, my code looks like this. There is still a lot to improve (from a documentation point of view for instance). 

Your code does seem to follow PEP 8 which is a good thing. Also, the logic is splitted in different small functions which is even better. If you want to make your code portable, you probably shouldn't hardcode in your path but use os.sep or even better os.path.join instead. In order not to call multiple times, you could use writelines. Now, from a functional point of view, it might be a good idea to create temporary files with tempfile for instance. If you don't want to use it, it might be better to use a hash of the original url or of the content and use it in the name of the new file. 

Then, it is interesting to note that the is actually the same thing as : you check what is left after the division. The awesome thing is that Python has a function to get you both the quotient and reminder of a division so that the code can be written: 

in two different places. There is no need for this, just do this away from the test. Keep it simple When looking for a solution, you are trying to handle all scenarios in a pretty akward way. The best place to start with is to answer the simple question : "is a different from 0 ?". If a is 0, next question is "is b different from 0?". Trying to group the different cases makes things easier to read. Also, it is easier to ensure you've handled all interesting cases. Suggestion When you pretty print the equations, is a special case, should probably be considered just as special. My final version of the code is below. I have mostly moved code from one place to another and I haven't fixed any issue because it is more interesting for your to do it. Also, I have a few ideas to make the pretty-printing function much more concise but it is a bit more advanced and I feel like you should learn one step at a time. 

(It's probably a good idea to rename arguments and functions but I'll let you deal with this). Useless return Your is useless. Do not use to check booleans It is a bit more idiomatic to write instead of . Avoid string concatenations Instead of using again and again on your string, you can simply define a literal string on multiple lines. Also, if you do it directly in your call to , the parenthesis will help you: 

This shows that the result is different when n is 4, 9, 25, 49, 121, 169. The optimised algorithm consider these values as prime even though they shouldn't (as they are perfect squares - of prime numbers which might have its importance when looking for the fix). Once this is fixed, you can use to ensure the results of the two functions are the same. In your case, the fix is simple : changing for in : 

However, an even more simple option would be to check at the beginnign that the value is correct. You could define a list with the correct options and use it like this : 

First easy cleanup "stdafx.h" is not needed for your code (which is good because it is not available on my system). Also, the indentation in your code seems wrong. By enabling all warnings on my compiler, it tells me that and are not used. A good way not to have unused variable and to make your code easier to follow is to define variable in the smallest possible scope, at late as possible. This also removes the need for all the "resetting" logic which is easy to get wrong. It is much easier to just define your variable and give it a meaningful initial value before using it. At this stage, the code looks like: 

Details At the moment, you are using to store whether all permutations of where prime numbers so far. It might be interesting to point out that in Python, you can add an to loops signifying that that was no in the loop. Thus, you could write something like : 

This version, just like yours, does not check the validity of the initial . This may be a desirable check. Then, you'd write something like: 

Optimise memory usage You could optimise memory usage by not converting your iterators into list and by avoiding non-required steps (like ). Changing a few others details (formatting, adding tests, etc), you'd get something like: 

I guess I got lucky (or inspired) because the value leads to a bug. I guess that should be . Different algorithms - string_to_int When you convert, let's say "1234" to an integer, you are currently saying something like : 

You probably should fail in a more explicit way when given an invalid connection mechanism. More generally, having the function called from anywhere makes things a bit hard to track. 

Similarly, a block could start with . The logic just aboves correspond to a more generic situation: if the current value is smaller than the next one, we actually want to substract the smaller from the bigger. This can be written: 

Separation of concerns Your functions does way too much : file reading to get input, getting solution for the problem, printing out the answer. It would be much nicer to have this splitted into individual functions. Among other things, it would make your code easier to test. Code-challenge are very good candidates for unit tests because the algorithm involved is usually pretty tricky, the input and ouput are usually pretty clear, no side-effect is expected and you are provided some simple tests with the problem. Rewriting this gives : 

First review It is almost always a good idea to put your logic in a function (or class) that can be easily documented and tested. That way, in anything goes wrong during the optimisation, you'll know it straight-away. Also, this can be useful if you need to measure your result to ensure your optimisation is an actual optimisation. Just moving the code around, here is what I start with : 

Now, different great things are easily doable : - you can your call to behind an guard to have reusable code on one hand (you could need the function to solve other problems) and code actually doing something on the other hand. - you can write tests to check your code automatically. The great thing is that the problem description gives you a few examples. 

The variable name might a bit confusing as one might think about the modulo operator. I guess or would be better. Suggestion It might be worth defining a function/method but it might affect performances. 

is all you need (on top of replacing with ). It can hardly becomes easier. The check is somewhat artificial. If I was to write the code, I'd write in such a way that only numbers bigger than 1 are in the returned list. 

if main guard In Python, it is a good habit to move your code actually doing things (by opposition to merely defining things) behind an guard. This is useful if you want to reuse the code : you can import the file and get all the benefits from it (the definition of values/functions/classes) without having it performing unwanted actions. In your code, the end of the script becomes : 

DarinDouglas's comment is right. However, it forgets to point out that your code actually does not work (or at least it will not always work). Before going any further, it might be interesting to write a few unit tests. Here's what I have so far (the names suck). One you have this, you can see that something is not quite right if you run the tests () enough times. 

( probably needs to be renamed, I'll leave this to you) List comprehension You can use list comprehension to rewrite in a more concise/pythonic way : 

Shouldn't you replace the whole code with ? Let's assumme that this is just a placeholder for actual code. If you handle your different cases in order and if is an , then you can make the logic a bit easier to follow : 

Now we can get into the actual changes in your code. One of the issue it that you have multiple functions calling each other which make things difficult to understand. All branches in end up calling (except when the option is not correct). It may be easier to call it once, at the end of the function like this. 

to avoid the boring repetition in the rest of the method. On the other hand, shift could probably be declared and defined only when you need it : It might be worth pointing out that according to the Java specs, integers are 32 bits so you probably don't need to do everything with arrays of 32 booleans. My feeling is that it would make everything much easier and you'd be able to do things in a straighforward way. For instance, case SEQ: would become : `case SEQ: return (src1==src2);'. If you do so, I think most of the loops you write might not be useful anymore.