This is roughly what BDD should look like. You're definitely on the right track in that you have a specific set of postconditions and expected results for every "public" method. However, the tests for these postconditions are incomplete in some respects that I think will probably come up as edge conditions and/or browser quirks (assuming your system is going to run in a browser). In addition, you're testing behaviors in this suite that are shared between your subclasses - even if they don't actually share a , they do have a common interface and common expectations. For incompleteness, I'm referring to 'should return false when value provided is null or undefined' when the corresponding test only tests . This should be two tests, one for and another for . In addition, you should define and test the function's behavior for other values that are commonly mistaken for and , like , , and . The empty string is of particular importance because it's unclear from your tests whether an empty string is acceptable as long as it's specified - the source of your data might determine whether that's applicable. I would go with two or three tests per native type: one that is acceptable, one that is not (if both are applicable), and one that is falsy (if the falsy value for the type is not already covered). If you really want to go all out, define behavior for the parameters , , , and . This sounds like a pain to do - especially when you see that you need to define said behavior for all of the other functions whose preconditions are the same. The root of the problem here is that your preconditions are not very DRY. Each function has two test cases: and as inputs to . Since and are not really the only two inputs you can expect to get, your tests shouldn't be coupled to those two inputs. Further, when you go to write your tests for your other rule subclasses, you will be unable to re-use your and tests because they have specifically named as erroneous and as acceptable. I'm not a mocha expert, so I don't know how helpful or cooperative it will be, but you can refactor your suites to test states rather than classes, and it will be far DRYer. From what I can tell, the rule subclasses all have the following features: 

That will only require 4 fetches per dword, and is perfectly readable (as far as asm goes...). The bit twiddling hack does it with just one. With regard to your instinct that family instructions would be better, I believe you're sadly incorrect. If you learn any other assembly language and try to use strings, you'll certainly appreciate the effort Intel originally put into providing special string instructions, but they haven't really optimized or extended those instructions with the same zeal as one might like. Further, you can't , because doesn't set any flags. If you ever do end up , remember to =D. This might seem like a long list of complaints, but for having first seen assembly 4 days before writing this, it's remarkable that you can do anything useful. Cheers. 

No, this is not efficient, if indeed it can be made to work. The operation has a loop that can iterate over N - 1 elements of an N deep stack. Typically both push and pop are expected to be constant time, as they are in the standard implementation. An additional disadvantage to this implementation is that it can only hold . 

I did something very similar to this in assembly a looooong long time ago, so I'm going to compare and contrast for the sake of nostalgia. And helping you out, that too. The main difference in our top level designs is that I was storing values as elements of the , whereas you are storing . The reason I didn't always store was that it didn't require any additional memory management for consuming code by default. If I needed to do memory management separately, I could do that by making it a queue of pointers. In your code, you must either store pointers to static data or and each element separately. I see those two possibilities as a hazard in the case that the consumer doesn't yet know whether dynamic allocation is necessary, or worse, if to static data and to something on the heap have been mixed in the same somehow. The end result will be an error (trying to static data) or memory leaks (not ing heap data). It's especially error prone because if you need to , you have to do it soon after you dequeue it (possibly happening in many functions) or it leaks, so switching between static data and heap will be hazardous. On the other hand, believe me when I say you've avoided the following headaches by storing only : 

I don't use underscore, so I am more or less naive about what you're meaning to accomplish and how it might look otherwise. Instead, from a consumer perspective, I am comparing/contrasting this utility with not having it only. I am assuming "all aspects" includes code quality from the perspective of maintaining, reading, or extending the code as well, and I'll start there. Reading this is made somewhat more challenging due to the similar-looking and . I believe this has been mentioned by another reviewer, but I would like to offer some workarounds. I assume that you do need an object for - if you don't, you should follow a previous reviewer's advice and be rid of it - to loop over its keys or use it as a prototype or dump it on the console at some point. It's okay to provide an abbreviated global name to consumers ( for your library), but it doesn't pay to do it in your own scope. Even and are more easily distinguishable, immediately clear in their purpose, and if you count the shift key, it only costs you one keystroke per typed pair. Speaking of saving and losing keystrokes, actually requires fewer keystrokes than . The same goes for , , , and . I've seen some other libraries do stuff like that, so you're not alone in this, but I've never found a use for any of it. That goes double, though, for and . I can't imagine wanting to spell that out. Just curious - why is there an explicit spell-it-out test function for everything but ? I guess if I was trying to maintain code written by real neanderthals that I didn't trust at all, it would be reassuring to see what they were intending to test explicitly in every conditional. In any case, it's more bondage & discipline than utility, and you can tell by how little use you get out of these functions throughout the rest of the code. There are lots of opportunities to use those functions. There are many cases where the body of those functions as well as and appear repeated verbatim, with precisely the same intent. Normally, I would say it's overkill to call repeated simple boolean expressions a failure to DRY, but that's the point of your library, right? You wrote those functions because they're useful code, so use them. The function returns false for boxed numbers. If there's a reason for that, you should probably add a comment about it and document it somewhere, or someone might assume that if then , since if then . I would rather see in instead of using native for-in and filtering with . It takes up less vertical space, restricts the scope of to the block that should be using it, and does the very same thing. I can read what you have, and it works, though. Just a matter of preference. If I understand it correctly, the difference between and your is that the iteration of can be ceased from within the callback by returning truth-y. I would then expect, when I read code that uses and not , that you are scanning an array to find something and intend to stop at some point. However, you go on to use the functions in and where the intent of the loop is to iterate over all keys or array elements. It does show that you have a useful function, but it also reads a little hack-y. Each time I read it, I spend a second or two looking for a to determine what you're looking for, only to realize that you just aren't using . I can't really comment on all the suffixes and underscores because, if they belong in the utility at all, they're tools specific to the rest of the project. Seeing , tokenizing, and meaningful underscores with no regex or grammar in sight makes me a little nervous (long story, code-based parsers are bad) but I have no idea what you're really using it for.