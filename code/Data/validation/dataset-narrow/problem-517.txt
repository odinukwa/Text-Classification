Context: In a larger project, I am trying to build an utility class to encapsulate the parsing of input data. And I want it to be able to process either an already existing input stream, or a file given by its name. The general idea is to build a stream converter. The input file contains a variable number of (possibly multi-line records). The program parses the file, retrieves one item, convert it and write it to the output file. So the structure of the program (pseudo code here) is: 

My first idea was to have a ref to a as a class member, and initialize it in constructor, either from an existing ref or to a newly opened file 

But now a cannot be used to initialize a , and I would not dare to use and later with a move from a standard stream! Current code: I finally decided to dynamically allocate a std::ifstream in my class when I have to process a file to have an lvalue to initialize my ref: 

The problem is that is a temporary, and can only initialize a const lvalue reference or a rvalue reference. A const istream would be pretty useless, so I tried a rvalue ref. 

It seems to work (even if in case of copies all will share the same underlying stream), but requires to be declared before , and the raw pointer initialization looks rather ugly. Question: As this design come from my former C experience, I wonder whether this follows modern C++ best practices and how I could make it better, more robust and easier to maintain 

So you have build a dynamic size stack containing integers, and you guarantee that the allocated size if a power of 2 and the used size is between the allocated size and its quarter. This automatic down-resizing of the stack is a rather uncommon requirement, so you should think twice before implementing it in real world code, but it is not really the point. You have consistently declared and commented your functions, so it could be used as a nice .h file. Good point. You code gave me one warning in loop test at because is unsigned. While generally harmless, this kind of warning should be avoided because it can lead to undefined result. So here, you really should use . In fact should be even more appropriate, both for and . In , you use an unnecessary where you could directly use . Not really expensive (only wastes a ) but IMHO it does not really make the code more clear nor more maintainable. But I strongly urge you not to use a function for error processing in an utility library. I did it (I was a beginner too...) once, and the library was later used in a program that had its standard output connected to the equivalent of /dev/null and a special logging library. As you can imagine, the program sometimes was stopping with no message in the log system and this took some time to be identified because everybody had forgotten the ugly die. So if this should be an utility library, please use an error code and let the caller do the error processing. For the same reason, I would not destroy the stack on error: let the caller decide whether the error is really a fatal one. That is just an application of the general separation of concerns rule. 

Without reviewing other aspects, I think you should separate the code so that there's the server itself in its class (or, maybe even better, its own project), and there's the UI. For instance, you should not show a MessageBox inside a server's code. There are so many reasons for that so I'll just leave this statement as is. In other words, the server should behave as a black box, returning error codes, or throwing exceptions, or anything else, according to its own API. Mixing the server's code with UI is not a good practice. 

It's not clear to me what are and ? If these represent the radius values (like C1-P1 line for ), then perhaps (and ) would be a better name here. I'd create and use a data class for each point-radius pair. Say, class with and or something similar. I'd separate constructor and results. The results are calculations that should not be part of the constructor. Take, for example, the class named in .NET: you can construct it, change the inputs, and only when you call the property named - you get the calculated uri. The same should apply here, too. Constructing a class gives us an instance with a valid state. Calculations - in their own methods or property-getters (that are practically methods, by the way). So should be the returned type of a method (or maybe if this pattern apply here), and not part of the class' state. 

Find the nearest number, in terms of distance, from the array to the given external number (20). sort the given array. find the value in (1) in the array. it can be done using a binary search. now, to the main point: the next value would be either to the left of the current value or to the right of the current value, since the distance is now between the next value to the current one, and the array is sorted (!). so all you have to do is to hold two additional indexes: inner-left and inner-right. these indexes represent the inner boundaries of the "hole" that is being created while constructing the new list. 

What if the script renames file "a.zip" to "b.zip", and both files "a.zip" and "b.zip" exist in the same directory? 

Naming Consistent: might look better if it becomes Accurate: perhaps could be used instead of , since init means some kind of a setup, while the method actually changes the array's values. In addition, perhaps the class' name could be changed from to , which, at least in the aesthetic aspect (to my own eyes), looks better. 

and the rest is obvious. Again, this has nothing to do with Python in particular. It's purely an algorithm to be implemented in any language. This algorithm takes O(n log(n)) in time, while the one suggested by the original poster takes O(n^2) in time. 

Classes are included manually Instead of including classes manually it is recommended to make usage of the autoloader function ($URL$ The advantage is that you don't have to worry about including a class. 

There are multiple returns in one method This makes the code less maintainable. Having more than one return means there are multiple scenarios when the method can be stopped. In case of a bug one need to debug through the whole method to figure out the return-point. 

Variable definition You sometimes define variables in camelCase and sometimes with underscores. I recommend to use one spelling type only. PHP If function is not part of a class consider developing a database class that handles it. Another option is to add a function to each of your Model classes. This makes your code easier to read. For more details check mvc pattern. In the function you establish a new database connection with each call. You can avoid it by promoting the function to a proper class and define a global attribute holding your database connection. JS In your javascript you have html code. I recommend to either load it with rest of the dom and hide it by default or load it using ajax. I personally compare it with inline css. HTML In html form you have an attribute . It should be in a javascript file. I compare it with inline css as well. "QUOTES" Also see CodeX answer. As tim mentioned and other variables not provided by yourself have to be validated and parsed by htmlspecialchars e.g. to avoid XSS. A bit about security I've added this section due to mentioned XSS. Security is a very complex topic and must not be underestimated. There are a lot of options to implement and grant security. What kind of options you choose depends on your time/budget but also kind of project and data that are going to be stored in your database. I kindly ask you to think wise about the data that will be saved in the database and make researches about proper security measures. There are a lot of PHP Frameworks. I recommend to take a look into some of them as those provide security standards. 

As you notice it is better readable. From here there are two approaches how the code can be optimized further. Approach 1: IsValid-methods should be created. These kind of methods performs a validation. 

This is an addition to other reviews. Code Quality: include 'home.php';: In the context of your shared script it's not obvious what it does. I recommend to rename it to e.g. . Further depending on the content there are other more beautiful ways to handle "that". require_once 'class.user.php': Including classes manually shouldn't be practiced anymore. Okay, maybe in an application which has like 3 files in total. However, in larger applications you should use feature provided by PHP using . So, when you try to instantiate a class PHP automatically tries to include the class once if it does not exists in the current context. View & Business Logic are not separated: Nowadays view and business logic is separated to provide a better overview. Further it grants a better maintenance if implemented correctly. Check patterns like which stands for Model View Controller. Other header("Location: index.php"); You perform a redirect without specifying the reason like . 

first element is 19, since abs(20-19) = 1 is the nearest distance to 20. let's find 19 in the sorted array: 

The math behind this function is not that simple, but it's not that complex, too: You should calculate the shell's index, according to , , and . Then you should calculate on which side of the shell are and ("North", "South", "East" or "West"), and calculate the "distance" (in steps) of the current item from the shell's start position. All this is pretty much mod calculations. Once this method is done, you could simply write a nested loop (N by N) with and , and print the function's value, without having to populate a matrix before that. The calculations in the should not take more than O(1) (in space and time), so eventually you could have a solution of Î˜(N) in time, and O(1) in space. Just an idea, though. 

From the algorithmic perspective, I'd like to suggest another solution (regardless to Python as a language). Here goes: let's assume that all items in the given array are different. the other case has a similar solution, so let's focus on the algorithm itself. 

Having so many operations -- seems like you'd want to use some kind of a factory, injected in the constructor, or the instances themselves injected in the constructor, instead of constructing the classes inside the constructor. 

First of all, it's very good that you read about the evilness of . Avoid it at all costs :) As for your solution, it's not thread safe, in terms of functionality: Thread A tries to add an object to id = 123. Since this object doesn't exist, the returns , so the false part of the condition takes place. Then Thread A acquires the lock and starts to add its object. However, Thread A hasn't yet completed its processing, and the system now switches to Thread B. Strangely enough, Thread B wants to add its own object with the same id = 123 (!). And, what do you know, since Thread A hasn't finished its processing, Thread B asks if the dictionary and gets . That's the problem. Even worse, when Thread B starts its processing of adding the object, an exception would be thrown, since there's already a key assigned with 123. So, no, the suggested code is not thread safe. That's a classic race condition. How to resolve this? Option 1: Double check on read operations Inside the lock, you can call again to the , which is a read operation. MS provided a cheering statement, that read operations on its data structures (dictionary, list, etc.) are all thread safe. Update: from MSDN: A Dictionary can support multiple readers concurrently, as long as the collection is not modified (my emphasis). So please ignore this option. Option 2: Use ReaderWriterLockSlim Class This class is optimized to the scenario of multiple reads / seldom writes. So when you want to write, you upgrade your lock to have "write" scope, and you continue your code. Option 3: Use a simple lock on the entire method. This is very straight forward. All options are fine, and my personal bias is towards option 2. Update: see also a related post at Ayende: Why is this not thread safe? Good luck! 

There are global attributes with the access modifier An object is responsible for its valditity. As of that its attributes has to be setted via setters always and the attributes has to have as access modifier either or . 

Recommendation Curly brackets are sometimes in same line as a method header and sometimes in the following For the sake of a good code-reading and understanding code should be structured. Write curly brackets either in the same line as the method header or in the following. 

Not every method has a self-describing name : What does it return? Object Length, Current Line Length, ...? I recommend to rename the method to what it does - . 

Description: This section describes missing setter, multiple returns and if-conditions. In the constructor of the class Route are multiple returns. This makes the code less maintainable. Having more than one return means there are multiple scenarios when the constructor can be stopped. In case of a bug one need to debug through the whole method to figure out the return-point. So, at this point a switch to if-else-if-else should be performed. Below you see a minimalistic sample. 

Each class belongs in an own file It seems to be overhead but remember: Each class has one task to solve and the same goes for files. In small projects it does not matter that much but as soon as a project grows it helps a lot. My namespaces are similiar to the path of the class location. As of this I know where every class is located - everytime I instantiate a class. Namespaces If you have not read yourself into namespaces I recommend it. Namespaces combined with an autoloader are a great way to make your daily developer life a lot easier. When using an autoloader you have another reason for having one class in one file. further aspects 

You include an autoloader in the test class. From UnitTests I am aware of a bootstrap file. If such a class exists/can be registered for functional tests as well you should move it to a respective file. 

Script is terminated in the constructor The script should not be terminated in a random class but by an . The type of the exception decides wether the script has to be terminated. Commonly a leads to a termination. Possible Route class 

As others mentioned the code is not completly OOP. A real OOP application does not contain functions but classes and methods. Well, except of the file that includes the class that initialize the application and the autoloader function - AFAIK function expects a function only. The autoloading part is missing as well which is part of dependency injection. I recommend to get into it. In the constructor of class User you do not validate the email etc. that are stored in the session. They should be a) passed as arguments to the constructor and b) validated. E.g. in the method. Another point is the php closing. To avoid errors never close php. It's hard to figure out a space or another character after php-closing.