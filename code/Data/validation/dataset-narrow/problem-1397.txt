If you had extremely complicated shapes, using pixel testing might be a good way to go, but if you have just circles and triangles, you use different methods that will be faster to set up, and execute faster as well. For a circle all you have to do is know the radius, and when the user clicks, call a method that calculates the distance between the center of the circle and the point where the user clicked, if that distance is lower than the radius, then the user has clicked the circle. 

Many CRT TVs are not perfectly rectangular. They have pixels on the sides and top that are cut off at the sides. Typically the 80% inner portion of the screen is guaranteed to be safe. On HD resolutions it will most likely to have 0 to 5% missing of the screen area. In your game engine, add some temporary guides so you can align all the critical parts in the viewing area, and test at all the resolutions that you need to support. Even if your screen is wide, and the aspect ratio is wrong on it, your guides will be able to help you adjust it. 

It sounds like you need to learn more about how Object Oriented Programming works. I think that you are creating an instance of an enemy, and then without storing that instance in an array, just creating a new instance with the same name, effectively destroying the original instance and creating a new instance. Create an array that will hold all the enemies. When you spawn an enemy add it to next position in the array. In your update method loop through all the enemies and update 1 per loop. 

Yes it is real, It really can render things at any detail density without slowing down. But it does have some notable restrictions. 

Sorry, no matter what kind of encryption on the client side you do, if you store sensitive stuff on the client, it will be hacked. The client has to be able to read the data in the "encrypted" file. So you are giving the lock and the key to the client in a competitive game, and telling them not to edit anything inside your encrypted file. Your client will be hacked no matter what. The only thing that the encryption will do is slightly increase the time to be hacked. Always assume the client is compromised. If you can't work around that assumption, then you are So-Out-of-Luck. 

Add it to your List and the loop restarts, after the loop is done, you are going to want to return the finished list. You can can now draw any frame of the animation by using: 

6502 Assembler Here is a forum page about hacking the ROM. $URL$ It should contain any code references you need as well. A few posts down there is a link to a zip file that contains these items needed to edit/hack the game. 

Yes there are many tools that allow dumping of the full swf, and/or all of the actionscript. $URL$ being one of the many out there. No, its not worth the CPU power as it will be easy to crack and design a fake program using your "hidden" key. If someone is going through the trouble of hacking your game, a "hidden" key and data transfer protocol are going to be easy to find. Treat the client as hostile, always, and assume any protection that is in the client program will be hacked. Design your server software to detect cheating instead of the client. 

What would be the fastest method for doing anti-aliasing for a flash game that is drawn via blitting to a BitmapObject? A method I thought of would be to make games stage smaller than the BitmapObject that the game is drawn to, and then somehow shrink it to the size of the stage. Would that method work? If so what would be the fastest and highest quality to shrink the bitmap? Or would there be a completely different way to do it? 

Currently your script plays the animation and immediately checks if the currently label is "endwalk" only once. What you need to do is use an onEnterFrame event and check what frame the animation is on. That would fix your current issue. You could also put simple actions on the frames themselves without having to use events. 

I found a post on how to site-lock flash movies/games here. It is the fourth post down. You can modify it slightly to make it do something or set any variables you need changed. Here is the code from the post. 

Large games commonly make liberal use of 3rd party technologies and APIs, generally these are C or C++ libraries. Many of these libraries do not exist for Java, so a developer will have to spend more time(money) on developing a Java equivalent. Code in Java will at best run about the same as C++, but generally in the real world, it runs much slower than C++. Also Java is not compatible with any consoles, so that is going to limit you to Desktop systems, and possibly android. (I am ignoring low end java capable phone as they cannot run anything of visual interest) Use java if you are going to be building most of your systems for scratch, or you know of some java libraries that you will use, and are targeting Desktop systems. Do not use java if you are going to want to use C++ only Apis, want bleeding edge performance, or want to create console games. 

Since you wont answer my comment above I will give you a few options. 1 . Use a tilesheet that spans multiple Textures. 2 . Use a 

I don't thinks there should be any issues with it running on Windows 7. I have played every version of Unreal on my Windows 7 desktop. Windows 7 does require more RAM than Windows XP, so you should take that into account when ordering the computers, as if you have too little ram, the game's performance might not be as high. I do not know what you have specifically done to the engine in your simulation, but you really just should test this out on Windows 7 machine. You really should be able to find a machine that has Windows 7 on it to test. 

Here is one way to do it. Set a minimum distance that things can spawn at, so things can always be winnable, but make this distance almost impossible to win. Have a difficulty variable that that starts out high for easy, and lowers as it gets harder. Set the position of the next object at the minimum distance + difficulty variable + a small random number. This will ensure that stuff spawns randomly, but it just has some rules to follow before it spawns. There are other more complex way to do it, but for what you are describing I think this is the best. 

I would rather read than have to listen to a synthesized voice. Android where space is at a premium, I don't think any speech would worth the size penalty, but if you had to have speech, use a real human's voice. The only reason to have synthesized voices is generating them live to save space, but on android were you are also limited on processing power, you will not want to generate speech live. Edit: For your game you might want to look into the build in voice support, or use one of those libraries, as it seems that your game will not require extreme performance, so using a bit of CPU for voice generation should be fine. 

How can I create sound emmiters that pan and change volume based on distance from the player in a 2D game? 

Okay first off, I don't know how you think you are running 40 frames per second with each frame being 40 milliseconds. 1 second = 1000ms. 40ms per frame gives you an FPS of 25. If you want to actually be at 40 FPS you are going to need to have a timestep of 25ms per frame. Most racing games run with the car physics at a really high frame rate. One example would be Forza 3, it more sim like than most games, and its physics runs at 360 hertz. So using a frame rate that is higher than your update rate could work, although with java-script you may be limited with performance. If you really need to run at 40 FPS, I see no problem with creating a function that you can plug in the current time, and the distance, and have it return an estimated time. 

If you want to use that method of multi-threading, for each object in the game you ideally just want to the information that it needs to render. 

I am trying to figure out the best way to render a 2d game at any resolution. I am currently rendering the game at 1920x1200. I am trying scale the game to any user selected resolution without changing the way I am rendering, or game logic. What is the best way to scale a game to any arbitrary resolution? Edit: I am trying to achieve this: $URL$ but I think the code he has is for a different version of XNA because I cannot find that method overload he uses. 

If you are moving 1 simple object around, blitting will not give you any performance increase. But if you want tons of complex objects, particles and enemies, you should probably use blitting for everything. 

Normals in 3D graphics are a 3D vector indicating orientation or direction. Normals themselves cannot be shades, as how can you shade {.1,0,.4} ? Normals can be used to shade the polygons themselves. For example, a light source at a certain angle hitting a model made of polygons at a certain angle, the normals of the polygon faces can be used in the shading process to make the light make parts of the model brighter. 

FPH? I had no idea what that meant till I clicked on this question. And no I cannot see what could be useful about knowing how many frames per hour. What would be useful is logging the frames per second over time to make a visual graph, or to analyze programmatically. With frames per hour, you could have 60fps most of the time, and every 20 seconds 1fps, and the final reading wont look different than a solid fps that is lower than 60. 

I am not a lawyer and this is not considered legal advice. Yes it would be illegal. You have to contact the owner of the song, and work out licensing details. It is likely to be very expensive. 

That 66% percent of users on XP are not 60% of gamers who can run an intensive game. For that I would look more toward the Steam Hardware Survey. As of November 2010, almost 60% of Steam Gamers have a DX10 system. From what I understand DX11 is really similar DX10, but has some new features. It seems like you could write a 9 and 10 version and if you really want to use some extra features to enable eye-candy you could also port the 10 version pretty easily and support the new features. And to answer why you should learn it, I think you should learn it if you want the features it provides, if you don't want or need them, don't learn it. 

The Bitmap has transparency, and only non-transparent pixels are solid and used for hit detection for the physics engine and gameplay. I have seen some versions done with convex hulls, but for multiple reasons I am not using convex hulls to build the levels in my game. How can I implement 2d shadows on a level made out of a Dynamic Bitmap? The answer jpaver posted is good, but I am sure there are some other ways to do this. Does anyone else have any more information on this question? 

I think the best way to do it would be to manually set up boxes in the area(s) that you want the NPCs to take cover in. Have a variable for "fear" or some other metric you want, when a threshold is reached the NPC should move to the closest box that is out of the players line of sight. You could figure a way to dynamically have enemies take cover over behind any object, but more times than not those can generate some strange and illogical cover positions.