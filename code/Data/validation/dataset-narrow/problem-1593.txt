Unfortunately you need console access and a connected monitor which is very inconvenient because raspiBackup is used most of the time on headless systems. Another solution is to use networkd on Jessie. It seems somehow be related to systemd which is new in Jessie and the different way a backup is created with tar and rsync. Does somebody have an idea what's the root cause for the issue? My goal is to have the restored Jessie image to start again like the original image with an IP without any workarounds. Update 6/25 I started two Raspis - the original and the clone image, enabled debug on dhcp and extracted all dhcp messages from /var/log/syslog. I noticed 

Update 7/13: This is an important issue for me. That's why I posted the same question in this forum and consider that post as the primary post for my issue from now on. 

I found out you can fix the dhcp issue on the cloned image by starting the dhcp server manually to get an IP from the local DHCP server and then uninstall and install the dhcp client again with 

The exists a nice tool called pishrink which reduces the size of a dd image as much as possible by shrinking the root partition. If you start up the restored image the first time the partition is expanded to it's maximum size again. If you run Windows just use your Linux on your Raspberry to shrink the image. 

The way to boot from USB has changed. The latest raspbian image 2017-04-10 supports direct boot from USB and you just have to copy the downloaded image via dd or windisk32imager to your USB device. In the past you used an SD card to boot and then switched the root device in cmdline.txt to /dev/sda2. That's the way for Raspi1, Raspi2 and Raspi3 to boot from SD card but run everything else from USB stick. Raspi3 doesn't need the SD card any more. There is one important step you don't have to forget when you want to use Raspi3 to directly boot from USB: You have to enable boot from USB only once in your Raspi3. It sounds you didn't do this. You wrote you want to setup a clean system. So I suggest to execute following steps: 

The Pi has some GPIO pins, and they are great for a bunch of things. PCI, the conventional (old) PCI standard connector has two rows of 62 pins, a total of 124 pins. If you take out repetitions, that totals 124-45=79 pins (maybe imprecise). The thing is that is probably one order of magnitude more than the number of GPIO pins the Pi has. Actually if I did the same math with the Pi that I did with the PCI, it would have 20 pins. And considering the PCI bus has to do addressing and data transfer at 33MHz, needing to generate the address bus from a GPIO would probably take much longer than the available interval. Sure you can limit the address range (hardwire a lot of unused address pins for your application) and take out a bunch of pins, and you can make a kernel module to interface the PCI module with the GPIO, but still seems very unlikely that it would be possible. Now if you told me you would like to interface an old 8-bit ISA board... well I did that with an Atmel 10 years ago, with a Realtek network board, and it worked just fine with an ethernet stack and all...;) 

First Part For the first part of the question: there are a number of solutions that are regularly used on Linux/Unix machines for that sort of task. Some of them are even file system-level replication, like CODA, AFS etc. They aren't very widely used, though, but possible. Another one is to just export the file system from one host to the other, using NFS, which is a type of file system and gets mounted when Linux boots, or WebDAV which needs an apache module or some other solution on the server side and gets mounted by the client the same way. These solutions are susceptible to downtime and data loss due to lack of redundancy: if the server crashes the files become unavailable. You can also use windows-born protocols like CIFS or the old SMB. iSCSI is also a newer option. All then them susceptible to the crashing-server downtime issue. The most used solution for that task is a file-level replication application such as rsync. rsync will mirror the files from a server and make incremental updates, changing only the files that were altered on the server. It is pretty standard and easy to setup and learn. There are other options, of course, and searching for rsync will show you many of those. Second Part This seems to be distro-specific if you choose to use distribution provided packages for your server applications. On Raspbian, which uses debian's dpkg tools like apt, aptitude and others, you can easily setup a cron job ("man cron" and "man crontab" on your pi console) that will execute a "apt-get update" and "apt-get upgrade" to keep everything up-to-date. This solution does not come without risks though. Auto-upgrading can, rarely, break your setup and need operator attention. If it is in auto mode and unsupervised, you might run into downtime from time to time. 

The exists a nice tool called pishrink which reduces the size of a dd image as much as possible by shrinking the root partition. If you start up the restored image the first time the partition is expanded to it's maximum size again. If you run Windows just use your Linux on your Raspberry to shrink the image. 

You also can use tar to backup your root and boot partition. tar will backup only used space. To backup the root partition you can use following command: 

By accident I detected this question. raspiBackup can also be be used to restore the backup created by raspiBackup (See $URL$ So I'm wondering why you're asking how to restore the backup. Anyhow - a main design principle of raspiBackup was it also should be possible to restore everything with just plain Linux tools. raspiBackup saves the boot partition in an img. The root file system can be saved with dd, tar or rsync. So in order to manually restore the backup 1) you have to recreate the partition layout with the information available in sfdisk file 2) format the root partition 3) restore the img into the boot partition 4) restore the root partition with dd, tar or rsync Hope this helps even my answer it's quite late :-) I suggest to place all questions about raspiBackup on the website in a comment because that's monitored by me. Update 11/5/2017: One user of raspiBackup manually restored a backup and described the steps in detail. See here for details 

Check whether your ssh daemon is up and running and listens on all interfaces. Execute following command as user pi on your Raspberry sudo netstat -tulpen | grep ssh 

Download the 2017-04-10 raspbian image, copy the image via dd or windisk32imager on your SD card and modify the cmdline.txt (see your first link) echo program_usb_boot_mode=1 | sudo tee -a /boot/config.txt Boot the image from SD card which will enable the USB boot mode on your Raspi3 forever. Check with vcgencmd otp_dump | grep 17: 17:3020000a Copy the 2017-04-10 raspbian image via dd or windisk32imager on your USB stick Plug in your USB stick,remove the SD card and reboot. Your Raspi3 should now boot from the USB stick successfully :-) 

Short answers: 1-No. 2-There is a 1.1A polyfuse after the microUSB power connector, so anything trying to pull more power than this (includung the 700mA for the Pi itself) will cause the board to stop functioning. 3-The return pin should be GND. The long version: First things first: there are at least 2 electrical motors in a floppy drive. And if I am not mistaken, they are 12V motors. So, I don't think you will go far using only the 5V power pins as for powering up a floppy drive. The Raspberry Pi, unlike other electronic hobby-targeting platform, has no protection whatsoever in the GPIO or power lines. That alone should drive every project thought to make use of these signals to think about some sort of protection, at least a transistor. You are talking power, motors. You should always use some sort of protection and never connect it directly to the Raspberry Pi. You can use the Pi as a controller, but shouldn't use it as Power Source. Use it to control some power circuit that will source the power you need. That said, according to the the Raspberry Pi Hardware guide: 

RT_PREEMPT will further break control loops in the kernel, making them preemptiible, and resulting in further lower latencies. But even the RT_PREEMPT seems only to better the response time by an additional small amount. According to Brown and Martin, the best refence I fould about Real-Time linux, if you need hard real-time you will have to look into Xenomai, or possibly RTAI. If you want to use the RT_PREEMPT patch, there is a thread about it. You can find ready-images of Xenomai for the Raspberry Pi, and a couple of howtos here and here if you want to build your own Xenomai Kernel. 

I would suggest you check the DS18B20 1-wire sensors, which are digital, and have working kernel drivers. Adafruit has a tutorial on how to get them working. You can use up to 10 sensors on the same pin at this time (this is a hardcoded kernel driver limit, as is using the pin it uses. This tutorial has it right, just follow it). As for reading the results, it is as easy as finding a file with a predefined name pattern and then opening the file for read and parsing 2 lines of content. Using 2 sensors is as easy as duplicating the procedure for reading one. Each sensor will be made available in a different file in the file system. There is no need for any Java-specific libraries, procedures or tricks altogether. Just open a file with a particular name pattern for reading. If you use the same sensor, the filename will be the same between readings, so you only need to find the filename that the kernel driver creates once for each of the sensors throughout the sensor's lifespan. As for an expansion board any that makes pin GPIO 4 (which is P1-7) available is okay. That is the fixed pin number used by the 1-wire kernel driver. The Pi Cobbler from Adafruit is one of the many that will do that. 

There exists a backup tool for Raspberries called raspiBackup. If you restore this backup on a different SD card you're actually cloning your Raspberry. 

Addendum: It's also new for me the new raspian image supports direct boot from USB. I have already some Raspi3 enabled for USB boot. I was keen to know whether the new raspbian image boots from USB and I just downloaded the new raspbian image, copied it on an USB stick, plugged it in and I was able to boot from the new image via USB immediately :-) 

This question is old but I think it's worth to add another answer: There is a tool available called pishrink which shrinks an image to it's minimal size and will expand it to maximal size during boot. Just shrink your image, copy it to another sd card and you're done. 

I never used etcher. Whenever I prime a SD card I use the dd Linux command. Windows guys use win32diskimager. Anyhow: The etcher doc states it's checking the cloned images. If that's true then it seems the image you use is somehow broken. On the raspbian download page the sha1 is listed. Please use sha1sum to verify the sha1 of the downloaded zip file matches to the published sha1 and download the image again. 

If you use Windows the boot partition will be mounted as soon as you plug in the SD card. Open any editor you are familiar with on Windows and create a file called 'ssh' and save it. That way your Raspi will enable the ssh port when booting :-) 

QEMU has an ARM emulator. It's a SW emulator and you should have a powerful Linux box. I personally use QEMU to run a test suite on raspbian to test a shell script. I didn't try to run a web application. But I would give it a try. I published the steps I executed to create the QEMU image on my Linux desktop on this page. Hope it helps you to get a QEMU raspbian image up and running very quickly :-) 

I don't suggest to use noobs which makes a lot of thinks much more complicated. Install Raspbian on a SD card instead. Next create a file called 'ssh' on the boot partition. If you have a Linux box handy mount the SD card and partition mmcblk0p1. Then just execute 

There is a debian-way of running OpenVPN, which is a lot easier than trying with different scripts on your own. When you install openvpn using the package manager (apt), like: 

Everyone of the 3 git repos you linked is for a specific component. The tests one constains a full program. You can infer that the Kernel needs patching, as well as some other components, from the first paragraph of the link you pasted: 

It has torrent and donkey protocols in a light daemonized server, that you can access via a HTTP connection using a browser, even from remote machines. 

It accepts Direct Current. A pretty FLAT thing that does not move. Waveforms are only useful when speaking about power supply when it is an Alternate Current supply.. 

I know of two great sites for supplies and also for information on how to use external hardware with the Raspberry Pi. They are Adafruit and Sparkfun. You should definitely check Adafruit's Raspberry Pi Tutorials, where they teach you how to connect a number of different hardware to the Pi. Spark fun also has a number of tutorials, but they don't seem to be as specific to the Raspberry Pi as Adafruit's. But you should give them a look also. 

There are a number of protocols that stack on top of Bluetooth for specific applications, such as Human Interface Devices (mouse/keyboard etc.), Audio Headsets and others. They are called "profiles" in bluetooth-terminology. Wikipedia has a comprehensive list of bluetooth profiles that is interesting to know. Many of these profiles have driver implementations for Linux, and, as an extension, for the Raspberry Pi. Choosing one of those existing profiles would be, thus, the best option for such a project. Linux machines use the BlueZ Bluetooth stack, and you can check which Bluetooth profiles it supports in the supported profiles link. For your particular application I would suggest using the Serial Port Profile - SPP that should be simple to implement and will transmit and receive short messages like the ones you probably need to get your project done. Sometimes it is called RFCOMM, like in the Android Bluetooth Documentation. Given that there is a BlueZ version for Android (I don't know if it is the default stack on the Android, but I suspect so), you have the two sides of the channel supporting SPP. Other profiles you might take a look that could get your project done, even if in a hackish way, are: