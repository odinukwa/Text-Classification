and the first time through the loop it will always display 0 because it never waited between readings. You should put the as the first thing inside the loop, or, while you are using top as a test, you should comment out the because the top call essentially is a . /proc/stat Your processing of the stat files is broken. The format for the file is (taken from my machine): 

That will likely halve the time needed to find the string length. Then, your code would be a lot easier to read if you used array-like subscripts to access the chars instead of pointers..... that way you can get rid of the variable as well: 

Additionally, there should be an empty line after the closing and the start of the next method declaration. Threads You are using swing, yet I cannot see any places where you are accommodating work that is done on the Event Dispatch Thread (EDT) vs. your game thread. This is likely to lead to inconsistent gameplay, irregular timing, and other problems.... especially during the manipulation of the Graphics objects. Terminology I am not seeing a Finite Automata here... this looks pretty open-ended, not finite. Magic Numbers These are everywhere. There must be a better way to centralize them. Integer Arithmetic This line: 

This is more to tackle than would be easy to cover in a single answer. Small items. There are a couple of small items that are a problem. 

If you want to pull an event from a listener, you can easily do so by adding a listener. If the listener feeds events in to a (blocking) queue, you can iterate on that queue, and pull events as you need them. One thread parsing the files, and other threads waiting for the needed data. That's the way I would do it.... Actual code I would start off with an interface like: 

Midpoint math is often a pain in the whatnot, but a real trick is to add 1 to the length before halving it. Additionally, instead of repeating the math multiple times, you can do it just once. 

I have exaggerated the indentation to make it all visible..... Now, gives us some extra methods over just-plain-Map... You should use them. First up, this "check" method. @maaartinus correctly identifies this as being a problem with the name. The standard name used in many libraries (including the Java Native libraries, is . 

Conclusion Right now, your code could do with a major refactor and shuffle. have a look at your options, and then try to bring it together in a more structured framework. Your current code has out-grown it's exoskeleton, and it's time to spread it's wings and try something different. 

We produce these by setting up two arrays, the actual char pwd array, and an index array: We initialize the arrays as: 

The member fields should be final. There should be 'getters' for the fields, and the fields themselves should be private (not public like you have). 

The above will set the environment variable to that complicated JSON.... you can understand why setting it on a commandline would be messy...;-) ? Implementation With such a big background, the implementation itself is actually quite simple.... but it is critical I get this right as I learn how the node.js systems fit together. I am looking for a review of any and all aspects of the code, the use of the libraries, the conformance with best practices (async is not an option here, I don't believe, but I am possibly wrong, please correct if I am). 

On further reflection, the looping example above (as opposed to the streaming one), will be faster because it does not do the String regex, etc. and does not have an intermediate String value. The same logic in Streams, with 'continue' type logic, would be implemented with a , but we could/should also avoid the toLowerCase...: 

The same code running bit_length in python 3 is shown here in ideone (also contains correct parenthesis for python 3 print statements). 

Preferably brace it too (like style guides recommend - they also recommend a space after the , and before the ): 

I would not worry too much about the stack overflow. Java typically has 10's of thousands of levels it will manage before overflow. On a reasonably balanced tree this would be more than enough. DFS2 Again with the static, but the rest of the implementation looks fine. The Stack based system is a head-scratcher, but it works well. It allows for the stack to simulate a recursive approach, and that's what we would expect. Your use of is good, and often I see people using , so nice there. DFS3 You messed up your naming, why is got the method name ? Consistency please. THis one using a visited marker on the node is a real problem. The code is no longer reentrant, and you have to reset each node before you can call the function again. DFS4 (or 5, depending). Using a HashSet is an OK option, but it requires a lot more space to manage. Additionally, it depends on the hashcode and equals methods, so would be slower. I would avoid it. 

In general, I would suggest that you are approaching this problem with the wrong object model. Your model is: 

I think you have missed the point with the NumberPicker here. There is no need to add in a new level of abstraction for your application. Right now your 'calling' code needs to implement a class, and call . The needs to implement the method. Sure, this works, but, the design is supposed to be a whole lot simpler, just do: Make your calling code implement a and the method. Then, it can call directly. Basically, your code should be simplified to: 

That will, for example, return 0.0 for ..... which is not the double you are expecting. Secondly, catching division-by-zero using exceptions is a poor way to do it. You should instead just pre-validate: 

I encourage you to explore the Thread version because it will expose you to other aspects of server programming, specifically multi-threading which would be the logical next step for you if you want to handle more than one client at a time. Bugs You have some small bugs that concern me... for example: 

you really should not use . A simple would work better in this situation You are not closing the Scanner when you are done with it. I know that in this case, working on you don't think it's necessary, but, you should get in the habit of doing it. I have seen too many occasions where unclosed-handles create problems. the variable names are horrible .... , and ? (Well, is OK....). in the current version of the code, you are still doing and not . This is because you are starting at . If you start at you can do a clean . returns a . Doing a comparison against double for each loop is something the JIT compiler may be able to optimize, but I would err on the side of caution, and manually cast it outside the loop. 

There are few small things that stick out to me... starting with the least significant, and moving up... Constants Why are your error message text values public? If it is to satisfy the Unit testing, then the common solution is to make them package-private, and put the unit tests in the same package as the code. Most common build tools (ant, maven, etc.) have separate folders for the tests and the source, and you can have the same package structures in each. If you really want to test the actual exception text, then the better solution would be to have separate specific exception types for each problem type, or to reuse different existing exceptions. For example - it is quite OK to throw a if one of the input strings are null when they should not be. An for empty-strings is OK. Or, create the if you need it. vs. In your validation streams, you have code like: 

You do not report the actual Error - is not actually reported somewhere. What if the error was "UUID is invalid: Illegal character 'G' at position 25". That's a useful error message, but instead, the user just gets the error "Invalid Token". In your other error-handling block, you do a better job og logging the actual value, but those values are still not reported to the "client", they are just logged on the server. You don't alter the behaviour of the program.... you "report" the problem, but you don't return, or abort the file processing. This is a big deal. For example, when you have you report a broken , but you keep processing things, which means your may be , and your following code will panic. Duplication! That same error logic is repeated many times. You should refactor the code and reduce the duplication: