I'm not sure if this applies to your case or not, but c++ implementation of box2d ask for some class to do rending jobs. so you have to provide box2d with some class telling him how to draw objects. you can manually pad all the given box2d data in your debugdraw class. 

There is a project named Sprite Sheet Packer which is designed to create sprite sheets, recently I've wrote a plist exporter and you can download it from here. though you need to compile it yourself. 

One last solution that I didn't see in other's answers is to add check some to your save data. For example you can calculate sum of all characters in your save file (excluding checksum) and print it at the end of file. this way if someone changes some characters in your file you can easily notice them. you can also spread checksum bytes over your save file to make them less noticeable. maybe if you are using MD5 checksum and you expect your save file to be 256 characters length, you can save checksum in bytes [2,4,6,....,512] 

dec value also creates some upper and lower bounds for player velocity. note that if we can assume velocity should be somewhere between -10 and 10. for more information I need to know the code other than that lines. 

The Easiest way is to update your world twice(or more) every cycle. using this method you can increase your max speed 2 or more times. The more Universal way to do it but is to check collision of the shape generated by the moving object, with all the tiles. something like the picture below while red box moves collision is checked for every square in map and the blue area (which is a polygon generate by convex hull algorithm): 

some notes: this function gets player origin and velocity as input and then returns velocity after applying slide effect. it's trying to find some free space in front of player and tells player to move in that specific direction. if statement which checks for picked objects is almost equivalent of 

I'm not sure what type of game you are asking for but there is an opensource game named OpenTTD written in c++. I think you could use it as a good sample. some features that make this game unique: 

We know that and => => => At other hand we know the target itself is 1 meter wide, so as long as that value is less than one meter we will always hit. after that part it has a probability of which is equal to . Note that we can always assume all of target surface is inside cone of fire. it's doesn't really affect game-play that much but ease calculations very much! now back to our 3D problem with a 2D target. Since it's a cone we are talking about the bullet will always pass through a circle of certain diameter when passing the target. again we need to compute it's radius, then the area of that circle. As I've explained before we can use and hence the surface area is . And in the end we know probability is . as I said it's a function of h^2 but since is very small, it takes a long time before that probability falls very low. 

The spring model will result in an unrealistic effect. since when a shooter wants to tune his gun after a shot, he slow his movement when he gets near to original target. I'm not sure how my algorithm will turn out but I think it will generate good result: lets say a player originally targeted point x,y; when he shots, I'll set random values to two new parameters dx,dy; I'll then adjust shooters target to x+dx/(1+time*const_value), y+dy/(1+time*const_value). note that time is calculated from when player shot a bullet.const_value is something based on weapon type. for example for snipe rifle it's something smaller than 1, but for a shotgun it's larger than 1. random value for dx and dy is also based on weapon type, for a snipe it's something small but for shotgun they are big. 

there is a game engine named cocos2D, and it contains an audio engine named cocosdenshion. it's a three layer object oriented sound engine. you can easily select a layer and starting working with that. and it's all based on openAL, you can surly get enough ideas from cocosdension even if you don't want to use it directly. and it's under MIT License so you can use that without any worry. 

I need both reach GUI features of c# toolboxes and fast rendering features of XNA, is there any way to merge these two into one app? or is there any other way? for example some equivalent to c# toolbox in xna? 

Here is another idea which seems to be missing: In case of long distance backgrounds, like sky boxes, Parallax layers doesn't really feel good. Think of the stars for example, when walking on earth, or even better through out the night, all the stars move together, though we know they are hundreds or thoughts light year away from each other. The thing is they are way too far away for us to notice their distances. All that said we still want a very big texture (say 120k*120k), to be drawn with our limited computational power (which can handle 8k*8k at most). Like using multiple parallax layers, you should create different textures, each with different kinds of details. For example one represents galaxies, another one is a bunch of stars, etc. But this time instead of moving them with different speeds, they should differ in their sizes. Here is an example: Consider using 3 textures, one is 2048*2048, another one is 729*729 and the third one is 625*625. Since these numbers are coprime with each other, When combining these 3 textures in 3 layers, one should move lcm(2048,729,625) = 764M pixels from the origin to see same thing being drawn, which kinda feels like infinity. In fact you can add other layers or change size of each texture and you'll always end up with a result as big as least common multiple of texture sizes. 

maybe it just stuck in some function in the main loop so that any other event(like touch event) make them step one point but the main loop event doesn't happen any more. 

accoring to your changes I can assume you have two angles, one that I call theta which is just like the one you have in 2d plane and has some value between . and you have a second angle called (let's call this one phi) and it has some value between . you can see in the picture what are these angles exactly specifying. 

First of all we need to know how a beizer curve is generated. according to it's wiki page, a is a function of t stated as follow: In this formula t is a variable between zero and one and all other parameters are vector values (it means B(t), P0, P1, and P2 have values for x and y in 2D world). the next thing you should know is how to define a line based on two given points. again we can see in beizer wiki page that lines are some special kind of beizer curves with only two control points and no beizer point. and their formula is again defined using parameter t as follow: again t is a scalar value while p0, p1, and L(t) are 2D vectors. Now we want to know if our beizer curve collides with the ray started with an specific point in an specific direction. to do so we need to solve This equation: 

while working with z buffer, what ever you draw will change the depth. Meaning when you start drawing player all it's pixels are marked as z=0. Later when you draw the door, all pixel that are draw above player will be drawn with z=2. At this point we change the depth test function. Depth function determines what are the conditions to draw a new colors in that specific pixel. As I said we change the Depth test function. It means from that point forward OpenGL will only draw objects if they are behind other objects. I guess you can now see where I'm going to. The blue rectangle is behind the wall but it's above the red one. So while drawing OpenGL should just skip all the pixels which are not behind the wall. note: I've just noticed the default value is so I've changed instruction 3 and 5 

the only real restriction you have while developing for iphone is the sdk apple released for iphone. other than that you will mainly use OpenGL and OpenAL which are both pure C code. in some cases you might want to use some c++ libraries (like box2d) but there are equivalents both in C and Obj-C. so every game you release for iphone should at least have some obj-c codes to load your application and to do some basic file read/write things, other than that you are free to use pure C, Obj-C or C++ or even a combination of those languages. also as jasconius said there are many games written and published using only Obj-C. there is even a opensource gameengine named cocos2d-iphone out there that powered many iOS games so far. 

you can inherite a class from your button class and override OnClickFunction in your CustomButton class. The benefit is you don't have to check if the button is pressed it informed you whenever it's clicked but it may cause to overuse of inheritence. you can define some function OnClick and pass it to OnClickEvent butten class (just like normal c# event handleing). this has the same benefit as the previous one and you don't need to worry for inheritence overuse. you have to check in your main loop if this button is clicked or not. in this method it's not realy event. so the disadvantage is you have to check yourself whenever you have to do somthing based on button inputs but it has a advantage that you can control where the buttons really are checked and take effect.