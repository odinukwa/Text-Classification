I think that your limit checking is a little obscure. Why are the constants defined in the constructor? They're related to your class, not to your constructor. If I were to be able to change the or someday, I'd need these constants to validate that my new values are still "legit". You might want to look at the Contract class in the .Net Framework. It offers functionalities that would be useful to you. Otherwise, if you don't want to use this, you should at least rename the method to something like or something close to this. Right now, isn't very self-explanatory. Comments like this : 

It is somehow easier to read and respects the coding standards. Try to keep your constants at the top of your file and keep your order consistent. Let's say you have this template : 

You got the good start, and some methods don't go hand in hand with that "convention". But, some do! Ex : 

Much shorter isn't it? Your indentation is flawed, I don't know if it's related to pasting it here or if it's this way in the IDE. Try to respest the IDE's indentation, why is more spaced. Space is cheap, use it ;) Your Connection String shouldn't be hardcoded in the application, get it from a configuration file (web.config or app.config) or at least receive it as a parameter somewhere. 

P.S. Generally speaking, it makes sense to do not hold an intermediate state of you calculations (like trimmed string values) – just an original data + define functions/properties to process them. It makes your design more flexible. P.P.S. It might be useful to have class: 

And all the API with multiple overloads will come as two sets of extension methods – I really like this trick :) 

Mixin type emitter (Well, not sure that implementation really looks readable - I hardly understand IL. But it works for method delegation :) 

What do you think about this file system manipulation helper? There is an utility class Folder which I can use to define directory structure of my app: 

While implementing things like repositories we often can see that reading and writing parts can be done totally independently. The same time client side will win from the single reference (who wants to inject two parameters instead of one in many places). What do you think about a little bit of IL magic? Let's say we have: 

I would not personally put LoggingService implementation inside factory, as it reduces testability and usually needed to play some tricks with generics type parameters only. To have a predictable behavior according to your design it might look like: 

Semantically, HTML button tags are supposed to represent a user's action, whereas the link tags are supposed to take care of the navigation between pages. That said, as @user1320170 pointed out in comments, your tag should be a link (< a > tag.) You'll notice it's much clearer this way. Apart from that, your code is good, using is a good plan. 

Imports You should define your import at the top of your file, not in the method. I know you only have one method, but if it wasn't the case it would get complicated to track where each import is. Exceptions Depending on how "normal" it is not to be able to scrape a link, you might want to stop your process there and check. So in your you could use , which keeps the stacktrace intact. Apart from these two little details I don't see much problems in your code. 

Read your comment, read your method name. Does it mean the same thing? No it doesn't. In that case, should be or something like that. is a very vague term. should be or something like that. Because right now your method doesn't explain enough. That : 

What do you think about the following syntax for some very simple and intensively reusable validations? Does this: 

DDD How often have you heard from your domain expert manually managing room booking in his/her Excel all those terms like , , ? I bet that never. This stuff does not belong to the domain, does not solve any business problems, and probably should not exist. Having names like that clearly indicates the problem - those words are not in the Ubiquitous Language. Domain logic is way too corrupted with technicalities. Sure, no database related code should be allowed in domain. P.S. It depends on the task, but I could probably load all the data in memory and run here easily. Design What is the Software Design? All the things helping you to keep your project maintainable and that you cannot change latter easily. What helps keep project maintainable? Placing dependencies in a way where volatile components depend on a minimum amount of stable abstractions using Dependency Inversion where necessary. There are too many concrete tech elements in your code to follow “minimum amount of stable abstractions” criteria to keep things maintainable, so design misses its goal here. P.S. It is not a responsibility of the Controller to decide on room/combined room booking priorities – it belongs to the business logic – to the place where you actually implement the logic – repository in your case, as you do not need DDD here at all. I would have the following models in the Core project without dependencies on anything else: 

If the file contains PHP code without closing (which is recommended), you'll get a syntax error. the code and remove at the end. 

I'll keep the procedural style, you use; otherwise I'd prefer object oriented code. You need a function that creates the database connection on the first call and returns that connection on every call. 

To make the singleton pattern in complete, the magic method should made private, so the connection cannot be copied. Business Logic Layer Keep the business and data access layer separated. The business layer ideally does not know anything about storage. The data access layer is injected into the business layer. 

Consider using an autoloader (see PRS-0). Then you don't have to bother about, where files get included. A Factory is used to create a set of objects, which depends on some context. For example, you could have a and a for XHTML or HTML5. In order not having to check which one is needed again and again, you have an and an with and methods. Factory methods usually are named . 

Of course the is simplified; you can easily elaborate it to do a more sophisticated error management, but you get the point. 

In Java, the convention wants that methods are written in camelCase. Which means should be and so on. The indentation is a little off with the declaration of the . Instead of this : 

Well, why don't you create an exception that works with this? Something like (You might have a more appropriate/domain-specific exception name!) : 

Since your validators are stateless, I think you should initialize them in the constructor of the object (called only once) and make your validation list , this would save you the performance cost of creating validation instances everytime you create a instance. 

Your validation doesn't have to be in the controller, I'd even say it doesn't belong there. You should probably think about having Command validators that would be some other classes that say if your command can be launched. I would want to give you more information, but the lack of context on the code makes it hard for me to show you how I would build the controller but it would go along these lines : 

Is it better? That, I don't know, it's a matter of opinion in that case. PS: You might want to add attribute above your controller's actions. You don't want people to reach these actions with a , or , it'd be weird. Thanks to @Heslacher, there's a way you can cut on some duplicated code by delegating the creation of somewhere else. I would recommend creating a second constructor to this ViewModel that would look like this : 

But it mixes multiple version translation in a single piece of code and will look ugly after introducing of more versions. What is the best way to deal with versioning generally speaking then? I would prefer a single sectioned query to deal with all versions in a unified way instead of running stored procedure with multiple queries if possible. P.S. I just think that is a must feature here... 

This type of functionality does not require whole document to be loaded in to the memory. It might be easily done as a set of improvements over which provide better scaling possibilities: 

There are a lot of parameters I would like to configure for my object, so having some kind of composition helpers is a big thing to simplify proper use of it. Let’s say that we have only 3 parameters for the sake of clarity (there are a way more, but amount of code in C# is overwhelming): 

definitely looks having a lot of responsibilities. Have you ever consider implementing here? It is an inverted IEnumerable, "push" instead of "pull", so it works really well for event sources and they filtering/handling in a time sensitive manner. Reactive Extensions (Rx) for .NET provides you with some kind of LINQ for observable sources. There is a free downloadable book Intoduction to Rx - you will just need a part of it to grasp the idea. 

I've unit tested this code (except the builder, but it works according to the unit test that uses it, tests will come later, oops). I want to know if there's anything smelly in there or things that could be optimized. The full code can be found on $URL$ 

Your method name is misleading. , in my opinion, would verify if your inputs are sorted. You should rethink the method's name to consider that there's the same increment between each values. If is set to , you can use this simple boolean expression to validate your numbers : 

Notice the , they're here because there's not enough context in your question, I can't figure what type to use. In your next question, please add more context! :) Now, we've got a method that does the nasty work for us, let's see what the code looks like : 

You should never expose a . In fact, in most cases you never want to expose a concrete type when it comes to data structures. Since you return a list, I assume the said list won't be modified by the caller. So you should return . This limits the ways a user of your class can screw up your code (as you can't add/remove/insert/etc. from an IEnumerable<> without casting it, then it's just asking for trouble).