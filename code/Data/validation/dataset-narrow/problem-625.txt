I like the way you defined and . I think that using to compute the number of digits is a bit overkill. Do you really need to convert the number to a string to do that? I think that using a logarithm is better. 

You can then define and by simply passing the appropriate strategies to . I think there is still room for improvement. Your code relies on some global state through and . Getting rid of the second one is trivial. You can just pass it as a parameter to , making it even more flexible as it will now support also different combinations of fading strategies and fading intervals. Clearing the timed action could be a bit more tricky. One possible solution could be to make your function return another function that closes over . In that way you will only need to keep track of the function you got from the invocation of and invoke it when you want to stop its action. 

That class should contain a reference to an InputStream and to an OutputStream and it should completely handle input validation and the rendering of the game state on the screen. should represent an action of you game such as create a new game, exit, ... I don't think it is responsibility of your application to maintain a list of words in an external file. You can use a class to read from the file, but you should not write to it. You should just have a implementing a method. Finally you need to put everything together. What about this simple game loop in the method. Note that you should really decompose it in some sub-methods but I think that for now it would be ok if you manage to get to an implementation that works in this way. 

Disclaimer I'm not a Javascript expert so I cannot guarantee that the code I wrote works flawlessly but I hope you at least got some ideas on how you could improve your code. 

I had to implement an auditing system where the user have to provide a reason he needs to perform a certain operation. When he provides the reason, he can perform freely it for a certain amount of time. Each execution of the operation needs to be logged somewhere. I implemented it using a Continuation Passing Style, which allows me to cleanly handle atomically permission checking and operation logging. 

I would introduce a layer in between your threads and the file. E.g. have a thread that handles all writing to the file, it holds a mutex protected queue which is written by the other two threads. That way you have a layer between the physical file (slow access) and the queue (fast access). You then do not have to lock the file in any way since only the thread that writes the file needs to have access to it. 

I/O You want to read 2 characters although you use this can have the effect you are overwriting the end of the buffer when you read since there is always an \0 added to your two characters. Either increase the buffer, change the format specifier or use an alternative method of reading from keyboard e.g. followed by or simply read the characters one by one using . The latter method has the advantage that you could prevent the user from entering invalid characters while he types. You may also want to convert the characters to upper case just to be a bit more flexible towards the user () structure I think the code could do with some more functions to clarify the purpose. E.g. 

is the name of the function if you want to use standard C but I understand your compiler has some convenience function. You should also check the return value of ungetch() to see whether it failed or not. It returns EOF when it fails. Code is for programmers to read so there is absolutely no benefit of making terse expressions by ocular optimization, instead let the compiler optimize and focus on writing clear code. Use compound statements instead of single line statements for clarity. 

always make a habit of initializing all variables when you declare them, it is good practice. when you use runtime functions you should check the return value e.g. scanf returns the number of argument it has successfully parsed based on the format specifier, if it returns 0 you know something went wrong and can do something about it instead of having a potentially uninitialized variable to deal with. personally i prefer using fgets/sscanf/atoi/atof for input, fgets is simple to use and can not cause stackoverflow if user enters something unexpected. even though you have split up your functionality into functions you shouldt go one step further and split it further. It may also be useful to create an enum for the account type e.g. 

clearly something went wrong because , which should really be local to never got cleared between the first and the second invocation of . Your algorithm looks ok. If you need more performances you probably need to trade some memory for a better execution time and adopt a solution based on a Sieve of Eratosthenes-like approach. 

I think that at this point you might be thinking at how you could obtain an instance of . I think you should use some sort of factory or build it using reflection depending on what is better in your use case. 

The first thing I noticed is that you're lacking separation of concerns. Why does you class implement ? It should just represent the state of your player in the game without dealing with user input. That should be the concern of another class. Why do you have ? You should really pass this a parameter to the constructor (or to a modifier method). Public fields are almost always a bad idea. You usually don't want them so you can have a better control of who/how can modify them. , , , and have a very poor naming. What about introducing an with , , , , (and maybe )? That should help you make your code cleaner. Why is a public member? What is the meaning of and ? Their naming is cryptic and does not help me understand what is their purpose. All the invocation to static methods in like are a huge smell. Why do you need them? You should avoid almost at all static methods. Probably what you need is an method, that returns information about the movement performed by the player. It should be called by , which should also compute the new position regarding the current background. It does not make much sense to have it in . Ditto for , , and invocations. You want a different class to handle input and rendering. That class should contain the , , , methdods. They clearly don't belong to . I hope that these comments will give you some ideas on how to structure better your code. 

Why don't you use more self-explanatory names? For instance I'd rename to . I know the symbols you used are quite standard but I think it is a good habit to give meaningful names to the variables you use. I'd also suggest you to exploit the regular structure of your code to shrink it a bit. You can do that by creating a function that asks the user for a couple of values and executes a function. 

I'm developing a Go REST service that uses JWT (JSON Web Tokens) for authentication. I've written a JWTHandler which validates the token using a Validation Handler. If validation succeeds, the request is passed on to a Token Handler. If the request fails, it is passed to an Error handler. All three of these handlers are public for the sake of flexibility but I've provided default implementations for Validation and Error handlers. jwthandler.go 

MessagesListFragment Firstly, should only be used for initializing the view. If you want to perform networks calls, you may do so in : 

Use a to load the images asynchronously on start up. Cache them in memory and use them as needed. Only load images as needed. For example, the board may have 200 tiles, but only 10 are visible at a given time. So load the first ten tiles. Anticipate which tiles will be needed and load them as necessary If resizing is a one time operation, perhaps saved the resized images to disk so that you won't have to resize them after the first time. BufferedImage offers . You could have one big image with all 100-200 tiles. Load this one big image once, and then show only the relevant part of the image using . This is a concept known as Sprites and you can find a clearer example here. 

In , I don't like how I'm using a factory to create a dynamic handler for every request. Is there a way that the same thing can be written without the factory method. There are just way too many if-else conditions for the sake of error handling and I just can't figure out how to clean it up. The design of JWT Handler was inspired by the Go blogpost on 'Effective Error Handling in Go', but I just can't get my head to think that way. 

We will start by cleaning up the code: First, let's make the for loop cleaner to read. A compiler is able to inline variables that are only used once in a scope. 

Second, in , StringBuilder is more efficient when concatenating strings. Also, is redundant because you apply the same logic in both cases. 

Now, let's deal with performance: You are loading 100 - 200 images from a file, resizing each one and then placing it on a screen. This is a resource intensive task and you need to optimise it. Here are some suggestions 

The while loop's expression says it should quit when c is not a digit but after that you do not handle the case if c was EOF. Should you then return EOF or 1 ? Personally I get a bit confused by the function name, when I read getInt() I expect it to return an int instead of getting the value via an argument but that is just me. 

sidenote: when you declare functions that do not take parameters, write as argument. In C when you write e.g. it means that the function can take any number of arguments (as opposed to C++). Writing makes it clear it takes no arguments. get_slices There is no reason to declare as static, better to have a local variable that you return. You should also check return values of allocations, they may in some cases return NULL so that must be handled. also again, lose the gotos generally speaking it is good to check arguments to functions so that they are sane. e.g. with asserts 

it is a common defensive programming technique to put asserts at the beginning and at the end of a function to ensure that the functionality is as expected. first you check if the caller contract is fulfilled, then that the expected result is reached. 

There are magic numbers in your code 2,3 etc. try using constants for those values with descriptive names. The function is arguably a bit long and has quite a few if-statement levels, better to split into several functions that you can parameterize. You may also want to present public functions to the user that do not have all the arguments then leave the original protected e.g. 

There are several style guides (e.g. google has one), it is up to you pick one or do your own but there is no universal style guide. Important is just that you are consistent in your code so that you don't use different styles in different files, that is confusing (irritating) I find your code looks fine from the style point of view. Normally one would avoid (if possible) to include the headers like Hangman.h and CharReader.h in your header GameManager. Instead you declare them as pointers in the header and remove the headers.