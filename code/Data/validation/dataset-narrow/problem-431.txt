is \$\mathcal{O}(n)\$. Assuming we have a string of \$n\$ distinct characters your algorithm could devolve in to \$\mathcal{O}(n^2)\$. Of course your strings are likely never long enough for big O to matter. In problems like this no matter what language you use it is often useful to build tables of characters. 

Bugs Your optimized routine has a couple major bugs. I always recommend checking the output between original code and optimized code should you need to perform optimization. 

Notice that operator[] inserts elements if they do not already exist in the map. If you do not want this behavior or you want to handle the error differently than returning a value-initialized unsigned int then do the following: 

Since I am not a Java programmer I will just comment on the core algorithm here. I am not sure if there is a non-naive solution to this problem so I will focus on the naive approach. 

First let us remove the variable step factor. So . I will reincorporate the variable step factor later. Let be a \$m \times n\$ matrix. yields a \$m \times i\$ submatrix of . Let . This yields the column differences of . 

Advanced Assuming the range of numbers to check is large, there is a better way to solve this problem than the brute-force approach. We can use the concept of induction and recursion to solve this problem in \$\mathcal{O}(2^d)\$. For simplicity, the following approach does not handle the fact that zero is a Stepping Number. Rather than checking all numbers between \$A\$ and \$B\$ to determine whether they are Stepping Numbers, we will instead generate a superset of Stepping Numbers in this range. Let \$d_A\$ be the number of digits in \$A\$ and \$d_B\$ be the number of digits in \$B\$. This approach generates all possible Stepping Numbers on \$[d_A,d_B]\$ digits. We then filter this initial output to produce all Stepping Numbers between \$A\$ and \$B\$. While you could generate the Stepping Numbers strictly between \$A\$ and \$B\$ without filtering at the end, doing so would either require you to either maintain two separate lists or generate unsorted output and then sort it later. Generating the extra Stepping Numbers outside \$[A, B]\$ is not a big deal since there are not many Stepping Numbers in general. For example, there are only \$3627\$ stepping numbers in \$[1, 2^{31} - 1]\$ which is the positive range of a 32-bit integer. Assume you already have a Stepping Number \$S\$ of length \$l\$ and you want to append a digit to \$S\$ to create a Stepping Number of length \$l+1\$. There are at most \$2\$ ways to do this depending on what the least significant digit (LSD) of \$S\$ is. For instance, assume \$S = 43432\$. The LSD of \$S\$ is \$2\$. In order to append a digit and have the resulting number remain a Stepping Number, the appended digit must be \$1\$ or \$3\$ resulting in either \$S_1 = 434321\$ or \$S_3 = 434323\$ respectively. It is important to realize that if you have all sorted \$n\$-digit Stepping Numbers then you can easily produce all sorted \$(n+1)\$-digit Stepping Numbers by iterating through each \$n\$-digit Stepping Number in order and, for each Stepping Number, appending digit \$\mathrm{LSD}-1\$ before \$\mathrm{LSD}+1\$. 

The swap method in the other answer is the approach I would use, however there is a similar answer that more resembles your approach so I thought it would be worth sharing. The method will be to build the array of non-zero elements and fill in the rest after. The trick is that if we do it backwards we can get the correct output in-place. 

Since I do not know what the actual implementation will be I can only comment on the code as it is presented. From the algorithm it appears that you are applying a filter multiple times in order to monitor some propagation effect - as opposed to applying the filter multiple times to stabilize time profiling. From here on out I will assume that running times is part of the core algorithm. General C++ concepts 

Yet Another Approach By restructuring the recursion we can remove the skipped parameter. The trick is to use recursion only when needed. Iteration suffices to skip indices but we "must" recurse to choose an arbitrary number of elements from . Here is a simple substring printer (powerset) using this method: 

As mentioned in the comments of the other answer, your decimal floating point numbers are stored as binary and rarely have finite representations. If you simply want code that passes your test I would mention that it is much easier to remove padding from than it is to expand the scientific notation. 

Background I will first change some notation since I do not like that \$M \geq N\$. Let \$A\$ be the minimum number in the range to check and let \$B\$ be the maximum number in the range to check. The task is to return all Stepping Numbers inclusively between \$A\$ and \$B\$. Be careful when trying to find Big O of your algorithm. You assumed your algorithm was \$\mathcal{O}(n^2)\$ but you never defined what \$n\$ represents. If you let \$n= B - A + 1\$ and \$d = log_{10}\,B\$ then your algorithm is \$\mathcal{O}(nd)\$ since you must iterate through \$n\$ numbers and perform an operation on each of the \$d\$ digits (on average) of each number. General Advice This section is a mixture of coding style tips and finger-pointing at some sub-optimal code. Most of this advice will not end up in updated code section, but I think it will be useful to you. 

Updated Code This is much simpler code that uses some of the advice I gave above. In we are iterating from right-most digits to left-most digits because it is simpler and because it does not matter what end we start on when checking for Stepping Numbers. 

The reason that we do not handle zero being a Stepping Number is that appending a digit to zero does not result in a new unique number compared to what we already had. There are a few different relatively simple ways to include zero in the output if necessary. Note that I used more comments in this code than I normally would in an attempt to be make this post more instructional. I do not want you to be under the impression that you need to comment 50% of the code. I generally only comment lines that are not self-evident. Whatever that means depends on the context. As a final note, if you do not like recursion then you can generate all \$1\$-digit to \$d_B\$-digit Stepping Numbers instead. You would initialize with all 1-digit Stepping Numbers (except 0) and use to create higher-digit Stepping Numbers. The advantage is the code would be simpler (you could remove ) and a potential disadvantage is creating and filtering a larger list which could be slower. 

Now we no longer have any explicit loops (in the matlab code at least). This algorithm is much faster and simpler. Consequently, it is much easier to port to C. You will find that for , for your algorithm has dimension and for the simplified code I provided it has dimension . However, in your original algorithm, and are always the same if , hence you were performing one calculation too many. Now let us reincorporate the variable step factor. Realize that if we increase it is equivalent to taking every \$\textrm{tstep}^{th}\$ output after the cumulative sum. So if you want you perform the same three-line code above but at the end sample it via or in general . You can use to compare the outputs of your original approach to this approach. Remember that you one-padded your output so if you use \$\textrm{tstep} \gt 1\$, you need to remove the extra padding when comparing the matrices. Finally the last index of the non-padded output will differ as well (if \$\textrm{tstep} \gt 1\$) since your computation computes the last index differently than the rest of the indices. You can fix this by performing instead of simply however the latter approach is more consistent in my opinion. 

Your overall method of sorting the list would be good if the program called for finding the largest number in a list of size where and were unspecified beforehand. However, if we know (or can assume) that << then there is a faster method that just requires using more memory. It's often nice to think of how you would perform the task yourself in problems like this. If you had a stack of papers with number grades and needed to find the second highest grade would you sort all of the papers first or could you use your memory to help you solve the problem faster?