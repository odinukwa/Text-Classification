I would think some existing UPS units designed specifically for the pi would be a far better approach. Some can allow for additional battery for longer life. I think if I remember correct, some can initiate a shut down on low battery as well. On top of this, I found a nifty design idea for something that may work. Raspberry Pi UPS Quoted from this link is the part I want to convey here: 

Radioshack sells a VOM that has a serial port and a API to interact with the meter. You could get a "premade" device such as this if it has a customizable API. Then just code a pi interface to it. edit: requested link RadioShack 22-812 

The reasoning behind the JS popup is, those can trip up generally simplistic written brute force scripts. Then redirect the page to drop session and go to another page for added complication for any automated hack attempts. Additionally you could lock out all IPs but specific ones to allow connections: 

I tried Ubuntu 16 once, nothing worked well at all. Slow as you state, the packages that installed were not up to our project standards we have (example mysql was impossible to remote into). Various bugs elsewhere too. Symlinks failed to work correctly. Set a link and it was like running down a tunnel that wrapped back on itself. So far Raspbian runs very smooth and impressed with it's performance as a dev and server platform. I doubt Ubuntu 16 has the needed kernel compiles for the rpi. So it is bound to run horrible regardless unless you compile it yourself and find everything you need. That said, in short, you are not alone and that performance is normally experienced by many. However, I would seriously avoid clocking it up to boost performance on an OS that is not very compatible with it. You will be looking to replace it sooner than later. 

Effectively you would power a small router or something that provides a external connection (from the same power source) that can cause a drop in LAN connectivity on the pi if it is shut off. It would have to be something that has a lower tolerance for power drops than the pi so it shuts off first. Then on the pi you have it ping that LAN and if it does not show connected it does a 'shutdown now' Granted this would reduce battery life considerably, but it is a non-GPIO/hack to achieve what you are looking for. 

As I pointed out in the comments, inserting an empty SD card into a Raspberry Pi and trying to access that SD card via USB or LAN from a different computer is not going to work. The Raspberry Pi is a computer of its own and you wouldn't be able to access a hard drive in a regular computer with no operating system either. What you'll have to do is set up the SD card befort inserting it into a Raspberry Pi. There are several ways of setting up a Raspberry Pi SD card, but all of them start with inserting the SD card into a computer using a SD card reader (many notebooks have them built in). That way, you'll be able to access the card like a regular flash drive. Once you have access to the SD card, the easiest way to start is by downloading NOOBS and putting it on your SD card (you can follow this tutorial by the official Raspberry Pi Foundation). Once you have done this, you can insert the SD card into your Raspberry Pi and start it for the first time (if you use NOOBS, you need to attatch a display). To access it remotely (e.g. from a different computer in the same network), you can use SSH (following this tutorial, again provided by the official Raspberry Pi Foundation). 

The PiTFT does not use all GPIO pins, the 40 pin connector is merely for physical stability and ease of use. Some PiTFTs even have another 40 pin GPIO connector in order to easily allow for more GPIO peripherals. You might want to get one of those. Using DSI instead of the GPIO would be hard, as you would have to write your own drivers (and might need custom made driver boards as well). The Raspberry Pi Foundation allowed some insight on these issues when they introduced their 7" display. 

I had the same problem after I messed up my .xsession-script. Rebooting wouldn't help and username as well as password were correct. However, you can still access your Pi using SSH (e.g. using Putty on a Windows machine or on Linux/Mac OS X) and then retrace the steps that created that mess in the first place (most likely editing or in a way, that the command to be executed did not work or finished after a few seconds or is executed in the background). 

Beyond this, for brute force you could have a sql database logging connection attempts from the remote machine by IP and time stamp, blocking repeated attempts within a set time frame.. You would generate a sql entry based on these variables: 

A function that generates a sql log query if desired called loginlog() Then use some php to fire off the check: This is just an example.. 

The big thing to watch about any PSU you attempt to use for the RPI is the dead/no load voltage. As @goldilocks stated, I have seen a few PSU questions asked and I also think it is on topic (all-be-it loosely) to find the best PSU that won't fry our rpi. What you will want to do if you buy any PSU is leave the 5v end unplugged. Before plugging the PSU into the wall, connect a volt meter to the 5v side. If you have a volt meter that is quick to read and has a auto "hold" feature for the highest detected reading that would be best. Otherwise watch the meter and plug the PSU into the wall and look for a spike initially and a holding voltage that goes past the tolerances of the pi. Many wall unit PSU's will spike. Thereby fry or weaken your rpi. 

Have a look at htpasswd from apache: htpasswd The steps to create this can be quite confusing, but in the end you can lock out ANY endpoint url/directory on your server with a user/password prompt. Key notes from this link in case the link changes: 

Boot to recovery with a working internet connection. It should show in the list. If you don't have a internet connection on instal it seems to hang as the win install bits try to authorize your Microsoft account for the install. 

The only way a windows .exe will run on anything linux including the pi is through wine. I am not sure if there is a pi compile of wine as I would never try it. For a .jar these are java scripts. Again not sure if pi has a JRE (java runtime environment) as I would not have a reason to attempt or research this. The .dmg was already answered. You may want to look into linux basics guides and such on files and programs. Then look at specific platforms/architectures. The pi IS a linux box, but on arm not x86 intel. 

I don't know if you are looking for a surveillance software, but I have succeeded in installing and running , a software motion detector. You should have a look in the official guide. 

Maybe a startup script already exists on your file system (try or to find it), or on the Internet. Otherwise you will have to write your own (have a look here, or here) 

List the devices shared by your RPi. You should see the same device as in the forth step of the server part. Note the busid. 

Multi user chat (aka MUC) MUC are clients allowing you to join different rooms and chat with people you don't necessary know. A well known MUC client is IRC (not XMPP). Some web-based examples: 

I don't know the compatibility version chart between OpenSSH servers and clients, but I think that updating your OpenSSH client (from your desktop, laptop, or whatever) should resolve your problem. 

As short answer, what I can say from my experience is, as long as you do not use (free implementation of SMB/CIFS) or NTFS for the NAS part, that should be fine. Those two features are known to be CPU intensive and could be a bottleneck for the RPi. XBMC can run quite smoothly on a Pi. (the daemon client for the popular BitTorrent Transmission) has low CPU/RAM footprint as well. 

Obviously, the problem seems to be either the port forwarding configuration, or the ability for the SSH server/RPi to handle external connections. Port forwarding configuration Maybe you should try with a specific external port. Let's say 10022 (external port) forward to your RPi IP address, port 22. Then from an external IP address, try . If you have a message similar to this: 

I measured the power consumption of my WRT610N router with a Belkin Conserve Insight power monitor. The WRT610N has two antennas (2.4GHz and 5GHz), and I disabled one of them. To load the system, I used . 

If you manage to install one of them, please share your experience by asking and answering a new question. 

If you installed Raspbian via NOOBs you can access the NOOBs menue by holding the shift-key during start-up. In the menue, click on the -button in the top of the window. Select the -tab and add an separated by a space to the end of the line. After exiting NOOBs, your Raspberry should boot into an emergency-terminal from which you'd be able to change any script. 

This means: At 0x57 and 0x6f, the MCP79410 is listening for I2C communication. 0x57 leads to the EEPROM, a status register and a unique ID register whereas 0x6f is the address that leads to the RTC itself. In order to establish a connection, the line should be added to and the line to . After a reboot, the -command from above should return 

I was trying to set up a MCP79410 real time clock (RTC) and had to search quite a bit until I found a way to integrate the RTC's time signal into my Raspbian Jessie: Apparently, even there, some things changed over the last updates of Raspbian and there does not seem to be a huge crowd using this particular chip (as opposed to, e.g. the DS1307). I specifically wanted to connect a MCP79410 already hooked up to an ABS07 quartz crystal and a HU2032-LF battery to my Raspbbery Pi Model 3B running Raspbian Jessie 4.4.38-V7+ #938. The implementation should be as easy as possible and simply provide me with a correct system time even if the RPi is disconnected from the internet. 

In order to use the newly established connection to provide one's RPi with a time signal, one needs to comment out the lines 

from . Before the next step, one should make sure, one's system time is accurate (e.g. by comparing it to a radio controlled clock nearby). Now, one sends one's current system time to the RTC using the command 

If I understand it correctly, your PWM-frequency is 100Hz and your duty cycle is 20%. This would mean, that your LED is on for 1s/100*0.2 = 2ms and off for about 1s/100*0.8 = 8ms (and so on). Are you sure you can see that? Maybe you should start with 

I haven't try them, but you can try the following softwares. Single user chat Single user chats allow you to chat with one or more people that you have in your friend list. Some known clients are Pidgin, Gajim, or GTalk. Some web-based examples: 

The WRT610N power supply can provide 18W (12V * 1.5A), so it can manage the additional 2.5W consumed by the RPi. My RPi is powered by my WRT610N since one month, and I did not noticed any problem. 

As far as I know, there is no software that allows to block the network access for background processes. You can use AppArmor to block the Internet access for every software. You should be able to put every programs in a blacklist, and then put in the whitelist. But it will surely be painful! For the blacklist, you can use rules similar to this (you'll have to find every paths!): 

If you see a similar message, then the port forwarding configuration works well. Otherwise, you should tweak your router... SSH server configuration If none solution of the above worked, the problem is probably in the SSH server or RPi configuration. 

The logs make me think the startup script is not provided. To run , you have to provide such a script (in ). Make sure the file exists. 

GMediaRender should do the trick. It is a UPNP media renderer running as a daemon. I've once succeeded in installing and running this soft on my RPi. A couple of tutorials explain how to install it on a Pi. It is quite tricky, but possible. I think I have followed the first link. If you are brave enough, I suggest you to share your experience by answering your own question and explain step-by-step the procedure to install GMediaRender. 

Well, according to this reply from the ReadyMedia author (formerly known as miniDLNA), subtitles are not meant to be used through the DLNA protocol. I could see the subtitles on my LG TV because LG added some features to the DLNA protocol (that seems to be used by my Synology NAS though). The ReadyMedia author does not want to implement specific features as it may be incompatible with other clients. You can have a look to Universal Media Server. On the official website, it is mentioned the following: 

Why don't you use the one recommended on the product page of your LCD? That way you minimize the probability of further incompatibilities.. Update: The difference between the driver boards recommended by Mark Smith and me are their interfaces. TFP401 must be connected to the Raspberry Pi via HDMI and (!) USB, RA8875 needs a GPIO connection using the SPI interface. Furthermore, RA8875 cannot be stascked upon the Pi directly as the GPIO ports' layout is not the same. 

From now on, the RTC will keep the time and resynchronize the RPi's system time automatically on startup or manually by entering 

The should be something like - a kind of pointer to the physical USB drive. You can find out what to insert in your case by comparing the results of the terminal command before and after inserting the drive. 

Update: In Linux, mounting something works a little bit different from what is happening on Windows systems - at least from a user's perspective. The mount location (in your case ) is a directory (aka folder) like any other (e.g. or or ). Whenever you mount a device, the device's file system becomes inserted into that directory - and whenever you unmount said device, the (empty) directory stays behind. You can allways remount it to that location again - provided, the directory is still empty (meaning nothing inside and nothing mounted to it). 

Well, I had the same problem and had to find out that this question is a rather hard one. This blog entry introducing the official 7" RPi display explains some of the most important keywords involved (HDMI, DPI DSI, DBI). If your display needs to be a touch screen, than the first important aspect is, that (from my research) only displays connected via the DSI-port (J4) or GPIO will not need an additional data connection for relaying the touch input. If your display is connected via HDMI, then an additional connection (usually via USB) is needed (and will have to access the USB ports from outside if you do not want to solder around - this might conflict with your casing). You should be able to get this information easily. The next important aspect is, that displays using the GPIO ports usually need special drivers (either to be installed on a standard raspbian or delivered with a non-standard raspbian provided by the manufacturer of said display). This complicated things enormously, as those drivers might be documented badly or outdate fast - even the next update of your OS might render them useless - not to speak of difficulties using OSes that there is no driver for. You should be able to find the drivers and some customer feedback online. If you can't find the (correct) drivers or some support easily, then you will most likely have troubles using the displays once you bought them. Furthermore, displays using the GPIO ports usually need to provide an additional GPIO breakout in order for you to be able to use some of the GPIO ports for something else. This information should be obtainable by looking at pictures of the displays (is there a GPIO "outlet" somewhere on the screens backside?). TFT, LCD (or maybe even LED, oLED) are different technologies for displaying stuff. Although they determine the optical quality and power consumption, I personally would not worry about those too much. More important - at least in my opinion - is the touch technology, meaning resistive or capacitive. The former should be used with a stylus and usually can't take gestures ("multi-touch"), the latter is what modern smart phones use. And lastly, regarding compatibility with RPi3 (as opposed to RPi B+ for example), DSI and HDMI should always be fine and regarding GPIO I would go with the manufacturers information (as they are the ones, who provide the firmware/drivers). Hardwarewise, there shouldn't be a problem. To become a little bit more specific, the only DSI screen I found, was the official 7" one. It will work without any alteration to Raspbian (I don't know about other OSes). There are quite a lot of GPIO screens of which I would use the ones by known manufacturers sold through major outlets in order to avoid being stuck with bricks (At my department, we have several displays we can't use anymore, because they are cheap knock-offs whose firmware is nowhere to be found anymore.). And regarding HDMI: As HDMI as well as the touch device (whose information are being transmitted by USB) are standardized, there should not be a problem regarding any of the major OSes. I hope this answers most of question. If not, just clarify your question in the comments.