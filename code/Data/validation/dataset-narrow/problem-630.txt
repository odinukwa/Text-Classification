Though I do not generally advocate the use of , you could shorten some of your lines with it. (Especially the obscenely long ones.) 

First and foremost: while mutation may be generally frowned upon in F#, in some cases (like this one) it's acceptable to make a tradeoff of immutability vs. performance or maintainability. In this case, it serves both of those goals. Let's say you want to do this idiomatically, and you want to avoid directly mutating the array. It isn't that hard: 

A lot of times people post PHP here and it's often very ugly, this is not one of those times. Your classes and design are beautiful, and it's very obvious what your intentions are. You've built a good structure, and you've commented clearly. In fact, I saw this comment as was immediately impressed: 

And finally we find the appropriate method. All this boils down to the following: now when you want to transform a to an , you simple create a method. My main looks like the following: 

In the case where you're only piping to one other function, you should stay consistent with whether you inline the pipe or not: 

Now, you don't take any input in this programme at all. You just run it procedurally and exit. While this is great for dummy programme's that demonstrate a system, you should consider adding support for user input through arguments or the CLI. I'm not going to detail all that here, but I will say that taking input through the CLI is extremely easy. 

Why? The type is an - that means, it's capable of being automatically closed and deallocated. In the case of , IIRC there are unmanaged objects that need disposed, cleared and cleaned up before the connection is done. There are resources it uses that are not automatically freed. If you look at the API of , it has a method which indicates that it will disconnect from the database and free it's resources. This is important because if you forget the call, then your database connection will hang open. This has performance implications for your programme, database and network. So, we use construct for it which is a fancy way of writing: 

So it's a bit hinky if you're not sure why I did things. First: I have the parameterized constructor and the default constructor, which seem to contradict. I wanted the parameterized one so I can make absolutely sure to set the required properties for a setting when I instantiate them. The default one is for Entity Framework. Second: I have this which contains the default settings of the application. This is for two purposes: First: seeding. It allows me to easily seed the default settings of the application: 

Finally, we come to : Why is everything in this ? What happens if I want two variations with different seeds? You cannot do that with your implementation. Only mark things static that are universal states. That is, something that there is absolutely no reason to want to have different states for. In your case, does not meet that criteria. 

Generally, you should never have any fields (a field is written like the two items above, no etc.), you should always make fields a property instead. Just as well, should be renamed or another meaningful name. 

So I have an , which is responsible for providing an abstract base for other objects to inherit. (Like objects, which are people, objects, which are animals, etc.) The provides a solid foundation for and to interact with, I'm just curious if it's not gone overboard or if I've missed something. 

Never returns a non- value either. So I'm guessing the bits you left out are substantially important to understanding why you chose the form you did. Provided you don't need in the method, I would change the return result from to . Then rename it to . 

Perfect, so this has one responsibility. It's not the prettiest, but it will do. Next we have to implement this in our other method: 

The other advantage to this version is you'll always be sure that you have a valid object, no need to , which means we can make this generic for your other situations: 

The table has no indexes on it, apart from the PK. This is for SQL Server 2012. There are two records in , and almost 22k records in . When both filters are applied, both records in match , and ~17k records in are returned when the filter is applied. 

The first thing you should do is clean your code up. We should notice that is called no less than once, and no more than twice in the loop. We can fix that (quite easily). Next, we should notice that if we find a in our second loop, we can skip that many numbers ahead. Lastly, is bad practice. In Java you can subtract single-character literals. Instead of , let's do . The 48 becomes a magic number, and it's just as easy to subtract the instead. :) 

We can refactor with no issues. (This may not seem like a benefit, but it adds significant value to the code in the form of idiomatic code. It's much more clear what is going on with this example, than with your original code.) 

So I lied, I'm going to go into all the detail I had in my original answer, because I'm already at this point and I may as well finish up. My stress level is already maxed, so I can't give up now! Prior rambling aside, it's time to talk about what exactly is wrong with your benchmarks. I'm going to analyze this in a scientific manner. First, we have to ask a question, then do some research, create a hypothesis, formulate an experiment, analyze the results, construct a conclusion, and publish a result. You did some of this, but not all of it. Especially in the experiment. Question: can the built-in modulo be made any faster? Research: utilizing the mersenne prime identities, it is theoretically possible. Hypothesis: Mersenne prime factorization will be faster than the built-in modulo. Now we have the experiment, this is the really, really hard part. Benchmarking is hard, Eric Lippert taught me that. Though he didn't just teach me that, he taught me a lot more with such a simple response. He taught me what it takes to create a good benchmark, or at least a good enough benchmark. Now a good experiment has a control, and at least one independent variable, only one of which is modified at a time. We need to identify our independent variables, and that's somewhat difficult. You identified one of them: the algorithm, but there are 4 easily identifiable independent variables: 

So, first: there's no need to define in the method as a parameter. It's not used as such, instead it's used as a pre-fill so that you already have an array of the right size, but there are better ways to do that: 

One of the reports I am working on requires me to locate searches a customer makes, and graph them in certain manners. I have one query I'm particularly concerned about. This one takes the most amount of time (relative to the batch) and seems quite ugly to me. Essentially, this should graph the search results by the day of the week and give me: the total number of searches, the average searches per week day, the number of searches that had no returned results, and the percent of searches that have no results. 

I know this seems like an irrelevant suggestion, but simple changes like this can go a long way for future maintainability. 

The interface requires the method (ASP.NET Simple Membership). The F# portion has two modules: and . 

Alternate Implementation From what understand of the documentation, you should be able to get away with making this a lot simpler: 

No one has yet addressed the fact that you have chosen the wrong tool for the job. What does represent? It looks like you should have chosen an where you chose an . 

This is pretty self-explanatory, and it should make sense. The next step is directing the user to . This is where magic starts happening, and this is where we start making actual MVC decisions: 

Even then, is truly unnecessary. I'd bet there is a separator of some sort between commands in the string, which really shouldn't be a string, but should be something like the following: 

Do the cast immediately, but then filter out all non- items then cast. By doing it like this we eliminate the double-map, and do a single map to if and only if it is a . More interesting: we can add these two methods directly to the module just as if they were extension methods: 

I see you've included braces everywhere, which is very good. The only recommendation I would make here (which removes arrow-code in Visual Studio) is to omit braces around directives that are directly proceeded by other directives.