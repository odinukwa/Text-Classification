Basic algorithm Since you have very large files, you should consider streaming the file one line at a time instead of loading them all once; your program would use a lot less memory. You would also not have to copy your , which is very large! In order to know which files you've already processed, you could create a new file that holds a list of all the files you've processed and write to it as you stream from the original file. This is of course, assuming you want to keep the original file intact. I will continue under this assumption as the other case (simply delete from the list as items are processed) is simpler. Check the Notes section for a better idea that you can implement with inspiration from the following section. Implementation The following is a sample implementation for the algorithm I described in the previous section. For brevity's sake, I did not include the items mentioned under the Form section, nor did I include exception checking; I will leave those things for you to figure out. It is also most likely not as optimal as it should be, but it's merely meant to show you streaming. Sample 

That looks pretty good. You might consider using an enumerator and block to avoid the need to write: 

Here's a way that uses the method Array#sample and several class methods for reading and writing text files that are defined in the IO class. I have made the following assumptions: 

This alternate calculation of is not especially interesting in itself, but note that can be computed: 

's block is not used here because the key is not present in . The next value of the enumerator is now passed to the block: 

creates an array of separators that is passed as the argument in when the middle name or initial is to be included. Each element of that array is the (string) value of bracketed by a separator (except in one case where the initial is converted to (). For example, 

This shows that when determining the largest palindrome for numbers up to , it was only necessary to consider pairs with values greater than . Hence, at most pairs were examined, which is of all pairs of numbers up to . For , two palindromes were found before the search terminated. In each of the other four examples, only one palindrome (i.e., the largest) was found before the search terminated. 

3.2. Example 2 This example displays a more "real-world" use. Instead of having the function call , that would be done by threads consuming from the data member. Since this is an example, I've provided a simple function that works only for free functions; overloads can easily be added to deal with functors and member functions. 

To indicate that the first three files have been processed. You would then only have to check the first character of every line you read, instead of the whole file name, to know which files have been processed. This is the technique I would personally use, as it doesn't require an extra file and it keeps the original file mostly intact while providing a much faster comparison. 

2.2. function_traits.h These are simple template class specializations that provide the required function traits for the implementation of . I realize that specializations for and functions are required. 

Notes A faster way to check if a file has been processed would be to add a character indicating that it has been processed, for example: 

You can expand on this by providing functions that use the "Error hiding pattern". That is that they return a to indicate whether the input operation succeeded or not, while the result is stored in a reference parameter. Other isn't the only object that can be streamed from. For example, you can also stream from files. You should provide a way for users of your function to specify what they want to stream from (this can be as simple as having a parameter. 

Your first question was answered nicely by @sockmonk. You could have written , which, though longer, is arguably clearer. Regarding the second question, I suppose that's a matter of individual preference, but I am happy to use a ternary operator when it fits comfortably on one line. One reason is that it reads fasters than an clause or statement, as we humans have greater experience reading horizontally than vertically. @200_success makes an important point in his comment on the question. For the example he gave: 

Edit: In view of @Tokland's suggestion of constructing a set of prepositions when processing the words one at a time, I thought it might be interesting to run some benchmarks. You'll see that I just used random arrays and words, rather than read and write to files. 

I have formatted the numbers to make them easier to read and also added three statistics I thought might be of interest: 

I have assumed is not needed for some unspecified purpose. This is a way of achieving the desired result with a single pass through the array. 

Enter market on day 1 Now suppose we enter the market on day 1. We could compute a new net_gain array: 

Welcome to Code Review. This queue implementation is not truly concurrent-ready. Arbitrary initial capacity 

3. Sample usage Here's some sample usage to show how a user can get the return values. Basically, the user would send in their function/functor to the dispatcher and would take care of the rest; the dispatcher would return the from its submit-a-function function. 3.1. Example 1 This example is pretty much just a test of the template deduction rules and shows how you can use a collection to erase types. The main feature is that you can have a collection of functions that all have different signatures and return types. 

Consider what happens if returns value A, but before the expression is evaluated, is changed to some other value B. This could cause to say that the queue is empty when it isn't or that it isn't when it actually is. Conclusion These are two of many issues that are currently in your code. I've decided to stop here since that's a pretty bad problem. This current implementation if not safe at all. I recommend you do some more reading and learning about thread interaction. Good luck. 

To see where each search terminated, divide by , round up and subtract . For example, for , this would be: 

if is odd. If ball is fixed in is final position after reaarrangements, at offset of , it follows that either is odd and 

[Edit: I'm not happy with my solution after reflecting on it. Constructing the array is wasteful, as one can just maintain a running count, as others have done.] Here's a slightly different way of looking at it. Let be a car position, west to east. First compute an array , such that: 

If , or is entered as a string, rather than an array of strings, it is converted to an array containing itself. constructs an array of strings, one for each combination of strings taken from , and . 's arguments are as follows: 

We see that two of the are 's (), and one is the original number . The number of pairings is the lesser of the number of 's and the number of s. Here that is one. I will now go through the steps to determine the number of pairing in above for . To make it easier to follow, I will first sort (though the method neither requires to be sorted nor sorts it): 

What this means is that when the comparison fails, E is updated to the current value of X. If the comparison succeeds, X is updated with the value of N. Therefore, you don't need to update X again! That is the whole point of a compare/exchange operation; you're basically saying: "I was the last to modify X." Issue #1: Unsynchronized access to writer In your code, you perform a store to the atomic variable with a copy of a value you last obtained from the update performed in the compare/exchange operation, but this is not atomic. 

Why have you decided that the default size should be 100? Different people have different needs; having default values like this isn't a good idea because there is no true advantage to having a default size of 100. While this is subjective, I suggest you remove that default size and just have users be required to specify the size that they want. Compare/exchange confusion There seems to be a misunderstanding in regards to the use of compare/exchange. The compare/exchange operations work as follows: 

Specialization for special types You can also provide a way to read whole lines through template specialization or through a different function, since it would be useful for strings (reading a phrase, for example). More functionality You can provide a way to obtain values based on a predicate. So that it can be a lot easier for people to get valid values. For example, I want to get easy input of an integer that is between 0 and 10 from an user. Example 

The way I've displayed the error messages may not be what you want, but that would not be difficult to change. Note that, when a file name has an invalid format, I've listed all the reasons it is invalid. When matching a substring against a regex, notice that the length of the substring is checked by including start/end anchors and avoiding the use of , and . For validity checks that involve a list of possible values, I've made the list an array of the values from your hashes, as the keys did not appear to be used. If the keys are needed, those arrays could be replaced with hashes. A potential problem with this approach is that it's not very flexible. If, for example, a validity check were changed to involve something other than matching a list or a regex, it might be difficult to alter the code to accommodate it. I initially considered a different approach that offered greater flexibility. It retained the array of hashes, , possibly changed somewhat, but also had a module that looked something like this: 

Here is an example of test data with 8 4-character words, of which 3 are prepositions, and a sample size of 2. 

1. Description 1.1. Functionality The objective of these types is to provide type erasure for any function while maintaining the ability to provide a return value through a combination of and its associated . 1.2. Motivation This is useful for any sort of dispatch manager, a thread pool that you can submit tasks to being the actual target; where a task is any function with any parameters and return type. 2. Implementation 2.1. deferred_invoker.h This is the main functionality. Type erasure is provided through the base class, which simply has a virtual member function that is called when the function has to be invoked. The specializations will then know how to deal with the invocation and whether they have to save a result. They also take care of ensuring the correct initialization arguments required for the call are initialized and saved in a tuple. This applies for template parameter which is any function. A simple tag dispatch system takes care of return types. I've omitted a third implementation of for lambda and functor types to focus the review. It's basically the same style as the other two (possible design issue?), but it takes a copy of the lambda/functor and the arguments, instead of a pointer to the function. 

It can be inferred (and easily proved by induction) that after rearrangements, if ball has not yet been fixed in its final position, it will be at offset: 

A word about the regex (which I've used to avoid the need to ). looks for a string that contains one or more characters other than . is called a positive lookahead. It is not part of the match (which is why it is sometimes referred to as having "zero width"), but it requires that the match be followed by , where signifies the end-of-line. This strips off from the beginning of . To make it easier to remove leading zeros on trailing numbers, I've not included at the end of each subdir. (It can be added at the end if desired.) Next we execute 

There are two cases to consider, depending on whether is even or odd. The easier of the two is when it is odd. Suppose, for example, and , so and is odd. In this case the range can be divided into and . Let be the array that will hold the products. When calculating: 

Well, this is still not quite right. The calculation of is not correct, but it needs a fair bit of work to fix. I've therefore commented it out in . I also changed the name of the method because it's easily confused with the built-in methods for for strings and arrays. I'll leave it to you to fix the rest and of course others may offer additional suggestions. Alternative Solution Here is one way you could write the program more compactly. Code 

Imagine a first call to in thread A makes it inside the statement and gets stalled just before executing . Now another thread B calls and successfully gets past ; the writer now has a value different than reader because of the compare/exchange operation. However, the store of an element has not happened yet since thread A is still stalled. What is thread B going to pop? It's going to access whatever garbage memory is at that location. Issue #2: Malfunctioning empty function The load from and the load from followed by a comparison is not thread safe. 

I've actually implemented the same functionality in the past, so here are my comments. Wrong behaviour? It depends on what you can consider wrong. Consider running your own example and inputting . The 2nd will be left in the stream buffer and will be automatically assigned to your 2nd variable. This clearly causes weird behaviour, but it is the same behaviour that occurs when normally using . Suggestions The following are what I consider to be useful features for such an utility function. Better interface In order to provide a nicer interface, you could instead read a single value from your stream and then discard anything else that's been left in the stream buffer; calls to will always return one single value and successive calls won't be forced to take what's left in the stream buffer. Example