If you want the code in your to be called inside the method as well, simply encapsulate the code into a function of its own, and call the function from both methods. 

Where is the time since the last update. Now if we want to change the velocity with respect to time, we just need to add a line like this: 

If you want seamless looping animations, create your animations so that the start of the loop is the same pose as the end of the loop. Then when one loop ends, you can simply start playing the second loop without needing to make any changes. Alternatively, you can blend between the two animation poses. This is where you'll use your value. Spanning the amount of time defined in , use linear interpolation to blend between the last pose of the current animation and the first pose of the next animation. 

Yes, the loop is ideal for this. There are no special plug-ins required and you can do this with the free version. Basically you move the objects a tiny bit towards their destination each frame. When all those frames run one right after the other, it gives the appearance of smooth movement. A self contained script would look like the one I've created below. Ideally you'd take this as a starting point, and update it to use your own speed and starting point. 

Though I don't use 3DSMax or XNA, I would assume this issue is caused by the left and right wing not sharing a common parent. All the bones should be connected to a common root bone, since most applications (it seems XNA is included) don't support multiple skeletons per model. Place a bone down the center of your butterfly and make the left and right wing children of that bone. 

Yes, it's possible to do this. You can follow the documentation found under First Person Weapons. The definition of such an item would be created using information found in the Weapon System documentation. Overall, the steps are as follows: 

You have plenty of options, and it really just depends on what your style is and the design of your game. One of the easier ways to handle this is with a simple scene manager. The first thing you need for scene manager is a script that persists between scenes. This can be done with a method called . A very simple scene manager would look something like this (written in C#, because that's what I use, but it should be easy enough to convert): 

As far as I know, there's no way to manually trigger these events, and this strategy is far less of a work-around than manually triggering events. 

It doesn't particularly matter. As long as you're consistent throughout your game. I believe the more common approach is to have the world bounds centered around , meaning you'd have your bounds go from . Since most data structures that represent position (Vector2 or Vector3) default to zeros, you know that the default placement for objects is in the center of the world (instead of in the bottom corner). 

As I'm sure you found: would just wait forever, since is not getting updated during the wait. In your function, I'd store the action that's being set. Then, when entering your update loop, check to see if you're waiting for an action. If you are, check for a keypress. Something like: 

This could explain your issues. You're drawing your scene based on the position of your character. However, you're attempting to get the mouse coordinates based on the position of your camera. Try rendering like this: 

I tried out billboards a while back. I just created a quad that faced the camera. Using the position I want the object at and the up and right vectors (normalized) of the camera, you can set the four corners of the quad like so: 

Might as well learn it from Stanford right? The video lectures there are rather good for someone just starting out. You'll use Karol the Robot as your guide to learning to program. Once you get more comfortable with the higher level concepts you can dig into the source for Karol and learn how actually do the drawing and moving around. 

Basically you want to have a range around your camera. When chunks come into this range, you load/generate them. When chunks leave this range, you save/unload. Keep in mind you'll want to keep the loaded range larger than the visible range, so your chunk loading isn't seen. At the moment it looks like you're storing your chunks in a dictionary. That's kind of a strange choice, and it may be a little more work for you to maintain your chunks with that data structure. It looks like you've got a lot of the functions you need already, nice work. You'll want a list of chunk positions that should be loaded, your loaded list. Your update loop is going to maintain that list. As the camera moves, you update the list to include all the chunks in the range of the camera. This is where the dictionary choice is a little strange. Essentially you'd have to loop through all your dictionary entries, unload the chunks that aren't in your loaded list and load the ones that aren't in your dictionary but are in your loaded list. The alternative is to have some sort of linked list structure. Where you can add/remove chunks from either end. This does get a little tricky when dealing with 2D linked lists, but I think you can make it work. It would look something like this: Starting with this scenario, where the red dot is the camera, moving in the X plus direction. All the grid squares (chunks) touching the green area are currently loaded. 

This method will one of the most time intensive, but has the result of providing you with the most consistent verifiable results. You can also use the tiles you've created to automatically produce variations of the same map, altering your path to take different directions. 

I suppose you could have the server send a hash of it's executable to an authentication server, to ensure it hasn't been modified been modified, but that's about it. I wouldn't worry too much about it, if you're going to let players have their own servers let them do whatever they want with the game, they purchased it. You can make it difficult to cheat, but you can't stop players from cheating. Your job is to make a fun game that people want to play. Focus on that first. 

You need to store the random position outside the scope of your method. If the position is already set, use the set position, otherwise create a new one. 

You'll have a list of all players in the game. That list will contain player structures that contain whatever data about each player you may need, including their team. Yes, using a index for team is just fine. Or you can use a name, or reference a team object that contains more information about the team. A single list is fine. You don't need to do anything extravagant like dictionaries or multiple lists. This is a list that's not going to be more than 10 or 20 items. Iterating through the list to find teams or certain information is trivial. If you want to get more complicated for easier access, create an additional list of Team objects. Each team will have a unique identifier (like the index you have, or a name or color). Then, each team will also contain a list of references to the players that are part of that team. You can use something like where each player list is indexed by the team index. Or a where each object has a inside of its structure. There are lots of ways to do this. With such a small list, don't worry about performance. Just make it easy to use for the things you want to use it for. You don't have to separate the free-for-all and team modes. In free-for-all, just give each player their own team. 

There's two types of friction, static friction and kinetic friction. Static friction is the friction that needs to be overcome to get something moving from rest. You'll notice when pushing a box across the floor, it can often take more force to get it moving than to keep it moving. Or you'll be applying force and it will jolt forward and you'll have to not push as hard. That jolt forward is the point when static friction is overcome and you're dealing with kinetic friction. Kinetic friction is almost always (always?) less then static friction. Either way, friction is a force just like acceleration. It's calculated based on the normal force of the objects and coefficent of friction (Âµ). 

64bit does not only mean access to more memory, it also means larger word size. So larger instructions. I'm not sure why FlasCC requires it, but it clearly does (as shown in the minumum system requirements). I was able to run the demo on both x86 (32 bit) and x64 (64 bit) systems. So it appears the 64 bit is only required for the compiler. 

The precision should be precise enough to meet your requirements. Your requirements may allow for some missed updates now and then. Your requirements may allow only high-end hardware. It's up to you to find the balance between resource usage and precision. The precision will vary from genre to another, from one game to game and even from one game mode to the next. In this case, if you don't have any other problems with setting the precision at 30Hz, then set it at 30Hz. 

Blowing up the car when it takes too much damage is typically rated 3 funs above just slowing the car down. 

Though, you'll have to change some things with your code, because this will likely get reset as soon as the mouse moves or you update from the mouse position again. However, if you want more of a strafe action (facing forward and "side-stepping"), you'll want to find the vector that's perpendicular to your forward vector and move along that. 

I looked into the C++ port of Artemis. I was wrong about it being out of date, it's actually as recent as January of this year. It looks like the author is off to a good start. I would recommend picking up from what he's already done. It would be a great learning experience as Mike C said. If you take a look at the source for Artemis, you'll find that it's actually pretty small, and pretty simple. Just remember to give back to the community when you're done! I'm sure Arni Arent and Tiago Costa (creators of Artemis) would put up a link to your port on their website too. Good luck! 

Typically, systems operate one after the other. They process all the entities that match their requirements, then the next system does the same and so on. The data lives with the entity. There shouldn't be anything stored in the system, it's just a lock that gets turned, the key is where the information stays and moves from lock to lock. 

Pick one from each column to make a new gun name and type. This can make your job easier, but you would also have to ensure that it's a logical name that's produced. Additionally, it's really only the center column that is special, the other columns are just modifiers. But it does give the perception of a larger pool of names. 

To rotate it without leaving the gray box, pick the top or bottom left edge. If it's the top choose a rotation less than 90 degrees that rotates counter clockwise, if it's the bottom choose a rotation less than 90 degrees that rotates clockwise. Then rotate by the chosen rotate around the selected corner. This will essentially pivot the rectangle by a corner that's already on the edge, ensuring it doesn't rotate outside the grey rectangle. Unfortunately this option limits your choices a good deal. Moving it back inside the grey rectangle isn't too bad, and gives you a lot more flexibility. Essentially, you'll need to either find the bounds of the rectangle after rotation, or maintain the bounds through rotation. Maintaining the bounds would be something like keeping track of the points that make up the corners and rotating those points when you rotate the rectangle. Either way, you'll end up with the bounds of the rectangle, and then you can easily compare its edges to that of the grey rectangle. Allowing you to easily translate the rectangle by the difference. 

It's unclear what your rationale is for doing this. You might want to ask a new question about the problems you're running into that would inspire you to look for such a utility. There is a library called LightGL that attempts to do what you're asking. This is just a simulation of immediate mode, since true immediate mode is not supported. It's not really very close to immediate mode either, but it's likely as close as you're going to get. 

You can get specific information about the image clicked by accessing the associated with the you're drawing. Specifically the function. When you detect a click, find which image is being clicked on. Then you need to get the you created for that image. Finally, convert the click coordinates to image local coordinates and pass them into the function. You'd likely want to test the alpha component to see if it's below whatever threshold you define as "not part of the image". 

You can calculate the dynamically using the current speed of your entity and it's maximum acceleration with the following equation: 

I couldn't find anything offical, but it seems to be headed that way. The project is still somewhat active as far as the user base goes, as seen on the blog page. And there's still 1000+ downloads per week from the sourceforge site. However, the developer side of things looks much worse. The nightly builds, which were going fairly regularly (a least a few days a week an new release would be added), stopped back in March. It's likely it's abandoned by the developer or on track to be abandoned. 

This should be legal, but be careful where your music is coming from. If you're using sound samples provided by software you need to ensure it's OK to use those sound samples. There's something in music composition called Sampling. This is taking small bits of other music and re-using it in your own. The legal issues surrounding sampling are a grey area, wikipedia has this to say about it: 

Generate nodes as you do above. For each surface the node touches, collect its normal. Add all normals together. Scale resulting vector by appropriate scale (whatever the size of your AI unit is) Displace the navigation node by scaled vector. Check node to ensure no surfaces are within x distance, if surfaces found, remove node. This means that you're in a tight corridor that you can't fit a unit through.