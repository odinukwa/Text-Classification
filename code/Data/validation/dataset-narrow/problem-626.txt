But if you throw exceptions, be so nice and try to communicate what happened, if possible why and if possible how to fix it. 

This method can be made static because it does not require any state information from the owning class. 

Oh, and there is one more thing. will blow if you try to convert to that exceedes the . It'll also hide the fact that you can loose precision when converting incompatibile types. Consider this: 

I find you should split it either into multiple CSVs - one per player with his properties or a larger one with all player properties. The , and repeat for every properety set. Encapsulate them in a new class: 

As far as the block is concerned you don't need the variable. With LINQ can create the list inplace: 

you use the constraint to be able to create an instance of the generic argument that at the same time must implement the interface below that requires one method for searching: 

I already hear the voices saying oh no!, this is so slow!. Well, if you think that, then you can implement your own and that are aware of and don't have to iterate the entire collection. Then it'll be much faster but only if you have arrays with an insane number of items. 

in other places however you can use positive conditions (which are preferable because they are easier to understand) to further reduce nesting like where you check the : 

EmployeeFacade This class shouldn't be called like that because it's not a facade. It's more an . What is a Facade? 

Step 2 For each main switch create a class that implements the interface. Here's an example for two of them: 

Scoping : In your controllers are all your services default scoped. In mine humble oppinion make them private, if you wish to have the default scope make getters and setters default scope. Why: You easily can forget the private before a global variable but getters/setters are mostly autogenerated public so normally when these are not public it's ment to be. Final's : What is looking odd is that in you don't have the marked as final as you do that in your other controllers. Error handling : 

I was working on refactoring your code. When I was finished I saw that @tim already posted an answer. He address the most what I also wanted to point out, but in mine opinion he forget 1 thing. 

You are declaring this synchronised. So if 2 threads are calling this method, the second one has to wait until the first one is finished. Because you don't have an input variable, the output will always be the same, setting false. In this case there are no race conditions what could affect the outcome of this method, so I wouldn't make it synchronised. private static final : You are making a great use of the fields. What I'm not liking is the next step : 

You do not check if qc is null, what is possible when you get an exception. You have 2 options for this. 

It's clear that this String need's to hold todays day formatted. The thing what you could improve is making the static. Like this you don't have an instantiation each time you create an instantiation of the 

We start with that tab disabled. As the subscriber is created you can set the disabled to false and set the source of the include, so the tab will unlock. Another option, what I use in mine application is using the "visible" attribute. 

There is also a tremendous code duplication in your collection handling methods that should be addresed first. You can do it by implementing the collection operations in a new type, let's call it . In this type you put such methods as , , (old ) etc. Then you should get rid of the three events and replace them by implementing the same two intefaces and that the also implements. This way you'll have a nice new type that encapsulates the entire logic. 

So we can remove one null check and test only the description-attribute and turn it into a ternary operator: 

You should write more consistent exception messages. Currently the first one says why the exception occured, whereas the other one does not give any reason but instead it says what to do in order to avoid it in future. Giving a solution with the first message would be more useful. 

You need this flag because your function is doing to much. It violates the S (Single responsibility principle) in SOLID. It's not only resolving the elements but it's building the final result at the same time. The method should actually only return a with all the names (or other itmes) it found so that you can do what ever you need to do with it like: 

I'm not convinced by the index implementation. Since dictionaries don't have them, it should always be as not supported. In a context of dictionaries it's virtually meaningless as you cannot use it anyway. See: Interpreting NotifyCollectionChangedEventArgs 

I start the application from the where I initialize the processors and the (from ). Then I wait untill they all are done or cancel the one that might be either hanging or working with too much data at once. 

I'm looking at this class and I'm confused. The reason why is that I'm doing web programming so a dialog can be asked on different sessions. In that case this class is useless. In stead of holding your and in your class as static variable, just return them in the method. Then your 

Personally I wouldn't do this. The reason why is when your field change name, your test fails because the field is hardcoded there and with refactoring this isn't persisted to the test. What should I do? Normally your is in the same package as your . When this is correct you could use a protected method. Example : 

We all know what you are trying to do. But what happens if is magically turned 10? You have a bug that will not correct by himself. Let's say we do the following : 

Or something like that. Let the method return the actionlistener, but in the creation of your actionlistener use also at least 2-3 methods. Edit : Your problem : Use instead of with your eventlistener. looks for multiple button clicks, so it will merge some events. 

for the same result. Naming : While you have not many var's to call => I like that you already point to the bottle. Still I'm thinking could be a better var name. While loop : Well it doesn't make a big difference but for your own sake, use a for-loop. You don't forget to substract one then. 

This field could be because you set it in the constructor and there is no setter for setting this at a later point. LogFileFunctions.java Javadoc preffered 

The hurts the stack list. It would be much easier if you just added new items at the end of the list. The needs to rebuild the entire list: 

But how does it work now? The new methods allow us to define the order of movements. We have two. You can have more or them to start at different corners and various paths. We also need a starting point that lies outside the array because the first move will move it inside the array. We also check if we already visited a point that I track in a to know when to change the direction. You could have some other bounding checking but I thought a is an easy quick start. To know if a point is already in the I created a new comparer: 

To sort your you should be using data-binding and let WPF do the work. First let's fix the that you currently populate manually. For the sake of this review I assume you use your code-behind file as a data-source that is bound to the via: 

When building longer strings with lot's of concatenations use specialized methods or objects. Concatenating strings with the operator is the slowest possible way to create a string. The is such an object. Highly optimized for string creation. 

You're right about enumerating both parameters multiple times. Each call to or will execute the enumerator. This might of course become very inefficient, especially if your collections have a lot of items. So what could you do instead? Well, one option would be to replace with the next closest type which is the . This would guarantee that both collections are already materialized. This however is rarely a good solution so it's preferable to keep it lazy. But for this, simple LINQ is not enough. You need to work with enumerators directly and implement your extension in such a way that it uses the method. With it you have the complete control over the enumeration process. With a little bit of logic you can keep you parameters lazy and still be able to validate that the are more values then separators. You do this by first getting the first value. Then the will try to get a pair of separators and values to append them to the string. If at some point it could get a separator but not a value, it means that there is at least the same number of separators as values and at this point you can throw an exception. The other case is when there are not enough separators. To detect this you just need to try to get another value after the . If it works then it means there were not enough separators. 

Summary: While I'm no c++ coder, it looks for the rest good. If you really want to score high you could use recursion for the for-loop. 

So the result in the abstract class could be (You know what exactly the code does so make the names better for your cause): 

Method names do not start with a capital. starting with a capital is for classes. Fourth : You rely on users of your class that they close your connection. You will have memory leaks cause they will forget to close your connection. There are 2 possibilities what you can do. First : 

You are in a while loop so your loop will continue as long is bigger then 0. So I'm guessing you inserted that code for the last bottle. You just have to change : 

if - else if - else if ... When you see this, it's time to consider switch statements. I hope the is an enum, so you can refactor this to a switch. If it is a String, you need java 7 or higher to do switch on Strings. Code can be as followed : 

This is completely safe in your pojo, nobody could even acces the object. And outside the package no one will ever see this method. The advantage is when you refactor or the method name, your test is automatically updated. 

You can do it a little more generic but I'm afraid you still have to test each. I don't know if your case is always changing to green or not. If not I suggest the following enum : 

Default value of a is . Default value of a is . Take care, default of and is . Defensive programming 

You should use more meaningful variable names like and and your code could use some more LINQ and s. 

It might also be a good idea to move the code from the constructor into a new method like or so you can extend the dictionary later if necessary. Usually those dictionaries can learn new words. 

These methods are implemented in a very inconsitant way. Only one checks if the property exists in the dictionary, the other ones will crash. There's also a lot of repetition. The entire logic should be in only one getter/setter and the other overloads should call the main method. Lastly I think their names should be changed to because this is what they do. 

If we assume for a moment that a can be sorted the way you do it then it can be also achieved with a simple LINQ query: 

I think you can make it nice and clean(er) like this: Define an interface that you pass to the repository: 

Since it's a game and in games code usually should run pretty fast I'm rather sceptical about your bullet solution. 

I'm assuming the css does not require any vaidation because it's been created and validated with an editor like jsfiddle etc. The result of is 

It won't be any more complex then it already is and you'll be able to verify many parts of your application without having to click every button and hoping it won't crash. 

Naming Apart from the you should try to make you code more consistent. This means, don't use abbreviations like or . Use full words especially for parameters. 

Now you can store it and have a direct access to the which you can use to instantiate without regex and strings. 

Isn't it better to call them and ? It helps you when you are programming. Take in mind that you get this code and must find a little bug. You are getting a headache just by always thinking what and are Check for your own faults : 

It's hard to say but if I get this with an interview, you will not pass. On the other hand, I'll find it good you come to here to learn. Number 1 is really red flags. Let's start with the review. 1. No with logic. I removed the comment lines to point it out. 

The next class is the calculations itself. Because the UC is so little it stands open for interpretation like what do I have to do with all negatifs? In mine solution, an array of all negatifs shall work and spit out an array with 1 number. There is also no details to do when more subArrays are found with the same highest sum so I just return 1 of them. 

All over : Nice readable code, as an outstander, who doesn't know the things the other classes need to do I still understand what this class has to do. 

A bigger problem here is that you don't log the . It vanish in thin air cause you don't use the in the catch. Succes with finding the problem at that time. 

Now you have a more generic method that can sort, even more entries in the map is no problem. Hope you have something from this review. 

Code should be self explaining, so if you need to put comment behind a variable name to explain it, there is something wrong. Mine suggestion is :