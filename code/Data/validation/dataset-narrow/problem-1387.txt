As Luther already wrote, it's how the flash renderer works. One thing that will guarantee pixel-accuracy is to turn your sprites into bitmaps and then set the pixelSnapping property to . Or try on your vector sprites (see here). 

When you separate armor and health, you not only add the option of getting more effective health-points, it also adds a new mechanic to work with. In a shooter game like Unreal-Tournament, you would have ubiquitous health-pickups which heal for 20 points of health and your health is capped at 100. When you're at 100 health, the health-pickups become useless. But, you can effectively double your health by getting armor/shield powerups. It's clear that this adds more variation and requires some more strategy by the player to keep health and armor at the highest level possible. It also gives map-designers more options to play with. If I recall correctly, armor was scarce in Unreal Tournament and also placed well hidden (hard to reach, you needed to go to areas outside of your usual walking path) or at very exposed areas where you risked to get gunned down before reaching it. So some map designers used it has high-skill/high-reward powerup. It's obvious that this only works with two types of power-ups (health alone wouldn't add this layer of complexity). So armor isn't just health 2.0. It's a new resource which can be used for more variations in level-design and creates new gameplay strategies. 

Some other thing to consider is the coarseness of your mesh. If you have really small triangles (compared to the "feet" of your character), you might get unwanted results if you just consider a single triangle and its normal. Instead you might want to average the normals of several triangles and use that for your calculation. 

You can check all the layer-pairs that should report collisions there. In the screenshot you can see that Bullets will only collide with Enemies and Enemies also collide with the Player. Then all that's left to do is assign the matching layers to your GameObjects or Prefabs. Using the collision matrix is the best approach, because it directly affects the physics simulation (non-colliding layers don't have to be checked for collisions at all) which is the most performant solution to your problem. Another approach (or you could also combine the two) is to implement or on the Enemies and Players, and not the Bullet. Then you're free to implement different behavior for each entity and also report scores or perform other tasks. Bullets could also use 

Usually you'll just create one scheduler that calls the method of your world/game. There you iterate through all entities/sprites and call their update method. This gives you much better control about the flow of your code. You'll be able to run the physics-simulation first and then iterate through all bodies/sprites and update their position. Having all entities within a data-structure also gives you greater control about when/how entities will be added and removed from updates as well as better means of debugging (scheduled updates can be cumbersome to debug if you have lots of sprites). 

You're not working with bitmaps here. The object you're using uses vector graphics. So basically you're painting a lot of rectangles to your mask... The only reasonable way to determine whether or not your mask is entirely filled would be to render it to a (using ) and then iterate through the pixels until you hit a transparent one. In that case your mask still contains transparent parts. If you checked all pixels without hitting a transparent pixel, your mask is completely filled. This seems overly complicated though. I'd work on a Bitmap right from the start (eg. your "dirty" layer is a bitmap on top of your clean MovieClip. Then you actually erase the dirty pixels instead of using a mask. Update: I did a quick test of the Bitmap based approach. Here's the result (there's an indicator circle that always jumps to the first non-transparent pixel. Otherwise it would be too difficult to find all the pixels). And here's the source-code. 

The easiest way is probably to just export the model in a direct3d compatible format? Or convert the existing file. If you really want to use the OGRE mesh format and load that outside of OGRE, your best bet would be to write your own deserializer. You could use the MeshSerializer as a starting-point. 

Instead of checking the corners of your sprite, I suggest you check the midpoints. Like in this image: 

It depends on the game. In most cases you'll be fine with just some simple shapes that average the sprite over all animation frames. Something as shown here (image from Ray Wenderlichs/Andreas Loews MonkeyJump tutorial) : 

What you speak of is called "unwrapping". This is the process of generating UV coordinates for your mesh, so that it will allow UV mapping. UV coordinates are in the range of , where is the top left of the texture and is the bottom right of the texture. The process of unwrapping a 3D mesh to a 2D surface is something tricky. Imagine a cube. In order to unwrap it, you would have to cut/separate some of the edges, as shown in the following image (from Wikipedia): 

I think it's a good design to encapsulate functionality within a given class. The ball knows about ball-related stuff, while bricks mind the brick-related business... Your problems seems to be how these components communicate and how you can easily add new features. The best way (architecture-wise) is to have very generic components that are as loosely coupled as possible. A good architecture would be components. For a simple game like Breakout, a component based architecture might be overkill. Instead, you could do something like this: Game: (or Level?) keeps track of all entities and performs the method on all of them. CollisionManager: Detects collisions and notifies bodies/entities that were part of the collision. You could do this by implementing a messaging system or by invoking a method like on the entities. Ball: has velocity and direction and updates its position. For greater flexibility, you could make the Ball a state-machine, so you could easily implement different behaviors as different states. This could come in handy for behaviors of power-ups. Brick: Could also be implemented using a state-machine to implement different brick-states. Probably the biggest gain for your game would be some kind of messaging. The Brick could send a message when it gets destroyed (eg. hit by the ball). The score-manager could listen to that message and update the score accordingly. The message could also trigger a power-up to appear randomly etc. The benefit of having a messaging-system (or a similar pattern like "signal and slots" or the observer-pattern) is that you can have loosely coupled components that communicate with each other. So you can easily add more components later on by having them listen to messages and perform some tasks. Imagine you got the messaging system in place as described above and your Brick sends out a message when it gets destroyed. Listeners will make sure the score is being updated and there's a random chance that a power-up will appear. Now you could simply add another listener for that message that will play a special sound whenever that brick gets destroyed... 

So 1 unit = 1 meter. Don't use pixels for your physic engine. Your world should be decoupled from the actual rendering output (which is in pixels) 

Personally I wouldn't use double to store sprite coordinates. Since you have a fixed grid, why not simply use grid coordinates? Double would probably work, but is more complicated and you'll suddenly end up with rounding errors or equality check problems. Using grid coordinates, your sprite would be located at: and . You can then calculate the actual screen coordinates by multiplying with the grid-cell size. Animation is a special case, but I guess you'll move the sprites from one grid-position to another one, so you can calculate the initial position in pixels (screen space) and the target position (also in screen space) and animate from one position to the other. 128x128 is probably a bit large for a sprite.. I guess 64x64 is still sufficient. But it really depends on how big you want to scale these sprites. 64x64 will result in a 640x512 grid. 

You should make use of the property of your platforms (AS3 docs). So first make the children the hitArea of your platforms, like so: 

To connect the GameGui to the GameClock, you would do the following (maybe in your game start-up method) 

To combine multiple sprite-sheets you'll have to revert to a method like jhocking describes in his post (eg. combine the images and make sure coordinates in the XML files are being updated accordingly). That's a suboptimal way to go about it though. Instead of exporting several sprite sheets, why not export just one? Texture-Packer is a really great tool for this. You can simply create a folder, export all your sprites there (eg. animations as image-sequence) and drag the folder into texture-packer. The tool will combine all the images from that folder into a sprite-sheet and even auto-detect new images when you add them. When it comes to special sprite-sheets such as fonts, you usually have to resort to other methods. In case of the starling framework, this is a non-issue though. You can pack your font-bitmap (the whole sheet) into a sprite-sheet like any other sprite. Then in starling you do something like this: 

Since you already started learning, why not go ahead and try to implement something? Maybe start with a simpler game-concept (like Tic-Tac-Toe) to get a grip of all the things involved (code, graphics, sound, etc.). Then post more specific questions here as you move along. Since your question is a bit "broad" to say the least. 

Creating a new instance of would return a BitmapAsset instance, which is a subclass of . Using the Flash IDE, you would simply import the image to your library and then export it for ActionScript, as shown in the following screenshot: 

Moving the cursor should not create a sound. What you probably mean are sound effects that are being played whenever the cursor hovers over an important area (clickable elements within the game). You're right, the sound effect should be really subtle. I think you'll get the best results if you search for button rollover or blip sound-effects. Here's an example of what I would consider a suitable sound (it could be toned down even more). 

You want your game-world to consist of several "chunks", so that you can add/remove elements to your scene when necessary. Some games use chunks the size of one screen, so you'll always see 4 of these chunks at the max. The most flexible way for this kind of game though, is to use a tilemap. You can create those maps by using an existing editor, like Tiled or Ogmo Editor. For the scrolling, you'll need some sort of "2D camera" that moves around with your character and defines the visible portion of your screen. You can also apply some drag to the camera, so that it follows the character with a delay. To add the illusion of depth, you can create one or multiple background layers that move with a fraction of the camera speed (parallax scrolling). All this stuff is already present in game engines like flixel or flashpunk so it might be worthwhile to check these out if you want to start create the game right away. If you want to implement that stuff all by yourself for learning purposes, that's fine too. 

But this might not solve your problem at all, since the way is increased entirely depends on when and where you call that code. 

Tiled is very well suited for a platformer. But it really depends on how you design your tiles. Usually you'll have small tiles that are repeatable and form your landscape. Special corner- and edge-tiles can be used for a better look. Here's an example of such a sprite-sheet. If you'd like to position sprites freely (eg. you're not working with tiles), I can recommend an editor like GLEED2D. The editor writes to XML files, but these can easily be changed to something else by using XSLT or some other way of processing the XML data. 

I think your main problem here is that you continuously allocate new memory. Instead of creating small buffers for each pixel you want to read, why not create a buffer from all the image pixels and the read directly from there? Here's how I would modify your code. Disclaimer: I've never used WPF before, so take this with a grain of salt. I don't know how the pixel data is ordered in the array etc. 

You can then read this in and split by space/newline to get an array. Another option is using an editor like Tiled or OgmoEditor which can both save to an XML format you can read and parse within Java. You should be able to read files using J2ME too. 

Let my explain, why you should definitely add your results as a separate relation-table and why having a string of IDs inside the user table is "wrong": First of all, try to look at the database as a separate sub-system. The sub-system should be self-contained. So if you have a table and and there's a relation between the two (eg. user have multiple or one results per quiz), then this should be reflected in your database design. Why? Most importantly, it allows you to work with the Database outside of your application code. If you leave it up to your application to make the relation between and , then you're severely limiting the usefulness of the database itself. You won't be able to use any other tool (eg. directly querying your database for these relations) without re-implementing or re-applying that logic you used in your application. Having your stored in the table can also limit performance if you have to implement DB locking (which might be necessary with lots of concurrent users). Also be aware that you're about to perform premature optimization. Databases are already heavily optimized and can handle thousands and millions of rows. Without identifying the database as a bottle-neck, there's no reason to deviate from good practice. I highly doubt that querying the user table, splitting the IDs to an array and then querying the table with these IDs individually is going to be any faster than what the DB would do for you with some simple statements. If you're interested in the topic, you might want to read up on Database normalization. There's another candidate in your design that might be off, which is the column in your table. I suspect that this is a running total of all result scores? If yes, you should get that with a query from your results instead: