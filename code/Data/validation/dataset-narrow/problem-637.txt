This method should have been called , which makes it the constructor for the class and is called automatically every time a new is instantiated. Have a read on the RAII principle. 

It is unfortunately still necessary to store the entire input in memory, in order to count the elements. If it wasn't for that, you could just copy from input to output element wise. But what's important: The data structure used is now a plain vector, which removes a lot of unnecessary stress on the memory system, as the storage method is a compact as it gets. There are also no mutations to that data structure at all, it only serves to replay the input after counting all elements. 

I probably wouldn't use the old and classes, their interface predates the introduction of generics in 1.5, and as you noticed isn't even type safe yet. 

In every single location in your codebase where you need to handle either 2D coordinates, or 2D bounding boxes, you always chose to store each single component in an individual variable. Why? But you didn't just duplicate the pattern of storing the components individually, you also typed the bounding box tests over an over again manually. It's so simple to solve that, just group 2D coordinates into a object, and bounding boxes into object. The class should also contain the commonly used methods for test for with collisions, and in inclusions. 

That pattern of is better written as a chain of . The query optimizer of your database already did that internally as well, but it chose the wrong order for the join, resulting in overly large temporary result sets. Especially when joining straight on without applying the more selective filter by first. 

This isn't even valid reverse polish notation, with the 3rd term which includes both an operator and an operand. And yet your implementation did happily process this, including the resulting side effects. 

Neither of them have the correct signature for a copy assignment. The correct signature for that operator is . That already rules out abusing the return value to signal success or failure. If you want runtime errors, you got to do it with exceptions. If you violate that signature, it makes common patterns such as chained assignment () impossible. This may break other templated libraries depending on your datatypes to adhere to the standards. Especially returning a may cause rather unexpected side effects. 

That function shouldn't need to know how to traverse a tree. That functionality belongs to , not to the invoking site. A simple is much cleaner in this context. The complexity of building and traversing the tree should be hidden entirely hidden inside the class: 

If this is actually supposed to be C#, the whole script you posted should actually have wrapped in a regular C# class: 

I would expect that your students will mostly just reverse both lists, traverse in lockstep and identify the last common node that way. Students have a tendency to trade algebra for brute force, if possible. Smarter students will just read the length of both lists, skip the length difference, and then walk in lockstep until they find the common element. Which then also would fit better within the space complexity requirements, and requires no manipulation of the lists. 

This already guaranteed you that there can only be a single holding media object attached to each post, by design. Drop either of the relations. In a relational database, you want either a forward, or a reverse reference, but never both. Double linkage in a relational database is in fact not even possible once you start enforcing constraints. Not to mention that it is very easy to create an incoherent state, by inserting sets where the reversed relation points to the wrong row. I get that you want to express ownership of in order to be able to collect orphans, but that's not the way to do that. Let's just assume that double linkage itself isn't horribly bad, even then remains a bad idea. Why would you enforce an in , when you only know that multiplicity constraint for and ? Just drop that , and model the multiplicity solely via . If you want to reliably clear out orphaned media, just write yourself a little garbage collector for that purpose, in that case you can even safely drop that all together. Finding media which isn't referenced by any other model should be quite easy. 

These two have a rather strange signature for what they are called. Your task was to create an class which manages an inventory. No less, no more. What you actually did, was cramming all the input and output logic into that class as well. That's a direct violation of the Separation of Concerns principle. What that part of the API should look like is simple: 

Still rather comprehensible, isn't it? Unfortunately, the drawback of using and references is that updating the database just got slightly more complicated. It's generally better to just use a index which can be sorted by. So best drop and again, and instead just add an field which contains a unique number for each entry. You can then just fetch the rows in the correct order from the database, and the previous algorithm already yields the children in the correct order. (Bonus round: Ensure that is not only ascending for all children of a single node, but also when traversing the tree in pre-order. Now the previous algorithm can be modified to traverse the result set from the database only a single time, treating it as a queue which only supports the and functions. If you got that working, congratulations. Your algorithm has just reached runtime.) 

If by design, only links to media holding images, why would you not write this as a single query instead? 

You should revise on the API design on your service. You now have the odd situation where the needs to be aware of , while on the other side the controlling sites need to be aware of . This is a rather unfortunate situation, since you now created a dependency chain from via to . This means a can't exist, without existing in the same application. The solution to break this chain, is to make instead aware of , respectively define a generic interface in the package of which allows other components to register with this service. Now both the and the can exist and access the without the other component being part of the same application. As a side effect, this also solves the case where wants to observes the currently set brightness as well. 

These methods shouldn't contain any input/output logic, but only the algorithms relevant to storing products, respectively to query all stored products for the grand total. The input/output belongs into the scope working with the instance, not into that class. 

Eventually you will end up with a newline following the closing code tag (be it the IDE or the VCS software being "smart"). This will add to the output, resulting in an invalid response. Avoid using the closing code tag if there isn't any content following. This actually applies to all PHP files. 

Now it's both clear what each symbol means when occurring in the code base, and there is now only a single location which needs to be changed when you want to change the symbols. 

And because it was so nice, we do it again, but this time we prevent the user from terminating the application. 

So much for fixing the inner select. But as a matter of fact, now we don't even need to do it as a subquery any more, but can just handle if as a with and on the outmost query. Whether this actually gains any performance needs to be tested. 

Why did you assume that only will ever want to observe the brightness value? As your code hints, you will possibly have not only multiple maps at one point, but also multiple points from which the brightness could be controlled. Which in return would also want to register with that service to update their displayed state in case of external control. 

OOP is not only about how you encapsulate data and functions into objects - it's also about defining how objects interact with each other. Let's pick the object as an example. As you use it, it's just a container, but not exactly object oriented. This line actually characterizes it well: 

What is this line supposed to do? That should have been directly computed into and , so this line is obsolete. 

It does mean that, and your implementation using the to provide sufficient allocated space appears to be valid. Almost at least, because your implementation of is not checking types. So if a type is accidentally passed which wasn't covered within , respectively requires more allocated space, it is going to corrupt the memory. 

All of these names are actually rather difficult to read. Why? Because chaining words without gaps doesn't work all to well. You should make use of a naming convention which clearly separates the individual words forming an identifier. The two usual conventions for that are and , with the former one being commonly used in C# or Java, and the latter one being typical in C and C++. 

Why did you make these private? They should have been public with default values - just as all the others. 

How to capture exceptions correctly? You only capture and swallow an exception ever, if you know that you can safely recover. That means e.g. in the case of operations chained in LINQ style, you wrap no less than the whole chain into a clause. The exception is supposed to interrupt the execution of the chain, to avoid undefined behavior. And if the behavior of the surrounding scope still isn't in and can't be brought into a defined state in case of an exception, you let it bubble. As long until you can restore a sound state. 

This is somewhat pointless in Javascript, it's a double precision float anyway. Unless you have a good reason to specifically use deciseconds, just stick with the established standard of using seconds as the unit for all time stamps. 

That's a global variable you created here. Unless you have a very good reason to do so (and trust me when I say you almost never have), don't. You should have instantiated inside the function instead. 

At this point you can do away with the "timed" stuff as well. You no longer need it. You can now also replace your by the simpler . In fact, neither do you need the 2nd mutex either: 

Why is this a horrible idea? Because you just successfully eliminated the function the exceptions had originally: Error handling. The premise when using LINQ like notations, is that you have a valid set of data in a fixed formate at each step of execution. By intercepting the exception too early, and mangling it into the same format as a valid output, you are breaking with that premise. Instead of the valid input, you are now passing the error message down to subsequent operations. With no way to distinguish the error case from a valid result.