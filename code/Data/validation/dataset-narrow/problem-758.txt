Of the two, the dictionary is the best option, because the keys are stored in a hash table, and you can look up items in O(1), whereas in the list you have to transverse the whole thing until you find it, so it is O(N). Now, note that your dictionary implementation is a very thin layer on top of a dict. I would recommend inheriting from . If you are bound to the specific interface (, ) instead of the and , you can just create aliases. This can help you reduce the amount of code and also give you easier access to all the expresiveness of Python dicts. Note that the third method is broken. In particular: 

You can use the slightly shorter instead of . You can also move trailing lambda arguments out of parentheses: 

And you can even pre-compute the required capacity to avoid unnecessary array copying while building the string: 

Using returns a new object but such isn't necessary in this case. You can use directly on the . You can reduce duplicated code by using classes and/or extension functions. e.g.: 

Kotlin already guarantees that and are not as you've used for their type instead of . As such, the statements are unnecessary. I do not believe you gain much from and . and read clearly and are read in constant time so the additional variables seem unnecessary to me. You can place the last lambda argument in a function call into parentheses as you have done but I personally find moving it out of the parentheses easier to read and more idiomatic: 

I make use of an NChooseK function so we can determine how large the string[] needs to be to hold the results from the subproblems which will be carried out at the next level down in recursion. Full Code with Timing Code 

There's a better way If there are 5 balls and 3 buckets, but each bucket must contain at least 1 ball, imagine the following set of balls: 

I think it is worth mentioning that for large data a different approach could be used, since keeping exact frequency counts of words is too time consuming. Streaming Algorithms like "Count Sketch" makes a single pass over the data, uses low amount of space, and based on the amount of space you allocate to it, can guarantee to get the Maximum Frequency Word with say 99% probability. Algorithms like these are used every day in routers to approximate which IP addresses are requested the most frequently, given that routers do not have enough memory to store everything it sees and only sees each IP address once. For large data, I would recommend this approach. Not sure if 10 GB of text counts as big data for this problem though, however if every word in the file was unique (except one word which occurs twice), you probably don't want to try storing them all in a Dictionary :p. As an aside, Multi-threading may be able to help give a speed-up, although pulling data from a single .txt file seems intrinsically IO bound. It seems possible to pre-partition the .txt file into parts for each thread to process independently, using "unsafe" code with pointers directly at the partition locations in memory, and writing the line parsing yourself from the bit representations of chars. I doubt the above would be worth doing in C#, since you might as well manage memory as well using C or another low-level language for that extra gain in speed-up. Multiple threads would exhibit higher speed-ups on certain processors like the intel i7 which has 3 channels to memory, and this is a highly IO dependent task. If it happened to be hundreds of thousands of 10 GB .txt files across a cluster of computers, I would consider using an approach utilizing MapReduce on a distributed file system. 

In some languages variable names like are common and expected but in Kotlin (and Java) I find it more common and expected to have variables names avoid abbreviations, use camel casing, etc. I recommend using instead of . You are returning a . This is fine but data classes are so much better and Kotlin makes it so easy to define and use them. I recommend creating your own type to return. e.g.: 

You might want to take a look at Delegates.observable - stdlib - Kotlin Programming Language which you may be able to reuse to improve and reduce your code. 

"args" is more common and descriptive than "a" in a function signature "\n" is system-dependent; I recommend using instead can be used with a instead of first mapping an using a and then calling . e.g.: 

This includes timing code which runs the algorithm enough times to take longer than a full second, then divides by the number of iterations so you can get an average time elapsed (also it subtracts the average amount of time it took to loop that many times). On my computer this computes 16 buckets and 24 balls in an average 2,278 milliseconds. (Of course, printing the solution to the console takes a lot longer) Other Optimizations/Changes 

Rather than moving the balls around, we can move buckets. That is, I will mark 3 balls with an 'x' and that ball and the balls to the left of it (until the next 'x') are part of the bucket, (since all balls are in a bucket, the right-most ball must be marked. So we get: 

If however you actually need/want classes for tree components then I recommend making those components (or collections of those components) members of a class (e.g. a has ). 

You can still use a enum if you'd like but this function is very similar to so would seem to suffice. Every enum class has a function implementing (Enum Classes - Kotlin Programming Language). As such, would declare both and which seems confusing to me. I suggest defining superior and inferior check functions instead of but this may not be practical depending on how you are using : 

Unfortunately this can sometimes look a bit strange using , etc. but in Kotlin 1.1 you can use bound callable references: 

It seems your code needs Windows to run, so I cannot execute it myself. jonrsharpe has done a pretty thorough analysis. Some complements: Creating strings In here: 

First thing, you should use new-style classes, inheriting from . (Not necessary if you are in Python3, but convenient for backwards compatibility). So, in short, your choices are: 

Also, you need more comments explaining the flow. Give a literary overview of what is going on there. There are never too many comments. 

You are returning irx, but that may not be defined if is longer than 5 or empty. Also, you don't need to store it, you can just return it: 

To make this run faster, use memoization for the function getCombinationsRecursive(). Use BigInteger in the NChooseK instead of longs to support larger numbers, but then you will also need to use something other than string[] for the results for very large instances. Use parallelism if you don't care about the order in which the results get written (although as it stands, that could be difficult with this implementation). Write the results right to left by appending instead of putting the new values in front of the subResults. Completely change the algorithm to do a depth-first search over the possibilities instead of a breadth first search, that way each result could be written one at a time, instead of needing to store it all back out of the recursion. 

Using as a function name seems very ambiguous. The method name used in the Java class from LeetCode seems more appropriate: (thereby specifying that the arguments, although not numbers themselves, represent numbers). You can remove the explicit type specification for if you add explicit type arguments to . I personally find this more readable and less verbose: 

In my opinion, the main factor in preventing you from having a clean primary constructor is indeed the two paths to the super class (via or ) and having a super class define the property is in fact what also prevents you from making this a data class. I recommend making an or with no properties in its constructor. e.g.: