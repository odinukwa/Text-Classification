It's possible to perform the operation in fewer calculations, if you are concerned about (or interested in) those sorts of things. For example, one (potential) technique for doing so is discussed here. 

Generally this is done by loading animation data (built in a modelling/animation program like Maya) along with your model and reading the transformation and rotational data for each bone in a rig from there. This is commonly called skeletal animation. Instead of loading the data from pre-baked animation files, you can adjust the bones procedurally (this would be referred to as procedural animation). Doing this well for very human-like behaviors such as walking, running, and jumping is an ongoing area of research. There isn't a set of simple equations that you can apply to your bones to get even vaguely realistic motion out of them. Most procedural animation pipelines end up being an exercise in fiddling with a lot of little variables in order to achieve a desired result. You can probably find engines that support full or semi-procedural animation (the Fabric engine claims to), or procedural animation suites that integrate into modelling packages like Maya. There are also papers on the ACM and IEEE sites dealing with the subject, although they are behind membership paywalls so I can't link them directly. The state of the art (as it is appropriate for and applicable to real-time simulations, like games) is not very great -- 100% procedural animation often looks a bit mechanical. Now, this isn't to say that procedural animations are of no use; often they are combined with pre-cooked animations, for example by using inverse kinematics to allow for dynamic foot placement on irregular surfaces during idle animations (IK is essentially a method by which you specify the desired target point of the endpoint of a bone chain, and the appropriate displacement and rotation of the bones down the chain can be computed taking into account constraints and whatnot). 

This example probably still needs some tweaking to make it just like you want, but it should get you started. 

If you know the shape of the piece, and you know where you want to place it, I would assume you have determined the orientation of the piece already. If this is the case then I think the solution is fairly straight forward. You have a default orientation for each piece, and depending on the piece 0-3 possible alternate orientations. The number of rotations left or right are "pre-computed" to match the target orientation. After figuring out how many rotation moves, determine how many spaces to the left or the right you need to move the piece. You can calculate this by using the left-most tile on the piece and the left-most space of the desired location. Finally, the same can be done for the height. From the target orientation, in the starting position, what is the space difference between the lowest tile of the piece and the lowest open space of the desired position. I say "pre-compute", because in my opinion there are too few possible orientations to make a complicated algorithm, and a waste of cycles trying to compute this. If you haven't done it already, it would probably take about 2 minutes to map out each piece and each possible orientation of each piece. For example, the 2x2 block has only one orientation, while the 1x4 bar, and the "s", and "z" shapes all have 2 possible orientations. And the rest of them, the "L", the backwards "L", and the broken plus sign, all have 4 possible orientations. (I think I got them all). 

I don't know if it's true that Unity can validate that a deployment of a game was made with a valid license or not, but it looks like if it is true they haven't released any tools you can use to perform this validation yourself (which is not uncommon, offhand the only company I'm aware of that does make it possible for you to do this yourself is Microsoft with Windows and Office). Your best bet, then, is likely to 

XNA, like many libraries, has dependencies on runtime components that must be in place in order for applications that depend on it to run. While you don't strictly speaking need an installer, the alternative is to ask or expect the user to have the appropriate dependencies installed or install them themselves (which makes for a very poor user experience). You can create an autorun file on your CD which launches your installer. What many games do is have the launcher detect the presence of your game and/or its dependencies and have the installation app tailor itself to what's installed -- presenting install options normally, and if the game is already there, presenting a "launch" option or possibly even launching directly into the game (this may annoy users though). Note that if you elect not to use existing installation solutions (NSIS, Inno, Windows Installer, et cetera) and write your installer shim yourself you have to be careful -- even C and C++ code requires redistributable components, so make sure to ensure the minimum OS level you support already guarantees them or build something that won't depend on them. Once the dependencies are in place, the game itself can be launched from the disc so long as it won't try and write to any relative directories, such as its own .exe directory (a well-behaved Windows application shouldn't do this anyway). Obviously the above applies only to XNA on Windows, as it's the only platform you can execute code off a disc on. 

You can use the dot product of a world up vector with an up vector relative to the player. If both of these vectors are normalized, you're results will be between 1 and -1. With 2d vectors the dot product is calculated by taking the product of the x components and adding them to the product of the y components. Given the vectors and . The dot product is . So, if the world up vector is (0, 1), we can see that: if player up vector is (0, 1), then the dot product of the up vectors is 0*0 + 1*1 = 1, and, if the player up vector is (0, -1), then the dot product is 0*0 + -1*1 = -1. This tells us the player is upside down. If the player is standing on the side of a wall (1, 0), perpendicular to the world up vector. Then the dot product is 1*0 + 0*1 = 0. So, to recap, if the dot product is 1, the player is up right, as the dot product approaches 0, the player becomes more and more perpendicular to the world, and is perpendicular with the result is 0. As the dot product turns negative, then player's head starts angling towards the ground, and the player is completely upside down when the dot product is -1. 

Fur is usually implemented as a render effect -- there isn't a 1:1 correspondence with geometry, although geometry may be used to achieve the effect (textured polygonal strips, for example, or the newer and better looking 'shells and fins' methods), so there isn't really anything to export unless you were you convert the fur representation to 3D geometry. This would almost certainly result in extremely poor performance in your game. The solution you probably want to is abandon using Maya to generate the foliage and employ a rendering effect in your game code to achieve the desired results instead. The article I linked to before provides one possible implementation; here is another example, using XNA. However, since you said you are using Maya's fur rendering to produce plants, you may instead want to consider rendering algorithms designed for exactly that effect. Game Rendering has a whole section on "vegetation." There's quite a few options for grass rendering, for example: 

The "key" used here can be whatever you like -- and it need not be a string, but those are easy to start with. The key will factor in to how you expect a user to identify a particular asset and will be used to look up the appropriate loader. Because you want to hide the fact that the implementation might be using a file system or a database, you can't have users referring to assets by a filesystem path or anything like that. Users should refer to an asset with a bare minimum of information. In some cases, just a file name alone would be sufficient, but I've found that it's often desirable to use a type/name pair so everything is very explicit. Thus, a user might refer to a named instance of one of your animation XML files as . Here, would be the key under which you registered , which implements . Obviously, identifies the specific asset. Given a type name and a resource name, your asset loader can query its persistent storage for the raw bytes of that asset. Since we're going for maximum generality here, you can implement this by passing the loader a means of storage access when you create it, allowing you to replace the storage medium with anything that can provide a stream later on: 

Probably the easiest way is to alter the A* heuristic. Once a tile has been used in a path, increase the heuristic for this tile so that the next pathfinding call will try to avoid that tile. This will also make the zombies gather around the player. 

The vector between A and B is B - A. The magnitude of this vector is the distance between these points. If point A is traveling along this vector then it has reached point B when the magnitude is 0 and it passes B when the vector components change signs (positive to negative, or negative to positive) as compared to the original B - A vector. For example, in 2D A = (3,4) B = (4, 6) B-A = (1, 2) 

I would think you could get an assessment of a player's skill by tracking a few things, and various skill levels could be defined based on these items. As stated already, overall score could be one of them. I think examining how well a player does on a per ball level, will also give you a good gauge to go by. For instance, how long a single ball is in play, how many times multipliers are achieved, how long the play maintains a multi-ball state, how many times hard-to-hit items are hit. Again, a high score is an indicator of all these thing, however you might be able to factor out some dumb luck high scores by monitoring these items. 

A "game engine" doesn't really have a fixed definition. Generally it's the unified collection of underlying technology used to make a game, usually supported by a bunch of related tools (and thus quite data driven). But it varies fairly widely from context to context. 

After the expression, objects will fully draw in the order in which you submit them for rendering, allowing you to draw objects over others regardless of their actual position in the world. If you only want to do this for some subset of your objects, draw the world normally first, then set the depth-stencil state accordingly (make sure to reset it to a one that enables the depth buffer before you draw again for the next frame, and also make sure that you always create the state objects in your initialization code -- don't create them every frame, as that is expensive and wasteful). 

Such a thing does not really exist; games are not a very established subject in academia (except for graphics, although there is a trend towards that changing, perhaps) and what "research" is done that specifically pertains to the MMO field is likely done internally by studios developing them and thus would probably be considered a trade secret and kept undisclosed. Your best bet is probably the LOGIN conference. 

There is some confusion as to what the parameters for are. This function takes two values. The documentation list them as , which I think the confusion is coming from. It can be read as (and it should be) from here to there. If you are thinking of these parameters as points, this from here to there idea gives you a line. However, if you consider the parameters to be vectors, then what you are looking at is an angle. This is illustrated by the purple arc. 

It is unclear as to why you are using a perpendicular. There isn't enough detail to describe the problem you are working. However, perhaps this will help. A 2D vector can be described using the values (x, y). The left hand perpendicular and the right hand perpendicular are easily calculated. The left hand perpendicular of (x, y) is (-y, x). The Right hand perpendicular of (x, y) is (y, -x). This can be easily seen with an example. On a grid where positive y is up, and positive x is to the right, a normalized vector pointing up can be written as (0, 1). The left hand perpendicular of (0, 1) is (-1, 0). The Right hand perpendicular of (0, 1) is (1, -0), or (1, 0). 

No. If your game has a gross revenue of $300 total, or $300 per quarter, you do not owe any royalties to Epic. 

When you have a group selection and you issue a movement order for that group by clicking, the natural expectation of the player is that the destination point will be the new "center" of the group once they arrive. One possible approach to this problem is to compute the centroid of the group when the movement order is issued, and then construct a path from that centroid to the clicked location. You can also compute the offsets from the centroid to each unit in the group at the start of the movement order, and store this in some kind of transient "formation" data structure. When units get within a certain distance of the target point -- a good value for this distance could be the radius of the circle that encloses the full unit group(*) -- have them move to the final destination, which you can compute by applying their stored formation offset to the clicked target position. Of course, it does mean your units will try to clump up into a single tight ball while moving. You can solve this by enforcing proximity constraints, or by use the formation deltas to move the entire group "in formation." Doing either of those raises another question: you computed an A* path from one point to the other, but you aren't moving everybody exactly along that path, so how do you deal with obstacles in the way? The solution is to employ a simpler form of local pathfinding to move units around local obstructions. Edge-walking (where you simply move a unit around the border of an obstacle until it gets back on the path or strays too far from it) can be useful because it doesn't have nearly the computational cost of A* and it will produce acceptable results for very small search spaces, which is what you're using it for. This is good, because the main benefit of this overall approach is not doing N A* searches for N units; since A* is computationally expensive, you want to minimize its use. This approach allows you to scale up the number of units in a selection group without negatively impacting search performance (at least not linearly impacting it). A key thing to keep in mind for pathfinding in RTS games is that a divide-and-conquer approach is going to provide huge wins, especially given the size of RTS maps and the number of pathfinding agents generally involved. Any way you can seize upon to reduce pathfinding complexity or put it into increasing granularity hierarchies will help improve the overall performance of the system. (*) You may also want to handle "outlier" units (for example, you have five guys close together and one guy really, really far away from the others -- all selected) by adjusting their formation delta to some maximum distance from the centroid. This means the outlier will move in closer to be with his friends by the time the move ends.