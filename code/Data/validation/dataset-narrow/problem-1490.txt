Getting feedback from students is the best thing you can do to improve your craft as a teacher. I end every week with an exit ticket (and the course as a whole with one), and it is often the highlight of my week reading students' responses. I tell students that feedback from me is the way they improve as students and so to is their feedback the way I improve as their teacher. Understand though that the motivation of your own growth should always be improvement in student learning. Include several straightforward questions about the relevant subject matter. These are ungraded "formative assessments." In other words, these are means by which you can see if your students actually understand what you taught them. It is no good for students to enjoy your class but not actually learn anything, and just because you taught it doesn't mean they learned it. For example, if you are teaching the binary number system, give them a few small sample conversion problems to answer on the form (and yes, Google Forms is my absolute favorite and preferred means for gathering and analyzing this data, but you could certainly do this without them). See if they can actually do what you have been teaching. I would then follow up these short practice questions to test for understanding with questions such as the following: 

These four will probably culminate in some sort of original creative project as a synthesis of all the concepts we will study. As I'm wrapping up my design of this course, I'd like to get input on these and any other simple, engaging assignments in Processing. What other beginner-level assignments in Processing would interest a student new to programming? 

Essential Understanding 4.2 of the AP CS Principles curriculum is as follows: "Algorithms can solve many, but not all, computational problems." Among the topics I am expected to cover in the context of this standard are algorithms that run in a reasonable time v. those that don't, the difference between solvable and unsolvable problems, the use of a heuristic, and the existence of undecidable problems. My plan is to cover the 0/1 knapsack problem, the heuristic of a greedy algorithm, and the halting problem. This is a relatively small part of the course and is assessed by only a couple of multiple-choice questions on the AP Exam, so I don't need more than one lesson (or two) of material. That said, I am afraid any one-day lesson will be inevitably reductive as these are complex topics. Moreover, the students are new to programming and computer science in general, so I need to balance abstract with theory with concrete, relevant examples. What lesson ideas, examples, and/or analogies do well to serve the teaching of this standard? 

In the final report of their internship, the students of our school must have one chapter where they "document" the developed work. When using the “waterfall” methodology, they usually have one sub-section for each stage: 

The idea of the game is: you have a group of pictures of persons with different facial features. One gamer selects one of them and the other gamer has to make questions to try to eliminate the ones that are not relevant and try to guess which one the other gamer has chosen. It is kind of like what you do in the WHERE part of the SELECT... 

There is this research paper "Learning edge momentum: A new account of outcomes in CS1" by Anthony Robins that is much focused on that subject... From the abstract: 

As probably we all experience, plagiarism is very common in CS. I know that there are several types of plagiarism ranging from simply submitting a copy of the colleagues’ code to other highly sophisticated mechanisms. In my experience, the most common is indeed the simplest one. The student just grabs the code from another colleague and eventually change the names of the variable, and submits the solution (some students don’t even do that!). While there are several systems that are easily capable of detecting this type of plagiarism, they do it mainly when the student submits the final version of the code. Some other tools, are capable of detect plagiarism and notify the student about that (as if they didn’t already know that!). In most cases the use of an anti-plagiarism tool will act mainly to support punitive measures. Although it is not the main focus, as part of my PhD work, I am working in a tool that analyses the source code as it is being written and is able to detect plagiarism in “real-time”. This way, the teacher can be notified about students that are performing plagiarism even before their final solution is submitted, giving the teacher time to act and avoid the punitive measures. My biggest question is: What should the teacher do with that information? Will this be efficient? 

Unlike straight Python, your program actually "does" something. You can make your robot throw objects into a basket, or follow a line (self-driving car), or respond to light sensors. You can start with a GUI programming language (NXT-g) and when they get the basics, move them to a "real" language (such as C, Java, or even Python). 

Show them how they use recursion in solving puzzles in their civilian life. Sudoku Ask them how to solve Sudoku. What's the naive way? You have to iterate through all (roughly) 9^81 numbers, checking each board. Assuming each check takes on plank second (we're not even close to that in real life), it will take about 3.35843803 × 10^26 years years to solve each Sudoku puzzle. That's way after the earth falls into a black dwarf sun. So how do we solve it? Recursion. Find the "easiest" block to solve (meaning, the one with the least possible variation). Let's say it's the next small board: 

If it's an 'end control character' (a 'close parenthesis' or an 'end-of-string tag'): Return the value that's left after all that work. 

Hey, that works!! Let's move to the next blank. And you recursively [1] check each square. How does it work? Because each problem is a subset of the previous problem. Here is a sample solver of a given Sudoku board (The website I found it labeled it as "very difficult"). The program solved it in less than a second, going through only 40,000 iterations. 

In reality, that's how most people actually solve the problem (ever seen people writing small numbers in each square, erasing ones that don't work? That's your stack!) [1] In this case you don't need recursion, because the board is too simple. But if you take a real board with moderate difficulty, you need to take steps in, check if they work, and if not, pop out until there's another way to solve it. In short, you push and pop solutions, which is easiest to do with recursion. A Maze How do you solve a maze? You go down one path? If it doesn't work you pop back to the last state where there's hope and try again. Solving arithmetic problems How would you solve (1-2)/((1+2)/(3-4))? Let's assume for a moment that all order-of-operations have been taken care of through parenthesis. The simplest way would be a recursive-descent parser. 

Since you mentioned that ideally you were looking for a video, a few years ago I used to show a video to my students: The Good Warriors of the Net - IP for Peace . It is a bit old, but the main concepts are there. Another that I used to show my students was: How the Internet Works in 5 Minutes Grab the popcorns! :) 

The question kind of says it all. Imagine that for an assignment you receive two or more similar submissions (e.g. programs). What will you do? Annul all the works? What if you know for certain who was the original author? Probably this is already in your schools’ code of conduct. In my school it is not and I sometimes don’t really now what to do. 

What if an agile methodology like XP or SCRUM is used? Every year we have the same problem, as some teachers say it should be done one way, while others say the exact opposite. Any ideas? 

I am not sure if this is really what you are looking for, but there is also Blocky from Google which is kind of similar to Scratch, and lets you see the source code produced by the block in different programming languages (JavScript, Python, PHP, Dart, Lua). Blocky is used in several projects like code.org. If Java is OK for you, than you can consider the BlueJ IDE which is: 

It is not clear for me what "computer science" means for you. Is it at High School level? If that is the case, you could try to introduce some of the mechanics behind "digital music". How it is processed from analog to digital. How it is compressed, how it is reproduced, ... What does it mean to be 8bit or 16bit, the bit-rate, the sampling frequency... If the students are more into drawing/painting, you could do the same with image formats. 

A visual demonstration might help. Let's say for the purpose of this in-class demo that the generic is an object of class and you are demonstrating a (singly or doubly) linked list. 

It reminded me of this blog post from Scott Hanselman: "Stop saying learning to code is easy." The entire post is relevant for this topic, but I'll just excerpt this paragraph: 

Additionally, I asked a question a few weeks ago about the differences between Scratch and Snap!. You might find this discussion helpful: "What can Snap! do that Scratch cannot?" Edit: In the context of AP CS Principles, it may also be helpful to know there is a full curriculum available from Berkeley that utilizes Snap!. It is called The Beauty and Joy of Computing. 

It is clear to me that the Game of Life works for reaching both of those objectives, but I get a sense that I'm missing something more that I could use it for. Keep in mind that these students are relatively new to computer science and programming as high school students. Ultimately, what is the pedagogical value of Conway's Game of Life for a high school CS course? 

Then the challenge is to make them fun and engaging and (ideally) interactive. I myself have undertaken the challenge here and there of teaching myself regex, and two resources rose to the top in my own learning: RegexOne and Regex Crossword. RegexOne is great as a lesson-by-lesson tutorial. Students can type and see in real time what tests cases their regex does/does not match. There are 15.5 lessons and 8 practice problems. The practice problems draw from relevant use cases, such as extracting a phone number, trimming white space, or reading a log file. Regex Crossword mixes regex with logic: students have to fill in a square grid and track how gradually more complex regular expressions interact with each other. (That sounds a bit vague, but an example like this one makes it clear what I mean.) The crosswords tend to have fun themes/solutions. There are many crosswords to solve, including ones with great complexity, so students will have to spend lots of time working at it if they'd like to complete all the puzzles. When it comes to working in class, it'd be pretty easy to work with some of the smaller crosswords in a non-digital manner. You could put one on the board at the start of every class as a warm-up or print/copy some of your favorite from the site. Maybe even have students work in groups and complete to solve a series of puzzles in the fastest possible time. Between these two resources, students will at least have a pretty good start to working with regex. 

For research reasons, in the last few days, I’ve been looking at several statistics on computer science programs in Portugal (but also in Europe and the US). One of the most interesting findings is that approx. 20% of the students will drop the program at the end of the first year. But the most problematic finding is that after four years, only approx 22%-32% of the students were able to graduate in a 3-year program. It is important to stress that in Portugal the admission to higher education is determined only by the grades that the students obtained in High School (50%) and the results of the exams in some particular subjects (Math and Physics) for CS programs, for instance (50%). In the end, only the n students with higher scores will be admitted. Given the demand for IT personnel and the high unemployment rates of several other areas, several students will end up attempting CS. I am aware, that some companies rely on the Berger Aptitude for Programming Test to select their candidates. From what I understood, this test is used mostly to evaluate the candidate’s ability to program and could not be used to select candidates for the CS programs. Given this context, shouldn’t the students be performing some aptitude test before enrolling in these programs? Is anyone aware of the usage of such tests? Obviously, I understand that one shouldn’t simply say to someone: “Hey choose something else!”. However, we are talking about several hundreds of students that are basically losing one or more years of their lives. Although this happens in Portugal, I guess the same thing occurs in other countries. Shouldn’t we be doing something about it? I am aware of some other questions concerning programming aptitude. However, I think mine is different. 

I suppose that a traffic light is a very good example and easy to understand by your target audience.