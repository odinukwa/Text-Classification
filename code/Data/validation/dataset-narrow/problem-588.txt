now you can get rid of the comment because the code is more clear. second is that I would not let your logic drop down. In my mind I'm reading and seeing that you are setting status. but you don't return right away so in my mind I think that you have more logic you need to perform, but instaed you just skip through everything and return status. Ok well if that is the case then just return on the spot so I don't keep reading the next bit of code. then you can just either delete the else statement and return RequestStatus.Error, or remove return status. third bit of logic that can be cleared up is when request is null. You check if it is not null in almost every if statement. Make it the first call, checking your other conditions then return. fourth is that if a condition takes prescendence over another condition put it first in your else if chain then you don't have to test for it again. With those 4 tips I would change your code to something like this. 

I know it's not much to go on and I normally give much longer reviews but there isn't much code to review. Here is the code I used to test against 

overal that is a bad test. Mainly because i'm not asserting anything nor am I checking that what was serialized is what was deserialized. That's cool we can work with that. So now lets write my test the way I want my code to work. I want to take a clubinfo, serialize it, then using my deserializer I want to check that it gave back the same values. 

the IntegerCalculator class is still a little bit from being complete, and the GUI itself as it stands right now can't add numbers larger than 1 number, but you get the jist of it. 

Now you will have saved your self some time in the future if/when the design requirements change. if implemented correctly you might not have any code changes.. say something like this. 

NOTE: No Attempt to clean up code was made, just safe encapsulating now the getSqrt() method looks like this 

Testing code like this is very difficult. It is hard to read, difficult to maintain and lastly is a HUGE pain to debug a small problem. First suggestion is to group things together into a class that need to go together. This is the first suggestion on finding out what is slow. So here is a much smaller version of the same code. 

Notice how fast it ran? Once you get that test to pass you'll be able to create a new instance in your main method of and replace all calls to DrawBoard with your newly tested method. A quick note about static: I made a new instance of and made the NON-static. I did that because when you have many static methods in a class it is a good way checking if a new class can be made. Classes can be simple (and should be). When you see that you should ask your self if it should be responsible for ________? Good luck 

Lukasz Zwierko mentioned a design pattern in his comment to you (MVVM to be specific) This is a very helpful aspect to making the code easier to write, and understand. It separates concern of certain bits of code into different classes that describe their intention. This will make it easier to come back to later and adjust the appropriate class for changed functionality/bug fixes. I would highly suggest looking into MVP (but other popular patterns are the MVVM, and the older MVC). It would take too long for me to give an example of how to do this. Next I would also like to mention unit tests. Your problem at hand uses too much code to give you the desired results. I know you can feel it because you asked your question here. Unit tests are great because they are small bits of code that can help mold how your code works. There is a art to it, and it needs practice to get good at it. That said there are TONS of resources out there and how to write unit tests. The following two tests are what I wrote to show that I only use one source of data and update the other two. 

Here is where the value comes in because I can override FindFile in easily, and I can pass in an instance of that easily info . So now all the math and resource finding things an go into the and be tested in a test framework (such as NUnit, or Microsoft's test framework). The underlying issue is why go through all that trouble to make 2 more classes just to return a client? Simply put for testing purposes. If all that code is testable then you know it works as you expect without having to run the actual application. It also gears your mind more towards the MVVM principle of seperating work that you do in the code behind with actual work that you want done. Also by seperating when you go back to this code and decide to use the MVVM approach you'll find it almost trivial. (Essentially it would be a matter of setting your button bindings to a method which is just the inside of your current button click events.) I personally think that this type of work is being overshadowed by different approaches such as MVVM. Granted WPF was built with MVVM in mind, but what if someone comes in and says oh MVVM is SOOOOoooo 2015, we use MVMVPM now, or your company decides that MVVM is to strange to work with and they only want MVC/MVP pattern used? No big deal because your code that does the actual heavy lifting is extracted and tucked away safely in a blanket of protection. (FYI.. I use MVVM, I like it and would recommend looking into it after you've learned how to seperate heavy lifting code from code behind) 

I understand that you don't know MVVM yet. However one of the driving concepts behind it is to make a class that does the actual heavy lifting. Ideally this code seperation should be true if you decide to use MVVM later, or if you stick with code behind. Your question is probably that of how can this be applied? Simply stated you codebehind should create a new instance of a class and give it the appropriate values needed to perform a caclulation then return the transformed values. case in point: 

The code at top that should turn the light white for 450ms. If I run that code in a completly non-OPOS environment all by itself it will flash white a billion times with no problems. In the multi-threaded OPOS program..it does strange things. most frequently red turns on first for a moment then green and blue turn on and then turn off at different intervals. (results vary, but this is most typical) I do know that the calls to the LED's are asynchronous (they have to be to allow for different color combo's) but I am completly lost as to how to block other API calls from my other threads until the coast is clear. Any suggestions? 

it isn't the biggest saver on lines of code, but it saves a few here and there. Add it up with what was suggested in another answer and you'll get some seriously smaller classes. Hope this helps some. 

In the end the commands are not going to change, so I've considered just using a byte array instead of a whole class for command. I don't like the idea of making an extension method for a byte array which makes me second guess doing that. Every command except for GetDeviceId takes in as it's first parameter the device id. So I wrote down on paper an idea about writing something like or I've also thought about making a non-static Command factory pass in the deviceId and have it send back commands. Then I wouldn't have to pass in the device Id each time. Are there any design patterns that would better match what I'm trying to acheive? 

it's like..HUH??? so I made the BuildAndSendCommands private and made methods to make the code more clear.. Now I have the method signature like this.. 

Now in your class you have two options, make a or make a . Here is an example of what I mean. It is by no means complete (and might even have a compiler error as I did it in Notepad++) 

I very much agree with Jakob about using MVVM as a pattern of choice with WPF. The two go very well hand in hand. Since Jakob mentioned it, this is as much as I will mention it. As your your code there are a few things you can do to clean up a few lines of code. 

Although you are doing it correctly, a part of me wonders if it was the correct solution for you problem. The reason I ask is because a interface usually means that each method that you define is going to need to be implemented differently for each sub class that implements it. In your case it doesn't matter what type of person you have they will always introduce themselves the same way, and they will always say their name the same way, and they will always tell their age the same way. That being said an abstract class would have been a better choice because the basics will be the same for both parent and child (and even if you decide to add another branch of a person) for things such as their name, and age. The introduction would possibly be the only exception if you added a culture to this mixture. Since different cultures introduce themselves differently in almost all scenarios that would be a good candidate for a interface. 

Now when someone comes in and wants to know exactly what the button does they don't have to read the source code and figure out what it does. The method states very clearly what it is supposed to do. The further you go down the list the more details you add. so what should the next level look like? Maybe something like this.