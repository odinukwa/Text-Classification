loop What other suggested and as you mentioned already decrementing i in the for loop may be a bit confusing for the reader (well it was for me at least), having a do..while loop feels more natural here where the while condition is false until user enters correct code (or changes his mind and gives up). 

your function can fail in a few ways but you only set the when malloc fails, you may want to add some more error codes like when nothing is read. 

The function will for any string 't' return 0 since strlen(s) will always be 0 (as others already have pointed out). You move the pointer 's' to end of string. You may want to do the check before the while loop instead. 

There seems to be no error handling in your code, maybe it would be useful to printout a syntax error and in which location it occurred. Prefer to put implementation details at the end of the class declaration like private/protected parts. In a perfect world when a user wants to use your class he should not need to know the implementation. In general I find your code nicely structured. EDIT: rephrased according to comment, hopefully making it more clear: When you declare a class put the private and protected parts below the public part because the user of the class should need to know about implementation details (design goal). 

you also call twice, that seems unnecessary but I guess that is due to your unwillingness to have local variables. 

you malloc should just take as argument i.e. the rest makes it just look difficult to read and in this case is wrong, same applies to . 

after that you can treat the pointers as any other pointer and you do not need to delete them. giveCard This function copies the card from the deck, which somehow seems a bit unintuitive, but ok that works i guess as well. Alternatively you could move the card to the players hand, then when you initialize a new deck just create 52 new cards in a fresh deck. Hand you may want to keep the hand sorted to make it easier for user. display There is no need to have the extra ( ) around ++iter Player You are inheriting from Player (Dealer) but Player has no virtual destructor, add one. It is not necessary to write in Dealer, when you inherit you can access the base class members that are protected/public. If you want to access private members then maybe you should reconsider why you made them private in the first place. It seems wrong to declare the Deck to be a member variable in the Player class - do each player have their own marked deck? I would think it would be better to declare it outside Player/Dealer since they only have a handful of the cards at any time. 

returns the same value regardless of what error occurs in the function, it is better to create an enum with various error codes so that the caller of the function can determine what went wrong and give a suitable error message. In the same manner remove the fprint-out in the function, let the caller worry about showing an error message based on the error code. 

For one thing you might want to be a bit more forgiving with non-digits. The original atoi just returns 0 if there are non-digits, terminating the program due to a non-digit is a bit harsh. 

First I want to say that you have good descriptive variable names. You have moved functionality into functions as well, that is also good. Although you should avoid declaring global variables, it is easier to follow a program flow if you declare the variables in main and then pass the relevant variables to the functions it calls. Another major advantage is that you reuse your functions based on the passed parameters. e.g. 

I find it a bit dangerously written, your while condition dereferences the pointer and checks whether it points to \0. But it would be arguably better just setting the array pointer to NULL when you allocate it in . Then you could just do instead of adding some extra memory that is not really used. I would write it as a for-loop instead since you have a variable you increment for each iteration. read_num_slices The function that have written to take user input uses a scanf to read the number, what it does not do is to remove the additional \n that is in the buffer from the user. So it may happen that you can get some problems with this. Personally I find using fgets together with sscanf to be a better way to read user input. That way there is no risk of stack overflow and you still have the convenience of scanf parsing. Remove the goto from the function, there is no reason to have a goto there, a simple if statement should handle the case if 0 slices is entered - you should check for negative values as well. e.g. 

You are a bit inconsistent with your if statements, sometimes you use braces sometimes not, sometimes the starting brace is on the same line as the if statement sometimes under the if. It makes the code harder to read. Choose one way and stick with that. I am also not sure why you pass fp to download(), since you do not open some other file in there it is enough to pass the file pointer itself Global variables; bad, especially if they are not really used by several functions e.g. is only used in . Comments; good to have. especially when I read such a line 

(depending on your compiler you may need to do that in the constructor instead) especially pointers, since a delete on an uninitialized pointer is undefined behavior but a delete on a nullptr is OK (NOP). 

EDIT to the actual code review: writing to calculate size is unnecessary and is hard to read, just write size. i.e. malloc(size) initialize all variables, one day you may change the order of the statements and then you may end up with uninitialized variable during runtime BTW I don't think your code works, when is successful you never set str to point to the new buffer i.e. temp_alloc so by next fgets on the same line (by lines larger than ) you are in uncharted territory. 

Comments You have using namespace std before the class declaration, normally you would place that in the .cpp or even better using statement in the individual functions where they are needed. Initialize all member variables using an initialization list 

These comments apply to your question, not your answer. Using strings as arguments seem unnecessary, it would be better to use bools or enums, that way if you one day change strings (e.g. another language) it does not affect the print function. 

use c++ headers (as somebody already said but can't be mentioned enough) in you delete what comes in, it is a bit unusual to do it like that because the caller of the function has no way of knowing (from the prototype/name of the function) that you are doing a delete on argument. Use instead a as argument making it clear that ownership is taken over i.e. (even though i am not sure why you allocate an int on the heap and pass it, instead of just passing an int by value) you should use instead of normal c arrays e.g. can be replaced with use in a C++ manner, writing is writing it in a C-legacy style, instead write ; (const always referring to the item left of const i.e. in this case the pointer ) you normally don't use in c++ programs, instead use ... even for debug output always initialize all variables, in particular the POD ones and structs. try....catch is good to have in main to exit gracefully if something goes wrong. in main could be replaced with 

When you declare variables it is good to place them one per line and initialize them. If your C compiler allows it declare the variables where they are used and not at the top of the function. 

that way you are more independent from the compiler version/options. when reading a value from keyboard use instead the more robust fgets to catch the input, even better put it in a function: e.g. 

you should check the return value of , it is not always successful. you need to deal with that event as well. e.g. reading many lines and with a memory that is fragmented may cause it to fail to find a large enough continuous memory block. also is an expensive function to call, it is better to allocate larger blocks than try to allocate several small blocks. 

check the parameter if it is null before dereferencing it to avoid error, just return 0 - optionally print a message to stderr. 

You could have added the sign at start of while loop instead, seems more clear somehow but that is just a matter of taste. 

The SQL string is dangerous as it is, I am no expert of MySQL but most database allow for precompiling a statement and then just supplying the arguments in the code. That would also speed up execution.