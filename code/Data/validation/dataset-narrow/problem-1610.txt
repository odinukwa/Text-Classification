Yes, there is. Take a look at the Raspberry Pi entry on the FreeBSD Wiki and also this question and (especially the last) answer. 

Download an SD card image (both STABLE and CURRENT images are available, for version 3 boards look here for the 64-bit CURRENT build) details of what is working are on the wiki. Decompress the image 

The problem is that Stretch does not run Bonjour out of the box, so the name of your Pi is unknown. You should be able to connect if you: 

If the SD card isn't called substitute the name you see in Finder. Then eject the card and put it back in the Pi and reboot the Pi. Next you need to figure out what IP address the Pi has been assigned. I'm assuming that it is "headless" so you can't just watch the console. That would be too easy... So, take a look at this question: Find Raspberry PI address on local network, my favorite method is to the broadcast address on the network () then use . Once you connect to the Pi run the command and permanently enable it is under Option 5, Interfacing Options. As I understand it, the trick in step 1 is a one-time thing. 

Check that your network is up and basically working by trying to ping a machine on your local net by IP address (). Check that you can talk to your router by attempting to ping the internal interface of your router by IP address (). Check that your router is routing by doing a ping to the external interface of your router by IP address (). Now try to reach your router's router by attempting to ping your router's default route by IP address (). Success means that you can reach a remote machine – specifically the machine that your router will be forwarding all of your Internet traffic to Now verify that it is all working with a to ping something far away by IP address (). 

In cases like this it helps to break the problem down – which in turn means knowing something about the pieces that need to line up for a network connection to succeed. Much of this information isn't specific to the Pi or it's OS, but it will be helpful to know the tools and foibles of the particular hardware and OS that you are using. This question and its answers may help: How do I set up networking/WiFi/static IP address?. Testing with other devices on the same network may also help pinpoint where the problem lies. Rebooting often works wonders. In general you want to start close and expand as you test, so you might: 

I am facing a performance issue right now on a test setup i use to investigate limitations for my upcoming project. AFAIK the rpi supports USB 2.0. And with this it should roughly match speeds up to 400 MiBit/s. A friend of mine told me that he already saw data rates of 50 MiBit/s using a USB WiFi stick. So this would be my minimum expectation. However, my current test setup shows that the pi is not getting even close to these speeds. Question The main question is: #1 Does anybody have an idea where the low throughput comes from, or have an idea on how to narrow down the problem a bit further? Please focus on this question :) This problem bugs me for already 3 days now, so there is already a lot of stuff that i have tested, but there are also things that are still unclear to me. I will mark the side questions in bold with a hash and an identifying number. Setup I connect an arduino mkrzero over its usb to the raspberry pi's usb. The arduino sends sensor data and the rpi reads it as fast as possible. In a comparison setup i use a mac with osx to read the data from the arduino as a reference system. If the either the mac or the rpi is not fast enough the buffers on the arduino will overflow. Then the retrieved data will contain gaps. How the systems are setup: 

Now comparing the amount of read bytes with the rates show that both perform linearly to each other. That is because this equation roughly holds: . Thus the rpi performs times slower than the mac on this benchmark. Now comparing the rates on a benchmark where the arduino served the data at 800sps shows that both processed the incoming data at the same byte rates ~16.6kB/s. However, it seems that the rpi seems to do a lot more cycles on the cpu since the cputime is 7 times higher than on the mac. CPU usage via revealed that there is still head room with about 12-15% overall usage during runtime. #2 I don't expect the CPU usage to influence the throughput according to theese numbers, or am i wrong here? Sample Size For the samples being sent to the pi take the Mac data sets as a reference. E.g. with a specified rate of 4000sps the Mac processed these with 83.5kB/s. Regarding the quotient of kB/s divided by Samples/s gives the size Size in kB per Sample: 83,500Bytes/s / 4000Samples/s is roughly ~20Bytes/Sample. This holds for the other reference measures at 3000sps and 800sps on the mac. Here is the code which spits out a sample on the arduino See Here: 

I suggest to configure your tools, to use a specific network interface. Let's say you are currently using to make some HTTP GET/POST to a web API endpoint. Just add the option to curl, to make it use a specific interface ( or or -- use to list all available interfaces) for the network request. 

The MAC address is only 48 bits and the serial number looks even less. So they are by no means cryptographically strong. You could now generate a HMAC of these values, or maybe from both (by chaining). You should consider that it is possible to disable the wlan0 interface (and probably the eth0 aswell). Which would void your MAC address result, so you need to test for that. 

interesting observation. such kind of measurements are hard to align. WiFi packets might have a different packet size, error correction etc. compared to eth0. I don't think you will see anything suspicious via - but I suggest that you try another tool: vnstat 

I was shocked once I found out, that some USB cables would not provide as much power as others to the Raspberry Pi. We have an Android phone connected to the Pi, and when its battery is mostly flat and its browser is rocking on 4G/LTE, then your battery could be drained faster than it can be recharged by the Raspberry Pi. So I bought a simple USB power meter and found out, that one specific noname USB cable was really a bottle-neck - the meter wouldn't go any more than 700 mA. I am using Anker cables now, and the meter is somewhere around 1,3 A with the phone plugged into the Pi. In my setup, there is actually 2 USB cables: 1) is supplying power to the Pi from a USB charger, and 2) is connecting the Phone to the Pi (data via and charging the phone). Obviously the cable 1) has approx. 250 mA more load (the avg. current of the Pi). Also, I would like to mention these settings in found on the Pi: 

I have been using it for monitoring network traffic since a few years. it offers live observation (with ) aswell as traffic stats over time (hours, days, months). Download 200 MB though your setup and then compare and ) Update: Don't forget vnstat updates its database only every x minutes (see ) Another remark regarding throughput speed in bytes/sec: In my opinion, this is a hard task to do accurate. Network traffic (especially when wireless is involved) can be very inhomogeneous, i.e. it might transfer 1 MByte/sec right now, then suddenly stop for 1 sec and then do 2 MByte in the next 1 sec, then go back to 1 MByte/sec. If your tool (vnstat, ifstat) is looking at a 2sec interval, you'd never notice that it was stuck for 1sec. So the refresh rate (interval) should be much shorter, like every 10-100ms. That's just one example why this can become tricky. 

The first column indicates the buffer size on the arduino and should roughly keep at a constant value below 2047 which is the buffer limit on the arduino. Otherwise the data retrieval is not fast enough. In this case it was for the 5 complete data sets being retrieved. Code 

Here the output is constantly updating the line with the bytes read over the time the program is running to calculate the rate of 83.5kB/s on the mac. Output (arduino @ 4000sps => 18.9kB/s over ~30s RPI) 

Possible sources of errors There are still several things i can check. However, i don't really know if these are worth the effort: 

Excluded sources of errors Now follows a list of possible sources of errors that i already checked and can hopefully be excluded. I have added a small description to illustrate my analysis, to keep track what and how i did it. Please correct me if something is wrong: 

The is printed just for debugging purposes. evaluates to 4, so that in total 5 of data are sent. Each is 16 Bits long. But note that these routine sends data as text. And we need to take the into account as well. Baud Rates On the arduino the baud rate is set to See Here: 

Comparison Data from above is measured over 30s with an arduino serving data @ 4000sps. Below first two lines are the two datasets measured above. Notice that 4000sps is too fast for both the mac and the rpi. With a sample rate of 3000sps the mac is able to process data fast enough, but the rpi not. With a sample rate of 800sps both are fast enough. 

Motive I am trying to build a modular high performance data acquisition platform for my upcoming project. Multiple arduinos should send their high frequency analog/digital signal input to the raspberry pi. Data aggregation and a processing should run on the pi as well as the HTTP based frontend to control the platform. In order to reuse existing standards, i would like to plugin several arduino modules into the system using USB if possible. That's the basic idea. 

Programs Both programs running on the either the mac and the pi or the arduino mkrzero are documented and uploaded to github. Reciever The programs running on the rpi and the mac are variations of rpi-uart-reciever. Printer This is the version of main.c when compiled WITHOUT . It prints out all incoming bytes as is to STDOUT using . Output