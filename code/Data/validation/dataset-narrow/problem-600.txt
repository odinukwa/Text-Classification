Extracting UI calls Finally the UI calls must stay in the UI-part, namely into the JavaFX controller. Typically it could looks like this (simplified): 

This parameter is the thing that bothers me the most in your class, and also the one who gave me the most trouble when trying to remove it. Why does it bothers me ? Everytime you have a in a method (or constructor), it's a sign of poor design because the class/method should do 2 things now (one for each boolean's value), therefore violating the single responsibility principle. It makes your code hardest to test and to maintain because of the conditionnal logic flow. If I understand correctly, the purpose of this flag is to avoid client code retrieving a when calling because the cache has not been updated at least once. I would rather resolve this problem by blocking in as long as the cache has not been computed once. In Java, one have the who is a thread-safe class able to fulfill this responsibility by blocking only until the cache is computed the first time. I came up with the following wrapper to achieve that: 

Going even further As I said in the first chapter, the method has actually 2 responsibilities. I would split those in something like that: 

Beyond the requirements The two setters are superfluous and can be removed. Also, Java class naming convention is CamelCase so you should rename to . Since your class is not meant to be inherited, you can mark it . Here is the full resulting class 

This kind of requirement is the kind of which clutters the code with at least one and is in general irrelevant. If you are okay to have a number in the filename (going from 1 to n), then why not having 0 ? After all, the requirement behind that is that no filename should be erased by another with the same name. So the real problem to resolve here is how to make sure this method won't create 2 files with the same name ? Since you stated 

In addition to what others have mentioned (good points raised by others), I'd like to talk about function pointers and vtables for a moment. The first suggestion would be to not use them in this case. I would avoid using function pointers in the struct unless you really want the behavior to change at runtime from one buffer to another (i.e. the allocation strategy of buffer subclass A is different from B -- seems unlikely that you'd want this). Otherwise using the function pointers will cost you in CPU time, memory overhead, and source code readability. If you did want to go the "function pointer in the struct" route, you can save memory by using more of a "vtable" approach. This pattern is used extensively by the Linux kernel, by COM, and by many C++ compilers when they implement virtual methods. Instead of: 

If you are not religiously opposed to (this probably makes more sense in C than C++), this approach is also common: 

According to comments in , correct use of the library requires the caller to initialize the member being called: 

Note that can fail, so we don't initialize anything in that case. (Callers of should do the same check.) Actually your allocation also highlights something: 

While I'm all in favor of the crazy C style pointer arithmetic loops when they make sense, I don't think it really gains you much to reinvert . And doing the compare backwards is kind of weird, especially where is perfectly reasonable. I mean, you can deduce the lengths from the previous pass... No need to be all macho. Also, this is subjective, but I don't think it makes sense to return if NULL is passed. Especially since the function lends itself towards use in a boolean expression; will be true, which is weird. Maybe you should let the program crash in that point. (Since dereferencing NULL is a bug.) Or if that scares you, you could return . (A NULL pointer can't be said to have a suffix or be a suffix, right?) I might also consider changing the name. Something like maybe? 

Unsigned subtraction (and automatic mod 2^32) will always give , even when , and as long as the actual elapsed time doesn't overflow the tick count (it isn't greater than 49 days). So you could replace the original with the following code: 

I tend to agree with Loki's comments if you wish to duplicate . But, finding a "safer common type" is way more fun than having a common type for all arguments right from the start. For this, you could use a trailing return type with to make each expression-returning template function return its expression's promoted type, rather than whatever type the function's first argument has. The example below is kind of ugly because each function's expression appears in the function body and in the decltype, so there is room for improvement, but it demonstrates the basic idea. This prints on both lines, where the original would print , then , because the second call's first argument is an . 

EBCDIC is a myth made up to scare children during holidays, so here is the ASCII-dependent version, as suggested in a comment by JPhi1618. The main imrovement is to efficiency, by avoiding std::string::find, which is probably implemented as a linear search. Unicode is not a myth, unfortunately, so don't ever try encrypting the string "Zur√ºck". 

Here's a version of your code which works with C-Strings by using to turn any array arguments into pointers. This also uses perfect forwarding in the recursion, to preserve argument types, just in case unconditional conversion to a const reference is inappropriate. I'm making this Community Wiki, because it's more of an answer to your question about C-Strings, rather than a code review (ok, little review: is usually so poorly implemented, you should use something from , like , otherwise, thumbs up!). 

I am not an expert in the source tree nor am I familiar with the coding style of its authors, but I found this to be an interesting question. I'd say it looks safe and my guess is the original authors are expecting to be initialized to zero. Update: OK, I misread an statement; looking at it again it looks like it might be unsafe without a custom allocator, so we'd have to look at et al. and the actual inflate logic to know for sure. Explanation follows: It looks like is allocated with the macro. That macro resolves to: 

If multiple processes perform steps 1/2/3 in lockstep, and the initial value is 0, they will both store 1 back. You could use a GCC extension for compare and swap to make an increment safe: 

Interface critique: You should have the caller specify a maximum size for the destination buffer, and error out when there is not enough space. The mark of a good C programmer is to create interfaces which make this sort of condition unambiguous, rather than blasting away on the buffer, potentially past the allocation size. 

Which brings me to the next point. I don't see any calls to . For a structure like this I think it's good practice to have a single alloc function (which is good, you already have that) and a single free function. So let's write the latter: 

Seems like you missed a potential here. If the buffer is exactly full when you hit that line, you'll write past the allocation. 

It has been commented that when working in C++ you should use . Assuming you want to stay with C style strings (or at least understand how you ought to work with them, in case you ever have to), I have the following suggestions: 

Note that I'm not totally comfortable with this method because it has 2 responsibilities: creating an excel file and filling it. Long answer Now you might wonder how I ended with the code above, so let's begin... Filename requirement You stated 

The requirement doesn't state what's the behaviour when there are no cans, so I assumed it is nothing. If you know what the requirement is in this case, I'll update my answer accordingly. Looking at your current method, I think the requirement is not reached. First you erase the old amount of tokens with then you refill the vending machine with 50 cans when it is empty, which looks really strange and induces an unexpected side-effect (see Principle of least astonishment for details). The requirement also states that you should be able to only retrieve one can at time (and not many). Here is how I would implement 

The requirement is fulfilled. However how it is implemented is a code smell now. It's a good practice to have only one main constructor doing the fields assignments, the other constructor just calling the main one with other arguments: 

The hardcoded string for the path The fact that you directly depends on , making the method hard to test 

Bill What does a need in order to compute a price ? A base charge and a distance. These two values must be provided in the bill constructor. The bill doesn't have to know about the . Then, the implementation becomes (note that I have made this class immutable): 

I assumed using a timestamp should be enough (guaranteeing you one unique filename per second). Here is after this refactor: 

Exceptions are (badly) swallowed is closed but not opened in this method. This could be a major flaw because it induces a nasty side-effect. It is a general idiom that the one who opens a resource is the one who closes it. is declared in the , no need to close it manually ! (it will be done automatically) 

Your code includes the optimization of evaluating only odd-valued candidates (by iterating with a step size of 2) because the even-valued candidates are known to contain a factor of 2, and are therefore always composite. This candidate-skipping optimization can be generalized to include prime factors greater than 2, by varying the step size in a certain way. I made a version of your code which skips candidates (values of ) containing factors of 2 and/or 3. This is done fairly cheaply by alternating step size between 2 and 4. Extending this optimization to even greater primes gives diminishing returns for two reasons: The step size adjustment calculation becomes more complex (and slower), eventually costing more time than what is saved by skipping candidates; and higher prime factors exist more sparsely than low ones in the candidate population. Skipping 2 alone catches 1/2 of the composite candidates, and skipping 3 alone would catch 1/3. But if used together, half of the composites 3 would skip were already skipped by the 2 skip, so skipping 3 just catches an additional 1/6 of the composite candidates. Including a 5 skip would only eliminate an additional 1/30 of the composite candidates, and a 7 skip 1/210. I experimented with replacing the floating-point call with an integer approximation, but it turns out that is very fast (at least on my machine). And then I gave up entirely after seeing Vedran ≈†ego's optimization, which is brilliant, especially because as gets bigger, the gaps between calls to become larger, to the point where it doesn't really matter much how slow your calculation is. So, I had to add this to my example, thank you Vedran ≈†ego. One other thing, the loop must terminate. If is signed (like ), it will overflow and wrap around to a negative value. This is a completely pathological situation -- calling with a negative number, plus other things, depedning on optimizations employed. Even for unsigned , duplicate primes will be added to the vector until the process crashes when it runs out of memory. So my example terminates before overflows. I also defined a type, to make it easy to switch the integer type used for calculating and storing primes. I use in my example, because it gives results a larger maximum value at no extra cost compared to . Try if you really want to see the program continue for much longer than you will be willing to wait. 

This also brings to mind... Why a vague name like ? C does not have namespaces and this is a name that could clash with others. Maybe it should be . Also more consistent with some of your other function names. 

Why do you need this? Your loop termination condition is already , so the check almost seems redundant... Now, it does seem like the upcoming and will create problems omitting this, but I would rather re-arrange those than make this loop look overly complicated. Just my opinion. YMMV. 

Then after this block, you can in any place you like, success or failure, even throw exceptions, and COM will still get uninitialized. (Notice I didn't initialize COM in a constructor. This allows us to inspect the on failure without wrapping it in an exception. I'm sure many would suggest wrapping s in exceptions. This is not personally my taste. YMMV.) 

You're right to suspect the , lines, but I'm not sure "leaking memory" is the worst of your problems. If you pass one of these "offset from the original allocation" addresses into or , for example, you're likely to get crashes. The way it usually works under the hood is that at an address just before the buffer, and friends sneak in things like the allocation size, so it can maintain its own data structures ahead of "your" buffer. (It's not guaranteed to work that way, but this is most often the case.) The important takeaway is that if you call , save the original pointer so that you have something to pass to . For that particular issue I would recommend one of the following: 

2. must be > 1. (I'm guessing the standard guarantees that but I'm not certain.) After the update: Now realizing that the allocations are not necessarily zeroed, I'd say it all depends on whether or not the local variable can be used uninitialized, as the only assignment I see is based on that value. Note that , which calls , which calls , seems to initialize the members that the assignments to depends on, notably . It looks like there are lots of size checks for overflow as well, eg: . I haven't given it a thorough audit but I'd say everything I've seen so far looks safe.