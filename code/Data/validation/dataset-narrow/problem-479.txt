This is a big problem. This function is way too big. Break it up. Have different initialize functions (for the different sections of GUI; I didn't read the whole function to determine good sections). Additionally, I have scanned the code several times, and I still don't know why you have on the method. You should almost never have to use this; there are almost always ways to make this unnecessary. This means that you are using some generified type without a type parameter (e.g. instead of ). It is likely that that is unnecessary. 

makes it so a function (or a class) can access the private and protected members of a class. Since you declared it as a , everything is by default public, so friend is completely unneeded. Also note that a function declared as a inside a class is effectively declared in the enclosing namespace, so the two versions above are actually equivalent. 

Good job on making the function static. However, Java's naming convention is camelCase: . I could have misread it as and gotten confused. 

Also, rather than comparing , you should use . Note that it is a functor, so you don't need to wrap it in a lambda: 

This should allow you to sort arbitrarily typed arrays, except for the primitive types, unfortunately (although I did not compile the code). 

Dependency injection looks better. It allows you to clearly separate the database and the other classes of your application. It would also help you test your application because you will be able to test your classes without hitting the real database. I'd also try to decouple the classes you're using in your application and the fact that they're database entities. It doesn't look right that an user or an employee know the database they're persisted to. You should consider having a separate class that abstracts away the database and allows you to do all the operations you need to store and retrieve your entities. 

I'd change a few things to make your code cleaner. Your method does three different things: it extract the message from the context, it creates the intent and it finally launches the email app. What about introducing a class, a , and an methods? is definitely to arrow-shaped. I'd refactor it to separate the logic of creation of the package info string and the code to retrieve the instance. 

I think that at this point you might be thinking at how you could obtain an instance of . I think you should use some sort of factory or build it using reflection depending on what is better in your use case. 

. Inserting something into the beginning of a string or a vector is inefficient. This is because every element has to be copied and shifted over one to the right. Try to avoid this if at all possible. . I recommend using as it's more consistent with other standard library containers, but that comes down to personal preference. 

This means that (almost) everywhere you had to have a special case for an empty sequence, you now don't. For example, you can completely remove this: 

If you wanted to implement the base 64 conversion yourself, note that you are still doing too much work. Your function could be replaced with 

I'm fairly sure that googletest recommends you use quotes on the include. Whichever way you choose is fine, though. 

It's nice to see that you make the random engine . It is, however, not the best to initialize it with the time. You should probably initialize it with a , which uses or the equivalent. You may also want to use . It might look like this: 

I mentioned it on the previous question, but it's important enough to mention again: avoid . See Why is “using namespace std” considered bad practice? 

As my go to first project for a language is a Mandelbrot, I had to implement one in Rust. I'm particularly annoyed by , as I feel like there has to be a way to add the arg length checking to the . I also wish to find a way to multi-thread this in the future. 

Note that you need to include both the start and stop dates but returns the difference between these two dates causing an off by one error (Credits to mjolka for noticing it). For instance is one day but you want to include both these dates so we should add one to the result. 

In addition to the comments in the other answers I'd recommend you to create a function to print the sentences on the screen. Something like 

Generally it looks good, at least to an Haskell beginner like me. I find the use of to be a bit confusing. I admit I had to read your comment to understand why you used it. I think it could also have introduced a bug. What is the expected behaviour for ? Your code returns but I would expect . Was your behaviour intended? This solution fixed the issue. 

You can then define and by simply passing the appropriate strategies to . I think there is still room for improvement. Your code relies on some global state through and . Getting rid of the second one is trivial. You can just pass it as a parameter to , making it even more flexible as it will now support also different combinations of fading strategies and fading intervals. Clearing the timed action could be a bit more tricky. One possible solution could be to make your function return another function that closes over . In that way you will only need to keep track of the function you got from the invocation of and invoke it when you want to stop its action. 

It would result in a compiler error, since the class does not have a copy constructor, because we used . Instead, the code would have to be used like so: 

This isn't too complicated, so there isn't that much to say. Your code is perfectly clear, but there are a couple things that could be improved. 

I recently decided to code some in Python after coding in Java using lombok for quite some time. However, I got bit real hard when I forgot to implement , since Lombok normally does it for you. I decided to try to implement something similar to Lombok's , which I called . Then, I added a similar way to generate a method. How well did I follow python style? I developed this using TDD, so I would like to know how my tests are as well. genmethods.py 

You don't need all these s in the header. As you only use and inside the header, I would expect your includes in the header to be 

Also, your function is doing multiple things: printing/reporting, and parsing/forwarding to . This is not a good thing. I'd recommend removing those and handling them where it's more appropriate: 

The keys are the first two elements of each list, still in a The values are the 3rd element of each list. 

I think you should not really need to worry about that. This is for sure a non-performance critical part of your application and all the objects you create are almost immediately freed. My advice is to avoid premature optimisation and to focus on code readability instead. I'd use some meaningful names. I'd replace , , with , , . It improves readability a lot. You should also consider splitting your code in different methods and make sure that everything has a single concern. Your is doing everything and that's not very good in my opinion. What about moving your declaration to a constant defined at class level instead that inside the main? I'd also introduce a and a methods. Your should look like: 

You should raise the level of abstraction and define the specific types and . In this way you can move the validation of the data where you build the objects removing all the cruft related to the fact that you use strings to represent higher level concepts. You then need to put in a method that returns the corresponding state (maybe using a it is enough, even it is a little dirty). The method you need then turns into checking that the returned is equal to the one passed to the function. 

This function is really big. It's 97 lines long. Break it up into smaller functions. Notice how you have comments for several small sections of code? Those are ideal for turning into functions. Yes, you will have many functions, but the readability greatly improves. However, many of your "functions" can be replaced with standard algorithms. 

It is considered bad to extend . For most purposes, you don't even have to extend Swing components. The only time you'd need to is if you want a custom paint method, so just stay away from it. Favor composition over extending. 

This utility might have a small performance problem. It is harder for current optimizers to optimize this style of object, with a pointer to member function (PMF) as a data member. I know this sounds a bit like black magic, but Stephan T. Lavavej claims that using is bad because of poor optimizability in this CppCon talk. Basically, the optimizer can have difficulty seeing that a PMF stored as a data member is actually constant, making it difficult to inline. However, if you don't store the PMF as a data member, the optimizer has a better time. Thus, it would be more optimizable in general to instead write a function with : 

I also implemented an alternative solution. The main difference with respect to yours is that I generare a list of (numerator, denominator) pairs instead of having two separate lists. 

I think it is a very good practice. As a side note, if you want to design a method like those, I'd suggest you to make the API method final and let the custom behaviors to be injected with the strategy design pattern (if you want to use composition, which is what I like the most) or with the implementation of an abstract method (if you want to use inheritance). In that way it won't be possible to skip, even on purpose, the call to the superclass method. 

I'd structure your program in a slightly different way. First, instead of passing around two arrays of , why don't you introduce a data structure and work with it? It would save you from checking that you get passed two array of the same length, which looks quite neat to me. I think you could also consider introducing a data structure to hold your pair of slope and intercept value. If you do that it will be much clearer what your function does. Since you eventually want to have a function you can play with, you could create a . In this way you decouple the computation of the coefficients that best fit with your data and the construction of the corresponding curve. This enables you to play not only with the curves you fit from data but also with curves you can define from their coefficients. I think that a nicer way to compute the value could be by putting as much math as possible in some temporary variables you define in the block. That could allow you to separate the high level computation you need to perform with all the other smaller steps required to compute some other intermediate results you need. If you apply the changes I suggested you should come up with code similar to the following: 

The code is pretty good, and quite readable. Here are some of the things I noticed: Header guards Your Logger.h needs header guards: 

The placement of a single in the index-sequence version makes the generated assembly identical for both versions. The missing was on the that was doing most of the work in the index-sequence version 

This algorithm is wasteful. The algorithm for addition that we learn in primary school is usually something more like: 

requires that its iterators are Bidirectional Iterators, so that could be your requirement. Do note that a different iterator class may have a different algorithmic complexity, so you'd have to evaluate if there was any change. 

I have no idea what this is by the name. What's the for anyway? What is this the period of? Or is this referring to the punctuation mark? 

Use constants Since you are using numbers to represent what choice the user made, I strongly recommend you store them as constants: 

You seem to be planning to add elements to (hopefully a in) the after the comment. This is a bad idea. Always do the sizing and positioning of your after you add every element you want to it. That way, the will know the size of all its subcomponents to allow for proper sizing and positioning: 

I had to implement an auditing system where the user have to provide a reason he needs to perform a certain operation. When he provides the reason, he can perform freely it for a certain amount of time. Each execution of the operation needs to be logged somewhere. I implemented it using a Continuation Passing Style, which allows me to cleanly handle atomically permission checking and operation logging. 

The updated code looks much better but you could try to extract some more common structure. You can define fading in a general way that allows you to plug in some fading strategies. You already have fade in and fade out but you'll be able to reuse the same code for other 'fading'. 

you can easily determine what is the corresponding mark by going through the list until you find a lower bound greater than the value you have. For instance, if your input value is you first evaluate . is bigger than so you can move on to . Ditto for . Finally you get to , you see that and hence you know you have to return . 

I am on the it's disgusting side. I usually think at extension methods as something that could be useful by themselves. In your case you need to provide some external context with , which could lead to confusing code. Who should be in charge of updating it? In my opinion you should have something that has both the responsibilities of keeping track of the current max values and to select the next one. Also, I'm not sure if you're talking about this selection method, but there they divide the fitness value of an item by the sum of the fitness values of all the items, not by a maximum value. You cannot test it. The calls to and make it impossible. I'd rather make the dependencies on random number generators explicit. As a matter of style I don't like having an empty body for a loop. Given that you want to implement the selection method I linked earlier, I'd probably go for another different approach. I'm not sure yours actually implements it (but I have not looked at it for long enough to be sure it doesn't work as you would expect to). 

Nice comment! It's almost a documentation comment, though, so you might as well make it one (I'm assuming Doxygen format; if this is a doc-comment for some other documentation tool, disregard this): 

No. Don't do this. I get that it's a pain to type out or , but code isn't just for writing. Adding these functions really just make it so that it takes longer to read the code; don't alias these system function calls. Good IDEs would make writing as easy as (something like) (or whatever the auto-complete key is; I'm assuming it's tab), and is often just or . Use those IDE shortcuts instead of these functions you defined. 

Don't use to say that a function takes no arguments. It's a C-ism, and should be avoided in C++. Just write . 

prevents using this function for types such as simple C arrays, or even vectors if the vector uses a pointer as its iterator. Prefer . I find that that's a mouthful, so I tend to use : 

But then, from here it is clear that you are taking filenames that you will open inside the function to write to. This is not ideal. As a user, I'd want to use or :