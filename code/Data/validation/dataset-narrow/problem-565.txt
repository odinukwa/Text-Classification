Because you are creating a generator in each iteration with the same seed, the value you get from your distribution will be the same. So no, this is not the correct way to use the new random subsystem in C++11. You need to pass in a distribution by reference to . Also personally I don't feel that random numbers should be a part of a sorting algorithm because performance becomes non-deterministic. I would suggest you use one of the other pivot selection strategies. Also your algorithm requires the use of random access iterators. Might be worth noting. 

this condition will always be true. And you are never removing from the list (if you were, you would get a . So the check is wholly redundant. So you loop over all of the futures in and call on your . This doesn't make sense to me, if you're going to call use a loop that describes what you want to do better. This is further strengthened by the fact that you never use the loop variable. Maybe something like this: 

API and Naming To me the names of and are not very apt as they don't reflect the way I think about a queue and they don't match the naming of the STL queue. I would much prefer if your class implemented the same API as where applicable. Or at least used the same terminology such as and . Performance This: 

Here and are both \$\mathcal{O}(n)\$ where \$n\$ is the number of spots. This means that for example the inner most loop of : 

Your approach is completely wrong. There is a difference between escaping and validation Validation is the act of making sure a piece of input conforms to certain rules (be it logical, or business rules). It should not be used for security. You can't catch all possible edge cases with a blacklist, don't try. Escaping (or Sanitization) is the act of escaping characters with special meaning and replacing them with another character or a string that will have the meaning of the literal character in the target context (for example, replacing with in HTML). Escaping can and should be used for making sure nothing with special meaning enters the target context (HTML, MySQL query, JavaScript, etc). 

Yes, it is safe. No, it is not a good idea. Don't mix application logic and configuration with the database, the database is used for permanent storage of data. Use a file (json, ini, xml, whatever) which is named the same but has different contents in production/dev environments. Then, it's as simple as: 

In the above example the nonBusinessDays of the week are SATURDAY and FRIDAY, and 1st and 2nd of June are holidays. In that case, 3 business days from now is June 5th. This can probably be improved further, let your imagination run wild :P 

If it doesn't match, prompt the user with an error message and tell him to try again. Your job isn't to try to extract a good category from a bad one. At most you could just correct the case with if you want. 

There are several advantages to writing proper HTML and using semantic tags. Instead of asking yourself "How should this look?" Ask yourself "What does this mean?". What does it mean for a text to be red? Does it mean phasized text? Maybe text? You can always apply the on top of that (or even better, with a classname). What are the advantages? 

In addition to @mdfst13's excellent answer I just want to point out one small thing. When you are comparing euclidian distances or radii of objects you can do the comparison squared and get the same result. Formally, \$d \gt \ell \Leftrightarrow f\left( d\right) \gt f\left(\ell\right) \$ for any monotonic function \$f\$. The same is true for other inequalities such as \$\lt, \ge, =\$ etc. Which means that: \$\sqrt{s_x^2 + s_y^2} < \sqrt{v_x^2 + v_y^2} \Leftrightarrow s_x^2 + s_y^2 < v_x^2 + v_y^2 \$ for two vectors \$s\$ and \$v\$. In short, when comparing distances you can always compare the squared distance for the same result, as squaring is a monotonic functions iff the argument is larger than zero, but this is rarely a problem when comparing distances (or radiuses). This means you can avoid doing a costly square root operation in tight loops in many game related applications. Also I do believe that is slower than because is much more general and handles non integer powers. 

The time complexity of is linear in the number of elements. As the test progresses you'll end up with at least quadratic time. You need to swap your s for something with a quicker . I would suggest which has amortized constant time in look-up. 

Time complexity Let's have a look at the time complexity of your algorithm. The bound is: \$N<2\cdot 10^6\$ and we want to compute: \$\left(\sum_{i=1}^N i^i\right)\mod(10^{10})\$. Naively computing \$i^i\$ like you are doing will require \$\mathcal{O}(i)\$ operations. Computing the sum \$\sum_{i=1}^N i^i\$ will cost you \$\sum_{i=1}^N \mathcal{O}(i) = \mathcal{O}(N^2)\$ operations. Or in other words you're looking at the order of \$N^2 = 10^{12}\$ iterations of your inner loop. Or if every iteration of your inner loop take 10 ns (i.e. about 10 clock cycles on a 1GHz CPU), you're looking at \$10\cdot 10^{-9}\cdot 10^{12}=10^4\$ (\$10\$ cycles, \$10^{-9}\$ seconds per cycle) seconds which is about 3 hours. However by using Exponentiation by Squaring you can reduce the time to calculate \$i^i\$ from \$\mathcal{O}(i)\$ to roughly \$\mathcal{O}(\log_2(i))\$ meaning that your expected complexity to calculate the sum: \$\sum_{i=1}^N i^i\$ is \$\mathcal{O}(N\log_2(N))\$. For \$N=10^6\$ you're looking at about \$2\cdot 10^7\$ iterations (\$\log_2(10^6)\approx 20\$) which should take our hypothetical computer about \$2\cdot 10^7\cdot 10\cdot 10^{-9}=0.2\$ seconds to compute. So to fix your performance you need to use a better exponential computation, there are plenty of examples on the web. Your code Now to look at your loop: 

Also, what's the need for here? How does it do things better than just making a new object and working with that? A few WTFs when going over your code: 

This User object is different, it doesn't know where the details come from, they are injected from that magical place outside of the object where it doesn't know anything about. This User could have come from a database, he could have come from session, a file, a REST api, or I could have just made it up for testing purposes. So how do you get the details from the database? You use the Data Mapper pattern. 

Bonus we can make it more general by passing the key generation function as a second parameter to , then it can work with every array, even if they aren't functions: 

Now for the more juicy stuff. Is your library useful? Why would I, a user, want to use your library instead of just writing HTML? Or generating HTML for that matter? The usage code seems a bit over-engineered, too large and "clumsy" to actually be useful. Truth be told, it's a nice project to improve your knowledge with XSS and the structure of HTML and perhaps even OOP, but it's not actually useful in the real world, because generating HTML is simply easier. 

where is a key delimited by dots, and returns an object in the form of a tree, where you can access the value by traversing the parts of the complex keys as keys in the object (see examples below). The function 

In C++ we usually use for generic template type parameters. Nest implementation classes The class is an implementation detail of and should thus be a nested class. Normally we prefer terse but descriptive names, would be preferred to but even better, if is nested you can simply use as it will always be clear from context that it is a binary tree node. General comments on : 

It deduces that the function always returns the same value and it completely removes all code and just returns a constant! It also removes the calls to and as it realises they are pointless and don't affect the output of the function. If that is not impressive, I don't know what is. :) So I would like to take this opportunity to reiterate my first piece of advice again: Clearly express what it is you want your code to do. Let the compiler worry about generating good machine code, the compiler is likely much better at it than you are. 

Since noise is essentially random, your large block of chains is causing severe CPU stalls due to branch miss predictions. You should create a look up table (LUT) and quantize to an integer which indexes into the LUT. This should get rid of many of the miss predictions. Also note that is invariant under the inner loop and you can move that calculation to the outer loop, although your compiler should already do that if it is optimizing. Edit: Also, your code doesn't look like perlin noise to me but I could be wrong. 

What's wrong with your sanitizing Sanitizing is an important job of the server. It makes sure nothing nasty comes in and affects what your users are seeing/experiencing. Sanitizing is done as late as possible, for a simple reason. When the username is entered to the database, you shouldn't make assumptions on who is going to use that username. It could be your application later on, it could be an API you may or may not choose to provide one day, it could be a desktop application or a mobile application which does not care for HTML formatting. When you extract that value from the database and are about to put it in HTML, that's the point where you should escape for HTML using . Maybe at a different point you may want to output it to a JSON response for an API, in which case, is good, but not as much. 

And have the PHP handle the serving of the requested file. Getting Fancy You can even use and to rewrite URLs like this: 

Now, your object can hold an array of other objects, who he's friends with! You can do all sorts of cool stuff with that, like listing mutual friends (since those Users have their array too!), displaying a list of friends on the page, or just figuring out who has more friends. The object is commonly known as a Domain object, it's an object which is part of the Domain Logic or Business Logic, i.e. the actual application, the actual purpose of the application, the part that does the actual work.