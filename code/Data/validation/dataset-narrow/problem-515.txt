Your code does not read numbers from the "console until input isn't a number", but reads 100 inputs strings from the console and returns those that can be converted to integers. If you want to read numbers from the console "until input isn't a number", you could do something like this: 

3) For the fun of it, you could consider: Because you basically do the same same loop nested three times, it could be a candidate for a recursive function iterating over each addend and yielding all the positive sums. In that way you could generalize the algorithm to handle any number of addends... 

Some minor points: 1) You don't really need the variable, so just do the math in the call to TryGetValue(). 2) If are all positive you may the loop if . 3) It is stated that there is only one solution per input, so you can skip the check . This will never be true for the nums that add up to the target. As for the rest of nums it doesn't matter. 

Synchronizing within the constructor makes little sense - your object can only be constructed in one thread. Your fields and one method are , meaning that one could extend the class and modify the map outside of a synchronized block (for example), breaking your synchronisation contract - this is possibly undesirable. It may be useful to (re-)read Effective Java #17: Design and document for inheritance or else prohibit it. 

Your naming is funny and all but quite counter-productive - names primary goal is to explain what the code does, not to give a lol moment (I know, boring). 

Regarding your question about efficiency - a more efficient way (less time to code and fewer lines of code) would be to use existing libraries. With Java 8, you could use the java.time API: 

Overall your code does what you intend and that's a good start: to print a diamond with numbers. The first improvement could be to handle an "arbitrary" sized diamond: 

All in all All in all I would implement the class something like this (without any threadsafety considerations): 

3) Have you considered using and let the item class implement interface to keep track of collection and item changes in a dynamically and event driven way? 

The latter is not meant as a better choice, just an example of another approach. The caveat is the inner list object. 

To me it is much cleaner. IMO the type definition of Instructions do more damage than good resulting in an unnecessary double match in and . I think it's a good idea to extent the keypad and use it for validation of a step. My solution would be something like below. The concept is to think of the keypad as a coordinate system and then convert the result point of each instruction sequence to a key in the pad: 

You are picking the characters randomly - so whatever the order should not have any impact on the randomness of the password. 

Once you have done that, you can start optimising the method, for example by caching the results as you calculate them. 

A good improvement would be to store each tweet as a object instead of using Strings only. It could look like: 

There is no need to add to your methods signature - this is an unchecked exception. You should mention any exceptions (checked and unchecked) in the javadoc though. You abuse asserts - they are supposed to check things that can't happen, not to validate external arguments. You should replace them with more standard idioms, such as: 

First of all I'll upvote the question for the effort. You split the problem into subproblems and you show good understanding of C# idiomatic as well as general programming skills. On the other hand I think you overcomplicate the solution, because your general analysis of the problem is a little too "chessish". Instead I would try with some kind of "mathematical" model: 

Here the groups found so far are given as argument to the function and finally returned as the first part of the resulting tuple (with the remaining items as the last). Yet another aspect to consider is performance... 

A chessboard is an 8x8 matrix or coordinate system. A chess field can be converted into a matrix coordinate set (x, y) by: Two fields are on the same "diagonal" if their offset has equal length in x and y: 

Your benchmarks look fine. Instead of using the BlackHole you could probably have simply returned the number of sentences although that would have created an (unlikely) window for optimisations and using the BlackHole is safer. 

It is unclear what and are in your code and you are mixing things together which makes fixing your code harder. I therefore suggest refactoring your code: 

which is more compact (7 vs 18 lines) and I think also clearer (fewer lines of code to read => fewer lines to understand). 

The brackets are redundant in , and also in . You say "The 65 comes from the CHARACTER_SET length, which I have found out before". Well then make it clear! Ideally your code should be self explanatory. So instead of using , use . is redundant: is already a String... Strings in Java are immutable, so prepopulating the string with spaces is a waste of time because that string will be discarded anyway. 

But this will halt the calling thread while HSecondCounter ticking every second infinitely with no way to stop it. So this is not useful. 

To avoid the overhead of cutting of the length you could use an enumerator instead like this in order to handle the first group separately: 

2) The names sumI, sumJ, sumK are somewhat misleading because they aren't sums. Better names would be valueI, -J, -K 

Beside that I would change the flag to an too, because you can then distinguish between more levels like: 

Because of the flag-behavior of ConsoleModifiers.Control it will be true if any combination of Modifiers are pressed that involve . It would maybe be more useful to make it more distinct like: