First up, the shell variable is already defined in bash, and is the log-in name of the current user.... so, if you log in as 'rolfl' then will print . There are a number of programs and other systems that may be confused if you change the environment variable the way you have. Next, I don't think that the symbolic link you create does what you think it does: 

This problem is well understood, and all the Java number-type classes are Immutable (Integer, Long, Double, BigInteger, BigDecimal, ......). is a really good example of what you should be doing here. Have a look at it's Javadoc. Notice how all the mathematical methods do not modify the , but return a new with the right value. Putting all of this together, your class should really look something like: 

The benefit of two indexes is that you can keep the logic more readable ... ("more" is relative) as each index moves by one character at a time... and a space counts as 3 characters. 

The outer loop does a index-only range on the slice, which in itself is not a problem, but logically it is . Again, this is not really a problem, other than the fact that you are looping the indexes of the slice. The problem is that in your inner loop, you make that index-loop obvious with the full-syntax loop. I would be tempted to use a full loop for the outer loop so that the index functions on and are obvious. The other thing I would suggest is that you supply a function for the parameter, instead of a . While mentioning parameters, it is not common practice to use upper-case parameter names. These parameters are never exported, so should be lower-case initial, and mixedCase for multi-word names. If you supply a function for the sort order, then your sort function is improved as well. Consider: 

It finds the location of data to keep, and moves each 'keep' span just once. No data is ever moved more than once. It works by keeping a cursor of the start of the copy-zone, the start of the following match (if any), and then it copies that region on to the end of previous content (advancing that copyTo variable as needed). It was only after I implemented the solution myself that I realized how similar the routine was to Edwards. I do prefer my naming though. The significant performance-affecting difference is that I only have to perform the on the final (shortest) span of unmatching code. That is essentially the only difference I can see in the effect of the algorithm.... and, this difference will become more and more apparent as the input String size increases. When I run it through Edward's harness (I ran without William's code...), I get: 

This strikes me as an occasion where a custom method with positional format indexing may help (Formatter ). It is a little-known feature of Java's String.format / Formatter class, that you can reference values by their position. Consider the following methods: 

You are intending to return an int value, yet you return a for the block between and . In PHP, false is not an int, and is also false-ey. Then, in the 'else' block, you return , which is 'true-ey'. I am uncertain that your char ranges are correct. In UTF-8, the invalid blocks are inconsistent with , there are multiple valid UTF-8 encodings in that range. I am not certain you have your conditions right. Is there something I am unaware of? 

Note that the code above handles all the basic situations you describe - it has the ability to feed items in to the queue if the idle count is low, but that can be "turned off" by setting the minIdle count to 0. In addition, it restricts access to the underlying queue by fully encapsulating it, and not exposing it. The implementing classes only need to worry about how to handle a situation where an instance is not available "in time", and it has 2 choices - either give it a new instance, or throw an exception. For convenience, the actual supplier is passed in as well, so it can use that if needed. If you are curious, I set up a "stupid" little test system to run the code. By messing around with the different thread sleep times, you can trigger different behaviour: 

One note to consider first.... it is a 'common' model when doing matrix-operations in high-performance computing, to 'flatten' the matrix in to a single dimension. For example, a 3x3 matrix will be flattened in to a single-dimension of 9. The (row,column) indices in the flattened matrix are calculated as follows ( = matrix-row, = matrix-column, and = one-D index) 

This function may, or may not, do both. The JavaDoc indicates that this function will return the value that occurs more more than half-the-time, and that if there is no such element, the result is undefined. This makes the method useless, because anyone calling the method will then have to re-scan the entire data set to see whether the method is returning a right answer, or an undefined answer. Since repeating all the work to check whether the method produced a reliable result or not is required anyway, you may as well do it in the method itself, and then return a result which removes the non-determinism. 

creating a new Color every time is a little severe. You can do a few things here, for example, if your color palette is limited, then cache the individual Color instances. I know it sounds petty right now, but, when you add it up there are a lot of new Color instances created. What you should at minimum do, is track your last Color used, and only create a new one if it is different. Pull the outside the loop, and have Pull calculations outside the loops where you can... and continue/break when you can too. 

The first method breaks the digits in to their 9 rows/lines. The second method runs through each digit and builds a single line for all the digits. The digits are separated by some spaces, and the lines are separated by newlines. Input to Digits The missing piece now, is how do you convert the input line to the available digits. Here's one way: 

In summary, the toString() method should produce enough data to debug problems with the object content. It is used occasionally for a 'contractual' representation of a value (like ). But, in general, toString() Is a tool for the PROGRAMMER, not for the user. It is there to assist you when things go wrong, not when they go right. In my real Job I file bugs against code (and pursue the bugs relentlessly) which throws exceptions where the exception has an in the message. I also mentally +1 people who's programs produce good detail during exceptional conditions. Now, in your particular situation, I think that you should use the toString() method to represent the state of your Customer, and, because the display-conditions for your customer are different to the internal state (e.g. display needs to be UPPERCASE,) I think that you should have a different mechanism for displaying the Customer than the toString() method. In other words, the information you will need to debug a situation involving a Customer (something printed in a stack trace or debug session) is different than the information you want to display on the screen. 

If you need to do something more special than just the 'needs modification' test, for example, you need to distinguish inside the block between these conditions, then I would recommend an Enum with a static method, for example: 

This can all be done in a single loop, with very little data needed to track the details. Loop over the data... for each value: 

The code above assumes a non-empty line in all cases, otherwise you get IndexOutOfBoundsException. This is the sort of issue that should be identified and covered with Unit testing. This also leads on to the fact that you appear to be reinventing-the-wheel, and should consider the suggestion for using java.util.Properties. Despite that suggestion, I have to weigh in on the / theoretical discussion as well. Loop entry and exit points are already the targets of branch instructions in the compiled (JIT or Byte) code that Java produces. These branch points are well managed, and have clean, and well documented entry/exit conditions. They are nothing like the concept of a GOTO. I have, over time, become very comfortable with using them, and they are no more distrustful than an early-return from a method call. In fact, conceptually, that is what they are, simply an early-termination of a block of code that happens to be in a loop, and the termination may allow () or disallow () further iteration. I would not recommend using these statements with impunity, but, the fact that is the natural syntax in the statement gives some hint that it's OK to use. It is the right tool for some jobs. Use it when appropriate. 

Your code is neat, and structured just like I would expect to see Java ;-) - separate files for each "class". In your case, though, the separation in to files is probably over the top, and if you are talking idiomatic go, I would not expect to see separate files for the NotGate and the XorGate. There is a small bug in your code, you use: where that should be a and not a . You have declared the interface, and I understand why you have it, but there's a subtle thing about interfaces in go, they are not the same as Java. Go uses duck-typing, and, because you have an method on the pointer to , it is also actually a too. You may not be expecting that. You have an inconsistency in your pointers too. You keep your as pointers to your instances, but you keep your as the actual Gate values. I would expect that your methods on the and should be on the pointer to them, not on the actual gate. Thus, your methods are currently: 

never use exception handling as part of the routine/regular code path in you program. Most Java VM's require significant locking and processing to generate the actual exception and its stack trace. I have seen 10% performance improvements in large commercial applications where simple pre-validation of common exceptional conditions saves a huge amount of processing resources. What if the user enters the non-existent class name , they get an back. In the event that the fails, you do exception handling and return null. If the program asks for the same value again, it will do the full search again, and so on. If the class exists, it is not normally very slow, but, if the class does not exist, the has to search the entire classpath. Cache the results (of both the successes and the failures so you only have to call once.