Ultimately I just want an accurate measure of bandwidth utilization. If I can get this tool to display that, that would be great. If there is another tool which can be used, that would be great too. 

I'm trying to shrink a raspbian image following this procedure: The procedure works fine and I am able to get the shrunken image to boot correctly in a raspberry pi. However, there is a step in the procedure where we improve the compression of the image by filling empty space with zeroes. This requires mounting the image on the filesystem like so. 

I found a sample wlan.conf file that might meet my needs here but it doesn't the display is the same. 

I have been using the paho-mqtt client successfully with python 2.7 on raspbian stretch, but I have a need to use python 3.5 on a new project and paho-mqtt does not appear to install or build for that version of python on raspbian stretch. when I try to install via pip ... 

I doubt if using USB would be the main cause of delay. In what language you write your noise cancellation? In C++ you might make good use of the FFTW3 library, which is very fast and well written. 

I'm not sure you can accept this as an answer, but maybe you need to know what happens when the pi is powered off as by disconnecting the power with a mechanical switch. For my purpose I needed this approach, so I gave it a try recently. I placed the switch between the 5 volt cable. I didn't get in trouble after about 50 times toggling between "on" and "off". Also I tried to switch on/off with really quick intervals, specifically when the file systems were being mounted. After each "power off" without issuing 

After that i went to Raspberry Python 3 to do the same thing, but nothing happen in Python console when i tried to run it. the console cursor just sit there doing nothing beside blinking, but when i try to run it from terminal by typing and followed by file directory, the text just appear like nothing happen. I don't know why, but i'm definitely missing something here. can i actually run this on Python 3? and why the text are not shown in Console that called from IDLE? 

i've changed the metering mode to 'spot' dunno if that make a different but the effect seems more predictable in this mode. i already change it to all of it's available option but the white balance? is still drifted in one or other way. 

If you want realtime html5 audio on the receiver side, I would definitely recommend a streaming audio solution. CPU, network and memory load is probably much less compared with the solution you described. Icecast in combination with Jack for streaming audio seems a good solution at first sight. Icecast is well documented and works fine for audio output. But it might get hard to get Jack working on a PI. You could also try an equally good combination of Darkice and Alsa, which is described in detail here: $URL$ If you want to continue with your approach, you might want to convert the raw audio data to MP3 before you bring it to the ssh pipe, just to relax the bandwidth and file I/O. 

Currently, my system is only producing 10 FPS out of 20, which is my target. I'm barely hit 15 FPS in single grab-and-show simple code like this: 

I've been trying to create a program that split few different section of my main OpenCV program to increase fps. The first thing i ever think of is the Pipe() function from my friend. I've tried this 'default' code below in python 2.7 on Windows 10 to learn the basic first of multiprocessing: 

Basically no, you either need a buzzer for simple BEEP stuff hooked to one of the GPIO or using HDMI adaptor that contain an audio jack. for more complex, a bit permanent solution you can build one of pwm based audio like what Bj Black already mention 

I have done surgery on this image by (1) using gparted to shrink the file system, (2) fdisk to change the partition table and (3) truncate to to remove the unused portion of the file, as specified by the procedure. The image itself appears to be okay insofar as I burned it to a microSD card and the raspberry pi booted successfully. I am mystified as to why I cannot mount the file system following the recommended procedure. I am doing all of this inside of a virtualbox (5.2.6) virtual machine running ubuntu (17.10.1) where the host os is mac os (10.13.3 Beta). The image file itself resides on an external hard drive which is accessed by the vm via a shared folder with the host os. One suggestion was to extract the file system from the 2nd partition to a new image and then mount that directly. This would allow mounting without specifying an offset. This seems a little extreme. 

I'm currently trying to develop image tracking using color in Python 3 and OpenCV. But i am facing problem in PiCamera. At the moment, i've done some method to fix white balance, shutter speed, and other stuff. But i can't get something fixed yet. i assume it was a white balance that drift. this is my setting: 

i thought it was the 'I/O' bottleneck stuff, so i went to Multiprocessing code which is basically polling the frame whenever it is available without waiting for each time camera capture frame to complete (that is what i'm currently understand). but there were no significant different on FPS counter or i must say, only 2 FPS increase. This is my Multiprocessing code: 

In sort. No, you cannot modify IDLE easy enough without dismantle IDLE core code or something. Instead, you can use Geany (in raspberry or linux stuff) or Notepad++ with your own RUN-command. But with a drawback, even this is not in the scope of question. See, the Geany and Notepad++ is only for printing stuff in multiprocessing or multithreading code. It's not mean to be a debugger or some sort. 

So you have ssh connection but do have a visual on the leds? If you are using ssh the network connection is lost before shutdown completes. You'll notice that the network connector leds stop blinking before the green led on the board stops. Some processes might take real time before they are actually stopped after shutdown has send them the TERM signal. Although the TERM signal is send before the network is brought down, some processes might still being busy to stop. Therefore it is difficult to know exactly on beforehand what the last blink of the onboard green led will be. If you want to be sure not to lose data of jobs you started yourself, you'll need to quit these in a proper way before the shutdown. Other jobs are better keeping care of by the shutdown process. I guess waiting about 5 seconds after the last green blink is safe for a new boot. If you see a 'dirty bit' report during boot, you know that you have powered off too quickly. You can check the file /var/fsck/checkfs whether dirty bit was set or not. Dastaan has the same experience as I have, 10 times green blink seems to indicate that shutdown completed, but I haven't found any documentation about that.