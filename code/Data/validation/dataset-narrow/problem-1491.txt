We can then have a line that says “print_sum(1,2)”, and the computer will print the sum of 1 and 2. Here, “print_sum” is a verb, and the parameters are the objects of that verb (the implicit subject is the computer, of course). Thus, saying “print_sum(1,2)” is a complete sentence. “print_sum” is an action, and putting it in your code tells your program to perform that action. On the other hand, we can have: 

Here, “sum_of” is a noun. “sum_of(1,2)” is not an action, it’s a thing. Having a line that consists of nothing but “sum_of(1,2)” wouldn’t do anything; it’s not a complete sentence. However, it can be the object of a verb; for instance, “printf(sum_of(1,2))” would be a complete sentence. Advanced programmers naturally go back and forth between treating functions as verbs or nouns, and sometimes use them as both (that is, they use the return value in a calculation while also taking advantage of their side effects), although many people frown on such behavior. Your students clearly aren’t able to distinguish these two attributes on their own, so you need to make it more explicit. Naming a noun-function “add” really isn’t helping; that’s a verb-name, and so your students are going to be expecting it to be used for its effects, rather than its return value. If you were explaining in English how to calculate the norm, would you say “Take the square root of add the square … “? Have your students pay conscious attention to whether a function is being used as a noun or a verb, have them give them appropriate names, and model this by giving your functions appropriate names. If a function is being used as a verb, then you can just run the function, and whatever code is in the function will be run. If you’re using the function as a noun, however, then you need to tell the program what value to assign to the function. That’s where the “return” command comes in. The “printf” command is still in verb-land. It’s doing something, not being something; if you write printf in sum_of, you’re telling the program what sum_of does, not what it is. When you write “return x+y”, on the other hand, you’re telling the program that “x+y” is what sum_of is. 

Another metaphor is an office worker with an in-box and an out-box. The worker corresponds to a function, the in-box corresponds to the parameters, and the out-box corresponds to the return value. We can also imagine something analogous to printf, such as the company twitter account. When students put printf in a function, and then try assigning something to the function, the analogous situation is a worker tweeting the result of instead of putting it in their out-box. 

STOP Planning Time to code (Time to write a test, then code): Using test first, write the code to draw a blade of grass. STOP Coding Time to plan 

What is needed A box, that you put all of your votes into, and out comes a count for each candidate. Possible solutions How do you know that the output is correct. Ah that is easy, you produce an audit trail. But now we have no anonymity. So we add encryption. But for it to be audit-able, anonymity can still be broken. (If you can check your own vote, then I can check your vote (if I torture you long enough, then you will give up your key). A solution that works, but does not use a computer. The many boxes - you walk into a room (box1), and show your ID, your name is removed from the list, and you are given a voting sheet. - you walk into a subroom (box2), and make your mark on the sheet. - you then fold(box3) the sheet. - you leave box2 and walk to a locked box (box4), and place your sheet into it. - at all times observers (from all interested parties) are walking around box1, to check that the rules are being followed. - at the end box 4 is sealed. - latter box 4 is opened and the sheets counted. With lots of people watching. A set of totals is produced and announced. The sheets are put back in box 4, sealed and locked. I have probably missed some detail, but this solution cannot be implemented electrically, because there is no way of putting people into the electronic boxes to observe. Some videos on this The problem Some solutions I found a problem with all of these solution, as I was watching it (Did not have to sit and think for days). Other stuff 

If leaning Object orientated, then I believe that learning Eiffel first is quicker. [This is not based on my teaching experience, it is based on a claim of Bertren Myers. Any my experience as a programmer. When I learnt Eiffel I realised that I did not know C++, then I knew C++.] 

We are often asked to plan: We are asked to make lesson plans; When I was a programmer sometimes I was asked to create a plan; We are told to ask our students to plan their projects. However there is often a problem with this: 

This helps them at least understand why we need to program. After this I give them an exercise on "giving instructions to someone". Intentionally ambiguous so that they can easily misinterpret it in hundred different ways. Like ask them to get me a Peanut butter and jelly sandwich the next day and we'll snack it in the class. Say it's for "me" (i.e., the teacher). Intentionally critique them like "but I wanted it toasted" or with "less butter" etc., Students usually go "But you didn't tell us that! How do we know?". That's exactly what you want! Now educate them to the benefits of being precise! When you give instructions to a computer you have to be very precise. With humans the more ambiguous you are the more confusing things get. So, now we come full circle to why learn programming? It's the art of being specific - that is what we want to teach/learn. No matter what job you do, it'll come in handy. You'll realize what it means to be specific and "how specific" is good enough. The act of talking to a machine is just a fun way to teach you this. You may not use it, but at least you'll know something about it! I've had great success with this with kids of all ages. It helps sink things in. Know why it's useful and what's the point are the best questions IMHO. 

A computer is blind conceptually speaking. Even if you gave it a camera, it cannot "see" per se. It has a translation of what is viewed to bits. Now to the blind student. Image Processing is similar to how folks without sight process things - they "feel" their environment for "signals" and make a conclusion about what it is. A computer does the exact same thing, but with math. Ask them to feel a stick. Easy. Now draw the stick on the floor/paper and ask them to say if a stick or triangle exists on the paper. Really hard. Ask them how would they know if a triangle is on the paper. Feel the edges? Anything else? How about everytime there's a triangle a new sound is heard? Be creative. Now talk to them about "rasterization". Think of handling them one sliver at a time, and if anything is different by feeling, they note it. Can they "conclude" a triangle after seeing various cuts of the paper? This exercise can be naturally extended to Image Processing and then math can be explained. Computer Graphics is different. It lives in the visual plane and the idea is to "draw" it. A good introduction is this: Problem statement: Draw a line on a graph/matrix and each "cell" must be filled in. Which cells to fill in between points A and B when "drawing this line". Extending this to blind students could be done with toys/pins etc., How would they know which spots to "fill in" to get as straight a line as possible? What does a "straight line mean"? This discussion could lead to things about using a line's slope (i.e., math) to figure which pixels to color on a raster display. Same thing with Circles. I'd start here first. Once that's done, to move to transformations - moving things in space. Easy to feel and then take to the math. I haven't worked with the blind, but I imagine such exercises/parallels with their sensory world could be useful. 

Summary Not all IDEs are the same. Not all editors are the same. You will have to look closely at your editor, IDE, to see if the IDE provides anything more, and does not make things too much more complex. 

The book has the philosophy that exceptions are only used for program bugs. variance, invariance, preconditions, and post conditions. Everything else should be checked traditionally. You will be surprised at how much simpler this makes things. You hardly ever see or use a catch clause. The philosophy makes it easy to get things right: if you forget to check an input, or have an out by one error, then the program will tell you that you have a bug, and tell you where it is. 

We then introduced loops. Then we studied the code to find patterns. The code for Square is used a lot, can we reuse it. Put it into a subroutine. Then we did pattern matching to see that drawSquare, drawTriangle etc are similar. Introduced parameters, and create drawPolygon. I also experimented with giving them code that I write, and asking them to modify it. (this was done on last lesson of term with a set of classes. We got to python very late.) Next time I will spend more time on getting them to read the code, and making a prediction of what it does. I will provide two sets of code, one using subroutine, with nice names, the other without. I will ask then to predict that they do, and to also evaluate which one is easier to read (to make this prediction). This should show one of the advantages of subroutines/methods (readability). Readability is the most important property of subroutines/methods. Code reuse in secondary, memory is cheap. However reuse is important, as it makes code consistent, and easier to fix (only in one place). Therefore after they have had time to discover the reuse property, do an evaluation that focuses on consistency and bug fixing. Order of teaching I have been considering order of teaching. Here is some of what I have come up with. I am using partial sequences: that is describing some things that should be taught before some other thing. From these we come up with a sequence, to teach (some parts of this order may be arbitrary, as long as we obey the partial sequences). [notation: represents “is taught before”]. 

In like languages (C, C++, Java, C#, …), always use in the form (there may be some exceptions, but rare). So you are using to construct a foreach, as the language does not have the higher level structure. (C# has ; C++ has library implementations; Java has foreach, but uses keyword )