Can you see how the Potentiometer has the two Red wires in the wrong place (swap them to fix it) so that if the wiper (which SHOULD be connected to the Red wire of the Buzzer I believe) is at the bottom of its travel (near the Black wire electrically speaking, then, when the switch is pressed, it SHORTS out the 5V supply to ground. Also, R4 is redundant as the circuit seems to be - its effects are entirely repeated by R1-3! Also, this is only going to work so that the buzzer makes a sound when the button is pressed, if the buzzer is a device that accepts a DC voltage as a power supply and uses that to power an internal oscillator to drive the sound producing element inside. Not all "sounders" work like that, some need to be driven with an AC voltage (they do NOT have an internal oscillator circuit, they need an external one). If the buzzer is a device that takes a DC voltage and makes its own sound, then feeding the supply via a variable resistor as a potential divider is a poor design - for a good rule of thumb the amount of current that can be taken out of the middle of the divider (the wiper contact on a potentiometer) should be no more than say a fifth or better no more than a tenth of the current following from top to bottom. A better arrangement would be to disconnect the black wire from the bottom of the variable resistor altogether and then the existing mis-wiring of the other two connections to the variable resistor is not important, so that the nearer the wiper gets to the connected end the more current/voltage/power gets through into the buzzer (and less gets lost in the variable resistor) and it should get louder as expected, depending on the relative resistances that the buzzer and the variable resistor have, you will only get any sound from the buzzer when the wiper is pretty much towards the connected end. 

Those "Two Arduinos via i2c" sound suspicious to me. The Pi's IIC lines have the pull-ups needed TO 3.3 Volts. The 3.3 Volt supply is VERY limited (50mA TOTAL IIRC) - so two things come to mind: 

A close inspection of the photo shows what looks like two wires going from the small circuit board with a micro-Usb socket towards the Pi. The circuit board is also connected to a purple battery and has a small (illuminated) blue LED and what I think is must be a key-switch which would make sense to have a controlled (needs the key) on-off action. I believe the small PWB is a boost converter that takes the 3.7 Volts from the battery and boosts it to 5.0 Volts which would be present on the power terminals on the Usb connector. The two wires that would seem to carry this power to the Pi are the end two wires on a 40-way ribbon cable that is connected to the GPIO connections of the Model A+ Pi. Sadly those two wires would be the 3.3V OUTPUT from the Pi (the Red edge wire on the ribbon cable) and the 5V Power rail - normally an output on the Pi but can be used as an input (the second wire in the ribbon cable, which like all but the first is a plain grey). Result: 5 Volts DC is being applied between the 5V and 3.3V lines - This is most likely to have damaged or destroyed the Pi! It is possible that the circuit might have worked if the correct wires were used - unfortunately they were not. R.I.P. 

It is a pity that the Raspberry Pis do not have GigaBit Ethernet but it is at least theoretically possible to have swap space on a network device - the Linux Terminal Server Project can offer it from the server to the clients according to this item on their wiki. I found a Foundation Forum topic "Tip: Swap over nfs" that shows how someone who already had some NFS mounts already in place used a swapfile on one of them and mounted it via a loop-mount (possibly needed because Linux does not allow a NFS mount to be used directly). Given that the remote swap-file will hold data that the OS must not lose I'd only consider this for a wired Ethernet network - a wireless link would be too fragile IMHO. Also, of course you must not allow the remote server to be shut-down without turning the swap off and allowing it to completely empty first! 

It may be possible to design a suitable circuit with a set of "super-capacitors" batteryuniversity.com article & Wikipedia entry and something like what you get from an on-line auction site if your search for a "3V to 5V 1A DC-DC Boost Converter" - you would another (say 5-25V in to 5V 2A(?) output Buck-Boost") converter to drop the 12V (well 13.8V) Car Supply to the 3 to 5 Volts needed to keep the capacitors charged - then the first converter uses that to power the Pi. You'd want to monitor the incoming 12V to detect it being switched off and to tell the Pi to shut-down (like the UPiS devices in the other answer does!) You would also need some inrush prevention in the circuit as the super-caps will take a large surge current (from the 12V converter) when voltage is applied to them and they are discharged. For the record: individual super-caps usually have a maximum voltage of less than 5V but you can now buy units that have two in-series to operate with 5V volts - however it is not a good ideal to put more than 2 or 3 in series without extra "voltage-balancing" circuitry which just make the design more complex - the reason to use a "boost" converter is that it will keep producing 5V when the voltage from the capacitors drops below that... 

Well done on including the bare bones of the circuitry you are trying to use! As @Chris has said your use of the Triac is not correct in that it does not conduct electricity through the main terminals (MT1 <==> MT2 or in this case pins 4 and 6) until a sufficient gate pulse is delivered into the gate terminal - or, in this case, as you have very wisely opted to use a optically isolated one, until a sufficient pulse of current is sent through the LED. It will continue to conduct until the current through it falls to a low enough value that it switches off - this is the simplistic case when the load is mainly resistive but any significant capacitance or inductance will mess with this (i.e. it will a good model for an incandescent light bulb but considerably less so for a motor). For starters though your zero detection circuit will not be producing the signal you expect - the LED in the PC814 will be illuminated for virtually all of one half of a mains cycle, that means the photo-transistor will be conducting and thus pull the pin going to the Raspberry Pi to around VCE(sat) above 0 volts which will be around 0.4 or 0.5 volts I expect. For the rest of the time the input to the Pi will be pulled up via the 33K; to get a pulse around the time of both zero-crossings (i.e. at a 100hz rate) you'll need to feed the PC814 LED via a bridge-rectifier circuit - without a smoothing capacitor. Um, I looked at a datasheet for this device and found that both those diode devices are optical emitters i.e. LEDs, the one further from the transistor symbol is not a reverse polarity protection device as I at first thought! That being said the waveform you show as Pic2 is inverted - the transistor will be turned on and saturated for virtually all the cycle (one of the LEDs is illuminated except for a very small time around the zero-crossing) and thus the pin to the Pi will be low except for a very small time around the zero-crossing. Also the 33KΩ and 3.3 volt supply mean the peak Ic for the transistor is 0.1mA which is off the range that is characterised in the datasheet I saw, given the capabilities of the Pi's 3.3V supply I'd drop that resistor to, say 6.8KΩ to raise the current to nearly 0.5mA which just about gets it onto the ranges shown on the graphs in the datasheet. To get a controllable power output you must start a timer as soon as you detect a zero crossing with a minimum of around half the width of the pulse (so that ideally you start the timer at the peak of the pulse which neglecting the turn-off time of the photo-transistor in PC814 is the point when the current though the load is passing through zero) and a maximum of a bit less than the half-cycle time (10 mSec for 50Hz mains) less the time you allowed at the start and the time you need for the pulse to turn the output TRIAC on - then when the timer has ended THEN you send that pulse to turn the output on for the time to the end of THAT half-cycle. The longer the delay before sending that pulse the less the power that gets put into the load. You will want to tweak those timings (minimum, maximum and turn-on pulse duration). As for the quality of the timing overall, we are talking a timer being run every 10 milli-Seconds but which does need a fairly low latency to detect the start time to be initiated by the zero-crossing detection; I do not know how good the Pi can be made to respond to the signal, ideally it would be an interrupt input which is not something I had have exposure to on the Pi series. MAINS ELECTRICITY IS DANGEROUS! - The use of (optical) isolation is vital in this usage case, I'd strongly urge you to put all of the circuitry you have shown on a separate PWB in a separate enclosure (which needs a tool to open it), with at least a 6mm gap between every copper track (and the pads thereon) on the live side and the low-voltage stuff which the Opto devices will straddle. Also a suitably rated fast blow fuse in the Live supply rail before the feed to the Opto-isolator PC814 and to wire the Opto-Triac between the Live supply and the load (so that if the TRIAC fails open-circuit the load is not left pulled up to the Live supply) - though the failure mechanism for TRIACs does seem to be to fail short-circuit in my experience! Remember also to fasten the wiring on both sides of the "Mains Barrier" especially on the Live side so that there is more than one thing holding each wire (as short as possible and not possible to cross the barrier unless with TWO layers of insulation a.k.a. DOUBLE-insulated) in place (a two screw per terminal block OR solder and a tie wrap to the PWB for each conductor) and a Mains Warning label on the outside of the enclosure, etc., etc. ... Disclaimer: The above constitutes advice only, I accept no liability for anyone taking it and would urge everyone who plans to do something like this to satisfy themselves that they are aware of the risks and responsibilities for them and un-informed others who may come into contact with what they have done. {FTR: I hold a BEng(Hons) in Electrical & Electronic Engineering} 

In addition to the individual files in the files that Jacobm001 refers to, the "master" file in is also used - it pre-dates the "individual repository file in a sub-directory" format that Debian (and thus Raspbian) now uses, and will probably have at least a reference to a source which actually redirects requests to a local mirror for you. 

It isn't possible using a "PowerBank" type device - they may have an LED display showing the state of charge but they don't (as far as I know) tend to make the information accessible to the connected device. What you want a similar but more sophisticated bit of kit called a Un-interruptable Power Supply {UPS}, not only do these charge their own battery whilst connected to the external supply they will also supply power to the connect device. Most "Power-Banks" cannot charge themselves and supply power simultaneously. There are UPS units for things like the RPi, I use a second hand UPiS originally from PiModules but I've not been impressed with the delays in firmware updates and others have had long delays in product shipments. There have been/are several projects to Kickstart such product and some have reached a production stage - as this isn't a forum for shopping recommendations I won't go on but there are such things out there. Like the larger products designed for use with PCs most UPS devices do have a means to at least warn a connected device that the power is about to run out so the latter needs to shut-down now; more advanced options are sometimes available and monitoring the instantaneous voltage/current/state of charge (I was trying to avoid the confusing expression "current current"!) and how long the supply will last if on batteries are typically amongst what can be found out. My UPiS provides some of these, including the current drawn (including the battery charging current) via either the RPi Serial port/ it's own external micro-USB power inlet or via the RPi I2C bus - it also uses a dedicated GPIO pin with a simple monitoring python script to tell the RPi to tell the RPi to shutdown as soon as that Pin is pulled to ground by the UPiS. Alternatives: