In a nutshell, what makes a shallow water equation a shallow water equation is that the water height is not zero and it assumes no variation in the seafloor. Note: No fluid dynamics equation will allow for a water depth of 0, as that would mean you have no fluid. You should read the Wikipedia article on the shallow water equation. Basically, in shallow water, the vertical velocity is ignored because the value is so small and has minor impact to the wave propagation. To quote the section in case of modification of the source page: 

I think the issue is that the input is being polled every frame as part of the Update(). I would suggest pulling the input from the Update() and using input callbacks instead. That way the input is only polled when fired, and not every frame. That should cause the direction to only update with input changes, and the Update() will continue to render the same direction until the value is changed the next time the callback fires. Unity doesn't have callbacks, I forgot that I emulate them. This is going to take some more thought on my part. I will update soon. If your game is a top down on an 8 point compass this gets a lot easier, but I'm trying to come up with a generalized solution. 

adding the .png file on the cache with SpriteFrameCache.. adding .plist with spritebatchnode adding the correspoding .png file, I didnt see any performance difference. 

When the loading screen loads objects like music cutscenes, the idea is to preload the objects, so... what should happen next? Do I transfer the objects to the next scene? or these special objects, media objects or even just images of the sprites, do they have to be part of a Singleton? According to my logic, singleton is a simple solution, that can I use whatever was preloaded in the loading screen to take to the game. The only drawback is that I have to keep management of these objects to unload them when out of the game scene.(its just an example, but its really close to what my game is doing). The thing is, i believe there is a more elegant solution to this problem. Anyone has any suggestions? or tell me if my method is wrong? 

In my test I keep adding and adding objects with the same image.. in this case a bullet... eventually the app crashed because it ran out of memory. Same thing happened to both situations with SpriteFrameCache and SpriteBatchNode they both dropped FPS to 30(when its supposed to be 60) and then just crashes...I understand the scenario is not real.And obviously its destiny its to crash if I just keep adding images without destroying objects that are no longer in use...but the question remains. I saw the same performance issue, however I read that SpriteBatchNode makes only one draw call making it best performance practice. Has anyone tried and can confirm the performance difference and exactly how can you prove this performance difference in code and in the app? 

And now for level design... This article mostly covers newer games but contains some fascinating insights into level design in general - you might find it helpful and at the very least an interesting read: $URL$ This is an article about a technique to manage the difficulty of, well, difficulty. It's scalable to infinite levels and uses DDA concepts: $URL$ The information in both of the above articles could be applied to arcade environments - level design tricks to keep people playing, ways to dynamically adjust difficulty so as not to discourage people, etc. You could apply more linear concepts at the same time as well. For example, your game may use DDA in conjunction with a linear difficulty scalar so it consistently increases in difficulty over time while slightly lowering or raising it at certain points based on the player's performance. 

I have no clue what I'm doing with regards to events. I know how to use them but creating them myself is another matter entirely. I've also made buttons without using events that work on a case-by-case basis. So basically, I want to be able to attach methods to the OnClick EventHandler that will fire when the Button is clicked (i.e., the mouse intersects Rec and the left mouse button is clicked). 

Seeing as javamonk has already linked some good technical articles, I'll try to approach this from more of a theoretical angle. 

There's a trick to this: Selecting Areas: As you move the mouse, the only tiles you need to check for new impassable tiles are the newly highlighted tiles. If the mouse is dragged from X=25 to X=26, then you only need to iterate over the tiles at the X=26 column from the Y of the starting tile to the Y of the tile the mouse is over. The worst case scenario is you cross both X and Y axis, in which case you will only iterate over L+W-1 tiles. Deselecting Areas: The catch is if the player selects a large valid area, crosses an invalid tile, then backs off of it to go back to the large valid area he had a moment before. To keep from having to check the entire space when your area shrinks, keep track of how many impassable tiles were crossed as you cross them. Then when bounds change, subtract the number of impassables that were in the column or row that was deselected. As soon as your impassable count is 0, you no longer need to check so long as the selected area is shrinking. This still ensures you never iterate over more than L+W-1 tiles at any time. Highlighting: While Selecting areas, as you iterate over, spawn a red rectangle at the location of the impassable tile you are currently looking at. Store them in a 2D array for when you need to remove them. You could do some magic and scale a single rectangle for contiguous blocks of impassables with a little thought. While Deselecting areas, iterate over the column or row in the 2D array mentioned above and remove any object found in the row or column. this will be fast, as you know the column or row you're looking at, and since most will be empty, they will more or less be skipped. 

I understand the concept but applying it is another thing entirely for me. And to clarify, I'm not wanting an animation, I simply want to create an icosahedron from the vertices of a tetrahedron. EDIT: So I now have an alternative way to create an icosahedron using golden rectangles. That's fine for the purposes of my particular project. However, I'd like to leave the question open for solutions to the original problem, i.e. mathematically converting a tetrahedron in Cartesian co-ords into an icosahedron (not vice-versa). 

Going off this information and the fact that were will likely be several hundred objects rendering on-screen at any given time, my question is as follows: Which method is likely to be the most efficient/optimised and why: 

From my experience, mass is either: a) A global value that applies to all spatial objects equally (or no mass scalar at all). or... b) An individual scalar value (e.g., pounds, kilograms) directly associated with each individual object. This approach obviously doesn't scale well. or... c) Defined by a base "type" (e.g., wood, rock, water, flesh, weightless...) with a scalar value associated with the type. That value could be used on its own or it could be used in conjunction with the size of the object to determine the final scalar, depending on the accuracy required. Not sure about the Frostbite engine but I would assume it uses something similar to c). 

My game has different, and detailed animations throughout the game. For example, the main character has an idle stance, so its not just painted still, giving him some life. Death animation, hurt animation, etc... even the background scenario has animations(which I don't think I went with the best approach here, but, it's working for now, this will be in another thread if not answered here) Anyways, the thing is, while the main character had these animations only that character was in the game at that time, so everything ran smoothly. After adding another character, the enemy, the burden of animations seems to overcharge the FPS and just slows the game down. The most obvious of this problems was that the spritesheet I was using was 1 per character, I figured how to use spritebatchnode efficiently and now 1 spritebatchnode covers the 2 characters animation set. The FPS tried to get back to normal, but its still laggy at times. This worries me because my game design has more enemies to the game, meaning that it will have this issue in a bigger scale. So I believe that its because of my animation approach, its poor, and inefficient making my game run slow. I have been trying to find the answer online with no luck, and I don't my approach is the best. I tried working some solutions by my own, but they end up in the same thing. THE ONLY, the only way I find how to reduce this problem is to make my sprites smaller, its not a big deal, but I wouldn't like this solution. 

From your example I can tell you're making a "connect the pipes" type game. You have two possible approaches here: 

You can hard code each level, testing the map array for a specific total state, making sure that A2, A3, and A4 are all orange. You can program a pathing algorithm to test if there is a path between the two colors. 

One thing I would be careful about is using the correct input callback. I would suggest one of two things, read the API's on the input methods available, and choose the one appropriate to your desired behavior. Some callbacks only fire if the key is held down, and others fire on a tap. Secondly, your architecture should change a little bit. The callback should only set the Target transformation. When you click on a pot, copy the transform from the pot to the target of the move script. The move script should be changed to automatically strive to achieve it's current target transformation until it reaches it, at which point it will wait until it receives a new target. This is best done by having your movement code in the Update() method within the script. For a small game, this will achieve your goal, and not cause much overhead. (Bigger games with many moving entities need to approach the problem a little differently) These changes will mean when you click a pot, the target will be set, and on each frame the movement script will adjust the chef's position if it doesn't match the target. The beauty is that you can reuse the "moveto" script for any other objects, with either a fixed, random, or controlled target transformation to add a little extra to your game. (a rat, or an assistant for instance) 

As the title implies, I want a Button class with an OnClick event handler. It should fire off connected events when it is clicked. This is as far as I've made it: 

Arcade game difficulty... From my own personal experience (not sure there are many or even any articles to back this up but I'll keep looking), arcade games are almost always consistently incremental. Every level the enemies get a set amount stronger, they move a set amount faster, the timer is shortened by a set amount, etc. There are variations to this, like when entirely new enemies or other gameplay elements are introduced at certain points, but in infinite games these will run out eventually. DDA (Dynamic Difficulty Adjustment) is an interesting difficulty concept that can be found in some arcade games. One good example is Astrosmash. The game gets progressively harder in the form of more and more asteroids, but it can also get a little easier for a short time if the player is struggling. One example of purely linear difficulty (no DDA) in an arcade game is Robotron: 2084. As the player finishes the levels, enemies progressively become more and more difficult with more and more of them appearing in each level. The game was specifically designed to be extremely difficult and yet people have still managed to "beat" it (after 255 levels the game reverts to the original screen). Not because the developers specifically made it so that it could be beaten, but simply because some people are dedicated enough to do so regardless of the odds (barring the literally impossible). On that note, if you haven't already, check out The King of Kong. Sort of relevant and offers a bit of an insight into the minds of dedicated arcade gamers who set out to "beat" games (or in this case, high scores). 

One thing to think about here is that you are updating the entire mesh UV state for each tile you modify. I'd be sure to check and make sure it's not refreshing the mesh after each tile. you might return the UV updated array one level up and marge them all at once. Basically restructure so you calculate all, then apply the changes to the chunk/mesh. I also notice you're searching for the chunk index once for every tile you update. Do this outside of the tile loop, and pass the result to the SetTile() so you only do this search once per chunk instead of once per tile. 

So theoretically speaking, with boolean assignment, it's actually slower to try to avoid assignment, than to assign it each frame. The method declaration for the C# call is :: public void SetBool(int id, bool value); :: the id lookup is an O(1) operation off the heap from a hashtable, and the value assignment is an O(1) assignment. 

This question falls into the subject of Runtime Analysis. Assignments are, by nature, constant time operations. From a performance standpoint, you generally don't need to worry about constant time operations. Since you asked: Any primitive operation(assignment, logical evaluation, etc) are generally considered to take one flop from a runtime standpoint. Occasionally there may be more cycles for other overhead, but as a general rule they are considered to take one flop. Lets compare pseudocode: