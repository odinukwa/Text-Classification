In general, you shouldn't leave auto-generated s in submitted code. For an interview, I would be fine with leaving s explaining functionality I wish I could implement but didn't have time for. 

See the above note - we probably don't want to force the user to deposit money before every withdrawal. 

The contents of the outer loop - i.e. the inner loop and the check - could be broken out into a separate function, , which could instead of . I.e. in the loop, and if you finish the loop without returning, . 

Regarding these loops: I prefer to avoid statements where possible. They tend to be more difficult to understand intuitively, especially in a loop. As a rule, I prefer my loop to end because of the condition it checks, not because it gets d. 

We will start by cleaning up the code: First, let's make the for loop cleaner to read. A compiler is able to inline variables that are only used once in a scope. 

Say X = 3 and Y = 3, then the combination is: So basically, you have a: min number which is 111 max number which is 333 so: 

MessagesListFragment Firstly, should only be used for initializing the view. If you want to perform networks calls, you may do so in : 

Unfortunately, things aren't as simple on Android as they are on iOS. Kindly follow this tutorial to understand how data needs to be passed between Activities in Android. MessagesAdapter Your adapter implementation is mostly correct albeit one glaring error: It is NOT an Adapter's job to handle click events. The adapter should only render the list items. Interaction with the items should be handled in the activity or fragment. Declare an interface to handle button click events in your Adapter 

Using an array and incrementing the size is a little ugly, and it's inefficient. Consider using an ArrayList, which allows for index-based insertion in constant time, and hides all of the size changes (as well as doing them more efficiently). 

My biggest suggestions for improvement are: always submit the cleanest code possible, try to follow broad, important, rules for how the language should look, so it looks clean to the reviewer, and work on writing short, helpful comments around tricky or interesting spots in the code. 

Overall: aside from the "first item in array is 0" which is either a mistake or a misunderstanding on my part, your code is clean and well-organized. I urge you to 1.) try to use less often, and rely instead on iterator-based loops and -based loops as much as possible, and 2.) read up on ArrayList - it's a very common and useful data structure, and I think it's what you're going for by trying to implement a self-adjusting array. 

At this point you can probably guess that I'll recommend doing away with the list. A generator should work. If on Python 2, is probably better than as well. (Note, I didn't mention . That could be changed into invocations if you are on Python 2, but you seem to be on Python 3.) 

I was able to shave some milliseconds off by moving the call inside the calls, which let me get rid of the explicit loop: 

Two ways to rewrite it: When you know which version of the method you want to call you can name it directly, but in that case need to pass self as an argument: 

I also found this PyPy issue that leaves me less confident there's any performance still on the table. 

Use a to load the images asynchronously on start up. Cache them in memory and use them as needed. Only load images as needed. For example, the board may have 200 tiles, but only 10 are visible at a given time. So load the first ten tiles. Anticipate which tiles will be needed and load them as necessary If resizing is a one time operation, perhaps saved the resized images to disk so that you won't have to resize them after the first time. BufferedImage offers . You could have one big image with all 100-200 tiles. Load this one big image once, and then show only the relevant part of the image using . This is a concept known as Sprites and you can find a clearer example here. 

You should define the lower level method instead. will use that to define and that way you are sure to get efficient testing. Speaking of which: 

Any GPU limitation on salt lengths is small, unlikely to last, and will not necessarily apply to ASICs. I do not think it is a good idea to rely on it. The salt is only used on the first iteration of PBKDF2 so it might even be possible to precompute the first step with a CPU and leave the rest for a GPU. It would be fine to halve the salt length, but since it only costs memory and a constant amount of work, it is not a problem to leave it as is. Nit: You misspelled "length". 

One of the servlet in my web app takes parameters in the form . The first parameter is required and the second parameter is an integer. I've made some code to validate the parameters but it looks really really messy. Is there a nicer and cleaner way I can write the following: Thanks :) 

Now, let's deal with performance: You are loading 100 - 200 images from a file, resizing each one and then placing it on a screen. This is a resource intensive task and you need to optimise it. Here are some suggestions 

Second, in , StringBuilder is more efficient when concatenating strings. Also, is redundant because you apply the same logic in both cases. 

Read the input in blocks, which you sort and save into files. Merge the files while iterating by always choosing the extremal item. 

However, beware. AFAICT, the item could have been deleted by another process in between checking whether it exists and deleting it. You should probably just delete the item and raise an error if that fails. 

You are saving some data that you never use. , never used after this. The whole parameter is unused if you remove the assignment. already is. If you remove from here, you can also remove from . 

Personally I find your use of a global variable fine. Using a singleton class for encapsulation where a module would do is IMO needless complexity. If you can have multiple high score objects it's a different matter, of course.