Meaningful Variable Name: The variables i and k don't tell the reader anything about what the code is doing, initial and cnt are better, but spell out count. The variable gamewin is very clear, but use camelCase, gamewin => gameWin. Meaningful Comments: You don't need anywhere near the number of comments you have, the code itself should clearly explain what it is doing. Comments should explain the why, not the what. The best comment in the code is 

Global Variables There are two global variables used in this program, n_labels and labels. In this program and can be defined in the function and passed into the functions that user them. It is generally better to pass variables in where they are needed than to use global variables. A major problem with global variables is writing and maintaining correct code. It is very difficult to see where global variables are modified and how they are used in different functions and files. As programs get larger and additional source files are added global variables created in one file may conflict with global variables previously created in another file. This conflict will show up when trying to link multiple files. In the C programming language the way to avoid this is to declare variables that need to be global to the file using the static keyword so that the variables are limited in scope to the current file. 

in their code they are allow possible collisions of functions from their code and different libraries they might be using. The code here is complicated enough that one might want to include libraries to do some of the work. Most professional programmers will use std::cin, std::cout and std::vector rather than the statement. 

Reduce the Complexity of the Functions The first while loop in should probably be it's own function, possibly called . It's generally a good practice to break code up into smaller functions that have simple tasks to do. The function might also be broken up into smaller functions. The Single Responsibility Principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. 

hides the fact that cin, cout, vector and stack are coming from the namespace std where cin, cout, vector and stack are used in the code. This can cause confusion of where the code is actually coming from. As the software becomes more complex and uses more libraries this becomes a bigger problem. For a more detailed discussion of why it is a bad idea to use see this stackoverflow question and stackoverflow question. Code Reuse One of the major goals of object oriented programming is code reuse. Once something is written and debugged it should be available for programming in other projects and programs. It might be better if each of the classes had its own header file (header.h or header.hpp) and a source file. A second goal is encapsulation. Code that uses other classes only needs to know the interfaces and not the details of the implementation. This allows implementations to be imporoved over time. RandomNumber.h KenoWinCalculator.h and KenoWinCalculator.cpp Bank.h Award.h and Award.cpp kenoGamePlay.h and kenoGamePlay.cpp The combined use of headers and C++ source files allows the classes/API to be maintained without forcing recompilation of all files. A linking phase may be required. In some cases these might become dynamic libraries with the header files providing the APIs. Avoid Using Goto C++ and to a lesser extent C provide a lot of ways to control the flow of the code, the use of is discouraged in most modern programming lanaguages because it is very hard to maintain the code. In the case where it is used here, rather than using a style integer array it might be better to use a C++/stl container class such as std::array and to use the std::find() function to find any duplicates. 

It's possible that the magic number (numerical constant rather than symbolic constant) 100 is a bad choice. Memory is allocated by word size which is always going to be a power of 2. Depending on the computer this can be either 4 bytes or 8 bytes (4 chars or 8 chars). It's not critical in this particular instance, but if the array is within a struct it could affect memory allocation. 

Note: I was not successful in reducing the total number of lines of code, at least partially because breaking the code into header and source files adds some overhead lines of code, and because adding functions adds at least 3 lines of code for every new function. The original solutions is approximately 375 lines of code this alternate solution is approximately 440 lines of code. One of the few major changes to the code, one is that the function was turned into a class. The other is that an of multiple maps was used to replace a rather large case statement with embedded if statements in . A third was to decouple the class from the class by adding another interface to the class. A fourth was to change a C style array of integers into a . The final major change is that the random number generator now returns vectors of unique random numbers rather than a single random number and the interface is no longer a static member. Possible Bugs in the Original that are Repeated Here 

One goal in programming is to reduce the number of lines of code in a function so that the entire function can be viewed at one time. This makes it easier to write and debug. Prefer Local Variables over Global Variables When I first started reading the code I thought that it was declaring numeric constants in a strange way because of the following: 

The Second Bug in the Code The return value of spi_conn.init() is never tested to see if the connect was made or not, the following call to spi_conn.transfer() may not perform as expected if there was an error with the connection. Within the call to spi_conn.transfer() there is no check to see if the variable has a valid value or not. Inconsistent Block Indentation In SPIConnection.cpp the opening brace for is on the same line as the function declaration, however, for the opening brace is on a new line. For all the statements the opening brace is also on a new line. You should choose one way to do it and be consistent throughout the code. Magic Numbers When the int function fails it returns a variety of hard coded integers. It might be better to use symbolic constants that indicate what the errors are: 

Improve Performance Since the code is using a C++ container class, it might be possible to use iterators to improve performance. Once the code is broken up into functions and compiled -O3 it can be profiled to find where any bottlenecks exist. 

Note: In the specific usage of these numbers there are errors, every four years there are 366 days in a year, the price of a powerball ticket can change. Why 999? Also what if the winnings were greater than 999? In the following code 5 is another magic number 

This is my first hand crafted makefile in quite a while. I thought it might be useful for anyone who wants to review the Knights Tour - Improved Refactored Recursive Breadth First Search. I believe there is a lot of room for improvement on this makefile. The C++ source code as well as the makefile can be found on github. 

Drupal 7 replaced the Drupal 6 procedural interface with an object oriented interface. Several of the result interfaces are discussed here. They didn't exactly remove , they put it into the object oriented interface. You can use your while loop with 

A collision is when 2 different functions have the same name, the same arguement types and a similar functionallity (this is why they have the same name). Someone developing software may want to override a function such as , or they may want to override the functionallity of a class such as std::vector or std::stack. Namespaces allow these constructs to be overriden. The use of the programming statement: 

Reduce Complexity, Follow SRP @VTT is correct about the function it should be broken up into multiple sub functions, it would have been easier to read, write, debug and maintain that way. The Single Responsibility Principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. 

A class is reusable. A class can be added to a library more easily. A class will reduce the number of global variables you have. 

First, you asked a well defined first question that explains everything in the code so good job! Include All Necessary Headers The code is missing some header files, specifically 

Nice Question. I would hesitate to port the code as it is currently implemented. For Portability Don't Ignore Warnings When the library will be distributed on multiple platforms it might be better to use the -Werror flag to make all warnings into errors. Any warnings may become errors on other architectures. At a minimum when compiling for a portable library the -Wall flag should be used. Using Xcode on El Capitan (Mac OSX) I got multiple warnings about integer versus long mismatch. It might be better to change the length parameter in these functions to take rather than unsigned int: 

Your solution() function is too complex, you should create sub-functions to implement your solution. The problem statement does not state that you can't create sub-functions for the solution() function. Good candidates for your sub-functions are each of the for loops in the code. Using sub-functions will make your code easier to read and maintain. The names of the sub-functions should describe what their are doing: 

The best reason not to use classes is due to lack of memory resources when programming in an embedded system, the software engineer is responsible for tracking memory usage and that may be difficult when using classes. 

While this is primarily targeted at classes in object oriented languages it applies to functions and subroutines in procedural languages like C as well. The main function could be broken up into at least 4 functions: 

The second brace on the last line of the original is problematic, it is not immediately clear when reading the code. Keep it Simple The function contains the code 

Reduce Complexity, Follow SRP The Single Responsibility Principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. Robert C. Martin expresses the principle as follows: 

Generally it is better to assume that code will need to edited at some time in the future to add features or fix bugs. Prefer return() over exit() In the case of this program since there is no error checking there is no reason to use either or . If there is error handling in the program, the function should only be used if the program encounters an error it can't correct deep in multiple function calls. The function should only be used in stand alone programs, never in operating systems code. When using the exit() function, use the macros EXIT_SUCCESS and EXIT_FAILURE that are defined in stdlib.h. Don't Repeat Yourself When code is repeating itself, it is better to write another function rather than repeating the code. Then the code only needs to be written and debugged once rather than multiple times. This is know as the DRY principlein software engineering. Example: The following code has loops that repeats that 

It might be easier to read, understand and modify the outer loop if it was a do while loop rather than a while true loop 

Using iterators in this manner makes it much easier to program correctly. Declare Variables as Close to Use as Possible In the loop defined as a possible candidate for a function there are 3 variables that should be defined within the loop rather than at the top of the function. The variables l1, l2 and l3 are only assigned values and used within the loop. 

Don't Repeat Yourself: The DRY principle is stated as "Every piece of knowledge must have a single, unambiguous, authoritative representation within a system". The principle has been formulated by Andy Hunt and Dave Thomas in their book The Pragmatic Programmer. They apply it quite broadly to include "database schemas, test plans, the build system, even documentation." When the DRY principle is applied successfully, a modification of any single element of a system does not require a change in other logically unrelated elements. Additionally, elements that are logically related all change predictably and uniformly, and are thus kept in sync. Besides using methods and subroutines in their code, Thomas and Hunt rely on code generators, automatic build systems, and scripting languages to observe the DRY principle across layers. SOLID Programming Principle: In computer programming, SOLID (single responsibility, open-closed, Liskov substitution, interface segregation and dependency inversion) is a mnemonic acronym introduced by Michael Feathers for the "first five principles" named by Robert C. Martin in the early 2000s that stands for five basic principles of object-oriented programming and design. The intention is that these principles, when applied together, will make it more likely that a programmer will create a system that is easy to maintain and extend over time. The principles of SOLID are guidelines that can be applied while working on software to remove code smells by providing a framework through which the programmer may refactor the software's source code until it is both legible and extensible. It is part of an overall strategy of agile and Adaptive Software Development. 

If global variables are going to be shared between modules the header file should declare the global variables as because as defined above the variables are declared in each source file and this should cause multiple symbol definitions at link time (it should be reported as a link error). Global variables should never be used in shared libraries, it creates dependencies in the executable binaries that are hard to track down. libasc There are functions in libasc that are surprising in a shared library, , and are functions that one expects in the main executable binary rather than in a shared library. What would be more expected is features shared between executables such as functions that create and alter the prog_master and thread structs. Functions that are Declared but not Defined The code contains a static declaration for the function print_info(), but the function is never defined and never used. A good suggestion is to always compile with warnings during development, this will help to eliminate bugs. 

The more separate functions there are the easier it is to understand or read the code. This also makes it easier for any programmer to maintain or debug the code. Prefer Iterators Over Indexes for Container Classes The function contains the following code: 

Don't Assume the Buffer has the Necesary Capacity There is a possible critical error in the following code: 

The sub functions of both of these functions may be usable and sharable by each of the high level functions and that may reduce the total lines of code in this program. Error Handling in C There are times when it is inadvisable to call either because the code has necessary clean up that it must do, or the code is part of a larger system that should not quit such as an operating system. In such cases the error should be reported and then either the function should return an error status or some form of exception handling should be used. In the the only exception handling is the possibility of returning to a known good state using setjmp() and longjmp(). An example use of can be found here. The function saves the state of the program at the location where it is called and provides a location to jump back to in case of errors. The function jumps to the location indicated by . In best place to put a call to setjmp() is in a high level function such as or one of the functions called directly by Alternate Form of Main In more complex C programs such as this one it is better to limit the code in the function to setting up the program to run such as parsing the command line for switches and opening any input files, calling a function that executes the major portion of the program and then calling functions that clean up after the program has run, such as freeing any memory that has been allocated or writing to and closing any files that have been open. An example: