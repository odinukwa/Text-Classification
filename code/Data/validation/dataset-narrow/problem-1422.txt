Having a single snake mesh in this context will be a lot harder to implement/maintain than having the modular cubes system. Think about it: initially your snake mesh has no joints (1 bone). When it eats an apple the mesh scales (on it's length axis) and needs to have 1 joint (2 bones - vertices on the mesh need to be re-assigned from 1 to 2 bones) etc. One way to do this is to have multiple meshes for each of the possible number of bones (like 1 mesh with 1 bone, one with 2 bones, one with 3, etc). Then you still keep your cube system only now the cubes are not rendered, and then each time an apple is eaten, you remove the current mesh and add the one corresponding to the new length of the snake. At the same time your cube snake evolves as well, and each time you do this you link each of the new snake-mesh's bone to each corresponding cube and voalah, the mesh's bones are guided by the cubes. Honestly what I'd do is: 

As RobCurr states, simplest way to do this is to make sure the landscape mesh "matches" the track tile size, so that you don't get tracks that jutt above a hill or go through a suddenly ending slope. What you can do in Unity is make a script that tells you the point on the landscape where the mouse cursors "is". I say "is" because obviouslly a 2d moving mouse cursor doesn't really intersect a 3d landscape. What you actually wanna do is create a ray cast from the camera, through the cursor and onto the landscape, and use the point where that ray goes through the landscape as the point where the mouse cursor "is" on the landscape. Look up Raycast and this post here Then you need to script up the behaviour of the track tile when the user drags his mouse "across" the landscape: how the track tile needs to be rotated, should it be straight or curved (if the player changes direction after already laying down some tracks), etc. Make sure you have a good grasp of prefabs and how to instantiate them for this part. 

FengGUI is just such an implementation (Java GUI Framework on top of JOGL and LWJGL). You can get its sources here, maybe that will help you... 

Well, I'm not a major expert either, but I think in your 2nd example, the WaitForComplete() function will still block the calling thread until the ThreadedAction thread completes. What you can do is pass a callback function to your zip processing Thread, and have it call that function when it's done. That way your main thread starts the zip thread and then continues on doing his stuff (updating GUI, what have you), and then the call back function will set something in the main thread when it's done (like boolean zipDone=true), and at this point the main thread can react to that (display "Zip extracted" in the GUI etc). 

So, my question is: is there a way to actually mirror a mesh in Blender and then have it imported in Unity so that it displays properly (as it does in Blender)? If yes, how? Thank you, and please excuse the TL;DR style. 

Now hit play, and for each of the local and global movenents of the Cube, also move (by hand, in the viewport) the plane in various directions. Notice how the Cube global and local translations are influenced by this (or, as the case may be, are NOT at all influenced by this). 

Make a Cube. Rotate it a little in all directions. Then make a script in which you make him move slowly in one direction. Switch that translation from local to global. Look at how it changes its movement, something like: 

If it's for mobile devices, as in phones, then making the public as individual characters (even really low poly ones) is out of the question. Not only will it bog down the limited resources of the device, but no one will notice such detail on such a small screen. My best bet would be an animated texture. Or multiple animated textures, where you have one for "idle" (not much happening in public, just small isolated motions), one for "cheering" (all public moves wildly), etc. And then you display then accordingly on a plane which represents the public's geometry. Now, in order to obtain the animated texture you could do a bunch of repeated textures on plains, have them animate (like raise them a bit for crowd standing up, move some around for crowd fussing about, etc) and then create pre-rendered textures out of these. Or I guess you could use some actual public footage which you can tile about and create animated textures out of that. 

AFAIK, there's no native IOS support for .obj format (referring to IOS OpenGL APIs). So either you use some IOS app that can import .obj format or you've made your own such parser. If it's a 3rd party app, check and see if it cannot read zipped versions of the .obj files. If it does (and is properly implemented) this will use less memory when parsing your .obj file(s) If it's your own parser, update it so that it can read zipped .obj files. There are also .obj optimizers, which make your .obj file smaller by either rounding up values or removing vertices (if they're too close together etc). 

Well, starting with the log lines you posted: those basically tell you that you don't have memory leaks "per-se" - you can't really have that with Java (well you can with Android Java if your'e careless with certain resources like image loading, but for most of the time you're fine). What those lines describe is that at some point the garbage collector freed up some memory (line 1), than it follow by telling you that, from the whole chunk of memory available to your application an extra chunk has been made "active" (allocated as heap because instantiating something has made the previously allocated heap almost full) and finally the 3rd line is another garbage collect call which frees up some memory. The Java-like "memory leaks" you can get with Android (and really any Java program) are really very different than those you can get with unmanaged languages (like C++): with C/C++ you get a memory leak if you consistently forget to free memory that you've manually allocated to instantiating some objects. With Java you can't manually allocate memory (the "new" operator in Java does this behind the scenes) and you absolutely have no way to manually free used memory (you can hint at it, but that's it). Since Java's heap is "freed" by the Garbage Collector automatically (and based on its own internal algorithms), what you can get is: if you create a lot of new objects in a short time (instead of reusing existing instances as much as possible), the Garbage Collector will be called more often to free your memory (followed by a behind-the-scene reallocation of heap for the new objects) and this can take time. It can get to the point where the GC uses 10-15% of the application CPU time, and results in visible slowdowns. Obviouslly, the first and easiest way to avoid this is to reuse your already created objects as much as possible (instead of creating new ones). Coming back to your actual question: normally, the number of Activities you create will not have a dramatic impact on memory consumption and garbage collection time. That being said, you should balance the number of actual activities you have between having a decent logical organisation of your project and a decent GC occupation. Basically if your app has a handful of screens, you should make each one as a separate action. If however you find yourself making actvities for very small elements, which can just as well be displayed as pseudo-pop-ups and/or dialogs in an existing action, is better to refactor that code and "merge" those multiple small activities into a single one (with state-driven for the display of each of the contents of the previous activities). The idea here is to make sure that: