MPLS is used to tunnel traffic over MPLS core routers to reach BGP NHs of BGP destination networks, since these MPLS core routers probably didn't learn (and probably shouldn't learn) the destination NLRIs via BGP. In case of L3VPN for example, without MPLS it would be necessary for all provider core routers to know all customer's routes via BGP, each in its own VRF to keep separation between all customers. So in that case, an addition of a new customer would require an update of all provider core routers as well. This solution is not very scalable and requires a lot of work to maintain. Maybe some other tunneling mechanism could be deployed here, but MPLS based tunnels are easier to configure and are dynamic (based on LDP which is derived from IGP information). 

Here's some version info that should help. I think that the other thing that immediately strikes me is autonegotiation being disabled, which shouldn't be necessary. Is this something that your provider is asking for, or based on learned behaviors? I recommend reading what's out there, since autonegotiation has been recommended for over 10 years. Anything you're connecting to should work fine with it as well (the last time I had issues was on a 3500XL - we're talking ooooold). Check out: $URL$ First off, Junos 11.4R7.5 is the supported release recommended for SRX240, as of 8 April 2013, per JTAC (since you mentioned versions). $URL$ (need login) Also, JTAC recommends EEOL releases on SRX or J Series for IPsec features (may or may not apply, but FYI). (For me, the only releases available for SRX240H on juniper.net are 10.4, 11.4, and 12.1 - that may help set your expectations on what to run.) $URL$ (need login) You are also running a version that was released before the malformed TCP vulnerability came out. I shudder to think that a live exploit exists, but you definitely need to be on versions that were published around January or February 2013, or later. The versions you need for 11.2 are 11.2R5.5 or 11.2R7.5 (or higher) $URL$ I mentioned versions because the SRX is a 'rapidly evolving' platform as well, and anecdotal evidence and hearsay suggests that you'll want to upgrade more frequently. 

Create a general NAT access list for inside traffic to internet and remote network (with permit and deny rules) Create a specific NAT access list to match router-originated traffic Add outside matcher to tunnel interface Create 2 nat rules, 1 for each access list in #1 and #2 above. 

This is not my full config - I have tunnel interfaces with crypto configs, lots more routes and a handful more access lists, but just wondering if there's anything in that config that might be causing the inconsistency. 

Have you tried walking the MIB/OIDs in question from a management station? After having spent a lot of time w/firmware QA, I've noticed things like show commands are likely to not display correct info, even when the OIDs are poll-able. I recommend using and knowing Net-SNMP tools and utils as debug before trying to poll the information in cacti, observium, etc. e.g. will say "No Such Object available on this agent at this OID" if it's not there Walking 1.3.6.1.4.1.9 on my IOS-XE box gives a lot (I just need to add the MIBs for description). Then I have something to work with (including other gems that might benefit me for monitoring) 

VPWS is a point to point L2VPN, using this technology two geographically remote hosts from the same IP subnet are able to communicate as if they were connected to the same switch. This thing is achieved by the transport of Ethernet frames inside an MPLS tunnel. So if to capture the packet as it travels between two LSRs inside the MPLS core you would get the following headers: | ETH | MPLS (transport label) | MPLS (VPN label) | ETH | PAYLOAD | The outer Ethernet header is for communication between two adjacent MPLS core routers, and is de-encapsulated and encapsulated inside the tunnel for every hop the packet travels (Along with the transport label). While the inner Ethernet header is for the destination endpoint beyond the tunnel (Identified by the VPN label) and remains intact while inside the tunnel. For example: CE1 10.0.0.1-------- PE1 -----MPLS BACKBONE------ PE2 ----- 10.0.0.2 CE2 When CE1 pings 10.0.0.2 , it first has to get the L2 address of the "directly connected" address 10.0.0.2. So an ARP request is sent across this tunnel in the form of : | ETH | MPLS(transport label) | MPLS (VPN label) | DMAC:FF:FF.... | ARP | After ARP reply is sent back across the tunnel, CE1 is able to communicate with CE2 using the learned L2 info. | ETH | MPLS(transport label) | MPLS (VPN label) | CE2's DMAC... | IP | DATA | 

Edit: downgrading to 12.1R5.5 did not fix the issue, and I'm still getting corrupt/md5 hash match failed. This does not appear to be due to lack of storage, which could cause weird errors like this. 

The JNCIP / JNCIE-SEC latest courses use 12.1X44-D10.4 as the recommended Junos version. I setup a 30-day evaluation on my home SRX device to study JIPS, based on 12.1. At this point, I'm guessing that my problem is that trial licenses for 12.1X44-D10.4 might be equivalent to 12.2, 12.3, or entirely not supported. Here's what I'm trying now: 

I'm trying to configure an IPSec tunnel between a Cisco router (ISR) and AWS (Customer Gateway). The connection to the ISP here is a PPPoE connection with a static private IP (e.g. 10.100.1.1) which is mapped to from a public IP, (e.g. 160.1.1.1 ). There is no filtering on the public IP, all traffic is translated to the private. I am now trying to configure the IPSec tunnel, but am not able to get it up. The recommended configuration provided to configure a tunnel if I had a public IP is as follows: 

Since the license installed properly (but not the IDP signatures), I was also going to manually request a download with the proper URL parameters (mentioned in KB19502) I've had no luck on Juniper.net, but here are my planned next steps: 

Check out the MIBs available for 4.2.x on the ASR 9000 @: ftp://ftp.cisco.com/pub/mibs/supportlists/asr9000/asr9000-supportlist.html#Supported_and_Verified_MIBs_XE_4_2_X That link says that the CISCO-ENTITY-SENSOR-MIB is available, and hasn't been updated since 2007. Edit: it appears that the asr9k-mgbl-p.pie package was not available on the router, as mapped in the ASR9000 MIB list above. Supplemental info: Cisco's MIB Locator tool is IOS-only, so check out the directories above above the asr9000 on the FTP link for more info. Tool: $URL$ SNMP ftp dir: ftp://ftp.cisco.com/pub/mibs/supportlists/ For more information on loading MIBs: $URL$ A really good Cisco SNMP links page: $URL$ 

is a pppoe internet connection and a VPN connection to another network - 172.16.1.0/24. Routes are configured for 192.168.1 and 172.16.1. Network is working as expected between these 2 networks, and between 192.168 and the internet ( on dialer1, inside on fa0/1, and ) However, I am unable to connect to 172.16.1 network from the router itself - the source address comes from the tunnel interface IP of 169.254.x.y. I could add a route for 169.254 on the remote network, but would rather want packets originating from the router to have the source address translated to 192.168.1.1. Is it possible to do this? 

What is the difference between these two L2vpn technologies? The bits of info I was able to find but still don't answer my question- VPWS: 

IP is a layer 3 protocol. DNS is just a service that translates host names into IP addresses, you need this because humans are better at remembering names than numbers. So once you enter a website name your browser client has some API to ask the operating system to issue a DNS request for the name you entered. DNS requests are transmitted to a specific DNS server IP address that resides somewhere on the internet (The address which you configured manually or received via a DHCP update). For that server to know which service you specifically want (since this server might also be an HTTP server for example) you also need to specify a port number, DNS uses UDP port 53. So for that reason it must be an application layer protocol. If your DNS server would always reside on your local subnet you could have a Layer 4 protocol to implement this (the sever would then identify the incoming request by the unique multicast IP address dedicated for this service - the same mechanism as OSPF for example). 

So I have modified the 3 occurrences of public IPs with the private IP (based on $URL$ but the tunnel does not come up: 

I initially thought that the error might be related to this bug: $URL$ but firmware is a fixed version: 

Finally got it to work, after much playing around. The high level steps to complete were as follows: 

The adjustment to the first access-list (the addition of the ) allows me to add the to the tunnel and not translate 192.168 traffic headed to 172.16. The 2nd access-list allows me to identify router-originated traffic headed to remote private network, and the 2nd rule ensures translation from tunnel IP to private inside IP (.1.1). Working like a charm.