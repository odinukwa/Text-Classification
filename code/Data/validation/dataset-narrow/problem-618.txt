Perhaps will better convey the fact that it's solving the puzzle. sounds like a function that fills in the initial positions from a file or string or something. You could shorten the "is the cell is filled" check by dropping the for maximum C-ness: 

Note that this assumes a single-character directory separator. My only quibble with the class, and I understand you want something lightweight, is that there's no checking of the array passed to . This shouldn't be too much of a problem since it will fail pretty quick if the parameter isn't an array or contains non-strings, but if that comes later during the execution the error will be harder to spot. I think you'll get a simple "class not found" error. Oh, and the method should be named since it removes any existing directories, or it should append them to the existing array. 

PHP provides quite a few handy array-manipulation functions. This is a case for which passes each value to a callback and assigns it to the same key in a new array. 

While it works, converting this to a list comprehension and adding on the first and last cells using seems more Pythonic to me: 

You don't need to check size() for even/odd value, the integer division will work in your favour in this case, so 3/2 = 1. And random_access/bidirectional/forward iterators have overloaded operator, so you can add the result directly to . The would be helpful when you would use container which has only available (can increment, but only by single step). Then it can be still somewhat simplified to: 

(I would also write as , but I think the compiler will optimize that one anyway, just old habits from ASM times die hard). 

One more thing, I forgot to mention one other idea. If you can sort the blockers by the position (rotation), then you can use the last position (last index to moved blocker) to check, whether that blocker is still current for next frame, if not, move to next. Removing the loop cycle completely and having just couple of basic s. 

Some short note without really reading into the source. In MVC usually the Model is independent of View and Controller. So your looks like mixing together Model and View class, supplementing functionality of Controller too. Some general notes how I would split these: Model: 

As you can see, I removed the array ( not needed) and I use the know state after last to avoid . So this is certainly more efficient, but also harder to read and comprehend. 

Contract Enforcement There are a few ways to violate the singleton contract, but none need to be guarded against. 

And seriously, you're not saving yourself any time by omitting vowels at random. In fact, it probably takes longer as you have to keep correcting yourself when you type . 

My first thought is to use the Factory Pattern and supply a to the which would cease to be abstract. 

This algorithm requires the values to maintain the same structure in both trees which is probably okay for this assignment (homework?). If these are binary search trees, there's at least one optimization you can make right off the bat: inside the block you don't have to check both directions. Think about how you would find the root node of the subtree in the main tree. And yes, choosing meaningful variable and function names and using consistent formatting (I fixed it) goes a long way toward keeping code readable. 

Use optimistic locking when the logic requires separating a read and update of the same row into two transactions, usually because you're showing the original data to a user and letting them edit it. The example in your question doesn't need it because you're simply overwriting the existing age with a new value. Trevor is correct about how to implement the optimistic locking check (3 and 4 below). The only part missing is how to get the original timestamp. 

Hmmm... anyway, I really like what you wrote here: "I'm noticing that reading doesn't really help much as much as writing programs and running into issues and solving them." This is absolutely spot on. All this general babbling around usually makes little sense when hit by real world problem. Also refactor a lot. Not just the code, and implementations, but as learning is your goal, dive deep into finished project and go trough all the API, all the abstraction, and try to imagine something better, easier to use, easier to understand it's responsibilities, easier to read and get the idea and eventually easier to implement (although sometimes to get better API and abstraction the implementation can be more bloated, but the cost of bloat has to be clearly justified by the cleanliness of resulting API/abstraction). 

I also modified the code to be PIC (position independent code). This is first time ever I tried that with assembly, so I'm not 100% sure I did+linked it correctly, but the code works, in debugger I see relative addressing, and stripped binary has only about 6kiB, so looks OK to me ... and now I tried to run it multiple times in debugger, and the code address is randomized, so the ASLR works too. And fixed some of your comments. And I test return value, so now the code upon invalid input will simply output the current sum, and the program can be terminated early by entering non-integer, or Ctrl+D. 

should not be static. It's one thing to maintain a static instance to implement a singleton, but that object should interact with its state using normal instance variables. And you may as well initialize it in its declaration instead of the constructor. The service should create the thread itself instead of creating it in to make it self-contained. This allows another implementation to use a thread pool for parallel directory creation and easier testing. is not thread-safe and could allow two or more instances to be created. Use a blocking queue, so you don't have to poll and sleep. The thread will be put to sleep if the queue is empty and be awoken once a new directory is added to the queue. This will shrink your run loop to a few lines and allow you to rely on the well-tested thread-management in . 

Assuming a set of ten to twenty common types, you can make your API easier to use with these helpers. For the rest, the generic accessor will suffice. Either way, encapsulate all parameter item creation and use behind container methods, which you may already have since you left them out. 

or create a configuration interface with implementations backed by raw values, an array, a object, or anything else and pass it to the service being configured. But it should definitely not accept a generic or the it produces. 

The Model/View relation - how I like it - can be demonstrated on this classic: Consider having blog application, so for each article you have date+time of publishing the article. Then Model should contain UTC timestamp value (can be unix timestamp, if you need only dates since 1970 onward). And View will do all the formatting magic, ie showing "5 seconds ago" for fresh article, or "previous millennium" for some really old article, also converting the date/time to local time zone of user (source data stored on server being in UTC, time zone agnostic). 

(the exact value stored in is , encoded as 64 bit integer value) So you are just destroying precision bits of the original value, but the resulting value can still contain decimals with precision you don't expect. For some more information study how the floating point numbers are designed, maybe this may be of help: $URL$ 

I never did MIPS Assembly, so I decided to try on this simple one. I will comment on your code mostly from performance point of view (as smac89 covered simplicity/readability variant well). In your case I wouldn't be afraid so much of branching (and it's not trivial to lower amount of branches down), but about number of integer divisions () and also syscall outputting integers (hidden divisions). From the limited info I was able to found about real world MIPS architecture implementation it looks like for example PIC32 MIPS32 M4K Core does use about 1 cycle for 1 bit during divide operation, maybe with some early exit optimizations, so in worst case it's about ~32 cycles for 32b/32b divide. I tried to use MARS and it works OK, but I don't see any serious performance information except simple instruction counters, plus is not counted into the stats at all. So outputting integer is "for free", while in real world it would hurt so much that it would be probably better to keep just string representation of and increment it as string, avoiding binary integer (at least with my code it would work, as I don't do on it, so I don't need integer form of "number"). Anyway I didn't go that far, only reworked your loop to avoid divisions, and also to avoid pseudo instructions when possible, so the amount of real instructions generated is similar to the source code. 

As Kinjal suggests, logging the error is a good alternative when failure is recoverable. However, I would throw a custom exception (or use ) and let the caller decide to log and continue or terminate. I really don't like returning success codes when I can avoid it because it muddies the code with checks. Finally, instead of setting a certificate or leaving the field blank consider modeling a certificate checking strategy. This would require a simple one-method interface with two implementations: and . Again this improves testability by providing a seam for mocking, separating concerns, etc. It also removes the need for checks and allows for more strategies and certificate types. 

That's better, but is still doing too much. I don't like that it has to parse the original message, check for an empty chat message, and send the formatted message if it's not too long. Let's extract the parsing first. 

That being said, using the PHP approach you can take care of proper HTML-escaping attribute values (though you didn't) in one place to enforce correct rules. I built a few helper classes for generating image and article link elements for my current project from and model objects. These classes have setter methods named for the attributes and pull reasonable values from the underlying model objects all while performing correct HTML-escaping. The majority of the page is HTML plus PHP, but these classes make embedding a link or image very easy: 

I found another bug in your source: will be always false. Unrelated to your bug, I have read an advice somewhere to always use only "<", "<=", "==" and "!=" in comparisons. It felt strange for few weeks, but once you get used to it, it really makes easier to read sources, as you know the values should only increase from left to right, if the expression is true. So I would write your expression as: . 

The initial comment: not clear what is entering (deducting it's about byte ) and I would rather use "arguments" or "input" word. Not clear the description is about bits. Not all arguments are described (the code does use also address for ). Typos. Modified registers are incomplete too (again ). Etc.. 

Well, the runtime of your code can be maybe improved a bit by cleaning up the current code a bit, but the main bottleneck is the inefficient algorithm, so I will not comment on your particular code and style, and I will focus on the algorithm only (if you still insist on code clean-up of current version, let me know in comments, I may try to rewrite few bits of it more to my style to show you a thing or two, but I think reviewing better algorithm would make more sense). Also I would focus on the search algorithm, not on the init. I'm afraid with huge word list even init can be very costly, and worth optimization, but the initial data may be preprocessed ahead, so you then read not only word list, but complete definition of graph with edges between them. You should have posted, if the init itself is important for you as well (can be worth of effort for application where input word list changes often, so graph has to be rebuilt often). Imagine the words as nodes of graph, with edges between words different only in single letter (obviously words of different length form a completely disconnected sub graph, but even with words of the same length the graph can have several disconnected sub-groups). If a starting word has a ladder to the ending one, both should belong to the same sub group of graph. So first optimization may be to store each sub group separately (for example: having for 4-letter words two or more graphs). Then in O(subgroup_size*letters) you can tell if starting word belongs to the group under scrutiny. (with global hash map of words containing index to subgroup and index within subgroup the O(...) can get even lower, depends on hash map search implementation, but the initialization will get longer). Now the ending word must belong to the same subgroup, otherwise the ladder path does not exist at all, so another search of word ( O(subgroup_size*letters) ) will tell you, if the solution does exist. And also you will have both nodes (starting and ending word). Now you should do a "path between nodes" search, I'm not sure if the shortest one is required, or any will do. For these situations something like A* path-finding algorithm can be used. I didn't check A* lately, so just from my head some idea about such algorithm, basically searching the graph from both ends, in a deep/wide way by word_distance: You have to create some and set . will be distance (number of nodes) from starting point. Also set and marks whether belongs to the starting node, or to the ending node. Put both indices in the deque. Now till the deque is not empty, pick the index out of it and it's color. For all it's neighbours: 

Joseph cleaned up the code a lot so let me point out a few things that you'll be able to use in your future code. 

On the surface the code in your question seems fine, but I can tell you from experience that once this door is cracked just a bit, it will continue to creak open wider over time. 

Substitute your desired "not present" value of choice for . Edit: This is the short form of the ternary operator which evaluates to the first expression if truthy or the second expression if not. This is similar to how the operator is often used in JavaScript. 

The code implementing the core algorithm is very cumbersome. This is partly due to shoehorning the line entry/exit times into the first/last stations as evidenced by some internal stations in your tests having unusable exit times. But the code duplication doesn't help either. 

Do you have to instantiate new object input/output streams every time? Depending on how expensive this is, you may want to store them in a , especially when using the byte arrays above. You are seeking twice for every operation which could have a large cost if the block containing the header is far from the head/tail of the queue. Could you tolerate writing the size of the queue less frequently or in a separate thread? Are you writing to disk for fault tolerance or because it might grow too large to fit in memory? If the latter, keep it in memory only and write it when the application terminates or every x operations. Why do you need ? Can you use as the initial offset for an empty queue? Abbreviating to is terribad! It looks like the plural form of and doesn't add any value. Pay those extra two keystrokes for clarity and call it exercise if you need an excuse. :) 

I had only some limited quick look, just cherry-picking some things to comment on: Entropy level: I'm not expert on this topic, but I think using time stamp as additional entropy source every time you produce a number is not a very good idea. But I'm even afraid you use it as only source of entropy in some cases, which is definitely wrong. I was unable to quickly show what's wrong about it, as you have weird way of updating, masking the problem out in your example. But after you change this I'm afraid it will become obvious this needs rather some "seeding", and building up upon seed data. About : You do great deal of pushing all around into it, yet only pops from it, and only once. So after running this for a while (using it as output stream, without calling RNG) the buffer will grow a lot, eventually running out of memory. If this one is supposed to be a buffer of pre-generated random numbers, then the should generate new buffer value only when buffer is empty, and then it should pop value from buffer and return it. But I would do something different, I would change buffer into single number, used as seed. At any point of your current source, where you end with buffer.push, you would instead use old value of buffer as input for the transformation (in some way), storing result back to buffer. Then will do yet another transform over it, and return the value. But at this moment the timestamp-every-call will start affecting the statistics of random numbers a lot for particular date-time and RNG calling period. So I would use timestamp only for initial seeding, then the RNG would work as any common pseudo-random arithmetic RNG, with added twist of output stream being further source of entropy. About output stream as entropy source: well, you should check the common output stream byte values first, they are not "random" bytes. From the code it looks like you are aware of that, trying to build an unsigned value ORing 4 shifted values, but the result is only 20b wide for ASCII, and the values are overlapping, so the upper bits of ASCII (not varying much) will affect the lower bits of next character (I hope I did read the source correctly, didn't debug it, BTW for better readability you should put these transformations from string to unsigned into some function, so you can test it on it's own). I would probably take only 3 bits (or maybe just alternating 2+3, to avoid ASCII specific values definition to affect the entropy of such value too much) of each output character, and cumulate them in 32b buffer till it's full (the overlapping 1-2 bits kept for next value), then use it for transforming the seed buffer (so roughly every 10 output chars the seed will get additional entropy). This may still go quite wrong with UTF-8 or unicode16/32 output stream variants, just imagine somebody using it with UTF-8 Arabic texts, having every second byte something like or what's the actual prefix (too lazy to check). About : 

In PHP 5.0+, variables that hold objects are actually identifiers for looking up the object. Only assign using the reference operator if you truly need to bind those two variables together. Assigning normally will only copy the identifier and not the original object. Do you need a destructor that calls the parent's? I suspect that you only need to override it when you want to augment its behavior just like normal methods. However, I admit I've never needed a destructor in PHP and could be mistaken. This comes down to coding style, but I am not a big fan of leaving off braces for single-line blocks. I used to be, but once I got used to putting them on every time I became a convert. I can't count how many times I've added a second line and forgot to add the braces and wasted time trying to figure out why it was executing the second statement when the block wasn't entered. Finally, I'd add an explicit for those methods. I believe this will eventually be required for all methods (no more default) in PHP. 

Not Go-specific since I've only skimmed the syntax, but good advice in any language, you should refactor to extract several methods: