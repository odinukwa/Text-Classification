I think your question simplifies to "how do I run a command automatically at startup?" The answer to that is to put the command into a file such as . 

A couple of ideas which spring to mind - perhaps some will be more appropriate than others, given your setup. 

When you write in a C program, the compiler replaces it with a single character. The is called an 'escape', and it gives a special meaning to the character following it -- in this case the . Commands sent to the devices must be terminated with a suitable line ending, so it knows where the command ends. Common line endings are (which is a single number 10, or hex 0x0A) used by Unix-like systems, and (which is a 13 and a 10, or 0x0D 0x0A), used by Windows. I imagine your modules might work either combination. Nothing, as far as I know, uses just a . There are various ways you can send it. 

Yes, the yellow RCA jack is probably a video input. Connect it to the yellow RCA jack on the Pi. You just need a single RCA (or "phono") cable (The white and red jacks are probably left and right audio inputs respectively.) 

I'm late to the party, and you already have some very cheap options, but I reckon you may be able to do it for less - just a couple of resistors - if you have a PC with a spare serial port nearby. The hardware side is a little hacky, and the connection will be SLOW and you do say you want reasonably fast, but I thought it was worth a mention anyway. Premise: You can do network over serial using PPP (what modems use to connect to the ISP). So if we can get the Pi's Tx and RX to talk to a PC serial port, we can network over that. How can we connect the Pi's Tx/Rx to an RS232 port? The voltages are different, so you could either 

Write an app for your mobile phone. There are really good getting started tutorials for Android. Get the app to send messages to the Raspberry Pi over Bluetooth. Google is your friend. I found this example of a project which does exactly that. Make the commands change the state of the GPIO pins. Lots of tutorials exist for how to control GPIOs. 

If you wanted the Pi to detect the phones, you could have an app on the phones which looked out for a suitable SSID and connected to it for just a moment. The Pi would record the MAC address of the devices which connected, and the time. Then you have a list of people's MAC addresses and you're done. MAC addresses are spoofable, but not easily (depending on your definition of easy) on most devices. 

I hope that will get you started. If not, please let us know more about what you do or don't know. (For example, how much programming have you done - in general, on the Pi, and for Android?) 

Since you do not mention any special hardware setup, I assume you are using a normal Raspberry Pi with no special hardware changes or external wiring etc. This is behaving as I would expect: you are writing some stuff which is sent out of the serial port or to the tty. There is no reason that data would be presented back to you when you read from the serial port or tty. The serial port is essentially two wires: one going out, one coming back in. Stuff you send out doesn't automatically come back in. 

Assuming you want the phones to detect the Pi (not the Pi to detect the phones - which would also be a possibility). Short answer: I can't think of any way you can do this within your constraints (Android device does not connect to the access point) which CANNOT be spoofed, but here are a couple of ideas which are probably hard enough to spoof that nobody will bother. As I see it, you're limited to information you can convey in the Pi's SSID. I can't think of any other way to get information to the Android device, if you don't want it to connect to the Pi. So, how can you make this slightly harder for people to spoof? Here's my idea. Set the Pi to change its SSID every minute, to include a fixed "stem" and a new random number. For example, you could call it with changing every minute to a new random (unpredictable!) number. , and so on. Store the random number and the times it was applied in a big list. The Android app looks for WiFi access points with names starting with and then stores it and two successive numbers. It reports this back, along with the times they were recorded and some information identifying the phone (and the owner), to some server. This proves* that the phone was in that location for (at least) three minutes. *It doesn't really prove it. You could still spoof this, BUT you'd have to go to quite a lot of work (rewriting the application on the phone, or set up some sort of relay to distribute the numbers live and set up slave access points), because it reports the random numbers AND the times, so the server can verify that the numbers match the times. 

A quick Google of "40 pin pixel dot clock to HDMI" turned up this driver. I'm sure there are others. 

You will probably struggle. I couldn't easily get hold of the program to check, but by "Linux Ubuntu" it very likely means "...on an Intel/AMD processor", and it's likely that it includes binaries which will have been compiled for those processors. If it were open-source, you could (probably) compile it yourself, but it appears it's not. 

I don't think you'll find anything much simpler than a switch connected to all three Pis. It doesn't need to be any special kind of switch, just a standard single-pole button. Set the appropriate GPIO on each Pi to input, pull-up. Connect together the appropriate GPIO on each Pi, and one side of the switch. Connect the other side of the switch to 0v. Make sure all three Pis are grounded together. When you press the switch, all three inputs will go low. Do whatever you would normally do to deal with switch bounce. If the wires are very long, you could conceivably get noise problems causing false triggers. We can worry about that if it happens. 

There are several fairly straightforward solutions to this. Will all three items still be on the pads when the fourth button is to be enabled? If so, all you need to do is check for all four conditions: 

If you were to drive your roll of fabric with a stepper motor, you'd trivially know how many turns you'd done. Measure the diameter of the roll - perhaps with an ultrasonic distance sensor - and you can convert rotations into metres. Can you pinch the fabric between rollers or cause it to roll a wheel, and attach the wheel to a rotary encoder? 

Break the problem down into parts. Google each part. Combine them to make your project. First, you need to work out how to get sound from the microphone into Python. I found Python-SoundDevice and I'm sure there are many others. Now you have a recording. Next, you need to convert this to a set of frequencies. The things you want to look for are (Fast) Fourier Transforms or maybe Discrete Cosine Transforms. The maths is quite advanced but you can get away without understanding all of it, probably. I would recommend you research this part quite thoroughly as it's really not simple. At least, I don't know of a simple way to explain it. Again there are many Python implementations - the Numpy one came to hand quickly, Lastly, you need to decide whether there's enough of the required frequency in your sound. The frequency-domain data will contain many different frequencies. You want to check how loud your desired frequency is compared to the background noise, and use that to control your buzzer. 

There are more solutions - for example you could have your fourth switch connected between an output (which you'd set low/high to enable/disable it) and an input (which you'd read). That seems a bit of a faff, though. 

The optical mouse idea sounds quite nice also, provided it can reliably "see" the fabric. I'd be thinking along the lines of creating a new driver (heavily based on the existing mouse driver) so you can collect the data is a way that's convenient to you, not mixed in with real mouse data. 

will not do what you want. The reasoning is a bit involved, but for now, probably don't worry about it and just use the former. 

I suspect this may be more complex than you imagined, given the level of detail in your question. To "connect to existing telephone line" you need a telephone line interface - not too hard to create with some basic electronics. Read all about it here for example. To "do basic call related activites", I guess you mean dialling, going on/off hook, detecting ringing etc. For dialling you will need a DTMF generator, which you can do in software on the Pi. A quick Google search turned up this and there are many others. Detecting ringing and going on/off hook are explained in the first link, about telephone line interfaces. The Pi's audio output should plumb easily enough into a suitable telephone line interface. The Pi does not have an audio input so you'll need to add one to connect to your telephone line interface, perhaps like this. As for "create a web interface via which I can make calls" - this is a huge topic and you don't give any indication of what you know. You might consider using PHP to call external programs, for example. There are many options here but perhaps that will give you an idea to start with. Then you'll be able to make sounds on the line and receive sounds from the line. You don't mention what you want to do with them.