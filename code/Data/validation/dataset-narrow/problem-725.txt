and then, check directly whether the result is within your interval (without your auxiliary function, which just hinders readability). Now, the bad news: computing the number of days between two times, even assuming that they are in the same timezone, is hard. Your function only works if you are in UTC. To truncate to day for any timezone, use the solution in the accepted answer of this StackOverflow question instead. Once you have you correctly-truncated times, getting the difference in days between them is not as easy as you think: if you simply divide by (like you currently do, in a somewhat weird way), this will fail if the times are not on the same timezones. You say "that's not a problem", but you're probably wrong: most places in the world change timezones twice a year, for daylight saving time. So you have to take this into account… You have two options: 

→ , same for . is more readable. You can also convert everything that represents a time into a or a , rather than deal with Unix timestamps. There are functions in the package that do what you want to do (, , etc.). About that, why does need to do complicated things with times, checking when was the last time it was called, etc.? Shouldn't the caller take care of this with a simple instead? It feels like this complexity shouldn't be there. is a weird name for an implementation. maybe? Your package isn't very idiomatic, which makes the callers do weird things to use it. For example, why do you have a struct that doesn't contain anything? Why not simply have as a package-level function? Same for the other empty structs of this package (…). It's more idiomatic to test for rather than . I'm not exactly sure what you're doing with (this is pretty complex). Maybe add a comment for the line or refactor this part? Talking about refactor, is way too long. Split it in sub-functions. No need for an after . Rather than: 

If you can't guess, try it; it's a good way to learn =) Anyway, you don't want that to happen. So you can do this several ways. Before I'm going into two idiomatic options, let's talk about your interface definitions: 

Note that this benchmark is still pretty flawed: you're only testing it with a couple of values, so depending on which they are, the order of the if/else statements are going to matter. You should use much more values, picked among a reasonable distribution instead. 

→ . When a function returns and you want to return an error, you usually return the default value of along with the error. So in , you would return rather than . This helps you make sure that you're not going to use the return value when you return an error. Instead of printing the error with , you probably want to use and add an error message. Or not print anything at all and let the callers deal with the error (after all, it's why you return it), possibly returning instead of just . Close the file after usage. Add . Use a with option instead of trimming whitespace by hand. Your CSV file shouldn't have space after values (arguably, it shouldn't have spaces anywhere). On "does this look like Go", I'd say you have too much whitespace (empty lines in functions are seldom used), line returns (you never see them right after declarations () or assigments ()), and your variable names are Java-level verbose. In Go, you would use instead of , instead of , instead of , etc. 

Again, as I see it, this program does not treat an interruption as such, so I'll give you an explanation of how I've been learned to treat them and how it can improve your code. First of all, an interruption is a source which interrupts the currently executing code to execute another that expects an event. Due to this behavioral, an interruption should be always as short as possible. An interruption needs to be as short as possible because if you can call an interruption before it has ended (like in the case you are experiencing) it will overflow the stack pointer at some point in your execution and cause your device to not perform correctly. This happens because when calling an interruption the embedded saves where it is, performs the interruption/s (if more than one has triggered) and then comes back to where it was and resumes normal program execution. Do you see the main problem in your code with what I've explained here? If your interruption takes longer than the time you call it periodically, you will never exit the interruption, thus regarding your code unusable while also making your embedded to perform badly or not as expected at some point because of an overflow in the stack pointer. Because of this, an interruption should only consist of flag management which will be used in turn to allow the code intended to be executed in said interruption in the main body in your code. You might ask yourself how you can do this, so I'll give an example of how to implement this on your own code. 

We are given two list on integer arrays, and the objective is to retrieve another list which contains the duplicates in both lists. The code developed is the following: 

This code would make the greeting valid for both languages, while also making the code more mantainable if you want to change the greeting message for any language/s by having all the messages in the same place. Keep in mind I substract 1 from since arrays are zero-index based. Implementing language this way can save you a lot of code, make it more readable and also more mantainable since you don't have to look in n lines to fix an error that has propagated through all your languages due to copy pasting code. This can be applied too to handle any amount of users, further reducing your code and making it, again, more manageable when maintenance or improvements happen (which you are bound to do). If you need help in developing anything, comment my post with what you need and I'll try to give you an answer as clear as I can. Hope this helped explain how to handle multilanguage. Note: To ease the maintenance of interface messages, you can switch the matrix, n for languages, m for messages, that way you will have in the same first dimension the same message for all the languages, rather than having all the messages for a language in the first dimension. 

The code works as intended but, as said, I would like feedback on what I can improve in this code. That explains why I post this question even though there exist duplicates of this one, I just want feedback on my code, that's all. Thanks in advance for your responses. 

It doesn't seem that the library has a query builder or a specific type. So building a query in an idiomatic and readable way should be done as you would do for a normal string, and that is using the package. This will allow you to get rid of many code smells: 

In , you're needlessly allocating strings by modifying the variable. It would be a fairer benchmark to write it in the following way: 

you could also write but it's not that important. Now, the rune/string/byte question is the interesting one. deals with only; and converting strings to bytes and back is expensive (new memory allocations each time). So I'd change your code to use instead of , and instead of . The function becomes faster: 

Yes, this is the way to do error handling in Go. By design, you can't let exceptions propagate to the callers "silently", you have to consider what makes sense at each step. I found that on large-scale projects, it makes it significantly easier to predict and test the error handling behavior of your code. It also forces you to put the error handling first, which (imho) results in more readable, less nested code. Truly global variables don't exist in Go — if a package exports a variable , other packages will have to call to access it. That being said, it pretty much never makes sense to do that. In the example you gave, cmd.go and project.go are in the same package, and all package-level variables are shared, so identifiers conflict. If you want this variable to be shared, it's more readable to put all functions that use it in the same file. When you want to mock some of your functions, it's the sign that there should probably be an associated interface. You can then "mock" an interface easily, by re-implementing your interface in your tests and making it do whatever you want. I find this more readable and idiomatic than using complex frameworks. 

In short: your method should be two lines long, your method should be three lines long, you shouldn't have more than 2 global variables, and all errors should be caught on . 

why not: log.Println("fetching from hacker news", fmt.Sprintf(newsUrl, i)) Using everywhere makes your code not very resilient. Maybe it's worth looking at "what can fail for transient reasons" (typically, database transactions…), and re-try the thing that failed a few times with exponential backoff. There's lots of whitespace in the "what stores the data" part, which isn't very idiomatic. Empty lines in functions aren't really frequent. 

I put zeroes outside the func, to avoid converting it over and over. You still have a few conversions & allocations, but there's no way around them. The other functions can be modified easily to accommodate the type change. 

And, no, there's no easy way to have something more dynamic that , unless you have a specific use case in mind (and then, you would use an interface, but this is out of scope for this question). See this for a detailed discussion on why Go doesn't have generics for now. 

the line containing your query is long and not easily readable, maybe skip more lines you can write the skeleton to your query once, instead of using successive appends — this is also more efficient if you have many services the call to can be avoided using a simple condition in your template you can replace directly by its value, that you previously computed in your Go code and you can get rid of the variable that you pass to & , just do all the substitution logic in the go code. 

For N = 109 you have to store about 7.4 GB data, if you merely use longs with a size of 4 bytes. This is not feasible, which, I assume, is the whole point of the problem. You have 200000 Qs - storing the Qs instead takes up only 11 bytes per Q - one byte to determine the operation, 8 bytes for the two values which can go up to 109and 2 bytes for c, which fits into 16 bits, as it's not higher than 10000. If you store Q, you end up with around 2 MB of data. You could apply the Q operations at runtime to a single long (long) and then print each value individually. This algorithm will be memory-efficient, but very very slow. Looking at the problem, we will have a lot of array members having the same value. There are only 200000 operations but 1000000000 array entries - we can change 200000 different values - if we do this, we still have (109 - 200000) array entries with the very same value. Even if we modify 200000 ranges, this doesn't change the fact, merely the distribution of distinct values. So it's much more efficient to store a value and then for which array range this value is valid. In example: 

The first question I would have is: What head are you talking about, there is and ? Does the function modify a global variable called head? Not even your unit test creates a variable called head as head of the list ;) Your data is a void pointer and then you use , that's not legal, because the size of a void pointer can be different from the size of an int. It's already strange that you don't store a pointer to an int in data, but the int itself. Is this really what you want? Didn't you want to store the pointer to the int? I assume you actually wanted: 

You added the cast likely because the compiler complained. But the problem was not the missing cast, but that you converted an integer to a pointer, instead of an integer pointer to a void pointer, which can be done without cast. When you store a correct pointer, you can then display it correctly with: 

With this change it's a breeze to adapt data and also to add new resolutions without accidently messing up code that worked before. 

This way changes of the data do not change the executing code, also the data is actually grouped together - you have a chance to spot erroneous data just by pattern recognition (or rather that something disturbs the pattern). Then we see that the data also correlates with the input parameter. We can include this, too: 

Regarding the updated code: I don't like the use of the term in the functions. You have this prototype: 

The context is passed (as pointer) to each function so it knows the circumstances it operates under. This also groups relevant data together. The second context you operate under is a specific meter. 

Here I would establish something that I call context state. Your functions and daemon run in a certain context that is established. 

This is a mixture of storing the value and storing the operation. When you need to print a value, you look up the range and print the value. As you see, we need less than 64 bytes for this simple example to store the information how the 7.4 GB data is compromised of, yet we can print the value for each and every array position. Even if we have reduced the data, we still need to optimize the remaining data. We can't just dump it into a linked list - as stated, we can end up with Q+1 entries (200001), we can't afford to search the entries with an effort of O(n), let alone (r-l) * O(n). But if we put the data into a binary search tree, we can find the correct array entry in 18 steps within the 200000 entries. This costs us some more memory, not only due to the overhead, but as we need the array index as key, we can't group all identical values together, just as long as they are one range. So the example above will need 4 nodes in the binary search tree, to separate the value 0 twice. So, when you combine these two approaches, you should be able to get a decent memory and processor time consumption.