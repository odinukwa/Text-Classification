That just makes the syntax so easy to remember as well as provide you with enormous control over your events. If you're going to use jQuery on a regular basis, I recommend that you take some time and read through the source code of the methods you're using. To find them quickly just use and type . That should jump you straight to what you want to know. This way you can understand what and how they are doing things, and even find better ways to do them on your own. Also if you see something you think should be done better or differently, you understand how it works and you can contribute to jQuery. 

If you didn't know already, this type of plugin is referred to as an accordion. I would suggest reading the code for the jQuery plugin (since you are using jQuery) to find out how they do it. With this you can get ideas, see their organization, and if you find something that can be fixed/improved you'll have the power to contribute! To add to redexp's answer about the method. In your click functions you might want to prevent the default browser action on a link, which is to direct the page to that link. Since you just want to perform something on your page and don't actually want the browser to leave the page you should prevent that action. The difference between the two is that does that and at the same time stops event propagation. Propagation being when you click on an element, it triggers an event on the element, and any events on its parent elements (because technically they were also clicked). Whether or not you need to stop propagation is up to you, so pick accordingly. So basically: 

First off, your documentation is incomplete in a few places. For example, in your function, you didn't fill in any of your documentation, except for the part. And, in your function, you only filled in , , and . Finally, also in , you called the parameter "rows" in the documentation and called it "cols" in the function signature. Choose one and stick with it. Documentation is a very important part of every function. 

Now with that information be said, we can easily create a map/different of the different metric "types" and the number of basic units on one of this type. That would look like this: 

2: The value is called a falsey value. That means that can be treated as though it were false. So, for example, this here: 

I've searched everywhere in the Java API documentation and I haven't seen anywhere a class called . However, from how you are using this so-called , it seems to me that this is just like a . To reduce confusion, I recommend that you use a instead (probably an ) rather than this thing. 

Game design Don't rush me Why do the letters disappear after a few a seconds? What if I need time to think? To me, this seems like a "hacky way" to hide the cards after two were chosen. Also, this even leads to a problem that occurs after a pair is found: the space I click on next shortly disappears, even though I just clicked it. After a pair is found, you should clear the timeout with so the next spaces that are clicked do not disappear. 

Don't be intimidated be the size of the book, I just like to write out and explain in as much detail as possible. Well anyways, I've pretty much re-wrote the whole plugin. I've applied a more object-oriented approach and re-factored the plugin into the Module Design pattern. It's now much easier to add functionality and debug code. I've also added in some safe guards to properly initiate the plugin as well. At the end of the code, and inside it, I've included a few links for reading and watching materials. I highly recommend you go through them as they can explain the concepts demonstrated here a lot better than I can. 

UPDATE I've looked at your .js file and there's quite a bit I would change. But focus on the resize event for now. The way you have it now, the code runs hundreds of times since it is called each time the window size changes, even if the user isn't done resizing. Now we don't want to do that since it can really slow down the browser, if not crash it all together. So what you want to do is only run when the user stops or is done resizing, then run the code. Here's an example of how I'd probably do it: 

You should be passing an exit/error code. The exit code describes how execution went to external programs in a single number. Any non-zero number means that something went wrong. Therefore, for example, when you are ing from the program in , you should be passing a non-zero number to show that something went wrong. 

with the number . Well, the filter is not null so that is false, and the filter is always going to say no to any input, so that is also false. This conditional does not, and we loop again to the last element: . now holds because of: 

Versatility It is very, very uncommon for an HTML tag to just be a tag along with inner content; there are almost always attributes. Right now, your code can only generate something like this: 

However, there's a problem with this: your variable needs to keep its state, so if we just drop it in the function, then it will lose its state every call. So, that means we need to have this function return another function like this: 

In fact, let's take this one step further: let's store all the buttons in an array. This is very easy to do with . This will return an array of all the elements that are of the specified tag: 

The Sieve of Eratosthenes works by going through and marking all numbers that can be divided into, essentially. Take your input "n", for which you want to find all the prime numbers up to it. The sieve starts at 2, and multiplies 2 by increasing amounts until the multiplication is about to exceed the value "n" - in your program, this is accomplished through the integer division and then iteration up to the calculated result. So, as it multiplies the values together, it marks the result as non-prime. Meaning that 2, 4, 6, 8, 10... etc are all set in the bitarray as 0 (meaning non-prime in this context). It moves on to the next value, so it starts at 3. The process repeats as it marks all multiples as non-prime. Time to move on to the next number - 4. As 4 has been marked as non-prime, it skips over 4 and moves on to 5. This continues until it finally reaches the number which is the value of its square root, so when you are using the sieve to get primes below 100, that means the algorithm checks the multiples of values from 2 to sqrt(100), so 2 to 10. It doesn't need to go past this value as all prime values above that share multiples which values that have already been checked. So, for example, if we moved past 10 to check multiples of 11, we'll get 22 (which is divisible by 2, so has already been marked non-prime) and 33 (divisible by 3). The values which remain with a value of 1 are prime. tl;dr The algorithm goes through all prime values below or equal to sqrt(n) and marks their multiples up to n as non-prime. The remaining numbers must be prime. EDIT: The code above adds 1 to the div operation, which I didn't mention in my explanation. EDIT 2: This specific modification of the sieve is essentially the same as the original sieve, however rather than removing square values during the normal removal process it removes them separately at the end. 

Other than that, your "translation" from procedural to object seems fine; all you basically did was stick the methods and variables in an object and add to the beginning of a few things. I think that the code is good in an object because, as you said, it aids organization. However, since I don't know the full/rest of the code, I can't be sure if this is the best approach for your situation. 

This will make sure to only include the file if the operating system is a Windows one. Then, in the section where you would normally open and read from the file, you would encase that in: 

I have one main problem with this function: you are hard-coding the enemy to be a "snake". What if you want to have another enemy? Are you going to create another practically identical function just to print out a word that is not "snake"? Of course not; that would not be very effective. To make this function more flexible, let's add a parameter to the function that is the enemy that the user is fighting. That is done simply like this: 

DRY You are repeating yourself in a lot of places in your code. In fact, I'd say most all of your code is just a giant repeat. 

I think simply put, HTML semantics is closely related to grammar in any other type of language. If you want the people (or computers) that are reading your text to best understand what you're doing, you need to use proper grammar. We can still understand you if you write like a ghetto fool but if you want anyone to take you seriously in writing, you have to do it right and follow basic grammar conventions. 

It's all probably a lot more complicated than this and articles like this probably explain it all a lot better. As you progress in plugin development you should start to think about implementing design patterns. There are almost endless options of patterns you can use and some you can event make sort of a hybrid pattern. Don't feel overwhelmed with all the options pick out a couple to start with and try them out. I'd suggest the Module Pattern (another good article) since you've already sort of implemented it in this plugin. Also look at the Observer Pattern (aka Pub/Sub) it's great for dealing with custom events. This video by Jeffery Way does a great job of explaining the concept. I'd recommend you'd watch the rest of the episodes from that series as well because he does cover some good ground on plugins. 

What is with all the functions? This is the main C file and, as far as I can tell, the only C file in this project. These s aren't needed. 

Then, your method could take an array of these and loop through them, adding them to the string each time. 

In JavaScript, it is bad practice to iterate through an array using a loop. You should be using a normal loop: 

When the end of a line is reached, then this is called. However, since the file you are reading is from and also reads from , then this call is going to remove the next character from the file. See the input again, but with the characters removed by : 

Your current code already follows this structure. However, as show above, it doesn't quite do what it seems. 

The method is a non-standard feature and it may not work across different user's browsers as each browser may have a different implementation, or may not have implemented it at all. Read more at the red box at the top of this Mozilla Developer Network article. I'd say you are better off using because most browsers implement that, and use the same base implementation. 

This answer took me a while to write and I was a little drowsy as I wrote it. If anything is too confusing, just let me know in a comment. 

I'm learning Java too! Looking at this the only thing I might suggest is that you only do the calculations that you need to. You could then remove all answer variables and print the result of the calculations directly, saving time and memory, albeit not much. In terms of presentation, I personally would use lowerCamelCase for variable naming, e.g. firstNum, and I would also indent all of the cases as they are within the switch block. Finally, for I'd make sure there was no space there. Despite what I say for the presentation, that part of it is totally up to you, so do what you prefer, as long as it looks clear! 

shouldn't work because - well, imagine this: runs and now temp is set to the last node. Then, the check is ran . Because the last node is not null, it will run , and because you're already on the last node this means that temp becomes null. The check then runs again, and as temp is null it moves out of the loop and attempts , which doesn't work (and probably triggers an error) as temp is null. You're gonna want it to check the next node before it sets temp to that value, as it does currently. As for code review, the logic seems sound, and presentation is up to you, however if this were my code there would be a few things I'd do personally, however I'll put an example instead of points: