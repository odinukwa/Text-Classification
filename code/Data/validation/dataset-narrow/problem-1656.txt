Obviously wrapping this stuff in something more concise is a good idea. Note the use of newlines; this is necessary. I recommend using the low level functions here and not higher level stream based ones. I have heard of people disturbed by this because of some presumed I/O overhead. Again, they are not disk files, // are system calls, you are interfacing with the system, etc. There is a more specialized API for using the I2C bus that is C specific, with dedicated function calls. Although I haven't used it, there's also an API for SPI which is also based on reading and writing to sysfs nodes, but appears to have a few C features too. Note that you can go up levels up in those documentation links to traverse a tree -- it's mirrored from the kernel source directory. 

If you mean you just want a remote command prompt, SSH is the standard tool (it will do graphical X forwarding too, but that is slightly more complicated). To enable the server on a Pi using Raspbian, add a file named to (aka. the small first vfat partition) and reboot. You then need to install the openssh client on the RedHat VM, if it is not there already. The command to connect is: 

Then X would exit when epiphany does. Notice no at the end there, or what would happen is epiphany would fork, the script would end, X would die, and epiphany would go with it. 

Same trick, different place. Now when someone closes , shutdown will happen (but if they kill X, it won't). You could also do it both ways, but I actually like this one better because it means you can exit X and get a login, which may be useful sometimes, and you can also easily turn the system off from the GUI. Don't background () myApp in the .xinitrc even if there is no shutdown after it though, because when the .xinitrc is done X exits ;) The last call there has to persist in the foreground (normally, it's a DE or window manager). Init scripts and are similar concepts. One is run by , which is process 1 on linux (it's the only process started by the kernel). The other is run by the X server. Note that there are .xinitrc files and an xinitrc command (they're related but not the same). 

Because the Raspbian image is not a filesystem image, it's a device image. It is intended to be used like this: 

It sounds a little in your question like you might be inserting SD cards with the power on. Don't do that. It won't work and nothing good will happen doing it. Insert the SD card with the pi unplugged, then power it up. A green light on constantly on a Pi 2 indicates the card was rejected, e.g., because it is not formatted correctly. No green light on an A/B/+ means the same. Or else the hardware is broken, but this seems an unlikely coincidence on both of them. 

Probably the safest/most paranoid way to allow for this is to export the individual pins and make them owned by the server user, e.g.: 

1. Note that while the mentioned there is still in the source archive if you download it, the online version has changed location and gotten a bit snazzier: $URL$ ...However, the keyboard is not part of this, or at least, not in the sense you need. 

Raspbian is a regular debian system, there's no special case here. Since anyone else with this problem would also be unable to boot, I'm not sure what you mean by them having access to files that you don't... You do need to be able to access the SD card outside the pi, preferably with another linux system (on a live CD, in a VM, whatever). Without that, you are sort of tying one hand behind your back. 

Again, no number on the end. This should show the two partitions, the first one of which is type and the second . This doesn't guarantee the card is okay, but it is a good sign. You can also use if you aren't sure if or or whatever is the card, since regardless of what filesystems are or aren't on it, the first line will tell you how big the device is in GB. Unless you have a lot of USB drives sticking out of your machine, the card is probably the only thing that is ~8 or 16 GB or whatever size it is. 

I think you are out of luck. Although I doubt it is the case, you could leave it unplugged for a few days on the chance that it is the main polyfuse that's heating up (but I do not think the symptoms of that would be as you describe). 

I agree in general with gnibbler. It will work but it will very noticeably under-perform a desktop. For what it actually costs (< 10% of a cheap cheap box), it's great, but keep in mind it doesn't cost much. Vis, doing things with the OS (browser kiosk, etc), linux is extremely (and easily) malleable -- hence stuff like SUSE Studio, which is linux based. Unfortunately, it is very unlikely to work on the pi as the vanilla kernel source needs some tweaking first, and I do not think SUSE has such a version for the pi. The primary general purpose pi distros are versions of Debian (raspbian), Fedora (pidora), and Arch. However, the fundamentals of these (and SUSE) are identical in most respects. I mention this because you could always buy a pi, configure it to do what you want, then if you decide the pi hardware isn't good enough, you can easily transfer your configuration to a normal desktop platform using whatever medium -- hard drive, usb stick, dvd, network, etc. Conversely, you could also try and create what you want using a general purpose distro on a desktop and, if that suits you, get a pi and try that configuration there. Another option involving the pi would be to use it as a thin client; a decent desktop used as a headless server for this should be able to run web apps for at least half a dozen of them that way (while all the pi has to do is present the GUI), but more expertise would be required to set it all up. 

This is not a direct answer in the sense of "here I wrote a script for you" but it does contain some information that might be helpful to you or someone else who wants to do so. You can probably automate via a tool called , which is intended to be used in scripts with interactive CLI tools; the basic idea is you tell what prompt to expect and what answer to provide using an "expect script". It isn't installed by default most places, and depends on Tcl, which may also not be installed, so you could just do that and have a look at it and play around, or have a look at the man page online (e.g.) and whatever tutorials and examples you can find (remember, search "linux expect tutorial", do not include "raspberry pi" in your search terms). [Regarding OSMC: I'm not sure OSMC is intended to provide things like this, so you should check that first and if isn't available, keep reading, because it is more likely to have , which is a better option anyway; if that isn't available give, you are out of luck.] Using is not the ideal answer here, however. The better option is a tool called which is sort of like , but intended for scripting using its own format. This can be fed via stdin, so you could do it with a "here document" in a bash script. A thing about partition tables is you can screw around with them without destroying any data as long as you don't actually mount and use any of the partitions. The partition table information is written to a part of the device that is separate from the partitions themselves, so you can completely change things, then put it back the way it was -- no harm done. I'm saying this because you could get comfortable with by reading the man page and playing around with a spare USB stick (if available). The first thing you'll want to do is make a back-up copy of the existing table that can then use to restore things later; see the option. Sfdisk is probably installed by default; try to find out. You want to read that page anyway. There is a newer version of (2.26, from 2015) that has a much better man page (and some additional functionality for GPT disks, but that is irrelevant on the pi). Unfortunately, Raspbian and other Debian derived distros (I think this includes OSMC) are still using a version from 2011. I would guess it is otherwise much the same but the man page is not as friendly. The ones found online are mostly for this old version as well. :( The newer one has a whole section "BACKING UP THE PARTITION TABLE" based on using 

Which, by coincidence, is a GNU command (i.e., standard on the system). It operates on files (see if you care) so 

So that's the smallest resistor you should use to prevent burning th LED out. However, you probably won't notice any difference in brightness if you use one twice as big, and you won't notice much at twice as big again. You can experiment with that -- but do it one at at time, because what you don't want to do is 

You'll find an . I would guess this is via the C library call, which interestingly does not involve an actual syscall -- other than those involved in opening and reading . If that meant nothing to you, don't worry. The point is UIDs and GIDs are fundamentally numbers, not names. Those numbers are kept intact. The superuser () is always 0, but there is thus an obvious security concern in copying part of a filesystem from one system to another, if e.g., bob's UID number turns out to be larry's and larry can access the copied data. But it is easy enough to prevent this, particularly if you are ing it all into a single file.