The config file only lists host-to-IP address mappings, but never (service) ports. So, a doesn't belong here, simply remove it. You need to specify the port number explicitly in your URL anyway if it differs from port 80. Port numbers in URLs are a dedicated element and don't belong to the host DNS name/IP address part in an URL. They are dealt with within the browser, but not in DNS (DNS SVR RRs are not taken into account when resolving URLs). 

Beside lacking a non-APIPA IPv4 address, you also lack a default route via the WLAN interface. The only route you see is a direct subnet route, probably an APIPA autoconfigured IPv4 subnet (with an additional indication in form of its /16 prefix size). You need to make sure that the IP network you connect to via WLAN has either a DHCPv4 server running -- or IPv6, or both. The DHCPv4 server then should distribute not only the IPv4 device address and subnet mask, but also the default route and (proxy) DNS server address. 

If it's an HDMI monitor, then it's per definition driver-less. Other displays for the Pi aren't driver-less, except for the official 7" touch display. For the power supply, just follow the official Fondation 2.5A supply to be on the date dose until you've gained more experience. 

Shut down of USB devices (as is the Ethernet port on the Pis) may also happen due to undervoltage of the 5V rail. What does has to say? If your Pi has seen undervoltage since last boot, you'll see , otherwise , as far as I know. 

Yes, you can bridge an Ethernet network interface with an Access Point WLAN interface. There are many tutorials about this, even the Foundation has it here: $URL$ ... make sure to scroll down to the lower part where the bridge configuration is given. 

If you don't need an exact image clone or image file, but instead just need a logical mSD clone, then have a look at rpi-clone which is a terminal script. It allows to "clone" to a physically different mSD, and creates bootable mSDs. A simple creates a fresh copy from the running system. Lateron, does a delta update. Project is on GitHub: $URL$ 

I understand your mobile hotspot to have Internet access and to provide it to other devices through a Wifi/WLAN hotspot. As from your post both your PC and the Raspberry Pi have WLAN. The easy route: Forget about Ethernet (I'm explaining why in a second) and connecting both devices directly to your mobile hotspot. This way you can achieve your usecase without gettling lost in difficult network setup details. Why no Ethernet? There are two reasons: first, your home router not only is a switch, but it also has a DHCPv4 server built in. You would need to disable it. Second, you would need to set up your Pi as a Wifi-to-Ethernet router. A bridge configuration wouldn't work, due to the 3-MAC-address restriction of Wifi. So, your Pi would need to NAT your Internet access (again). In addition, you would need to run a DHCPv4 server on your Pi. The difficult route thus looks like this: 

Create a full 1:1 image on a smaller card, say, an 8GiB card. Later flash this image to larger cards, such as 16GiB cards. This is the fastest method if your image has a good ratio of used blocks/total blocks. For rather sparsely filled images, a plain 1:1 flash might not be the fastest method after all. After flashing, you may run a one-time script to expand the system partition to the full size of the mSD cards in order to make good use of the available storage. This is the way done with Raspbian, and other distros. Clone your master card/master image logically onto your mSD card copies, with a cloning tool, such as rpi-clone. This can actually be even faster or on-par with plain 1:1 flashing in case your source image/card is only filled to a lesser extend. 

As of Raspbian 8/Jessie, IPv6 is enabled in the Raspbian images right from the start. There is no need to touch any configuration. With the client installed, IPv6 stateless address autoconfiguration (sic!) will be used with stable semantically opaque IIDs (interface identifiers). You only need a router advertising an IPv6 prefix (or several). In addition, DNS server addresses will also be autoconfigured from the router advertisements (RA). It's perfectly fine to have the RAs set M=0 and O=0, that is, no DHCPv6. 

Fortunately, has a built-in check that will do only a limited number of restart attempts in case of failures. Normally, these settings should suffice. More details can be found in 's documentation here: service unit configuration 

The directory usually is used for mounting external storage devices, such as USB thumb drives, USB harddisks, SMB/CIFS file sahres (if I'm not mistaken), and so on. When using the Pixel desktop, the next subdirectory will be the filesystem label of your storage device you've plugged into the Pi. Whatever you deleted inside , it probably belonged to the contents stored on one of your external devices. It's gone now. 

One reason may be that many of the various RTC chips, such as the DS3231, store time only with second prevision, when read from or written to. Thus, I would expect a normal variation of +/- 0.5s depending on when Linux read the hardware clock on each boot. Also, when setting the hardware clock initially, only seconds are stored, so you may end up with +/-1s overall. However, you should see only a random fluctuation in this range, but not accumulated deviation. Except, in case you constantly update the hardware clock from the Linux clock: this would quickly accumulate these errors. As you didn't give details in your question this is only speculation at this time. 

To summarize the comment section: we don't know why changes the disk identity, but can only guess (or rather speculate). Anyway, this change made by has the undesired side effect that it renders Raspbian images after beginning of April 2017 unable to boot. The reason is that the partition UUID (PARTUUID) changes, and the kernel boot parameters as well as the still reference the old PARTUUID. So either don't use , or update thr command line parameters and with the new PARTUUIDs you can retrieve via blkid. 

Replace with your particular SD card reader/writer. I'm solely using the script for many months now and I never had any issues. The only caveat: don't do a delta update to an mSD with an existing, different OS setup. Just use the option to ensure that you get a working clone in this case. 

You may have been able to use the hostname, before enabling host AP mode, because you had the DHCPv4 client running that was registering withnyour LAN's default gateway that may also be running a DHCP and DNS proxy server. Now that you've disabled dhcpcd, your Pi doesn't get registered anymore with its name. A lot of platforms and applications only use DNS, but not mDNS (avahi), unless explicitly enabled. 

When using the Pimoroni Button that gives me five buttons and an RGB status LED. I'm simply using a Python script that uses so I need to press and hold button A for two seconds. I don't know whether GPIO zero has something similar, so the example below simply triggers on a button press. (Side node: don't know if GPIO zero has debouncing and whether that's necessary at all.) In my I call the command to find out whether the AP is on our off. The command returns status 0 if the AP is on, then run the commands above to switch it and wifi off. If the commands returns a status code other than zero, the AP is off, so run the second set of commands to start wifi, AP, and the DHCP server. And now all this in Python 3: 

Network layer: decide whether to use your phone in tethering mode so it works as an access point, or configure the Pi to act as an access point. Unless you can connect both devices to an existing Wifi network, you'll need to put one device into access point (AP) mode. 

The most basic check is to leave out any mSD card, and then to power up your Pi Zero W. It doesn't matter if your power through the power-only micro USB socket or backpower through the OTG/slave USB micro socket: both will be fine for such tests. If on power on you don't see the green ACT LED lighting up and shortly blinking, your Pi Zero W is pretty much dead. Check your soldering for any unwanted solder bridges or solder blobs that went to places where they should not be. As every Pi gets fully factory tested, there is a very low chance that your Pi arrived dead. There have been few cases of wrongly programmed OTP fuses, but that's not the case here. Please note that with the Pi Zero W the meaning of the ACT LED has been reversed from it's meaning on the 3B: this allows the single ACT LED to also, erm, act as a PWR LED. So normally it should be lit. Only when there are mSD card read/write, ACT starts to blink or going dark if there are extensive read/writes; but usually only for two or three seconds at most. 

Connect your Pi via Wifi to your mobile hotspot. Configure your Pi to act as a MAT router between Wifi and Ethernet, see here: $URL$ ... but with one important exception: don't change the interfaces configuration of wlan0, keep it as it is so it still autoconfigures. Check the IP address and netmask you get from your mobile hotspot. These must not conflict with the IP address set for eth0. If it does, you need to change the configuration accordingly. Make sure to switch off the DHCPv4 server in your old home router, so it works only as a switch/bridge on Ethernet/Wifi Connect your Pi via Ethernet to your old home router. You should now be able to access the Internet from you PC: PC-->home (router) switch-->Pi (new home router with NAT/DHCPv4)-->mobile hotspot-->... 

Paste, save, exit. Reboot. Now the Pi will connect to this network every time it is available. You can also add multiple networks to this file. 

So the OP is actually using Debian Stretch, and not Jessie, as he is bitten by the less-than-stellar decision by the Debian maintainers to enable "stable" network names. Unfortunately, the maintainers (both Debian as well as Raspbian) do not seem to realize that having stable, albeit unpredictable network interface names based on the MAC48 of the network adapter is a bad idea on server platforms, such as the Raspberry Pis. The reason is that on the Raspberry Pi hardware platform, the builtin Ethernet and Wifi network interfaces are connected via USB. And Debian Stretch now enforces USB-based network interfaces to use the unpredictable naming scheme. This results in total confusion as can be seen here, as the unsuspecting users are completely left in the dark. How many users will understand what is going on? Alas, to switch off this naming madness, follow these instructions from the Stretch release notes, to get back to stable and predictable network interface names on Raspbian, and I don't like this, how do I disable this? in particular. In short: