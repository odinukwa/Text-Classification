You want the expected value to be .95. In simple terms, this is the sum of for each state. A brute force method would be to iterate over all 22^3 states (assuming you have 3 reels), add up the payout, and divide the sum by 22^3. However, since most states probably don't pay out anything, it might be easier to work out all the states that do pay out instead. For example if you had 1 Bell sybols per reel, then the probability of 

In some games that I've seen, the debug console is actually the Lua interpreter prompt. That way, anything you can call from script can be done from the console. 

I agree with Alex, but more to the point, I don't think you'll find a silver bullet approach to make collision approximation models. You will need to let your editor pick from a list of optional methods or generate one from scratch. After a tree model and material have been made, creating another cylinder and sphere mesh for collisions should be negligible effort. 

Have you looked into entity component systems and event messaging strategies? Status effects should be components of some sort which can apply their persistent effects in an OnCreate() method, expire their effects in OnRemoved() and subscribe to game event messages to apply effects which occur as a reaction to something happening. If the effect is persistently conditional (lasts for X turns, but applies only under certain circumstances) you may need to check for those conditions at various phases. Then, you just make sure that your game has no default magic numbers also. Make sure everything that can be changed is a data driven variable rather than hard coded defaults with variables used for any exceptions. In this way, you never assume what the turn length will be. It's always a constantly checked variable that can be changed by any effect and possibly undone later by the effect when it expires. You never check for exceptions before defaulting to your magic number. 

I am currently developing a MOBA/RTS style game with an authoritative networking structure. Of course, the server needs to send a big number of packets every second, answering requests from the clients. The packets are split into commands and states. Commands contain all the actions a unit has performed since the last send-procedure, and states include the position and rotation data about a unit. Commands are sent over TCP because they need to be in the right order and reliable for synchronized gameplay, individually to every client, states over UDP through a multicast group that consists out of the player clients because I interpolate, and a lost packet will not create any damage then. Today i came across the RDM socket type, selectable through the C# Socket constructor, and I thought that this maybe is what I really want? My TCP connections currently do not make use of the seamless streaming of bytes as I wrap my data into packets and send them in constant intervalls. is the RDM socket type what I want? Having reliable connection-less packets send over PGM sounds really promising to me. 

I would avoid the general idea of a tower type. Let tower contain a set of properties that matter. An Attack object (that has its own range, RoF, damage, sound effects, onHit() effect for DoTs, etc.), a model, health, location... Then build factory classes that are asked to build a "type" of tower by figuring out how to initialize a tower to be a "cannon" or a "mortar". This way your systems never need to look at a tower type. Graphics for instance just draws the model specified at the location specified. It doesn't have to lookup the appropriate model for towertype X each frame for each tower. What makes this great is that if you want a new tower type, you just make a new initializer that builds those towers with different defaults. Your systems won't need to be "upgraded" to support it. 

Noel Llopis has some articles in Game Developer Magazine a few years ago about implementing deterministic replay; they're reprinted here and here. tl;dr version: record all your input and be able to play it back, avoid real randomness (pseudo-randomness is fine for most cases), and implement determinism testing early so that you know when you break it. 

John Ratcliff has a code snippet to do this, and it's hosted on Google Code. You'd still have to write the command-line code around it, though. 

Eigenvalues and eigenvectors are very commonly used in math, so it's good to understand them even if you don't have an immediate use for the in games. They're generally covered near the end of an undergraduate-level linear algebra course. One I can think of is for dealing with the moment of inertia in physics. This is a symmetric positive-definite matrix, so all the eigenvalues are guaranteed to be real and positive. If you compute the principal axes of a rigid body (which are the eigenvectors of the matrix), you can rotate the body so that its moment of inertia is diagonal - this would allow you to store just the diagonal components as a vector3, instead of the full matrix. Another place I've seen them used is computing the best-fit plane to a set of points, or to find the best-fit bounding box (section 6.1.2 in the link) Have you searched in the WildMagic or Ogre code to see where else they're used? 

I assume that you're asking because file sizes would be too large to make copies of your SQLite file for each "new game", so I don't believe you have any alternative. Otherwise I'd say just copy that original game state and alter it directly. You may consider the idea of firing a sort of OnLoad() event whenever a new area is visited. It could check the time of death on each enemy found in that area and "expire" them away from your data file before you finally display that area to the user. It might be a bit tricky, but you could even have another thread combing for expirable changes in your gamestate whenever your main thread is not actively trying to access the file. You'd want to think of a clever of indexing "expirable" state changes however. 

Sorry if that's not a valid Java struct (I haven't touched Java since undergrad) but hopefully you get the idea. 

EDIT: The above only tells you how to check that the payouts give the desired return rate. As a simple example, lets consider a game where you pay $1 to flip 2 coins. Here are three payout schemes that all give a return rate of .95: 

Where are all your comparisons () coming from? If it's from a sort function, could that be replaced with a radix sort (which is asymptotically faster, and not comparison based)? Looking at your timings, even if the sorting itself isn't that bad, your function is being called twice for each function; all of that data should be computed once. It should be faster to sort an auxiliary structure e.g. 

Properties like or are shortcuts for . So yes, the GameObject your script is attached to is the Object the script "sees". To your second question im not sure what you mean with manipulate but most of the time the answer is yes. MonoBehaviours should (mostly) only affect the GameObjects they're attached to. To the Find method you mentioned, i guess you mean the method, you should not use it. Has bad performance and if you want a reference on a different GameObject just add a field to your MonoBehaviour and drag-n-drop the object you want to access in the inspector. For more questions about the script system or other stuff in Unity feel free to ask me. 

You might have misunderstood me a little bit. Not all objects HAVE to use factories. Perhaps only your tower and enemy objects. Maybe your Attack object as well as a Projectile. You'll need to tinker to see what fits the pattern. Some people would create a generic Entity/GameObject class though. You could do some research on Entity Component Systems to see how that works. Ultimately though, if a "cannon" is built, you could call to get a . Just pass it Then use that to call This method (implemented in ) will make a and set all its properties accordingly for a cannon tower. You could do something similar for stamping out enemies of various "types" as well. 

Two heads pays $3.80, everything else pays nothing Two heads or two tails pays $1.90, everything else pays nothing Two heads pays nothing, everything else pays $1.26 

I can't vouch for either one, but there is a utility available here for going from HLSL to GLSL: $URL$ and here for going the other direction: $URL$ The first one is explained more here: $URL$ 

@The Communist Duck already posted a Wayback Machine link, but here's another version of the article that appeared on Gamasutra. 

This should be equivalent to testing the ray of the AABB path against the Minkowski sum of the line segment and the AABB. The Minkowski sum in this case should be pretty simple - it's a convex polyhedron formed by sweeping the AABB from one endpoint of the segment to the other. Once you can figure out the planes that define the polyhedron, you can use e.g. 5.3.8 from Christer Erison's RTCD book. The hit fraction from the raycast is the same as the hit fraction for the AABB cast.