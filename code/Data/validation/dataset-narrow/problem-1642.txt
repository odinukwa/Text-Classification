BerryBoot is designed to download prepared images from the internet. If you are a linux user (or you want to dig into it), you can follow these instructions from the BerryBoot documentation to prepare the images yourself, then put the prepared image to a USB flash drive, plug it in the Raspberry Pi, boot up BerryBoot and add the image through Add OS > Install from USB stick. 

This would be enough to use to talk to your RPi with different programs. To simplify your life further more with SSH, you can also create a SSH config file in your user directory in . For the IPv4 address it would look like 

I think, there is no way to have avahi assigning you a static IP address (an IP address looks something like 192.168.0.23 for IPv4 or 2001:DB8:F001:BEEF::23 for IPv6). What you are probably talking about is the domain name, avahi is announcing to the network (raspberrypi.local). This domain name is resolved (translated) somewhere in the network to an IP address, because this IP address is the number your net is using to deliver the IP packets to the target. The translation domain name => IP address is usually done by a Domain Name System Server (DNS Server). There usually is no DNS Server in a simple home network. Sometimes your Wifi router is doing some DNS stuff. But in your case, you are doing the name resolving stuff with avahi. This is how avahi works: The avahi daemon on your RPi is choosing some link local IP address (say 169.254.0.1, you should see this in your ifconfig output, link local addresses are always beginning with 169.254) and then it is sendig messages through the net, announcing: 169.254.0.1 should now be called raspberrypi.local. These kind of messages are received by other avahi daemons or by zeroconf daemons on Macs. zeroconf will write on it's list: 169.254.0.1 is now called raspberrypi.local. If you type on your Mac, zeroconf will replace raspberrypi.local with 169.254.0.1 and ssh is talking to the correct machine. It could be, that your RPi is selecting another IP address after a few hours (maybe because nobody talks to it?). And it seems like your Mac is not listening to the annunciation of the new address because it is sleeping, or there is a communication problem between avahi and zeroconf. Solution: I would recommend, not to rely on avahi / zeroconf as it is not 100% predictable. I am assuming that your network consists of a router and some devices (at least Mac and RPi). The router is a wifi router where your Mac is connected via wifi and the RPi is connected via ethernet cable. With this network you somehow need to make sure that the IP address of your RPi is always the same. After that, you can somehow map the IP to a domain name. At first the IP address: You most probably have a DHCP server in your wifi router (this is a standard functionality of home wifi routers). The DHCP server is assigning dynamic IP addresses to the devices in your network. But only to the devices asking for one. To allow all the devices in your network to talk to each other, they all are in the same subnet. The subnet is most probably 192.168.0.0/24 or 192.168.1.0/24. This means, all addresses in your network are starting with 192.168.0. or 192.168.1. and only the part after the last point is changing. (Note: This is a different subnet than avahi and zeroconf are using. Every device can be in different subnets). To know the subnet, look at the first three parts of the IP address of your router, your Mac and/or your RPi. To know where to reach your RPi from your Mac, you can do (for example) one of these four things: 

I experienced a lot of crashes and reboots with XBMC (with XBian and RaspBMC) though it got much more stable in the last year. But especially some XBMC plugins are really unstable. I would try running the RPi with a standard Raspbian installation. Try to boot into LXDE desktop and maybe play some videos with the omxplayer. If it does not crash, try a fresh RaspBMC installation. If this does not crash, try to add your desired plugins. Reboot after installing every plugin and wait if the RPi crashes. If it is still rebooting with a standard Raspbian installation on a SD card from this list, no USB devices attached and a real 2.0 A power supply connected, I would think, the Raspberry Pi is broken somehow. Try to troubleshoot power problems like Milliways mentioned in the comments. 

So I tried to optimize the startup time by changing the directive to but then the application never gets started. After logging in via ssh I got this: 

Tell your network's router to assign a domain name to your RPi (it will identify the RPi with its MAC address, assign a dynamic IP address via DHCP and resolve the domain name to this address). Not all routers have that functionality. 

I think this is true, if the branch prediction was correct, because the introduction of chapter 16 talks about best case information. If the branch prediction was not right, the first nop in the loop could take a bit longer (maybe 1-2 more cycles?). In this case, the delay would be somewhere in the lower two digits nanoseconds longer than intended. But maybe I am wrong and branch prediction is not relevant for noops. It also looks like, you don't need to care about the Intelligent Energy Management feature of the CPU, because the BCM2835 SoC does not support it with an Intelligent Energy Controller. Like mentioned in chapter 9 and 10.4, this would change your processor frequency dynamically. Update: It might also be interesting to use the timers of the BCM2835 SoC for timing stuff, but this is only interesting if you are doing asynchronous things because it does not seems like you could switch to some power saving mode, when waiting for the timer to go off. The timers are documented in chapter 14 of the BCM2835 ARM Peripherals Datasheet. 

($URL$ I think this was the reason that setting was preventing SystemD from starting my script because it generated a circular dependency conflict. As goldilocks correctly stated in his/her answer, the is about whether or not to run the unit, not when to run it. So I used because it sounds logical. I am still a little bit puzzled about how to use the , and directives. Edit: not anymore after reading the [Unit] Section Options completely. 

I had a look at the files in the debian packages on archive.raspbian.org. It seems like this is a dependency problem. The package depends on which depends on which depends on >= 2.15. But the available version of libc6 is 2.13. I think, you should file a bug with Raspbian. 

you can omit the lines. Those are pointing to your SSH key. But if you use it and add the content of your Macs file to your RPi's file, you can ssh to you RPi without entering a username or password, just: 

So if your pin 36 (GPIO16) is connected to a button that pulls it to GND and your script is executable, than this should work: 

Run only once when button is pressed. With checking in the infinit loop you are polling the pin as fast as possible. So if the pin gets LOW, you are re-starting really often until the pin gets HIGH. You could remember the last read state in a variable and execute only if it was changed. But I would suggest to use the edge detection feature of the GPIO module. There are different options to do this. In the example below, an event is registered to detect a falling edge and execute a function if this happens. Let your Python script find . As mentioned in the other aswer by joan, with the Python script executes a file in the current working directory. Depending on how you start the Python script, this is not the directory where your Python script resides. So the best would be to give an absolute path to like 

Power needs: The Raspberry Pi runs at 5 Volts and a current of 1 Ampere. The voltage is fixed. For the current: You can run the RPi at lower currents (especially the model A), but to make sure it runs stable, provide at least 1 Ampere. This is true, if you don't connect anything to the USB ports of the RPi. Every device you directly connect to the USB port will draw additional Power calculations: If you connect more than one RPi to one power supply (like a USB hub with only one power adapter), the voltage does not split up, so it would provide 5 V for every RPi. But the current would split up. You can simply sum all current needs of all the devices, you connect to one power supply. If you connect three RPis to a power supply, it needs to provide 3 Amperes. Every additional device, you connect to the RPis USB port will also sum up. The 7-Port hub you linked, comes with a power adapter providing 15 Watts. Watts are calculated Amperes * Volts. The power adapter outputs 5 Volts, so you can calculate the available current by dividing the Power (Watts) by Volts. If you divide 15 Watts by 5 Volts, you get 3 Amperes (15 W / 5 V = 3 A). The linked hub would be sufficient to power tree RPis at maximum if you don't connect anything else to the RPi's USB ports. Current Limit per Port: The next thing to look for, when buying an USB hub, is how it limits the current on each port. The linked hub can provide 3 Amperes, so it seems like it is no problem to power three RPis connected to three of it's ports. But some hubs are limiting current on each port sometimes even to 0.5 Amperes. For the linked hub, this seems not to be the case. The part about iPads means, the iPad will limit the current, not the hub. If the hub is not intelligent and says "I have a lot of current for you", the iPad will draw only 0.5 Amperes (500 mA). Power for 6 Raspberry Pis: To power 6 Raspberry Pis, you would need a power supply that is capable to provide at least 6 Amperes. That is a lot of current. But for example, this USB charger claims to be able to deliver 8 A but it only has five ports. But as it claims to limit each port to 2.4 A, it would be possible to connect two RPis to one port. This would be possible for example with a passive USB hub. Note on additional USB devices: Again: If you want to connect additional devices like USB drives, keyboards etc to the USB ports of your RPis, you need their current needs to the whole sum. But as the USB ports of the A and B model are not protected that good, I would recommend to connect devices only via active USB hubs to the RPi, especially if you want to connect USB hard-drives. If you want to connect USB flash drives, they won't add much current needs. Maybe 100 mA maximum. But some of them are drawing dangerous spikes of current for a really short time if you plug them in. I had some flash drives crashing my RPi model B every time I plug them in. With an active (powered) USB hub, that does not happen. Or plug the flash drive in before powering up the pi and never unplug it again. The Model B+ claims to have better protected USB ports and should be able to provide at least 1 Ampere to connected devices (if the RPi is provided with at least 2 Amperes). This should be enough to power a modern 2.5 inch form factor hard-drive. I did not look at the schematics of model B+, nor tried that, so I cannot verify that information.