As Illya has mentioned Regex alone cannot solve this problem. Instead, we must employ some type of stack-like data structure to give our program memory of past characters. The first three lines of the main function are just a cheap way to replace blockers with a single character. A better solution would be to tokenize so that this isn't necessary. 

For more information check out this nice write up on Scala collections that is co-written by the creator of Scala, Martin Odersky. 

Style Comments Methods which take functions as parameters ( and in this case) should be invoked using infix notation. That is, if there were a god of Idiomatic Scala Style he would prefer to Defined functions should use camel case, e.g. over . In general, and you will get a feel for this the more you use Scala, pattern matching is preferred over if-statements. You will notice that in your function I've swapped your if-else statement for a pattern match on the value . The last style tip I have for you is to break a chain of higher order functions over several lines. This last one can be fudged in some cases, but in general I find that it improves readability. Efficiency Comment The one change that I made in the name of efficiency was to change the container type of from to . The reason I made this change is that accessing an item in a takes linear time on the length of the list, whereas accessing an item in a is almost constant. And as you know, you are accessing elements of by index is in the last line of . 

There is one catch to this idea. The and are mutable (which I believe immutability is strongly suggested by Spring). It's possible that the and/or fields are supplied by the client/UI, or they might not be (orgId will always be supplied from the UI form). If they are not supplied, we query our database for them. If they do not exist in our database, then we throw an error. They almost always will NOT be supplied. To do that, I change the to override the methods and look up the or if they are not provided 

Drop the and inheritance of command objects and instead create an that creates a POGO and stores it in the scope. Then in the controller, I pass both the object and the to the layer. Just pass the 3 fields through the scope and don't worry about creating the or an . Instead, every method in the would have an additional 3 arguments for these fields. 

It would be nice to have a code review to show me where I can improve on readability (along with other things you may find!). I've been trying to clean it up and refactor a bit, but a fresh set of eyes would be nice. I went a bit crazy on comments because I wanted to make sure I would be able to look at this in a few months and not forget why I did something the way I did. But perhaps putting some of that info in a github wiki would have been better. 

CASE CLASS I would change to a . One reason for this change is more concise object declaration, e.g: 

I would say that your latest code looks fairly sharp. However, after translating your code to something I could test, I noticed a pattern that could be captured with the code below: 

Below are some of the changes I would make to your code. In my opinion one of the nice aspects of Scala is that it gives you all sorts of ways to reduce the amount of work your mind has to do in order to decipher code. As an example, one of the first things I did was declare a type that is equivalent to . I then just substitued where necessary and the code (to my mind) became more readable. The choice of was arbitrary on my part, you could if you wanted use instead. Along these lines I shortened all of you variable and value names. As the program is set up right now you don't need to pass in a array, but I left it in anyway. As you mentioned this is a homework assignment so I'll leave a bit of mystery as to why this is. And really you don't need the and the . Next note that is equivalent to . And finally (for now) checkout how I initialized and . If you still would like to use your function you should look into the method called . Cheers. 

I'm integrating with a 3rd party vendor that has and in it. My tool is a user administration tool that allows us to store information in our local database about the and that we manage in the 3rd party vendor. So the and are stored in the 3rd party vendor as well as our database (we act as the middle man sort of). I'm at a crossroads with some ideas and would like to hear what others thought of the following problem and my solution. Before I dive in, we're using Grails 2.4.4 One use case for the tool is creating a . We create the user in the 3rd party vendor via an API call, and then we store information about that user in our database. There are many uses cases like this and there are 3 fields that are always in common between them, an a and an . These 3 fields are required for just about every API call we make to our 3rd party vendor and most of the result in an API call being made. For this reason, I had the idea to make a "Common" with these 3 fields on it that can be extended by another Command Object. 

My Question: Do you think this is an appropriate design? I believe the biggest drawback to this is that the is mutable. Brainstorming a few other ways: 

Overall I'd say your off to a great start. Here are some of the changes I would consider making to your code: Formating Output When printing strings that encapsulate values/variables you have two (idiomatic) choices in Scala. Option one is to use string interpolation: 

I've introduced a smidgen of strange syntax just to show you a possibility. As a way of explaining what is going on, consider that the following are functionally equivalent: 

Pattern Matching Within the helper function each layer of the recursion checks the value of against some constant value using an if statement. The more idiomatic way to do this in Scala is to use pattern matching. For example: 

that you are immediately throwing away because you aren't assigning it to a variable. In other words you should only use a list comprehension for building a list, not for calling a method that is doing work elsewhere. An alternative implementation is as you might expect a nested for loop: 

I was able to reduce the run time of your code to a few seconds (2 seconds on my computer) by changing the type of from a to an immutable . You were correct that was the major bottleneck in your code. This is a bottleneck because checking that an item exists in a means inspecting every item in the until we find it or reach the end of the . Fortunately we can use a (which under the hood is supported by the class) and reduce the search time for objects from linear to effectively constant. Notice that in the code below I simply applied the method to your function converting the returned to a .