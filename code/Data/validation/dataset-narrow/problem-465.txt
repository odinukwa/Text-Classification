A more potent approach is to return not the length at which to split, but the results of the split. In fact, makes this work out of the box: 

For separation of monadic and pure code (and generally for factoring out common code from across cases), here's a to replace : 

captures your usage of into a simple interface, except you need a way to retrieve the , so let's tweak it. 

Note that is the version of r that does not have its set to yet. This could have been averted if merely contained the room's name. The recommendation to use abstractions theoretically also goes for , but what's needed here isn't available in the common libraries. Using my package prototype pointed-alternative and missing StateT combinator getsT: 

Getting the state at the start of your block, setting it at the end and recursing once makes pretty superfluous, by the way. 

makes the record syntax pain go away. unmakes , and eliminates the worry about missing parents. That said, we never actually profit from initializing nodes with themselves as parents. abstracts away the passery. pushes the worry about malformed input off into infinity. should provide , but I think my name is stupid and my implementation might be stricter than needed in the general case, so I don't want to submit that PR. I'll cease caching in to make a one-liner. 

This can probably be reduced further because either of us introduced some unneeded numerical operation somewhere. 

This is the backpack problem and NP-hard. We won't be scaling well in the worst-case whatever we do, but we can do a little better by, for example, only keeping track of suffixes of vendor selections that can't be undercut in time and price at the same time: 

Here's a little to start with: implements . implements as , and as . These don't error on being out of range, instead doing nothing. is a bad name because list is also a verb and set is also a noun. is . should be called or , because you aren't generating the neutral element or inverses, and are using either commutativity or associativity to only append the original generators to any new elements, and only to the right. 

It'll lazily take no more memory than it takes time to find the first result if you do not try to enumerate all possible results. For / to only try one option, you want 's / behavior, not 's. You could parametrize your Parser type in the used so the user can change it on the fly. yoctoparsec uses this "push" style. 

(Edit: Actually that one throws out the first of each two equal elements, not the last. Here`s one without that problem: 

Since the from only ever contains , its result should instead be . And then nobody ever sees a object, so we don't need it. 

gives a bunch of valid advice. collapses 9 lines into one thrice. and encapsulate the use cases of the functions. can replace three names simply by turning the differing functions into arguments. Since I didn't want to write a type signature there, now wants . smells, use . So does , use list comprehensions and pattern matching. ...... why not ? :( Also, use pattern matching instead of fst and snd. Let's also inline some stuff that's only used once. is unused. 

As you can see, foldr also has its argument order wrong. Now your code is , except that you had the argument order wrong at the end there. :) This implementation of is almost identical to your code, but the average reader will have heard of and the average stackoverflow voter evidently finds its code confusing out of context. 

Your use of for memoization can be extracted into . If one can stop instead of having negative balloons decrease score, can be condensed into one case. 

Lists are not for random access. As far as I know, Vectors are the modern way to have fixed-length random-access listlikes. They will allow you to do the traversing updates you want in one pass. 

By the way, the closest we've got to a typeclass law for is that it produces strings that you can paste into Haskell code to recover the shown value. Pretty-printing or format conversion functions are usually called something else. 

In real code, I would consider this to be too much naming for this little code. Most of this would probably be used only once and could thus be inlined. Since the exercise required implementations for all these, it's okay. is . is . Did you try compiling this? means that shouldn't work, and elemIndex takes the Char before the String. 

Library combinators and list comprehension syntax allow much collapsing of your code, and many of your type aliases and oneliners do not deserve a name, except perhaps for those at the bottom because you export them. 

(I think doesn't deserve a name.) In case the order in which the output is given isn't important, here's a version that doesn't require quadratic time because each element is compared to every other: 

There's also and , but if you simplified your question and above doesn't unsimplify, post the whole code and there might be an unreasonably short answer again. I also have the feeling wherever you use could be simplified further since only really returns a boolean. 

Your implementation is wrong. Some factors may be larger than the square root of , say in . More might follow. Edit: This is not good. Where are my heuristics leading me? Send help ._. 

Show is usually used to generate Haskell code that can recover the shown value. I wouldn't name stuff that's only used once and doesn't deserve to be a library function. 

Walking across the list of positions from the right cuts off suffixes, requiring you to keep traversing and copying the corresponding prefixes over. If you cut off prefixes instead, you only need to traverse once. 

If you write uniq as a right fold, you don't need to pass an accumulator through, and the list comes out in the right order: 

Shouldn't the current world automatically be satisfiable if the created one is? Or is this one of the things nonstandard s might change? and look like they ought to be removed and inlined respectively, but I'm not sure how to keep lines where you use from duplicating. 

By changing the internal definition of Boiler you can clean up that flip. By also changing the user interface you can use the Read instance deriver: 

By defining r = round . sqrt . fromIntegral, newBoard fits on the screen. positions doesn't appear to be used in newboard's first case. Half the code disappears if we interpret Cell as ((Int, Int), Int). newBoard's first case can be pushed one recursion call deeper, mapping [] to [] instead of [x] to the current right hand side. [_] ++ _ ~> _ : _. positions is only used once, therefore I inline it. 

is subsumed in , the chain length is monotonous with the set size, and do notation feels like it might help with include. 

If something can't happen, put your money on it and make it crash if it does anyway instead of silently carrying on. deserves its own name to lift our burden of manual tuple juggling. Adding elements to the end of a list smells. Let me reverse the list order to fix that. The with the booleans looks degenerated, there must be a better way - let me undo its introduction. The booleans can be replaced with conditional recursion. The set need not be returned in the cases that used to return True. The list entries that are to be later returned need not be passed deeper into the recursion - and then the list need not be passed down at all. Incidentally, this restores the original list order. Let's look what I got so far: 

The last two lines of collapse to . may be to your liking. can handle 's state-passery, but you'll have to redefine as to allow 's actions. 

And then, if you don't mind making it more defined, make this and the above similar snippet use the same first argument to foldr. 

Since you only use call the nonpartial case of and only use it once, you can inline it. Pattern matching is better than ///. 's can be used again. 

I left the and tags themselves out of what is printed, that's easier to code up so might be the correct way. Edit: More existing combinators :D 

I now notice that list comprehensions don't actually use the instance of lists within let expressions. Ah well, since the instance for happens to make smaller than anything, I can get rid of the list comprehension again, and restore maximumOn! 

You pretty much want , except that one has all of the argument orders and pair orders backwards, or the monad, except that one passes its state to the right. We can define our own : 

I refactored for a while, largely replacing recursion with combinators. I think all these type aliases are unnecessary, I probably would have removed them if I had finished this. You didnt actually use the LHS in , except to pass it into recursive calls, so I took it out. 

The third case subsumes the second. All possible result lists are prefixes of the same infinite list - let's define that instead. captures this pattern. A combination of and captures . 

Here's your simpler way of modelling the problem: Each eliminates the other program's next until neither sends. 

and both call their argument , leading to mixups. maps the integers to , not . You are looking for . 

This code kinda looks like the error cases do happen regularly. Were your comments under the assumption that we are currently looking at the that is going to win the contest? Let me use list comprehension syntax to skip through erroring s without hacking our way through the data we happen to be working with too much. (Sadly this requires pulling back of parts of maximumOn.) Also the perfect numbers case seems to be subsumed by the other. Also the last element of the list is x if we're interested in it. Also the two positions of x are always in the front and back so we can just compare lengths, and we need not even pass the list out of include. 

Have you tried compiling with the flag, as in ? Other than that, perhaps refactoring the code to use tried and true library functions might help: 

's name makes look like a crutch, and that is good, because it is one. I would inline definitions that are only used once and do not deserve to be in a library: 

You don't seem to be using 's monad instance. 's purpose is for you to not need to pass gamestates around manually! Doing everywhere misses the point. can help with nested data structures. An example: 

If is put in a where clause of , it isn't globally accessible and you can call it or something because the scoping already points out it belongs to . Swapping s argument order lets you say . is a smell. Instead of passing down an umulator and growing it to the right, you can pass it out as the return value and grow it to the left. 

We're passing around a lot of setters and getters and indices, if only there was a library that specialized in that... Enter . 

) You've commendably already brought into a form that allows it to be written in terms of library combinators: