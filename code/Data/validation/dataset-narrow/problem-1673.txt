Thanks for all the help. I ended up picking up the Make Mag book on the RaspPi and followed the walk-thru on the configuration of the WiFi. Have no idea what I was doing but it seemed to get it working without any hassle and I did it in under 15minutes. I'm thinking it was a problem in the interfaces file that I had done changes to to make it a static IP. I had read a couple conflicting articles and I think I picked the wrong one...Ooops. Anyway, works great now and I've been playing with the Gert board so life is good. 

Have you confirmed communication is working between the RPi and the MCP3208 in this configuration? If it IS working then skip the next paragraph and start checking for functionality. Both the LM35 and the MCP3208 can run on 3V3. (Always look at the datasheets to confirm.) So first thing is loose the voltage divider you made as I suspect that is probably messing up your communication between the RPi and the MCP3208. You should be checking the functionality of the system starting at the LM35. Get a volt meter and confirm the LM35 is giving you a voltage level on the DATA pin. If the DATA pin has a voltage then you have an issue further up the line. If you have other sensors attached and they ARE working then simply swap out the data line from another sensor for the LM35 and confirm you are still seeing a value on Ch7. If you are seeing a value then try a pull down resistor of around 18K Ohm or more. If you don't see a voltage value then you have an issue with either the port or the code you are using to read that port. I'd first see if changing the port[Channel] in your code fixes the problem. If it does then you know that the port is suspect and you should avoid using it. If it doesn't work then time for you to debug the code. LM35-datasheet MCP3208-datasheet 

Trying to connect my new Raspi to the internet for the first time via a cross-over to a bridged connection with my laptop's wi-fi. The Raspi browser works for internal network webservers but won't receive anything from the WAN using either URL or ip address. Get a name resolution failure and a fail to load page. I'm thinking it must be router related as it only fails if going through the gateway router. Any ideas what the issue might be and how to resolve it? 

Good day, I am currently working on an obstacle avoiding UAV using stereo vision to obtain depth maps. I noticed that the quadcopter would sometimes not steer to the correct direction. I am using the Raspberry Pi Compute Module IO board which comes with two CSI ports used with two v1 Pi Cameras. Issue I soon found out that due to the latency between the cameras, the left and the right images are not in sync thus the errors in the depth map result. Steps taken: I noticed the image blur when moving the cameras around so I adjusted the shutter speed by setting the UV4l/raspicam driver. With the shutter speed, I also tried to increase the framerate as I've read, it improves the latency issue. In my code which uses the opencv library, I used the grab() and retrieve() commands to replace the read() command so that the frames from both cameras is grabbed at the nearest time possible however it didn't help much. Does anyone know any possible solutions? 

hdmi_force_unplug=1 Add or uncomment this line to force the raspberry pi to output at the HDMI port and not on the composite video output (3.5mm jack on the new pi/yellow jack on the old pi). hdmi_safe=1 Add or uncomment this line to force the pi to output at low resolution which is supported by most displays in the market. config_hdmi_boost=4 You can boost the hdmi signal by adding or uncommenting this line by changing the value from 0-7 (o-default 7-maximum). 

Good day I am trying to sample distance using a sonar/ultrasonic sensor for altitude measurement. When the PWM is not active, the sensor gives accurate measurements in centimeters, however with the PWM active, the sensors outputs unrealistic measurements. I have seen other having issues with the arduino platform and have resolved this issue by decoupling the supply of the sensor with an electrolytic capacitor. However this does not resolve the issue and upon closer inspection, with the PWM active, the measured pulse/echo is wrong. Is this an issue with the sonar and PWM fighting over the raspi's timer? 

It turns out, in the dt-blob.dts file that I have previously modified to accomodate two pi cameras that the UART was disabled :) 

Good day I am currently setting up UART communications for two Raspi's using wiring Pi's uart library. I have three Raspberry Pi's (B+, Compute Module IO board, B2). I have been able to make communication between B+ and B2 but so far have been unsuccessful with the CMIO/Compute Module IO board. Is there a special way to set up UART for the CMIO board? The uart communication was intended between the B+ and the CMIO, the B2 is just used for debugging. What I have tried are the following: 

If you're on the console (attached keyboard and screen) you should be able to use the Linux virtual console system to switch between multiple terminals using (ctrl-)alt-F1 through F12 and more with shift. The number of terminals configured and the number of them having getty processes (that ask you for login and password) depends on configuration. 

If you can program, you can pick up python amazingly quick and get useful stuff done almost right away. There is an impressive library of stuff available as well. But it shouldn't be absolutely required for any pi related work. You can attach many sorts of IR receivers to a PI, from demodulating detectors (like used with TV remotes) on GPIO to somewhat specialized USB dongles and irda modules. What you use depends on what you're trying to receive. There are also less communication-oriented IR uses in e.g. PIR sensors, light beams, and raw "morse code" style flashers that are all accessible as well. Which ever task you want to do, you should try to find a receiver that looks like a standard device of some sort to avoid having to hunt for drivers. A USB serial port type might be handy for the pi. There's a logic level UART on board (might not be avilable/easy for this) and you can get bot LL and EIA232 voltaged serial dongles for USB for more ports. These do your classic cellphone-laptop-printer style communications, not TV remote style. For on-off signals, GPIO might be the way to go. It's harder to do fast signals with the roundabout way these are accessed in common operating systems. Accessing GPIO without breaking system security is another challenge. How you get to these from Node, or js, is another matter. There may be a library/binding for accessing some devices. Others you can access through device files or by running some kind of middleman program (this might be a natural spot for Python) that will handle the device and that you can talk to from js. If it all seems unfamiliar, think of this as some pointers and keywords to a lot of interesting reading :) 

That would have been a delightfully short answer, but "body must be at least 30 characters; you entered 1". :) The X server is really usually called and you can just start it. You can set the DISPLAY number as an argument along with some other things. You might want to have some sort of session, though, and still go through xinit or such and start X with startx. You can use or such as a script and simply not start a wm there. You will need a "magic client" as the last command that stays running so X doesn't terminate immediately. In a traditional "failsafe" session, that was an xterm. If you know what to launch and launch once only, it could be that mplayer. Or any UI/wrapper that does the launching for you. When the last ("magic") client in the init script terminates, X terminates. If all you want to do is play video, you might see if rpi can run mplayer with directfb instead and skip using X11 entirely. 

I am currently using the default range of 0-255 and a frequency of 400Hz. int gpioSetPWMrange(unsigned user_gpio, unsigned range); from: $URL$ 

I have been trying to debug this problem for 3 days now. I tried using the wiring-pi library and the pigpio library but both have the same problem. This is an example code with the same issue: 

Good day, May I ask if it is true that if I activate turbo on the raspi-config, the pi doesn't always run at the maximum speed at 1Ghz. 

Is it safe to set force turbo = 1 at the config.txt to force the cpu to run at Maximum frequency as long as the temperature does not exceed 85 degrees celsius? However this voids the warranty Also will the command temp_limit = 85, override the force turbo = 1 setting? May I also ask of using this command instead of force turbo by changing the default scaling governor in the /etc/conf.d/cpupower file can achieve a similar effect so as not to void warranty. START_OPTS="--governor ondemand" STOP_OPTS="--governor performance" I have read that using a raspberry pi B+ due to the more stable power supply, I do not have to worry about corrupt SD cards. Is this true? Thank you :) 

I remember editing the dtblob for the CMIO to reroute the I2C, is there a required way similar for UART set-up? I have been so stuck with this problem. Your help would be very appreciated. PS, I cannot use the ethernet port as the CMIO does not have one :) 

Good day, I am currently working on a quadcopter project and am currently using the pigpio library for the PWM used to command the ESC's of the quadcopter motors. 

The vcgencmd command is the more accurate one as the vcgencmd command takes the reading from the firmware and the cpuinfo_cur_freq takes the reading from the kernel. The problem with using cpuinfo_cur_freq is that when the cpu throttles due to too low load, undervoltage, or high temperature, it does not get reported back to the kernel. Source here and here I hope this helps :) 

There are many converters out there in the market that offer means to convert an HDMI signal to VGA however some of those are said to not work with the Pi. I had the same issue with both Pi and Odroid boards and tried three different HDMI adaptors and got only two of those to work. Here is a list of some HDMI to VGA converters that are tested to work with the Pi: $URL$ For tweaks on the software side you may try editing the config.txt of the Pi located at /boot/config.txt