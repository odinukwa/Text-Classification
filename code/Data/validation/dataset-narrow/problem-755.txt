You should also look up the requirements for containers: $URL$ You are missing a couple of type definitions. Like . Worth a read: I wrote a series on how to implement a vector: 

Also you may want to put all your code inside a namespace. In this scheme were you access the year and count you have to perform two array lookups. Not a big deal. But to me the logic seems the wrong way around. 

Overall Design The input and output use the same buffer but are not linked together. If you have not written anything into the buffer I would not expect you to be able to read from the buffer (as there is nothing to read). When you do write I would only expect you to be able to read only what has written (no more). 

If something satisfies the alignments for a larger alignment. Then it automatically satisfies alignment requirements for smaller values. Thus if memory is aligned for an object of size . Then it is also correctly aligned for objects that are smaller than 'N'. 18.6.1.1 Single-object forms [new.delete.single] 

With an enum there is no space taken up (though potentially the above may be optimized out). C++11 also allows you to specify the size of an enum: 

Copying Because you are not managing the memory you don't technically need to follow the rule of three or five. But this also results in unexpected behavior. 

You are tightly coupling your code to where it is being used. This may or may not be a problem but it seems to be excessive here. Leave all your members private and don't expose them via getters. Provide methods that modify your objects state without exposing it. Here again you are passing by value: 

This tightly couples the print method to a particular output method. It would be better to allow the user of your object to define what the output method is: 

Check Invariants and return quickly. If you check you invarants quickly at the top of the function and return. Then you don't need to indent the rest of the code. It is obvious that the remaining code is only being used if the invariants hold. 

This line is likely to fail. Using your method you need to validate that the pointer is not NULL wither at the point of setting or at the point were it is used. 

Design. If I was actually going to write this I would encapsulate the concept of a word in a class. Then you can localize the change in a single well named class. You can then make use of standard routines to help read/print. 

The above two lines contain identifiers that are reserved by the implementation (this means you are not allowed to use them). You can not have double underscore anywhere in your identifier. Also avoid using a leading underscore (the rules are complex). Also macros (things defined with are traditionally all upper case. This will avoid clashes with identifiers that have more restricted scope rules. Personally I use my namespace and file name as part of the macro guards. Since I own the "ThorsAnvil.com" domain I use this as my top level namespace to make it unique. 

That's not the copy and swap idiom (seems to be the inverse). May throw a few people. If you are not going to use standard idioms them you should have a go at explaining why. Not sure this is helpeful: 

There is already a why re--invent it. Exceptions should probably inherit from if you are going to write them (that way you can use there version of and storage). Talking of it should definitely by marked cost. And under no circumstances should it throw. So the actual declaration you want is: 

Prefer Reference over Pointer Since the producer and consumer must have a buffer you should pass it by reference (rather than pointer). This also makes sure there is no confusion over ownership of the buffer (the owner of a pointer is responsible for deleting it). By using a RAW pointer you can not tell the owner but by using a reference you are explicitly stating that you are not passing ownership. 

Comments Comments have to provide real information. Otherwise they are useless. Maintaining comments is as hard as maintiang the code. So unless they provide real information you should not write any. Bad comments are worse then no comments. This comment does not provide me any more information than the function name already does. If you provded an WHY or HIGH LEVEL how that may be useful. 

Absolute fail. The indention suggests that we return when (diff > 0) but the code is not going to do that, as only the first statement after the belongs to the if block. Always prefer to use statement blocks after control structures. Even if they are one liners (some people still use multi-line macro's that will break your code if you don't place it in '{' '}' 

This indicates to the reader and the container that you are passing ownership to the container and it is responsible for deleting the pointer. Note: you will now have to make sure that the destructor correctly destroys the pointers. Also note that because you define the destructor to do some real work you also need to make sure you obey the rule of three (as the default copy constructor and assignment operator will not work correctly). All this has been encapsulated in the boost ptr container(s). Take a look at: 

I see a normal iterator and thus normal access. You usually also want a const iterator with const accesses to the data. I see that you give const version of but not . 

Since you are not modifying make it a const reference. Note: You should return by value. The optimizer will remove the need to copy out of the function so you don't need to worry about a copy here. Declare variables as close to the point of usage as possible. Here is declared but not used until the next section of code. So When I start seeing being used I need to scan up the function a long way to find it. 

Which brings me to your formatting. Your code is really hard to read. Use the same rules for parameters that you would for normal variables. There is no extra points for minimizing vertical size. Your fourth constructor is good. But to be complete you may want to add a fifth to handle the nullptr (as it is not a pointer type, just convertable to a pointer type). But