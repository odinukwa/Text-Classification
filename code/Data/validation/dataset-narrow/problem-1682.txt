Think of a MOSFET as a remote control switch, one that isn't so remote, but is certainly a switch. Your device with the high current requirements will have its own power source with appropriate leads to activate it. Plan to interrupt the power lead with one pair of contacts on the MOSFET called the load. The other pair of contacts on the MOSFET may be called trigger or similar. You would run from the ground of the Pi to the ground of the trigger with one lead, and from one of your GPIO pins to the other contact of the trigger. When you have the Pi send a signal to that pin, it causes the MOSFET to close the switch on the load side. 

There are more than a few approaches to reading resistance. Because you know the specific values, it puts you a bit ahead of the game. Take a look at O'Reilly Raspberry Pi cookbook chapter 8 The site is using a variable resistor, aka potentiometer. The primary difference for your purpose is that the values will jump from one to another, rather than being "smoothly" advanced. You'll note in the body of the document that this particular circuit is constructed in such a way as to provide stepped readings from the pot. I suspect that will not matter in your case, as you have stepped inputs from your circuit. 

There is what appears to be an identical method presented by Adafruit in multiple pages. The foundation behind this method is to read the values without the need for additional external devices such as an analog to digital converter. 

If ever I locate my previously purchased eTape sensor, I'll be putting it service in a chlorine tank, which is a quite corrosive environment. The eTape sensor is teflon coated and rated for such use, so I suspect that insecticide would be an easy job for it. Five to thirty two inch lengths (130 to 800 mm) puts the device close to your needs, with escalating prices to match, of course. The circuit in which this device is to be used need only read as a voltage divider or a resistance option for US$30 more. In my correspondence with the manufacturer, I was cautioned to seal carefully the connections at the strip end, as they would not fare well when exposed to chlorine. Additionally, ordinary RTV silicone releases acetic acid when curing and would cause damage, but non-acetic acid type silicone would be acceptable. With a 32 inch maximum length, you'd only know when you are nearing the last 16 inches. Reference is made in the page for custom lengths. 

The default python library already supports DMA PWM on all pins. See $URL$ for documentation. edit RPi.GPIO doesn't use DMA. I just checked the source code. 

I've hooked up an LDR to a pi's GPIO and ground pin directly. I set up the internal pull-up resistor on the broadcom chip. This created essentially a voltage divider, that would make the pin would read low if a led shined on it, and high is not. Since you only need a yes/no answer there is no need to measure the time to charge a cap, just like analog-to-digital converters do. You just need the voltage to be either above or below the tripping point of the GPIO for either state of the led. The tripping point for the gpio seems to be around 1.2v ($URL$ So under normal lighting condition the voltage should be above 1.2v. When the led is shining on the LDR, the voltage should be above 1.2v. Just note that in my setup I've taped the LDR to the led with black tape, so the LDR is in complete darkness. You probably have to have some external pull-up resister that better matches the resistance of the LDR. Some variable resistor (pot) would be a cheap and handy way to calibrate. My sample test script for reading the gpio pin. 

Your current situation could indeed create a short between two row pins. (the keyboard might have some resistors inside, but I think that is unlikely). A software only solution might be to set the GPIO pins back to inputs, when you don't use them, instead of setting them to 3.3 volt. The diode solution will also work. The GPIO pins need at least around 2.6V to register a HIGH. So 0.6V is no problem. Resistors will also work. Note that you calculate the voltage incorrectly on the voltage divider. Since the internal pull-up is something like 10kOhm, the resulting voltage will be more like 0.2V. Downside to the resistor solution is that if you press multiple button in the same column, none will register. 

Below to be shortened or deleted # Appendices # # A1. Opto isolated / Photo coupler relay module board and schematic # Opto isolated relay module has a photo coupler which is 4 pin IC. The picture below shows a photoCoupler PC1 (with its 4 pins labelled 1, 2, 3, 4 in green) and a transistor Q1. The ICs are not always marked. In this picture, PC1 is EL354, and Q1 8050. 

Rpi has only one serial UART channel. So for 8 channels, you need to use software to config GPIO pins as UART. However, software UART on rpi/linux is not that reliable, even at low speed (9600baud). Or you can use 8 SC16IS750 modules for hobbyists (less than US$10 from eBay). SC16IS750 is a slave I2C-bus/SPI interface to a single-channel UART. 

Appendix C - Logical level converter using TXS0102 Now I know that Rpi GPIO can directly drive the relay module, but there are two problems. First, the GPIO signal with a long connecting wire is noisy, therefore not that reliable. Second, the flywheel diode 1N4148 might not completely suppress the coil back EMF, and if unluckily the 1N4148 breaks down, or not properly connected (poor contact, dry soldering joint etc), the back EMF might damage the Rpi. So I decided to use a logical level converter to shift up the Rpi GPIO signal from 3V3 to 5V. I first tried TXS102 converter and found it working well. Besides shifting up the GPIO siganl, the noise at the high level is also greatly reduced. 

Actually logic level shifting might not be the easist solution for you. You may consider throw away your BJT transistor input module and get photocoupler based module. Then you can keep you gpio pin signal at 3V3 logic level, and the 5V0 power at JD Vcc is strong enough to energize the coil. There are many advantages of using photocoupler. You might like to google to know more. 

Just connect the Arduino a mostfet or power-transitor, to the 9V battery. Have the Pi control whether or not the arduino gets 9V by connecting a GPIO pin to the Gate/Base of the mostfet/transitor. You could put the arduino into sleepmode, but that's kind of pointless, as the voltage regulation, leds, and other stuff on the UNO board use as much power as the ATMega328 itself. PS also add a pull down resistor to the gate, so it isn't floating while the pi is booting up, shut-down or powered down. That way the arduino will always be off in those cases. 

You shouldn't power the led strip from the Pi's 5V line. Only connect the GND, CI and DI lines to the Pi. Connect the 5V and GND of the led strip to the separate power adapter. Note that the ground is "interconnected" here. If the adapter isn't strong enough for the entire length, you can indeed split the led strip into sections. Just like above, connect DO to DI, CO to CI and GND to GND. Next connect the new adapter to the 5V and GND of the new section. 

Unmount the drive. Create a folder inside . Make this folder readonly. Next mount the diver and again create the folder . Edit your script to have it write the the folder . If the drive isn't mounted the script can't write to the folder. However, if it is mounted, it can. It might even work without creating the subfoldeer, and just making the folder (on the SD) readonly. But I'm not sure in mounting overrides these permissions. You'd have to check yourself. Also make sure you script doesn't fail, if it can't write. 

At $32,- I'd just try, and see if it works. Camera's that are designed for those kinds of conditions will probably cost into the hundreds if not thousands of dollars. You could try putting the board into an enclosure, and force cool outside air though it with some tubing and a fan of sorts. Also be aware of air-humidity. 

However, I very soon found OP's relay module spec a bit unusual. It says drive current at least 4mA Ib, to switch on PNP BJT Ic to drive the 55R coil at 90mA. This implies a DC current gain of 90/4 ~= 20. I found my first PNP to simulate OP's module is not suitable, because the Ic(sat) too big. So I replaced it by 2N5401 (see appendix below for a spec summary), which at Ib = 1mA, Ic = 50mA, hFE already is 50. In other words, this 2N5401 module input current of 1mA, 1/4 of OP's module, is enough to switch on the relay. So I cannot simulate OP's module of 4mA input, 2.4V+ relay switch off condition. Instead, I just tried to bias the PNP BJT to trigger at 1.0V+, which is high enough to entertain RPi's 0.6V- Low. And the trigger/activate deactivate band is around 0.2V-. I repeatedly verify that the trigger signal 0.2V to 1.0V will activate the relay and 1.0V to 2.4V (rpi's high So Rpi's High of 2.4V+ must be able to switch the relay off!. After manually tested the module using a 0~5V power supply unit to simulate Rpi/Arduino GPIO signals and found everything working as expected, the time has come to do the real thing: actually using Rpi GPIO signal instead of the 0~5v PSU, using an working python program. But to my surprise, the program does NOT work! The reason is that I forgot there is something called hysteresis. The relay switch hysteresis characteristic is as below. / to be continued, ... Why the set-GPIO-to-input trick can switch relay off 

DIY your own module using 2N2222 If you are a DIYer or maker, and you want to build everything yourself, then you can use a Songle or How does an Electric Relay work? $URL$ Built Your Own 5V Relay Module [using 2N2222, driven by rpi] - Nick Momrik 2017jul05 $URL$ 

By default the pins are inputs and therefor floating (except the I2C and UART pins). Why not flip the required value? You just enable the internal pull-up on the pin on the Mega, and have it wait till the pin goes low (). Once the Pi is booted, have it set the pin to output, and LOW. No extra resistors needed. 

Some hub backfeed power to the Pi. Either buy a hub that is verified to work, or open the usb cable and snip the 5V line, preventing backfeed. Make sure you have 2 usb cabled between the hub and the Pi as illustrated below. One for power from the hub to the Pi. One for data from the pi to the hub. 

The ws2801 will indeed still use power, even when all leds are set to zero. Relay is the safest as it isolates the power of the led-strip from the pi. You'd need a very beefy transistor to switch 1A of (max-)current. Transistors also have a voltage drop, so the WS2801 will get a lower voltage. Not sure if it likes that. (Sidenote: If the transitor has a voltage drop of 0.6V; then if 1A of current is passing through, the transistor will convert 0.6W of power into heat. Which will make it quite hot without any heatsink) A better alternative to transistors, in this case, would be to use a MOSFET. You could use a optocoupler to switch the GATE of the MOSFET. But it quite safe without. PS did you remember add a (flyback) diode to the relay? 

Couldn't you just print the command to tty1, and then run the command from ssh, and forward the output to tty1. That way the end result would be about the same. Except maybe missing the pi@raspberrypi ~ $ in front on the command, but you could just fake that by also printing that. 

I tried the HC04 output signal for the relay module in Low trigger mode (which requires sinking current, but not in High trigger mode (which requires sourcing current), . So I am going to add the HC04 hex NOT gate which can source current to the relay module. Appendix F - HC04 Level Converter Floating Input Problem Last time when I first tried the HC03 based level converter, on a photocoupler relay module, I found that if I left the input floating, the module picked up the noise and the relay switched on and off crazily. I thought the frequency was perhaps 1kHz. I was not sure if it was some sort of positive feedback oscillation. But when I used the scope to check out, I surprisingly found it was 50Hz! I guess it is some sort of resonance. But I don't know what is the difference between resonance and oscillation. Perhaps I should goggle again. Anyway, I think I need to add a pull up/down resistor somewhere. 

ULN2803 and especially UDN2981 are not so common. They have 8 channels and therefore have a bigger 18 pin DIP package size. For less channels, more common 74HC03/04 or 74HCT125 with 14 pin DIP package are more common and easier to handle.. 

Use functions whenever possible. It is easy to convert functions to objects, but not the other way round. Do not use wiringPi for now. Python can just read and write to MCP with one write and one read I2C command. So wiring Pi is sort of over kill. I know python can use wiringPi. But I am not sure if Python wiring pi is 100% compatible with C++ wiringPi. So I think it is easy to first play with Python, then C++, then wiring Pi. Time for me to go to bed. Sorry for misspellings etc. See you tomorrow. ZZZ.