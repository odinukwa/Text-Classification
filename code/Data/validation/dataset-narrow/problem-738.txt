I'd solve the problem by providing a PL/SQL procedure that knows the "split"-logic. In the example below I assume that non-splitted rows are not inserted into the table at all but all inserts should be done with the procedure. This is a rather common pattern when there's data manipulations but it is not clear from your problem statement if this is an acceptable solution in your case. I used regular expressions as it's a very handy tool for pattern matching with superior expressiveness and clarity compared to spaghetti. I didn't used triggers as it's not possible to modify the table trigger is attached to. The solution can be easily applied even if you need to read the input data (i.e. non-splitted) from the same table. Example 

Use analytic function (you might also consider using or functions instead) to assign an unique number in ordered sequence to each row. This is the standard way to implement top-N, bottom-N and inner-N queries in Oracle. Note that this example doesn't resolve ties. 

As bonus I also introduced you to standard SQL datetime-literal syntax. Let's create some data to play with: 

By the way, thanks for your question - I see the Sundaram's sieve for the first time. Seems very elegant :) The final code: either copypaste the snippets above or use this gist :) But I sincerely hope you at least read through this and not just use the final thing, because of the time I put into writing the explanations... :D 

Now, when I hear "functional paradigm," I hear "loopless way" and "immutability." Functional programming is about more things, of course. EDIT: oh man, I had in the code. Stupid mistake :) Fixed now. 

OK, we have the s, now we have to deal with the sieving. If you look at your code and think about it in terms of transforming one array to another, you realize you either change an element to 0 if it was unlucky and its index was in the , or don't change anything if the index wasn't there. Look how it translates to code: 

And now for the functional ways. (Disclaimer: I don't think my functional rewrite of your code is any prettier - but it's more functional. Maybe someone can make it look more elegant?) I'm no expert on functional programming, but from what I've learned, you generally try to use things like map, reduce, filter. 

This is very much the same idea I'm using to encapsulate "business logic" queries for re-use in PL/SQL code. So if you're looking for a validation of a concept you'll pass my review :) In a comment to the other answer you said this is just a snippet from a package code - that's good you're using packages. For PL/SQL apps in practice all code should be located in a package - a standalone subprograms a rare. The notes: 

is always guaranteed to return a single number so the exception handler for is a dead code and should be removed. If you're just checking for existence there's no point to count beyond 1, thus enter . This also guarantees the returns either or . This might or might not help your query performance (check explain plan). It's a bit questionable if such an utility subprogram should record the exception or not but more information about your error handling implementation would be required to comment further. I usually don't but I'll let the exception propagate to the caller context and then record the full stack trace there. The good thing is that you (I just assume that from the name of ). 

As you can see, equals , at least at the first go. What we'll change will be the loops. Instead of thinking in terms of , we'll think more like - transforming the arrays with our , , functions or their CoffeeScript counterparts. Now, we have to define the transforming function for the , because we want to do something like . You see, with a little bit of imagination you had in your code. Now we'll do exactly that - our function for the will get a step at every call, just like your loop did. So that's that. Next problem we have is rewriting the "global" changes you make inside the loop. So we need to do something about the and lines. We'll make the changes propagate through the result values. But how can we make two things propagate through one value? We'll use an array. Remember, is an array and is a number. Essentially we'll insert the at the beginning (or the end, wouldn't matter) of the array and at each call of our reduce callback extract it from there - and of course, after the reduce finishes. 

Your core problem is how to find out top-1 and bottom-1 in a single query. This is essentially a SQL problem and has not much to do with PL/SQL. First I present you the SQL solution and then simply wrap that into PL/SQL. You didn't provided table definitions. I was lazy and didn't tried to reverse engineer your schema but instead created very simple table that illustrates the solution that you can apply to your real problem. Other notes that might or might not be relevant to your case: 

The is just for demonstration and is to guarantee the correct ordering of the tables. The is not needed if you have other rules ensuring the id is found only from one table. If the id can be found from different tables just add a wrapper -query (the details left for exercise) to pick the first one only. Now just wrap that inside your PL/SQL as you see appropriate. When some information is not available in all tables it's up to you what is the value indicating missing value. It can be e.g. or or depending on the context. However I'd recommend unless there is other factors that rule that out. Hope this helps ! 

That's the end of our callback function. Now remember, the function works with , but so far we have only the . Let's fix that: 

Also, I'll point out the bug in the code you have in your "equivalent Javascript code" link - it has in the at the bottom instead of (which is correct). You probably guessed that since your code here has that fixed. doesn't filter the elements from the array, does. 

And we need to prepare these new values for the next "iteration" - and return them. You can see that instead of deciding whether to finish or loop again right after changing the , we delegate that to the beginning of the callback. If we had it here instead of at the beginning, we'd do unnecessary (and potentially harmful) changes to the numbers array, because we can't stop the reduce from getting through all the steps. That's a minor disadvantage of this approach - we do some unnecessary work. But we can limit it to just finding out if we actually need to do something or can just return immediately.