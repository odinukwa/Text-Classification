I couldn't find a great tutorial for this for SDL2, but I don't think the API for this has changed much since SDL 1.2, so you can most likely take a look at some tutorial on events for 1.2 and still follow along. Here's the documentation on SDL_PollEvent. 

Treat the tilemap as purely graphical data, and use some other structure to resolve collisions. In your case, you can define the boundaries of your roads using edges (segments). You have a vector (line) representing the player's movement, and you want to know if this line will intersect some wall during this timestep. Since these walls are represented by edges, the problem breaks down into line-segment intersection. Pseudocode: 

Again, you should prove your suspicions with a profiler before taking any action. Don't waste any time optimizing that you could be using to finish your game. I've used VisualVM before, and found it useful. 

I'd suggest renaming to - not only is that what it is called canonically, but also doesn't just contain the direction of movement, it's also got the magnitude of that movement. 

However, we want the opposite formula - the player's level given their total experience. What we really want to do is solve for the level, . First, let's group the terms: 

I using my own projected quads to draw the texture, because I do not like the SpriteBatch(it resets some state that is does not reset). But I think it should work with SpriteBatch, too. Otherwise you can look here to see how to create them. 

Settings the cullmode to none is only a workaround. There is a problem within Blender that causes problems during export. Maybe you can send this model to blender community? So they are able to identify this bug in their software. By the way, you should never disable backfaceculling during your whole drawings, because you loose performance. So your code should look like the following: 

I'm not sure if you can do this with the AlphaTestEffect(in fact I does not know how ATE works). I recently want to draw some kind of menu, that fills the the the stencil buffer correctly and is a kind of mask. My PixelShader looks like this: 

I'm pretty sure that the build-in "Autodesk FBX - XNA Framework" does not support this features, but maybe there is an other imported available or an other possibility I missed. The aim is to speed up rendering a little bit especially by using instancing. So having one VertexBuffer to draw at one time would be pretty nice. 

I don't see any real problems with your implementation here, but I suspect your problem is buried in . I couldn't find any mention of it in the documentation, so I assume it's something you've implemented yourself. Make sure you're using or equivalent, not just . However, it'd be easier not to use any trigonometry at all: 

Get the objects that will be moving this frame. Get their bounding boxes, before they move. Call this list of boxes . For each box in , check if is intersecting bounding boxes of objects that aren't moving. If it is, union those the boxes (including ) and replace with this new rectangle. Redraw all the portions of the background defined by the rectangles in , as well as all the entities to which those rectangles belong. 

If you make a public array class member in Unity, you can individually assign objects to the array in the inspector menu. It looks like this: 

Create a class. It fires a single event: , when some given interval of time has elapsed after the timer is started. Create a object in the class. In , initialize the timer with a time of 6 seconds and bind to its event. In , unbind from the event (since that can't occur anymore) and explode the bomb. Additionally, reset the timer, but don't start it again. In , unbind from the timer's event and reset the timer. Now, the timer won't fire. 

I guess, this information should be enough to see where I'm going to. And now the questions. There are going to be lots of various resource files - textures, audio, meshes etc. Do I need a resource manager also on the game server or it will be enough to have a good resource manager on the clients only? As the game world gets bigger and the number of clients grow, the resource manager needs lots of careful planing to avoid loading all the resources in memory and thus possibly causing low-memory issues. What is the best practice - do game servers load and keep the resources cached in RAM (and also unload them as necessary to avoid low memory issues) or this task is relayed completely to clients? I've heard a lot about memory managers/heap allocators and how the game engine might benefit from a custom memory manager to track memory allocations, collect statistics, debug etc. Will a custom memory manager give something valuable to the multiplayer server or it is enough to use custom macros around new/delete to track standard C++ memory allocations? Could I use some NoSQL RAM database engine which periodically (or when there are enough dirty objects, or when system goes out of free physical RAM) flushes its state to some persistent database? Will the game server benefit from such approach? I don't want to use something just because it's modern and cool, I prefer simple (but still scalable) solutions. 

PickableGeometry.PerformPicking(rayInObjectSpace) simply uses a TrainglePicker class I wrote that adapts the algorithm written by microsoft that you can read in the triangle picking example from mircosft. By the way, PickableGeometry.PerformPicking(rayInObjectSpace) gives you the distance from camera to object in object space. So if you use a world matrix with a scale!=1, you have to scale to distance value, too. Or you calculate the position of the intersection in object space and apply the world matrix to calculate the intersection point in world space. Its up to you! 

AlphaClipValue defines what pixel are visible in texture. e.g. 0.8f defines that alle Alpha values in the texture that are above 204 gets drawn. Other pixel get cliped. 

As you can see, I first perform picking on the WorldBoundingSphere. This is extremly fast and so I don't have to perform TrainglePicking on every object I draw. If I picked the BoundingSphere, I should test weather I really the geometry so I have to transform the ray to the object space of my geometry. This is implemented in a extension method that looks like : 

Your Player's bounding volume is a circle: Calculate distance from center of the circle to line, and check whether it is smaller then the radius. Check out this: Distance from point to line in 2D on Wolfram. Your Player's bounding volume is a rectangle: Your have to calculate each intersection of the rectangles four lines and check whether one of the intersection lies in between start and end point of one line. Check out this: Line-line intersection on Wikipedia 

Before anything, I'd look for a heap profiler and make sure it's the GC that's causing problems. However, if you find that it is indeed the number of objects you have in memory, you've already come up with the basic solution; page your chunks out to disk once in a while and only keep nearby ones in memory. But, as you've seen, there are problems with the approach, namely slowness. My first recommendation here is the same as above; use a profiler and check what's actually taking so long. A few general tips: 

As long as you only have one spawner, it doesn't look like the spawner could be instantiating 10 platforms. However, it's definitely possible that you'll get two. On the frame after the platform is instantiated, if gets called before , then will still be and another one will get created. Try setting within . That way, when a platform is spawned, it will immediately prevent spawning of any other platforms. 

However, this is cumbersome if you you want to assign the same array to many objects. It's easy to do this programatically, but I'd rather not hard-define the array in code - it makes moving/renaming the objects harder. If I want to pass the same array to multiple game objects, how can I do it more efficiently than dragging each individual element into the inspector? 

what your are asking for is analytic geometry. I think there are mainly two scenarios, assuming your wall is only a line: 

Basically I got all my information from Picking sample from microsoft. This method creates a ray in world space that i can use to pick something: 

Is there a option during import that allows my to apply the bone transformation on all vertices, so that during draw call I should not have to do this? Is there a option during import that merges all vertices into a Vertex- and IndexBuffer, that allows me to draw the whole model with just one call? 

Preconditions: I have some models, that does only contain some meshes and one texture. There is no animation within the model. An example: a model of a table. I want to draw the Model with a custom effect, so I have to swap the effect after loading the model. In order to draw them correctly, I have to apply the bone transformation manually on each draw for each mesh and effect as can be seen here. So there are two questions: 

This ray in world space can be used to intersect with bounding spheres in world space. So my picking looks like: 

The usual way to process most input is to set up your game loop to poll for events. For your specific case: set a flag on the event for the key you want to listen to. When you want to process the input, check if the flag is set and if it is, do your action and unset the flag. Example: 

The term stands for the increase in XP needed per level - 50, in the example. We can solve the above using the formula for arithmetic sequences (sum identity): 

In the above code, finds the point where a line and a segment intersect, returns the sign of a scalar, and returns the magnitude of a vector. The part where you intersect the movement vector with every wall can be optimized with a broad-phase approach, but doing it for every edge is often fast enough (it was for me). The harder part with this method is figuring out how to define the edges themselves. It's kind of ungainly to have to define these edges for every level (road) you create, but it's often the easiest solution. If you already have the road data stored in some way, you could probably construct the edges from the angles and widths of the roads. This method will also work with shapes other than straight lines. You can abstract the method to support, for example, arcs, and store generic shapes in the data structure. 

This event is published to the MessageManager. Now at one point in time the MessageManager goes through the pending messages and finds that the DamageSystem has subscribed to HIT messages. Now the MessageManager delivers the HIT message to the DamageSystem. The DamageSystem goes through its list of entities which have Damage component, calculates the damage points depending on the hit power or some other state of both entities etc. and publishes event 

I'm building a virtual world kind of engine. It's mostly for fun and learning. But I would like to get it right from the very beginning, so it is stable and can be scaled relatively easily. I've been reading a lot lately about architecture of multiplayer real-time games (and real-time 3D games in general) but still there are some questions unanswered. For now, I know the following: 

I am developing a hobby project to learn game engine development and to have a platform where I can test new ideas and have fun. Currently I have a quick-and-dirty multiplayer server and client using some third party libraries (enet for networking and Ogre3D for rendering). My "game" is mostly like a free-ride sandbox. I have read some great articles about custom memory allocators and all the benefits - complete control, different strategies for different game objects, tracing and profiling. But also I have read that it is hard to develop an allocator which is better than the default one and that it might be hard to get it to play nicely with 3rd party libraries. As it seems so hard to develop a custom allocator, I thought about using jemalloc but I'm not sure if it is a good choice for game server and/or client. I tried to find some 3rd party free/open source memory allocators designed specifically for game engines but I could not find anything production-ready. I really would like to track allocated objects by their type - to see how many network packets I have, how much memory is taken by meshes, static objects, NPCS etc. and also to see where exactly are some memory leaks coming from. Also I would like to avoid having to restart my game server regularly because of memory fragmentation issues. What is your experience? Is it a good idea to use some general purpose memory allocator (like jemalloc or tcmalloc) for game servers and clients or should I develop my own custom allocator (which seems a daunting task considering that I don't have enough experience with advanced C++)? How do I integrate my custom memory allocator with popular 3rd party libraries (enet, Ogre3D, some physics libraries) if I have no idea what allocation mechanisms are used inside of those libraries? If I decide not to use a custom allocator and stay with the one provided by MSVC runtime, is there any simple way to track my memory usage and prevent memory fragmentation without sacrificing performance? 

If I understand you correctly, you don't want to have to redraw the entire screen when a single object changes position. You've basically hit upon the solution; only redraw the portion of the screen that you need to. One method to do this is dirty rectangles. Roughly, the algorithm is: 

I can see one big problem with dropping the game loop: things won't be able to happen without events firing. This is important for things like physics and AI, which must act independently of player input. Of course, you could just make a timer that fires every 60th of a second to update those systems - but that's basically just re-implementing the game loop. Barring those issues, I think it is possible (although, perhaps, difficult) to implement the server the way you are planning. 

It looks like you're incorrectly assuming that the item is removed from the ground immediately upon picking it up. However, it isn't, and the player keeps intersecting with the same item, picking it up multiple times. Before pickup, you should check if the item has already been put in an inventory slot: 

Here's one approach to solving the problem using basic algebra. If you don't care about the steps, skip to the bottom. An easy thing to come up with is, given a level , the total experience needed to obtain that level: