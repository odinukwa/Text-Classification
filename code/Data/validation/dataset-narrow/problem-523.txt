All the code samples below are functional and in both cases my sequencer is behaving as intended when populated with some simple test tasks. I recognize that I'm being a bit loose with the permissions - a lot of things are public that probably shouldn't be but it makes it easier to test and debug in my current engine and I'll buckle down on that a little later. I'm a self-taught programmer who hasn't worked with many large or experienced teams yet and I'm still quite new to C# as a language, so I'm more than happy to receive any critiques or advice on how I can generally improve! First Attempt: This was my first attempt at handling real time tasks (for example, automated character movement over time). If a task can be performed with a single frame/update/tick it will either return or , the tree will continue being traversed, and as many nodes will be ticked as possible. However, whenever a task node returns we need to store that task somehow, back out of the tree traversal, and resume from node next time. Because each composite task calls on its sub-tasks, it seems like the state of the tree at any given time is tied to the function call stack. I can't just store the running tasks in a list outside of my behavior tree, because despite being easy to tick them again next frame I would be losing the bigger picture of their place in the tree and wouldn't know where to go next. I 'solved' this by creating a reference to a task in each of my composites. When one of a composite's sub-tasks returns a reference to that task is stored in then the composite also returns . Next time the composite is ticked it checks if a task has been saved. If so, the is reference compared to the current iteration and the loop will jump ahead until we find a match. This is the behavior tree class which only really serves to encapsulate everything: 

General impression You are not actually injecting any of the dependencies into , you are injecting a service provider that has to locate the dependencies. It may feel like dependency injection but it really isn't. What you are doing here is, basically, creating spaghetti code. Suggested improvements My question would be: What is the responsible for? Your UserProfile class depends on a View, ORM and FormBuilder class. It is in control of retrieving the user from the DB, outputting a header and outputting the user in the view body. The FormBuilder does not even seem to be used. There are several ways this could be cleaned up, for now I'll use "classic" MVC. Assuming (based on the function name) that this class is primarily a View, it should only need the user Data and your ViewCreator to function. Your router would call the Controller that would retrieve the Model and pass it on to your View. The suggestion below completely removes the service locator from the picture. Please note that the code is written for clarity in conveying the message, it is not meant to be 100% working or correct (especially the static call syntax in the controller). 

Background: I'm in the process of writing a relatively simple behavior tree driven AI system for a game that I'm working on. Basically, the behavior tree is made up of individual gameplay tasks (move, attack, etc.) as well as composite tasks that iterate over sub-tasks in a variety of ways. Each gameplay task is a leaf and will return a status (success, failure, or running). For example, a sequence composite task iterates over its sub-tasks in sequential order. If all of the sub-tasks in the sequence return , the sequence will also succeed. If any of the sub-tasks in the sequence return , the sequence will end early and fail. Finally, if any of the sub-tasks return , the sequence needs to store its position, return this frame, and re-tick the same sub-task again next frame. I had no issue getting my behavior tree to work correctly within a single frame of execution at first by recursively calling down the tree. This works basically like a depth-first traversal. But I've been having some issues finding a clean way of dealing with storing and resuming from nodes that return . I probably can't post all the code needed to compile and run this without making a mess of this question but here's the basic flow of the program: 

Things could be cleaned up even further by not initiating classes from the router but injecting them into the router from your delivery mechanism/root/index.php/etc. Further Suggestions You say you're not well versed in any framework but what you seem to be doing here is very similar to the way Silex works, which uses Pimple (which was mentioned in the comments to your question). The learning curve is quite flat so it could be worth the effort of seeing how Silex does things. If studying an entire framework takes too much of an effort I would strongly suggest you take a look at PHP-DI to observe the way a Dependency Injector should work. 

Conclusion Anyway, that's about it. Both of these "sequencer" composite tasks work correctly now, but I'm not convinced that the code couldn't be a lot better in both examples. The first code is just a brute-force reference comparison of the saved task against the current sub-task, but it's relatively clean and simple. The second code is based on iterators/enumerators and feels like it's on the verge of being the right path, but it's also a bit messy and it probably shows my lack of experience in certain areas. I'm alright with that, as I'm here to learn and improve! After all, I don't have many opportunities for code review! My main questions are: 

You are putting way too much logic into your controller methods. Most of the logic should be placed in a service that should be injected into the controller. The logic in the controller methods really shouldn't do much more than grab a value from here, set a value there and maybe call a function on a service. The most extreme way of achieving this would be to make the entire controller a service, creating a new controller and see how much you need to move back from the service into the controller. In regards to the "how", you may want to take a look at Chris Fidao's talk about hexagonal-architecture, 

This worked fine, but it felt a bit messy and brute-force. So I thought about other possible ways to do it. Thinking back to some of the C++ code that I've written, using something like an iterator came to mind. After a little research I found that IEnumerator seems to be more-or-less the same idea in C#... Second Attempt: So, going back to the drawing board, I tried rewriting my code to make use of enumerators. Now, instead of storing a reference to a task, my composite now stores an reference. I've used foreach loops and IEnumerable objects many times before in C#, but this is the first time I've ever needed to deal with IEnumerators alone. Honestly, I went for a kind of 'lazy' approach to calling instead of doing so in the constructor because I figured that tasks might be added and removed dynamically at various points in time. I added some small convenience functions for controlling my IEnumerator to prevent cluttering my code in other places. Here are the changes to my CompositeTask abstract base class: 

Answers to your questions 1. I find it hard to judge either "Sane" or "Decent". I think "Clean" is more important: single responsibility, clear separation of concerns, no side-effects, etc. Reading Clean Code by Robert C. Martin can be invaluable there. 2. If the set method actually set anything this would be less clean as it causes side-effects. Since it is really only another getter, there's no real problem. 3. Yes. This can become problematic. The best thing for it is simply to learn how to write unit tests (it honestly isn't all that difficult) and having tests with your code will teach you how to create code that is easy to test. 4. Yes, the array in setConfigData() is set again every time data is requested by . This is because it is being used from local scope and not from the class scope since it does not have a in front of the variable name. You don't need to make the array an object to resolve this, just load it from class scope using . 5. OK or not is mostly a point of view. Most folks will probably think it is fine. In my personal taste the conditions could be cleaner/less muddled. 6. Yes, MAJOR issues. Configuration should live outside of the class. It can be injected into an object at the point where it is being instantiated. You really don't want for me to edit the framework code when I want an application I build on top of it to alter its behaviour! 7. Personally I would not put all of that functionality into one method. I'd create separate methods for separate scenarios to keep the class signature (or interface) simple and easy to understand. In closing If you feel inclined to look at this from other angles, you should probably also take a look at other data structures that can/could be used for configuration other than an array. For instance, the ARC config component uses a tree structure. If any of my comments seem unclear or need more elaboration, don't hesitate to ask. I will update my answer as needed. Furthermore, as you stated that building a framework was mostly about the educational values, I think you will agree that something as essential as configuration has a lot of lessons in it. You seem to be learning them quite well. Keep it up!