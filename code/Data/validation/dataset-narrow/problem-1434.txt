To compute the camera size you will only need to scale it down from your maximum camera size if the map is smaller than that size. When scaling, you need to select the smallest dimension of your map, vertically or horizontally, and work out the >1 ratio of width:height or height:width. You want to do this because you always want the graphics to fill the scene-view and the larger of the two dimensions to reach off-screen. Working that out and using it to scale your map will assure that your scene-view is always full. You also want to do a separate bounds check, as Cong Xu mentioned, so your camera follows your character, except the camera's position is bound within a camera safe region. That region will be 1/2 camera width and half camera height in from the edges. Notice that this will need to be recomputed for each map as the camera size will change. 

Well, this is both funny and painful because of how much time I spent trying to resolve this issue. The corruption might have been a clue. I loaded up the program tonight and the issue is non-existent now. It turned out to be a driver issue, because I have just installed the AMD Catalyst 11.10 Preview driver and haven't touched the re-sizing code. That makes sense. :) 

I can't find a way to simply set a uint to a shader constant variable. But the following is a workaround : 

I would consider making an enemy factory. Every time you make a new enemy of any sort, add it to a list inside your factory instance. This means that you can update all of your enemies from your enemy factory, and you know that every enemy is in the list. 

Essentially, you have a directional graph, where every connected room is connected by two unknown passages - one in either direction. Say you start in node , and doors and lead out. You don't know what lies beyond each door, so you just pick door . You get to room , which has doors , , and . You now know that door leads from room to room , but you don't know how to get back, so you randomly pick door . You get back to room ! Now you know how to get between rooms and . Continue to explore through the closest unknown door until you find the exit! 

Trial and error is a great thing. You've got the idea of it - an overlay of some sort would be the easiest. The suggestion to use orange for dusk, and black for night, is also a good one. But nobody here can tell you what colors to use to make your game look good - that's entirely up to you and your sense of design. A much more complicated way to change the time of day is to generate an entirely new set of sprites for each period of the day. Most of these sprites would be simply shaded differently, as if you were using the above overlay, but this would allow other effects like streetlights and such. 

If anyone knows how to set a uint to the shader that would be useful. Though now that I know the 'unpacking' works ok, I'll be passing in the blendweights via a Texture2D. 

Forget about tessellation and compute shaders. You simply want to maintain a system copy of the terrain and send it (or parts of it) to the GPU every frame. Yes it's slow, but it ain't that slow :) The trick is to make the section your updating small enough to not bog down the computer. So you don't want to be updating a terrain 1000x1000 tiles. Use chunks of terrain, I use 16x16 tile chunks with 4 tri's per tile, indexed. I can update a terrain chunk in real time no problems. I was going to suggest a dynamic vertex buffer, but you don't even need that.. here's the code i use to update geometry, just use the default resource usage : 

imagine the +'s as the vertices of your mesh. Simply randomize the height of the corner verts (A,B,C,D), then average the mid-verts between these, with a little randomness as well. Keep doing this foreach mid-vert until all your verts are positioned in the z direction. You'll end up with a fairly natural looking terrain. There are all sorts of ways in which you can modify your height algorithm, using various noise and smoothing methods. There's not really any math behind generating a simple terrain mesh. Not until you look at more complex methods, when you're after more interesting results. But you have to be comfortable with generating height maps first. 

thanks for your time! I'm really new to LibGDX (and Java itself). Which approach should I use to render my different game parts? I want to show a background, the main character, a bunch of enemies and an HUD. The playable area will be bigger than the screen so the camera has to move following the main character (top view). Also everything has to be procedurally generated. For example, I have the code to generate the map (background) but I don't know how to render it if it's in another class (not the core entry point one). I can think of calling a custom background.draw() method from my main.render() class and pass a batch to draw onto but probably there are better ways. I've tried to use Stages (scene2D) aswell but I can't get my camera to move (are they mostly made for UI?). I'd like to be pointed towards the best solution performance-wise since it's gonna be called every frame :P 

I would like to know what is the best way to implement collision avoidance and eventually pathfinding in a LibGDX 2D top view game. Think of "Binding of Isaac". I use a sort of tilemap to place the obstacles (squares), taken from an ASCII map, but I'd prefer to keep the movements free from it. (Enemies shouldn't move from tile to tile but freely) Since the target is mobile I can't use heavy algorithms. I'm not particularly concearned about enemies getting stuck on weird shapes (such as 'U') since it kind of makes sense (they are white globules, not particularly smart :P) but I still want them to be a challenge. I've taken into consideration Steering Behaviors and the LibGDX-AI framework but I can't find good documentation, I can aswell code it by myself in case. ANOTHER QUESTION Just to know, which kind of algorithm is used in the Binding of Isaac? It perfectly suits my needs 

But this doesn't behave as expected. The geometry is a dark red, when it should be white. What the turtle is going on here. 

Can I recommend getting 2d shadows working first, even if it's just for the level that your avatar is currently on. It will be easier to start looking at the code that way and get it working. I have implemented shadows in 2d tile maps in a couple of ways. One shadowcasting method which I found described by Eric Lippert at Microsoft works quite well. And the other way, which I did myself first time i looked at this kind of thing was to orthogonally sweep the visible tiles and tile-edges and generate edges (and maybe corners iirc) describing the scene in the lowest number of edges. You can then cull hidden edges and form any custom shadowing features such as recessed shadows if you want to show a little bit of wall. Then create your shadow geometry (projective shadow casting ?) and render it over the top. But if I try to take that idea to 3d, it just becomes easier to do it in 3d. While the method described by Eric Lippert could presumably be converted to 3d. But I think you'll find that doing it in 3d is expensive. Perhaps take a look at the source code for Brogue as well. It may have a more efficient implementation for 2d visibility/shadow casting. Good luck. 

I would try sticking with Perlin noise, but adding a weight to it based on height, to ensure a certain average density at certain altitudes. To quote part of Notch's post on Minecraft terrain generation: 

David Hellman has written some great articles on The Art of Braid, which is the most artistic games I've ever seen. While art is an extremely personal, subjective process, it's definitely interesting to see other people's processes. The articles talk about how the art began as extremely abstract and moody and got more form as it was reconciled with game mechanics. 

That all being said, if I were designing a kid's MMO, I would actually implement a stringent blacklist filter, but only as a second line of defense. Your first line of defense should always be moderators and the ability to report abuse. I would weight blacklisted words, with each user getting a secret score of how profane they are trying to be. Chances are, any user who will try and circumvent your filter will trigger it first. The more obvious profanities, (as opposed to obscure or outdated ones,) or more repeated profanity attempts, put them on a watch list for moderators, or some sort of ban list. This way, moderators can focus on users who seem to be trying to harass others instead of wasting their time reading the comments of still-innocent kids. 

Isn't it as simple as rendering your gun geometry (or 2d HUD style gun) near the camera and narrow the field of view. 

Can I just suggest that you absolutely forget about biomes if you can't make and use height-maps yet. Step by step is the way to go. 

It probably depends on what it's for and what your employee is telling you to do (if you get to that stage). If this is just for yourself, don't bother with Autocad, just use Max, it's so much more fun. Max and Maya are great tools for 3d visualization, I've seen some wicked home interiors made with these packages. You can model everything in Max for visualization, but if you need technical specs then Autocad might be the way to go. Listen to what anyone says about Autocad, because I don't know it much, I've studied Max and to a lesser degree Maya. So an autocad user might have some things to consider. 

I agree mostly with Asher, XNA is ... was a good language to learn on and C# is very intuitive and far easier to work with than C++. C# and Java are incredibly similar, so you'll feel something familiar there. What you know in C++ can be applied to C#, you just have to forget about all the annoying and confusing stuff :) But if you are going to learn a framework, just start learning SlimDX, I've recently given up on XNA because well... it's based upon DX9, an aging framework, and it looks like XNA has reached the end of the road. It cannot run DX10/11 under the hood, and that's what you want to be using. That is current technology. Using SlimDX is incredibly similar to using XNA but it is far more powerful and you know you are learning current technology. 

How can I handle collisions with obstacles in LibGDX? Is there any automatic way to stop the character's movement when it collides with a wall or I have to constantly poll for all the possible objects it might encounter and stop the movement accordingly? Polling this way seems pretty poor performance-wise, especially if the framework already does that for me and I make no use of it. My game is a top view roguelike, more or less like "The Binding of Isaac". EDIT some beginners like me might make good use of it. Since LibGDX has no built in collision detection without Box2D, for games where physic calculation is not needed you can build your system as follows: Create 3 lists (Static, Dynamic, Controlled) where you put all your (relatively inherited) objects in the scene. Static objects (walls, obstacles, traps) are passive and perform no checks. Dynamic objects (projectiles) perform checks on both Static (stop if you hit a wall, destroy self) and Controlled (deal damage) Controlled (players, enemies) objects perform checks on self (player hit AI controlled enemy) and static objects After a collision is reported notify the relative objects. Controlled objects can be Dynamic aswell but if you have a lot of projectiles flying around you can avoid self-checking Dynamics and improve the performance. This way you should reduce a lot of useless checks aswell as limit cross-checks (both player and projectile notifying eachother) and keep your game well organized. This is just an idea that i'm testing now, I can't guarantee it's the best :P 

Essentially, you're taking a little slice of a Minecraft terrain. So generate 2D Perlin noise, but weight it so that anything above a certain point is likely to be air, and anything below a certain point is likely to be earth. This will give you a good ground terrain, with some overhangs and interesting features, as well as some caves and floating islands. (If you don't want floating islands, you can test for them and remove them manually.) This method won't give you things like tunnels, so you'll want a method for adding those in after terrain generation, such as a random-walk. 

The best way to generate interesting voxel terrain is with a Perlin noise density map. Rather than using a 2D Perlin noise map defining the height of a 3D world, use a 3D Perlin noise map. Weight the map so that the values closer to the bottom will be more likely solid, and the values closer to the top will definitely be air. This gives your world height, but also allows for overhangs and caves, similar to Minecraft terrain, as this side-view of a slice of terrain shows: 

The above pictures and cave system ideas are from this excellent blog post. You can learn all about Perlin noise here, and there is some sample code to get you started here. 

Don't. Filters don't work. At least, only filters don't work. Whitelists, blacklists, it doesn't matter. Neither of these will ever prevent kids from harassing each other. The only way to make this work would be to not filter the chat, but to provide large building-blocks for sentences. For example, a kid might select "Do you want to..." and the options for "go to..." and "trade..." would be pulled up. Selecting "go to..." would bring up a list of places in the game. Disney settled on this method for their MMO "Toontown", after their 14-year old whitelist test subject decided to "stick [his] long-necked Giraffe up [their] fluffy white bunny." Simply put, you cannot blacklist or whitelist enough words to prevent abuse.