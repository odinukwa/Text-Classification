The 3 has the same form factor as the 2/0/+ models, with the same 40 pin GPIO header, so yes. The buses involved will work the same way, hence so should the software. 

That'll take a while. When it's done, it's done. Unfortunately, from the glimmer in the photo in your post, it looks like you did write an image and it did mostly boot. What happened after that is unclear because the picture is unreadable. 

I have not played with the GPIO pins this way but based on this article, you must first set the direction of the pin to "out". The node is owned by root, so: 

This is from itself, which produces that sha hash. It's sort of obvious from the line that's what's being extracted, but to demonstrate, just run: 

The obvious question is then: What software? You have to get it from somewhere. Minibian is based on Raspbian which is based on Debian, and the fundamental units for distro packaged software are packages. The network installer works off a list of available packages to resolve dependencies, then downloads and installs the appropriate files. You can manually download such files from the same place; you should have a list of repos in . For example, a default for raspbian is $URL$ If you then navigate to the pool/main directory you'll find packages broken down into subdirectories. As long as you periodically do an with the system online, you can do do this whenever while offline: 

I know the linux kernel has a language agnostic GPIO interface through which can be manipulated with , , etc. How can this be used to create event driven callbacks programmatically? 

Yes, accessing a web page requires a web server to provide it. Once the two devices are on the same hotspot, you can access the web server using the Pi's IP address. It does not matter whether the Pi or the phone is acting as the hotspot AP. 

Yes, because Windows machines cannot read ext4 filesystems, at least not without third party tools. Unfortunately, this means there is no way to tell, using such a machine, whether there is a second partition and if it is formatted correctly. 

Those prefixes are for start and for kill; a script which is symlinked using the latter will have it's option called, if any. Stuff in runlevel 0 and 6 are mostly because they are services started at boot that are now being shut down. If you want to start something in reboot, use . 

And if is a file it should be a file in too. However, if you've been using that zany thing with prior to this, all bets are off. You could save yourself a step this way: 

This adds read/write permissions for the group owning 'whatever'. A lot of stuff in /dev is uid and gid 0 (owner root, group root) but some things have a separate group such as 'video' or 'disk', and when this is the case, the group will already have read write permissions on the node. So, first check if the node you are interested in is like that: 

Yes, but there's a distinction here which complicates things -- although I'm not an RPi.GPIO (or python) user I would assume it applies. PWM pulses need to be precisely timed without depending on CPU instructions, since on a multitasking OS the CPU cannot be counted on for this purpose and forcing it to do so would be (very) detrimental to system performance. So there are dedicated bits of SoC hardware which can be controlled and run independently much like other peripherals. The fundamental component of this is a 19.2 Mhz clock, which can be processed into two independent channels. Each of the PWM pins (12, 13, 18, 19) is wired to one of these channels, so when you control the pulse what you are actually controlling is connected to two pins, although whether they actually output this signal depends on the mode set on them. Anyway, that clock and the channels just run whenever the power is on, regardless of whether they are used to do anything (there may be things the clock is always used for other than PWM, I don't know). The same will apply to pins set to carry their signal. In short, I do not think there a way to detect if anything beyond the pin is making use of the signal; this also applies to outputs. However, setting the pin as an input may produce a predictable result, or it may "float" as it does when disconnected (i.e., read as either high or low). The problem with relying on this is there's no way to differentiate a chance reading on a floating pin from one which is pulled up or down by a connection, unless perhaps you experimented with polling the pins to see how likely no variance is likely to happen on a disconnected pin over a duration -- but I doubt that will be very reliable either. The solution is to add some additional circuitry, preferably something which would set an input high when the servo is connected. Of course, that is likely to complicate the processes of attaching and detaching servos. The two things I can think of off the top of my head both involve a 3-pole switch, the kind where in one position wires A and B are connected, and the other, B and C. 

Yes, that is how electricity works. However, beware that stuff connected to the Pi can cause a draw exceeding the limits of the polyfuse on the microUSB supply jack, so unless you want to experiment with seeing how long that takes to reset (or what it can handle...), avoid that. I believe the limit is 2 A on all models but the 3, which is 2.5 A. Also beware if you backpower via normal USB or one of the 5V pins this polyfuse does not provide any protection. Presuming this 2-3 A limit is there for good reason, in that case you want to make absolutely sure no more than that will be used. If I were doing this I'd chop a microUSB cable and wire it to the supply so you do not have to backpower. This also ensures the power goes through the onboard regulator first (which it certainly won't do via a 5V pin). It may also be possible to get a mini->micro USB adapter. 

If you mean, can I squeeze more water through a pipe than the pipe was made to contain then no, or can I get a pump to work faster or some combination or the two again, no. If you need a faster pump or a bigger pipe, buy a faster pump and a bigger pipe. 

This is the kind of thing which may be an interesting learning experience for you but comes with a high risk of failure. RF communication requires fairly fine grained timing, usually (as with bluetooth, wifi, etc.) via hardware dedicated to that purpose. The cheap plain jane 433 Mhz things you can get for a few bucks online are interesting in that they don't have that. You presumably have the additional complication of having to reverse engineer the protocol used by the car. Hopefully you have a controller that works to help you with that. In my experience, just getting a receiver to receive messages via a protocol of your own invention can be tricky. Trying to pick out and properly interpret an unknown pattern is going to be like trying to play scrabble underwater, in a muddy, murky swamp, at night. There's also the possibility, since the pi is not ideally suited to this, that the timings required are not feasible. 

Unless the green light at least flickers a bit a first, this may be a variation on the previous scenario. To explain: 

The 4 at the beginning is for the setuid bit necessary to 's functioning, the 750 means read-write-execute for owner (root) and read-execute for group (usesu), nothing for anyone else. 

No, django is not too heavy for the pi, and this doesn't look like a heaviness oriented issue, it looks like a screw up. There seems to be a lot more than just django included in that wham-bam tutorial. Maybe you should ditch that, do a bit more reading about django, install just apache and -- which should not require a from some git repo, BTW; I'm not a python user but I would think is a better choice -- then go from there. In fact you don't even need ; there's a (python 2.7) package and a package already. If you are just starting out with something, use with the distro packages whenever possible. People who write "tutorials" like this which lead well off a beaten path without explaining the whys and where-fores should be themselves led off the trail and beaten ;) I am sure there is plenty of much, much better quality material around, although it may not seem to promise wham-bam (oops...) results the same way. The official python documentation is pretty thorough, and django has been around for a long time and is very widely used; presumably the same is true there (I'm not a user, but I sometimes peek my head in). Your mistake is including "raspberry pi" in your search terms. It's a fairly normal computer in this context (albeit a diminutive one), so it is not so much the brand of hardware that's relevant as the operating system, and Raspbian is a close derivative of Debian GNU/Linux, which has been around for several decades. 

Next, we need to set some capabilities on dumpcap so that it can do what it needs to do without being run root: 

Although this seems a little counter-intuitive, since you aren't actually hotplugging. It may also be that you need to experiment with and settings further down the same page. Or it may be the or settings, all of which are, again, included with . 

as the shebang opening the script. will show you all the available pythons. You can also specify the specific interpreter on the command line: 

Sometimes commands have redundant seeming switches like this because they must satisfy specifications for several different contexts. Simple logic tells us that since is the default anyway, using is itself redundant (again, it exists to satisfy an external spec; some implementations of may not work this way by default, but all the ones that conform will implement ). Since the pi itself can't poweroff (it is either plugged in == on, or not), there is no point in using , but it won't cause any harm. It may make a difference WRT the way the red LED blinks at the end (you could compare with to see). Note the major purpose of is to stop (halt) the OS from running. So you can use either form. 

Obviously using whatever static address in place of and your router's address in place of . Note it is important to use an explicit CIDR () because the default is , which indicates a network of one. You also probably need to add your ISP's nameservers to (and beware DHCP tools like to overwrite that), or else use Google's ( and ).