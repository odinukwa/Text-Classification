Parametrised complexity: kernelization, iterative compression, bidimentionality, ... Approximation algorithms: randomised rounding, scaling, ... In graph theory, based on structural hierarchies of graphs like bounded tree width graphs/excluded minor graphs/ bounded expansion graphs / nowhere dens graphs, there are different tools (like decompositions) and meta theorems (like Courcelle theorem). 

Shortest 2-Vertex disjoint path problem in undirected graphs recently solved (ICALP14) by A. Bjorklund and T. Husfeldt. But the deterministic solution is for the case of existence of a unique solution. In the case that there are more than one solution, they showed that the problem belongs to RP. As authors of the paper mentioned, it is not known if the problem is in P in general scenario. 

I don't know if there is any pure graph theoretic problem which is hard in bounded vertex cover, and if there is any it is very interesting for me to see such problem. However, here is a problem of weighted disjoint paths with congestion, a natural practical and theoretical problem. Input: 

First of all I think you mean a maximum clique, not all cliques (and even not maximal cliques). As otherwise e.g in $K_n$ there are $2^n−1$ cliques. If the question is the one that I said, then there is no polynomial time online algorithm for update (unless P=NP). If there is such an algorithm $A$, given a graph $G$, we can find a maximum clique of $G$ in polynomial time. Just start from a graph on $n$ vertex without any edge and add edges of $G$ one by one and update information in each step by $A$. After adding all edges we have a maximum clique. Note that if we use exponential memory at some steps we can do this, but to write on exponential memory we need exponential time as well. Maybe there are some heuristics. 

I'll provide a naive approach which give $O(m^2 \cdot max_f)$ running time but shows the problem is P. First turn the graph to undirected graph. Suppose one edge is in first graph and the other in the second graph, contract both of them and name them $s,t$. We can find a minimum edge cut that separates s and t in time max_f which is a running time of best maximum flow algorithm on unit weight graph. We run this algorithm for all possible pair of edges. But why this works? trivially there is no smaller cut and the two sides are not edgeless. On the other hand if a graph G is connected minimum edge cut C between two vertices s, t always cuts the graph into two connected subgraphs. 

Feel free to down-vote, but please leave a comment if you have anything technical to say, Thanks for your patience. 

Notation: Let $X = (V,E)$ be graph, $e = (v_1, v_2) $ an edge of $X$. The vertex set $V_k$ be the set of vertices of distance $k$ from $e$, and let $h$ be the height of $X$. According to definition of $V_k$, $V= V_0 \cup V_1 \dots V_h$ and $V_{(h+1)}= \emptyset$. Let, subset $E_k$ of edges of $X(0 \leq k \leq h)$ is defined as- $E_k = \{ (u,w) | u \in V_k, w \in V_ k \cup V_{(k+1)} \}.$ The subgraph $X_i$ is defined as- $X_k= (V_0 \cup V_1 \dots \cup V_k, E_0 \cup E_1 \dots E_{(k-1)} \}$ For example, $X_2 =\{ (V_0 \cup V_1 \cup V_2, E_0 \cup E_1)\}$ $Aut_e(X)$ is the automorphism group of graph $X$ where $e$ is fixed. If $B$ is a generating set of $Aut_e(X_k)$ , we write $\langle B \rangle = Aut_e(X_k)$, for example, it is clear that $Aut_e(X_0)=\langle(v_1,v_2)\rangle$ where $ (v_1,v_2)$ is a permutation of vertices $v_1, v_2$ of $X$. Principle Constructing generating set of automorphism group of $X$ is a GI (graph isomorphism) complete problem [1]. So, if we can compute generating set of automorphism group of $X$ (which has bounded valance in polynomial time), we can solve GI in polynomial time. So, we wish to determine $Aut_e(X)$. Technique: We will construct $X_0, X_1..... X_h$. For each, $X_k$ we will construct $Aut_e(X_{(k)})$ Note that, a permutation of $Aut_e(X_{(k) })$may be extended to an automorphism of $Aut_e(X_{(k+1)})$. So, generators of $Aut_e(X_{(k+1)})$ can be obtained from generators for $Aut_e(X_{k})$. To construct generator, structure-type of $E_k$ is manipulated. The structure-type of $E_k$ can be divided into finite classes. For example, in the trivalent case, there are only six type (only five of those cases can actually occur). We will classify the edges in $E_k$ into types and will group them into families . This helps to create a number of unique labels. For a fixed valence, the number of labels is small. At this point, we use the concept of setwise-stabilizers to find permutations which acts on particular label. In the process, we find the generator of $Aut_e(X_{(k) })$. Then, we use the generator of$Aut_e(X_{(k) })$ to find the generator of $Aut_e(X_{(k+1) })$, as stated earlier. Proceeding in this manner, we obtain, $Aut_e(X)$ . 

PS: A stronger result was later proved unconditionally by Okamoto (On Relationships between Statistical Zero-Knowledge Proofs). Description of some terms Since the above result includes a lot of cryptographic jargon, I try to informally define each term. 

If possible, find a survey, book, or a lecture note. This will help a lot to see the jungle through the trees! To find books, Google Books is your friend. Search the keywords in the Google Books, and try to find a relevant book on the subject. Take the top-down / bottom-up approach, and alternate. That is, read the most recent papers first (the top research), and references thereof (bottom). Why? Because the top research is likely to be better, and has probably surveyed bottom works and improved them. However, to understand top, it is usually the case that you need to skim the bottom works. Important: Don't get stuck at the bottom. After reviewing older works, take the bottom-up approach. Finally, alternate between the top-down and bottom-up approaches. Don't read a paper unless you are somehow sure that it is really relevant. The relevancy depends on several factors: The amount of citations, the fame of authors, the conference/journal it is published in, and so on. Be sure to read the title and abstract carefully, and skim the sections. Decide if you should ever read this paper now, and to what extent. If a paper has a conference version and a journal (full) version, select the first one. The conference version usually gives the general idea, and avoids cumbersome proofs. Read the full version only when you really need to learn the proof details/technique. 

This shows that the $\beta$ hierarchy has contradictory relativizations, nominating its separation as a "hard" problem. The literature does not seem to care much about the $\beta$ hierarchy, since a regular search does not show up with many relevant results. In particular, there's a very limited (and seemingly irrelevant) number of papers citing the above results. 

How about Complexity Lower Bounds using Linear Algebra? The book is not exactly what you want, since it surveys lower bounds using linear algebra, not the complexity of linear algebra problems. Yet I think it is helpful anyway, since it is first necessary to grasp the complexity of linear algebra problems, and then use it to prove lower bounds on other problems. Here's the description of the book: 

Seems this is a FPT algorithm for a fixed $k$. First of all we can just consider a block which contains $s,t$. If we have a $k\times k$ grid minor which contains $s,t$ then we can find the corresponding chain. As otherwise, as Chekuri et al. shown, the graph has tree width at most $O(k^{1/\delta})$ where $\delta > 0$ is some constant. So we can compute the tree decomposition of graph then check whether that chain exists or not. I'm not sure if with usual dynamic programming on graphs of bounded tree width is possible to find the chain. Also if is not bounded tree width, their algorithm can find the corresponding grid in polynomial time. P.S: Note that I didn't use the fact that there are $n^k$ s-t paths, may be by some trick inside this fact is possible to obtain better algorithm. 

Consider a star graph, if we take a center of star union with $l-1$ arbitrary vertices then the corresponding subgraph is induced connected subgraph. So the maximum number is about $n-1\choose l-1$. We can extend this class of graphs by connecting arbitrary vertices together to have more edges. It's also possible to achieve closer to $n \choose l$ if $l$ is much smaller than $k$, or $k$ is big enough. 

In general, if the problem is in such a way that needs more than one dimension for dynamic programming and also those dimensions are depended to each other then the problem has potential to be hard in graphs of bounded tree width. We can see this pattern in both of problems in the question as well as for the sparsest cut problem. (In the first problem we want to keep previous coloring on the other hand keep coloring as small as possible, in the second problem obviously there are two functions which are dependent to each other) 

Minimum number of cops (pursuer in your definition) needed to win in similar game is equivalent to Kelly width of $G$, and it's NPC to determine that minimum number, it's similar to path decomposition for undirected graphs, but I don't know about minimum number of moves needed such that $k$ cop wins. But there are some works around similar games, if you are interested to know more about them maybe a good search term is cops and invisible inert robber game. Note that we can add loop to every vertex of a graph $G$ to skip the most move condition, then the game is in fact invisible robber game or the kelly width game or for undirected graph it's a well known path-width game (invisible robber is inert by nature). The maybe main difference between Kelly width game and this game is that robber can walk along edges not a single edge (I didn't read the question carefully at first, I read evader walks along edges, but still I don't think it makes totally different game, one may find a gadget to simulate walking along edge by walking along paths, e.g something like turning vertices to complete graphs). 

I think the answer to you first question is negative: A circuit has a fixed number of inputs, and thus, IMO, we can only talk about "families" of circuits, rather than just one uniform circuit. Regarding your second question, you may note that there are "uniform families of circuits," whose description is generated by a Turing machine. That is, let $\{C_n\}$ be a uniform family of circuit, and let $M$ be a Turing machine. Then, for each $n$, $[C_n] = M(1^n)$, where $[C_n]$ denotes the description of $C_n$. There are several complexity classes below P, defined by uniform families of circuits. For example: $\mathbf{NC}^i$ is the class of decision problems decidable by uniform boolean circuits with a polynomial number of gates and depth $O(\log^i n)$. 

This is well beyond my imagination! It seems that, even if we are given the proof σ, it is unlikely that we can construct such formula ϕ. 

The experiment above resembles a "chosen plaintext" experiment against a symmetric encryption scheme, where the adversary can obtain ciphertexts corresponding to messages of his choice. In a more powerful attack, called "chosen ciphertext" attack, the adversary is allowed access to a decryption oracle as well. So, my question is: 

(I specially need survey-like references; those which are newer and do not need a lot of expertise are more preferable.) 

Consider an array of bytes. I want to partition the array, such that the following two conditions hold: 

The Karp–Lipton Theoem states that if $\mathsf{NP} \subset \mathsf{P/poly}$, then $\mathsf{PH}$ collapses to $\mathsf{\Sigma^P_2}$. Therefore, assuming separations between $\mathsf{\Sigma^P_2}$ and $\mathsf{\Sigma^P_3}$, no $\mathsf{NP}$-complete problem will belong to $\mathsf{P/poly}$. I'm interested in the following question: 

In game 0, adversary A is given oracle access to a random permutation $\pi$. In game 1, the random permutation $\pi$ is replaced with a "stateful" random function, which preserves the "permutation" property. (In Bellare-Rogaway terminology, this is called "lazy sampling"). Finally, in game 2, the stateful random function is replaced with a "stateless" (of "forgetful") one. 

Wikipedia has an interesting take on independence: ...These barriers have also led some computer scientists to suggest that the P versus NP problem may be independent of standard axiom systems like ZFC (cannot be proved or disproved within them). The interpretation of an independence result could be that either no polynomial-time algorithm exists for any NP-complete problem, and such a proof cannot be constructed in (e.g.) ZFC, or that polynomial-time algorithms for NP-complete problems may exist, but it's impossible to prove in ZFC that such algorithms are correct [1]. However, if it can be shown, using techniques of the sort that are currently known to be applicable, that the problem cannot be decided even with much weaker assumptions extending the Peano axioms (PA) for integer arithmetic, then there would necessarily exist nearly-polynomial-time algorithms for every problem in NP [2]. Therefore, if one believes (as most complexity theorists do) that not all problems in NP have efficient algorithms, it would follow that proofs of independence using those techniques cannot be possible. Additionally, this result implies that proving independence from PA or ZFC using currently known techniques is no easier than proving the existence of efficient algorithms for all problems in NP. 

Are there any literature /algorithms regarding the problem? Can the problem have a log-space time algorithm (without using planarity check algorithm)? 

The computational complexity of of finding $P$ is polynomial in $\beta$. We construct the generating set of automorphism group of $H$ using $\beta_k$, for all $k$. As we know, constructing generating set of automorphism group of $H$ is a GI complete problem [1]. So, we try to construct the generating set of $Aut(H)$ . The technique used in the paper [2] by E. Luks can used here. Notation: From now on, $G, H$ are adjacency matrices of graphs $G, H$ respectively. $H_k, G_k$ are blocks or sub-matrices of matrix $H, G$ respectively. The adjacency matrix of graph $H_k \cup H_e$ is $M_{(k,e)}$ where $M_{(k,e)} =\left( \begin{array}{ccc} H_e & R_{k,e} \\ R_{k,e}^{T} & H_k\\ \end{array} \right) $, where, $R_{k,e}$ is the non symmetric sub-matrix of adjacency matrix $H$. Here, $R_{k,e}$ represents edges between $H_k, H_e$. Similarly, $S_{k,e}$ represents edges between $G_k, G_e$. $$H = \begin{bmatrix} H_{(x)} & R_{(x, x-1)} & R_{(x,x-2)} & \dots & \dots & R_{(x,1)} \\ R_{(x,x-1)} & H_{(x-1)} & R_{(x-1,x-2)} & \dots & \dots & R_{(x-1,1)} \\ \vdots & \vdots & \vdots & \ddots & \ddots & \vdots \\ R_{(x,1)} & R_{(x-1,1)} & R_{(x-2,1)} & \dots & \dots &H_{1} \end{bmatrix}$$ For simplicity, we assume $\beta \leq n^{3}$. The outline of the algorithm to construct generating set: At $1^{st}$ iteration - Step 1. Construct all possible direct product $(\pi_1 \times \pi_2)$ where $\pi_1 \in \beta_1$ and $ \pi_2 \in \beta_2$. There are $| \beta_1 | \times | \beta_2| < n^{9}$ direct products (permutations). All these permutations (direct products) form set $\gamma_1$. Each element of $\gamma_1$ is a permutation that acts on graph $H_1 \cup H_2$. Step 2. Construct/find - $\alpha_1 =\{ \pi \in \gamma_1 | (M_{(1,2)}^{\pi}= M_{(1,2)}) \land ( R_{1,2}^{\pi} = S_{1,2}) \land (H_1^{\pi} = G_1) \land (H_2^{\pi} = G_2) \}$ $\alpha_1$ is the set of automorphisms of matrix $M_{(1,2)}$. $|\alpha_1| < n^{9}$.There are two possible cases- Case 1: If $|\alpha_1| =1$, then for each $\pi_1 \in \beta_1$, there is only one permutation $\pi_2 \in \beta_2$. So, there could be maximum $n^{2}$ permutations in $\gamma_1$ but only one permutation could be included in $\alpha_1$. Case 2: If $|\alpha_1| >1$, we would be able to construct a generating set $\mathcal{S}_1$ of an automorphism group of $Aut(M_{(1,2)})$ Note, that if $\exists \pi_a \in Aut(H)$ such that it acts on vertices of $H_1 \cup H_2$, then $ \pi_a \in \langle \mathcal{S}_1 \rangle =Aut(M_{(1,2)})$. So, when we construct direct product of $\mathcal{S}_1$ and another set, $\pi_a$ can be found in the resulting generating set. See Theorem 7, on page 31 of [3].The theorem showed how to obtain the automorphism group of an arbitrary graph from the intersection of a specific permutation group with a direct product of symmetric groups. Step 3. Now, we construct the generating set $\mathcal{S}_1$ from $\alpha_1$. This construction of generating set can be done in polynomial time (see [3], page 40, theorem 9). From [4], we find that $|\mathcal{S}_1| \leq log(n!)$ . $\mathcal{S}_1$ is the generating set of automorphism of $H_1 \cup H_2$ . Step 4. We start $2^{nd}$ iteration, for $\beta_3, \mathcal{S}_1$ (instead of $\beta_2$), $ M_{(2,3)}$ where $M_{(2,3)} =\left( \begin{array}{ccc} H_3 & R_{2,3} \\ R_{2,3}^{T} & H_2 \\ \end{array} \right) $. We find $\gamma_2, \alpha_2$ repeating steps $1,2$ and construct $\mathcal{S}_2$ (repeating step $3$) which is the generating set of automorphism of graph $H_1 \cup H_2 \cup H_3$. Note that, $|\mathcal{S}_2| \leq log(n!)$ . Step 5. We keep repeating above four processes, until we find the set $\mathcal{S}_{(x-1)} $ which is the generating set of automorphism of graph $H_1 \cup H_2 \cup H_3 \dots \cup H_x=H $. Note that, $|\mathcal{S}_{(x-1)}|\leq log(n!)$, since $ \langle \mathcal{S}_{(x-1)} \rangle= Aut(H) \leq S_n$. Detecting Isomorphism: We repeat the process of construction of $\mathcal{S}_{(x-1)}$ for graph $G$ and obtain set $\mathcal{R}_{(x-1)}$. I assumed, that the oracle that gave $\beta_k$, would provide permutation sets for $G$ also. Once we generate generating sets of $G, H$, we can decide isomorphism betwen them [1]. References: [1]Mathon, Rudolf. ,A note on the graph isomorphism counting problem, Inform. Process. Lett. 8 (1979), no. 3, 131–132. [2] Luks , Eugene M. , Isomorphism of graphs of bounded valence can be tested in polynomial time, Journal of Computer and System Sciences, Volume 25, Issue 1, (1982), Pages 42-65. [3]Hoffmann, Christoph M. ,Group-Theoretic Algorithms and Graph Isomorphism. [4] Miller, Gary L. ,On the $n^{\log_2(n)}$ Isomorphism Technique. 

How about a preprocessing phase? Given a random seed $s$ (of size $n$), run $X$ to get a pseudorandom stream of size $1000n$. Denote this stream by $s_1,s_2,\ldots,s_{1000}$, where for $1\le i \le 1000$, $s_i$ is a contiguous portion of the stream of size $n$. This preprocessing phase can be done with a very low overhead, given the fact that $X$ is an efficient PRNG (today, we have very fast PRNG's). Now, give $s_i$ as the seed to the $i$th machine, which uses $X$ to generate its own pseudorandom stream. Given the nice properties of $X$, unless $s$ is known, for any $1 \le i < j \le 1000$, the seeds $s_i$ and $s_j$ are computationally independent. Moreover, you only have to generate and save one small seed (i.e. $s$); therefore, this approach does not need a great deal of true randomness or storage. 

If $VNP=VP$, then factorization can be performed efficiently, and therefore we do not have to resort to repeated squaring. However, performing factorization for someone who does not know the factors of N incurs a polynomial overhead. You may also be interested in the concept of feebly one-way functions, though they are not exactly related to the question. See the following references as well: 

A naive approach is as follows. This approach can be used when no better solution is available: Keep a ternary search tree: Each node (except leaves) has three children: a , a , and a . The height of tree is L. Each leaf stores 1 bit: whether the pattern denoted by the path from the root to that leaf exists in your sequence. A full ternary search tree takes a space of $3^L$. Since L is rather small (L=15), the space will be $3^{15} \approx 14 \ MB$. Since |data|=100,000, and since K << L, it is possible to prune the tree in such a way that it takes much less space. Now, a backtracking algorithm can search this data structure: Given input x, it starts at the root of the tree, and checks the MSB of x. This bit is either 0 or 1. Assume wlog that the bit is 0. Then, the algorithm omits the child, and takes the and children. This is continued until we find a match, a mismatch, or when the number of 's along the path becomes greater than K (assuming the tree is not pruned already). The above algorithm may take a long time, unless you have pruned the tree properly. That is, if a node does not have a child in the , mark it as having no child. Note that since $\binom{15}{7} = 6435$, in the extreme case, up to 6435 patterns in might match x (which is 6% of |data|; so even the best algorithm has to search this fraction of the database in the worst case).