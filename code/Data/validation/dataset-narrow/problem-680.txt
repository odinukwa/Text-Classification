That was a lot of text, but do keep in mind that a lot of this are suggestions not explicit errors. In general it seems like your coding style is good, and that you've implemented good extensions to the robot library. And in the world of programming there is always room for other implementations, or other viewpoints. So keep up the good work, and don't be discouraged even though this got to be a somewhat lengthy review. 

Whether it is worth it for such a simple case, is a matter of taste, but at least the trick to simplify the vs is a neat trick, and my first code example is a little gentler to my eye. You could also opt for a not so readable, but shorter solution like: 

An even more vital question than does it deviate from best practices, is whether it actually does what you intend for it to do! Does it accurately time exection of the function in you are testing? I believe not due to the following reasons: 

This behaves mostly the same as your code, and the difference is that this also returns 1 when the text is only one character long. The other flaws/feature, is kept as is. Do notice how it has simpler logic, and is a little easier to read, whilst still doing the same stuff. Alternate algorithm In my first naive approach at a different algorithm, I used a loop going through the string once, and stored the position of where I first saw a given character. This worked rather nicely, until I considered the case "abbaaaaeeeeeeeeee", where the first occurence of "a" is at start, whilst the longest substring should start with the "a" at position 3. This made me change the length calculation from using positions, to stripping of the characters from end of string. This led to the following code: 

It is kind of hard to understand your question, but it seems like you want the following parameters: 

And then you proceed to give us the code example, and state that you want to make your program more efficient by a factor of a thousand (from 7 seconds to a few microseconds). That is not easy to accomplish... Alternate solution for generator Here is a suggestion to revert the process, in order for you to generate Alberi puzzles. It is not coded, but it shouldn't be that hard to actually code (I think...): 

Avoiding the rebuild You're in a class, and a class can have a constructor. Utilize this to build the needed . And instead of having a rather costly I would advice in this case duplicate the reverse map, as well. (Another option would be to use some external library to implement some bidirectional map, like the BiMap from the Guava library). This would lead to code resembling this untested code: 

This has gone unanswered for a long time, and even though I haven't done any serious prolog coding, I would like to come with some general remarks which might be useful for you. Style wise I would add spaces after commas, to increase readability. Other than that it looks clean enough, but some comments on what the different parts does, wouldn't hurt. But my main point in this review is this: Device code structures after you have a need for it, and don't create structure first and then ask for a need of it. You've done it the other way around, which is kind of strange, but could be a good learning experience for you. Could it be useful for some cases? Who knows. In general, most likely not, as normally you have the use case first, and then code a solution to it. 

Avoid repetition of code It seems like you duplicate some of the code. When searching, deleting and inserting, you will use the same code to find your point of action. This can extracted into a separate method, and thus simplifying the other three. As a general note, if you keep copy-and-paste code, you need to reconsider if is not better to use a function instead! Single consern A neat principle to consider is the single concern principle, which states that a method/class/whatever should do only one thing, and do that well. In order to achieve this you would need to make more methods, and simplify the logic. Given that the logic is correct, a somewhat remodelled could become: 

This is a code review at a high level, as I'm a bit rusty on my java, and I don't have the time to go into detail, but I do have some comments to your code. Choose an indentation style In your code you have multiple indentation styles, and this makes your code harder to read and understand. At some point in time it will most likely cause errors as well. This was your code: 

Notice how you now can read the if statement directly as: if not previousWasWhitespace and currentIsWhiteSpace putchar. And this should be a goal, that the code should as readable as possible. On a side note, the if statement can be reversed into , but whilst still correct it is harder to read, so I prefer the first variation just because of readability. 

But the 2nd fastest version was using postfixing the string, a single function, and skipping the pairwise iteration, like in the following code: 

Translating my alternate implementation to yours with your definition of and I trust you'll manage. Note that within the method the coordinates needs to be in the first dimension, whilst the coordinates are in the second dimension. In other words, keep your head straight on when handling dimension indexes. Update: Changed to non-static methods, which purely was a result of laziness in my test setup based upon the method, and not proper object initialization. 

This would replace your , , and method. I also changed the to a simpler logic for checking whose turn it is, what to play, please enjoy: 

Your code as it stand is on the border of being off-topic as it is a stub, however since the following actually works and seems to do the job, I'm going to answer it: 

Whilst your code is a clever little trick to add useful details to an exception, there is one vital flaw as I see it, and that is you don't know where the exception was thrown. In the best code bases I've seen and worked with, there is always an unique exception message which you later on can use to locate where the specific exception was thrown. In mostly stable production code, exceptions should not occur very often, but if they occur two things are important when looking into it: 

Do be aware that this code review is making some assumptions, and might be a little overkill for something which you might just have thrown together to solve an immediate problem you had. However, becoming a robust and good programmer, starts by doing it right from the smallest through to the largest projects. 

This way your loop is clearly focused on getting a legal quantity, and breaks your when that has been achieved. Then it decides whether to add anything to the order or not. 

This file has only the intended changes. The latter option should be a better alternative for changing lines in a file, and should be quite efficient as well. A further optimisation, could be to remove already changed option from the dict after doing that line, but then again that could be unneccessary micro optimisation. The provided solutions reads and writes the file in one go, and only keeps one line of the file in memory (except internal cacheing). In most operating systems, this should be the better option for handling an arbitrarily sized file. (Earlier Windows version could loose some efficiency due to the almost simultaneously read and write to two different places/files at the same time.) 

Edited: My solution review was based on a misunderstanding of the problem statement. As a foreigner I confused multiple/multiply/multiplicand, and thought you had done the same. Your code does however return the binary looking decimal which is a multiple of \$N\$ as requested, and that renders my previous solution void, which found the factor you need to multiply to \$N\$ to get a binary looking decimal. The only comment I then have to your actual solution, is whether it is worth it to test whether the candidate is greater than \$N\$ before starting the modulo operation, but that has to be tested if it gives any significant speed increase. Most likely it is not worth it. Thanks to Barry for correcting me regarding my mistake on the solution review 

I've not commented upon the usage tests as I consider those test cases to illustrate usage of the cleanup variants. And they look nice enough, although I would probably use as a function, and introduce a little vertical spacing (with comments above instead of after code). Refactored code Here is my suggestion for : 

When all this is said and done, read the documentation or do searches like "python sum" or "python mean" before reinventing the wheel. 

Do read other answers as I will only comment on two subjects: Choice of combining functions and Exception catching. At end is a little untested code suggestion. Choice of combining functions Whether to combine two functions into one or not, depends on a multitude of factors, so a general answer is hard to give. However some pointers can be given. A function should primarily have one and only one concern or task. And this task it should perform well. In this case the task is to get the source of an url, which is a well defined task. However, if this were part of a larger library of url handling, then that task could be unclear as maybe many functions have that concern or task. A function could group related functions to form a better interface. It could be valid to do as you've done to have a common interface to getting URL's, but if you need to add loads of stuff to distinguish between them as parameter, then you are at a loss. I've seen code jamming many parameters into one function, and then having massive 's on differement parameters to distinguish which sub function to perform. That is not good. Another advantage of having a grouping function, could be to have common error handling. In your code you could make the within the and you could harvest those benefits. You could i.e. make it a loop trying different version for getting the url. Exception catching Related to error handling, it is generally considered bad advice to catch . Catch the most specific exception available. Locate what exceptions your sub functions raises and catch these. Maybe they raise something like . Also it is better to do stuff like instead of using commas. The behaviour of using commas here both makes it unclear, and will be addressed/depreceated in newer versions of Python. It is good advice to make unique exception messages so that it is easy to find again, even if your code project is several thousand or millions code lines. Using your good function name could be one way of making it unique. Remember that in the large project you never know where the exception might occur, so it's good being able to locate it. Another tidbit is to include vital parameters in exception message. Yet again, if your code base is large and you don't know where the exception is triggered it is wise to include enough information so that you are able to regenerate the exception in your test environment. Just having an "get_page_source failed" doesn't help anyone, but "get_page_source failed - url: Httttttttp::////does.it.fail/" clearly indicates why it failed. Code suggestion Maybe something like the following untested code would be my take on it: 

In addition to the excellent answer by SuperBiasedMan, I would like to make a small point regarding the use of vs another possibility , and precalculation of line numbers. vs Both cases creates a temporary list of the words in the line, due to , but there is a slight difference after that. Using will actually remove the 10th element of the list, change the index of all preceding list elements, and return the popped element. Using will simply give you the 10th element. It maybe a marginal performance issue, but additionally the index variation is somewhat easier to read and understand. While has it advantages, in this context it just seemed a little misplaced. Precalculation of condition parts In your code you are calculating the line numbers each and every time you hit the statements. However the calculation is a constant throughout your script. You could do something like the following at start of the script: 

This uses string.ascii_lowercase for the set of lowercase letters and a positional approach for rotating a letter a given approach. The methods could be extended using default parameters to allow for other characters sets, but that is left as an exercise to the reader. Furthermore I've presented two functions here one for rotating the entire string, and one for rotating a single character. These could have been combined, but I like the single responsibility principle of letting one function doing exactly one thing. Lastly I've kept the main logic from the original post, only embedded it into a , and added some extra information related to the output to display the various rotation offsets used for presenting the text. For even more various alternative implementation look at other posts here at Code Review tagged caesar-cipher (in a variety of languages). Both shorter and longer and simpler and more complex variation exists. 

Details as to why the exception occured, and this your code does good. You make it easy to provide good details to the exception. Where the exception occured, and this you seem to bypass. You only have a generic reference to which exception was thrown and possibly a somewhat unique combination of parameters. This will make it hard for you to locate your exception when your code base is getting larger 

This was tested using the original duplicated a few times to get a slightly larger set, but it does show that using the double loop like I did, is currently the faster solution, and it runs at about 33% faster than the original code, and the solution using is actually quite a bit slower.