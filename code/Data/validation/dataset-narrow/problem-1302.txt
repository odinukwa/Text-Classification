To add a puzzle like quality to this you need to generate some sort of dependency on the switch values (the door shouldn't really know about this, the switches should notify the door it can open.) I would use a parent object much like indeed005 is suggesting but with some important changes: 

This should help smooth out collisions and contact with the ground as opposed to a square based collider which will have the sharp edge to "bounce down" hills. Image courtesy of iPhone & Mac Development Blog 

Now Bobs first hat with 4 thrusters cannot reach its maximum speed at the NorthEast angle! What happened? Well as we have restricted our range of input to a circle we are not allowing x reaching 100 at the same time as y reaching 100. In the picture above you can see that bob has to move at 70 units x and 70 units y per meaning he cannot reach his max speed of 141. Even if we were to use Bobs second space ship that can only use one thruster then it has a value of 99 units speed NorthEast (using appropriate integer rounding) meaning his max speed isn't even accurate with his second magical hat. Well with the circular input we would have to change the way a pad reports to a computer in order to do this without a lot more maths than a simple Pythagoras theory and tan-1(x,y) function. Using the scaled directional values reported by the controller instead of the raw values means we don't restrict our selves with dead zones like we see in the green square of your diagram. If you were to use the blue circle values resulting from using raw values from the controller you could use polar coordinates instead, giving us the angle and the magnitude of input. However as it stands if you were to restrict yourselves to a circular input you would have to add in extra clamp functions to your x and y inputs from the controller to make it a range of -70 to 70 in order to do what we did with Bobs first magic hat taking us right back to this: 

The camera hierarchy goes like this: SmoothCamera extends -> ZoomCamera extends -> BoundCamera - Zoom cameras adopt Bound camera properties/methods. Smooth cameras adopt Zoom camera and Bound camera properties/methods Choosing a SmoothCamera you'll have all the functionality from the others. The difference between them is that they simply gain functionality depending on which you pick. BoundCamera can be free moving, the position can be set manually by yourself or can be bound to a particular sprite or object to follow the x,y coordinates of that object constantly. ZoomCamera is like BoundCamera, it can be freemoving, or follow an object but this time you can dynamically set the zoom level and make handlers to zoom in or out on the scene (You could add pinch to zoom functionality with this camera). SmoothCamera can zoom, free-move, follow and additionally have a speed setting that allows it to tween from one position to the next. So when following an object it will move smoothly from point a to b, not snap to the object constantly. These parameters are generally set in the constructor. I hope that makes it easier to understand. 

This then shows that if it crosses a grid line that the cells either side of this line are those that are filled. You can use an intersection algorithm to find if your floating point line will cross these by scaling your points to pixels. If you have a 1.0:1 ratio of floating coordinates:pixels then you're sorted and you can just translate it directly. Using the Line segment intersection algorithm you can check if your lower left line (1,7)(2,7) intersects with your line (1.3,6.2)(6.51,2.9). $URL$ Some translation from c to C# will be needed but you can get the idea from that paper. I'll put the code below in-case the link breaks. 

However, as a counter example a fighting game (great real life example being Street Fighter 4) may not need to reload all that many assets in order to restart a level. The 2 players, environment state for the level and simple level timers are mostly static and not dynamic (the players health will always respawn at 100% each round, timers reset to 90 seconds and the level has no bullet holes [or does it!]) and so resetting the level is a matter of putting the fighters to full health and putting the environment back to its original positions (like onlookers in some of the levels.) So for a fighting game when doing a rematch (not going from round to round) you need to: 

What you may be missing is the center point of the planets. The position may be a handle at the right of the planet (and so it is pushed off to the left.) Use the mesh itself to find the center point. As you have very low poly meshes on that example this shouldn't be any strain at all: 

So this sounds like a order of execution issue. If you're having a similar issue try organising your event listeners in an a different order. A huge tip for anyone starting with events, especially those related to drawing, get a piece or paper and write out the layers of your scene from the furthest background right up to your foreground effects sprites and put them in order. This should be the order that you draw them in and the opposite order for how you interact with them (mouse click, touch screen etc.) Good luck! 

I am building a very basic tower defence game in Unity3D where one tower is your standard long range mortar/artillery. I want the projectile it fires to follow a parabola curve to make its movement seem like a mortar. This movement is not dependant on any physics (as I can make a projectile follow a curve but I could implement the Unity3D physics if the method used would benefit from it. My question is: What technique should I use to ensure the projectile hits the locked unit whilst taking into account that the unit is moving along a possibly non linear path (defined with my A* implementation.) I have not implemented any code as of yet as I wanted to consult the masses for any wisdom you can provide! My initial idea was to fix the time the projectile would take along its parabola curve (regardless of distance) and try and track the position the unit would be at after this time delay. Is this along the right lines or are there alternative methods to consider when aiming a projectile that follows a curved path instead of a linear one? Thank you for your time. 

To answer this you need to think of the simple idea of what a controller needs to be capable of doing and why. 

Okay this a rough copy of your code from the other question but I would create a delegate to report the next point on the path to your CharacterControl components. Please note that this is completely untested and it will require your own tinkering to make sure it works in your project - such as the delegate reference to your AIPather component instance: First the AIPather: 

This allows you to make a series of switches with any degree of dependance: If you wanted you could make a series of switches in a linear formation: 

A simple reason is that a console has a single set of hardware that is the same per console. Your XBox, PS3 and Wii all have the same hardware as your neighbours XBox, PS3 and Wii. However your computer has a different CPU, different graphics card, different amount of RAM, in fact the whole configuration and Operating system settings, installed drivers could all be a completely unique permutation that no other person in the world has. This is what makes it difficult to port to a PC. You need to account for every possible piece of hardware within your minimum system requirements and above. That is a tricky and difficult process to program and debug. It is very hard for developers to know every configuration to program for and near impossible to run tests on these configurations. Once they develop it for PC there is extensive testing done in house by the devs but it also can be reliant on beta testing from users for upwards of a couple of weeks to a few months. This outsourcing of tests with beta players before the port to PC is officially released is typically why you see the gap on release dates between Consoles and PC. 

For a wall of any kind simply tag it as "Wall" and code it with this is mind when making collision detection on your main character. For a platform, guess what, tag it as "Platform". You can then implement a different collision behaviour for each object type using OnCollisionEnter: 

These could be represented as enums in your client and get transmitted to the server on a per score event basis. You just killed a zombie? Excellent take the zombies ID - apply the killed zombie event and send this packet of info to the server. The server then confirms the actions - keeps tally of the score and confirms this with the client side so it can display it. The zombie having an ID prevents your players from replicating any ID's they can't send Score_KillZombie on a zombie ID "10000000" that your server knows isn't there or already dead. They can also not reloot a zombie that your server flags as empty of loot. These situations go on and on but the important thing is that you give your server all the control on what actually is set in the game environment. Your client should simply tell the server what predefined event has happened and the server itself will decide if the client is lying or not (remember - it doesn't always have to listen to a client - that's where it weeds out any cheaters.) Pretty much any implementation of a web game that relies on interaction with a client-server model does this predefined event driven approach. FPS's tell the server when they have shot and in which direction - the server decides if it actually hit the player. MMO's tell the server who their target it is and what spell they want to cast - the server decides if they have enough mana and are in range to do so, reporting back if the target dies. Even Facebook apps will authenticate actions like in Marvel Avengers, sending a move and the target bad guy, the server will decide how much damage it did and what the bad guy does as a reaction. In conclusion Never let the client make any authoritative decisions. 

The information provided below is from $URL$ where you can find out more stuff like WASD triggers and multiple camera options, but the basics for the 3rd person setup is here: Setting up the Camera Object Underneath the "Create Camera" Button, you will see a white box with the value "Camera 001" in it, right click it and hit "Modify Properties". Set the values to the following (Name - Sub - Value - (Description)): 

And it can only go 100 units a second so we simply clamp the speed after putting Pythagoras' awesome theorem on that x and y: 

This is essentially how Peggle handle their slow down effect and trigger the end game music and is perfectly viable for using on your camera/rock/squishy pre-empting death-scene scenario. 

If you need to find out only when (and where) the line segments intersect, you can modify the function as follows: 

If its a 2D RPG then you are surprisingly more flexible than its 3D counterpart. If you are working with just simple sprites then you are only limited by your desire and skill to animate it. There won't be any right answer here as this is more a graphical design choice than a technical question or limitation - due to that I would recommend making this a wiki entry for "ideas for morphing" or similar. My idea would be to play on your games title and theme: Necro-Monster. Seeing as "necro" signifies the dead and corpses you could have the character sink into the floor or crouch into a black, death like mass (giving you a set starting point for all charater transformations to keep things simple). After a short pause they "uncrouch" into the monster shape. The monster form would then shake off the black-death mass material or it would simply fade or slide off depending on your desired graphical complexity. 

Notice the top one, ideal situation with your current setup. Bottom left is what can happen if your camera is rotated on it's Y axis slightly but you are tracking directly on x,y,z. Using the above should solve this issue but I believe this is the origin of the offset camera. 

If you are scaling a percentage this would be relative to the current zoom level. so it would be 0.2, then 0.16 and so on. This makes the mouse pointer be the focus point no matter the scale factor. 

Here is my two cents: All the work can be found on here too so you can run it and see how it works $URL$ Separate it into pieces and you can see how it'll work with a wee access expression after flattening the initial map array. Here is what I used to generate your map (at the moment it's square only but as long as your width and length are divisible by your chunk size you're fine): 

Which looks awfully familiar. And this is why we have square inputs on controllers that clip "half way" and raw inputs. We use the scaled ones to give ourselves a more flexible set of x and y values in development. 

It actually looks like you are already on the right track with your comments. Try changing your font initialisation to this: 

And that's the entire list essentially - meaning that a quick state reset instead of a full level reload is more feasible. This can also be shown by the loading time when you initially start the match. It takes a long time to load all the character and level models but only a few processor ticks to reset the character starting positions between matches with an already loaded model. It's important to note that this is also a more in demand requirement of fighting games as their players tend to want to get back in the action incredibly quickly as matches can typically only last a minute - emphasising that this answer is very much dependant on the game and genre. FPS's demand more dynamic assets while Fighters demand quick repeatable action. I hope this has shed some light on your question. 

In Unity when you import the objects make sure your import settings (available by selecting the object in your project view and revealing in the Inspector) are set to import the models textures. See if this helps. 

If your machine is unable to work with XNA currently there may be related issues down the line with MonoGame. It is always worth ironing out development environment installation issues first before starting on a project. Edit: As Josh mentioned in the comments - XNA has been abandoned. I had not actually realised myself, so although the example from XNA installer affecting MonoGame is not an issue in this case I still believe it is worth noting that install issues are something to clear up before project development commences.