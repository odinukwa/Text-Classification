If you're in it for the thrill of programming then you would probably not have many issues with an IT degree over a CS degree, as the places where you would find the best work environment wouldn't be the same places that would pass over you because you don't have a CS degree. At least I'm hoping that's the case when I graduate with my IT degree... 

This I have a problem with. You should build your bosses around what you think your players should be able to handle. You're building your players and combat formula around what you want your bosses to be like. Once you get your combat mechanics and roles built, then you can decide on how you want to design your bosses as it should be a good balance between the damage the players can deal/absorb vs what the boss can deal/absorb. 

I was reading an article about this topic on a blog by somebody who has studied Jesse Schell. Their philosophy concerning game is identify the "core mechanic" or "toy" that is fun to do in the game, and build everything else around that. Take minecraft for example. The "toy" that is fun to do in the game is making blocks explode and putting new ones in their place. If your game has its core mechanic down and playable, and most importantly, it's FUN then release and iterate. If not, then don't release until it is FUN. Again, considering minecraft, it had the bare essentials of the fun "toy" built so Notch released it. It's since sold over 1.8 million copies at 10 euro (or more) each. It's still barely in beta and a significant number of copies were sold in ALPHA. But it was fun. Keep your eye on the ball. An unfun game is a game that will go nowhere no matter how many years of development you put into it. =) 

It is not possible to directly use a multisampled texture. You have to resolve it to another texture (same format, same size) first. You can do that by binding the non-multisampled texture and blitting the multisampled one to it with glBlitFramebuffer (you might need to append EXT to function name - use glBlitFramebufferEXT - if you use OpenGL 2). 

Pitfall #1: overdesigned code. Think about whether you really need every thing you implement because you're going to have to live with it for quite some time. Pitfall #2: too many objects. I wouldn't use a system with too many objects (one for each type, subtype and whatever) because it just makes automated processing harder. In my opinion, it's much nicer to have each object control a certain feature set (as opposed to one feature). For example, making components for each bit of data included in rendering (texture component, shader component) is too divided - you'd usually need to have all those components together anyway, wouldn't you agree? Pitfall #3: too strict external control. Prefer changing names to shader/texture objects because objects can change with renderer/texture type/shader format/whatever. Names are simple identifiers - it's up to the renderer to decide what to make out of those. One day you might want to have materials instead of plain shaders (add shaders, textures and blend modes from data, for example). With a text-based interface, it's much easier to implement that. As for the renderer, it can be a simple interface that creates/destroys/maintains/renders objects created by components. The most primitive representation of it could be something like this: 

I made a really basic 2D RPG. I want to know whether I can turn it into a free to play MMO. I cannot afford to rent a server with enough capacity to serve a big number of players but I'm wondering whether I could get a hosting plan that starts cheap but scales enough to eventually handle a big numer of users so I have minimum fixed costs and I can cover expenses on the go with ads or whatever. Is there such a thing? Thanks 

I'm making a retro videogame, currently I'm using 32px x 32px tiles for the map and 64px x 32px for the characters. However the game looks extremely small, I could increase the tile size to something like 64px but it seems dumb since I would have to scale all the images (I don't care about adding more definition for the characters than this). So my question is, should I increase the tile sizes or do it in 32px and zoom/scale the images depending on screen size? Is this how games like Super Mario Bros. do it? 

I developed a simple game using the free version of Unity. I want to understand how much it would cost me to remove the Unity Splash Screen to know if it's worth it. Right now Unity professional edition costs $75 per month, does this mean I have to pay every month while the game is on the app store or can I pay just for the month I have to release the game so I remove the Unity Splash Screen and that's all (provided I don't need to update the game later)? 

Since is valid in constructor but not in , it seems that the destructor was called before , perhaps by copying an instance of the class. P.S. Errors like these could be prevented by following the Rule of three. 

Those models look extremely detailed. If this was done with subdivision, it would not be too hard to step over the 65536 vertex limit (I'm guessing that the game could be using 16-bit vertex indices for these models). It only takes a grid of 256x256 vertices to be right on the limit, 8 subdivision levels on a quad would go over it. 

Use same animation for both characters programmatically - one of the characters will need dynamic bone remapping to get properly animated - it's doable but might be technically confusing; Combine characters into one mesh - all combinations will have to be exported separately, lots of storage space waste; Use same animation for both characters with static bone renaming, basically a mix of previous two techniques, probably most complicated. 

It's mostly legacy from the times when all that could've been made with 3D was some screen-space rotating cube or parallax scrolling or something similar. In such applications, Z was "depth" because X and Y were the axes for the screen plane. As demos were getting more advanced, the original conventions stayed because it's easier not to change anything that works. As for why exactly today's games have Y as the vertical axis - there are lots of poorly written tutorials out there that do not explain the difference. Usually it's most useful to have the primary movement plane on X and Y axes (so that most 2D calculations don't require swapping axes in code). For most sidescrollers, it is quite naturally coincident to the screen plane (X/Y). For adventure games and such, X/Y works nice as the horizontal plane (perpendicular to direction of gravity) because it maps perfectly to in-game maps, gamepad controls, terrain heightmaps and many other things. 

Yes, it is quite usable and I'm developing a game myself on the platform. However, the limitation is you have to choose between HTTP requests or XMPP somehow. I'm going the HTTP route personally. Most games use some form of secure socket connections from the server to the client, so for that kind of setup you need a dedicated server running your software, but if you can set it up as a web service or website then you'll be fine. 

Find your OWN need that wants to be filled. My personal game idea is something that I've searched high and low for, but I've not been able to find a great game to fill that void. Because I also have fairly typical interests, I get encouraged by the fact that my game will likely not fail. That it's something I really really want to play helps me keep motivated too. Minecraft (seems to by my favorite example these days) was built because Notch noticed a void that needed to be filled. He filled it and is now a multimillionaire. Find something missing and build that. It's the best reason for building a game ever. =) 

I know this question has already been answered, but especially with the recent release of the elastic beanstalk, Amazon's Web Services are another alternative. 

The best advice that I've ever seen is to SHARE your ideas. Game companies with the resources to steal your game idea are more unlikely to steal it the more original it is simply because your idea isn't proven. The more you share it and keep people updated on the progress the more likely it is that you'll find people who are also interested and will help you build it, even if it's just by letting you bounce your ideas off them. You can not work in a vacuum. Get your idea out as fast as possible and get feedback as early as possible. If you're talking the 3D type WoW MMO that everybody seems to think they can improve then you'll need a team of 40+ people to start, including highly experienced game logic programmers/designers, graphic designers, network admins, testers, etc. It's far from a small or casual undertaking. Start with a very light skinned down version of your game that you can make yourself and develop it from there. Use open source libraries and resources as much as possible so you're not reinventing the wheel at every turn. If you start to make it big then you'll be able to afford rebuilding your standin work, but if you spend 50 weeks making all the different kinds of plants you need, and that puts you only 20% of the way done with a beta launch, then you'll get nowhere in a hurry because you'll lose all your inertia. 

What you should optimize for is probably best shown in and around slide 40 of this presentation: $URL$ The idea is to prevent the code from doing wasteful things with the CPU. Loading memory and then throwing it away is rather wasteful. So, naturally, you can reorder data to make better use of it. If you see a commonly used function that uses a certain set of variables, you'll want to make sure that they can be loaded on as little cache lines as possible by putting them close together and aligning them properly in memory. With sufficiently complicated physics engines (ignoring fixed size particle system solvers), given that bodies contain lots of data and are rarely accessed sequentially, there aren't too many other optimizations to perform. 

If all of these are true, you have an intersection. At this point partition structures (like AABB trees) are not necessary at all. You might only want to start thinking about them when test count goes over 10 000, which is when you need to test about >140 AABBs. Best to avoid using the broadphase for as long as you can because it will introduce a lot of complexity and hard choices and measurements. Not one of them is going to give a good speed improvement without serious workload and staying within special constraints with your AABBs. 

Create something that the player wouldn't want to happen. Show it happening in a harmless setting (cutscene is allowed, can happen to other characters). Create a situation where it is obvious that the player will experience the undesirable outcome unless he acts soon. 

I'm new to C++ and as a college proyect I'm building a 2D platformer with some classmates, I recently read that it's a good idea to have a stack of gamestates instead of a single global variable with the game state (which is what I have now) but I'm not sure how to do it. Currently this is my implementation: 

I read that most servers handle more than 50 requests per second. Is this true? how many requests can a normal server handle? How do MMOG manage requests having to update player actions instantly? 

Then I have a global variable of type GameState: GameState *currentState = NULL; And in my Main I define the currentState and call it's methods: 

Right now I have a class called Obj from where enemies, items and the player are child classes, my idea is to add 3 public variables to it like this: 

I could also add invisible "Obj" in specific places for when a player walks over a certain place. I don't know if this is a good idea but I can't think of other means to do it. How is it commonly done? Also how do I keep track of events that already happened? 

Then I could create an Obj with eventDeath=1 and when it died it would fire event(1). event() would be something like this: 

I'm building a game in C++ (using SDL) for a college project, I'm trying to figure out how to script events that happens when a player does something, or some time passes etc. I have a and idea of how to do it but I don't want to go against how it's commonly done. 

I'm writing up a design document for a voxel based adventure game, similar to minecraft, but fixing a lot of fundamentally broken game mechanics, or at least updating those mechanics to be more suited to an adventure game. I'm considering creating a weapon scale from 1-10, where weapons at 1 are least powerful, and weapons at 10 are most powerful. I was considering making the materials to make the weapon most common for the level 1 weapons, and 10x less common for the most powerful weapon, but if you look at minecraft, diamonds only occur in 0.1% of blocks and they still feel too common, unless you're prone to dying of course. In keeping with the adventure focus, would it be better to have the higher tiers of weapons only come from monster drops, or from a combination of a rare monster drop and a mineable item, or are there other common game mechanics I could use to have a super powerful weapon that's also hard to get, but worth your time to get? To state the question another way, for the time investment, should a weapon that's 10x as powerful take 10x as long to obtain, or 20x or higher? Are there any studies that show any correlation between "fun" in how long players will grind for an item and an appropriate time investment scale for obtaining equipment? 

If I had to guess the biggest reason that the game you played runs so slow is not that it's a game maker game, but that game maker markets itself specifically to non-programmers. Because you have non programmers making games it's highly likely that the game in question uses some very inefficient algorithms that cause it to run slow. As in most cases, the speed of the language will only lightly affect the overall performance of the program. When people say "omg this language is 50% slower than this other language" and the speed is still stupid fast in both cases then you'll find little to no discernible difference to the end user. 

You can make a new interface function that is called whenever UI/HUD is drawn and allow custom/scripted components to implement that function. This requires an IMGUI system (there are lots of tutorials on it in Google, this is just the original presentation) to be used. With that, you can make windows as entities inside which you'll have your own UI-building component and a window frame renderer component. As for not processing all of this every frame, you can render all UI to a different buffer which you'll update only on all kinds of input / data events. That is, whenever an event is received, it changes some variable to indicate that the window needs to be repainted the next frame. If that variable is true, it is then set to false and UI interfaces are called after that. If you want animations, it's important that you use this exact order of operations so that UI itself could trigger a repaint for the next frame. 

Many possible reasons why something would not be rendered but if the difference is only in the matrix, here's some that I think might be most likely: 

That's not the way to approach DOD. That's just the C syntax of object-oriented code. DOD means thinking about data before writing your code. OOP is often (but not always) the other way around. Example: You're going to have 10000 visible, colliding particle objects in your game. OOP: I'll start by making a Particle class. Each particle will have a "collide" function. Just so it integrates in the world, each particle will be an Entity too. The Collide function will be virtual because Entity has an abstract virtual Collide function. The Render function will be similarly designed. DOD: Since we've got a lot of particles, it would make sense to store them closely together to minimize the time it takes to process them. There will be a collision processing function that handles all particles at once and can be optimized in any way, if necessary. To further optimize memory access, particle data will be separated into rendering, physics and common data arrays, depending on the actual data that is used. If particle count is going to be increased, these things will be considered: reducing size of color data, making some of the variable equal or at least non-integrated (curves/equations) for all particles (allowing to remove them from data). Obviously DOD takes a lot more time and thinking. How much it's worth depends on the project. These days, when everything is calculated in one library or another, it might not matter much. But if you want to make something truly impressive, it's basically DOD-way or the highway.