The short answer is no. As others have said, there are no DC connections from the Ethernet jack. However if you are ready to make up your own cable, I believe it can be done. First you'll need a PoE (power over Ethernet) device - because your regular Ethernet switch or modem most likely won't be sending 5v over the Ethernet cable. I have set up PoE for an Arduino, but since PoE shields are available for the Arduino, that's not too hard. I used a PoE device from Freetronics, that cost me about $30 NZ. It has a DC input, which i connected to a wall wart. Then connect a regular Ethernet cable from the router/switch to the PoE device. Also a cable with all cores connected to the other side of the PoE device. The other end of this cable goes to an Ethernet plug, but this only uses the regular 6 wires. The other cores will take power from the PoE device and these would have to be routed into the Pi. You might be able to route them to the Pi's GPIO and so power the Pi through GPIO or you may be better off grafting a micro USB plug on the wires and using that to power the Pi. The PoE device takes a power input and routes this through the Ethernet cable. It also passes the Ethernet data straight through from the switch/router. 

I have a script named upload_picture in one of my folders and I invoke this when a picture is ready to be saved. My etc/motion/motion.conf file has a line almost identical to yours. Mine reads: on_picture_save /home/derek/webcam/upload_picture my upload_picture script is quite simple. It sleeps 10 then uses wput to FTP the image to a web-site I don't have an on_motion_detected setting, but looking here It seems the format is the same for the two options. So I'd check that your script is actually being called. And I'd do that by including an echo "Running" > /tmp/foo line to the script. Also make sure whatever account is running motion has access to run the script, and probably that it has a shebang at the top (#!/bin/sh). When you change motion/conf you would probably want to restart motion and the link I copied explains that. Another thing you could try is at the end of the on_motion_detected line put >/tmp/motion.log 2>&1 which will record output from your script to a log file 

You may have already checked, but make sure you have your LEDs the right way round. Short wire = negative, or if you've trimmed the wire to be the same length, there's also a flat edge to the LED on the negative side. Next thing, be sure you have connected the jumpers to the right connectors. I've wasted time looking for software errors when I actually just missed the breadboard connector by one row. You could try swapping, say your connectors for pins 13 and 16 to make sure the On/Off parts of your circuit are wired properly. 

Firstly, I must say that I have not tried this, but I have an app on github that includes code to get data from the BMP085. It's part of a weather station receiver app that I put together - largely using other people's work. Kevin Sangalee (who has done a lot of work on weather stations) had written a file bmp085.c which I included in my app. I don't have this component so the code is just ifdef'ed out on my app. You might get some help from the code, which is in C. You can find my git repo at $URL$ 

I'd backup the suggestions so far. The most likely point of failure would be the SD card. My own experience is that the SD card is fairly fragile. I had a power outage for just a second (New Zealand's electricity network is not that great even in the main cities!) and though the Pi would be able to restart after a power outage, in my case the SD cards failed dramatically. I had two Pis crash and get corrupted SD cards - I had to re-install the OS. My 3rd was able to pick itself up and reboot OK. Of the two that failed one had such a badly corrupted card that I was not able to put a operating system on it, it ended in the bin. For a permanent fixture, you should consider that the power is likely to go off and come on without warning. Make sure your app will start automatically on boot. Also look at avoiding writing to the SD card - which will wear the card out (albeit very slowly). I'd imagine that an art installation wouldn't need to write to files or anything, but if it did then look at having your files in /tmp, which should be in RAM not on the SD card. You might consider ways of including a backup power supply. Perhaps solar cells or LiPo batteries. Another approach would be to think about redundancy. Would your project be able to use two Pis, one that would cut in if the other failed? It could greatly complicate your project but for mission critical applications, that's a standard approach. Sorry I've not included any actual figures as you have looked for, but maybe there's some information here that could help you think round the problem. 

On desktop computers, I can do all these steps remotely, by installing both Kali and Linux on the same computer, and changing boot options via GRUB. Is there anything similar on RaspBerry? Answers for any couple of operating systems accepted, yet Ubuntu/Kali couple preferred. Some info about the partition structure of the SD card would be fine (one partition for everything? one for boot and another for the operating systems? one for each operating systems?). 

The usual place for Ubuntu and Kali seems to be , for what I have tested until now (the image file creates the system root there). Is it possible to install some Linux distribution on or move it from after installed? Generic any-Linux answers are preferred. If not possible, I would go for Ubuntu, as it is a very popular distro. Additional points: 

What could I do to make besside-ng work? It seems to be a part of the AirCarck-NG suite, so I can not install it separately. 

By using this method, the 2GB root partition extracted from the .img Ubuntu file can be expanded to the full size of my, say, 32GB SD card. Is it possible to revert this step to shrink the, say, 32GB root filesystem size, to something smaller like, say, 4GB (assuming, of course, that filesystem has no more than that 4GB data full)? 

Finally found on the GUI: Welcome --> Info about RaspBerry Pi : the core must, indeed, be updated using instead of . Here is a capture (sorry, my Ubuntu is in spanish, but I think the sense is understood): 

What is wrong here? Any missing library that can be fixed? Is this some fatal error telling it is not possible to compile this source for Raspberry? Or generic Linux sources can never be compiled on Raspberry? Do I need something like an appropriate guide to follow for this task? Additional Points: 

I am running Ubuntu v16.04.3 LTS Xenial, and, after much researching, I have found a missing kernel option that I do need: 

I have compiled source codes some times for some Linux programs, so I was wondering if it could be done too for Raspberry. I have a Raspberry Pi 2 running Ubuntu v14.04.2 LTS. I don't know if the compiling procedure is generic for any (or most) programs, so I have decided to try with a rather simple one: PeerVPN, a simple tool that creates a new virtual interface device connected to some server. Here is the source code. But when trying to compile, I get: 

This option seems to be disabled, and I need to enable it, so I assume I must recompile the kernel. Is the recompiling kernel method the same that should be used on Ubuntu for desktop computers, so I could use these general instructions? Or maybe the RaspBerry way is different? What exactly differs? NOTE: Suggestions for any other methods different from compiling, if they exist, are welcome too. 

As long as you request "programmatically make my code target the right device each time", I suggest you to activate predictable network names: 

I have installed Ubuntu Linux 14.04.2LTS from official WiKi and added AirCrack-NG (for wireless auditing) suite by following official docs too (the official package was obsolete). But now I am not able to find the program: 

Using another SD card, I have then installed Kali Linux for RaspBerry, and this one seems to have besside-ng inside: 

I have not been able to find any list of Linux distros accepted by , nor that compatibility detail on the Ubuntu website. Can I use on Ubuntu Mate? Is it safe? Reason for doing this: Indeed, the package (updated by ) installs a new kernel, but it seems a bit outdated (v4.4.38-v7+ #938). The tool installs a more recent one (v4.9.53-v7+ #1040), even when it is not the last existing one that the Ubuntu Desktop version runs on PC (v4.10.0-37). 

Short answer: it is just a peculiarity on latest versions. Alternatively you could also use and . Extracted from this thread at AskUbuntu: 

Short question: Is there any way to have more than one operating system on the same SD Card of my RaspBerry Pi 2 and remotely boot from one to another? Long question: I access my RaspBerry Pi 2 remotely via SSH. It have no keyboard nor screen, and uses to be permanently ON. I use to work with Ubuntu and Kali, each on a different SD card. So, when I want to boot from one to the other, I have to: 

I have tried copying the file from Kali to Ubuntu, but, even when the program starts, it seems not to behave all right: 

More details and several workarounds (if those ram disks on screen annoys you) on the above mentioned thread. 

Upgrading the RAM is, as you have said, not possible. You also cannot upgrade the GPU or the Broadcomm CPU. If you want to upgrade the SD card, you simply buy a new SD card and re-install the operating system. You can even backup an existing card, burn that backup image to your new card and then expand the space to fill the card (using raspi-config). A list of known SD cards that work is on the Wiki at eLinux Maximum size currently reported to work is 64GB. You can use a powered USB hub to expand the number of USB ports. A list of the hubs known to work are also on the Wiki at eLinux. A powered USB hub will allow you to add additional storage space via a USB pen drive or USB portable hard drive. 

Use Python. Use the RPi.GPIO library to detect button presses. Issue system commands to run omxplayer depending on which button is pressed. 

You could start out with something simple like a GPIO breakout board, for instance the BerryClip from Raspberry Pi Spy ($URL$ which will show you the kinds of things you can do and will introduce you to programming. If you want to try something slightly more advanced, there's an interesting tutorial here which goes into a fair amount of detail: $URL$ When you have further specific questions about GPIO, feel free to post them to Stack Exchange. 

Try a more powerful power supply. Keyboard repeats generally indicate a lack of power is being provided to the Pi. 

Both Pin 2 and Pin 4 produce 5V so this is expected. Pin 4 was labelled DNC to start with, but it's always been a 5V pin, just an undocumented one. 

You might want to look at Andrew Mulholland's work on Raspi-LTSP which uses a centralised controller for multiple Pis. It essentially uses the Pi as clients to connect to the central 'server' which can be a laptop or desktop machine. $URL$ 

To get lighting inside your case, you're going to need an LED, a resistor and some wires to connect it together. Your main restricting factor will be the amount of space left inside the case once you've put the Pi in. Doing any sort of breadboarding is not going to be an option as the board itself takes up a great deal of room - even the smallest size breadboard is going to be too thick, plus the wires will project out of your GPIO pins too high. About the only option you've got for doing it yourself would be to solder wires directly onto the GPIO pins, add an inline resistor and then the LED. If the PiGlow is too expensive for you, can I recommend the LEDBorg? $URL$ 

As you can see from the picture, it allows you to drive 2 DC motors (bottom right) and has outputs (left) that you can configure as servo outputs. There are also a number of inputs (which can take both digital and analog signals. You can get it from 4tronix or The Pi Hut. I reviewed the Picon Zero over on my blog. 

There are a few out there. The one that I like is by NeonHorizon (Daniel Bull) and is called BerryIO. You can download it from GitHub. 

In newer distributions, Java is already installed so you might find you already have it. If all else fails, try: 

Which should redirect your output to a log file. If this doesn't work, you'll need to add some logging to your program. Take a look here for help on file operations 

If you've already halted the system using the button in XBMC, pulling the power cable out and re-inserting is still the easiest way to power on the Pi. It's not great, but it is quick. 

There are two ways you might do this. First of all, the simplest: Use two Raspberry Pis and connect them to a wireless network. Secondly, you could use Arduinos with RF wireless transmitters and a receiver on the Raspberry Pi. Take a look at the RasWIK (Wireless Inventors Kit - $URL$ from Ciseco. It gives you an Arduino with built-in wireless capability and a GPIO plug-in board for the Pi allowing wireless communication between the two of them. Not sure how you'd do it for multiple sensors, but that's part of the fun. 

In terms of remote control, you've got a few options. You could SSH into the Pi and control it via the command line. You could install VNC on the Pi and then use a client on another computer to connect to it that way. Alternatively, you could use a bluetooth dongle and pair up a Wii remote, PS3 controller or anything else that uses the bluetooth protocol. There are a variety of tutorials available online for all of them, so let us know if any of those take your fancy :-)