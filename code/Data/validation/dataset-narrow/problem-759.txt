You can replace the test against string with functions that just check those values then this simplifies to 

The delay can for example be added to the animation struct so animations can have different timings. A special value of 0 can mean not animated. 

and don't do anything with the T passed in. also leaks 2 of the created nodes. In fact a lot of functions have a that gets overwritten immediately. This is a horrible leak. If you need to init the value prefer . 

Don't make member fields const. This creates issues when you go and copy an object. Just drop the const on the fields and instead pass const ref around if something needs a view. You make a very strict statement about indentation (spaces only and 4 at a time) and whitespace. Instead you can follow python's scheme: if new line is longer then prefix must be exactly equal to the previous line's indentation (push current to stack). If shorter then look backwards in the indentation stack until you find a match and pop until that point. Number of indentation tokens is equal to the size of the stack. You don't have any way to express escaped characters in your string literals. Is would also consider adding offsets in the line for each token. Having error into down to the proper token is much easier for the user than only the line. especially when they go for obtuse one-liners. 

You don't need to build the object in one go instead create what all cases need and then optionally add: 

You use unsigned as your data storage you should instead use bool, is specialized to use a bit vector for more efficient storage. Initialization of the field can happen in just 2 calls: 

The only feature you use from is its cancel ability, so you can just declare it as a . Then you can keep the class as a static inner class of . Conversely you can declare as a and also keep as a static inner class. 

You use a busy loop for a timeout. There is a better method with javax.swing.Timer. This removes the need for and the thread. 

You can loop and count the characters until isn't or the remaining length is equal to the desired length and then take the to return 

you shouldn't be using an infinite loop and sleep in a gui, instead use the timer functionality of FLTK using and 

First you pass the vector back by pointer which is not recommended, instead just pass it back by value and the compiler will optimize it to a move. Similarly no need to use pointers in tuples to return the data from creation. Also A* and dijkstra are very similar in fact dijkstra is A* where the heuristic function is always 0. So most of the code could be reused. 

Once you get under a second for whole process execution it's better to start timing inside the program using a accurate timestamp function. This avoids the C runtime initialization and printing from dominating the measurement. One suggestion I had was keeping a so you can easily grab a new node by doing 

Erasing the individual means moving everyone that comes after. If you don't care about order then do a swap with back: 

Not much to remark on. Beside some lack of documentation about which thread each function is expected to run in. You can also do incremental append as you are reading to let the user see you are still doing something in case the file is really massive or slow to read: 

However you look up every werknemer a lot based on the ID. You should use a instead which includes methods to check if a key is already used and a way to get the object back with the key: 

Note the comp helper function. I added that so you can easily make it use a custom passed in during construction. This can be easily expanded to also keep a list of nodes to update should you want to insert/delete a value: 

Prefer making explicit functions instead of macros. They are more easily debuggable and compilers like to inline such short functions anyway. 

the first issue I see is that is not thread safe. Instead use an AtomicInteger second is that the thread gets into a spin lock when it is awake and it's not its turn. the solution to this is to do: 

An executor service will be able to do a with a timeout and return a set of futures holding all the values or return when the timeout expires. This means that your should take a set of keys and build all the tasks from those at once and then submit the tasks as a batch: 

You'll note I added to various points in each pattern, This lets you ignore the whitespace that may surround the operators. The in a Pattern means a word character. If you only want alphanumeric +undescore then you'llneed to replace each instance of it with 

Here the dll is the one doing all the allocations and calling code queries the pointer only to access the elements. 

As for synchronizing if you only needed the consumers to run once you could have used a but that cannot be reset. So you'll have to use a . With a cyclic barrier you can make the producer the Runnable that gets invoked when the last thread calls its . Then you can be sure all but one consumer threads are waiting for the producer code to finish. 

However instead of a series of flags you can instead use an enum to specify what type it is. This lets you use a switch instead of the nested if-else you currently have. This is also a solution for the duplicate code; create a single static public function that returns said enum. Your view creation requires that the button list is in a particular order. As is you can update it by using a for loop: 

\$i, j, k\$ all have to be distinct because the characters they refer to must be different so you can save a few test and iterations there. 

This creates an associative array so if you give it a key value then you can get out the associated value. in your case that is done like: 

In you don't actually use the first parameter . Instead you default to always. The field is a path and everywhere you use it (except in one of the calls where it doesn't have any effect) you use it as such; so you may as well store it as a and make it clear. This lets you avoid the vs and use the constructor that always works: 

When looping over all primes you can make use of the previous primes you have found to skip the non-primes. This can be done using the for example sieve of Eratosthenes. 

You can use a single match of a Pattern to find both the leading values and the string inside the parenthesis: 

I see that your function actually does 2 things, computes the ranks and computes 2 averages (one filtered and one not) and the computing effort of the ranks is not reused for the averages. It may be more advantageous to split them out into their own functions. 

This immediately say "this function returns a empty string or a string with a space depending on this condition". 

You can't really help the constructor but you just need to make the destructor of virtual and let it do the closing: 

In other words you can just use the angle to select the offsets you need to check and then check the board based on the offsets. 

Looking at the use case (calling it for every index in an array) it would pay to SIMD the function if your cpu supports double precision vector math (modern cpus almost certainly do). This will mean using intrinsics for the math which will be less clear code but will probably be faster. 

doing is very odd to see and very much prone to mistakes in writing or reading. It's better to use negation in the condition: 

After some research I found that it's slightly more efficient to get the half quaternion directly from the double quaternion: 

On that note I suggest renaming to and remove the from it. Some added functionality for it would be adopting a locked lock, relinquishing a locked lock (without unlocking it). I also expect (from experience with such in C++) that creating one will automatically lock the lock for you. There is generally an overload for when you don't want that: 

There is no need for the FutureTask, the executor service will create a future that you can use to wait on the task and get the result (if any). 

When implementing the standard collection classes take a look at java.util.AbstractSequentialList. It implements everything based on the and methods. You only need to override the others when you can implement them much more efficiently than what can be done using those two. 

However why the enum in the first place? You can simply parse the string as an int with and use the return value directly. 

You don't need the s to see if \$s[i] = “a”\$ you only need to do . If you really want to minimize the time it takes then dumping it into a would be best. Something to note is that you can square s much faster doing the simple multiply with self method than convert to and use call . Also the square root of a square is the same as the original number. 

This will create a lot of namespace collisions. Writing where you need to isn't that awful. You have a destructor so you should also create copy and move constructors and copy and move assign overloads so you follow rule of 5. Your create node makes extra copy when it doesn't need to. Also let the store value be initialized in place: 

Depending on how many types of items you will have and how many items will be live at any one time it may pay to use the flyweight pattern. Where each item stack has a pointer to an item type which holds all the behavior, and hold the data that makes the stack unique and/or is used very often (how many items in the stack, id for the sprite to draw, ...). Making the objects fixed size (with a pointer when the you need that extra storage space) will let you make an inventory hold a instead of a . The first will have much better performance when iterating over all items in an inventory. Hold by value what you can and use as few pointers as possible for the rest. I'm not a fan of complex inheritance trees, either you need a virtual function in the base class anyway or you need s all over the place. as a tag type is a pretty bad way of making something stackable. You will need to to find out whether it can stack and the stackable items may each have a different max stacksize that you then need to query. So just create a single in the base class of the item type. 

consider also adding a moveable push that you can call with Your doesn't, looks like a typo during debugging: 

Add a buffer length parameter and then use to avoid overflow. Your testing code hides the usage of the function. It's clearer to put it on a separate line: 

Then you can pass an instance of that filled with the field specific comparers to the method of . The doesn't need to hold the string value of the field to compare but instead a Comparer (or a mapping function). Ortherwise you can build a and then you can get the comparer directly from the map. 

You force the user code to pass in a vector as the raw data. This is not always how data is read in. Provide an overload that takes in a begin and end pair of char* iterators and forward the vector overload to that. is faster than scanning for a null byte. So consider changing the format to use a prefix length instead of the null terminator. If the format is fixed then you will want to add the values of the enums explicitly. That way they don't depend on the declaration order and it's clear that that the values are chosen for a reason. Exceptions are frankly fine, one thing I see is that you only throw an exception where more data can create a correct parse (either directly or by adding a null terminator). So you can add the remaining unparsed tokens to the last DATA token. That way you can partially parse the data and resume parsing when more data comes in. 

I would make it clearer that you are looking at a single array that is split in the middle in the parameters. Instead of pre-filling the result vector you can reserve it and push back the values. The value type of the iterator can be discovered by using . The reserve is not strictly necessary but it will avoid reallocations that aren't needed. 

You can gain some efficiency by wrapping the writer in a BufferedWriter. If you are using java 7 or better you should use try-with-resources to auto close the writer, otherwise you should use a try-finally: 

Your Big O interpretation is a bit flawed, This is only O(n) per recursion step (single loop with every operation in the loop being O(1)) leading to the normal O(n log n). The first optimization you can do is 

As an aesthetic point you can be a bit more frugal with the whitespace. Too much whitespace spreads out the relevant details too much which can make it harder to read. 

Having a print method interacting with the console is not a good idea. What if you want to show the contents in a gui instead? Instead add iterators to be able to inspect what is on the stack without having to capture the output that generates. 

but this has a race condition (turn changed after the test but before the wait->the changing thread has already called and deadlock occurs. (This is the reason why wait and notify have to be in the synchronized blocks) This means that you need to synchronize the testing and the changing of turn, but if we do this then we don't need a special class but a normal will suffice: 

That can also be used for , speaking of recursion isn't the best way to describe looping until you find something instead prefer an explicit loop: 

There is a danger for an infinite loop. If calls and handling that object also causes to get called etc. then run will never return to the EDT. You can fix this by using 2 queues; one for aggregation and one for handling the current set and swapping them when entering . This also fixes the race as when setObject is called while some are being handled then they get pushed to a new queue and the run gets scheduled again. 

Speaking of sizes the size of the standard primitives are not guaranteed to be exactly the same on all platforms ( being a particular pain). Instead use the integer types from . 

Violation of rule of 0/3/5, if you implement the destructor you must also provide the copy constructor and copy assign (plus optionally the move constructor and move assign). Speaking of move, there is no advantage taken of move semantics. You can add a const variant to the subscript overload: 

"dynamic array of Rectangles" should translate into . If you don't and use a pointer then you need to take responsibility of cleanup and following the rule of 0/3/5 as needed. As is you had a leak in your destuctor because you didn't delete the individual s in the array of pointers. 

This is a bad habit and not one you really want to develop. It leads to various naming conflicts that can be a pain to deal with. Typing every so often isn't that big of a pain. 

You make a function and then you don't use it in the first method following it; probably an oversight. You should make const versions of your and besides the non-const versions (the idea is that all non-mutating operations should be doable with a const tree): 

This will still create a lot of new partially solved boards but if you add a to then you can reuse the original board and only need to clone it when returning it in the singleton: . 

In general your comments say what the code does. I don't recommend commenting like that, because sooner or later they will get out of date. It is better to say why things are implemented the way they are (and just don't comment when it is obvious). You can remove the annotations in by properly using the generics: 

This way there is only 1 point where you need to handle the exception at the cost of an extra indentation level. 

note: I use underscores in the hexadecimal literals to make it clearer (they are legal in java 7 I believe) however in java 6 you will need to remove them. 

Keep the updates queue as a ; you don't care exactly what it is only that it's thread safe. is kinda cryptic as a function name especially as it doesn't actually set any object. I suggest instead. 

You should move the actual dijkstra algorithm out of the main function and create a new one that returns the path. your code to erase a found vertex from is flawed. it is as simple as: