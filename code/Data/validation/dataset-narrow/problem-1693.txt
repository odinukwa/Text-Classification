See /boot/overlays/README for details. Recent Pi kernels directly support software bit banging of I2C on any spare GPIO with device tree. 

Python may not be the best choice if you have high or sustained data rates. You would be much better off using C. Try the following Python. It should capture all the interrupts although if you have sustained high interrupt rates it may take time for them all to be processed. 

The DS18B20 is a digital sensor using the Dallas 1-wire protocol. If you just want to get figures to play with you could, as you say, connect an ADC and twiddle a pot. However a simpler, and perhaps more useful, source of data is the SOC (System on a Chip) temperature. The following C snippet will print the SOC temperature. 

The Raspberry Pi is a computer, just like your PC. The mini-USB cable will provide power. You need to login to the Pi via the network cable. Perhaps use putty or similar to connect to the network machine called raspberrypi? The default login name will be pi and the default password will be raspberry. 

Q3. The weighting says how much to consider the old RPM when a new RPM is available. The default 0.0 says to ignore the old reading. Try using values between 0.0. and 1.0 to see the smoothing effect. Instantiate with 

The sysfs kernel interface to the GPIO has limited capability. See $URL$ for details. Broadly speaking you can set a GPIO to be an input or an output. For an output you can set the level high or low. For an input you can read the level and request to be interrupted at a particular edge transition. You would use such C language calls as poll to respond to kernel GPIO interrupts. 

Other suitable libraries are servoblaster and the RPIO.GPIO Python module (note, not the similarly named RPi.GPIO). 

A Reverse DNS service can't resolve that address so you'd have to assume the worst. Have you changed the pi password to a decent long (16+ characters) password with a mixture of symbols? 

I would assume it's JavaScript as node.js is " an open source, cross-platform runtime environment for server-side and networking applications. Node.js applications are written in JavaScript, and can be run within the Node.js runtime on OS X, Microsoft Windows, Linux and FreeBSD." 

A gpio set as an input will float randomly between high and low until it is actively driven. There are internal pull-ups and pull-downs for each gpio which you can select with software. The value is about 50k ohm which will easily be overridden by an external source. 

The simplest, fastest, and probably most reliable connection would be a point-to-point Ethernet cable. Alternatively a serial to USB dongle. The serial end could be on the Pi from the UART (pins 8/10) or on the PC end with a suitable RS232 adapter. 

That appears to be an ancient instructable for the Pi, perhaps from 2013, which is an age in Pi terms. The command seems to be associated with the kernel module version of servoblaster which I doubt anyone actually uses any more. You should probably be installing the user daemon version of servoblaster. Both versions are available at $URL$ For instructions search half way down the README.txt for . 

Have a look through this raspberrypi.org post which seems to offer a working solution or at least a start point. If you can program there are many Python examples which should be easily portable to Java, e.g. my $URL$ 

BCM2835 ARM Peripherals page 102 is probably the place to start. I'm surprised that SPI CEx is confusing. SPI is a well known protocol available on many microprocessors including PICs and Atmels. CE (chip enable) is a synonym for SS (slave select). GCLK (general clock) generate a general purpose clock (square wave of user defined frequency). 

If you don't use global within the function the assignment will be to a local variable. Annoyingly if you only read from a variable in a function you don't need the global statement, it will be assumed. 

printf output is line buffered by default, i.e. the line is output when a new line is detected. Use, for example, to add a new line to your output. 

Download my piscope and look at the I2C clock and data lines while your program is talking to the chip. That may be enough to see if chip is working or not. If data appears to be flowing you could check its content with a Python I2C sniffer example. To get the best results it's probably best to start the pigpio daemon at a 2Âµs sample rate if wanting to sniff the data, e.g. sudo pigpiod -s2. 

You need to identify the GPIO actually used by your display. You can use any GPIO not used by the display assuming you can physically attach a wire to them. If you can't get access to the GPIO from above you can always solder wires to the underside of the expansion header. 

I'd be looking to buy an A4988 based microstepping driver. You can pick them up on eBay for less than a UK pound (if you are prepared to wait for delivery). E.g. $URL$ Datasheet at $URL$ 

Use dd (or similar) to copy the working Pi image to your PC. Use dd (or similar) to copy the copied image from your PC to your Pi. man dd 

no file called scan.sh exists in the current working directory (of the script) scan.sh does not have the executable bit set the user has no permission to view scan.sh 

I suggest looking for entries in . If GPIO X is in use by the kernel there will be a gpioX directory. 

I am assuming the command you issue is intended to set GPIO 4. The most likely explanation is you have the 1-wire bus enabled. By default the 1-wire bus is implemented on GPIO 4 and checks devices every few seconds. That will change the GPIO back to being an INPUT. Either disable the 1-wire bus by removing or commenting out the entry from or change the GPIO it uses. 

You need to check the state of the GPIO at regular points in your main loop and if necessary issue the continue command to restart the loop. e.g. 

You assign each device a unique bus address by connecting pin A0 to one of the other pins. I have added the hex address of the device to the table. You don't configure the address in software, you configure the address with hardware. The linked raspberrypi.org post was changing the I2C address of a SRF02 sonar ranger. Don't use instructions for one piece of hardware on another piece of hardware unless you know they are compatible. It's like using the tuning details from a motorcycle manual in an attempt to fix a ship. 

The DHT11 specs are available on the www. You need a pull-up on the data line. It's quite safe to use the DHT11 without a pull-up on the data line, it just will not work. For the Pi it is safest to use a 3V3 pull-up. If you use anything higher you may damage the Pi. The Adafruit software for the DHT11/DHT22 works occasionally. More reliable software is available. 

A Real-Time Clock (RTC) is completely irrelevant to the provision of PWM. All an RTC does is tell a computer what time it is when it boots. It's useful to time-stamp files and so that any on-screen clock displays current time. It plays no part in the production of PWM. The answer you link to is outdated as far as the Pi is concerned. It reflects a reality in 2012. Things have progressed since then. For instance my pigpio library provides servo/ESC suitable PWM on all gpios on the expansion header. It also lets you control the two hardware PWM channels should you find a need for them. 

See $URL$ for the pin out of the Pi's 40-pin expansion header. I'm assuming you have connected the servo control wire to GPIO 17. I'm further assuming you have connected a Pi ground to the servo ground. To see if your servo works enter the following commands. 

The command unconditionally sets GPIO X high. It does not return any meaningful status. That means that the line 

The normal way to install software on a Linux distribution is via a package manager. For Raspbian apt is often used. apt-cache search gnuradio gives the following results. I suggest you try sudo apt-get install gnuradio 

Assuming you have opened the serial device as a FILE *. Use fgets to fetch each line. Store the line if the first character is 'A' otherwise discard the line. Repeat. 

On most Pis you need to use I2C bus 1. I2C bus 0 is pretty much reserved for system use with HATs etc. The first parameter to i2cOpen is the bus. 

As far as I am aware you either have composite output (multi-pole jack) enabled or HDMI output enabled. You can not have both at the same time. If a HDMI device is detected at boot then the output will be HDMI, otherwise it will be composite. 

You need to transfer all three bytes in one SPI transaction, i.e. assert slave select, transfer 3 bytes, deassert slave select. The above code is doing three separate transactions which will be ignored by the ADC. Instead of the three bcm2835_spi_transfer calls change the code to make a single call to bcm2835_spi_transfernb. 

The Pi has external 1k8 pull-ups to 3V3 fitted to SDA (pin 3) and SCL (pin 5). I don't know what criteria the manufacturer of I2C slave devices use to decide if they fit pull-ups or not. It's best if I2C slave devices do not have pull-ups fitted, especially if they are pull-ups to 5V which can damage the Pi's GPIO. 

You should not directly drive a relay from the Raspberry Pi. An individual GPIO can only safely provide about 16mA at 3V3 which is unlikely to be enough to energise the coils of a standard electromagnetic relay. Even if you could the back EMF caused by the collapsing magnetic field in the relay coils when it was switched off could destroy a GPIO and the Pi. You should use the GPIO to switch an external circuit to switch the relay. Typically a transistor (to amplify the current) and a diode (to protect against back EMF) would be used. Personally I'd probably use a ULN2003A chip as they were sort of designed for this purpose. There are lots of relays built into driver boards available for the hobby market.