For option #1 you'd probably need to modify it a bit to conform to the rules of the marketplace. Depending on how your game works, this could be a minimal effort or a huge task, but you have the opportunity to earn a bit of money (probably not much, but you might eventually buy yourself a very nice dinner, and maybe even more, without seeing your game its hard to say). If your game is really good, you could even try publishing it to Steam, but their requirements are much more strict than Xbox Live Indie games. For option #2, you can just put it up there and link to it in some online forms (though not here, maybe in chat though). For option #3, again you don't have to make any changes, you can just put it up as is. 

The main point, is that multiplayer is hard to do, so I recommend you work on your game design skills in a single player environment. Then if you are wildly successful, maybe try adding multiplayer and/or start a new game with client/server architecture from the getgo. 

This is assuming that there is a distance where running A* every frame has performance that is still acceptable. In short, I'd go for your second option. Especially if what you have is working, I'd avoid reimplementing something else if I can just scale back what is working well. The bottom line is that you'll have to try it out to see if it works for your game. 

In this case, containment seems to make the most since, but you may want to have some of your objects inherit from a common base, such as "Sprite" or similar. It is beyond the scope of a single answer on this site to explain all of that. I recommend that you review some of the XNA sample code and see how they do things, and come back and ask us specific questions when you get stuck. 

Obviously you may want to provide more parameters to the sprite during its update process, so you may very the speed or other things as well. 

Should give you three objects all referencing the same Sprite object. A quick search shows that I stand corrected. Java is in fact pass-by-value; however, since java has "pointers" the result in the code above should remain the same. Java passes the pointer to the sprite by value; but they will all still "reference" the same sprite. 

My rule of thumb is that if it has double quotes around it, it should probably be in an XML configuration file, unless the double quotes are being used to index into a configuration file. 

Since it looks like you are using the parameter, you will need to calculate the correct scale value based on the original and target size. Since the parameter is a float, and not a pixel size, you'll need to calculate the percentage your target is of your source. 

The formula for uniform scaling as you are asking, would be . For additional information, and alternate approaches (i.e. using a destination rectangle instead of a scaling factor) see this MSDN article. 

You could, as @Nathan suggested, use a distance from water to define which tile-set to use for each area. This could help keep your maps looking fresh and consistent, yet still be generated on-demand. 

C# and XNA will allow you to develop for Windows, XBox, and Windows Phone. It supports multi-player two former platforms. One of the game samples that comes with the developer tools used to be a space shooter. In my experience it has a very low barrier to entry, the tools are free for Windows, and only $99/year for XBox and Windows Phone. 

What would be a good algorithm for calculating the recoil of a shooting guns cross-hairs? What I've got now, is something like this: 

In a general sense, the engines like Unreal or Unity provide you a way to get your assets on the screen. They may have tools for mashing up a bunch of assets, but you still need a program like Maya, 3D Studio Max, or Blender to build the assets you're going to be mashing up. Specifically, to answer your question on effort: the effort required is probably significant, but not insurmountable. It depends on your skills and dedication. If your a programmer, building the 3D models for each of the items you want will probably be the area you spend the most effort; on the other hand, if your already adept with a 3D modeling package, and aren't much of a programmer, you'll find yourself struggling with any engine. The steps required, in my view are: (assuming you're starting from absolute zero) 

Your image could be very large causing to be slow Your loop could be firing slowly or inconsistently. I could be wrong, and maybe there are extenuating circumstances, but generally a call is never good in a game loop, or any loop for that matter. It could quite easily be the a contributor to your choppiness. I'd remove it to see what happens. Other code you've stripped out from the example could be taking up lots of milliseconds in your loop. 

I see no reason that you cannot do both, and get the best of both worlds. Input Events are generated by polling (at some level the driver polls the hardware to see what state its in), and since your main loop polls all input devices, you can easily implement your own. Something simple like below is what I've used in the past. 

I use code like this to move my sprites, it tends to work quite well for me, it also uses "GameTime" to ensure movement is consistent across frame-rates. 

It will depend on the number of enemies you have and how active they will be. If you have lots of enemies, but they don't do much most of the time, an event system might be better. If you have enemies that are usually doing something the loop may work best since it factors out the complexity of the event system and because if events were in place they would be constantly firing anyway. 

This really depends what type of game that you are making. If your game is a simple text based game, then you can build the same interface in HTML and use different CSS to make it look good based on where the game is being accessed from. More realistically, your game is highly interactive, and it would be best to build the web/facebook version in Flash/Silverlight or another browser plugin. Then port it to iPhone in Objective-C. (Or, if you're more proficient in Objective-C start there and port to web/facebook.) The main issue that you'll probably run into is that on iPhone the input scheme will be different which could impact gameplay. The bottom line, is that you will need to, at a minimum, build a different Rendering and Input scheme for each platform you wish to deploy to. Facebook, is really just a normal web deployment, inside the facebook site, so the design would be the same for facebook or any other web game. edit A few things I'd like to point out, based on your comments. First, HTML5 is probably NOT a good place to start, it has poor browser support (thought getting better), I'd stick with HTML4 and/or XHTML 1.1 and CSS2, these will work in almost all modern browsers; however, if you require any animation, I'd recommend using Flash or Sliverlight to build the game, and use their associated ability to call web services to save state to a server. Second, HTML is just the presentation, if you don't go the plugin route, you would likely need PHP or ASP.NET on the server to manage your game state and persist it to a database. 

I agree with @Omnion. Use the list approach, but keep it sorted if performance is a problem. That is to say use a hybrid approach. Use the list as your third dimension , but only identify the first 5 items as a specific type, and anything after that is an ink own type, or a type that won't require checking multiple times per frame. 

This totally depends on the nature of your game, and how much data is actually on each screen. My approach to this would be as follows: avoid premature optimization. With that said, let me elaborate a little, and explain how I've managed this in some of the games I've written for mobile devices. I typically load textures as they are needed, because most (if not all) mobile devices have very limited memory. In order to keep performance high, I try to keep these textures around as long as possible, if there is a reasonable chance I'll need it again. A quick example: I have a texture that is my pause screen. It has some button looking things, that have hotspots around these "buttons" and a few blank areas where I draw text. The first time the pause action is invoked, I pull up the texture and draw it, then when they resume I keep it around, in the event that they pause again. Now, if memory became an issue in this game, I'd ditch the pause menu texture when they resume, so far, its not been a problem.