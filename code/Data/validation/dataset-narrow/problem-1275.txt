In your code, you calculate but the weight does not depend on the immersed volume (). I think you misunderstood the law of physic you mentioned. I don't quite see what you were trying to do with 

The industry standard for first-person view simulation in most shooters is to have character models and animations distinct from those used for third-person view. There are several reasons for this: 

Trying to tackle solid mechanics are we? First let me clear up a bit of your confusion regarding various concepts of Newtonian mechanics: 

The whole point, and the best part, is this: you know that your solutions to the problem (H(a) and d(a)) obey the specifications (n(a)), so you get the same n(a), but you have freedom. You know exactly the freedom you have, and you can use it to customize the experience. You should always try to give yourself such freedom while satisfying your most important needs, whenever possible. Now that we've chosen the one-hit damage d(a), and since d(a) depends on the weapon damage w(a), we can use d(a) as our specification and try to find a w(a) that gives us this d(a). The principles are the same, the problem is different: we want the player to cause more damage as his level increases, even with the weapon remaining the same, and we also want the damage to increase when the weapon alone gets better and the level stays the same. But what importance should each factor have? Suppose we want level to be more important than weapons: a bigger part of the variations of d(a) = a² should be independent from w(a), for example with w(a) = 22.sqrt(a)    and, therefore,    d(a) = ( 22.sqrt(a) ) . ( 10/22.a.sqrt(a) ) = w(a).( 10/22.a.sqrt(a) ) We get the following graph for w(a)... 

The loops obviously have complexity O(mn) where m and n are the number of vertices of each shape. The set contains mn elements at most. The algorithm has a complexity that depends on the algorithm you used, and you can aim for O(k log(k)) where k is the size of the set of points, so in our case we get O(mn log(mn)). The algorithm has a complexity that is linear with the number of edges (in 2D) or faces (in 3D) of the convex hull, so it really depends on your starting shapes, but it won't be greater than O(mn). I'll let you google for the algorithm for convex shapes, it's a pretty common one. I may put it here if I have the time. 

Now, the solution to your problem actually depends on your implementation of world and camera geometry. You can either rotate your camera around point B or you can "rotate the world" around the camera by the inverse of the previous rotation (as usual in the "ProjectionMatrix * CameraMatrix * ModelMatrix * positionOfVertex" part of a vertex shader, if it's OpenGL or DirectX you're using). 

Make two separate vertices. Make a circle around one of the vertices (the base vertex), that is within a plane perpendicular to the segment between the first two vertices. Hopefully you can make a circle using trigonometry, right? That's already all of the vertices of the cone. That's also one third of all the edges (there are n edges in the circle and 3n in total). Make n edges from the base vertex to the n vertices in the circle. You can make one half of the faces (that's n faces) as you do that. Make n edges from the tip vertex to the n vertices in the circle. You can make the other half of the faces (that's n faces) as you do that. 

the main speedup I introduce here is not looping over all bricks but instead going over a grid and checking for each cell whether there is a brick that needs to be removed and you don't have to muck about with line-line intersections just transmit the and with as much accuracy as possible note I didn't account for wall bouncing 

Lens flare is always in front of any thing rendered so you may as well just disable the depth test when you draw it as the last thing. A sun/skybox can be drawn first with depth writing disabled. Changing the size is as easy as doing the perspective divide in the vertex shader explicitly and clamping the Z to -1,1. Or instead of putting the far plane at your sun, put the sun at the far plane. 

NPC on a path only need to be sends periodically. However instead of only the position you also send the speed and direction the NPC is going. That you only need to send the data a few times a second and the client can extrapolate the current position of the NPC. Health should only be sent when it updates and once every few seconds as a sanity update. 

Then during the rendering you fill the second VBO with , set the attribute pointer as if they where one for each vertex and set the attribute Divisor to 1; draw with 

the openGL driver will unload stuff from vram on its own as needed (most of the time). And if you are ready to remove the mesh from vram then you should be sure you are not going to needed it for a minute. When reloading it you might as well read it back from disk. 

you don't render the same game state 4 times but interpolate the state between 2 physics frames also 15 (visual) FPS just feels laggy you need at least 25ish to feel smooth 

There is one optimization you can still do, which is to create a cache of polygons that need to be rendered: 

the constructor doesn't do what you think it does. It sets the values directly. The values of the quaternion are in order: the cosine of half the angle, the sine of half the angle times the x coordinate of the normalized rotation axis, and the same for the y ans z components. So instead you want to use or after inlining the result of the trig: 

can be gotten with . Then will be similarly . is a convenience function that will compute also take into account the quadrant of where the point is and deals with properly and generally goes from to . 

In my limited experience with atomics I haven't found a way to have the threads pick their buffers without needing a lock. But the critical section is only a few memory operations so it's not a huge deal (a busy-wait lock would suffice most of the time). 

And then you go over each of the marked cells and update them in the same way, (marking the neighbours of changed cells as you go): 

Draw the floor (transparent part) after drawing the rest of the objects with transparency blending turned on. Otherwise you can pass a currentFloor uniform to the fragment shader and a floor attribute to the objects so you can add the extra shade conditionally. 

just generate and keep all blocks within a X radius of the player in the hash table, and then frustum filter for drawing, same way minecraft does it it's cheaper to keep more sectors in memory and then filter than keep just enough and generate 

How to tell in the general case whether two convex shapes intersect? I'll give you an algorithm that works for all convex shapes and not just hexagons. Suppose X and Y are two convex shapes. They intersect if and only if they have a point in common, i.e. there is a point x &in; X and a point y &in; Y such that x = y. If you regard the space as a vector space, then this amounts to saying x - y = 0. And now we get to this Minkowski business: The Minkowski sum of X and Y is the set of all x + y for x &in; X and y &in; Y. 

So if OP' is to be (1,0,0) then what is P? It's the point you get by applying the equation of positions to OP' = (1,0,0). Let's now define R1 = R.(1,0,0), R2 = R.(0,1,0) and R3 = R.(0,0,1) 

Inertia is not a tuple (x,y,z), it is in fact a 3x3 matrix but in the case of a simple box, calculating said matrix within the set of coordinates naturally associated with the box yields a diagonal matrix (i.e. whose only non-zero entries are on the diagonal,so there are 3). The pdf you linked to gives Ix, Iy and Iz which are the three non-zero entries of the inertia matrix I (but I'm going to call it J because I is often used for the identity matrix). But if J had been calculated relative to a randomly chosen set of coordinates (if the axes in the pictures to the right of the table in the pdf hadn't been in these positions priviledging the geometry of the solid shapes in question) then the matrix J would have been much more complex and, in addition to Ix, Iy and Iz there would have been three other real numbers necessary to define inertia: Ixy = Iyx, Ixz = Izx and Iyz = Izy. Three additional numbers only and not six because J is symmetric. I don't know what was supposed to mean, but if inertia is going to be a vector, then you'd better make sure your solids always have nice symmetries and invariances with respect to the axes of your axis system. Classical mechanics tells us that J.(dω/dt) = T where T is the torque, ω is the angular velocity and dt is a small amount of time (your timestep). Both are vectors. To get only dω, i.e. the small amount of angular velocity that you will add to your current angular velocity, you need to multiply both sides of the equation by the inverse of J and then by dt: 

I can't say I've played all puzzle games in existence, let alone all games with puzzles in them. But I only remember one about whose puzzles one could say they were all always placed at the one and only appropriate point in the narrative and that they contributed immensely to it. What I mean is that when the designers of most games insert puzzles (or rather, "specific gameplay sequences") at certain points in their story, their goal is to challenge the player. And that's it. Maybe because the story requires it at that specific point in the game, maybe because it gives the gameplay rhythm. Take Half-Life 2, for example, and give me one example of a puzzle (you know, the physics ones) at some point in the game which couldn't have been replaced with another one, due to the story requiring that specific type of gameplay at that specific time. I know that in the latter half of the game, the puzzles require the Gravity Gun and can't be done without it, but the gameplay is pretty much the same: grab->put down, grab->throw. The same applies to almost all games, where the aim of a given bit of gameplay is always either to give the player a gameplay bonus or to allow them to move on in the story or more rarely, as in Deus Ex: HR or LA: Noire, to reveal more about the depths of ths story. On the other hand, in Braid, the gameplay and "story" are tightly interwoven. The first chapter is supposed to be "forgiving" and about innocence and so is the gameplay. The chapter with the ring is about finding comfort in the presence of someone dear, all the while knowing that their companionship is a burden (to someone as ambitious and driven as Tim), and the gameplay is a perfect translation of that. The same applies to the other levels and even to the epilogue. Jon Blow himself said about his game design experience with Braid that it was like sitting in a gold mine and scooping nuggets of gameplay, examining them from all angles (or something along those lines, was it in Indie Game: The Movie?). That's the phase you're currently going through, it looks like. So I what I would do if I were in your case, where you have a unique idea and you'd rather sit in the gold mine and scoop nuggets than write a story, is do precisely that, do this job of scooping as many gameplay nuggets as you can. Once you have something to say, a message to shout out, then you'll write a story with these two constraints: the message and the gameplay. They will be unrelated enough that the story can accommodate them both. Take, for example, this painting (the medium) that depicts an old Middle-Eastern king killing his servants, horses and dogs, bringing his world down with him as he is losing a battle and his palace is assaulted (the story). It's about grandiose decadence and egotism (the message). We could imagine lots of different works of art with the same message. For example, imagine a scene in a movie about a corporate CEO who in the end burns entire bags of bank notes in his condo as the tax administration/feds/IRS/what have you are after him. You can always write a story that adapts to your medium and message of choice. Edit to answer the asker's comments: So you have a gameplay you like as well as a story you like. You would like to develop both further, but doing so would mean having to make sacrifices on the gameplay end or on the story end when comes the time to merge it all into an actual game. One solution could be to work on the story first and use it as a constraint for the gameplay, which would only serve as the medium for it and, in your creative process, would always come second. Another solution, the converse of the first, is possible, where you find as many variations on your gameplay as you can and then see what can be done with it it terms of storytelling, hoping that you can build your original story around these gameplay elements. All this cranking of constraints into others looks painful. What I'm suggesting is that you take a good look at your story and try to pinpoint exactly what makes you like it in the first place. What, in its substance, makes you want to tell it. Extract that substance, forget about the details of the story like the setting, the names of the characters, their looks, the duration of the story, forget that it's about human beings (it could be about animals!), forget all of this and look at its substance, its deeper message, somewhat like I did (or tried doing) for the Death of Sardanapal painting linked to above. Then, I assure you that you will never have the slightest bit of worry regarding cranking the story and the gameplay together. You will find the story that makes use of the gameplay to convey the message. I personally believe that that is what matters the most. So scoop those gameplay nuggets. By the way, this is not how Jon Blow thinks we should make games, because this disconnects the message from the gameplay. If, like him, you can create an experience that is contained within the gameplay and have the player extract the message himself from that experience, that's also extremely cool. 

Each of the vertexes of the triangle will have a coordinate assigned. When the triangle is projected onto the screen each point that is displayed on screen will have a set of barycentric coordinates. Then to get the texture coordinate you just take the average of the texture coordinates weighted by the barycentric coordinates. In openGL this is done automatically when you select varying as output of the vertex shader and input of the fragment shader. 

Beyond that if your chunk size is a power of 2 then the optimizer can change the math in and by bit operations. You can do that explicitly if you don't trust the optimizer to catch it. 

but if size*size>255 then you need to upgrade the indicesList to contain a short or int, otherwise they just won't fit. 

You don't need to call for the indexes; the indexes are found from the bound during the call (which is saved in the VAO state IIRC). However indexes start from so the contents of your index buffer are flawed they should be: 

you are in a voxel engine which means that each box should have a discrete x, y and z coordinate thus: if you have a box at index (x, y, z) then you can get all neighbouring boxes by getting the boxes at index , and edit: after some more info... just detect the collisions for a line between the center of the current cube and the center of the potential neighbouring cube, thus instead of intersecting with the bounding box of the cube you intersect with 3 lines strechting from to and to and to 

lets rephrase it a bit you have a point and a direction , find the smallest such that has one of its coordinates on a whole multiple of cell size in the same dimension. then it is easy take p.x and find how much you need to go in the x direction so that we are on a multiple of width then you find how many you need to add take to get there, if d.x is negative then replace with and negate v.x then you do . repeat for each of the axis and take the minimum of the s 

It only stores the vertex binding and the index buffer binding That is all the parameters of plus the buffer bound to Vertex_Array_buffer at the time of the call to and the bound Element_Array_buffer. Uniforms are part of the current program. Everything else is global state. In doubt you can check the state tables in the spec of the version you are using. 

Keep an "on-screen tiles" collection that you update each time the camera moves and each tile has a reference to the objects in it. This was you only need to update the objects referenced by the tiles that are on screen (or just outside). 

you can rotate/shear the scene so the light is vertical and build a height map and use that as the shadow map for the shear matrix it's something like 

The interface will help here, when the call function of the Callable throws then the get of the Future will throw a where its cause is the original exception. You can subclass and override the which will notify the world when the computation is either successful or failed and let the world handle the failure condition. 

you first create a set of parameters that you will generate, for example elevation, humidity, temperature then you can define a function that will return a biome from any combination of these parameters how you generate those parameters is usually with perlin or simplex noise but you can let it depends on other (previously generated) parameters like elevation and prevailing wind to create a rain shadow.