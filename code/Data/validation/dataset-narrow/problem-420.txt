this is not thread safe! What is more, the value is never assigned to ... (thanks @DaveJarvis for noticing this!) 

I use this pattern a lot; I find it useful. Do you? What would be your gripes against it? Sample implementation of a simple pair: 

You may want a static method in your class, named, for instance, taking a as an argument and returning an : 

Now, code written using Mockito and TestNG (with test file in same package than class , so that the method is visible): 

Easy to adapt in the second scenario. Second remark: I fail to see why is an illegal value at all for your predicate; as your code reads right now, I can very well input as an argument to the predicate and it will work. Why not just "let it be"? After all, it is the user's fault if a correct predicate is not provided, isn't it? Third remark: calling a an ? Uh... Why not just ? Also, remind that any interface obeying the prototype of a can be used, so you can define and use instances of this interface. By default, you could supply an empty one, or one that s, for instance 

Note how I am using vectors everywhere and only in the end putting the results in a data.frame. Indeed, there is arguably no need for a data.frame until you want to see the results in a nice format, at the very end. Keeping things in vectors avoid the repetitive and the annoying conversion from character vectors to factors (what forced you to use ). I have slightly modified your algorithm, where instead of replacing valid postcodes by so they won't get affected by fixes, I am propagating a vector of valid or "best guess" codes () via the construct: 

, but I suspect the main bottleneck in your code is the use of parallel loops in and , for operations that can be done faster using vectorized R functions. Please give this a try and let us know if it is faster for you: 

It builds a list () of eight matrices in memory, one for each neighboring position. Instead of four loops, you are down to a single loop (8 iterations) wherever you see or , everything else uses vectorized operations. Testing the code: 

Correctness Does it even work? Did you write unit tests for it? For example I can't see where the method makes any use of argument (other than to assert it's not null). 

Apart from using upper case for method names (as pointed out by @paritosh), I think it's a reasonable convention to use prefix for methods returning a boolean representing some state that may or may not be. Case in point: $URL$ Note this is a property, meaning you could indeed replace with a read-only property. Not that there's anything bad with leaving it like it is - properties are just more idiomatic in C#. Using a property kind of puts more emphasis on the fact that we're only checking on some state, and there's no side effects to that. (You can still implement a property in such a way that it causes side effects, it's just blatantly against the semantics of it). Last but not least, variables should be named with lower case in C#: 

It doesn't have to be static, although there are conflicting schools of thought here. On one hand, making a method static sort of stresses the fact that it's stateless - and for instance the popular code quality tool for C#, ReSharper, suggests this by default. On the other hand, making a method static has certain consequences, such as an inability to override the method. I don't think it's a big deal either way in this case, anyhow it's a little controversial whether statics should be used by default. As for other remarks: Overall design The class is called , but it knows some other tricks beyond notifying (by sending emails. By the way, I would consider renaming it to to resolve any possible ambiguity, since there are various types of notifications in this world, but I'm not hellbent on it). What it also does is that it searches personnel members by their ID - that doesn't qualify as "notifying" in my book? I would expect retrieving a manager by ID to be implemented on - let every object take care of itself (aka Law of Demeter). Naming 

the use of rather than looping over an unused argument the use of 's and arguments rather than the trick you used making an optional argument 

Rather than carry the weird assumptions about your data column names into the second part of your code, I took care of making uniform names in the data reading/cleaning section. For that, I converted all names to lowercase using . I added a to check that each sheet contains the four columns you need. Always try to gather in your head the assumptions that your code is relying on, then add code to check these assumptions and die if they are not met. Everywhere I needed a column from the data, I referred to it using its name (e.g. ) rather than its position (e.g. ). Doing so will always make your code more readable and more robust to data changes. I replaced with a base solution. It helps remove a dependency to a 3rd party package but if you prefer to keep dplyr, it's ok too. I replaced the calls with simpler (easier to read) calls. I note that your calls were probably returning the expected results but you are doing something weird. To use , your regex pattern should really use a set of parenthesis to catch something that will be stored inside . It would have made more sense to not use regex captures and just use the empty string as the replacement instead of . 

If you are intent on using a builder, then I'd suggest either making it an inner static class to the main class or a different class in the same package. If the first solution, then the constructor for the built class can be made ; if the second, it can be made package local. First scenario: 

The "drawback" here is that it is up to the caller to remind what predicates where in what order in the calling lists, of course. As to your hypothetical class: 

I'd just say to go with your implementation; just because it is easier to read! Also, you only from the list once, whereas the proposed solution does it twice. Shorter is not a synonym for better! However, the generics are not good; you should at least use . Not sure why the proposed solution uses as a lower bound... 

For more complex cases, I generally create both classes in the same package and make instance variables for both package visible (this leaves of course the responsibility on me that what I inject into the frozen part is actually immutable, but I deal with it ;) EDIT Right now the methods are called and , to reflect the pattern's intents; do you think of better names? EDIT 2 Objections from @bowmore: the SRP (Single Responsibility Principle) is violated; this is true: the frozen instance has the added responsibility that it must generate a pre-filled thawed instance. The suggestion here is to create an additional constructor/static factory method/method (pick your poison) on the builder class so that it be able to "swallow" the contents of the frozen instance. 

We're kind of emulating Java's enums here (one of few features where Java actually happens to be superior to C#). And a little bit of help (so that we don't use reflection etc.): 

be it a constant, or a collection computed in run-time, doesn't really matter. And then it gets as simple as that: 

the else-return bloc doesn't serve any purpose. The same with calls at the end of methods (, , , , ): redundant. These methods are exited anyway. You don't need to use both and clauses. It's one too many. Eg.: 

The last trick I can think of would be to convert these conditionals into instances, and pass them to the LINQ chain. I haven't got a C# IDE on this computer, so this code could be syntactically incorrect, but you get the idea: 

Because the last two lines of code are the same for both cases. Then there's the loop iterating over the nodes sort of repeats in and . It's a bit of an awkward construct... which you already implemented once as . Why not reuse it? The class can just iterate over itself: . The clunkiness of traversing the list node by node gets abstracted away. The main takeaway in my opinion is that you should start writing unit tests for your code. It not only helps to catch out bugs, but also implementation inconsistencies, as it forces you to think about the contract and all the edge cases. I'd also put more emphasis on making code documentation actually useful for a hypothetical developer who'd want to use your code. Try to put yourself in their shoes: would you be happy having these comments to figure out how to use the class? 

There is no need for the else at all since you don't do anything if is not odd. Also, there is no need at all for two lists. Just one is enough: 

Then have a in which you would pair keys with implementations of . If no entry exists, of course, the method call is wrong. While this is easy, however, it is not practical. Many frameworks, including light ones, include annotation systems which will do the job automatically for you -- you should try and find one, and use it. There is also another solution -- since this is JDK 7 you are using, you'll have it: . It also requires that you implement an interface, but using this, you can load your method implementations easily. This is what I use in one of my projects, and it works quite well; the only trouble with it is you need to create a file in , but it's a trouble you only have to do once for each method you create; or if you use Maven, there is a plugin to generate it for you. 

where is a super fast (internal C-compiled) function. Question 2 Is the argument handling OK? I wanted users of the function to be able supply either ppm or mz_tol, but not both. Am I using missing() correctly? There are two schools for this kind of situation: 

some assumption checking with the use of variable names that are closer to the problem write-up (, , ) or more descriptive, e.g., the use of for finding if a number is divisible by or vectorization (notice how one of your loops is gone), which should make your code faster The use of instead of is more robust in the case when is zero. 

5) is a questionable variable name, given it is also the name of a base function. 6) This is debatable: I would get rid of the condition since it won't hurt doing the swap even if . IMO, the simpler code is preferable to the marginal computation time gain. 7) A nit: know the difference between (numeric) and (integer). Here you are using when you mean to use , which causes unnecessary conversions from integer to numeric (though the operator brings you back to integers by doing the opposite conversion). 

There's no use in putting "generic" in the name. Any C# programmer knows that indicates generics by itself. Case in point: in .NET we've got and - not . (So "drop the the" ;) ) 

How do you know the method you're looking for will always come up first on the list returned by ? If you only expect one, use . But indicates you consider the possibility that more than one method matches your given criteria. So, do we have some guarantee it would always be the first one in our way, or are we just "feeling lucky"? :) This looks pretty fragile to me. This is subjective of course, but I have to say that since this method is actually less functional than and the implementation is rather brittle, I would personally veto this extension in a peer review, since I don't believe whatever readability improvement it brings to the table justifies the trade-offs. I think this is a textbook example of what Jon Skeet calls evil code. It's not wrong as in "doesn't work", it's sort of clever, its "magic" can even have some appeal to it, but it's fundamentally unclear and dangerous. I highly recommend this talk: $URL$ If you really want such syntactic sugar, I'd ditch generics and reflection-based approach, and replace it with hardcoded extensions for , , - come on, it's not like there's dozens of use-cases anyway. Oh, and have them return a to distinguish between input actually converted to the default value, and not converted at all. Like so: 

I would only have put the input directory in its own variable so you have more direct access to it if you decide to change it later. Also, you could have chosen to and used within . 

If my first suggestion is still too slow and your matrix is so large that my second solution cannot be used, you might want to use a mix between the two approaches, where you loop on chunks of rows, i.e. rely on . But I'll leave that to you as an exercise :-) Finally, I will point out that if you are interested, you could search CRAN or the internet for a package that does exactly what you are after. KNN is a very common tool and there must be packages (compiled from C) that already do it much faster than this code will do. But not much to be learnt there... 

so we will be calling . All that is left is to write : a vectorized function that will take as inputs two vectors of airport names and return their distances. We could first put the important data in a matrix with airport names as row names for easy access: 

Error handling or the lack thereof. Sending an email can fail for a variety of reasons, and you don't handle exceptions or failures. In you're sending emails in a loop - what if there's 10 managers, and sending it to the second one fails badly, shouldn't we try to ensure that the remaining eight would still receive their notifications? You don't handle edge cases either (such as an inexistent recipient: it would result in a once you tried to retrieve from a null , if didn't contain any entity under a given id). 

Code style Magic numbers In "DatabaseManager", I would convert "magic numbers" (connection life time being 5 minutes, command timeout set to 120 etc.) into constants. Fluff / noise 

You have not implemented exception handling (the last requirement). Eg. if calling code passes to or , it won't crash straight away, but as soon as you call , it will result in an unhandled once it gets to this null "fruit". Also note that we don't know what calling code may pass in as an argument - could be some object that implements one of the interfaces, but actually explodes once our code calls its or ... The requirement states that it's the responsibility of this code to handle exceptions, so if this was my homework, I'd prefer to be on the safe side here. Less importantly, you implemented as a property of rather than a field (which is what the description asks for), although public fields actually are considered a bit of a code smell, and a backing field is automatically created for properties, so I would leave it. Aiming at good code style you could make it immutable though (as a field, or a property with a private setter), and set it in the constructor - it stands to reason that name of a given fruit isn't subject to change. and could be too, but that's nitpicking already. Apart from the lack of exception handling, it seems okay to me. I like that you used some modern C# features to cut down on verbosity.