The other thing I noticed is that you are checking the string against itself. Which is not similar to the description you give above (where you are comparing two different strings). 

This code works fine. But if you return by reference you can alter the value while it is in the list. This can help if you don't want to pop the value and then replace it. I would have done: 

Maybe the difference is not a big issue as you are going to crash with a double delete anyway. But you break the principle of least surprise by doing it differently. 

Prefer to use the initializer list All the members of a class are constructed before the body of the constructor is executed. So in your case you are constructing the member then (in the body) calling the assignment operator. If you use the initializer list you construct the member using the parameter. 

I think I can see that from the name. Your comment should explain WHY not WHAT. I should be able to see that WHAT from the well written code. The problem is that code and comments can diverge over time (as bug fixes are applied) if they are describing WHAT. If you explain WHY that will usually remain the same. What happens if I change the code to return now the comments and code are different but it still works. Does the next person change the code or the comments. Error Codes 

You only every use the first element. If you are not going to modify a parameter help the compiler by letting it know that the parameter is const (thus will not be modified). So pass the vector by const reference. If you remove the vector pass by const reference to std::string. Currently is implemented as a runtime check on the type. But you know the type at compile time. So you should use template specialization. So in the class define a default version that does nothing. I would change that to try and use the constructor (that has a string). If the class does have a string constructor it is a compiler error but you probably want to know that, 

It looks like you are locking the same mutex twice in . You can not use a normal mutex and lock it twice for this you need a recursive lock (this will allow the same thread to lock a mutex more than once). 

Overall Design Is wrong. If a philosopher can not acquire either fork they are supposed to be thinking instead. In your code when they try and acquire a fork they block waiting for the to be available. Thus they never get any thinking time in. When you try and acquire a fork if you fail you drop any currently held forks and then think. You should never block waiting for fork. I don't remember and dinner parties were guests were just looking at the handle of the fork waiting for it to become available. If they could not get a fork they generally engage in conversation until the fork is available. Remember this problem was originally designed to allocate tape drive resources as efficiently as possible. You are not using your tape drives or your CPU very well if you spend time waiting. 

The complexity of fib is (Approx). You put this in a loop so your complexity is . Which is fine for small fixed amount of numbers (fib is simple and usually n is small (less than 100)). But when n is unbound like your problem this becomes a problem. Fib is also relatively simple and can be done in . 

I would also change to . The use of to mark member variables is an indicator that you are using bad member Vs local names and need a rule to allow people to distinguish between the two. I would prefer you improve the naming convention of your variables so that it si obvious from context the meaning. Modify the array constructor to use members to do the real work and make the code more readable and thus self documenting. 

You did not provide the implementation of your constructors or assignment operators so its hard to tell if they are good or not. Also nice to add easier access to const iterators: 

A user of your code will eventually forget to check an error code thus resulting in bug. If something goes wrong that you can't fix locally then throw an exception. If the user of the code does not catch the exception then it will correctly terminate the application (any other action is a bug without knowing the context). You can then find this in testing and add the appropriate code to fix the problem (or ignore it as appropriate). Semantics and Rule of Three The compiler generates the copy constructor and copy assignment operator for you by default. So the following are not your only constructors. 

The one issue I have with this is that it does not provide the strong exception guarantee and you can't fall back to the original state if something goes wrong. Though this is correct. I don't like the copy constructor not explicitly initializing the members. Have to go check the rest of the code to make sure the members are initialized reeks of doing things in multiple places. Move Semantics The source of the move can be left in an undefined state (as long as it is valid). I don't see the need to values from the source object. just move them. Poping them adds extra work that is not required. The destructor when called when do all the cleanup required. 

Here you are pre-allocating an array of . This means that must be default constructible (i.e. have a zero parameter constructor). Also if is expensive to create and you don't use the whole array then you may be creating these object unnecessarily at an expensive point in the code. You can allocate memory without calling the constructor then use placement new during the push to copy the data into the memory pool. The same problem also appears in Potential Leak. 

The is a good starting point. But it is by no way the warning flags (just a small subset). I personally use a few more: 

Overview You should be using std::thread and family rather than pthread. The main reason is that these are exception aware and will do the correct thing when being destroyed. Moving on assuming we are talking about pthreads. Secondly you don't use RAII enough. As objects you create via pthread are not cleaned up correctly in all situations and as a result your application is not well defined. pthreads is a library. As a result all it knows about is stuff (this includes functions). Passing C++ stuff to a C library is undefined. So the callback functions you use in need to be declared as C functions otherwise there is no guarantee they will work correctly. To declare them as functions you need to Your design relies on global objects. This is always a red flag. All this queue handling shenanigans should be done inside a class to protect the the queues from some other programmer coming along and using them in some other manner than is expected by your code. You can then declare a single object in the main function and pass it around as a parameter (so you don't get global state that can be accidentally mutated from somewhere else). Design I am not clear what you are trying to do. The code does not do what the description above says. 

Moving the list. You have the move constructor. But I am not convinced it is correct. But you also missed the move assignment operator. 

When doing the initializer list. I always put the punctuation at the beginning of the line. This avoids this situation. 

But hold on. The only counts white space as word separators. But if we had a real line. There may be other punctuation on the line" 

You either need to check the ptr on construction (to make sure it is never NULL) or if you allow NULL pointers then you need to check when the object is used. Specialization To avoid repeating yourself allow your code to be specialized by a second template parameter that understands how to reclaim the resources of different types. The default version just calls delete but this allows you to use specialize it for handles etc. Circular lists are easier with no NULL pointers. 

Not sure if that is unique enough. I can easily imagine somebody else using the same header guard. I would add the namespace to your header guard. I use as a prefix to all my guards and the namespace (because I own the domain thorsanvil.com). 

I think a triangle is really better represented as 3 points. What if A and B are parallel! This also makes several of the other methods easier to write. It seems like you be able to get the distance between two points by subtracting them or a distance method (thus you don't need to expose their internal representation with getX() and getY()). It's OK to write a print method. But you should proably also provide the output stream operator. 

This makes code hard to read (and thus maintain). Also not everybody will read your code on a wide display. 

If this code is working. Then DON'T do any major refactoring without unit tests. You can add your standard modernizations that are easy to show work: Use Copy and Swap Idiom on the assignment operator: 

This needs a lot of work to bring it up to current standard practices. Currently I would not consider this C++ code, but rather C code that happens to use some C++ features. All Upper Case Identifiers These have always been reserved for macros (#define). Thus using them for something else is likely to cause identifier collisions. So don't do that. Also note that macros do not respect namespaces. 

If you can not call then you should remove it from the class. I would just get rid of the macors. Then your users can do: 

You are using a Sentinel at the beginning of the list, but this is not really needed. Sentinel are very useful for double linked list but don't make things easier for singly linked list. Your code will be simlified by removing it. You can make your code simpler by moving the initialization of the node into its constructor. The destructor can be made simpler just be running accross the nodes and deleting them. There is no point in the extra work in pop() to keep the object in a valid state. 

Each iteration you are making a copy of the internal array from into the object. To prevent this use a reference. 

Standard conventions indicate that the input and output files come last. Flags are modifiers that appear first. Both input and output should be optional and if not supplied be replaced with standard in/out. Note the by itself instead of a flag should indicate standard input/output depending on its position. Thus I would write it like this: 

I prefer the constructor to initialize members. It's easier to spot when things are missed. If you are going to initialize the members in the code then I prefer them near the construcors so that it is easy to spot. Personally I lay my code out like this: 

This is called the basic exception guarantee. That's fine but you need to document it because most people expect the strong exception gurantee. Also using the copy and swap idiom mkae providing this gurantee easy, 

You can use other techniques to find primes : But since this is a code review I will review the code you have: The easiest optimization is to record primes as you go. A number is prime if it is not divisible by any of the primes you have already found. Thus you don't need to check a number against all smaller numbers just all smaller primes. 

But you don't even need to be using pointers. Texture is not polymorphic. Just create the object in the container (not the pointer). 

This means you make a copy of the value. This is fine for simple types like integer but for complex classes this is potentially expensive. Another reason to use and . But here at least should return a reference to avoid the copy. 

So it looks like you are running around a maze that has been printed incorrectly on the screen. and thus it looks like collision detection is not working (it probably is) but the detection does not match the visual cues. Reviewing your code: These expressions 

OK some fixes to stop you getting trapped: You were getting stuck because you could and wake the threads in the condition variable. Then after the notification another thread can set to false thus trapping the threads in the condition variable. Example 

You bet yea :-) Having a quick look at the code. The size worries me. A BST is a simple structure and should not take this much effort. NULL is not a magic value This is showing a lack of understanding of the type system (are you coming from a Java background?). 

So you can pass a node by reference. Which means that internally you will make a copy. Which makes this redundant: 

You will need a static char array (or equivalent (like a switch)) somewhere as there is no built in way to convert enum values (which are integers) to a string. 

Code Review R had better be constructible with an integer. Otherwise this will fail to even compile. 

If you can create a non zero reference counter then you can combine this with the default constructor. What is your use case for this assignment operator? 

If the array is sorted. Then the only re-ordering that will happen is negative numbers into positive (as a square of a negative results in a positive). So negative numbers will need to be re-sorted into the positive numbers. 

This is not what I would normally call an Object Pool (in the traditional sense of the term). That term I would use to refer to a pool of memory that returns "Uninitialized" memory (via a pointer) usually via an allocator so that a operation could build the object (and the memory is returned after it is deleted). I do like the term though as that is an accurate description of what is happening. You are temporarily giving ownership of objects that can be returned (in potentially a new state). Your ownership semantics are wrong though. You return a indicating that ownership has been transferred to the borrower. But that is not actually true. The "pool" actually retains ownership as it calls the destructor on the object when it is destroyed (ONLY the owner of an object should try and delete it (reclaim the resource)). Also if the "pool" is destroyed (thus destroying all the owned pointers); then the "borrowers" are left holding to objects that no longer exist (bad point 1). But when they do release them the "deleter" tries to put them back into a "pool" that no longer exists (bad point 2). As it stands this code is just ill-advised. You need to think some more about your ownership semantics.