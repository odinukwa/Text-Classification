If you want to increase the time to kill (TTK) for later levels, you could either increase enemy health scaling or decrease player damage scaling. Of course this is only one dimension of the combat. You would have to create another set of formulas for player health and enemy damage. The TTK for the creature vs the player should be higher (it should take longer for a creature to kill the player than visa versa), but the closer you get to 20, the closer the numbers should get, for increasing difficulty. Add in avoidance and mitigation requires you to combine the damage formulas with the mitigation % or miss chance to determine the actual average expected damage. The damage values above would be the target numbers for each level that you try to balance around. Once you have squared away your baseline creature, then you can create variations, such as glass cannons that do high damage but have lower health. If you put in the work at the start to build a good baseline enemy for all level ranges, then creating new enemies that are near balanced is actually fairly simple. 

This process of filling out can be extended all across the creation of the RPG. All numbers are interdependent. Examples: 

This is your baseline. Quests that take 50% longer should generally get a 50% boost in XP. You might make Hard/Medium/Easy quest difficulties that get 150%/100%/50% XP respectively. 

Lets take a simple example using only damage and health, with a level cap of 20. The base enemy has 10+5/level health and the average damage per round of the player is 8+2/level. You can put those equations into Excel and you come out with something like this: 

Difficulty is perceived as a combination of time, risk, and meaningful choice. RPGs usually start off with small encounters that are very quick, have little risk, and little meaningful choice. This continues while the player is learning the game and the character they are playing. As new abilities are introduced, more meaningful choice is introduced. Do you use poison at the start of the fight or just go for direct attack. Along with this comes longer fights and more risk. If a player can kill a creature in 2 basic attacks or 2 special attacks, there isn't much choice. You need more granularity to have more meaningful choices. To get to this sort of growth, you need to control the length of encounters. In large scale development, this is done with formulas, which are much later fine tuned after extensive play-testing. Formulas are written only after requirements are established, and are generally used as a baseline for fights. You can create variations of the baseline after you have established the baseline. Answer some basic questions such as 

After you have established how long a player is expected to be in a level, you can decide how much money they should gain in that level. Generally the amount of money gained should grow FASTER than the TTL. So if your TTL increases by 20% between levels, your money gained should increase by MORE than 20% between levels. Otherwise it becomes more efficient to grind money by dropping to lower levels, and you don't want to reward tedious behavior. Use the Excel table from before and just add a column for Gold Per Hour. Come up with a formula for that with a slight exponential growth. Once you have established the GPH gained at each level, you can then use that to calculate the total gold gained in a given level. From that you can determine the curve of the cost of buying items of a given level, depending on the pace at which you want players to replace their items. 

You mention that the user feels "safe" if the spiders are all offscreen. This is probably the most important thing to address. Fortunately, you want the right kind of thing: a gut feeling that the user has that nothing is ever safe. The "gut feeling" people get is an amalgamation of many small cues that the brain processes together to try to guestimate an unknown (in this case, the position of the spiders). Your goal should be to provide many small clues in many different ways, visual and auditory, rather than trying to come up with one big clue which tells you where the spider is. Many have mentioned music. Sound is always good for gut feeling effects because we humans use it for wide awareness of our surroundings. It's the thing which tells us to stop focusing on trying to fix our radio because there's a zombie behind us. However, visual effects can also be used. You just need to make the spiders have a presence. A few ideas: 

The number one thing I have found that limits educational game is a hard lined insistence that the adult programming the game define what will be learned in the game. Much of a game's appeal is from the player deciding what they want to get out of the game. The game maker can make suggestions, but in the end, it is the player that decides. If your game suggest "You should want to learn to add positive and negative numbers," and that's not the player's definition of "fun," they'll quickly put the game down. Instead, make room to permit the player to decide what they want from the game. If they want to have fun in their particular way shape or fashion, let them! Sure, reward them for wanting to have fun in ways that support your educational goals, but don't make it hard to enjoy the game outside of a narrow window. Let's use your cannon game as an example to brainstorm on. Unless you feel like adding numbers to get to a zero, it's a rather boring game. However, what if summing numbers to zero instead offered you power ups, and the "game" was a more standard cannon game. Now the game is just a game, but there's a way to make it easier by doing math. If a player wants to win simply by shooting every number out of the sky, guess what: they learned geometry! As the game progresses, you may try to encourage them to play the math part of the game more by making it gradually harder to progress without playing the part of the game you want them to play. If they want to stick to the easy stuff, that's fine. If they want to rely on raw twitch fingers to blast everything, that's fine. If they want to concentrate on the math, great. If they want to find their own balance between math and twitch, that's even better! Now, consider that paragraph with respect to Candy Crush, one of the more addictive games of all time. The primary focus of the game is on studying patterns in the game grid. Instead of making that the game, they make it a way to power up: cookies kill off whole colors, wrapped sweets slaughter columns or rows, etc. At first you can just play the game any way you like. However, as you progress in the levels, the power-ups smoothly become more and more important, until you reach a point where some of the simpler power-ups are absolutely and utterly required to beat a level, and the game encourages you to reach for the more powerful power ups. Candy Crush is a good example for how to not make a game boring! 

I can't see anything fundamentally wrong with the shader, but here are a few things I find commonly done wrong with deferred shading that you might be doing. 1: Drawing full screen lights. The beauty of deferred shading is that you can pack your lights into geometry so that you only need to consider a part of the screen when drawing them (Like a cube with 2 times the radius as size). If instead you draw a full screen quad for every light, that will have a serious performance impact. 2: Render target depth. You are moving a lot of data around in deferred shading, so you have an interest in making the footprint of that as small as possible. If you can reduce the number or size of your render targets that can have a pretty big performance impact. 3: Rendering one light at a time rather than batching them. (Edit: You can have a static vertexbuffer and indexbuffer containing vertices for the max number of lights you want to ever render and then just patch the position and color of the lights that are active) And lastly, you can always look at the assembly of your shader and see how many cycles it will take, so that gives you an easy way to see your own performance and compare. GPU Gems has 2 or 3 great articles on deferred shading and the performance and other issues that come with it. 

XNA has a Vector3.Forward, transform that with your cameras viewmatrix and if necessary set your y component to zero and normalize. Generally if this gives you trouble you should refresh your basic understanding of linear algebra. 

Figure out your mouse position in world space and divide by the tile size. Basically keep track of where your upper left corner is in world space, add the mouse position to that (with appropriate scaling etc.) and then divide it by your tilesize. 

A good way to think about it is this. You can always break the textbox up into 9 bits, top left, top center, top right, etc. Now the corners will basically always be the same size the top and bottom side will be stretched along the x axis and the left and right sides will be stretched along the y-axis. The center will be stretched along both axis obviously. So the question is then how do you draw each of those. Drawing the corners is easy since they always have the same dimensions. But for the sides and the centers you have a few choices. If the textures for them tile you can just scale the sides and their texture coordinates up to fit and use sampler state wrap so that it tiles naturally. You want to make sure to round your scaling so your highest uv coordinates are integers, so that the tiling continues properly towards the corners. You could also not scale your uv coordinates and just let the image be stretched if it isn't (too) noticeable. And for the center you can do essentially the same thing. TL;DR: You don't really need to figure out how many of those pieces to draw. Instead thing of just 9 parts that make up a box and draw each of the parts appropriately. 

You interpolate to find states between known values, and you extrapolate to find future states. Think of the problem in terms of state variables, like positions and velocities. In the best of all scenarios, every computer which needs to work with state has access to the state data for the time they want to work on. For example, a collision algorithm to see whether laser-rifle shot X interesets player A's head, the best of all cases is when the algorithm knows the exact position of every object at the time the laser was fired. In the real world, we are not always so lucky. Sometimes the truth information we receive is more sparse. For example, if player A is a remote player on another computer, you may not know exactly where they're going when you fire the laser and need to calculate the shot. In this case, you need to create an estimator for A's position, typically with interpolation or extrapolation. The difference between the two is whether you have data that is bounded on both sides, or only one side. Let's say that Player A has already announced their truth position for t=0 and t=1. Player B shoots a laser at t =0.5. In many situations Player A's announcement of their position at t=1 can occur before Player B pulls the trigger. Why? In many games, the responsiveness of the controls is less than perfectly instantaneous. In a racing simulation, much of the player's position is bounded by the physics of a moving vehicle. You may choose to announce a "future position" because you know you really can't steer all that much in a short period. If you have information in the future, you can interpolate between the two values. What if you aren't lucky enough to have a t=1 value? What if Player A wasn't in a position to announce their future location, and you're stuck deciding whether you hit or missed with only the information from t=0? In this case you have to extrapolate. In extrapolation, you use what you know about the motion to extend beyond any data you have. You might know that Player A has a certain velocity, so presume that if you multiply that by time, you can get a position at each time. The difference is in the behaviors. Interpolation requires you to have an upper and a lower bound, which you do not always have. However, in nearly all situations it has vastly better results than extrapolation. Extrapolation can easily lead to unrealistic movements. Consider the case of a player who is sidestepping left and right to avoid being shot while advancing. At any given point, their velocity is along a diagonal, so if you extrapolate, the player may appear to run off to the side when, in fact, they never do. If you only do interpolation, the values tend not to stray outside realistic values. Interpolation and extrapolation are two extremes in the world of filtering. There are many many many many many filters out there for handling data like this which mix and match properties between interpolation and extrapolation. Accordingly, don't be surprised if you see algorithms that are not clearly interpolation or clearly extrapolation. Those two are just the tip of the ice berg.