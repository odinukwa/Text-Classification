You shouldn't increment from 0 every frame, you should increment from the object's current position. 

I'm not sure about Android, but Python can't run on iPhone. Currently the best tools for deploying a game on Windows, Mac, Android, and iPhone would be to use HTML5 or Unity3D. There are a bunch of other tools that are lesser known and thus less vouched for, like Ideaworks Gamestudio. 

This is what Adobe AIR is for. Personally I wouldn't really recommend that approach though, because it's not really optimal for each platform (especially not for mobile). I would recommend use Flash to develop for desktop browsers, and then port to a mobile development tool like Corona SDK. 

This isn't an article, but there is a chapter in the book The Art of Game Design by Jesse Schell that discusses a concept that Walt Disney referred to as "weenies" in reference to dog handlers holding up a hot dog to control where the dog is looking. The most famous weenie Disney used was the castle in the Magic Kingdom; visitors to that theme park were inexorably drawn toward the center by the castle visible right from the entrance and throughout the park. In the book, Schell talks about using this technique in the Magic Carpet VR ride by painting a stripe on the floor to guide player's to the throne. More generally, a "weenie" is anything that draws the player's attention. Once their attention is drawn in that direction, they tend to move in that direction. One of the best ways to draw attention is to place a desired item over there. Your example of the bananas falls under this; a lot of games will put gems or ammo or health packs on the path they want the player to take. In fact, the bananas in Donkey Kong Country are discussed at length in a couple articles on $URL$ Most of the other ways to draw the player's attention are specific examples of using contrast. For example, a bright spot in a mostly dark level will draw the player's attention. Similarly, a sudden change in the audio will draw the player's attention. If you think about those old Hannah Barbera cartoons then you'll recall how a different colored bush (or something in the scenery) told you something was about to happen there. When done sparingly, it can be fun to play with this trope. For example, when the player is suspicious that the desired item or differently colored door is tricking them into taking a more dangerous path. You don't want to overdo that though, or the player will feel like the level designer is just a sadist. ADDITION: Oh yeah and enemies can be placed to guide the player. Enemies are an interesting sort of guidance tool because they can be either attractive (the player tends to go towards the enemies) or repellent (the player tends to avoid the enemies) depending on context. How powerful the player is relative to the enemies, what kind of reward the player gets for defeating the enemies, etc. are all factors affecting how enemies affect the player's choices. 

However, it is probably sufficient to do the first form assuming you never bind the swapchain backbuffer RTV anywhere but the 0th slot. Also, be sure to use the following just before you start doing the swap chain resize: 

This code will always fail because you did not fully initialize the rasterizer state object which also sets fill mode, winding mode, depth bias/clamp, depth clipping, scissors, and MSAA line AA modes all together. And once you create that state object, it is immutable. To change any setting in that object, you create a new one with all the states specified. The DirectX Tool Kit for Direct3D 11 provides a lot of basic functionality that you may find useful for replacing old D3DX9 and concepts like "Draw*UP", common used state object combinations, and a bunch of stock programmable shaders you can start learning from. Take some time to really learn the Direct3D 11 API basics before jumping into a porting job for an old codebase that is not even really up to the programmable shader model for Direct3D 9.0 (circa 2004). Start with the resources at Getting Started with Direct3D 11 and the samples on MSDN Code Gallery. When you've got a good understanding of how to program for Direct3D 11, then take a look at the seminal 'porting from Direct3D 9' presentation Windows to Reality: Getting the Most out of Direct3D 10 Graphics in Your Games. All those recommendations would apply to moving from Direct3D 9 to Direct3D 11.x as well. 

Level design boils down to setting up decisions for the player to make. Thus, your first step when designing a level is planning out what decisions you want the player to make. Once you've planned out what decisions the player will make in your level, then you can more deliberately lay out elements in order to support those decisions. Note that the decisions aren't always complicated, and in simpler games it may even be the same decisions in a bunch of levels, in which case all those levels are just different permutations of the same set of decisions. Breakout is an example of the latter: in every level you want the player to make decisions about whether to chase after the falling power-up or stay under the ball. In a more complex game you'll be setting up decisions about which path to take, decisions about how to engage each enemy, decisions about when you use various resources, etc. 

By default, the Direct3D 10 device interface is 'thread-safe' if you don't use D3D10_CREATE_DEVICE_SINGLETHREADED. This means it should work from multiple threads, but could well have lock contention. Direct3D 11.x splits the device into two parts: a Direct3D 11 device interface which is always 'thread-safe' (again unless you use D3D11_CREATE_DEVICE_SINGLETHREADED), and the Direct3D 11 device context interface which is explicitly not 'thread-safe'. This essentially lets you create resources on multiple threads, but you can't 'Map/Unmap' them from multiple threads. Now all that said, D3DX itself may or may not be thread-safe. Are you using the 'thread-pump' mechanism? Note that D3DX is deprecated. For Direct3D 11, you can use DDSTextureLoader or WICTextureLoader. They are 'thread-safe' unless you provide a device context for auto-gen mipmaps. See this MSDN topic. 

The main thing to remember is that only affects the struct/class layout, is respected for local or global variables, but has no affect on heap allocated memory. In other words, it doesn't matter if the member variable of a class is marked with alignment if the class is allocated with . Heap allocations by default with x86 (32-bit) are only 8-byte aligned, so you have a 50/50 shot of getting the required alignment that way. By default x64 native (64-bit) alignment is 16-byte. Otherwise you need to make use of to get other alignment behavior from heap allocation. See MSDN for some more notes on this. 

I suspect you would run into copyright troubles. On the one hand, copyright law does allow fair use exceptions for parodies and documentaries that criticize the original work. On the other hand, this description does not sounds like a criticism: "it's supposed to be a gory hard core M game" That's not criticizing Pokemon, that's making Pokemon:XTREME 

For bullets they generally don't bother simulating the bullet actually traveling through the air and simply put a bullet hole on the target the instant it's fired. Other things like rockets are slower* and the game actually shows them traveling through the air. At the short distances the bullets will be traveling, along with the time lapse between frames, they would get from the shooter to the target between or within 1 frame anyway. *That is, slower than rockets in real life, in order for the player to see them flying through the air. 

is the address of the container object itself, not the address of the data you stored in it. Instead use 

VS 2013 Express for Desktop, VS 2013 Pro+, or VS 2013 Community include the full Windows 8.1 SDK. This includes the system headers for Direct3D 9 (d3d9*.h) as has been the case since Windows SDK 6.0. The problem is that your Direct3D 9 code likely makes use of the deprecated D3DX9 library such as D3DXmath, FX9, the original HLSL compiler, etc. You can switch to use the D3DCompile APIs and FXC.EXE which are in the Windows 8.1 SDK which supports shader model 2.x and shader model 3.0 profiles. You can use DirectXMath in the Windows 8.1 SDK. However, FX9 and other parts of D3DX9 are only available in the legacy DirectX SDK. In order to use the DirectX SDK with VS 2013, you have to reverse the long-standing path recommendations in your VC++ Directory settings to put the DirectX SDK include/lib paths last rather than first as they are now outdated compared to the Windows SDK. See MSDN for details and some other notes. 

I would guess that your slowdown is because you are calculating a path for all characters simultaneously. Calculating a path for one character is fast but if there are two dozen characters in the scene then that can bog down. Instead you should spread out the load over a few frames. Stagger your AI updates so different characters update their path on different frames. It would be really noticeable if a character didn't react until a second later, but just one frame is not going to cause bad reactions. 

You need to use Resources.Load() in order to load objects by name. Basically, put your model in a folder called "Resources" and then they can be loaded using the Resources commands. If the models aren't in a "Resources" folder then the only way Unity would know about those assets is to link directly as an array of meshes (ie. what you're already doing and want to change). 

VS 2013 only supports Win32 desktop development when hosted on a Windows 7 system. You can certainly develop a DirectX app on such a system as a Win32 desktop app, but there's no built-in magic template to get you started. You create a standard Win32 desktop app, then add support for Direct3D from there. See Direct3D Win32 tutorial. PS: The Windows 8.1 SDK is included as part of VS 2013 Express for Windows Desktop, VS 2013 Pro+, VS 2013 Community. You can download it as a standalone as you did as well. 

You shouldn't be loading the model every frame. Just load it once and render it over and over as needed. Also, you should create the and once and reuse it. 

Rather than use the legacy D3DXMath, consider using DirectXMath instead Plus you get all the source in the header. This computes the matrix as a row-major, right-handed matrix: 

You can't really go to a game development company and have them make your idea. Unless of course you have a ton of money to pay them to make the game for you, in which case you aren't so much getting another company to make your game as funding a game company. Besides what people have said in other answers, refer to this page on Sloperama: $URL$ Near the end of that page is this great explanatory metaphor: 

ADDITION: Y'know, I think you may be overcomplicating things based on "it certainly doesn't belong in the entity object". If there is some information about the entity that your application needs to continually refer to then stick that information in the entity and provide a getter; if not, then don't. If you really need/want it, provide one level of indirection; the EntityFactory class has information about what script to use when making intances of Entity. That is how I would design things for the use case I'm guessing you're getting at, since all Entity instances would reference the same script, but really it depends on your exact use case.