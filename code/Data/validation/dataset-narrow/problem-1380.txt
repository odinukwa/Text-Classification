In my articles I wrote about a possible solution to your problem. In my vision of ECS, I group the systems according their context and level of abstraction. When I talk about context, I mean the scope of the systems. For example, are the systems handling enemies? Are the systems handling weapons? Are the systems handling the player? Once I give a context to the systems, I group them under the same namespace, like PlayerSystems, EnemySystems and so on. Level of abstraction is instead about how abstracted a system is, for example: is it the system that manages the general physic collision? Or is it the system that manages the collision between enemies and enemy targets? The latter is less abstracted than the first one. In this scenario, what I would do is to let the general system, that manages collisions, communicate with the less abstracted systems. The communication could happen through an observer, defined in the same namespace of the abstracted system and used by injection by the other systems. Alternatively (and that's what I actually do), I let the systems communicate through the components. The EnemyTargetColliderSystem knows exactly the same component used by the PhysicCollisionSystem therefore knows when an enemy collides with something. At that point it must check if something is a valid target. This is just one way to solve the problem, it really depends if you want to take advantage of the computation already performed by the PhysicCollisionSystem. If not, you can simply perform a collision check between all the enemies and possible enemy targets inside the EnemyCollisionSystem. Be careful that I call it enemy target and not player. It would be wrong to let an EnemyEngine know about a component relative to the PlayerEngine. if you want to know more about my point of view on ECS, you can read my articles starting from this one: $URL$ 

One informal way is to observe the world around you. Watch the kind of objects and interactions you have every day. See what makes people happy or what captivates them. Is there any way that can be used as the basis of a game? Or can you add it to an existing game in a way that makes something new? Mull it over, try playing a mini prototype in your head. If it doesn't have potential, move on. If it does, make a real prototype. Spend a lot of time thinking and observing. Eventually you will have a lot of ideas that aren't good enough and some that are. 

As a player, one thing that makes some games stand apart from others is getting the movement animations right. They must feel natural and not forced or be distracting. A few examples: 

Acorn $URL$ 2D Graphics Mac OS X Free / $49.95 for advanced features "The image editor for humans." Pretty simple, but powerful enough for many normal image tasks. Pay features include: BÃ©zier Curve tool, Layered Screen Shots (really nice), Clone Tool, Levels, plugins, and more. 

so let me understand, you have a grid based datastructure and you use raycasting to analyse the data in it? If so, what you should use is simple a recursive search. IF you make iterative will be even faster. Simply start from the tile where your character is and then test the adjacent ones using indices. If they are island, repeat the operation until you don't find any. Look for Breadth Search on Grids for further information. It's more or less like you described, but you don't really need the raycast. 

I had to write a computationally expensive routine that runs in 20-30ms. This routine cannot run in the main thread since it would kill the frame rate. The routine runs on demand, when some data change. I wonder what would be better to use in this scenario. While I think ThreadPool will be all right, I wonder what would happen on an extreme scenario where just one core is available. Would it be better than to create a new thread every time and set the priority to below normal? I wonder though if, in this case, I would end up with the routine struggling to complete within a decent time (although waiting 1-2 seconds would be all right) My guess is that the ThreadPool is always better in a multi-core scenario, however I wonder if in a single core scenario, creating a thread with lower priority could be a better solution (since I don't care if the computation last longer than excepted). 

However, I've seen a few examples on the internet that look interesting, but I don't know how to properly code in these styles, nor do I know if there are names for them. These might not be the best examples but hopefully you'll get the point: 1: 

I'm working on a 2D platformer game, and I'm having a lot of trouble with collision detection. I've looked trough some tutorials, questions asked here and Stackoverflow, but I guess I'm just too dumb to understand what's wrong with my code. I've wanted to make simple bounding box style collisions and ability to determine on which side of the box the collision happens, but no matter what I do, I always get some weird glitches, like the player gets stuck on the wall or the jumping is jittery. You can test the game here: Platform engine test. Arrow keys move and z = run, x = jump, c = shoot. Try to jump into the first pit and slide on the wall. Here's the collision detection code: 

Although definitions can vary, I wouldn't define Unity3D as an Entity System engine. When we talk about Entity System, we should follow the Adam Martin definition. According his idea, the Systems should be created by the programmer, while in Unity3D the "systems" are predefined in the engine and cannot be extended. This is an old way to manage Entities and Components, it's more an evolution of the ancient technique where game objects were holding pointers to components compatible with the engine functionalities (like rendering, culling and so on). Of course when is not possible to extend the "Systems" functionalities, the only way to extend the logic of our entities is to add logic inside Components. This is anyway a step forward from the classic OOP techniques. Component Oriented (I call them Entity Component, without System) frameworks like the one in Unity, push the coder to favor Composition over Inheritance, which is surely a better practice. All the logic in Unity should be written inside focused MonoBehaviour. Every MonoBehaviour should have just one functionality, or responsibility, and they shouldn't operate outside the GameObject itself. They should be written with modularity in mind, in such a way they can be reused independently on several GameObjects. Monobehaviours also hold Data and their design obviously follows the basic concepts of OOP. Modern design tends instead to separate data from logic. See for example the MVC or MVP patterns. Data, Views and Logic should be separated to achieve a better code modularity. The real problem with the Unity Entity Component design is about the complexity needed to put two entities in communication in a reasonable way that doesn't lead to the use of various anti-patterns. Unity inverts the control of the creation of entities, thus the coder doesn't have any control on the creation of them. Inverting the creation control is a good thing, but Unity doesn't do it in a proper way. Not being able to inject dependencies in Entities is a limitation that forces coders to use anti-patterns in order to overcome all the intrinsics consequences. Eventually the cleanest option available is to use Singletons in order to share information between entities. That's why is quite hard to manage and maintain big projects with Unity. I wrote a lot about these problematics in my blog. So if you want you can continue reading my thoughts there: $URL$ $URL$ $URL$ $URL$ $URL$ $URL$ $URL$ In these posts I extensively discuss about the Unity3D design flaws that hinder the development of big projects and both IoC container and Entity Component System framework as possible solutions. 

There is a third option: have a small number of scheduled updates for tasks that can be independent. Scheduling one update method for each layer could be useful, especially if they are logically separate. One useful example of this is using one scheduled method for the main game logic and another to update the score display. 

Take a look at for finding what fixtures contain a point and use for having objects follow a mouse. I have some sample code, but no time to simplify it for you right now. If you need it, I can provide it later. 

I would experiment with exploiting the fact that Mahjong has two sides. Left/Right to control which side you are on. Up/Down moves to the next tile up or down the same side by row/height. e.g. When pressing Down: if there is a tile at a lower height than the current selection, move to that one. If not, move to the highest free tile in the next row down. Pressing up can move up in elevation or up to the next row. 

I am trying to replicate the wave gun from Super Metroid where the bullets fly along a sine wave path. The cool part is that you can shoot in 8 directions and the bullet still follows the sine as if the whole sine function is rotated. I've tried using a 2d transformation to allow shooting in every angle but I cant get it to work. Here my code so far (JSFiddle.net). If you uncomment the line "Axis.dir += .02;" in the fiddle to start the rotation you'll notice that the black box doesn't follow it's axis at all. 

I'm coding a 2D sidescroller using only JavaScript and HTML5 canvas, and in my game I have two problems with shooting: 1) Player shoots continous stream of bullets. I want that player can shoot only a single bullet even though the shoot-button is being held down. 2) Also, I get an error "Uncaught TypeError: Cannot call method 'draw' of undefined" when all the bullets are removed. My shooting code goes like this: When player shoots, I do and after that: 

What are some good approaches to procedurally generating an infinite 2d level? The level could be constrained in either dimension but not necessarily. The approach that makes most sense to me so far is using a grid-based radius. e.g. divide the play area into a grid with squares of a certain size and then load X squares in a radius around the player. Then when the player moves to another square build the next set and drop the farther (Persisting explored area is not necessary.) When a square is built, it contains a random arrangement of objects. When objects leave the outer ring of squares they are removed from the world. Are there better or different ways? Or if this is a good approach, what are potential issues? For discussion's sake, you can think of the level as a top down asteroid field with power ups, etc scattered throughout. 

I don't really have any tips on exactly how to achieve this, though. A lot of it must be attention to detail combined with trial and error.