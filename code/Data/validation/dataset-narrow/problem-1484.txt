I believe something is lost when you simply copy and paste code. They say that to learn a definition of a word, you read it, say it, and write it. So I think typing code definitely adds value, especially when IDEs like Eclipse have autocomplete and syntax checking. Typing is a learning experience. Unless you are copying from a raw format, copy and paste could bring in invalid characters. For example, try copy and pasting "hello world" from Microsoft Word to your favorite code editor. You'll see invalid double-quote characters pasted. 

I think it depends on the goals of the course. Does your course have specific objectives for working in a team? Is the primary goal to learn some aspect of programming? I teach a software practicum course where students must collaborate like a real software engineering team using an Agile Development Methodology. All the work they do is shared. Learning to work in a team is an important skill. But if the primary goal of the course is to teach programming fundamentals, web development, game programming, etc., then I would lean toward individual assignments. It's so crucial to practice programming. You can maximize this with individual assignments. 

I briefly discuss spacing, braces, and general readability. Then I open Eclipse and demonstrate [Ctrl]+a, [Ctrl]+i. This instantly indents your code according to a default standard (which is configurable). Since there are so many concepts to cover in class and limited time, this is one shortcut we take. 

Tracing helps students really understand what's happening in the recursive calls. It's also an important tool for when they develop their own recursive functions. If it helps to trace regular function calls, then it helps to trace recursive ones too. 

There are endless examples that illustrate selection. As you know, most useful programs have at least one selection statement. I've found that some students struggle with the concept, so I start small and pick examples that resonate with students, for example: 

Recursion is sometimes difficult for students to grasp. It's important to understand the concept before implementing it in any programming language. My college professor said that recursion may not make sense today, next week, or next year. But one day it will come to you, maybe when you least expect it. I show this image to help students think recursively. Next, I'll start with a simple recursive program to calculate the factorial of a number. In class, I simulate recursive calls with pieces of paper. I start by writing fact(10) = 10 * fact(9) on a piece of paper. Then I write fact(9) on a new piece of paper and pass it to a student. The student adds to it by writing fact(9) = 9 * fact(8), writes fact(8) on a new piece of paper, and passes it to another student. This process continues until a student must calculate fact(1), which is simply 1. Then all the papers bubble back up to me, and I calculate the final answer. But even with these relatively simple examples, sometimes it takes time to understand recursion. More simple examples help. 

This sounds like a question of vetting. Here are some things I do when evaluating Node.js libraries: 

It depends on the situation and your school's policy on academic integrity. At my school, it clearly states that authors may not knowingly permit other students to submit their work. You may want to ask your school to update its policy to include a clause like this. You will have to determine if authors know if other students submitted their work. The author could be a student in the current class or another class. The author could be a stranger online. In a previous class, I suspected that one student submitted another student's program. This was confirmed when I saw that the filename included the original student's first and last name. After discussing this with both students, I resolved it. I can't say that I follow a hard and fast rule. I think it depends on the situation (severity of the violation, actions of both parties, etc.). 

I think the first port of call would be to bring up the subject of handling criticism as a dedicated class session, including how to extract useful feedback from poor criticism, and how to make criticism (which they would be expected to do in the event of a code review, both reviewer and reviewee). They're adults, bring them on the level of both giving and receiving, and they should understand both sides. On the other side of the fence, how to criticise I find boils down into two categories: 

I find some people hate being told what to do, and will spurn it even if it's the most logical choice. By alerting Joey to the problem, the solution, the reasons for that solution and the fact there might be other solutions, allows Joey to see the problem as an impersonal thing for him to solve (he didn't create the mem alloc error: he has to solve it), he has one known solution, and the freedom to research other unknown solutions. Joey can either see your solution as the easiest, might devise his own solution (which might be surprising - as a student, he should be learning, not merely copying), or might just choose to ignore it, in which case he suffers the consequences (bonus points if you can create a scenario that causes the error), including any subsequent markdowns on program's performance. Final trick If you want to be really hands off, there is one question that will get most people to reconsider a piece or line of code that doesn't require explanation: What happens if ... What happens if this ProcessArray hits a mem alloc error? What happens if this switch statement encounters an unknown case? etc 

Subjective (EG this could look nicer) Objective (EG if you don't implement this, it will crash, and bad things will happen) 

Joey has a couple of choices here. He can consider you've got a fair point, and might go for it, or, better yet, Joey will present the list of arguments as to why he has it on a single line (maybe 'no-one else will see my code' or 'I'm doing a contest on fewest bytes used on code gold'). At which point you can either explain why not building it for other people in mind is bad, or concede there is a reasoning behind it. This approach I find is excellent in team situations because the suggestions aren't forced, and it allows people to argue for/against a particular criticism. A dialogue occurs, instead of an argument. Objective This is where real problems begin. It's not because Joey has made an error, but if he continues with the error, stuff will catch on fire, the world is going to end and goto loops will become fashionable again. As a result, you're required to put your foot down. Before approaching, I find it works extremely well if the opening dialogue starts 'this is nothing personal, but...'. Psychologically, people think it's reverse psychology and thus terrible, but when you point to the code, this helps reinforce it's actually not. The criticism should be kept short, matter-of-fact 'if this happens it will do this' (if this has no try-catch and it throws an exception, the stack is going to crash and the system will go boom). Explain what-why and how to fix it. You can help reduce the sense of it being a personal failure (the main driver of being defensive) by either indicating it's a common problem or that it's a hard problem to spot. Joey might still get defensive, however: trick is to not rise to the argument. So, for example: 

When I want to give an example of how inheritance works, I always point to C#'s class. The class is an abstraction of the idea of a data stream from which bytes can be taken or to which bytes can be stored. Its child classes include which represents the data of a file, which represents data in memory (RAM), which is an adaptor to provide an extra layer of data buffering, and which represents a layer of encryption. It's a very abstract example, but it's a real world example that highlights how different implementations of the same interface can be incredibly useful. It demonstrates the use of virtual functions, abstraction, the dependency inversion principle and the liskov substitution principle. Any can be wrapped in a , , or to handle the ability to read/write data more complex than bytes. These are also good examples of the decorator pattern being used 'in the wild'. ( and in turn inherit and , which are themselves another good example.) 

The latter on the other hand should be encouraged. Wanting to learn beyond the scope of the assignment is a good thing. It's a sign that the students want to be doing this and that they have the potential to become good programmers because they're inquisitive and willing to put in effort. Don't crush this, simply tell them that they are only allowed to do extra things like that when they have fulfilled all the other requirements. Perhaps enforce this by making students show you their work when they are finished so that you can give them permission to start adding extra functionality. Make it clear that the assessment is about providing "what the customer wants", not about showing off, and that any 'extra features' will be completely ignored and won't impact anyone's grades. 

The former is potentially harmful. Stress that they will get no points for having a good looking website and that they only get points for functionality. Perhaps even enforce this by restricting the students to using a colour palette that you have selected or requiring that they only use default colours if the environment provides them. If students are forced to use a restricted colour palette then they cannot spend time tweaking the colours. Perhaps also consider being specific about where their elements should be placed. For example, require that button X should be in the bottom right hand corner and that button Y must be in the left hand corner. They can still move things by a few pixels if they're that obsessive, but they won't be burdened by the desire to keep reshuffling all the elements. Alternatively, make the students design their UI before doing any programming and penalise students for deviating from their design for cosmetic reasons. (Allow deviations for things that genuinely cause an issue, but require that the student documents the issue.) These suggestions not only kill the problem, but they also force students to exhibit skills that they might need in a work environment (documenting changes and fulfilling the customer's requirements). 

There's also nothing wrong with admitting that you don't know the answer. A little anecdote: (TL;DR: encouraging students to check the documentation instead of asking you is a good thing in the long run.) When I was learning programming at college my programming teacher didn't know how to use the open file dialogue in winforms, so I simply went away and asked the internet instead. That was a good thing, it gave me practice at referring to the documentation and made me realise that in fact my teacher did not know as much as I originally thought. Once I had gotten used to the documentation I stopped asking my teacher and started referring to the documentation first. Before long my teachers were sometimes asking me questions.