Here is the rule of a thumb I use. Whenever I think that I need to write a comment inside method body, I ask myself three questions: 

You do not check for in and in equality operators. You probably should, since both and can be null by your design. You should re-use single equality implementation. For example, should just return . 

is a static lookup which is resolved at compilation time, so it does not look like you gain anything by caching the type or it's full name. Are you 100% sure that equality guarantees that types are equal? :) It probably does, at least in your case. But, for example, I would still rather use: 

Mat's Mug made some really good points. I would like to add a few things. I don't like the class. What will you do when you'll want to have a spear? A gun? 10 other weapons? 10 more items, which are not weapons? Your class will quickly grow to a point, where it will be real pain to maintain. This looks much better in my opinion: 

Why is it static? Do you really want multiple instances of your client to fight over the same lock? Looks weird. Your implementation is not thread-safe. That's risky. Synchronizing a single class even with all async's and await's flying around should be way easier, than synchronizing all the other places that are going to use . However it is definitely possible to design an application in such a way, that thread safety is not going to be an issue. 

I am no expert on malicious code, but I guess the only way to know for sure what works best is to run some packet analyzer software on both client and server, and see for yourself. I feel like your implementation uses too many threads. loop probably hurts more than it helps. It speeds things up only if you execute a sufficiently complex task on every iteration. Sending 1 byte over network is not complex at all. Try replacing it with regular loop. It is also unclear what in stands for. Why it is and not, say, , and why you should "sleep" at all. If it is required, then maybe it should be a property of your session, and not a hard-coded value. Clients implement , so you should dispose them at some point. I also don't see why you should create a new client on every iteration. Can't you re-use single instance? Another obvious thing to try is to run multiple clients on multiple threads. Maybe it will work "better". Maybe not. P.S. As for your thread safety concern: see SO answer. So no, calling or in parallel from different threads in not thread safe. 

I think you need to implement a cancellation mechanism. In worst case scenario you will have to wait for almost 20 seconds for to return with no way to interrupt this operation, except for maybe aborting the thread (which is hardly an option). This might not be as important for server-side application, but it is extremely important for clients, who should always have the ability to close the application or cancel pending operation. In general, I think using is almost always a poor design decision, and it can always be replaced with a wait handle of choice. Edit: here is a simple example of cancellation, which uses tasks: 

Calculator has no interface. I think it should. And it should be very clear. I don't want to know implementation details, I don't want to call factories and all that stuff, that doesn't even fit the screen: 

1) I would save constants (, etc.) as fields, so they don't take up extra space in already fairly large method body. 2) I think your use of is fine. However you can also rewrite it without . At first glance it boils down to: 

no longer violates MVVM and works well with DI. Also, prism uses plugin-based architecture. You define regions in your , and then implement independent modules, which are plugged into those regions at runtime. I don't see you doing any of that. I think you should spend some time reading prism documentation. If you do it right - prism will wire your views and viewmodels automatically based on convention and you won't have those problems. Personally, I hate convention-based design just as much as I hate service locators (including ). But if you chose to use prism, you should play by its rules. Fighting it or doing it wrong will only make things worse. 

Your code is not thread-safe on many levels. Even if you replace regular increments/decrements with methods from class, you will still need additional synchronization to make sure, that is not called while is running. Term has a specific meaning in context of Unity, so you should probably use different word to avoid confusion. I don't know what is the recommended way of doing these things in Unity. In absence of TPL (I assume Unity still uses .Net 3.5), the easiest solution I can think of, that does not require good understanding of threading, is to return WaitHandles from your async methods: 

I can't say I fully understand your design, since you don't really give any explanations as to why you implemented it the way you did. But if I were to suggest a better design off the top of my head, I would probably go for something like this: 

can work with so its not necessary to pass list to it. Same goes for : you do not have to call at the end of your first query, you can loop through initial enumeration. With LINQ you can join strings like that: 

Your class is not thread safe. By exposing field, you introduce race condition. Your method will fail if some other thread changes right after , but before . You must either hide this field or replace it with property with "locked" setter. Your class is not optimized. What happens if your hard drive is busy? Or if you specify network path and your network connection lags? In those cases it might take seconds (in some rare cases - even minutes) to write to file. If your application is not yet frozen at this point, it will freeze while waiting for , if you happen to call method again from UI thread. Your class is also not optimized for cases, where method is called often. Your class is buggy. It won't write anything to log, if there are less than 25 elements in the buffer. So for example, the last error, which is also usually the most crucial one, is almost guranteed to be lost. 

And initialize it in constructor. It is cleaner and requires less code to write. Also you might want to create another constructor for your command, that passes for by default. 

as any other read operation, removes read data from the stream, meaning you will never get the same string. logic is too complicated. The only code you really need is this: 

The meaning of those fields is extremely unclear, and the suggestion to "add all parameters you need" sounds like a bad idea. What if two events need different sets of parameters? What if one of them needs two floats? How will this architecture evolve then? I see two ways to make this class reusable. 

Instead of exposing your collection via property, you should implement appropriate interfaces on BinaryHeap itself, such as (or , or w/e depending on what you want to expose) and make the underlying collection . This: 

10) Maybe this is intentional (I have not been following your previous questions), but this does not look very safe: 

A strange thing to ask, given that you modify your collection yourself inside method. Consider not purging your collection during enumeration, and regular loop will throw alright: 

A few other things: 1) Your implementation is not thread safe. It is not clear how you are going to use it in multi-threaded environment. 2) Reopening file stream for every log message is inefficient approach if you log frequently. You will get a better performance if you keep the stream open for a lifetime of your app. If you rarely write something to log, than your approach is fine, I guess. 3) This looks weird: 

As for implementation - caches should be implemented on repository level. That's one of the main reasons why people bother with repositories in the first place. Whether and how queries are cached is an implementation detail of repository, it is not consumer's responsibility to cache results in simple scenarios. You can also eliminate copy-pasted code in your methods, if you utilize generics, since it boils down to: 

Some white spaces between operators and braces would be nice. A minor thing, but it really helps reading the code. 

I don't like your intro screen. It feels like it consists of two separate screens (1 - where you try to recall your name, 2 where you clean up). As it is - it is somewhat difficult to follow the execution path. I think instead of being a protected method should be an actual screen class which accepts options as constructor parameter. That would simplify reading. I dont like the use of an observable collection, i think it is an overkill. And it exposes the methods it should not. A simple wrapper around List which only exposes and methods would be much batter. At very least - collection should not be public. should probably be a protected property of your base screen. I think is confusing. Imho you should not manipulate properties which you use as an ID. Its better to make sure that all the green bags are called "GREEN BAG" instead (by saving it to constant field, for example) In general, i do not like implementation which uses hardcoded strings. I think that proper implementation should use scripts or (if the implementation should be C#-only) XML parsing. But i guess its a bit too much work for a two-hour challenge, right? :) 

You can easily reuse those rules by setting correct country-specific parameters (such as exact percentages or rule description) in constructor. And, even more importantly, you can now write proper unit-tests to test every rule in isolation. DeductionType is enum. Why? Is it a fixed set of values, that is unlikely to change? No, it is the opposite. With every new country added, you will have to modify it, adding even more values to this already confusing list. property is more than enough. Employee validation is part of Employee class. I think there two different approaches to validation, that serve different purpose. First is to implement validation inside the class to prevent developer from making mistakes. In this case validation rules should be simple and universal and exception type should be accurate (I want , if argument is ). Second is to implement separate validator, that would have a more complex and more specific validation rules that prevent user from making input mistakes. This validator can then be extended or replaced to further tweak its behavior depending on user environment. You go for the first approach, yet validation logic is too complex, exceptions are inaccurate and rules are not universal (for example, for some reason I am not allowed to use or whitespace in my country's name). There are some other things. should probably be immutable. There are too many projects for such simple program (over-engineering). is useless, since it has single non-generic implementation (over-engineering). But those are minor issues. 

My point is that there is always some sort of trade-off, and one approach might be better than the other depending on use case. However, by combining those two approaches, as you do, you are likely to get the downsides of them both AND gain non of the benefits. So I suggest you pick one or the other, and stick to it. 

Edit. Here is implementation, just to give you some idea on what I am testing. Feel free to review it as well, however it is not complete (some trivial extension methods and helper classes are missing) and I am more interested in feedback on unit tests. 

I don't like property, as it makes things ambiguous. Is it safe to call ? Or will I modify some existing static field? Well I will have to go and check the implementation to know for sure. I would rather just call instead. Or if you have something against using default constructors. I think you should merge and methods. It doesn't look like does any meaningful work and you can easily declare array inside . Also since you already check for string being null, you might as well return early by calling: 

You should read Naming guidelines and apply them to your code. should be a local variable. Otherwise calling more than once will produce incorrect results. There is no need for to be . should be a constant field. You can use and methods to pad the string with spaces (or any other character) from both sides. Instead of manually doing it in hard-to-understand loop. 

clearly should be of type . That is what for. can be safely refactored to with used as keys. Then can be refactored using method, and can return dictionary itself, or . I think the latter option is the best, since it will copy the collection, which will restrict access to property. As of now, someone might modify it in outer code, which will result it modifying ShoppingCart state. Returning a copy will prevent that. cast can be removed. I'm not sure i like the idea of having two methods to add items to the cart, which have different logic. It's pretty error-prone. Is it really necessary? I think you should probably stick to one. I think your shopping cart interface misses method. 

The second version is over-engineered in my opinion. The code bloat it introduces is obvious, the benefits are not. I think this api: 

I don't like the fact, that result generates itself. I would rather have two separate classes: one to run a benchmark and one to represent benchmark result. Also calling some method makes much more sense semantically than calling .