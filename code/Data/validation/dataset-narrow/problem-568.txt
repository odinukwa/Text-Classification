Yes this can be done better. Storing data in a serialized format in a database (be it JSON or XML) is a bad idea more often than not. The main issue is that you will have a hard time querying for specific items in the serialized blob (e.g. trying to find which member has liked which images). The basic thing you can do is to normalize your data by introducing a table: 

So the states themselves execute the code required for the transition into the next state given the current token. You can also pass around a context object if required. 

Consider checking for and abort when it's true (apparently the passed in string wasn't long enough). Depends on your usage though. Alternatively to the previous point you could add a parameter to let the caller supply the information of how long the sequence really is. I would consider changing the interface slightly. Have some methods which manage the object for you: 

Classic off-by-one error. You reserve space for 3 additional entries with but you add 4. and will be out of bounds on the last iteration (last valid index is and respectively) expects a NULL terminated array of NULL terminated strings. So the last entry in needs to be NULL (otherwise how would know how many arguments to pass when starting the process?). 

Users can define their own node types and associate any meta data they like with it. The internal implementation of how nodes and edges are stored is hidden from the user as they do not have to concern themselves with it - neither should they. 

I'd use rather than - somehow sounds more natural. You should make more use of rather defining a bunch of delegate types. For instance this: 

So train yourself to write well structured encapsulated code even for seemingly simple things because it will form a habit. Even if you don't want to develop software professionally in the long run you will find it more rewarding when you do it right. 

At first I didn't really like the implementation with the local but upon trying to re-implement it I realized it's difficult to restructure the code without making it actually more confusing - so fair enough. can't deal with any of it's parameters being . For you could check for and return or throw an . should probably have an thrown. Same goes for the naming convention functions: You only check for . This means you're never expecting arguments in which case you should use either use contracts or throw s or return empty strings. However given that this is a plugin meant to be used in Visual Studio as you edit you probably don't want exceptions bubbling up, so dealing with inputs might be desirable from a user perspective. I think can be simplified a little bit: 

You parse the CSV fields as yet you use an - I'd go for the generic in that case. Your CSV parser is broken in the general sense - i.e. it can't deal with things like this - it would split the value in the middle. Given your data that might not matter but it's probably easier to look for a 3rd party CSV parser on NuGet to future proof it. Given that you ignore invalid lines in the CSV file anyway I'd consider changing the implementation of the CSV reading into an enumerator which avoids reading the entire file into memory. Something along these lines: 

If all the methods look like in the provided sample implementation then I see several approaches to make your factory method cleaner: 

Depending on how the objects are used rather than building two inheritance hierarchies (one for request and one for parameters) you could make the request objects generic. So something along these lines: 

If I read correctly then it accepts arguments starting with . Given that seems to be the one letter abbreviation this means if I specify an invalid argument which happens to start with a letter of a valid argument then will return true. If you call on an argument which does not have (i.e. doesn't require) a parameter it will throw an as will only have 1 entry 

Is that basically correct? If yes then this smells to me: If you have a member in a class of type then this basically says: "I want a factory which can create objects for me and do not care what they actually do" while in fact this is big fat lie - why else would you decorate with an attribute saying "actually this requires a very specific functionality factory"? If the application requires that object Foo gets injected with a specific functionality factory then express it by making the type rather then - no 200 attributes, no 200 kernel bindings. Now you will probably say "What about unit testing"? 

In the end the size detection can be generalized by finding which byte is the most significant byte - which boils down to finding the most significant bit (the highest bits which is 1). There are a bunch of clever operations to make this really fast but the simplest is to shift right until all set bits are shifted out: 

Your list does not have a nice API to use. You can see that in which is cluttered with handling of many special cases. Some methods like ( would be a different candidate) are inefficient as you have to iterate the entire list first. You could avoid that by keeping a separate pointer. 

Not sure what the and stand for but they should be given proper names reflecting their meaning. When you read the bitmap you allocate an array to hold each pixel. Yet you only read one pixel at a time and you also only need it to determine whether or not to add it to . This is a waste of memory You only need to have a single structure to store the temporary data in (and you should check the return value of ): 

I think the xml doc comments are ok although in general mostly I'm dubious about documenting the backing fields as well as the properties. I typically like to keep them together like this: 

Let's look at your code from an extensibility point of view: If Sheldon decides to add a new item to the game then you have to go to classes to adjust the comparisons and winning verbs. I usually try to avoid such designs because whenever you require a developer to change stuff in places when something new is added then he/she is bound to forget one place. So how can we change the design? Well, a game seems to be suited for a rules approach especially since the rules are fairly simple and always of the same structure in this case: 

Modifying the loop variable inside the loop generally falls under the category "Don't do this" because it makes it really hard to see what is going on and can easily lead to very hard to find bugs. Attilio's answer already shows how to refactor this. I just wanted to mention it explicitly because it's a bad habit you should dump sooner than later. Another comment mentioned that you read in a string with but the location you store it at can only hold two characters. So if the user types in a longer string then you open yourself up for all kinds of memory corruptions which will lead to very strange program behaviour. This can be fixed by limiting the length of the string to read: (you should use because will automatically add a terminating byte). 

Neither nor pose any type restrictions on . So I don't see any need for imposing an restriction in the implementation. The other option would be to keep the restriction and make actually use of that interface (i.e. ) is the wrong abstraction to use. is meant for objects to provide a sort order as it has the concept of smaller, equal and greater. For your purposes you simply want to test for equality - so you should use or instead. 

The structure of the resulting string is much easier to see with (and it's also less code). You do something like this fairly often: 

Your current implementation is somewhat flawed as relying on to get the type name is dangerous. is meant largely to yield or short meaningful description of the object for debugging, logging etc. already yields a - it is totally unnecessary to convert it to a string just to then turn it back into a type again. If your repositories all have a parameterless default constructor you can avoid calling entirely. 

When throwing an exception because the argument violated a constraint then you should consider mentioning that in the message. Simply "Invalid foobar" is quite useless to anyone using it. A message like "Buffer size must be 128 or larger" would be infinitely more helpful to the programmer using this class. should be able to be called more than once without any side effects. In your case it would throw a because you set to null. A check should suffice. Adding a flag is another option. In the times of Linq as a user of your class I'd appreciate it if it would implement to iterate over the rows. I'm not 100% of the full purpose of . It looks like it could simply be expressed as boolean flag to indicate whether or not there a row is currently available. I think the design of the private methods needs to be cleaned up. They have some inter-dependencies for the various state variable (like buffer and row positions) which are not easy to follow. 

The best refactoring was mentioned by slaks though: Get rid of the implicit mapping and assign the codes directly to your enum values. In general: Try to accept the most generic collection type possible - this will give the users of the function more flexibility regarding passing in the arguments. I find nothing more annoying than having to make a temporary collection to satisfy some interface which expects a which might not even use the fact that it's a list. "Be liberal in what you accept and conservative in what you produce" - I find that approach quite useful not just in data processing but also for interfaces.