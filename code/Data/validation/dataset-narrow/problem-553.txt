The structure of a binary file is different depending on what option was used. For example the size of the prefix is 78 and 278 bits respectively. My purpose is to provide user-friendly interface to parse data from oscilloscope. Result I chose to place all stuff in the which I named . 1. owon namespace structure The following is just a short description of the namespace. 

creates an instance requests connection with If agrees to connect then it asks its to register as a sender, after that registers as a receiver, assuming that has instance 

Discussion Neuron class Emit function The main problem I see is that this function might be waiting for a long time before return. This is because of recursive process of signal propagation. The worst case is when all the receivers has almost full dendrite and get the last signal from a sender and emit theirselves and this process repeats until the last neuron in the propagation chain. is it a problem or I am missing something? Creation of Dendrite and Axon I have and as a pointers. So they are initialized as in the constructor. When they are needed they are created via operator (note that instance can have only one instance of and ). I suspect that it smells like potential memory leak. Would destructor resolve this problem? Dendrite class Struct Synapse I am not sure about declaring inside a class. Is it bad practice? The motivation is I do not need to use that struct outside of this class. And also I need to store 's together with its status and weight. IsComplete function I see that I check if signals from all senders have been received by iterating over entire dendrite tree while having function that already responsible for setting statuses of senders. Is it actually a problem or kind of a design flaw? Mediator class As you could see and has a lot in common. I am thinking about create a class to place all of similarities inside it and then inherit from this class. What do you think? So let me know what do you think about it. As always any suggestion, critic or help would be appreciated. And sorry for a lot of material. 

I am writing this smart pointer as a learning exercise. Any feedback would be most appreciated. Any flaws? Have I missed any test cases? smart_pointer.hpp: 

I am preferring to remove all the printing stuff from the class interface and use the operator<< overloading idea in 200_success answer like this: 

Is that the standard way to do function pointers to member functions in C++? Any comment on that would be interesting. I guess it could look a bit daunting to someone not familiar to std::function. I won't change the code in the review at this late stage. 

Question 1: functionxxx_as_string() is used below. How else could it be more elegantly named? Question 2: Is the static char* array method adopted below the only solution? Best solution? Any suggestions? Generally, I have this issue where my list of enums will be from 3 - say 50 items, mostly less than 20 items and they are fairly static. 

One way to write a client which uses a specific protocol, eg http like in this case, is to create a base class with the basic socket handling functionality with virtual functions which can be overridden with an inheriting derived class. But it is more flexible I think to be able to get the socket handling class to call a function specified by the client. Hence, the tcpclient constructor takes three arguments which are calling client callback functions to handle the asynchronous connect, data received and exception events. But the callback functions are straight functions. It would probably be more flexible to allow member functions to be called somehow. I wasn't sure how to do that. Anyway, I would appreciate any comments on the code. tcpclient.hpp : 

This seems like a desperate attempt to find a use for closures, and I believe your problem would be solved much more simply by making an object, perhaps even a object that lets you overload indexing Some observations: 

There is absolutely no point in asking for a code review of a translation of a non-functional program 

I would personally choose to set up a hash that converted suffix strings to a multiplying factor instead of using a chain of statements. Like this 

Here's my solution The main reason yours is so slow is that it's reading the HG38 file line by line, which means it has to upper case each line and append it to the sequence up to 4 million times per sequence That's very slow because the repeated appending will mean that the string will frequently become too big for the space allocated to it, and it has to be copied to a larger space before it can be expanded. Copying such a huge string thousands of times takes a lot of processor work I have written it so that a whole chromosome is read at a cctime. Then all that has to be done is to remove the newlines and set it to upper case, just once I've also printed the each chromosome's name when it is encountered, to give some confirmation that the process is progressing. (You can stop this by removing the statement.) The time taken to test the introns at the end is minimal As I said, this code produces the results 492784 /499504 that you expect, but I'm still concerned about the end pair of bases. Please let me know if you have an explanation 

Please review my ini file parser (and potentially some general config file formats). The data structure used is a section, see below. Does that seem a good approach? I was wondering about the name. It will parse ini files ok, but unix config files are so variable that calling the class config might be over selling it a bit. I don't support mid-line comments. Only comments on a line on their own are well just ignored. All values are stored as strings. I thought that only the user of the config file will know if a value should be used in his or her application as a string or integer or whatever and onus is on user to convert. Any comments would be much appreciated. Its intended initial use is for Windows ini files. Parsing the configuration into sections. config.hpp 

This simple program uses a socket class I wrote, class socket, to retrieve a users pop3 emails and print to stdout. I would like feedback on the socket class and the code to download the pop3 emails. My main focus is on the simple state machine to go through the steps required to download the messages. It looks a bit ugly. There are probably better ways to do it. main.cpp: 

Update As usual, the solution was staring me in the face. I am confident that the values you extract to and are not character positions but offsets, that may be passed directly to . It was your comment "subtract 1 from end of exon because its 1-based index" that threw me So it is the gaps between the letters that are numbers from zero at the start of the string. Like this 

I have a program that seems to work and produce the same results as your own code. However I have a problem in that the intron doesn't seem to be defined properly Suppose my sequence is the alphabet and the exons we have are defined by 

Assuming this makes the arithmetic much easier, because there is no off-by-one error to account for, and the start and end of the intron are 12 and 16â€”the end of the first exon and the beginning of the next. Furthermore, numbers can be fed directly into without any offset, except that the last two characters of the intron are clearly at (6-2) I've modified my code below to take this into account, and it makes it much clearer to read