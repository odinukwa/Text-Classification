This imports the available library. Although you can use exactly the same code with this on the pi as anywhere else (this is the whole point of "portability", which java stresses), under the hood this library may be very different from one platform to another. But that is irrelevant to your use of it. If the library is there, it is there to be used and unless it contains some defect or bug, it works. Please do not ask "But how do I know if it is there?" since this is a basic java programming task and belongs in another forum. 

Once you rule out the first two, you are stuck with the third option. If you recognize you've made a mistake with one of the first two, beware that you may have created the third problem in the process. You can permanently damage the GPIO system through incorrect use. 

You get a menu of which ones to do. Choose, e.g., . You can choose more than one. You'll also get to choose the default. Log in again and things should be fixed. 

VirtualBox is a hypervisor for x86(-64).1 It does not emulate foreign architectures such as ARM (the category the Pi falls into), therefore it is impossible to run an operating system in it that has been compiled for the Pi. While Raspbian is available for PC hardware, you cannot use it to do what you want to do since these two versions are not binary compatible. 

You are almost certainly looking for something in a directory with no suffix, since this seems to be an in executable (since it was "not found" using only a base name), which probably excludes the first entry (since that directory is not in a standard ). A more fine tuned way to do this search would be , which would give you only those two entries. Anyway, most likely it is the package, so: 

Because of all this, you want to make sure a system backup includes so that if used to restore there is the correct local correlation between names and numbers. Which it presumably does, and in which case yes, the ownerships will be correct. 

1. A exception to this would be, e.g., pi-specific stuff that s kernelspace in order to directly manipulate hardware. WiringPi, pigpio, and the bcm2835 library do this, allowing you to write a more or less pure userspace driver. 

In case it is not clear, there is no such operating system today as UNIX and there has not been for a long time. Instead, UNIX is an operating system standard that includes a number of different existing OS's. To "officially qualify" as a UNIX -- that is, to be counted as such by the people who own the UNIX trademark -- a system must pass a compliance test of the Single Unix Specification. You can find a list of systems in this category on that page under "Registered UNIX systems". None of them, AFAIK, are available for the raspberry pi, nor are any of them open source, so there is no way to compile them for the pi either (which in any case would be a pretty daunting task). However, as noted at the end of that list, the "unix-like" systems, BSD and linux, are non-compliant primarily because they are never officially tested. These tests are not free (I'd guess they are at least well into 5 digits USD), and they need to be repeated for each release and kernel modification. In the case of linux, I believe this would apply to each distribution separately. This would amount to many dozens of such tests per year -- probably more that the current total, just for linux. Since the testing is also not instantaneous, it would also hamper the rapid release model used by the linux kernel developers. In short, the difference between the official UNIX's (which include, e.g., Apple's OSX) and the unofficial "unix-like" OS's, linux and BSD, is perhaps more about a business model than anything else. This is not to say that any given linux or BSD would pass the compliance, since, for the reasons just discussed, this is not a particular goal. It is probably not a completely desirable one from a design standpoint either. However, most people would consider BSD and linux very "unix-like" and both of them are available for the pi. I would check with your school what they consider to qualify here -- it is very unlikely that they only include the officially registered ones since those would cost the school itself an amount of money disproportionate to their actual use value. I.e., they almost certainly include BSD and linux, particularly if your task involves the raspberry pi, since as mentioned there is no possibility of installing an official UNIX there. 

The filesystem appears to be getting corrupted repeatedly, and from the sounds of things, that includes while the system is running and not just between boots, which is when it is most likely to occur if you pull the plug at the wrong time. That should not happen. I would suspect a faulty or worn out SD card at that point. You may also want to check the physical reader on the Pi, if it is a model that uses a full size card the plastic holder can be easily broken without being noticed. The holders on all models can also become lose. However, the holder is most likely not the problem as I think that would cause a very drastic and mysterious failure (as opposed to just filesystem errors) and probably would not corrupt the card (but I could be wrong about that). 

Exactly. You will need to find out what the original partition boundaries were (i.e., where "the same place" is). These seem to change slightly over time with Raspbian images, so if the card was created a while back and you do not have the original image it was created from, you may be out of luck. If you do have the image, you can get the boundaries like this: 

You actually had me searching though logs to find a similar example of a REDACTED message, lol, until I realized you just meant the hostname. Anyway, that one's a pretty standard one post boot, and the is a timestamp in seconds since the kernel started counting. In other words, this is from about 15 seconds after a reboot, and other messages leading up to it should confirm that. If you didn't trigger this, you should look backward through the log to before the last message (there are a surprising number of things that happen in the first microsecond), which should be a note about the logger starting up, at which point it dumps these cached messages from the kernel (they don't actually appear in the log in the first microsecond, but by 15 s they should be). Any messages from right before are from before the system shut down and that may include a clue about about what triggered the reboot. Even if it appears innocuous, anything from 8:10 or 8:15 onward is worth scrutiny. 

A file is compressed using a proprietary format; the problem with this is that FOSS tools which reverse engineer it will may end up behind the curve if the people who distribute the proprietary versions (e.g. WinRAR) tweak it. There's a in Raspbian which apparently does not work for all files. There's an in Debian wheezy, but in Raspbian the actual binaries are missing; obviously they have not been compiled. However, there is source for that in the file. 

This is a fair bit of work, but it is a "want my cake, eat it too" = bake cake first scenario. A simpler spin would be to have a background logging app start at boot, and a completely separate foreground interactive app that can read the log. However, this is no good if you need the user interface to be able to control the logger. 

Here's the script which is going to run the two programs. I'm presuming you want them to run root, there's no indication otherwise and so we'll call that a separate question. 

Note that "SSH is not running" is not on that list. If this were the problem, you would immediately get "Connection refused", because the operating system does in fact reply if no application is using the relevant port. I have observed that it is possible for a system to be assigned an IP address that works to initiate and maintain connections, but the router still fails to route other parties who wish to initiate a connection with it (i.e., the Pi can access the LAN and internet, but nothing can access it unless the connection was initiated from the Pi). 

1. I left that video running while writing this and after 17 minutes, still no taskbar. Exciting stuff. 

If you don't have a system that can access ext4 filesystems (a Debian "live CD" is a good choice here), then you're stuck. You'll have to reflash the card and start again. 

Currently Raspbian still puts a copy of everything into . You need privileges to access this file, i.e., either or use or or . You are looking for the messages that indicate the beginning of the last boot; these will begin something like: 

I never use the stock networking config system on linux; over the years I've developed my own scripts to do everything I want. I don't even know how to do anything properly, in fact, because it has been so long since I did so (which is why I rarely answer networking questions here). This isn't something I'm recommending to others, but just to point out that you do not have to use any existing system services in order to arrange a network connection. First the obvious: 

This is clearly and simply documented in the kernel docs. I will not bother to regurgitate it here. Note that you can't use with because of redirection, but that does not impact what you are trying to do. Anecdotely I'd say using if using high level stream functions doesn't work on sys/proc nodes, use lower level methods. I don't speak lisp so I don't know how relevant that is. 

It looks to me like there is a distro cross-compiler installed on the system. It uses the same tuple, , but it is almost certainly ARMv7, not ARMv6 (i.e., it will work for the Pi 2 but not other models). Sort of a dumb/ambiguous thing about that naming scheme. The reason you don't have that issue with g++ is the C++ version of the compiler must be installed separately, and evidently it is not installed. You can confirm this with . You'll probably get: 

The limitation here is it's only the current moment. There are GUI monitors that will show a graph going back in time slightly -- two popular ones are and . Finally, for checking the logs for error/warnings, in addition to Patrick's suggestion about , you can check: 

A raspberry pi all by itself is not, in fact, a truly embedded device, although it is akin to one and might be used to create or develop such things, which is why there is this association. But it is really a general purpose computer like a PC. Many embedded contexts involve systems which are much, much more limited than the pi; 512 MB of memory is easily several orders of magnitude greater than such systems. Raspbian comes equiped with udev and that's what you should stick with. 

Presumably lightdm is configured to use the same virtual terminal (aka. vt, there are 6 or 8 of them accessible via ctrl-alt-F[n]) every time. If so, you just need to figure out which one, and you can then use: 

If you want to include the directory used by , you will need to add it to your . directories generally contain executables and if you you'll see a number of them there. If you had installed from the distro package, , then likely it would be in a normal system . However, the distro version (0.10) is probably older than the one installed by , and will not get updated as often (presuming , or you, update stuff it installs). To add to : 

Will filter for packages whose name starts with . That's a bit of an excessive list too, but the relevant package is presumably . For more details: 

You should end up with just a plain terminal on the screen, no titlebar, no borders, and the X mouse cursor. You can start other applications and move around with the cursor but there are no menus, etc. If you substitute the name of the lone application you want to run for , you'll start with that instead. 

Not necessarily -- PHP scripts can be executed in the same manner as python -- but in an apache context you are correct, they are not persistent. 

I specifically bought one of these because it supposedly contains four of these, which are supposedly used in robotics and recommended by the manufacturer for, e.g., (presumably small) electric vehicles. That was probably pretty ignorant of me electrically speaking -- I am now thinking what's important is how the voltage is regulated, not what the power source is on the other side. Power banks are sold fairly explicitly for charging, a use case which is going to have greater tolerance for fluctuation than actually operating an electronic device, and what's more, probably often (as in the Gogyre G2 example) include "over current" protection which may curb sudden instantaneous draws of whatever magnitude, and that's exactly what a CPU revving up and down will do. Anyway, that's speculation from an admittedly (electrically speaking) ignorant person, but what happened with that battery and the Pi 3 is the undervoltage indicator (a little rainbow square upper left if you are using a display, and a flickering power led) does intermittently indicate an issue. It does not stay on for more than a second or so and there does not seem to be any real problem, but I haven't used it that way beyond a few casual hours.