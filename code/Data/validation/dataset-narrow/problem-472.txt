You are checking the primality of the same numbers several times! Extra optimization can find a divisor, not just check primality. Optimized algorithm 

note the use or instead of . Another interesting optimization is changing the iteration in from descending to ascending. This should speedup it up considerably as it would terminate early more often: 

The way quick sort is defined (requiring random access) it cannot be efficient for linked lists (especially immutable ones). I recommend a recursive implementation of merge sort. It will be clear and concise. It should also be relatively efficient. 

it in . Style Avoid in favor of . is better written as . Avoid mixing and : keep conditions in and side-effects (like ) in . Repeated and Each (and et al) allocates a fresh list, so doing a repeated can waste memory (and garbage collection cycles), so either using 

You compute twice - this is a waste. You return instead of the improved guess, i.e., you return a worse approximation than you could. 

Trivial Use instead of . Avoid very long lines (Emacs will indent for you). Do not use when a single without would do. Memory Use instead of when possible to avoid unnecessary consing (in your case, allocates a fresh list, so its result can be passed to ). Catastrophic Whenever you use , you are using the wrong algorithm. Optimal search is linearithmic: . Insert search is quadratic: . Your implementation is : 

The only part missing from that match is the end, the last . I would use another regex match to grab that portion: 

I have little experience with python, so I can't offer critique on the finer points of your code, just the big picture. That said, several things stick out to me. First, you have some large chunks which are duplicated two, three, or even four times (see lines 198-215). Scour through the code and extract these into their own functions. Second, several of your functions are massively too long: (161 lines), (97 lines), (228 lines). , once you get rid of the previously mentioned duplication, could easily be broken into two functions: the finding and the scoring. is too long simply because it contains all of the input handling. The section within the block starting at line 435 absolutely should be its own function, if not more since it clocks in at 144 lines. Finally, and this is more observation than critique, your classes do nothing but operate as organized data structures. This isn't necessarily a wrong approach, but it would look good if you were to refactor your code to be a bit more object oriented, especially since this is intended as a code sample. 

Honestly, your loop doesn't seem that complex. I would probably ignore this warning in your case, at least until it grew in complexity or the surrounding function grew in size. In any case, here are some things you could change: a. Add a variable to replace the five instances of . b. Off the top of my head, I'm pretty sure an EC2 instance is only going to have one "Name" tag. You can extract this loop into a separate function if you feel comfortable with this assumption. c. If your lint rules / personal style allows for multiple returns, you can reduce the depth by returning from the error. 

However, no such allocation happens with so there is no reason to avoid nested reduces. Note that the proverbial "sufficiently smart compiler" should be able to handle these problems (but not necessarily the quadraticity above!), so you should only worry about this if you discover it to be the performance bottleneck. Remember (SICP): 

is C/Java style. Lispers use or . is clearer than . Lispers use indentation, not paren counting, to read code. Your code is thus virtually unreadable. Please use Emacs if you are unsure how to format lisp properly. 

Minor Paren placement Hanging parens are an eyesore. Global var Use instead of to create global variables. Sharp-quote for functions You should do instead of . Unnecessary allocation Since your returns a fresh list, you can use instead of . Major Sum Your function is broken - it will not work on long lists, see . Here are better ways to do this: 

Doc string (no more than one, but it can be multi-line!) usually comes before the declarations. Please see Syntactic Interaction of Documentation Strings and Declarations: will define a function which has no docstring and return , while will declare a function with a docstring, returning . should be . should not be used if you know that the object is a ; use instead. There is no need to bind and in since they are used just once. is, I think, more "idiomatic" than in your case. It is clearer to use in . 

Furthermore, It segfaults on me when I give it lines longer than 119 characters. (But this is probably system dependent). 

Generally speaking, anonymous (unnamed) functions are completely acceptable within the land of Javascript. They are used frequently and without prejudice, so don't be afraid of them. That said, I'm not a fan of the second code sample. Without an understanding of the jQuery API, I don't really know what the two functions do to the hover call. Are both called, one after another? Perhaps something else happens? The name doesn't really give any clues here. I think a great option here would be to combine the two samples. Use the anonymous functions of the second with the explicit naming of the first. Furthermore, it should be noted that according to the docs, is shorthand for and , not and . I'll let you read over the docs and decide which of the two you decide to go with, but ultimately I recommend going with something like this: 

Regular expressions are tough to read (human wise). As such, if you have a gnarly reg-ex in your code (), you should comment what it does. Furthermore, using regular expressions to check the total length of the string is inefficient and not necessary here, since you already have to check the length to report an accurate error message. As such, consider validating the username and password like this: 

Lisp is a multiparadigm language. is just as lispy as recursion, and, in a way, much more so (think in HOFs)! Style 

Implementations The first (HOF) version can be much more efficiently rewritten in using (provided returns fresh lists): 

You do 17 iterations when only iterations are necessary. Recalculations Now compile to turn recursion into a loop and see: 

This has the added benefit that the return value increases in (i.e., it returns the of your function). Alternatively, you can actually avoid constants: 

Note that takes so you can write instead of (you also want instead). Furthermore, is quadratic in length of the input string - it can be made linear instead. is a usually used as a prefix for iteration macros. Also, you call in twice; you can use to remove one call. Your line breaks in are very confusing. You can use instead of in because returns a fresh list. Summary I think your code is overkill. 

You are doing fine, other than a few simple nitpicks. You are not using (which is a crazy thing to do anyway), please drop it. You should fix your indentation, it would make your code much easier to read. You probably want to divide by , not , in and you probably want to simplify the code there by dividing by instead of multiplying by the reciprocal; also is relatively expensive, so, if you were not i/o bound anyway, you might want to replace it with multiplication. Function should probably return multiple values instead of a . Global variable should be local to . Function should probably be called (it read the whole list). 

In my opinion, a factory should create a specific class, global ones like this one shouldn't be used. For instance, having a PizzaFactory is something like this: 

I indeed suggest to make it static, so you can call . I think factories are the only things that are allowed to use static methods. But I think this is not something you do in a factory. It looks like it is some autoloading function. Factories create classes, they don't autoload them. You should use an autoloader (which you register with the function) to load classes. A autoloader looks something like this: 

Never ever use . That's a deprecated form of ; Avoid using on your properties, you want to have controll about the value of every property in your class; If you use or doesn't make much sense. Protected means it can't be accessed from the outer scope, but it can be accessed from another class which extends this class. Private means it can only be accessed from the class where it is defined. I like to have getters/setters for every property and never use directly inside my class, some other don't like that. See also this article by Fabien Potencier: "Pragmatism over Theory: Protected vs Private"; The operator, or , should only be used by accessing class constants and static vars/methods; Avoid using static vars/methods; Use or to access properties from the inside of a class. It works just like you use it outside the class, except that you use the variable (which contains a reference to the current instance of the class). 

I have a couple of issues with the main function. First, may work for windows but won't elsewhere. You should dump it. Second, Too many returns at the end. Third, The hardcoded input makes it kinda hard to test (and doesn't look good). Just read the first parameter from the command line or read in from standard in. Here is an easy way to do so: 

The path is one of these two options. In the first path, done is clicked first. In the other, want is clicked first. 

Finally, you have several magic numbers. To make code maitenance easier, define variables for constants like colors, strings, and timeouts. 

is always one less than size, so you don't need that variable. Just replace all instances with . Similarly, could be replaced with . 

To guard agains the previously mentioned bug, we need to check if not null. I'm including only the function. 

Moving on to the "did"/"done"/"done again" button is a little trickier. "I already did it" will be visible so long as the want count is 0, and "Done it again!" will be visible after the want count is 2 or greater, but "Done it!" is more complex since it only shows up on one of the state machine paths (step 3/4). It turns out it is visible when the want count is 1 and we did not click the done button first and the done count is 0 or 1. This all leads to this block of code: 

I think you mean that you want to know if this is correct MVC and, if not, how to change it. It is better to put all those logic (except the first line) inside a Model and call that specific method inside your controller. I have used CI once, so I can't help you with code examples... 

At first, you are requesting the element 4 times. That means jQuery need to search to the entire DOM 4 times to get an element. Cache the value of this element and use that cache variable: 

You should not use inline HTML (e.g. , , ). This should be done with CSS in a stylesheet or within a element. 

An upcomming design pattern is depedency-injection. Just search for some resoures about that and keep reading. It is used in all modern frameworks (ZF2 and Symfony 2 uses it). See also this article serie by Fabien Potencier: "What is Dependency Injection?" 

The difference is that you seperate the concerns in the second example. This means that you can change from database type (e.g. a SQL database, a XML file, an array, ect.) without changing to much code. In fact, you only create a new Model and you are ready! 

inside the callback of the method refers to the animated element, you don't need to use again, just use . You use once, just use that constructor instead of saving it to a variable. To complete correct code: 

Acknowledging the state machine, look at the "want"/"want again" button. The text will always say "I want to do it again" after the done button has clicked. Essentially we can boil it down to this: 

If we consider these two buttons a state machine, we see that there are six simple states (not including hover). 

It's not so horrible. You managed to cache your jQuery selectors, which is more than a lot of people can say. Good job there. 

You are caching , but really, it's not complex enough to warrant caching. I did some quick and dirty testing and found that you save about 10ms per 1,000 executions. That is not worth anything here. So, to reduce code size and bug potential, I suggest removing all caching. 

But having a list is just fine. Not knowing anything else about your requirements, I would leave it the way it is. The thing that really sticks out to me in your code is the use of a callback as a parameter in . Since this function is not asyncronous, I would ditch the callback and either log the error directly to the console or just throw the error and let it break the build. If you really want to provide a mechanism for reporting configuration errors to the user, then rename "callback" to something akin to "errorHandler". The use of the name "callback" usually signifies a function that will be executed once and only once, will be executed when the function has completed, and will not return a completed value but instead pass the value as an argument to the function. Also, I find it surprising that you do not log the time to the output of the file or console logger. Not a big deal of cource, it just stuck out.