_signPlane is an array of Vector3 using the following formula and applied for each plane once per frame when the frustum is updated: 

EDIT I've made a huge mistake in my previous explanation. GetButtonDown() is fired only during one frame when the button is pressed as well for GetButtonUp() when the button is released. So to know if the button is hold or not, you have to check state changes when GetButtonDown() or GetButtonUp() are true. For example, you have a variable "buttonDown" wich is a bool(true, the button is down / false, the button is up). When GetButtonDown() return true, you can assume that the button is hold by user. So you assign true to "buttonDown" and you only change the value of "buttonDown" when GetButtonUp() return true. 

I've just tried to draw it normally and it appears at the center of the scene. After that, i don't know what to do to make it appears at the bottom left of the screen regardless of where the camera looks, as if that was part of the UI. 3DSMax has the same thing at the bottom left of each frame. 

Now I have three models to draw, Model1, Model2 and Model3, each one use a different technique from the previous list. If I add those three models in the render queue I will end up with the following render queue : -> Set state A -> Draw Model1(Pass1) -> Draw Model2(Pass1) -> Draw Model3(Pass1) -> Set state C -> Draw Model1(Pass2) We can see that the Model1 will be drawn two times (two passes for the Technique A) but the draw call are separated by others draw call. I don't know how to resolve this. What will be a good solution to this problem? How can I design my render queue to reduce state changes as much as possible between draw calls. EDIT: After searching a little more, I have found this helpful article : $URL$ It seems to be an elegant way to sort object by depth and materials. And in the material id, I can had a pass id to sort same pass together that will allow to reduce state changes. Currently my renderer draw objects directly in the backbuffer without lights nor shadows, everything is flat. So I will just loop over my render queue and call draw methods. But in a future I will probably implement deferred rendering. I don't know a lot about it but I know that I have to render my objects in different render target to gather differents informations (Z-buffer, Normal buffer, G-Buffer, ...). I assume that for z-buffer and normal buffer I will use the same shader on every objects no matter which material they use. But for the G-buffer I will use the materials of each object so that means different shaders with different number of pass. If I use the solution in the previous link, if I have an object with a material that needs to do two or more passes, my render queue will have at least two times the object (one for each pass). But for Z-buffer or normal buffer isn't it useless to have the same object multiple times? What I see is that I will need to have at least two different render queue : one for G-buffer in which an object can be multiple times depending on the number of pass the material require and another render queue for Z-buffer or other buffer in which each objects are only one time. Am I right? 

I think would mean how many pixels to advance on the line to put the next character. I have 36 characters but I want upper and lower case to output the same image. I need this specifically for libgdx but this would probably be the same for any tool that uses a . In addition I have a file that came with the sheet that includes the characters allong with the other images. 

We can still use this vector for our rotation since nothing has changed there. If we a origin of and a target of the previous direction vector would have been . what we just did is shrank the length of it to 1 by maintaining it's rotation. If we do this to all our vector movement we have a equal starting magnitude of 1. Now let's make a velocity vector. At this time I have to warn you about how LibGDX deal with vectors. A vector is passed by reference by default and it's methods will work on the method itself. So if you do Then not only both velocity and direction have been scaled by 100, velocity is just a reference of direction. If there is something strange going on 99% of the time it's because of this. It gave me headaches when I started out with LibGDX. But luckely, we can just copy the vector. 

How to setup the rendering and camera for isometric gameworld projection? And specifically how do i get the images exactly the right size? What angles to use to get the exact 2/1 isomtric view? Methods to set the camera on the right position? Options to set like anti alias off. I have tried many things, 45, 30, 35.264 degree angles. What i do is set the angle of the camera, then place the camera in front of the model then use dolly/fov/lens settings to get the left and right edge of the model lined up with the save frame. Then adjust camera height so the bottom lines up with the bottom of the save frame. But i keep getting jagged edges and not the isometric style 2 width one height. 

Based upon this I will create my abilities. I used a build pattern for my ability class to help myself out. Just look it up, it's easy to create. Here I create a stun shot. 

I finished my game while I was unaware of this error since it only shows up when I disable "WIFI" on my phone and testing it with and . Otherwise, when both devices are on my personal network (and I believe the same network in general) the game works perfectly fine. Whenever two players connect via my own I have setup on Amazon AWS services I get this error in the Unity console for both players. I am running both the Unity and on the server. There are many question around the internet like this but not a single one with a answer. If this is really not easily fixable Unity should at least mention it's flaws where it provides the MasterServer. I would love to have an answer or at least some insight since now I have my own Linux server on Amazon I'd like to use it too. Currently it looks like my best alternative is using the multi-player options from Google Play Services. This is the log I get from the server. Looks perfectly fine but it might help answering. 

I am refactoring some parts of the game engine I am working on. This engine is made in C# with XNA. The part I have trouble with is shader/material and the render queue. In the new version I will give ability to indicate differents render states per pass within a technique (blend state, rasterizer state, ...). In my engine, all renderables have a material and each material is associated to one technique (thus to one or more passes). Later, when the game will be running, I will add renderable objects to the render queue and then sort it based on the pass used by each material. What I want to achieve is to reduce states changes between draw calls by first grouping same passes together and then passes with nearly identical states to be as closed as possible to minimize changes. But this solution seems to be problematic when it comes to use technique with more than one pass with completely different states. Passes within a same technique can be completely separated in the render queue and not rendered one after the other. If I say that it's because I have always see multi-passes technique render in a loop and all passes rendered immediately like that : 

If you don't have a WP7 and only a desktop computer the best solution is to use the WP7 Emulator. You can find more informations here: $URL$ If you have installed the latest version of XNA, the WP7 emulator is installed at the same time. If you don't have it, you can get it from here: $URL$ You can also read this post on AppHub, someone else had had the same problem as you: $URL$ 

Input.GetButtonDown is fired during the frame when user pressed the button. The function return true only one time when user pressed it. From the Unity Script Reference: Input.GetButtonDown() 

$URL$ Edit: Sorry for the french reference but i haven't find any date on the english wikipedia. The translation is: 

I'm trying to implement an axis-aligned bounding box with center/half-size instead of min/max. And I have some problems when it comes to create a method to detect if the aabb is visible or not. I try to do the same as on this website at "Method 5": $URL$ I'm trying to implement this formula: 

I'm creating an application which allows the user to manipulate 3D models. I would like to draw 3 axis representing the world coordinate system in 3D in order to give the user an idea where he is. These axis are represented by a 3D model. Now I want these axis to be always shown at the bottom left of the screen. I know how to draw them but not how to project them at specific coordinates on the screen. How can i achieve this? EDIT: I use XNA. The axes have been created with 3DSMax, each axes is a cylinder surmounted by a cone. When I load the 3DSMax file, I get an instance of the Model class. 

But I don't know if I can deferred pass rendering from a same technique instead of using them one after the other as in the previous example. Here is an example of what will probably happen with the solution I try to build: