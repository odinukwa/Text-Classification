Use member initializer list instead of assigning to members in constructor's body. It would be cleaner if would be set to (if in C++11 or above) or / (otherwise). Change argument to if you are pre-C++11. Otherwise use move semantics when constructing from . And also possibly add overload anyway. 

in loop condition is risky. Once you change to () (as commented above) for would wrap around and result in maximal positive value. The loop would be infinite. On the other hand note that alternative results in infinite loop for being already maximal positive value. (Which however seems less likely than being .) In loop use rather than . On modern compilers with integers it doesn't matter really. But it is cleaner to write so. And could make a difference if would be an iterator rather than integer. So it is better to have good habits. 

Unused local variable. I would write instead of . Feels more natural. But in the end there should be no difference. You are making no check against exceeding maximal positive value for . Change argument to if you are pre-C++11. Otherwise use move semantics when constructing from . And also possibly add overload anyway. 

I think you are mixing up different concepts here. Presentation logic is quite different from domain logic and both shouldn't be mixed together. I'm having trouble understanding what you are trying to achieve (what does the checked status means in your domain?), however in my opinion a should be expressed in domain terms and should not have any knowledge of specific ui data such as visible, checked...etc. I strongly suggest you to read about MVC. There are lots of MVC, MVP, MVVM... flavors in JS and that's why we mostly categorize these as MV* rather than MVC now. 

I guess this plugin could be useful, however I think you can drop the async part since it's not any harder to call directly. Also, I am not a huge fan of error swallowing or ignoring invalid calls since it makes the code harder to debug. If there's a call to without providing a callback, you should let the developer be notified. I also like to allow defining the value for the callback function so that you do not need to use for that purpose. Finally I allowed to return a value from the callback to change the target object for the rest of the chain. However I am not so sure about this feature since it could harm code comprehension but I am leaving it there as an idea. Basically it would be as simple as: 

And so on. When you're done, every number will either be 0 (if the index is prime), or it will be the count of prime factors of that index. Now it's as simple as finding the first four contiguous fours. This solution takes around 130 milliseconds: 

If you're working through the Project Euler questions, you should become familiar with the Seive of Eratoshenes. Not only is it a very simple way to generate a bunch of prime numbers at once, but it's an algorithm which can be subtly modified to solve other problems. In this problem, we want to calculate how many prime factors each number in a range has. We've going to be testing a lot of numbers, so it would be great if we can calculate all of the factor counts at once. And we can! First, pick a safe top number that we're going to test up to. I'll guess that the answer will be a number less than a million. Create an array of a million zeros. It starts as an array of zeros, but we want to transform this array so that: 

Instead of writing to use exceptions. There are also other means (like returning error code). But outputting to is of no use. (And seems more adequate anyway...) in loop condition is risky. Once you change to () (as commented above) for would wrap around and result in maximal positive value. The loop would be go crazy (although it would not be infinite). Instead of that you could start with . In loop use rather than . On modern compilers with integers it doesn't matter really. But it is cleaner to write so. And could make a difference if would be an iterator rather than integer. So it is better to have good habits. You could extract the loop fragment to separate () method which returns of given position. It would make code somewhat cleaner. And also you could reuse the method in other functions that I recommended to add (in comments above). You should first store in a local variable. Then set to . And only then the local variable. Current code uses of already deleted object and sooner or later will crash on that. I would write instead of . Feels more natural. But in the end there should be no difference. This method is badly implemented anyway. For example on a list constructed with the single element constructor calling will actually the node from but will never update member. Maybe changing the condition to (and next to ) would correct it. But since the idea of is likely wrong this method would change anyway. 

I would strongly advise you to modularize your code to make it testable an reusable. Since you are using jQuery, you could use the widget factory. I have created an example for you, perhaps it will look overkill and it might be, however it's just an example. Also, I strongly advise you to read how to write testable javascript. HTML 

The algorithm will probably not be an order of magnitude faster (slower? could be!) than a bunch of ifs or a switch statement, but it will definitely be more readable. It also has the advantage of being dynamic, since you can add or remove keys from keysToIgnore. Note: If you have to perform the iteration process many times, it could be faster to simply filter out the keys using and the algorithm described above. 

EDIT2: Here's my implementation packaged within a reusable function. I know this is an exercise and that it's probably not meant to be reused, however it's worth knowing how to do it ;) 

EDIT 3: Actually I've created a performance test that compares different solutions and it seems that using a map isin't the fastest way and it's actually slower than performing a double replace. I must say I am quite surprised. Anyway, here's the fastest implementation I could write: PERFORMANCE TESTS (includes @200_success solutions) 

There is no need to make public. and need it but client of your library doesn't. So consider hiding it from him. For example by defining within the class. 

Consider making it so that it cannot be used for conversion. Add also second argument being count of initial elements. And default it to . It would make the constructor a bit more flexible and little cost. (And also it will match typical STL container constructors.) Change argument to if you are pre-C++11. Otherwise use move semantics when constructing from . And also possibly add overload anyway. Use member initializer list instead of assigning to members in constructor's body. 

Consider having also a which uses and returns from . This would allow to iterate over object. With some template magic this could be done with single implementation. 

It could be useful to forbid copying of objects as it seems there is no use in that. To do that use if you have Boost. If you don't then either explicitly "delete" copy constructor and assignment operator (if in C++11 or above) or make them without defining them. 

For this code to be usable, it has to be completely 100% thread safe. Can anyone see a hole in it? Also, am I just re-implementing something that already exists in some corner of the .NET base class library? For the sake of context I'll provide a practical use: there's a long running application, and some code that must execute if a file exists. The file might exist when the code first runs, or might come to exist later, or might never exist at all. I invoke it like this: 

But we can do better than this. The above code has two loops: one which calculates the factor counts and one which searches for the contiguous fours. Lets merge this into one loop: that way it will stop generating factor counts as soon as it finds the fours. 

So, by making the member an rather than a , you give it extra semantic meaning that is enforced by the compiler. You do this for similar reasons that you mark members as . 

But that's more code than we need, now that we're following the convention. .NET provides a helper class: 

Implementation incorrectly returns value from . It seems that instead it should return value from . Return instead of as it would not require copying of the object. (But to do that you have to do the same for as commented above.) 

As you noted yourself your iterator differs significantly from what C++ considers and iterator. This means in particular that it will not be usable with any STL function. Or other libraries that use "normal iterators". As a side note I will mention that makes it much easier to write proper iterator. But it requires use of Boost. With your current design as it is how will you know that the iteration ended? There is no method in that says that. With your current implementation (of cyclic list - see comments in ) any iteration would be infinite unless you would count elements yourself during iteration and stop at . 

There are also other possible extensions. For example you could add allocator support. Or allow in-place construction of elements. But those are more advanced topics. Maybe save them for later. 

You should properly define copy constructor and assignment operator. Or at least forbid them (as already mentioned for ). Consider adding other constructors. For example from a range of elements of other list (by positions or by iterators). 

One of the simplest and probably fastest way to do it would be to store the keys to ignore in a fast lookup structure, such as using an object as a map. First you need to build the map, which takes O(n) time based on the number of keys to ignore, but allows you to ignore keys with a condition that will take O(1) time to compute. 

I have re-written the whole code to make it more modular as well as taking advantage of prototypes. The way your code was written was quite inefficient since everything had to be redefined for every newly created instances of or , since the whole code was inside constructor functions. Unfortunately, there is no way to enforce the privacy of non-function instance members without sacrificing the benefits of using prototypes, so I've used a naming convention to identify private members: they start with and underscore _ (it's a very common practice). You will also notice that I've extracted the logging strategy out of the and allowed to inject it instead. I am still unsure about how that feature should be designed (perhaps an AOP approach?), however it's better than having it encapsulated within the class. Anyway, have a look and let me know what you think. Note: I haven't changed anything related to the processing logic since I wasn't enough confident. 

It would be cleaner if would be set to (if in C++11 or above) or / (otherwise). There should be no use for default constructor anyway. (See below notes on .) In fact use of this constructor requires type to be DefaultConstructible while there is no need to require that. 

From implementation it seems to be a cyclic list. Was this intended? I don't follow the idea behind node. I think that it is not needed. Not to mention that it's value could be undefined while it will show up during iteration. The class would be a bit more usable if you could add element at arbitrary position. Given by integer (to make your design consistent) or iterator (to be consistent with previous comment). The class would be a bit more usable if you could remove element based on iterator. Or else allow the iterator to return it's position as integer. But remove by iterator is more in line with C++ (STL) style. The class would be a bit more usable if it allowed also iteration. So should have a overload returning iterator (as commneted above). Size in C++ is usually expressed using type. So should be also positions in your case. There should be a default constructor making an empty list.