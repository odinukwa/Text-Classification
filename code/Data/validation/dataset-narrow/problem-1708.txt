I haven't verified this on Raspbian, but poking around the folder might reveal a relevant file of sub-folder. Open a Terminal (CTRL-ALT-T should work, if you can't find a shortcut), then navigate the folders using the command. Terminal should open with you already located at , so just type and hit enter. will list files in the current folder, you may need to use a few more times. In the example above, you would have to then , and then should show you the files, look for a relevant one ( in the example above). Once you've found a file you want to look at or edit, you have a few options. The world is divided into two factions: those who like , and those who like . Type and hit enter, if it says it's not installed, type hit enter and hold your breath. is the easier one to use, but if you must use , scroll up and down using the arrow keys, when you want to type something, hit first (to switch to "insert mode"), then type. Try not to use backspace, delete or the arrow keys while in insert mode, some keyboards will screw up your text file. If you must, hit to return to "non-insert mode," and hit again when you are ready to type. When you are done, hit , then type (it will appear at the very bottom of the screen) (this will save and close). If you bugger something up and want to quit without saving, hit and type . 

Pulling the plug on a Pi without doing a software shutdown will corrupt the SD card over time. Format and reinstall. 

A typical Bluetooth setup is limited to 7 clients, so in case you are wanting to expand your project at some point in the future to control multiple light switches, ZigBee and WiFi would allow you to control an entire house, not Bluetooth. Most areas, both residential, commercial and industrial are oversaturated in the 2.4 GHz band of WiFi, meaning your system may suffer from interference if you go with WiFi. 5 GHz isn't always an option supported by the hardware for these projects. That leaves ZigBee. It is designed to be low-cost, low-power and easy to integrate. That's what I'd pick for a project like this. 

Interfacing ADC's is a big pain, this one is particularly difficult. There are a few things that make this ADC stand out to me 

The most likely outcome is that you have a hard crash or lock due to bit errors (The likelihood of a register, gate, or sram node flipping of its own accord is proportional to the junction temperature) . As far as I can tell, There is no default mechanism for thermal shutdown enabled on the raspberry pi kernel beyond throttling. Since RPI lacks hardware shutdown, the effectiveness of any shutdown mechanism in preserving the CPU is limited. 

If you have completely isolated or very low priority (diagnostic) inputs, you can probably get away with the naive multi-thread approach, but your application should be robust enough to handle jitter and missed signals 

That is, folder, configs and public keys get set to and private keys to If you are using key authentication, the same must be done for user config and key files under 

simulate this circuit â€“ Schematic created using CircuitLab Separating the loads means less impact if one device dies/shorts or goes berserk. It is also the most obvious place to add a battery, supply voltage monitoring, soft-shutdown, etc. However this adds complexity to the design. 

Application Note: AN2232-02 Bit Mode Functions for the FT2232 API Reference: FT-71 D2XX Programmer's Guide Related Older Application Note: AN_232R-01 Bit Bang Modes For The FT232R and FT245R Example Code (Visual C++) Example 4 Is the Bit Bang Mode Example EEPROM Programming Utility: FT_PROG 

DNS Lookups require a , e.g. When you do a simple name lookup e.g. , unless the name is defined in the file, it will not resolved. However, the setting ` adds one (or more) default domains to append to the dns lookup. Your router will usually have a default domain, for example , but this may be different so look at the configurations 

Try using , you may have a source that is on making all that noise. You can mute individual sources using this app. 

The yellow flashing symbol typically indicates that the CPU is being throttled, possibly because of temperature. Do you have a heatsink? See here for more info. 

There are different ways to do this depending on how big the objects are and what you intend to do with them. Getting the weight is relatively simple, there are USB scales available. The volume is a little bit more involved. The simplest way would be to have a water-filled container with a sensor for the water level. You would submerge your object under the water, the change in water level according to your sensor would be the volume of the object. Of course, this is straight up simple if your object has a greater density than water (it would sink). If it doesn't you'd need some way of holding the object underwater, either by putting a weight on them, or attaching it (little hooks). In this case, whatever you use, just put it in the tank without the object when you start, so that it's volume is taken into consideration by your sensor. Now, water level sensors don't directly give you the volume of water, they only give you the height of water. You can do some simple high school math to get the volume. Then density is mass divided by volume. I haven't seen any USB water-level sensors, so you may need to use the GPIO pins for that. And when you code this, it would be nice if your software has a simple "tare" function, for both the scale and the water level. Since we are talking about submerging objects, get the mass first, since wet objects weigh more. 

This type of problem is actually quite difficult for an embedded device to do. Decoding and multiplexing audio streams in real time is the realm of a dedicated Digital Signal Processor (DSP). Using 8 Output Devices will list the available audio devices You best bet is to write your audio data to a raw audio file Using 8 separate sound cards, you would start each file with a script 

When you interrupt the program, you lose unwritten data in the Userspace buffer, data already written to the kernel (ed) may be cached but won't be lost. However, if pull the power from your raspberry PI before performing an some data may be lost on reboot. Install a Signal handler If this is a program or script you have written yourself, you should install a , in order to "react" to the you have issued. You can install signal handler to and issue , and commands Signal Handlers can be used in all major programming languages and shell scripts. In the context of an application, your signal handler would issue the command or to any open streams/files followed by an per open file for good measure. In the context of a shell script, your signal handler should gracefully close the running process, and maybe a to make sure no data is lost on reboot. Other things to try 

Extract pins from the connector This is similar to your "bare wire" approach, but you leave the crimp pin on the wire end for a more reliable connection 

Details The utility and do not provide a system header, but inevitably they probably use standard linux ioctl calls through the (or, possibly, ) interface to configure the network interface but do not have their own API, possibly they interact through other kernel interfaces, its hard to tell from first look. You have two options that I see 

You have 2 options: Separate SD cards: this is always my recommendation. Repeat the process you went through to install RetroPi, instead install Raspbian on a new SD card. SD cards are both inexpensive and prone to failure. Having everything on the one SD card makes it likely that when the card goes bust, you just may lose everything from both OS's. Separate SD cards is simpler and safer. Multiple OS's on the same SD card: my least favoured option. To make this work, you would need to: 

The most likely issue is that the SD card got corrupted. Sometimes it happens during the creation of the SD card, sometimes it's an improper shutdown. Make a new SD card, and make sure you use the software shutdown process before pulling the plug on your Pi. 

larger int values, which you can specify manually in a 32bit kernel anyways the possibility of having more than 4 Gb of RAM, which is useless on the Pi as the RAM is built-in and non-expandable. 

First go to: Menu > Preferences > Main Menu Editor Check the box for "Default applications for LXSession" Go to: Menu > Preferences > Default applications for LXSession Under the Core Applications tab, notice that Polkit agent is set to lxpolkit. Make the field blank. 

If it's a server, treat it like a server. Setup automated backups off-site (another PC or out to the cloud). If and when whichever SD card you are running fails, setup a new one and restore your latest backup. That being said, a read-only filesystem will reduce the wear on your SD card. 

This is normal behaviour for a Raspberry Pi. Everybody wants to think of them as desktop replacements, but they are not. They pack a good deal of processing power into a small form factor for a very low price and low power usage, but a GUI will make the sluggish, Raspbian too. 

It's the same language, just a new version/revision of the standard and specification.The differences are subtle enough that you likely won't notice. Languages are very formal, standardized things, like dictionaries, maps, or laws. When the standard changes or a feature is added - usually after a long period of debate and discussion - this formal document is updated. Which triggers a new version number. Python3 was a significant update to the existing standard so they went as far as to change the first number in the version field to indicate its significance. However, its "still python" From the python.org page on 2vs3 

No, there is no reason to. is used by to track all computers you have ever logged in to, that way if the key of the remote server changes, ssh will complain that someone is trying to intercept your communication. There is at least one circumstance where it may be necessary, often on LAN you get a dynamic IP that changes day to day, if you have two pis and and then tomorrow they switch places, your laptop will complain that the key for has changed, even though it has simply moved. In this case you may simply delete the offending line in . It would also be necessary after a clean reinstall of the raspberry pi/remote server (sshd generates new keys during system install) 

Typically you mount equipment on standardized "DIN rails", and there area number of cases for the raspberry which have this mounting standard. 

does not need usually conversion, because its an bus, practically all modern devices understand logic. In either case, it is safe to use without any converters in most cases. However, the open drain configuration requires pullup resistors. The operating voltage of bus is set by a pullup resistor. Proper pullups are critical. Since either device communicates fine on its own, this is likely the cause of your issues. The internal pull-up of raspberry pi will struggle with more devices on the bus. Bus Configuration 

Everybody has , it's a system file. You are probably not looking in the correct location. Basically, from the root of the file system are a number of system folders, and a folder called . Home is where YOUR files and folders are, including , and such. You need to go into the system folder called . The simplest way to do this is via the command line. 

Changing partition sizes on multi-boot systems is risky, but if you must, use a partition editor from your desktop or laptop. I personally favour GParted on Ubuntu. Another alternative is to wipe the SD card completely and reinstall by specifying the new partition sizes you want, or making the partitions on the SD card ahead of time, again using a partition editor. For this application, I favour fdisk, available on a number of platforms. 

Dust-proof and vibration-proof are different things. Generally speaking, the Pi is an electronics board with surface-mounted components and no moving parts, meaning it should be able to handle moderate vibrations, like your typical smartphone or any other electronic device. As for your detecting electrical pulses and making a digital readout, or your pressure transmitter for that matter, that's exactly what the GPIO pins are for. If you search around, you can most likely find someone who has already done exactly what you are wanting to do and just replicate it. Things to consider are operating voltages of your sensors and any drivers that may be needed. You will probably not be able to connect "just any sensor from ebay," but there's most likely a sensor out there that works with the Raspberry Pi for your purpose. 

Here is what you are looking for. This is an x86 version of Raspbian made specifically to run on Macs and PCs. The Raspbian you have on your Pi is built for ARM processors. If you have enough storage space on the Pi, you can download this using the Pi and make a bootable USB flash drive for the PC.