Unfortunately, because the kernel runs the system it is harder to debug in place than user space code. Log Messages are pretty much all you really have fr It is possible to debug your own kernel code in situ, when you know what it is doing and where it is going wrong using verbose logging and other log-bassed debugging in your custom module/kernel , but diagnosing intermittent crashes in a pre-compiled release kernel is pretty much out of the question. You won't do any better than logging without additional hardware You need a hardware interface to run the debugging, in the embedded world this is known as (ICE), and is commonly achieved by using the interface 

Ground Ground is just a special name given to the common reference point in a circuit. A complex circuit can have one ground or many grounds, it can even have virtual grounds. Grounds can be isolated or coupled. Ground has nothing to do with where the electrons come from, its basically just a necessary coincidence that ground is the "source" of electrons with conventional current. All that matters is that is a "fixed point" that you use as a reference. "Ground" is only meaningful because it is a common reference potential shared across the nodes of a particular circuit, meaning every component has a "leg" on the ground. This means You could use a -5V power supply, relabel -5V to "Ground" and "0V" to "+5V" Everything will still work exactly as if you used a +5V power supply where "0" is Ground, assuming that the physics of the -5V supply is OK with "reverse" current. 

When choosing a framework, a trade-off exists between functionality that is done for you and functionality you must reinvent. 

Neither , nor implement a real glitch filter. runs a polling loop, and therefore there is an inherent glitch filter in that events shorter than the poll time (probably a few ms, but haven't checked) are never detected. is a socket based protocol, and the 'glitch' fliter enabled with is software filtering. 

The primary benefit of the is more network throughput. The processor core itself is not any faster, just clocked 10% faster with a slightly newer rev of the SoC (same arm core), with proper cooling you can achieve the same calculation performance by overclocking. From an engineering and design perspective, implementing on newly released hardware is somewhat problematic. Besides the production shortage associated with newly released products, there is also the possibility of bugs (hardware and software/firmware), physical incompatibility, and just general surprises that crop up. You should be prepared to deal with integration issues completely unrelated to your application. If it were me, I would target the established product (B) and evaluate or plan to upgrade to the when you are satisfied with its availability and performance. The performance gain is not worth the risk of missing a deadline or delivery date. That being said, RPI foundation has recently expanded its distributors . Although production shortage is still possible. There are many suppliers with large stocks. For example, looking at available stock on , , and there are over 25,000 Pi3 available for immediate purchase and overnight delivery. I'm not quite sure why the Pi Zero is still so difficult to get, but at least for the full size products there track record is getting better. I would not be concerned with availability in the long run, but for a brand new product and your deadline being next month, you can either take the risk and buy now or simply postpone the upgrade until next year, for example. 

Debugging the source of the failure to reboot would be an endeavor, without a serial port monitor and an oscilloscope it would be difficult to find a root cause. 

Throttling is a mitigating strategy to decrease the power consumption of the CPU and, as a consequence, its temperature. It is an attempt to keep the CPU within its safe operating region. If, for example, the ambient temperature is very hot, no amount of throttling would guarantee safe operation. However, IC's and PCB's can safely "ride out" very high temperatures if they are turned off. Products designed to operate at an elevated ambient temperature use various strategies to maintain the safe operation including underclocking and protective shutdown. At some point, you need to just turn yourself off, and the RPI cannot do this, if soft standby/idle mode provide only a small additional safety margin (device is still on), you may as well run until you crash... 

Is it possible that at any point (PIR) was configured as OUT? That would damage GPIO permanently and be an easy root cause (if PIN 4 was set to OUT0, and sensor is reading 1, that is a direct short from 3V3 to ground) . EDIT:: 

Based on your wiring diagram, your wiring is incorrect, you are not providing any power to the motor. The relay does not supply a voltage itself, it is merely a switch. The pin on the relay is only for the driver (coil), and not for the switched side. You need to change your wiring to supply power to the motor as if the relay is not there. You can either use it as "low-side" where the relay is connected to and motor directly to . Or a "high-side" switch where relay is connected to and motor directly to 

Otherwise, you may attempt to reinstall all packages using dpkg This is taken from a unix.se answer. Note just like the author of that answer, I did not test this sequence. 

This qualifies under category circuit rework. The "best" solution, if the pads are still usable, is to purchase the replacement part and re-attach it. The part is about $1 USD but this does not include shipping Vendor Link (Part Number Found in Schematic) It is generally a good idea to repair something to its original state. Most things can be repaired if desired, for example, the guides I reference below also have sections for repairing traces inside boards. Where there is a will (or an irreplaceable part) there is, usually, a way. An, in fact, there are companies you can pay to do this. 

In a sense yes, and you are already taking advantage of this solution. The peripherals that access the bus are integrated on die, they are also usually Enabled and individually clocked , so they do not require CPU cycles to perform the task (the kernel is not bit-banging). However, there is no general solution to simultaneously access multiple external devices in the way you describe. Most of this is handled by the bus protocol, which may allow multiplexing, messaging/mailbox and other high level protocols for more convenient sequencing and multiplxing of data. With a simple serial bus like One-Wire, the solution is either a carefully crafted poll loop, using dedicated interrupts, or some other specific scheme that can be applied to a given system. 

The raspberry pi can be used as your home automation server, but you need an intermediate, more permanently installed layer. In the most basic sense this class of devices is known as a Programmable Logic Controller (PLC), which, if you allow my analogy, is a simple ruggedized "Arduino", at least for this application 

It is "solved" in the sense that the kernel drivers will try their best to respect what you ask, however you cannot send two different voltage levels on the same bus at the same time, so the "solution" is just heavy handed concurency control which breaks your timing requirements. Also, kernel absolutely has internal threads and a concept of a thread, it may not be a posix thread as you know it, but in terms of multiple control/execution flows it exists. For example, register an ISR with an interrupt in a driver and the IRQ has its own kernel thread/task associated with it. 

If your devices are synchronous, i.e. provide an interrupt or ready signal (typical for ADC), then it is preferable to have an IRQ per device. You start the devices running with some time offset to guarantee that you don't have too many interrupts-during-interrupt. 

Disagree, there is a glaring electrical bottle neck. No way your simple ADC will respond at or even . Remember the step response of your ADC is limited by RC time constant. You should estimate this first as it determines the a practical max sampling rate. A resistor based ADC is a massive Capacitance beast, this time constant will be very large and limit your response to significantly less than a MHz. Put another way, the ADC acts (and IS!) a Low Pass Filter and a 12MHZ sampling rate is unrealistic. Dedicated ADC's designed to run at those rates are beasts that require careful electrical routing and signal conditioning. 

The better way is to use a power regulator board that has a higher voltage input ( common) with internal regulators for separate power rails. This lets you use a smaller power supply (fewer Amps), and the impact of the supply wire resistance is minimized. It also reduces interference between different devices in the system. 

No, There is no significant advantage or disadvantage for one vs the other for learning or doing "hobbyist" things. However, If there is a library, tutorial, or example you wish to try that supports one and not the other then start with that version Python2 still has more support from libraries, and more code for it on e.g. github to use as example. But this is rapidly changing. 

This has certain caveats, the audio is very likely to be poorly synchronized. Using 1 -8channel Device What is needed is a single device that can accept an 8 channel stream. This would be a dedicated sound card our receiver that can decode an 8 channel audio stream. An S/PDIF or HDMI connected 7.1 receiver or sound card would likely work. You would generate a multichannel audio file using , an example of how to do this with 8 mono channels is shown bellow 

On their own with nothing else, no they will not work in tandem. You would need to configure your networking to manually split traffic by application or use bonding as described below to have the kernel do it for you. This is called in linux , and is supported by the kernel (and thus all major linux operating systems). Generically the term is also known as 

Userspace Buffer, when a file is opened by a program you get a kernel provided buffer, this is where data from goes. Kernel Disk Cache, kernel caches file in memory before writing to disk. 

To restore only SSH/SFTP, you can start by correcting permissions for private and public keys under the sshd directory. 

Kernel Coreutils (Shell and basic shell tools) Networking Tools (wlan and ssh) System Frameworks like 

Bit Mode There are two modes - and that enable these peripheral IO modes. These bit-bang mode Do not require EEPROM Interaction as shown in the table below, they are accessed through the driver command API. 

Electron Current It is incorrect to think of electron current as "proper current", because it very much depends on the nature of the device. For example, in your battery the charge carriers may be anions or cations depending on chemistry. In a transistor the actual charge carriers can be thought of as "virtual" positively charged particles. What about Transformers and Capacitors? surely current "flows" through these devices, but there are no electrons (or any other charged particle) moving across the gap! You can, if you like, analyze every component of your circuit in terms of the real charge carriers that produce the current, however this would be an insane thing to do, extremely confusing, error prone, but ultimately provides no benefit to you as a circuit designer 

c, c++, python, etc. you need to first (after ). Some language structures have convenience methods for doing this (e.g. in c++ ostream::flush ) 

We can implement a simple frequency counter on the raspberry pi, by using a phase counter. Prototype of a simple (synchronous) counter 

This device is not trivial to use precisely because it is a USB device. There are much easier ways to get PIO expansion. This device has "GPIO" mode (called ) but it is intended, primarily, to replicate custom communications protocol in a serial manner, not as a GPIO expansion. While it can certainly be used that way, it will be a big drag. I would recommend using a different GPIO expansion product. or based devices are probably your best bet. Regardless, EEPROM is not how you configure the device to do Bit Bang/PIO Expansion. 

Most people will use a higher level GUI library like or to create usable objects like buttons and toolbars using the basic features provided by . These libraries also greatly simplify creating "event handlers" for things like buttons and key presses. You can also directly draw graphics using You do not need to have a full featured GUI Desktop Running or even Installed to use X to run a graphical application Your application (Again, , , whatever) would use the GUI Tools together with (API for Xorg) to draw widgets, windows, etc. on the screen. 

Namely, you will need to use , which is a hardware debugging interface. This allows one to set breakpoints and interrupt the CPU using external hardware. When set up correctly, you can use easily with running on a host PC to debug embedded linux kernels. The use is identical to using with any other application, but the interface is hardware. You would use this setup 

Good Resource Tutorial: $URL$ Note that even this may not be sufficient, there are many problems that only occur when things are running "at speed", that is, the interjection of a debugger or even additional log messages may change the system enough to hide or mask the bug. In short 

Which means 9 devices is beyond the fan-out limit of the bus in your configuration. The best option here is to reduce the value of the P-U resistor to in order to achieve a limit of 30 devices on the 1-wire bus. This will increase the consumption of the 1-wire bus from to , not very significant in powered applications. More Concerns When running sensors on long parallel cables, then there is additional capacitance on the line, this will reduce the maximum speed of communication determined by the . In the worst case If you have for parasitic supply storage, and say 10nF more with 9 parallel cables at 3m each (using ), with 4.7K, we calculate , which means that the maximum rate of communication on a bus is 5KHZ or less. . This is the worst case, so you may get away with faster rates, but you will have intermittent connection occasionally. 

Additionally, Any hand rework, even with good equipment, runs the risk of wiping out any improvement from a better spec'd oscillator. They are very sensitive parts. The improvement in temperature stability switching to a different XO in the same package is marginal, you are buying better tolerance and matching characteristics that reduce clock drift and temperature dependence for the device class, but physically speaking all crystals will expand/contract with temperature changes and all will experience clock drift, very hard to compensate for this. In the end its unnecessary, if you want to run an NTP node it will work regardless, if you want to function as a (local) time standard you will need to interface external equipment, Like a GPS, thermally stable clock, cesium clock, etc... However, If you want to experiment with stabilizing the on-board oscillator this I would suggest and alternative approach