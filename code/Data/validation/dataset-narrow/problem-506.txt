Note that this no longer references the static variable either. Finally, with these changes (and, really, in the scheme of things they are 'small'), your main method simply becomes: 

Finally, if you want true multithreaded execution in your filter, you can use Java streams instead of the for-loop I have. Consider this replacement function: 

Java class names should be CamelCase. Your class should be . use whitespace in lines consistently, especially around keywords and operators. Lines like: 

Sometimes applications do this sort of thing a lot, and in those cases I centralize these micro-tasks to static classes like: 

This makes it clear that the constructor starts a Write-lock, and the session is 'closable'. It can also be downgraded. Concurrency in any language is complicated. Java has four well-documented mechanisms: 

Note how we call instead of ? Now, what is ? It is a simple class that takes a predicate, and a Consumer, and it calls the consumer with the value, if the value passes, and it returns false if the predicate passes (which means the value will be filtered in a filter call). It is more comments than code, and it's really simple: 

In the above subselect, is an aggregation function. It aggregates all the values in a given group. You group by , but, you also have the nested join condition history`.`itemID` = `items`.`id`` .... which means your subselect will only return values for a single anyway. There is no need to group the subselect. MySQL has this feature which I call a bug, and that is that it allows you to group by columns that are not in the select, and not group by non-aggregated columns that are in the select: The 'feature' documentation here . The most interesting part is this: 

Note that, for this system, I have enabled all three input parameters, and I have done some simple 1-level-down recursive tricks to handle negative values (and Long.MIN_VALUE which is a PITA). Update - Performance Since the question was edited to include performance as a criteria, then the following code will do essentially the same as above, but with some performance tweaks: 

I agree with PenutReaper that the second is the better query, but for slightly different reasons. Views are designed to be used for inclusion in other select statements, and since the only non-aggregated column on the query is the , the second view makes that column more accessible for joins of the form: 

@janos has covered a bunch of my concerns, except the algorithm you use. I like the recursion, it makes sense, but I would make it a whole lot more efficient by doing two things.... 

The above code will always work, but for larger files will be slow. For practical purposes though, I don't believe you will run in to problems, and you should be fine. I worked a little Java 8 in to the following code as well. Consider the RingBuffer class which allows you to collect the data in to it: 

The switch statement will be optimized so that there does not need to be more than one modulo, and there is no concept of an ... just a single condition check. 

Thus, you can accomplish the conversion with efficient switches, array lookups, and 'simple' math in the loops. I have put together an Ideone implementation of this code so you can compare it with your code. 

Note that there is no need for the one-argument constructor now in the class. Code duplication is always a red flag. Consider the following methods: 

Your strategy of counting the spaces and then back-looping to shift the characters right (and replace spaces with ) is good. The basic algorithm is probably as good as it gets as a character array system. Your variable names are decent, and the code flows well. On the other hand, there are some small things I would change. Possible bug Your code, given the input you would output but you should not remove any "extra" padding in the string, you should return In fact, you should only really have the one array. The second one is making you do bad things ;-) Enhanced fors Use enhanced-for loops when possible, and always use blocks for if-statements, even 1-liners: 

Note how the generic type of the node is different to the list , but that is because they are in different contexts, they are actually the same when you use the Node class like: 

this is a write-only linked list. You can add things in the constructor, but you can never read them out .... what's with that? There is no 'get', or any other mechanism to retrieve data from the list there is no way to add data other than through the constructor The code will fail for the input given like: 

and then the will be forgotten. Is this a case of where a static method is maybe all you need? Something like: 

There is a lot of code-simplicity that can be gained by extending the component rather than creating a seperate instance of it... for example, the complicated internal action-listener becomes , and you can still create your own methods on the child classes that do 'compound' operations, like accept, and validate the password. EDIT: to extend my answer, and to show you real examples of what I mean, consider the examples in the Swing tutorials... 

Create an object (the ListIterator) in order to get a member. This is overkill. This pattern is repeated often. Rule of thumb, if your code is going to act on just one member in the list, then using an iterator is probably not the best solution. Iterator "implemented" The bulk of your logic is implemented in the ListIterator. This is a backwards way of doing it. The Iterator should call methods bck in the list, and not the other way around. assertIndexExclusive This should be called assertIndexInclusive (it includes the range end). Bug in subList The following code: 

Code style: Seriously, you manually create the blank ? Wasn't that sore on the wrists? Lazy programmers are a good thing, consider the following: 

If your comment about the not being a cycle means that if a node points back to where it came from , it's not a cycle, then I recommend passing in the 'source' when you walk the graph... for example: 

The only real way to solve this problem is to normalize both inputs in the same way, and while you are normalizing the text, you may as well convert to lower-case at the same time. This in turn leads on to a discussion about combining characters. If, after normalization, there are un-composited combining characters, it means that there is no composite character that represents the combining accents... so, how can you treat that as a single character? By maintaining an array of characters that form one base character only. This is beyond the scope of my answer, how to do that (bug I did it anyway), but, in short, each character should be represented as an array of base character, followed by whatever combining characters are modifying it. So, your goal: Handle "characters" (i.e. code points) outside the Basic Multilingual Plane (BMP), including characters from Supplementary Planes. is not handled correctly. Now, I would expect your code to have a method that breaks down the input string in to a normalized set of base characters (possibly surrogate characters), followed by combining marks. Both sides of the input strings should normalize in the same ways, leading to common normalized outputs. The Java library contains the class for this exact reason. Re-implemented - functional, not necessarily efficient I have put this all together here. If it looks complicated, well, it is because it is complicated.... ;-) :