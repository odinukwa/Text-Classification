I honestly believe that for that price, that's one of the best deals of this kind I've ever come across. I haven't completed all of the courses yet, but from what I've seen so far, the amount of content and detail packed into each of them is at least as high as most books you could buy for each individual topic. For instance, just the textbook/workbook for the first DX9 Module is over 1000 pages long, and that's not including the actual presentations which also have a full voice recording. I've also found the content to be very complete and useful. For instance, about 3 years ago, right after working through the first few lessons (including the workbook chapter) of the graphics programming module, I stepped away for a moment and implemented my first basic 3D graphics pipeline from scratch (on an old 2D Javascript Canvas) with the things I had learnt. I think that was probably the first time matrices and transformations really started making sense to me. To put it shortly, I believe that the value in this case (for the 99$ deal) is ridiculously high for the amount of content you'll get. I've built up quite a large library of game developments books over the course of the past few years, and this package still ranks up there on the list as one of the best investments I've made. The only drawback I see is that the courses (at least the ones I have) are mostly aimed at beginners, and are a bit outdated in terms of dealing with some more recent techniques. But that's usually the sort of thing you will only learn after reaching a more advanced level anyway, so the courses serve as an excellent starting point from beginner to intermediate level. Although more recent techniques are being researched every day, the basics still apply so in my opinion all of these courses are still very relevant. Edit I just noticed the following disclaimer on the site: 

It is also worth noticing the visual difference between an isometric projection and perspective projection which is what almost every 3D game uses. 

Basically you take the top-left and bottom right-corners of the camera in view space (which are always [0,0] and [screenWidth, screenHeight]) and transform them into world space. That's your bounds. And by the way you can get the by doing a . Solution with Translation, Zoom and Rotation You only asked about zooming but this might come in handy too. If you try to do this with rotation mixed in, the process changes a little. In this case instead of only transforming the top-left and bottom-right corners, you need to transform all four corners, and then find the minimum and maximum X and Y values to create your bounding box. Something like: 

As for adding layers, yes just add a third dimension to your map array with how many layers you need. Edit 1 Another alternative that would simplify the hover problem would be to draw the hover rectangle a little smaller so that it doesn't eat into the neighbours. For instance: 

The problem is probably that is of type while is an array of objects. Obviously, you can't assign a to a . This is due to the fact that you're using a spritesheet for your lava animation directly. Three ways I cant think of to solve this: Solution 1 - Put each frame in a separate file The most simple solution for this problem would be to move each frame of the animation into a separate file and load each of them into a separate texture object (e.g. into an array of objects). Solution 2 - Copy regions of the spritesheet into separate Textures If really want to use the spritesheet, another solution is to use the Texture2D.GetData and Texture2D.SetData methods to create the individual texture objects using a subset of the data contained in the original spritesheet texture. In other words, copy rectangles of data from the spritesheet into separate textures. Something like this (which I have wrote from memory so it's untested but should be close enough): 

Finally recalculate your direction using the quaternion above, or convert it back to a rotation matrix. Something like this for instance: 

I know this isn't a direct answer to your question, but I'd like to drop in that GLaDOS's voice isn't synthesized though - it was recorded by an actual voice actress and post-processed. That's certainly another possibility to consider. And just because I thought it was interesting, here's a video that shows how it's possible to create something that sounds very much like GLaDOS in the games, by taking an unprocessed sound clip recorded by the aforementioned actress, and processing it in a voice manipulation tool such as Melodyne. Most of the changes were removing pitch modulations between words, changing the pitch here and there, and messing with the formant of the sound. I think the original sound clip could even have been recorded with no pitch variation between words, with pitch changes then being added in the application. Melodyne is not free though but there is a 30 day trial you can try. And there might be a free alternative out there, although I'm unaware. Another alternative to editing the voice like this, is to use software that applies the changes as a whole to your sound clip, and automatically makes it sound like a robot. I'm thinking for instance about using some sort of Vocoder VST, which you should be able to find by googling a bit. 

You're a talented artist who can paint photo-realism and has no problem making it from scratch. You use a camera to take a photo of a surface that looks similar to what you need. You have enough artistic skills to start from a photo and modify it. 

Which basically discards the W component and stores Z on it. Then when you homogenize the result is the same as dividing by Z, which is what I did directly in my code. 

The sprite hierarchy representing every type of sprite I can display. The display list (which I call the stage) which groups and manages my sprites. 

But if you'd like to ensure that there's at least one frame of delay between each event being handled, you simply need to change the Update method to: 

To limit the position of the marker to that workable area, first move the marker as you normally would. Then validate the distance between the center point and the marker: 

Once you have that and you'd like to offset the object's position in front of your character, simply do something like: 

When the documentation is not enough, I like using a decompiler such as dotPeek to see what's really happening behind the scenes. Running dotPeek on gave me this implementation: 

As you may guess, the memory requirements increase quickly as the number of nodes increase (N^2). Since a short would usually be large enough to store each entry in the matrix, with a complex map of 300 nodes that would result in storing an extra: 

As for your other values, the value of looks really cryptic and I'm not really sure what you're trying to do. But basically in this given context, should be the amount of units you want your character to move. Finally, unless you're trying to do some really fancy easing, I would just use one of the XNA's built in methods for this: 

Since you've chosen this route I must warn you that it's actually not as simple as just using for two reasons: Problem #1 - Lack of pre-multiplied alpha support XNA4 now handles textures with colors in premultiplied alpha format by default. When you load a texture through the content pipeline, that processing is done for you automatically. Unfortunately doesn't do the same thing, so any textures that require some degree of transparency will be loaded and rendered incorrectly. Below is a screenshot to illustrate the problem: