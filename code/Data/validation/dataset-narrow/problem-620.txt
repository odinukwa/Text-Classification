I'm not 'feeling' the concept here. There's a disconnect between what you have, and what you're doing. You are asking for an iterator, but passing in a node.... that makes no sense. You should be passing in a . The should not be public... it should be attached to a new class in a more restricted way. Perhaps a interface and then a number of implementations like , etc. So, it's a design issue... Then, about the Iterators, you're taking advantage of Java8 Default methods on the Iterator (the default implementation), but then really, you should be streaming things, not iterating them. A Spliterator is what you should be implementing. In a sense, I see your code as being a good solution to a 'local' problem, but the way you describe the code is that it should be some form of API, and, as a library, it's problematic. 

On my laptop, this is comparing 1.5GB files in under 2 seconds. Obviously, your milage may vary, and my laptop is an unknown beast.... but things that may play in to the equation: 

That should reuse the pattern more efficiently, and improve the replaceall time (though Java probably does a good job of detecting that misuse, and compiling it efficiently anyway. There is a potential bug in your code, though, and it possibly accounts for the speed-up too. In the original code, you check every inventory item against every product. In the second code, you check each product against only the first inventory. You "break" the inner loop. As a result, your "faster" code does not do a full join between the data sets, but only a partial one. This may or may not impact your results, but it will impact the performance. As an aside, this code would look great in Java 8 with streams... do you have Java 8 available? 

Right, cool programming challenge. It appears, by scanning your code, that it does logical things in a relatively well structured OO way. I have written code similar to this a few times in the past, and it seems somehow familiar. On the other hand, when I mean 'in the past', I mean before the advent of the API. That API changed much of what you are doing in a way that is far more predictable, and neater. There are some problems.... There is no synchronization on the method. If there is an exception and the copied variable is set to -1, it is possible that the reporting thread will never see the -1 value, and will report the size of the output regarfless. The use of the copied variable needs to be synchronized. Additionally, your code will be significantly different again if you were to use the Java8 streams/lambdas. So, as a review, I would say that using raw threads and runnables, and using simple calls on threads is a real problem here. Rewriting it using Executors and Futures would be highly recommended. Personally I would be happy with an Executor/Future implementation, but a Java8 parallel stream implementation would be recommended by many now too. Because the work is long-running work, it would fit well with the concept of a . Using Concurrent API I am not about to rewrite this code, but let me go through some of the things you should be using: 

Update: As per your comment, the use of ReentrantLock and Condition is not necessary. I prefer to use consistent locking mechanisms in my code, and I have 'standardized' on Locks. Locks can do anything synchronization can do, and then more too. Unless you have many thousands of events all happening at once, the memory cost of the locks would be negligible. Still, I agree with the sentiment you expressed. The same can be done with synchronization: 

There are a number of things that are problematic. most fundamental is the algorithm you are choosing to run. It does indeed appear to be something like complexity. This is unsustainable.... and needs to be resolved.What it means is that your solution will effectively be unusable for more than 13 members of the list. This is especially true because you store all combinations in a single set... which is 'insane'. What you are doing is searching for a needle in a haystack, and first you build the haystack ;-). Instead, you need to use a better algorithm (take a magnet to the haystack ...). But, dealing with your first issues first: 

This is OK, but, in other places, you cast the ints to longs in-place. I would prefer the consistency to be maintained, and since I prefer the in-place cast, I would recommend you change the function: 

Double.parseDouble throws the unchecked exception . The exception thrown does not give great deals of information about why the number is not valid. I always recommend wrapping Double.parseDouble (and , etc.) in a try-catch that reports what value was parsed, as well as the exception that was thrown. Otherwise debugging is a pain. I often have a helper function like: 

although, that is not ideal, you should not need to be changing directories in the main part of the script. User Input You get a directory from the user.... inside a loop: 

This makes it look like there's something you are guarding against, but that's not true .... nothing else is calling this method, and no other methods are synchronized, so there's no protection here at all. instead, what you should do, is a checked set.... Your code is essentially: 

I believe you've fallen in to the hacker-rank mentality of do-it-quick... and all in the main method ;-) Your implementation should have a class, that is a container that tracks only the longest X number of lines. It should have a constructor along the lines of: 

There is no good way to handle the overtime rate other than with a conditional somewhere. Ternary conditions may help a bit..... 

The advantages of these changes is that each element has a unique ID that will help resolve looking for things in potentially multiple places. Additionally, having a reference that is independent of the display name allows you to change properties of the data in a single place, without having to redo many places in your code. For example, you could possibly have multi-language support directly in the XML with something like: 

Note how I have a correctly-scoped variable, and I use a return in both the successful, and catch-side of the try/catch block. The logic is now very visible. That function extracts just the file's type. How is it used, though? 

Yeah, yeah, I know, but even for non-braced 1-statement conditions, at least use a new line, and indentation: 

This query is horribly over-working. I can only believe that the query has been 'simplified' to put here on CR. Otherwise, as far as I can tell, the query can be rewritten as: 

But, what if the sum is more than 32 bytes? Also, if you are at/near the limits, and you have negative input values, then you may end up with a negative result. I know your code appears to limit the negative impact by forcing a positive sign, but it could 'overflow' the 32 bytes. 

But there is no 'else' condition for that. Did you 'trim' that out? What if the row is in the other direction? What if it is already in the correct row? Incremental Suggestion Generally, when presented with problems like this it often helps to generalize the problem.... For example, if you create a concept called a 'direction', which is a two-value pair, say an (keeping it consistent with your code). If the target is at coordinate and the current position of the tile is at then the direction is (you need to be reducing the row/column coordinates by 1 to get to your target. Then, your while loop can become: 

Because has only got a version of the argument. I would recommend a name like "journals" if you make the Collate class Journal specific instead of generic. Alternatively, something that describes the content, not the structure... like 'data', or 'values'. Leaks You have a few encapsulation leaks. The biggest is this one: 

Your use of is misguided, and it does nothing for you, in this situation. The fact that you have used here indicates that you don't understand what it does, and why you may need it. In general, with the availability of the , and traditional , there is no real reason to use at all. is a hard-to-see memory management technique that immediately rings alarm bells for me. while ratchet freak's suggested implementation will work fine, I strongly advise against using simply because it is too hard to see. In your case, you never change the , so there is no purpose to the . Sure, you change the contents inside the , but that's different. Further, your should be final, which would be better practice, and helps with concurrency too. 

Additionally, there is no reason, if you are in a method that builds these things, that you can't return immediately with the right answer. Often if you are doing things like the above, it indicates that what you are doing should be in a sub-method, with an early-return when you have a successful setup, and a default return value when things fail. 

The concept here is great, I like it, and I can see real usefulness for it. The Content class is unnecessary, it is just a logic container that does not add value. All the methods in Align simply delegate to Content anyway, and there is exactly one content per Align. Instead of Content, you could simply have and make the logic in there more private.... I am not sure why was protected anyway. There may be a slight performance benefit to tracking the max-sizes of each column as the data is added, and conditionally re-calculate it if data is removed, or set (and the removed value is the same size as the max for that column). You can probably save a fair amount of memory churn if you were to pre-calculate the size of the in the : 

Using a Set means you expect duplicate data, and you only discover it is a duplicate after you have done the work, and you add it to the set. You should adjust this to be a more natural structure, like a and then ensure that you are not processing the same customer twice.... Dubious Queue Usage 

sets to be the same as (because, for a 1-sized queue is a pointer to ). In the other you set to be null when there's nothing left, but this does not make a difference, really (other than Garbage Collection) because the function checks the empty queue using and not static inner class Your class does not have any need for a back-reference to the . It should be a static inner class . To do that, though, you need to make it generic too. Use a letter other than to represent the generic class... 

Now, we have two scaling ratios, which one produces the smaller image? The one that has the smallest scaling factor. 

your script takes 2 parameters, but you only check for 1. if the parameter is missing, you still exit with a success exit code (0). You should exit with something else .. (like ). there is no need for an else condition. Treat it like a guard-clause... 

This is a cool little problem that needs Java8, and regex. ... promise. First up, the method is new in Java8, and converts a string in to a stream of substrings, depending on the pattern, so, what's the pattern? Well, the pattern is to match the beginning of any word that needs to be capitalized. Your code currently finds characters, after whitespace, but that is, as you admit, too naive. Words that need capitalization are things like: 

The other nitpick is the newlines in the block. Yeah, it's a real nitoick, but I prefer a single-line for the , not 3 lines. Still, there is only one instance of this, so at least it is consistent ;-) OK, enough about the trivials.... Minutia String concatenation to get a String value of an Integer is overkill... things like: 

Now, that difference is small, I realize, but it is real ;-) Also, admittedly, occasionally when I run it Edward wins.... (compiled with on an AMD linux machine). When I run it on an intel machine (core i7 4770): 

it returns return-statements inside return a value now the input includes the 'maze' (instead of being a static variable) there are no references to , just to the array it has an internal variable it changes how it calls 

I believe there's race conditions in your code, Specifically, if you call asymettrically (more times than you call ) then you run the risk of a few things: 

I am really uncertain about the right-to-left characters.... should they be transformed in the same way as the left-to-right ones? You're the expert on that one. Still, you get the idea.... 

There is a very convenient way of handling files in python: the with statement. It handles closing automatically so you do not have to worry about it. It is very simple to use, look at the following example: 

where you the value, which implies you expect white-space on it. The very next line you check to make sure the first and last characters are actually parenthesis and . You should trim the value before that check because trailing whitespace is surprisingly common, and would be legal. I cannot find a good reference on Annotation syntax, but it appears that there cannot be a space between the annotation name, and the opening parenthesis.... is this true? Still, the correct solution for the whitespace problem is to solve it in the regex. This can also solve the parenthesis checking poblem. Consider the regex: 

This problem has me perplexed. Frankly, I don't believe you ;-) !!! There is no logical reason for this code to be so different from each other. There must be something else going on.... For a start, the bash process itself is probably taking almost no time at all, and all the time will be spent running the 'install' sub-processes. I imagine that you are running the install processes twice as many times for some reason.... or that, subsequent installs are faster because you don't need to access the disk/net, or something. Regardless, I don't believe the difference in performance is because of the vs. As a side note, do you need to execute the s in a sub-shell and capture the results like you do and then them? The install lines should all look similar to: