I never did MIPS Assembly, so I decided to try on this simple one. I will comment on your code mostly from performance point of view (as smac89 covered simplicity/readability variant well). In your case I wouldn't be afraid so much of branching (and it's not trivial to lower amount of branches down), but about number of integer divisions () and also syscall outputting integers (hidden divisions). From the limited info I was able to found about real world MIPS architecture implementation it looks like for example PIC32 MIPS32 M4K Core does use about 1 cycle for 1 bit during divide operation, maybe with some early exit optimizations, so in worst case it's about ~32 cycles for 32b/32b divide. I tried to use MARS and it works OK, but I don't see any serious performance information except simple instruction counters, plus is not counted into the stats at all. So outputting integer is "for free", while in real world it would hurt so much that it would be probably better to keep just string representation of and increment it as string, avoiding binary integer (at least with my code it would work, as I don't do on it, so I don't need integer form of "number"). Anyway I didn't go that far, only reworked your loop to avoid divisions, and also to avoid pseudo instructions when possible, so the amount of real instructions generated is similar to the source code. 

Source differences only, all the where in static code the 32 bit address part is enough, have to change to full 64 bit in PIE, i.e.: 

Well, the runtime of your code can be maybe improved a bit by cleaning up the current code a bit, but the main bottleneck is the inefficient algorithm, so I will not comment on your particular code and style, and I will focus on the algorithm only (if you still insist on code clean-up of current version, let me know in comments, I may try to rewrite few bits of it more to my style to show you a thing or two, but I think reviewing better algorithm would make more sense). Also I would focus on the search algorithm, not on the init. I'm afraid with huge word list even init can be very costly, and worth optimization, but the initial data may be preprocessed ahead, so you then read not only word list, but complete definition of graph with edges between them. You should have posted, if the init itself is important for you as well (can be worth of effort for application where input word list changes often, so graph has to be rebuilt often). Imagine the words as nodes of graph, with edges between words different only in single letter (obviously words of different length form a completely disconnected sub graph, but even with words of the same length the graph can have several disconnected sub-groups). If a starting word has a ladder to the ending one, both should belong to the same sub group of graph. So first optimization may be to store each sub group separately (for example: having for 4-letter words two or more graphs). Then in O(subgroup_size*letters) you can tell if starting word belongs to the group under scrutiny. (with global hash map of words containing index to subgroup and index within subgroup the O(...) can get even lower, depends on hash map search implementation, but the initialization will get longer). Now the ending word must belong to the same subgroup, otherwise the ladder path does not exist at all, so another search of word ( O(subgroup_size*letters) ) will tell you, if the solution does exist. And also you will have both nodes (starting and ending word). Now you should do a "path between nodes" search, I'm not sure if the shortest one is required, or any will do. For these situations something like A* path-finding algorithm can be used. I didn't check A* lately, so just from my head some idea about such algorithm, basically searching the graph from both ends, in a deep/wide way by word_distance: You have to create some and set . will be distance (number of nodes) from starting point. Also set and marks whether belongs to the starting node, or to the ending node. Put both indices in the deque. Now till the deque is not empty, pick the index out of it and it's color. For all it's neighbours: 

Okay, so now we have more smaller classes that each are specialized, but how is this good? My main goal here, is to not need to alter code when I create a new implementation of You don't have an example of the class or the main Runner class, so for now a just has a method. You can of course do whatever you want in your class. Instead of an class, let's make a class. That's what this is after all, an RPG. 

now there can be no confusion with who won the game. I also don't like itself as a function name, it doesn't really say what it's doing. I would prefer , or or something more along those lines. Don't worry about trying to keep names short, make them as clear as possible. 

You almost never want to make your instance variables public. You should use a getter if you actually need to see that variable outside the class (which would happen less often than you would think) Your location class contains information that specifies what type of location it is! 

This comment is redundant, the append method on a list appends an element to that list, you don't also need to say that it adds to the list. Here is an example of a comment that's useful 

If someone passes in that list, they can add/remove stuff from it and it will effect the list in your playlist object! Try this instead 

I've made up some methods here, in your code you have the logic to do these actions, so I'll let you fill in those! Notice now how short this method is, the shorter the method the better, even though it's made up of many calls to other methods, by giving them all good clear names, you should be able to see what the method is doing without looking at the bodies of these other methods. 

To make it less weird, and more OOP like, it would make more sense to extend , as that's already well known defined API, and just adding one more method to it makes much more sense in OOP world, having then class which can be used in place of std::string where needed. Helper utility class (or just a namespace with functions would do probably even better) would tried to provide pure functions, taking everything needed on input, and returning output, not having any instance at all, so they are accessible from anywhere, when you have the input ready. 

one way is class holding the actual string, responsible for manipulation with it. other way is helper utility class providing only functions, not holding any string at all. 

And the other three too (modify target register "edi" to "rdi"). And the instructions into glibc themselves require extra ELF setting to make the linking dynamic ("abusing" a bit directive "with regard" and special keyword ): 

One more thing, I forgot to mention one other idea. If you can sort the blockers by the position (rotation), then you can use the last position (last index to moved blocker) to check, whether that blocker is still current for next frame, if not, move to next. Removing the loop cycle completely and having just couple of basic s. 

I would refrain from using as general purpose register. This is limiting you in using / subroutines, and you risk memory corruption caused by interrupt happening in your program context. I would also refrain of such heavy LUT tables usage, as the program will be more likely limited by the I/O operations speed, so that tiny amount of calculation will quite likely hide in the buffered I/O waits. Here is my version, avoiding those things mentioned above: 

(the exact value stored in is , encoded as 64 bit integer value) So you are just destroying precision bits of the original value, but the resulting value can still contain decimals with precision you don't expect. For some more information study how the floating point numbers are designed, maybe this may be of help: $URL$ 

(this example assumes that the .equals and .hashCode in the HolyShield class will consider all instances of HolyShield to be equal) now in our calling code, we don't care how the is alive, all we care about is that they are! There is a similar issue with your checking if a gameCharacter is frozen. You currently keep track of this state with integers that are outside of the class. This state should be handled inside the class (or any subclasses). Currently you have this 

okay so now we have 3 subclasses and can get their priority, so all we have to do now is sort our list, and then remove all the ones that aren't free. Then, at position 0 we will always have the at highest priority! 

If you really wanted to, you could have a Song know about what playlists it's on, but I think that it's perfectly fine to just iterate through the playlists until you find it. I don't think a song should know about what playlist it's on. But a playlist should know what songs are on it. you could have a method like, 

We constantly append to the same list. Being able to compare cards for equality would be useful, consider overriding the __eq__ and __hash__ methods. And if you want to be able to do card1 < card2, you can also override __lt__ and __gt__ Final Comments My final suggestion would be, try and make a card game using what you've written. See what problems you run into, what works, what doesn't work. Something straight forward like War. Hopefully you found this review helpful! 

Give one line per import. Your code lacks a main guard. If I was to import any functions or classes from your current code, your slot machine game would start! Generally you just want to wrap your code in a conditional check that looks like 

(I would also write as , but I think the compiler will optimize that one anyway, just old habits from ASM times die hard). 

Why name like ? Was it just for this review, or is it actual label? Use rather something more descriptive. 

The Model/View relation - how I like it - can be demonstrated on this classic: Consider having blog application, so for each article you have date+time of publishing the article. Then Model should contain UTC timestamp value (can be unix timestamp, if you need only dates since 1970 onward). And View will do all the formatting magic, ie showing "5 seconds ago" for fresh article, or "previous millennium" for some really old article, also converting the date/time to local time zone of user (source data stored on server being in UTC, time zone agnostic). 

You don't need to check size() for even/odd value, the integer division will work in your favour in this case, so 3/2 = 1. And random_access/bidirectional/forward iterators have overloaded operator, so you can add the result directly to . The would be helpful when you would use container which has only available (can increment, but only by single step). Then it can be still somewhat simplified to: 

Some short note without really reading into the source. In MVC usually the Model is independent of View and Controller. So your looks like mixing together Model and View class, supplementing functionality of Controller too. Some general notes how I would split these: Model: 

Peter Cordes did leave you several review comments in the original SO question, so I will post the code-only here which is sort of adjusted by his advices (and my small modifications). Commands to compile: 

I had only some limited quick look, just cherry-picking some things to comment on: Entropy level: I'm not expert on this topic, but I think using time stamp as additional entropy source every time you produce a number is not a very good idea. But I'm even afraid you use it as only source of entropy in some cases, which is definitely wrong. I was unable to quickly show what's wrong about it, as you have weird way of updating, masking the problem out in your example. But after you change this I'm afraid it will become obvious this needs rather some "seeding", and building up upon seed data. About : You do great deal of pushing all around into it, yet only pops from it, and only once. So after running this for a while (using it as output stream, without calling RNG) the buffer will grow a lot, eventually running out of memory. If this one is supposed to be a buffer of pre-generated random numbers, then the should generate new buffer value only when buffer is empty, and then it should pop value from buffer and return it. But I would do something different, I would change buffer into single number, used as seed. At any point of your current source, where you end with buffer.push, you would instead use old value of buffer as input for the transformation (in some way), storing result back to buffer. Then will do yet another transform over it, and return the value. But at this moment the timestamp-every-call will start affecting the statistics of random numbers a lot for particular date-time and RNG calling period. So I would use timestamp only for initial seeding, then the RNG would work as any common pseudo-random arithmetic RNG, with added twist of output stream being further source of entropy. About output stream as entropy source: well, you should check the common output stream byte values first, they are not "random" bytes. From the code it looks like you are aware of that, trying to build an unsigned value ORing 4 shifted values, but the result is only 20b wide for ASCII, and the values are overlapping, so the upper bits of ASCII (not varying much) will affect the lower bits of next character (I hope I did read the source correctly, didn't debug it, BTW for better readability you should put these transformations from string to unsigned into some function, so you can test it on it's own). I would probably take only 3 bits (or maybe just alternating 2+3, to avoid ASCII specific values definition to affect the entropy of such value too much) of each output character, and cumulate them in 32b buffer till it's full (the overlapping 1-2 bits kept for next value), then use it for transforming the seed buffer (so roughly every 10 output chars the seed will get additional entropy). This may still go quite wrong with UTF-8 or unicode16/32 output stream variants, just imagine somebody using it with UTF-8 Arabic texts, having every second byte something like or what's the actual prefix (too lazy to check). About :