Assuming your Windows partition is NTFS (most probably a reasonable assumption): First, find out what label your Windows partition has gotten in CentOS. As root, run 

Use an incremental backup method such as rsync or any other method that suits your OS. Only files that have changed are backed up, so even if the drive is 400GB, most probably only a small portion of that changes from backup to backup. This will only transfer the parts that have changed, but to know this it obviously has to read all files and compare them with the backup. You can simplify the test to only check the modification dates, or you can exclude certain directories that you know does not change (or are not important to back up). The customization is up to you and your particular situation. 

to each wanted client's and see what happens. Block the web server externally as you described if you don't want external access. 

For your use case perhaps the internal SFTP client is not the smoothest way, though. You don't mention OS, but if it concerns *nix, then using an SCP wrapper script directly might be a simple way to save time in the end, creating e.g. and that attempts to upload or download the file given as argument to/from the server respectively, automatically deciding the correct paths from some given base project paths. Set up key based login so you don't have to enter a password every time. Another pro with using SCP from the command line on *nix as compared to the SFTP client is that you will be in a familiar shell environment, most likely Bash, and have access to regular navigation tricks among the commands such as tab completion, command repetition, brace expansion, etc. Personally I prefer version control systems for these kinds of tasks. It will give you simple uploading using e.g. a commit hook, and version control is very handy for code projects. I don't know exactly what you are doing so it might not fit perfectly, but if you like, take a look at e.g. Mercurial or Git. 

I would guess that the archive is damaged. Try downloading it again, and even controlling the checksum if an intended value is given at the download site if it does not work. If it still does not work, try 

to enable it. See for more info. For defining paths for , see the "UserDir directive used" table at the documentation at Apache, reproduced quickly here: 

This file should contain all the information from the last X startup. It is ~300 lines on my system at least, but if you have a phrase to search for it should not be a problem. You could also start with Xfce, save the log file and compare it with the xmonad invocation. 

The code is in (on my system at least). On line 312, the sub that control key presses starts (). It checks and a key mask; by default either combinations with or . shows other possibilities, e.g. which is most likely the modifier. By default, only shortcuts for walking left or right among tabs are defined. It reads current position (), then increases/decreases it by one (/), then sets this value as the new tab index. With this information, it is easy to modify to 

Since the asterisk is now not expanded (as long as it does not match anything in the current directory), sees it "as is", and uses it as a wildcard. You should wrap the argument in single quotes to avoid such context dependent behavior: 

I opened a terminal, issued without parameters and pressed Ctrl+Up and Ctrl+Down. This generated the key codes and for me (do it yourself, the exact codes can rely on terminal, etc.). I then pasted this into irssi as 

It only uses Bash built-ins and thus should be faster than issuing extra system forks for , but the difference is most likely not noticeable, and I/O will be the main bottleneck anyway. 

My first spontaneous thought was Urxvt's Perl capabilities. If you used that terminal emulator, it would be easy to make any text googleable (that's how I would have solved it if I wanted the function since I already use Urxvt). This wouldn't work with GVim, however. My second spontaneous thought is that Vim is open source, and thus it should be possible to customize GVim to do this. More or less work craving though, probably there are better solutions. 

As I said, I have been scratching my head several times over the behavior of directories in complex filter rules for rsync, and perhaps it is clear by the manual, but in that case I have been able to miss it for a long time, so a clarification would be appreciated. 

(or similar designs), then no, or at least vanishingly unlikely. If you are talking about the transformer portion, i.e. this part: 

If there is a new release available, however, it goes on downloading the differences, asking for sudo password (if run by non-privileged user for upgrades). For LTS versions of Ubuntu, I believe it only shows that there is an upgrade available if there is a new LTS version available. Do some more research of the tool to see its exact quirks. 

RAR archives can also "legally" be named e.g. and so on, and that would have to be handled separately in some way if those kinds of archives exist. A pragmatic way of solving this is to replace 

There are a lot of different window managers that can do this. One is Fluxbox. To set the background to black and start the application at the same time as Fluxbox starts, put e.g. 

Find the keycode using e.g. . Just start from a terminal and press the relevant button and note the key code, e.g. 

Well, if the subtitles and their internal distances are correct, though in time incorrectly scaled and perhaps with a constant offset, you only need two measurements (at what times two separate lines in the .srt file actually occur on screen) to decide both the base offset and the scaling offset (linear algebra: for two unknowns you need two independent equations). $URL$ takes two such input times and rescales the .srt file. It's real easy to calculate the offsets even by hand, but it's nice to have help rewriting the timings. Tip: use the first and the last subtitle entries as measurement values to get the best results. If the texts are still not correct, then you have subs for a cut version or something similar. You can use the above technique on each corresponding portion of the two video files, but it will be more work. It probably beats manually retiming every single subtitle, though. 

but that more general version is also more indecipherable :-) (and might have its own share of bugs; if floats are not needed, use the earlier version). ( is actually linked as on most systems.) 

Keys for movement in editors are most often adapted to fit with as efficient usage with QWERTY as possible, and so they will most certainly need to be remapped if you change key layout and want the optimal placement of everything, which you strive. E.g. in Vim, the HJKL buttons are used for a reason with QWERTY, and would most probably need to be remapped back to the same placement after the key map has been modified. What I mean is that it won't help you much to track movement and editing keys and use it as a basis for a new layout, since they are easily reconfigurable (in any editor worth it's salt, and since we are talking about a programmer's layout, we are most likely talking about Vim or Emacs), shouldn't interfere with the placement of the literal keys and have already been optimized (again: we are not talking about Notepad). You are trying to solve a problem which is an inefficient way to productivity, especially for a programmer, **imho**. There would be a much greater effect in simply learning more about the tools (once again: probably Vim/Emacs). You will find that less and less time is spent actually writing characters when programming, and more (but more efficient) time is spent on auto-completion, auto-tagging, auto-indenting, quick function definition look-ups, etc. The keys to do all this are already adapted to allow efficiency, and the big speed boost comes simply with familiarity. Thus I argue that a different keyboard layout is right on comparably destructive for productivity, since you already have many years of QWERTY exercise. If the same analytical training time was spent on QWERTY as people who switch layouts spend on Dvorak, they would also notice a speed boost. Speed comes with explicit training. If you were a copywriter/translator/author/etc., someone who actually spends his time doing work with the literal meaning of the keys, then a different layout might be of help. For a programmer, the best tip is usually to at least get an English keyboard layout, since programming idioms have been shaped by these and their key placement (on my local key layout, are all behind AltGr which is quite sub-optimal). tldr: Dvorak/Colemak/[the next "best thing since sliced bread"] (arguably) solves a problem only for those who enter a lot of flowing text in a specific language (most often English). For programming, the needed keys have not been subject to the same restriction as literal language, and thus it has already been optimized for its purpose (which is not just "write as fast as you can"; it builds more on logical operations. See Vim). I believe that the time spent in learning alternate layouts and the confusion that most certainly occurs time and time again is definitely not worth the effort in most cases (not just your own confusion; others who sit down at the same terminal you last used will throw things at you), very much including the programmer's. 

I guess you don't really want to strip the file name extension and the question is just ambiguously worded, but if you do: 

A problem could occur if you have newlines within file names, but that is usually just a hypothetical problem. 

In short it uses xdotool (package: in Debian) to search for a window with title "irssi" and then activates that window. There are other properties than window name one can search for if those better fit your needs. I'm using a small "trick" to name the terminal "irssi" when it is first started (see the statement in ). The last line tries to 

Removing dust mites is an obvious suggestion. If it's the bearings that are getting worn though: no, you can't really fix that yourself (not in a way that it is worth it timewise, anyway). To minimize this issue in the future, try replacing small (80mm) fans with bigger ones that can do the same cooling at lower RPM. The fans will be more quiet, and they will last longer. If you're not on a performance rig, you might also be able to run some components on passive cooling, circumventing the problem. 

needs to know the width of the presentation window in order to handle line-breaking and scrolling correctly the pane will often get far too small to be usable if you want to be able to handle full screen terminals, 25x80 and other sizes. 

EDIT: implies , I didn't take that into account. As I said in the comments: give us the command output. That will show if the files are actually transferred or just checked for changes and then ignored. 

when pressing scroll lock. Note . If you already get the "human readable" name in following parenthesis such as "" above, your keys already "work" as much as X recognizes them as distinct keys. If so, jump to 3. Add the key codes to . Sample syntax: 

EDIT: Specifically you can strip out the complete function if you don't use tmux or GNU Screen. If you don't run it over SSH or as an irssi plugin, you can easily throw out the logic. Very condensed, this would work for irssi without tmux (but it is untested): 

A lot of lines, but most of it is just pasted boiler-plate code (feel free to ask if any part is unclear). I changed the interpreter to since no Bash specific constructs are used. I moved the transcoding part to a function for clarity. 

Using Python's internal syntax, the strings will be protected from everything except three quotes. Using in this fashion will invoke the Python program once for every line. This works in the example you've given, but your actual task might be different (which is why I asked for a specific example in the comments). Perhaps the quoting "trick" might be of use anyway. If Python is to be used at all, it seems easier to just do all the manipulation from within the Python code; it is after all a competent scripting language. 

you will open a new split window on the right side, 20 characters wide, and start reading the nick list therein. You can write a simple startup script for tmux that automates the last step (starts irssi and splits the window to read the FIFO). Here is a small example: 

If it was just a single machine on your home network that had the problem, I would tell you to check the hosts file to see that there wasn't a rogue entry there, but unless you have an unnecessarily convoluted home network setup, this would probably only affect just a single machine (unless you have permeated the change to all hosts files, but you should be aware if this, I reckon). 

I tried to keep it as similar to yours as possible for easy comparison. Comments on this script and yours 

in a case insensitive manner, you can probably get a good guess of the remaining video files by searching after all files above a certain size, perhaps excluding some usual non-video suspects such as 

et voilà! (Possible caveat is file names containing newlines, but in practice I have never seen these. Requires some simple modification to account for that as well) 

I'm assuming/guessing that the apostrophes are not supposed to be included in the output. Standard shell solution, where is the file containing the input: 

A helper script called has been made for this. Even if you won't use the explicit script, look at the (very simple) code to see what is done. 

Perhaps you want to span directory names as well - it doesn't. Give more info on the exact paths if you want a solution for that. 

Let's say you set up the panes at a certain terminal size. If you attach to this session from a terminal with differing size, tmux will resize the panes, which will be problematic since 

That was the first problem. The second is the concept of so called "greedy" matching: will see the first and then try to match the largest string it can. If you have several HTML entities on a single line, this would be a problem since: 

This will extract the full directory structure, then move all files within to the directory. Note since there might be several files with the same filename that need to be selected from. 

You can always symlink in directories from outside the web root, or use an "Alias" (even better) in the configuration to point to a specific directory outside the web root. The logs are only readable by root and the group as default, which is a security measure. To begin with, you'd have to give the Apache user read permission to the logs to be able to serve it via http. This can be done in a couple of more or less bad ways. I'd recommend to actually not have the logs readable over http, but if you really want to do it, know that it is considered a security risk to give e.g. the Apache user write permissions to the log folder.