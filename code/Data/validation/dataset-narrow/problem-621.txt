This returns a hash that gives the ball (value) at each offset position (key) after all rearrangements have been made. Examples 

The class methods Matrix::column_vector and Matrix::row_vector are used to convert to a column vector and to a row vector. Matrix#* is then used to compute the outer product, a matrix that contains the products of all pairs of elements from the two ranges. That matrix is then converted to an array, flattened and 'ed, to eliminate duplicates. Compared to approaches that do not use matrix methods, this one has some extra steps and greater memory requirements. However, the computation of the outer product, being implemented in C, should be relatively fast. Whether this method is faster than other methods is an empirical question. (Edit: the benchmark showed this method to be relatively slow.) #2 The second approach employs a bit of fine tuning to boost performance: 

1 You can do this without using , but using here is the Ruby way. You can think of , for example, as a more compact form of . 

This array is returned by the method. If you would prefer less chaining, go ahead and add temporary variables and/or additional methods. The more you work with Ruby, however, the more chaining becomes the natural thing to do. It's no more difficult to debug, as you can do what I did in explaining what I've done. In deciding the proper balance between conciseness and the use of temporary variables and separate methods, I'm always thinking about how the code reads. Aside from performance, my main objectives are to make my code read well and read fast. I want an experienced Rubyist to be able to read and comprehend it in minimum time. Personally, I much prefer reading tightly-chained code to code that is all spread out, uses lots of very short methods, lots of temporary variables with highly-descriptive (and accordingly, long) names, and so on. It would take very little time (well under 30 seconds) for any experienced Rubyist to scan my code and have a general idea of what I was doing: creating an array of directories, converting that to a hash, sorting the hash on its keys, transposing the resulting array, extracting its last element and flattening. Yes, they would have to look more closely at certain parts, such as the regexes, sort criteria, and so on, and for that I would help by adding a few comments. Comprehension of some parts of the code, including , and would be virtually automatic, so it makes perfect sense to express those three operations as compactly as possible: here, three words separated by dots. What I've just said is the opinion of one Ruby hobbiest. I invite others--particularly those who write Ruby code for a living--to weigh-in on these issues by adding comments. 

It takes a couple of seconds to generate the hash, then each random string takes very little time to generate. [Edit: Flambino pointed out that it makes more sense to use an array: 

See Array#reverse_each and Fixnum#<<. The following is an optional extra that is not directly related to your question. In the code directly above, the first value passed to the block will be 

I have assumed that, in both and , the values of are unique. Here's one way to extract the desired pairs. Code 

Suppose, for example, and are to have and tuples, respectively, and in cases, the first element of a tuple in matches the first element of a tuple in . Thus tuples in have no match in and tuples in have no match in . Then 

but only a fraction of these are shown in the documentation. Perhaps a reader could provide an explanation. In any event, the two methods I mentioned are used as follows (when applied to @Ben's example): 

determines if player wins on the minor diagonal (top right to bottom left). I was unable to find a way to check the minor diagonal using class methods. 

However we already computed: where is (now) at offset . Since , we infer that is still the largest element in . Therefore, we know that: equals: 

Though I am not a professional developer, I will venture one suggestion: learn how to use String methods and regexes to fullest advantage. Sometimes it is necessary to use , , etc. to convert a string to an array of strings (possibly single-character strings), manipulate the array elements, then re them into a string, but there is a lot you can do by working on the string directly. Here, for example, you can use String#gsub with a block: 

Note that methods can be added to or deleted from the module (or renamed), with no need to alter any of the other code. A variant of this approach would be create a subclass of the main class for each of these custom checks, and then use the hook Class#inherited to build the array . 

We now sort the keys. would raise the exception because cannot be compared with . We therefore need to define the "spaceship" method, that is to use. Since we want the key to be last, we do it this way: 

Again, the block is not used because does not have a key . The third element of is passed to the block: 

Ball will change positions in until rearrangements have been performed, at which time it will be at offset , and will remain at that position (i.e., it will be at its final position). therefore satisfies the following identity: 

It follows that for , the odd expression of applies and for larger values of the even expression applies. We form a hash that maps into and then invert the hash to map into . 

You asked for something simple. This most definitely satisfies that requirement, but it's not especially elegant. generates distinct strings of the sort you want. Since there is a 1-1 map between strings and integers between 0 and 2,704,000-1, it's obvious from the code that the strings are random and non-repeating. 

The third element of () shows that the eastbound car in that position is being followed by one other eastbound car. The fourth element () indicates that the westbound car in that position will pass two eastbound cars. 

The important take-away here is that we only had to compare with to to determine if a better solution could be obtained by entering the market on day 1. As shown below, the same is true for entering the market on days 2 through 7. When we reach day 9, we have to do a little work. At this point we know that if we enter the market on day 0 or day 1, the best net gain is . Here are the calculations for each of the remaining days: Enter market on day 2 

This saves all those methods in the class instance variable . One could then use the earlier approach to make the validity checks that draw only on the information in , and cycle through to perform the others: 

Main method You want your code to tell the story of how you are solving the problem, starting with the general picture and then working down to the details. Your main method is . I suggest you change the name slightly: 

If we cash out at the end of day , the net gain is . For example, if we cash out on day , the net gain is (). Therefore, if we enter the market on day , we maximize net gain by computing: 

I've used Enumerable#each_with_object (v1.9+) twice, as it provides a convenient way to build an object such as an array or hash (which is returned). In the first case the object is an initially-empty array (with block variable ); in the second it is an initially-empty hash (with block variable ). I will use your data--with two changes--to explain what's going on here. I've added an empty directory and a file to the directory to . 

Rather than construct the polynomial string incorrectly, then fix it with regex's, it may be easier to contruct it directly. This is one way you could do that. 

Matthew, it appears to me that you are only making use of the two elements of whose keys are the top two in the sort. Please correct me if I am wrong. If that is the case, I believe your code (after "edit") can be simplified to this: 

For this example value of , this is what's happening: First save each coeffient's index with its value: 

Suppose the arrays were large and you were looking for an efficient solution. Let and denote the two arrays, with being the smaller of the two. First, convert to a hash: 

Assuming you can use Ruby's standard library, there's no reason to reinvent the wheel. What you need is contained in the module OpenSSL::BN, namely, the methods OpenSSL::BN#to_bn and . I can't find documentation for the latter method (or for other instance methods in that module). Note: 

You can also use Ruby's Matrix and Vector classes to see if player wins. In the following, is the player in row , column . Code 

Examples Actually, I am not 100% certain this is working, because I am not familiar with JSON, but I expect it will not be difficult to repair if there are errors. I did a poor-man's test by commenting-out and running: 

One of my hobbies is woodworking. When I'm about to embark on a new project, I have a general idea of how I'm going to do it, just based on experience. I almost always begin by working up plans with Sketchup, which includes the materials I'll be using for each part. I then give considerable thought to which individual boards I'll use for which parts (e.g., to emphasize, downplay or match grain, and minimize waste), and the order in which I'll be performing various operations. For example, I know I'll be jointing, planing and sawing to square up stock, and want to do that efficiently, to save time. At that time I don't give much thought to the tools I'll be using, because I know the choice will generally be obvious, and when it is not, I can decide that later. One thing I never do, however, is ask myself whether I should be using power tools or hand tools for a project, for I know I'll be using both, whatever tool works best for each operation. I expect most people take a similar approach to coding, which leads me wonder whether your question can or should be answered. I am not questioning its merit; if nothing more, it is good food for thought. With regard to metaprogramming, although we all know what it is,.. Stop there. We don't, or at least I don't. We probably can agree that anything having to do with singleton classes probably falls under metaprogramming, but what about hooks like and , , , even lowly , and more? Moreover, while some uses of metaprogramming are truly mind-bending, others are dead-simple (e.g., using a class instance variable instead of a class variable). So what criteria could possibly be employed to decide whether a metaprogramming approach should be taken to a particular problem or a class of programs? One knock against metaprogramming is that it makes it difficult for other coders to understand what's going on, and therefore should be used sparingly. I would tend to agree when the metaprogramming is both complex and unnecessary. Only 'tend' because life is complex. Forget not our responsibility to teach. Sometimes that means doing things that cause others to struggle. Let's say you've done some metaprogramming that has been given to me to maintain. Knowing little about metaprogramming, it takes me awhile to figure out what you've done, more time that it would have taken had you used a less sophisticated (ww?) approach. But then I have an 'aha' moment and think, "now that's cool, very cool indeed", and realize I could apply the same approach to another project I'm working on, allowing me to save a huge amount of time, and impress my co-workers in the bargain. 

These two expressions cover all the products. If is even, the situation is slightly more complex. Suppose and , so and . In this case we will perform the same calculations as above, but for and . We must then add the combinations involving the midpoint, . An efficient way to do this is as follows: 

This is quite straightforward, similar to what you would see when using a procedural language. Here's a recursive approach: 

This time, both hashes being merged have the key , so the block is called up to determine the value of that key: 

Not hardwiring "500" makes the method more general, facilitates testing and helps explain what the method does. In general, hardwiring is bad and doesn't buy you anything. Perhaps we might call the method . Make the main method simple, showing how the calculation is made is the simplest of terms: