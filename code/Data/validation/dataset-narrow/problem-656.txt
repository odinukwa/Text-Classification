The try-catch is necessary if there might be more than one "consumer" thread trying to set the value of the promise. Also notice that we're assuming that there is at least one "consumer" thread; if there's only the "killer" left, then it'll wait forever since there's no "consumer" left to finish emptying the queue. 

I'm also now vaguely worried about exception-safety. The good news is that node handles are fundamentally memory-leak-proof; if you destroy a node handle without inserting it anywhere, then the destructor frees the node (and its contents) for you. The worrisome news is that can definitely throw (most obviously, if resp. throws), and it wouldn't surprise me if could throw too. Do we need to do anything special to deal with exceptions here? I think the answer is "no, we get the basic exception guarantee that nothing will go horribly wrong as long as you don't try to use those iterators again," but I haven't formally explored it. 

Look into the library in general, for list-and-sequence-manipulating commands. You're looking for a way to "flatten" a list of lists; calls this . 

(Expand it out. Do you see why the control flow goes wrong?) Whenever you write a "statement-like" macro in C or C++, you must wrap it in for hygiene. Also, consider what happens with 

it in . Style Avoid in favor of . is better written as . Avoid mixing and : keep conditions in and side-effects (like ) in . Repeated and Each (and et al) allocates a fresh list, so doing a repeated can waste memory (and garbage collection cycles), so either using 

You do 17 iterations when only iterations are necessary. Recalculations Now compile to turn recursion into a loop and see: 

The seems to be no reason to use lists as opposed to arrays here. I would use multidimensional arrays instead: 

Lisp is a multiparadigm language. is just as lispy as recursion, and, in a way, much more so (think in HOFs)! Style 

note the use or instead of . Another interesting optimization is changing the iteration in from descending to ascending. This should speedup it up considerably as it would terminate early more often: 

Minor Paren placement Hanging parens are an eyesore. Global var Use instead of to create global variables. Sharp-quote for functions You should do instead of . Unnecessary allocation Since your returns a fresh list, you can use instead of . Major Sum Your function is broken - it will not work on long lists, see . Here are better ways to do this: 

The actual code implementation looks fine to me; nothing to complain about there. :) You might be pleased to (or, you might already) know that is part of the Library Fundamentals v1 Technical Specification, which I think means it ought to be coming to C++1z. However, it's not in the working draft yet as of N4567 (November 2015). 

Your function is on its way to becoming an unmaintainable mess. Rather than write out every case by hand, you should look for a way to factor out the "differences" between the cases into small functions; then assign one of those functions to a local variable and write the "samenesses" just once, in terms of . 

Speaking of trouble with carries, let's look at the shift-left and shift-right functions. They're interesting because you're using for the shift count itself, which is unlike any programming language or instruction set I'm aware of. The shift count can only sanely get as high as the log of the left-hand operand, which is to say, it had better fit into . But okay, let's look at right-shift and find the place where you do "If the right-hand operand is bigger than 4 billion, just set the result to and return"... 

is C/Java style. Lispers use or . is clearer than . Lispers use indentation, not paren counting, to read code. Your code is thus virtually unreadable. Please use Emacs if you are unsure how to format lisp properly. 

Doc string (no more than one, but it can be multi-line!) usually comes before the declarations. Please see Syntactic Interaction of Documentation Strings and Declarations: will define a function which has no docstring and return , while will declare a function with a docstring, returning . should be . should not be used if you know that the object is a ; use instead. There is no need to bind and in since they are used just once. is, I think, more "idiomatic" than in your case. It is clearer to use in . 

However, no such allocation happens with so there is no reason to avoid nested reduces. Note that the proverbial "sufficiently smart compiler" should be able to handle these problems (but not necessarily the quadraticity above!), so you should only worry about this if you discover it to be the performance bottleneck. Remember (SICP): 

The way quick sort is defined (requiring random access) it cannot be efficient for linked lists (especially immutable ones). I recommend a recursive implementation of merge sort. It will be clear and concise. It should also be relatively efficient. 

Admittedly the above code generates two warnings on both GCC and Clang, and it's a hugely unlikely refactoring anyway; but still, if this were my code, I'd use in both cases. 

The macro leaks out of this header file, which is unfortunate because it has a very short and possibly contended name. If the user has their own macro, your header will break for no obvious reason. recommend renaming it to , and ing it at the end of the header file. 

where the "hell" expresses itself in the form of a big triangle of whitespace along the left margin. You'd typically see this with API functions that take an "on success" callback and/or an "on failure" callback. 

Notice that I personally prefer to use the original template parameters , , etc. in places where your code used the member typedefs , etc.; I find that this improves readability but I believe reasonable people may differ on the subject. (In particular, the C++ Standard always uses member typedefs in declarations such as as opposed to ; but I think that's because the name is part of the API of the class, whereas the name is given for exposition only. That's a Standard-ism that we don't necessarily need to emulate when writing our own code.) 

You are checking the primality of the same numbers several times! Extra optimization can find a divisor, not just check primality. Optimized algorithm 

The second (recursive) version can be made tail recursive using an accumulator. This would help some compilers produce better code. 

You are doing fine, other than a few simple nitpicks. You are not using (which is a crazy thing to do anyway), please drop it. You should fix your indentation, it would make your code much easier to read. You probably want to divide by , not , in and you probably want to simplify the code there by dividing by instead of multiplying by the reciprocal; also is relatively expensive, so, if you were not i/o bound anyway, you might want to replace it with multiplication. Function should probably return multiple values instead of a . Global variable should be local to . Function should probably be called (it read the whole list). 

Note that takes so you can write instead of (you also want instead). Furthermore, is quadratic in length of the input string - it can be made linear instead. is a usually used as a prefix for iteration macros. Also, you call in twice; you can use to remove one call. Your line breaks in are very confusing. You can use instead of in because returns a fresh list. Summary I think your code is overkill. 

It's just asking for this kind of bug. Whenever you touch memory (via the operator, mainly), that should be on a line by itself, with no other memory references on the same line. The following is a cleaned-up version of your function â€” just changing the style to make it obvious where the bug is. 

so that the compiler would deduce the types for you. (And in this case it deduces ; but you as the programmer shouldn't have to care about that. Just let the compiler do its job and you try to stay out of its way as much as possible.) 

Any time I see a global constant string like , that's a code smell. (Especially such a specific string: I immediately smell that it is probably used in only one place.) So I looked a bit closer and found that it was used in only one place, in the constructor: 

(Self-answering for posterity.) There's a major flaw in my above implementation of : It calls ! This can cause the thread to block indefinitely. We need to eliminate that somehow, or at least make sure that we only ever call on a future that has just been passed in as the argument of a callback. The reason I was calling was to work around a type incompatibility: the type of 

You are not using tail recursion in , so the compiler cannot easily turn it into iteration. It depends on the specific problem; in this case I would probably do it iteratively. Sure, is useful and convenient. 

Implementations The first (HOF) version can be much more efficiently rewritten in using (provided returns fresh lists): 

Trivial Use instead of . Avoid very long lines (Emacs will indent for you). Do not use when a single without would do. Memory Use instead of when possible to avoid unnecessary consing (in your case, allocates a fresh list, so its result can be passed to ). Catastrophic Whenever you use , you are using the wrong algorithm. Optimal search is linearithmic: . Insert search is quadratic: . Your implementation is : 

is unreadable. is better. is far too high precision. With such an epsilon, you might as well use instead of - the "oscillation between two adjacent floats" problem will be the same. Read up on machine epsilon. This number should actually be an argument to . Adding a line break would make the function more readable. 

You compute twice - this is a waste. You return instead of the improved guess, i.e., you return a worse approximation than you could. 

I would additionally expect to be marked , and to be marked . In general it looks like you're not marking as many things as the STL would have marked. 

It's a little bit "weird" to have an opening curly brace without indenting the following lines; but it's equally "weird" to have a (non-member) function definition that doesn't begin in column 1, and having to indent all your code past column 1 is much more painful to read and write. The benefits of "collapsed" style really start to show themselves with 

Consider providing and possibly a template in addition to your . Of course this just increases the surface area exposed to the deadlock bug above; so start using first and add these member functions afterward. 

Anyway, these signatures are both getting into crazy metaprogramming, but the point is that I want to be able to construct a engine from e.g. or or whatever; I don't want to have to copy my key into a in order to build a . 

Incidentally, I don't know what the initialism stands for, but you should be aware that to a native English speaker it bears an amusing resemblance to "omfg". :)