Your algorithm is not doing the same thing as the original. The original randomizes the entire string each time, except the correct bits, while yours randomizes only one character each time. You can iterate directly over lists. So you don't need , you can just do . You should define as a new variable on a separate line so you can re-use it. You can use the modulus operator to keep the index inside the correct bounds. 

However, the biggest advice I can give is to use a bit of mathematics with a to get the results. If you multiply the score by 10, then convert it to an (which gets you the ), it will be an integer from 0 to 9, inclusive. Then you take the of that and , which will handle the case. Then you can set up a dict for the letter values: 

Don't use globals, pass variables as function arguments. Follow pep8 Don't use . , , , , and empty sequences like lists or strings are all considered , so in your case you can just do something like . If you need to test for specifically, use . Don't do , just an empty will return automatically. Don't do a blind , you should always check for a specific exception. For the loop, use to keep track of the current index. Use . This will automatically close the file when you leave the block, even if there is an exception, so you don't need to manually close. In , don't catch the exception at all. The default exceptions give the user more information and more useful information than your exceptions, so just let them be handled normally. It is clearer to do something like rather than . Or better yet , then . shouldn't be a separate function. 

Follow pep8. Your code is pretty good already, but your naming in particular is not correct. Although I can see the advantage of grouping everything into a class, the individual file parsers are not directly dependent on the class. I would split those out into their own functions. This will make testing in particular easier. You can then have wrapper methods in the class that call the parser functions. You are loading every file completely into a list. This takes a lot of memory for large files. Worse, it requires parsing the entire list twice, once for the header and once for the body. This is likely a big source of your performance issues. It would be much more memory-efficient to iterate over the lines in the file. I would recommend turning the reader into a generate that takes an iterator (which will usually be the file, but could be arbitrary lists of strings for testing), does the stripping, yields the stripped line, and skips empty lines. This has the added advantage that it will keep track of your progress, so you don't need to go back and read through the header again when you want to parse the body. If you use a generator, you can create a for loop that runs until it reaches the part you want, then breaks, then you can have a second for loop that picks up where the first left off. This will greatly reduce the number of tests you have to do. You are parsing the list of numbers yourself. Don't, numpy has a function that can parse a string to a numpy array for you. It is much faster than your approach. This is also likely a major source of performance issues. You should always use for opening files. This safely closes them even when there is an error. In the default Python version, files are closed automatically when the function exits, but that doesn't necessarily happen in other Python implementations like Pypy. It is much safer to use to close the files exactly when you intend to. You can use tuple unpacking to split the lines for your dicts. So . You create a class, but then parse everything into a single that holds everything. That defeats the purpose of having a class. You should either parse the components into class attributes, or you should just use functions and return a single . You hard-code the file names. I would make the file names arguments, with the default argument being the default name. is a directory, not a repetition. The repetition may be in the directory name, but there is no reason it has to be. So this is stylistic, but I would call it or something. There is no reason to mentally limit how you organize your files like that. You make all the parsers subfunctions of . This again defeats the purpose of having a class. They should be methods. Your classes should derive from . 

I find all the rows of and with some non-null values ("good" rows). Rows that aren't good are then filled with . I find all the rows of and where the last value is non-null ("perfect" rows). For rows that are good but not perfect ("imperfect" rows): 

In , I would use a ternary expression: can be made even more efficient by having return if the loop finished. Then you just divide the result of that by 100. This will result in 1. if the loop exits, avoiding the test entirely. I would only do run in your loop, and store the result of that function to a 2D numpy array. Then you can vectorize the rest of the calculation, since it is all just basic math. This should substantially increase performance. You can even move the outside the for loop to further improve performance. If the previous suggestion does not increase performance enough, you might be able use to further increase the performance of the loop. For an even more extreme vectorization, you can do all your calculations on all pixels at once. Rather than having a function, just use . Follow pep8 I would put the current contents of the block in a function and just call that function inside the block. In I would allow the code to pass a string (which defaults to , and use to dynamically call method with that name. I would rename to . I would put in an argument for that lets the user change . Similarly, I would put an argument in that lets the user change to something else. should accept that are then passed directly to the or method. I would move the and lambdas into their own methods. Or better yet, I would refactor so you just pass the and argument. In , I would let the user set the scale with an argument. The argument would default to . If it is , it would be computed automatically as is done now. In , you only ever work with integers. So I would use in to make sure it returns an integer. This allows you to avoid the later integer conversions.