Depends on the game. In a obstacle course/parkour type game against a time limit it's common to add checkpoints that add to a time limit which is tight enough to that a big mistake will cause failure. In a puzzle game however like your example then just letting the time run out is a better idea. It's probably also a good idea to let them undo actions that were wrong and let the player find out that they were wrong for themselves. If there is only 1 solution and you warn the player as soon as he makes a mistake then it becomes a not-fun game of trial and error. Rather than the mental challenge you are going for. 

makes a copy of the data and stores it in the VBO. This will then be uploaded to the gpu and the client can free/reuse the memory. 

You can get the position of the eye and test . This checks that the angel between the viewing vector (from v to the eye) and the normal is less than 90Â°. 

This results in the (dx, dy) vector being from the refPoint to the touch point (as you would expect). 

You then have the centers of the BB without having to know the size of it, if your game needs to know the centers more often than the top left then that is preferable. Storing the half vectors is to simplify retrieving the left/right and bottom/top vectors center-halfHeight provides the bottom and center+halfHeight provides the top. Granted all it does is avoid dividing by 2 but when it's done often enough the difference can be felt. 

If you know the problem is a too detailed environment then you should be able to fix it by toning down the details. You don't need to model every leaf of every tree, instead use a few intersecting textured transparent planes to create the illusion of volume. You don't need to model the window sills of the buildings you are whizzing past, just use a simple box and and bump-mapping to create the illusion of depth. You can set the shadows statically with textures so you can disable receiving shadows on those objects. Only the road surface and your car will need to be able to have a shadow cast on it. 

it's as simple as drawing a line from the anchor to the object after you calculate the location of it, you can also make the string thinner as it gets stretched to imitate a rubber band stretching 

You only need to render the triangle IDs when you need to pick and if the rendered scene changed (object moved, camera rotated,...) since the last time you needed to pick. You can also improve picking by only rendering what can be picked. No need to render the background into the color pick buffer if it can't be interacted with. You can simplify the geometry of the pickable objects as well. Often you can use a smaller target texture than the 4kp screen as you only need a small area around the mouse. Applying a scaling offset matrix at the bottom (after projection) of the transform stack will let you render only the needed area. If you absolutely refuse to do color picking then can use a raycast instead. This will cast a ray and return the first object it hit. This works fastest with a spatial partitioning so you don't need to iterate over all objects to find the one that hits. 

Why are you moving the viewport? You should only really touch it when the screen resizes. because you move the viewport everything outside it will not be drawn. instead adjust the view matrix to move the "camera" to where the player is this allows you to have larger levels as well. 

The tie-breaker is the heuristic. The next node to process is the one with the lowest where is the known cost from start to the node and is the estimated cost from the node to the destination. To guarantee you get the shortest path this must underestimate the remaining cost. A common one is the path as the crow flies. 

in particular there is no need to push the coordinates through a and the should be the last coordinate, there is a micro optimization that stores the in a temporary variable but I expect an optimizer to be able to deal with it. 

Your current algorithm is not dijkstra. Instead it's breadth first floodfill with a buggy loop elimination. Dijkstra implies that you sort the open list according tot he cost of the tile. Fixing the loop check requires something like: 

After some rounding errors energy will be different from one step to the next. Most physics engines just let you apply forces to objects nilly willy and don't care where the "energy" for the work it is doing would have come from and letting the programmer decide how it came about. 

you should only need to rotate around the y axis or you can just say to look at the point on the y-axis at the same height of the camera 

The positions and color (and all other vertex attributes) all use the same index buffer, there is no way to change that. So if you have an index then that vertex will have the position at index and the color at index . The size parameter indicates how many values to take (1 to 4). Sometimes positions are stored in the homogenic format (essentially add another dimension which is always 1 for positions and 0 for directions). This helps with matrix transforms. For your colors attribute that should be 4 because you also pass in the alpha channel. But for your vertex that should indeed be 3. 

Instead of running immediately these could also be set as a delayed event with a 1 tick timeout to avoid infinite recursion caused by events triggering each other freezing the game. Note that neither of these solutions use sleeps or multiple threads. 

the dot product is equal to the most you can get out of that is whether the angle is acute or not or pass to other algorithms where you can delay the normalization. But you can get the normalized from the non-normalized by dividing with (saves a sqrt calculation) 

You can use an image. Each pixel will be a tile and each 32bit color will encode several values like alpha=0 means impassible. Then you can use any image editor that allows you to save in a lossless format and choose the exact color values. 

You can use instancing and a texture atlas to combine all the draw calls into a single one. You only have a single 4 vertex VBO with the 4 corners and an index buffer to draw them using . Then in a separate VBO you have the position and size of the quad (in a single vec4) and the position and size of the texture to use in the atlas (again as a vec4). 

Minecraft uses some fixed length data for all blocks, which includes the numeric ID, metadata, and light level. Having this fixed length help a lot when reading it in. You don't need to use NBT (it is essentially a binary json with more types) but I do suggest putting it in a fast lookup structure (HashMap) to get the additional data related to a set of coordinates fast. 

of course then you can start to optimize because is and all the other ups will be the same again (do double check that though) 

you can group the objects by needed mesh so you can batch the draw commands without needing to swap out the mesh buffer for each object this eliminates the need for objects to know about how they are drawn 

In minecraft there is a distance based decay with a very short decay distance (16 blocks range). What you need it a connectivity test between graphs. One way to do it would be repeatedly take each edge and combine the connected nodes and into a single node. After all edges are gone you will end up with a node for each network. Then sending power is trivial. 

Actually this is like any tile based movement from a turn based strategy game. You can simply flood fill the tiles from the selected character to find which should be highlighted. Psuedo code: 

descent uses a portal rendering engine this engine divides the world in convex rooms and the engine knows which room you are in then to render you render the rooms faces and for each visible face that is a portal you adjust the frustum and render the room that the portal links to in psuedo code: