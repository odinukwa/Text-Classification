To make my point I have to reach back a little bit. I suggest to read this all or nothing. I currently came from a project where they used an "event bus"-like mechanism. It was used in the context of the web ui framework Wicket. Wicket itself provides an event handling. In the special case of Wicket they had to solve some problems. The Wicket internal event handling was based on defining an event and provide it to an event sink. This sink was an ui component in the wicket ui component tree and there was no need to use the root. Furthermore you have to define in which direction the event should be sent: upwards the hierarchy or downwards. So with this mechanism some parts of the hierarchy may not be reachable with only ONE event. So often there were more than two events involved to achieve the wished goal (in their case to update the ui component). In one case they had defined a cycle by making two receivers also senders passing event to each other forever. Then they came up with the idea of a central instance responsible for registering as an event sender and registering as an event receiver. This is nearly exactly the szenario you have. Honestly, this is a much better approach than the original wicket event handling. And many sites write recommendations on that and all in different contexts. But there are also some problems remaining. For example if an object registers as a sender of an event that already was registered you have to decide wether to allow it or not. Will a change of a sender or an additional sender affect the receivers? One other thing is you have to keep your events semantically unique. How do you ensure not to have two events (accidentially differently named or typed) that mean the same. Or vice versa: One event triggers receivers that accidentially listen to this event? This nearly always happens if you have abstract/generic algorithms that fire events like "Update". You have to ensure that your events remain semantically concrete. And because you can only identify an event by its type the information who sends the event cannot be evaluated usefully by the receiver even the event contains the sender. The receiver cannot distinguish between different senders of the same event. This information cannot be reconstructed. Here is the thing: An event bus should replace the observer-pattern but it doesn't. An observer-pattern decouples two objects in one direction. The receivers were nearby when they registered themselves to the sender. An event bus decouples two objects bidirectional. The receiver is now coupled to the event type. Because of that and event types should be semantically unique the receiver is implicitly coupled to the type of the sender. So the receiver is not able to distinguish between different senders of the same type anymore not as the observer-pattern. And if abstraction and inheritence is involved you can easily crash your event bus. I don't say: Do not use an event bus. But I strongly recommend to prefer the standard observer pattern. Everything else will lead to things you have to memorize additionally in every day you use this. You always have to be aware of the restrictions of such an event bus. The observer-pattern really has no disadvantages in its concept. Maybe you have ONE disadvantage within concrete programming languages: effort to write "a lot of" code. Some mainstream developers also address that you have to think about how to reach the sender within the object structure to register as a receiver. Yes, you have addtional effort to think about the composition of your objects. But that you always should do. Why are you thinking about clean architecture? By using the observer pattern you maybe have to write more code but it is not producing ANY PROBLEMS or has ANY RESTRCICTIONS you have to be aware of when apllying it correctly. In implementation deviations from this concept you may write less code but you definitly produce problems. This has something to do with irreducable complexity. No I am not a creationist. You have to think about it like a compression algorithm. An observer pattern is a lossless compression of a modelling problem. An event bus is a lossy compression of the same modelling problem (at least in OO). And because it is a lossy compression must be aware of the errors. The rethorical question is: If you bring up clean architecture as the base and the effort of design why then using a "lazy" implementation of the observer pattern? 

It is true. The difference lies in semantics. Interface owned by its own class The core is: EVERY class has an interface aside the language construct "interface". The problem is: Sometimes it is not beneficial. If you have a class in JAVA sometimes it is hard to ensure encapsulation. Therefore you hide the class behind an "interface" language construct. The separate interface of a class is only an extraction of the interface the class already implicitly has. You can compare it to the header file in the programming language "C" where it provides perfect encapsulation. In JAVA it is a helper construct which is not enforced. So nothing hinders you to use the concrete class implementation instead of the interface. In "C" you only make the header files known to other compilation units (I hope so, as I am not a C-developer). Interface owned by the framework The other way around: A framework provides functionality. To let your object cooperate with the framework they have to meet some requirements that are formulated as "interface" language constructs. Here comes the complicatet thing: You may have a class with an extracted alternative interface AND you want to have a contract to work together with a framework. Then you have two interfaces with different semantics to handle. The clean architecture If you consequently follow the SOLID principle it will guide you to exact this architecture. You have no chance to miss it. Your code In general I do not think that pressing a button is a usecase but I think you have a correct reference implementation of clean architecture. 

Sets as significant states You should think about the problem solving process in the whole. Currently the algorithm is ruling the structure. Some examples... Here you explicitly encode the final state as an expression: 

Thread safety To avoid inconsistency in multithreading environments I considered the start()-method to be synchronized. Again, this is optional for this simple exercise. Code 

General I was struggling about making this code review as in the first place I saw "a lot" of classes and separations of concerns (so my guess). But I went deeper into the analysis. Finally I came to the conclusion that something is strange about it. Do not get me wrong. You have basic modularization. But this has gone into only one dimension. You separated concerns vertically but not horizontally. Action The first thing which makes me think about is not beneficial polymorphism. An indicator for unfavourable polymorphism is that no behaviour is encapsulated. The only method in your Action enum with something to do is "byActionNumber". And this method is not under polymorphism. "isStopCondition" and "isChangeNumbers" are unnecessary indirections. You can evaluate directly the type and it is worth the same. Maybe at least "isStopCondition" is adressing another aspect. An inheritance hierarchy with each subclass providing same amount of boolean getters that will evaluate if the current instance is of a specific type makes this inheritance at least boiler-code. But furthermore you provide internal knowledge that you wanted to abstract in the first place. Calculator The Calculator has too many responsibilities even if it delegates tasks to its known "friends". Effectivly the Calculator "inherits" the responsibilities of all sub components. So effectively your Calculator ... holds the process state ... gathers input from a scanner for process purposes ... produces intermediate output to the console for process purposes ... gathers input from a scanner for calculation purposes ... calculates (this is what a Calculator is all about) ... holds and maintains the history ... produces the calculation result as output ... produces the history as output One reason for that: you haven't introduced abstractions at certain points. You are violating "dependency inversion principle". You can easily figure out the resulting coupling and god-like responsibilities by asking following questions: