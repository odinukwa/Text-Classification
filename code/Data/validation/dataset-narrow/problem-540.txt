The idea of starString is to turn into a row of stars. If starString gets and empty list, we can assume that we've reached the end of the line, and can add a newline character. 

You were really close to this one with your function. Going a little further from there, we can use Haskell's pattern matching system to adapt the same function to any size of list. The resulting code has a lot fewer lines, and I suspect runs a little faster. Personally, I find recursive definitions to be more readable in many cases than mapping and filtering (pipeline approach), but that's just a preference. For the histogram, I iterate over the list 10 times to count the number of occurrences of {0..9}, which is O(n). I then make a row of stars for each number in {1..maximum (counts)}, which is also O(n). I'll get back to you with a performance comparison with your code later. 

First type is a first order improvement that can lead to exponential improvement in the runtime and any reduction of this step will also remove the need to do the checking step. Second type is a second order improvement which at most will lead to a linear improvement in the runtime. For first type improvement, I'd do the following which makes sure I only loop through numbers which are larger than the palindrome I've already found (therefore no checking is needed to see if new palindrome is larger.. note that if you have this check, by the time you get to it, you have already lost the exponential speedup potential of pruning the search space and this check only provides at most a linear speedup.. the below approach actually prunes the search space): 

So to conclude, an interruption should always be as short as possible and only used to manage flags which alter the behaviour of your main code block. Hope this helped, comment any question that you might have with what I've explained. Note: The code only wants to give you an idea of how to manage interruption, so it may not be the one that fits your needs. 

The code works as intended what I am concerned about is optimization, how to improve this code in both, execution time and stability. What I am doing in this code is compare each element from one list with ALL of the elements of the other list (I see a problem here, but don't know how to approach it well, the foreach seems not to be the best option here). 

With all due respect to solutions offered, the solutions offered here are naive (naive in the sense of something that someone unfamiliar with computer science algorithms would think of). The most optimal solution will most probably be implemented using a dynamic programming approach (at the risk of stating the obvious I must emphasize that dynamic programming is not a language but an algorithmic concept that can be implemented in any language) where the program recursively finds smaller palindromes and combines them into larger ones when possible. The main problem with solutions offered here is that many sub-problems (which are essentially the same) are computed over and over and over and over again (you get the idea). Actually, I just did a search for this and an elegant solution using dynamic programming is offered here. :) 

The code works as intended but, as said, I would like feedback on what I can improve in this code. That explains why I post this question even though there exist duplicates of this one, I just want feedback on my code, that's all. Thanks in advance for your responses. 

Again, as I see it, this program does not treat an interruption as such, so I'll give you an explanation of how I've been learned to treat them and how it can improve your code. First of all, an interruption is a source which interrupts the currently executing code to execute another that expects an event. Due to this behavioral, an interruption should be always as short as possible. An interruption needs to be as short as possible because if you can call an interruption before it has ended (like in the case you are experiencing) it will overflow the stack pointer at some point in your execution and cause your device to not perform correctly. This happens because when calling an interruption the embedded saves where it is, performs the interruption/s (if more than one has triggered) and then comes back to where it was and resumes normal program execution. Do you see the main problem in your code with what I've explained here? If your interruption takes longer than the time you call it periodically, you will never exit the interruption, thus regarding your code unusable while also making your embedded to perform badly or not as expected at some point because of an overflow in the stack pointer. Because of this, an interruption should only consist of flag management which will be used in turn to allow the code intended to be executed in said interruption in the main body in your code. You might ask yourself how you can do this, so I'll give an example of how to implement this on your own code. 

where neighbors of n itself forms a graph. With each iteration, the graph gets smaller. Let's start with my Node implementation. I restrict myself to using the stl and not boost for Project Euler because I think I learn more that way. It's probably necessary to include this for you to understand the rest of the program. I would like some advice on how to improve it in case I use it again. 

A minor difference here is that I implemented skip (everyNth in your solution) as , since I think is more adaptable to other contexts than with partial function application. Just for demonstration purposes, could also implement skips recursively. Here's an implementation of : 

The problem here is the lack of functions or subroutines to avoid repeating code, thus making the code less mantainable. There are here other issues which are also important, for example, multilanguage support, which I'll address in the following To carry out multilanguage, I would declare an n x m array to store the n strings in m languages. To provide an example of what I mean, to store the greeting message, an array like the following needs to be declared 

To explain this array, the first dimension of the array declares the amount of messages stored, while the second dimension declares the amount of languages one can output the information. So, if we would like to print in any of the languages, the following line would just do that. 

Now the palindrome checking function: note that compare is abandoned if any digit fails the checking. With the string approach, yo u need to make full string translatioons and reversing to decide if a palindrome is found) 

Note that I have used a verbose approach in above outline to make my intention clear. You could compress the programming and rewrite it in the following more compact form once the intention is understood: 

I am not going to focus on any number theoretic improvements (like knowing certain palindromes or what palindromes factor into) since this is a programming assignment not a math problem. Now for the second order type improvement: Arithmetic operations are much much much faster than any string manipulation. So stick to math operations (divide, mod, compare, e tc.) A small helper function to extract a digit: 

This code would make the greeting valid for both languages, while also making the code more mantainable if you want to change the greeting message for any language/s by having all the messages in the same place. Keep in mind I substract 1 from since arrays are zero-index based. Implementing language this way can save you a lot of code, make it more readable and also more mantainable since you don't have to look in n lines to fix an error that has propagated through all your languages due to copy pasting code. This can be applied too to handle any amount of users, further reducing your code and making it, again, more manageable when maintenance or improvements happen (which you are bound to do). If you need help in developing anything, comment my post with what you need and I'll try to give you an answer as clear as I can. Hope this helped explain how to handle multilanguage. Note: To ease the maintenance of interface messages, you can switch the matrix, n for languages, m for messages, that way you will have in the same first dimension the same message for all the languages, rather than having all the messages for a language in the first dimension.