Drop in a couple breakpoints and see if either of the MoveHandler condition blocks are actually visited in the following code : 

Assuming you've correctly assigned a valid prefab GameObject to your 'bulletPrefab' variable, it looks like it should work. You say the "bullet still doesn't fire". Have you ensured that the AddForce method is being called i.e. add some debugging to that Fire() method to ensure it's being hit. The only other thing I can think of is that you need to be using and referencing a RigidBody2D component instead of RigidBody. It all depends on what target settings you chose for your project i.e. 2D or 3D. 

I'm pretty sure a quick Google would have given you the answer There are a couple relevant points in the FAQ pertaining to licence and use of assets from example projects etc. Unity stack answer : $URL$ 

Essentially what you're looking for is Unity's Retargeting of Humanoid Animations. $URL$ Basically as I understand it, as long as the rig you imported with the models/animations meets Unity's Avatar and muscle definition criteria for a humanoid character, then you should be able to use that rig and subsequent animations on other compatible models. Additionally, you probably need to check if the free models you got from Mixamo are actually compatible with the Mecanim system in Unity. I know that some of the older Mixamo packs were actually incompatible and only worked in the older (before Unity4 I believe) Legacy animation system. If so, then you'll need to update their armatures etc in Blender or Max etc. 

It sounds like you wish to control the players movement with keys, and aim the weapon with the mouse (hard to tell as you don't provide enough info.). If that is the case then drive the players movement with something simple like : 

When throwing the grenade, take a copy of the enemy's original position Vector3. Move towards that instead of towards the enemy GameObject. Alternatively spawn in a pre-cache'd "GrenadeTarget" GameObject at the original enemy position as a marker and move the missile towards that. 

The Unity Mecanim animation engine uses the concept of Root Motion to drive it's animations (assuming the animation contains the appropriate data). If you'd rather move/rotate the gameObject yourself then you can disable an animation's root motion in each individual animation during the asset import process in the 'Animation' tab. That would allow you to then drive the animations transforms using a script etc. I believe what you're looking for is in the following reference material : $URL$ Basically, if you override the 'void OnAnimatorMove()' method in a MonoBehaviour script which is attached to your animated gameObject, then the Animator component will recognise that the gameObject's animations are to be "Handled By Script". 

I think what you're looking for is to draw all of your tiles each frame to a sf::RenderTexture and then render that single object to the screen. The render texture is stored in an offscreen texture which is great for precomputing a complex static texture (like a level's background from multiple tiles) etc. Example: 

If you're making an endless runner that means the inverse of your players' velocity should be driving the movement of all the other entities in the game - such as the backgrounds (dampened obviously) as well as the various obstacles and terrain for your player to traverse. As such if you just instantiate a new pillar gameObject (based either on some mechanic such as a timer using predefined obstacle data lists etc) then it should just be driven by something simple like 

Many moons ago when I first dabbled in pathfinding algorithms I used the following site to help me to first understand the basic fundamentals of how a simple pathfinder is meant to work, and what it's trying to achieve : $URL$ The A* algorithm is quite popular and suitable for most pathfinding needs in gaming. A* will efficiently navigate just about any node graph when provided with a suitable rule set for finding neighbours for each node. The question you need to ask yourself is whether or not you actually want to implement your own pathfinder from scratch; or do you instead actually want to create a game. If you're actually leaning towards the latter then there is no point reinventing the wheel and you should instead just cannibalize an existing C# pathfinder for Unity, or just use the inbuilt Unity Pathfinder which should be sufficient and easy to use for most Unity games. Additionally this Unity plugin is also quite popular and very easy to use : $URL$ Pathfinding is a fairly complex and can be quite a deep rabbit-hole. It'll be very time consuming for you to learn, create, fix, refine and then optimize your own pathfinder - especially when others have already spent the time doing the above tasks at length(and probably doing a much better job than you! :) ) Anyway, the whole point of Unity in my opinion is to help you to bypass the need to develop your own game engine and having to write your own systems from scratch. It's done all that work so that you can just jump straight into developing games. 

Since those lines are responsible for changing the direction variable, they seem like the likely culprits. Alternatively change the 'else if' to 'else' to ensure it hits at least one statement. 

Prefabs are the way forward. In my opinion, every single entity should be a Prefab, even if you're going to only instantiate it once into the scene hierarchy (like a management singleton class etc). This'll save you many headaches down the line. A change to the Prefab will propagate to every instance in the entire project. Additionally, take a look at the new SceneManager API in Unity5. Could be useful for your project : $URL$ For gameObjects you wish to have in each scene such as a singleton manager etc, then you could use a simple pattern such as this: 

You appear to be correctly storing a texture and then setting that texture to a sprite, so I don't think the White Square problem they're referring to in the documentation applies to you in this situation as you don't have the texture being created in a local function scope etc. creates a copy of the argument and stores it in the vector so that shouldn't be a problem here I believe. You didn't post your main function so I'm unsure, but it would appear that you don't have a clear() or display() function wrapped around your primary SFML draw() function. $URL$ Assuming the texture is not actually white, in order to do some quick elimination testing you could pick a section of the loaded texture i.e. :