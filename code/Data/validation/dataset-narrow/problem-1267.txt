The important message to take here is that replays can be used for cheat detection sometimes and not protection. Even so, it may be hard or impossible to detect some types of cheats. It also begs the question what is considered plain cheating and what would be taking full advantage of tools that most players may not consider.. Here is an example: In a strategy game with keyboard shortcuts, player A creates some advanced keyboard macros that allow her to build up a base faster than any human player using ordinary controls. Is that cheating? Perhaps. But who can tell the difference? Perhaps a machine doing some statistics. Is the implementation here worth it? On the other hand, there is a competition going online in a deterministic single player game supposedly protected from cheating but player A again records her keyboard input until she loses, then she plays back her keyboard input and continues from the spot before she lost. She then repeats this process to allow her to basically save her state. Can anyone tell she is cheating? Yes but it will require someone to check and compare different playthroughs, even then it would be hard. Another thing that may be destructive in a game like you specifically described is if someone creates an AI bot that listens to the packets and computes an optimal decision based on the state of the game. This could be impossible to detect. Generally I think the conclusion is that when you are working to detect or prevent cheats (like any other security related matter), whatever technique you are using, is being used on people and they may outsmart your or simply pick another way you haven't thought of to cheat the system. Human and especially cheaters, are very resourceful. 

From what you are saying the game is in 160 X 90 but I'm sure the actual view could be in 800 x 450 for instance? Then you could maintain the "blocky" look and keep the image sharpness by simply drawing each pixel as a 5 x 5 rectangle and moving the world in steps of 0.2 instead of integral steps. This way you would get a feel of 50fps and will not get the blurriness you described. You could also do something like deepnight often does in Ludum Dare where the pixels are actually replaced by large blocks to give a look reminiscent of 8-bit games on a CRT. $URL$ 

The way to figure out where a dot in 3d space should be positioned on the screen is by imagining the monitor is a window and the dot is behind that window. To know where that dot is displayed on the monitor, you need to imagine you have one eye and the draw an imaginary line from that eye to that dot beyond the window and see where that line intersects with the window. This is where it should be drawn. If you have a line between two points, calculate the position of each of them on the monitor and proceed to draw the line. 

What is the most effective way to handle a read only array(not implemented in the language)? Does anyone have performance statistics that shows the performance boost gained for using method 2? And when is method 1 severely inferior to method 3. 

Alright, we have a large set of possible moves (what the player is allowed to do). We also have a well defined state of success that defines the desired goal. We want to generate a configuration where for the purpose of this question, only 1 set of moves leads to a victory within k steps. We also have a solver that can find all possible solutions for a given configuration problem. For example let's take Chess, how would you place a set of chess pieces on a board such that only a specific set of moves by White will result in Check Mate? 

You could use something like Dragon Bones instead. That could really save you a lot of work. $URL$ Making nice looking 3d animation is a serious highly paid profession. Making 3d models that will look nice in a 2d game is even more challenging in some sense. You have to remember 3d models in a 2d game may look out of place. Also if you go ahead and use 3d models, you may as well just stick the in the game as they are and render the in game. Just because game-play is 2d, does not mean visuals need to be as well. 

and simply do this 2,4,7(11),8(37,49) Inside a db, you can save the inventories contents as a varchar. You can also store an enchanted item by storing a pair of item base type and enchantment type. 

The bodies are apparently asleep and therefore need to be woken up before they respond. This is taken from this link: $URL$ From the Box2d site: 

Rendering a 2D sprite in a 3D space could be handled as a specific case of rendering a 3d object. The 3d model being a flat rectangular shape that is textured with the sprite in question. This is how I would suggest you handle your sprites. I think this tutorial gives an example: $URL$ The way bullets are handled there (2d images in 3d space) is what you are looking to do with characters in your game. 

Read my answer first. I am thinking there is more optimized solution, thanks. My question is how to include the following improvement: I read in the AS3 Bible book that: In regards to ShaderInput, You can use these methods to coerce Pixel Bender to crunch huge sets of data masquerading as images, without doing too much work on the ActionScript side to make them look like images. Meaning if I am performing the same linear function on a lot of items, I can do it all at once if I use Shaders correctly and save processing time. Does anyone know how that is accomplished? Here is a sample of what I mean: $URL$ 

The only constraint is that I may wish to limit the minimal size of the rectangle without affecting the granularity of the sizes. i.e. if the smallest rect is 1 square centimeters than the seconds smallest room should not be 2 square units. So ideally the algorithm should meet all three following constraints: 

It is a tree structure at heart. You have the "bare weapon" ("un-enhanced") which has slots for extensions that will be positioned accordingly in with some translation, rotation or scaling possibly and once you add an extension, it may open up new slots for extensions that will be positioned relatively to that extension's position. So if you placed extension in slot 3 and has 2 slots then slot 3 is taken and the new slots (3, 1) and (3, 2) will be placed and could be occupied by new suitable enhancements. So basically you have the root of the tree which is a basic un-enhanced weapon type. It has slots where new enhancements could be added randomly by the generator and possbly some enhancements could be further adorned with more complicated improvements if that enhancement has its own slots. You basically need to randomize recursively and decide in each step what to add. Some slots could be occupied with mundane stuff and on rare weapons they may contain some important improvements. To position the pieces that you add to the weapon you could wither use a slot specific transformation matrix that will move, rotate and scale the sprite pieces accordingly or use the needed math to position the enhancements accordingly. The bottom line is that as a data-structure the underlying idea is a tree that grows recursively as new pieces are added in, possibly with some constraints (perhaps you don't want a cannon with a silencer on top of it). 

None-physical way (not spring physics): If I simply wanted an object to pull towards another object and stop there I would use this instead: Define too far apart as a radius , any object farther than that radius will be attracted to its partner. 

You will probably want to play a sound when each when each letter is added. You could also accomplish this with a timer or check 

Create a list of all enemies in the vicinity. Compute distance from each enemy. If not within melee range, remove it. Iterate over all remaining enemies (within melee range) and compute the angle of the vector of their position minus your position. Deduct this angle from the angle the character is facing (get absolute value). If the value is closer to 2 * Pie (or 360 degrees) than to zero, deduct 2 * Pie from it and get absolute value again. Compare the result with what you consider an acceptable cone slice (for instance Pie / 5). If the enemy is within the range, deduct health. If you only wanted to hit one target, take the one closest to the character and inside the cone and deduct its health. 

If what you did previously is "flip a coin" for each tile (noise), generating a Voronoi diagram will provide a much better result. You could improve on this by dividing the into with an algorithm that: 

How do I find the vector point from the character towards the right? The vector has to be orthogonal with the other two but also face in right direction and not to the left. This is very similar to the question: Determining if something is on the right or left side of an object? But I just want the math to computer the third vector from the first two. 

The bounding box may be very different in each frame and so are the frame's size and the relative position point. There is no mystic way to do it. Normally to handle complex sprites' animations, one of the teams' members uses a tool to define a bounding rectangle around each frame and place a relative positioning dot in each frame. This data is saved to an xml file often but is created with a specialized tool. 

The code should serve the software engineer. Not the other way around. The code should be written in the most intuitive and simple way it can be written (but not simpler). Do not take advice unless you understand who it's intended for and what it's intended to resolve. 

tl;dr You need to treat your numbers responsibly and figure out how you want the game to behave in different situations. Some questions to ask yourself: 

The answer is an obvious no simply because "heavy rounding" doesn't alleviate the problem. Like you suggested the issue is with how floats behave on different architectures. Lets say you round things up. :) What happens with very large numbers? They are still exactly the same. Large numbers behave differently too on different architectures. Fractions, are simply large numbers with a different exponent that determines the radix (floating) point position. You would need to implement a cross-platform number. This is a known and well covered subject. Hint, there are performance issues.