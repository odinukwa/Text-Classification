Treewidth and pathwidth are popular parameters, measuring the closeness of a graph to a tree or a path, respectively. Indeed, it seems treewidth is so popular it is featured in many papers, books, and lecture notes that give (even very gentle) introductions to the algorithmic aspects of treewidth (see e.g. the Downey & Fellows book). Typically, these resources explain how some NP-hard problem (e.g. independent set) is solved in polynomial time through dynamic programming on a tree decomposition. However, it is sometimes the case a graph problem remains NP-complete for both bounded treewidth and bounded pathwidth graphs. But such hardness results don't imply hardness for bounded tree-depth, which informally measures the closeness to a star. It seems fair to say tree-depth is not as widely known as treewidth. For someone wanting to learn more about algorithms parameterizing by tree-depth, are there (similarly to treewidth) some nice resources available for learning how such algorithms perhaps typically work? 

A string $x$ is $c$-compressible if $K(x) \leq |x| + c$. If $x$ is not compressible by $1$, $x$ is said to be incompressible (or random, if you will). There are $2^n$ bit strings of length $n$, and there are $\sum_{i=0}^{n-1} 2^i = 2^n-1$ descriptions that are of length less than $n$. Because each description describes at most one string, there is at least one incompressible bit string for each length $n$. Also, at least $2^n-2^{n-c+1}+1$ strings of length $n$ are incompressible by $c$. Once again, at most $2^{n-c+1}-1$ strings of length $n$ are $c$-compressible, because we have at most that many descriptions of length at most $n-c$. Then the remaining $2^n-(2^{n-c+1}-1)$ strings are incompressible by $c$. 

[1] Zuckerman, David. "Linear degree extractors and the inapproximability of max clique and chromatic number." Proceedings of the thirty-eighth annual ACM symposium on Theory of computing. ACM, 2006. 

I suppose that more specifically, you want the paths to be edge-disjoint. Cai and Ye [1] study the problem of finding two edge-disjoint paths between two (not necessarily distinct) terminal pairs. If one is to believe the preprint, this is an open problem. However, their problem is slightly more general as the terminals are allowed to be distinct. This feels quite close, but is not exactly what you asked. 

Here's the same proof in other words. The idea is that if we had a $(2-\epsilon)$-approximation algorithm with $\epsilon > 0$, we could decide whether or not there is a dominating set of size $k$. In other words, we want to show that there is no $(2-\epsilon)$-approximation algorithm with $\epsilon > 0$ for $k$-center unless $\mathsf{P} = \mathsf{NP}$. Recall that the dominating set problem is indeed $\mathsf{NP}$-complete. Let $G = (V,E)$ with integer $k$ be an instance of the dominating set problem. Let us then define a complete graph $G'$ such that the distance between adjacent vertices is 1 while nonadjacent vertices have a distance of 2. $G'$ satisfies the triangle inequality as well. Suppose $G$ has a dominating set of size at most $k$. Then, $G'$ has a $k$-center cost of 1. Now, a $(2-\epsilon)$-approximation algorithm gives us a solution with cost $< 2$. If there is no such dominating set in $G$, every $k$-center has cost $\geq 2 > 2-\epsilon$. Thus, a $(2-\epsilon)$-approximation algorithm for the $k$-center problem can decide whether or not there is a dominating set of size $k$. 

Using a SAT-based approach, I can confirm every instance is 3-colorable up to $n \leq 22$. A local search solver finds a solution for $n=22$ still rather quickly on a modern desktop. I tried the same approach for $n=23$, but obtained no solution in about 96 hours. It is thus tempting to conjecture that $n=23$ is not 3-colorable anymore. (Let me also remark that a 4-coloring is found instantly for $n=23$). My observation for $n=19$ was similar to yours, that is, it already seems quite out of reach for a complete solver if the straightforward encoding is used. On the other hand, I wouldn't be surprised if a smarter encoding could settle the case of $n=23$ (and beyond?). Below is the solution for $n=22$. 

A path in an edge-colored graph is rainbow if no color appears twice on it. A graph is rainbow colored if there is a rainbow path between each pair of vertices. Let RAINBOW-$k$-COLORABILITY be the problem of deciding if a given graph can be rainbow colored using $k$ colors. For any graph $G$, the problem is easy for $k=1$ as it equals checking if $G$ is a complete graph. For split graphs, the problem is $\sf NP$-complete for $k \in \{2,3\}$, and in $\sf P$ for all other values of $k$. See Chandran, L. Sunil, Deepak Rajendraprasad, and Marek Tesa≈ô. "Rainbow Colouring of Split Graphs." arXiv preprint arXiv:1404.4478 (2014). 

There are other graphs, but they are all chordal. That is, chordal graphs are precisely the class of graphs that admit a clique tree representation, see e.g. [1]. Proper interval graphs are also chordal, while bipartite graphs in general are not. 

[1] Previti, Alessandro, Raghuram Ramanujan, Marco Schaerf, and Bart Selman. "Monte-carlo style UCT search for boolean satisfiability." In AI* IA 2011: Artificial Intelligence Around Man and Beyond, pp. 177-188. Springer Berlin Heidelberg, 2011. 

See Cooper, C., & Frieze, A. Stationary distribution and cover time of random walks on random digraphs. Journal of Combinatorial Theory, Series B. (2011). 

ISGCI just recently added parameters. They are still in beta at the time of writing, but one might look at diameter: minimum dominating set is a minimal upper bound, and by following the trail upwards, we find maximum independent set, and so forth. They reference e.g. the 2013 manuscript of Sorge and Weller, available here (see Figure 1). 

I am especially interested in chordal graphs, and any subclasses of chordal graphs such as block graphs. For example, I think the diameter of a chordal graph $G$ can be computed in $O(n+m)$ time, if $G$ is uniquely representable as a clique tree. Such a graph is also known as ur-chordal. 

When $k$ is part of the input, the problem of deciding if $G$ contains a simple cycle of length $k$ is NP-complete. For every fixed $k$, the problem can be solved in either $O(VE)$ time, or $O(V^\omega \log V)$ time. Flum and Grohe [1] showed that counting cycles and paths of length $k$ in both directed and undirected graphs, parameterized by $k$, is #W[1]-complete. For $3 \leq k \leq 7$, one can count the $k$-cycles in $O(V^\omega)$ time, where $\omega < 2.376$ is the exponent of matrix multiplication. This is the result of Alon, Yuster and Zwick [2]. The paper also contains methods for finding simple cycles of length exactly $k$, where $k \geq 3$. 

There is an algorithm due to Atkin and Bernstein. It computes prime numbers up to $N$ using $O(\dfrac{N}{\log \log N})$ additions and $N^{1/2+o(1)}$ bits of memory. The Wikipedia article on Sieve of Atkin gives pseudocode (caveat: see the comments). For more, see their paper A.O.L. Atkin, D.J. Bernstein, Prime sieves using binary quadratic forms, Math. Comp. 73 (2004), 1023-1030. 

Monte Carlo Tree Search (MCTS) has recently achieved some impressive results on games such as Go. The rough basic idea is interleaving random simulation with tree search. It is lightweight and easy to implement, the research hub page I linked contains many examples, papers and some code as well. Previti et al. [1] did some preliminary investigation of MCTS applied to SAT. They call the MCTS-based search algorithm UCTSAT ("upper confidence bounds applied to trees SAT", if you will). They compared the performance of DPLL and UCTSAT on instances from the SATLIB repository, with the goal of seeing if UCTSAT would produce significantly smaller search trees than DPLL. For uniform random 3-SAT and flat-graph coloring instances of different sizes, there were no significant differences. However, UCTSAT performed better for real-world instances. Average tree sizes (in terms of the number of nodes) for four different SSA circuit fault analysis instances were in several thousands for DPLL, while always less than 200 for UCTSAT. 

Recall the diameter of a graph $G$ is the length of a longest shortest path in $G$. Given a graph, an obvious algorithm for computing $\text{diam}(G)$ solves the all-pairs shortest path problem (APSP) and returns the length of the longest path found. It is known that the APSP problem can be solved in optimal $O(n^2)$ time for several graph classes. For general graphs, there is an algebraic graph theoretic approach running in $O(M(n) \log n)$ time, where $M(n)$ is the bound for matrix multiplication. However, computing the diameter is apparently not critically linked to APSP, as shown by Yuster.