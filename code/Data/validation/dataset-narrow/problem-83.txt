It is obviously some kind of Cisco IOS bug, you can googled a lot of such things, for example$URL$ Because it is internal Cisco IOS bug, you cannot fix this in the some logical straight way. If you have TAC support, you can open TAC case. Also try to change IOS (it should help you and this is first that TAC will ask you if you create the case) If you cannot create TAC case or change IOS, you can try this: - change vlan id, if it is possible - change anything for this vlan (description, some parameters, etc..) - shutdown this interface before this command and turn on after According to my experience something of this could help you (or could not, if you are not lucky). Hope this helps 

You cannot modify STP hello timer only for one port - it is timer for whole STP tree. Also this modification wil not help you - because if you have drops on this long link, you will have problem with STP anyway. What you need to do? If you have only one link, you can turn off STP for the both side for this link and split STP to two domains (one domain per site). You can do this by "bpdugilter" on the both sides of this link. In this case you can also implement a storm-control\any other protection for this link to be sure that problem in one site will not propogated to other site. If you have two links between these places (for redundancy), you definitely need to avoid any L2 protocols between them. You need to implement IP routing and then, if you need Ethernet between two segments in the different sites, you can implement tunneling. My experience say me, that the best answer in such case is MPLS, but maybe you cannot do this due to budget/equipment limitation. 

However, the IEEE did not plan for a large number of protocols - and it was wrong. As it turns out, the 1-byte-long DSAP field is not big enough to number all the protocols. To accommodate more protocols, the IEEE allowed the use of an extra header, called a SubNetwork Access Protocol (SNAP) header. The DSAP field of 0xAA, which implies that a SNAP header follows the 802.2 header, and the SNAP header includes a 2-byte protocol type field. The SNAP protocol type field is used for the same purpose as the DSAP field, but because it is 2 bytes long, all the possible protocols can be identified. For instance, the SNAP type field has a value of 0800, signifying that the next header is an IP header. RFC 1700, "Assigned Numbers" (RFC 1700), lists the SAP and SNAP Type field values and the protocol types that they imply. See more: SAP Numbers 

Identifying the Data Inside an Ethernet Frame Each data-link header has a field in its header with a code that defines the type of protocol header that follows. For example, the Destination Service Access Point (DSAP) field has a value of E0, which means that the next header is a Novell IPX header. Why is that? Well, when the IEEE created 802.2, it saw the need for a protocol type field that identified what was inside the field called "data" in an IEEE Ethernet frame. The IEEE called its Type field the destination service access point (DSAP). When the IEEE first created the 802.2 standard, anyone with a little cash could register favorite protocols with the IEEE and receive a reserved value with which to identify those favorite protocols in the DSAP field. For instance, Novell registered IPX and was assigned hex E0 by the IEEE. 

You did not use "ip route" right. You cannot do "ip route something interface", if this interface is ethernet (Full, Giga, Ten - whatever), because ethernet is broadcast interface, so router cannot create route and install it to RIB. You can use "ip route something interface" without definition of destination ip only for p2p interfaces - Serial (with p2p type), PPPoE, etc... Also "permanent" has sense only in "ip route something gw_ip" The best description of right usage of "permanent" route you can find there - $URL$ 

Edge configuration is not about disable RSTP for port. "Edge" means you are sure, that it is not a port to another switch, and you need to exlude it from STP calculation. This port is always in Forwarding state, if everything is ok (without incoming wrong BPDU). But if switch receives BDPU from this port, it should shut down the port or remove edge configuration from the port. In your case, because of "bpdu-blocl-od-edge" I believe port will be turned off (you can read this for details $URL$ Of course, switch continues to send BPDU to this port, because we need to detect loop if it occurs. 

ACKs are useful in sliding window protocols, they allow Transmitter A to be aware that data sent has been received by remote B. Transmitter A can then proceed to send next data - until its transmit window is full (of data sent to remote but not yet acknowledged). ACKs may be considered more essential than NAKs. NAKs simply allow for faster recovery, in the case where a packet/block sent by A is not received by B, and B detects by some way that a packet/block is missing. It is perfectly feasible to design a protocol supporting reliable transfer and flow control only with ACK, without NAK (with retransmission by Transmitter in case Transmitter does not receive an ACK, retransmission mechanism that is needed in any case). 

You may use the following protocol (inspired by PPP over Asynchronous Links RFC), with two special characters IDLE and ESC. You will need about 2 bytes of RAM at the Transmitter and 2 bytes at the Receiver to maintain state information (plus two more bytes for CRC computation). Payload data are arbitrary, from 0x00 to 0xFF. Say IDLE is 0x7E, ESC (for Escape) is 0x7D. IDLEs MAY be sent by Transmitter at any time when it has no payload data to Transmit. When Transmitter wants to send a frame/packet, it MUST send IDLE, then the escaped (see below) payload data, then IDLE. As IDLE should not appear in frame data, we define a second special character ESC that will be used by Transmitter when it wants to escape data. IDLE and ESC itself will be escaped, at a minimum. When the Transmitter wants to send payload byte: - 0x7E (IDLE), it transmits two bytes: ESC followed by (IDLE ^ 0x40) [IDLE XOR 0x40] - 0x7D (ESC), it transmits two bytes: ESC followed by (ESC ^ 0x40) - other byte, it transmits the byte unchanged. Alternatively this byte MAY be escaped by ESC followed by (byte ^ 0x40), provided that (byte ^ 0x40) does not result in IDLE or ESC. The escaping formula (byte ^ 0x40) is not magic, it can be replaced by another. The important thing if that the result of the escaping formula is never ESC or IDLE. From the Receiver point of view, any data received between two IDLE makes a frame/packet. Receiver has to unESCape these data in order to get the initial payload data. It is of course strongly advised to add a (2-byte) CRC at the end of the frame/packet, just before the closing IDLE. This CRC has also to be ESCaped. CRC can be computed on-the fly, on a byte-by-byte basis. I have implemented this kind of protocol (precisely: encapsulation) numerous times, it's very simple, reliable and efficient. 

In addition: Type-2 LSA use only as "virtual instance" of a router in MA segment, this pseudonode has an adjacency to all attached routers (include DR/BDR) on the network and lists all attached routers (RID) to that segment. For transfer LSA they(DR/BDR) use Type-1 LSA as well. 

Use may use NOC, NOC Project it's the scalable, high-performance and open-source OSS system for ISP. You can easily add VLAN's through the entire network. 

During loop, for a large number of broadcast traffic (eg ARP Request) at the end station may also increase the load on the CPU (for example if you are using cheap 100Mbit/s realtek card that calculate a checksum on CPU). As physically possible to find a loop if the cable is disconnected, the link lost immediately on 2 ports. 

We can also use CDP to get IP address of directly connected device, for e.q from 2950 switch or workstation by sniffer. Sw2950> sh cdp nei * detail. 

Because the concepts defined by OSI model are useful for understanding real-world networks. OSI defines 7 layers, these layers (especially layer 5/Session and 6/Presentation) don't match well with the now dominant well-known telecom protocols (above and around IP) - the model should not be blamed for this. After all we can't say that the IP protocol stack is particularly well designed. The model defines a lot of very useful concepts, and distinctions to be made, in the analysis/understanding/design of any complex telecom system. For example: the notions of service and protocol; the notion of primitive (request, confirm, indication, response, signal); the notion of protocol entity and Service Access Point; the notion of connection vs. association; the notions of SDU (Service Data Unit), PDU (Protocol Data Unit), IDU (Interface Data Unit); etc. These concepts are extremely useful. Also, OSI model is still used heavily to define current protocols. For example ISO 11073-20601 and friends (Point-of-care medical device communication), used in medical devices (typically over Bluetooth) heavily use OSI modelling of Application Layer. Or the IEEE 802.xxx lower layer protocols (e.g. 802.15.4, radio protocol) - these use the ISO modelling of the lower layers. These protocols are recently designed and in use today.