Furthermore, check whether you can alter your transfer logic, so that you utilize the streams decorator pattern to the fullest. I imagine, that you could actually wrap the output stream into a digest ouput stream first and in a cyper output stream second, so that you need only a single read-file-and-copy-to-stream operation. (See $URL$ 

I think the main problem in your code is the concept of "Data": when Data is a single class which represents a logical entity, you should not save it in three different places. In that case, write one method which writes the complete data object to whatever store, and be done. On the other hand, if Data is just a holder for various parts that do not have a logical connection, Data should not be passed to the various serialization methods. (The serialization method does three things here: extract the values to save from the data object, identify the place to save, and actually save.) If you go for separation of concerns, have the caller to the extract and identify parts, and have a save method simply save a given list-of-whatever to a given file. At that point, smoothly go over to Jerry's answer... :-) 

Resource-leak: you neither close the statement nor the result set. Depending on the database driver, this can lead to system resource leaks, blocked OS handles, etc. Always close database objects ASAP (apart from connections, which you can hold for a longer time.) Multiple looping over metadata: you reiterate over result set metadata for each row in the result set. As you do not know the underlying implementation, this may be quite an expensive operation, there's no way to be sure. Thus, better do this once and cache the information you need. Error handling: you catch everything, log it, and let the application continue running without any indication of an error, eventually based on incomplete data. Bad idea. Do not catch exceptions here, declare the method as "throws SQLException" (or maybe re-wrap it in MyOwnApplicationException or whatever) - just don't continue running in error conditions. Multithreading: connections normally cannot be shared amongst multiple threads (eventually invalidating their underlying objects and doing all kinds of funny things.) I see no precautions to avoid multi-threaded access in the code. General utility: ask yourself, what are you going to do with this map? Create objects from the contents? Create excel reports? Is your application code written to handle each and every funny datatype a driver implementor may be inclined to return via getObject()? I sincerely doubt this is really useful. For object mapping, have a look at various ORM frameworks / JPA, for reporting there are other frameworks. This looks like the re-invention of a wheel to me. 

Raw execution time for 1000 repetitions (with proper ramp-up) using 100000 chars and k = 150 went from 3308 ms for the original code to 3190 using both changes on my machine. And as you are on codereview, one additional remark: longer variable names (longest, subsequence, n?) do not hurt execution time, but have the potential to make the code more readable.... ;-) 

This way, you can do this once in the beginning, and in all further processing methods operate on sanitized input and be sure that there are no null pointers included. 

I think the mapper looks ok, but in the cost centers management method, you violate encapsulation by directly manipulating the travel's cost centers list. I'd rather leave the list management to the travel class: 

... if you need to pass a local tmp-map, this will be more BiConsumer-ish in your case, but the idea should be clear. 

Consistent style As a teacher, try to lead by example. Sometimes you put whitespace around operators (which is the norm), sometimes you don't, sometimes you prefix an opening brace with space, sometimes you don't. Whatever you do, make sure it is consistent (or configure a code format in your IDE and run the formatter over the whole code.) Non-OO menu decision In OO you don't just rip information out of an object to base your decision on it. Instead of 

Next step is: does the game really have to know who is a Player, and who is an NPC? You modeled both classes as being derieved from the common class Being, so maybe it should be possible to match any being vs any other? Without looking through the code en detail, you should strive for: 

Definitely the second. It shows that you have got at least a general grip on datastructures (knowing the complexity of HashSet operations) and know a bit about the standard library. Regarding the fist one: this even uses a loop instead of - I'd immediatly show you to the door for that, if I were the interviewer... Second is definitely better, but not impressive eiher. Try getting a grip on the stream API and play around with - my own try-that-for-comparison-solution was 2 lines using this... You shouldn't. From my opinion, it is OK to explain in addition that there might be a possible solution using binary search over the stones string, which completes in \$O(n\times log(n))\$, but I would not to see an even longer solution for micro-optimizing a simple problem which takes milliseconds to execute. Simplicity, readability and clarity are the key attributes. 

You could replace your instance-check with a configuration map, which holds the class as the key and a consumer as the values. Some improvised code to illustrate the principle: 

Stack Boolean logic: An expression "a == b" or "topPointer == size - 1" is already a boolean. Thus your isFull and isEmpty methods essentially read: 

Simplify: Getting a next day via an overridden method seems a little overkill. We know the stucture of an enum and we know that the constants will be put into a value array in their original order and have an ordinal() which corresponds to the index. Thus, next() would probably look like this for me: 

Real skill means knowing your libraries. Instead of 20 lines of handcrafted code, I'd rather go for: 

In addition, you should always close your ResultSet and your Statement explicitly. (Or: also use these in a try-with-resources block, and yes, both are AutoCloseable.) The background is, that these objects might be tied to system resources, and there is no guarantee that the database driver automatically closes these dependent objects when you close the connection. (I think the oracle driver behaves well, but this is a specific implementation detail which you should never rely on.) For the application you have (simple statement, read once) a single try-with-resources block seems preferable: