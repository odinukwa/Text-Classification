As of December 2013, a slightly accelerated frame buffer driver was made default in Rasbian. There is still as far as I know no "proper" accelerated GPU driver. The recent Broadcom release makes it slightly more possible, but no one has done it yet. 

If it says "Encryption key:on" it will need some sort of password. What type of encryption is later on in the scan results. In this case it says "WPA2" and "TKIP"/"CCMP"/"PSK", which is essentially standard security for a few years ago. 

Check your ~/.xinitrc file. It sounds like something listed there to be launched at execution of the startx command isn't starting properly and is hanging, making it look like X hasn't started. (It probably has, it's just showing a black background. Misleading, I know!) 

The foundation has been working on an accelerated browser which may work better. The goals they've stated are to improve rendering speed which may help. Unfortunately the limit you're hitting with display probably isn't so much a browser issue as a more fundamental issue with the frame buffer being slow to update. There's not much you can do about that other than maybe move to OpenGL ES, but if you're working on JavaScript that's probably not the right solution. 

Miracast (what the cast setting on a Nexus enables) is tricky because it's a direct device to device Wi-Fi protocol. There appears to be a project called OpenWFD that's working on Linux support but it's not ready yet. You'd probably have better luck using something like VNC, which works reasonably well on the RaspberryPi already. 

It may be that the image became corrupted while extracting or writing. Try verifying the file with and comparing the result to the checksum of ade48c874f8e4b694175de4c87d7357960961fbf. You might be able to recovery by simply doing a file system check, otherwise try re-writing with a freshly downloaded and extracted image. To do a check, run . The boot partition on the SD card has to be FAT. The external hard drive doesn't need its own boot partition, because it's on the SD card instead. The only reason you need it now is because you're copying the contents from it to the SD card as you've just written out the image. 

This can be seen on: However, for the RPi 3 (which is brand new, the video shows maybe 3rd or 4th boot after unboxing), I observe that once the boot process starts, the red LED occasionally turns off while the green LED may or may not be on, and then mostly comes back: This can be seen on: The reason I'm posting this, is that I've only ever seen one more RPi 3 boot, it was also brand new and booted the same image, powered by the same USB cable/hub - but I cannot recall it's red LED turning off during boot, like that which is shown in the last video. Then, I've also seen the following link, which states: : 

So, what I want to know is: should I be worried about this RPi 3, whose red LED turns off occasionally during boot, in the long run? (otherwise, even with the red LED turning off, this RPi 3 still boots fine - if I hook a screen on HDMI and a keyboard, then I can log in etc, without a problem; except I've noticed there's sort of a color gradient box on screen, that shows and disappears in sync with the turn off/on of the red LED... EDIT: this color gradient is/was apparently called "rainbow indicator") 

The current use in this case seems roughly similar to the previous case, so I would assume, that it is not a problem that the PSU can deliver less than the RPi 3 max rating of 2.5A -- but the problem was that the voltage was too low; so with a power supply voltage of close to 6V, finally the red LED turn-off issue is not there anymore. 

I don't have much experience with Raspberry Pi. However, I've just noticed a difference in booting between Raspberry Pi 2 and 3, and so I've taken a couple of videos to show that. In both videos, the Raspberry Pis use the same image (based on Raspbian 7), and are powered by the exact same USB cable (which is connected to externally powered USB hub); both videos start with the RPis unpowered, then I plug in the USB cable at the other end into the hub to power them (unseen in videos), then the LED light patterns during the boot process are captured for about a minute. For the RPi 2, typically once the red LED is on, it stays on - while the green LED flashes according to disk/SDcard activity: 

I wrote a python program that boots with pi, do it's job, and shutdown pi when finished working. It works fine, and when I'm connecting an lcd to the pi, I can know whether the pi finished shutting down or not, but the problem is that the screen shouldn't be connected. So how could the user know when the pi completed shutting down to safely unplug it from power? 

I need to create asp.net website (on windows), the website should be installed on a windows computer. The website (installed on windows OS) should be able to control the raspberry pi pins(with raspbian OS installed). I don't know how and where could I start! any hint would be so appreciated. 

I found the solution just in case someone else faced the same issue, the solution is to use crontab instead of rc.local file: 

when I run this script, it always work true and set my raspberry pi date and time correctly, but the problem is that it takes very very long time to execute most of the time. if I write a simple print command after calling os.system(dt), it cost me more than 10 seconds to see the print command output and some times it cost less than a second (but this happens rarely). Knowing that all my tries are done with same parameters, and some of these tries executed in less than a second and most of them executed in more than 10 seconds. This means that the problem is not with a wrong date/Time parameter value. Any suggestions will be so appreciated Note: I tried to run another script that prints some text every 1 second, and then I ran the above script when it reached os.system(dt), the second seperated script freezed as well as the above one. which means that the problem is that my whole pi is frozen when calling this command. does anyone know what's happening! How could such a simple command froze my whole pi!! 

So I have a python script that is using the raspberry pi serial RX,TX to communicate with a 4D System Display. It is working just as I want it to work, BUT, when I modify the /etc/rc.local to let this script run automatically at startup, and apply a reboot, the screen which uses the serial interface is not working. Knowing that all other tasks are working correctly, just the serial interface didn't work. So the problem might be that my script is running before serial interface is booting completely. so is there any workaround for such situation? 

Ok, thanks to the answer from @Milliways, I decided to make another test with powering the RPi 3. First, I should note that the tests in the OP question were made with a USB hub, which comes with an adapter that is rated 5V, 2A DC. I was sort of expecting that if there is only one USB load in the hub, that all of the available 2A current would be given to this load - but it is also quite possible that each port of this hub is current-limited to 500 mA, regardless of how many USB loads are connected. Also, here I tried a different Rpi 3 board connected on this same hub - and it also exhibited the red LED blinking during boot. Anyways, to get rid of this unknown, I soldered myself a USB 'power' cable, powered directly from a Thandar TS3021S adjustable PSU. This PSU is rated at max 2A (which is less than the RPi 3 maximum of 2.5A); I've set the current limiting to some 1.9+A -- and as a bonus, the PSU measures/shows the actual current used on its LCD. So, here are the results - when I set the PSU to 5.01V, the red LED still blinks (it's a bit hard to see on the video, but is still visible): 

What is strange, is that the current measured rarely goes over 0.5A during boot, so it didn't seem to me that lack of current is the reason for the red LED blink (although, arguably, the "refresh" rate on the LCD of the PSU which shows the current measurements could be slow enough, so as to obscure some current spikes, if any were occurring). At this point, I measured V26 (voltage on pins 2,6) - which should otherwise provide Vcc - it measured 4.72V, that is, roughly some 0.3V less than the input voltage. So, at this point, I started increasing the voltage supplied by the PSU. First I increased to 5.45V; in this case, the V26 was 5.15V - and while the frequency of red LED blinking decreased, it still did turn off at times. In the end, I set the PSU to 5.94V; in this case, the V26 was 5.63V - and finally, there was no more red LED blinking!