Your code is very good for a beginner! As you have noticed, there are always improvements to be done, so don't worry too much about this. Here's what I feel the other answers have missed: 

to run a function called when running this module (eg. with ). This is only a convention, the function could be called whatever you want it to be, or you could simply put all the code in the conditional, as you've done here. TextMate provided you with a function with a statement to specify that it does nothing and avoid a syntax error. Long story short: remove that main function! 

To answer your second question, you don't need to explicitely check for null: it's simpler to compare and directly. If the latter is null, then the comparison will return false. If is null, you don't want to return a value but throw an exception anyway, and this is what happens with your current code because throws. It makes more sense to check for success and return if something went wrong. If you have an type instead of a boolean, you have to return more explicit codes! Otherwise just return the condition directly. 

Make sure to use : your code will be more easily ported to another platform and you won't have to use those nasty double slashes. Lastly, you seem to be confused about exceptions, so let me explain a little bit. How exceptions work Think of try/except as another way to express your error-handling logic. It is generally more useful when the error is considered as "exceptional" and won't happen often. In Python we prefer to go a bit further than that: it's often easier to ask for forgiveness than permission (EAFP). So, to answer your question: no, that's not how exceptions work. 

After some testing, it's CPU-bound. I also hit PHP maximum allowed memory size when working with larger files: it eats more than 3G of memory when loading a 4M file. Try reducing the memory usage. :) I'm leaving my answer below since Paul answered to it. I/O bottleneck It's quite obvious that you're going to create a lot of data. The Google Ngram corpus, for example, uses 1To of disk space. You probably have less data, but you're still going to generate a lot of bytes, which suggests that your program is not CPU-bound, but IO-bound. This also means that using a faster CPU or another language wouldn't help at all. A lower bound Let's try to work out a lower bound to see what improvements can be made. Since you can't go any faster than a program simply writing the ngrams without any calculation, you should try copying your ngrams data to another folder to see how long it would take. Using "cp" would be dangerous, since there may be crazy optimizations like copy-on-write on your specific filesystem. 

"and" is an effective way to say "watch out for mutual recursion". OCaml encourages you to use nested functions instead! As The Structure of OCaml programs says: "Nested functions are, however, very useful and very heavily used in OCaml." 

I'm not sure about the exact complexity, but it is certainly huge! One-letter edits are fine to spell check one word given a large dictionary, but does not work if you only have a few words and the edit distance can be arbitrarily large. To look for close words in the dictionary, you should use the Levenshtein distance, as mentioned by ratchet freak. (Implementing the Levenshtein distance is a good idea.) 

(And keep in mind the "Flattening Arrow Code" comment from palacsint on your earlier question. :) same comment than 4. You have other occurrences of this issue, I won't list them all. : strive for meaningful comments. :) What is ? Is this useful or confusing? Try adopting a convention for your names, to allow users to easily guess them. Changing names arbitrarily is not nice. If you want to code_like_this, at least use . 

A note about the 80-char limit: in this case, the list is more readable if you don't enforce the rule. Recovering from failures What happens when mounting works but not copying? You should still try to unmount your folder. 

I think you should keep it. is not only meant for the compiler, but also for anybody reading your code. Even with the cast, you're still saying to readers "Trust me, I'm not touching your buffer!" and this is a valuable information that should not be discarded. 

Well, the answer depends on the meaning of the variables. If they are related (and they should be, since the same functions uses them!), then it's a good idea to group them in a dictionary since it makes the code more readable. However, even if it makes sense to group all variables into a dict, your solution is not satisfying because it is unlikely that and really belong to . What have you gained here? Function definitions may be shortened, but you only moved the problem to make it less visible. The next developer will be very surprised to see that you simply replaced function arguments by a dict without thinking about readability. This does not respect the Principle of least astonishment and probably others too. You should try to group variables that really belong together, make use of *args and **kwargs whenever it makes sense, and otherwise split/reorganize functions that take too much unrelated arguments: they probably break the Single responsibility principe anyway. Now, be careful when refactoring such functions, make sure you really understand them, and write unit tests or integration tests before changing them to make sure you don't make the code worse than before. 

Why don't you use multiple exceptions? If you want to stick with one exception, don't pass "invalid type" in the constructor, since it is always going to be the same message. Prefer to override to return "invalid type" when the type is . 

How exceptional is this error? What do you want to do when this happens? If it's rare and you don't want to do anything, then: 

the way you're involving winning conditions with the chance system user interaction: you're over-using alerts when you could slide down messages with jQuery. Avoid modal interfaces. AI is simple, but that may be what you want. 

This is even more true in F# where pattern matching lets you really write code around your data structures. So, what's wrong here? 

Okay.. got it. Iit looks like that when part of a winning move is done by a player, we add it to the player possible winning moves. Isn't this over-engineered? Why don't you simply check on every move if a winning move as made? You don't need to store wins or chances, just check 8 configurations. (Such a function would also work for larger grids, by the way.) 

This section of the code is specific to Tkinter, which is good. I don't know the API so I can't tell if something could be better. Oh, and thanks for the screenshot, the app looks quite good for not that much code. Congratulations! Don't feel demotivated by all my comments, you don't need to improve everything at a time. 

Disclaimer: I know some OCaml and a bit of Erlang, but never implemented an F# actor before. I also read the async paper you mentioned in the comments (apart from "Semantics" and "Implementation"). Style Indentation