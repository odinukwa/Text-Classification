Digging in: Check the Docs You have more fields than are needed. 2-3 tree nodes have either 2 children and 1 data field, or 3 children an 2 data fields. You have and in your initializer... Own the node You have a tree class and a node class. Move the node class(es) into the tree: 

But honestly, why not do the checking in the while loop, instead of relying on a global variable set who-knows-where? 

And get the same result! Going further, it turns out that Python has a built-in that adds up a sequence of values! You can switch from adding these numbers in Python to having Python's interpreter add the numbers in C. That should speed things up nicely: 

CellType Your cell type is an enumeration, which seems obvious but actually isn't very useful. The thing you mainly do with the cell type is display it, and sadly C# enums cannot have char as their underlying type. But you can work around that using an and just assigning char values: 

What you want is to have multiple producers - and a single consumer. You can use TPL Dataflow's for this. Here, acts as a single-threaded thread-safe consumer. 

Now, imagine table C depends on table B, i.e., table B cannot be dropped while table C exists. The function will be able to drop tables A and C, but not B, and so it will return . So, I wanted to write a function that takes a list of tables, and calls . If any of the operations fail, it calls again but this time only with the tables that could not be dropped in the first iteration. And so on, until either all tables have been dropped, or progression halts (i.e. all operations in a given iteration fail, due to e.g. a connection being closed) This was my first stab at it: 

I wrote a method called , which moves an element to the first position of a sequence if it exists; otherwise, is returned. If appears in the sequence more than once, only the first occurrence is moved. Sample input/output: 

(The looping version should be obvious, when you get there.) You are handling the various degrees of difficulty as separate blocks of code. That was necessary since your code had the answers built in. But with the answers encoded in the questionnaire files, you no longer have to do that. Instead, just open the file and handle the questions in one place: 

First, there's a couple of things you're not doing which I think you should: you should provide a comment describing what this program does, and you should validate your inputs. That is, give a banner like: 

The superficial docblocks are annoying. Please delete them. I really don't care if some automated checker passes with no errors or not - because the people who write automated checkers have gone way past the point of helpfulness into puerile prescriptivism: "Your variables must be at least 3 letters. Your sentences cannot contain more than two pronouns. Your participles are dangling." If the tool isn't helping you, don't use it! Or spend the time to gen up a config file that turns off all the stupid. Your organization is confused. You have a class Node, which appears to be used by and no other. So why isn't there an file, with and a private class Node? This reads like Java code. Get used to the idea that modules can contain more than just a class. Also, you spend a lot of time doing little special-purpose "play the game" logic. Why not write a class and simplify all the code? 

I would consider setting the value to something else other than the input value an unexpected result. In other words, it violates the principle of least surprise: 

Checking whether two lists are equal is naturally an O(n) operation. So yes, your code looks efficient. Note that you could also replace your loop with 

The same goes for properties - so should be named Coding Style You could mark your private field . People often also explicitly mark them as though it's not entirely needed. The type doesn't really represent a role, does it? The name seems misleading. I think would be a better fit. Why does have a parameterless constructor? Using that constructor would result in s being thrown, since would be unassigned. This cast is unnecessary: 

I could have easily defined these as extensions on or , but I wanted to try and define them for the most abstract type possible, . For this, a is needed (I think). Code: 

Please note, however, that it's important to keep this nested below the statement, since none of the data has been read in! The structure should look like: 

Of course, might be a better name than . Break down your function Currently your function consists of a loop to play multiple games in series, containing a loop to play each alternating turn, plus logic to display the end-of-game results. Break down your main into a separate function to play one game, plus a loop to play multiple games by calling that function: 

You don't show your import of . But I'd prefer that you not import by name, and rather spell it out inside your function. You're only calling it once, so it's more efficient to the reader for you to simply say: 

You don't seem to have a policy for a maximum pool side. Is that by mistake or by design? What should happen if someone requests an object too many? Your choice of method names is slightly off. When I talk to an object pool, I don't want to Loan it an object, nor do I want to Receive an object. I want to "borrow," "obtain," "take" or "get" an object from the pool, and I want to "return" or "release" or "put" an object back into the pool. I'd suggest: 

Exceptions Regarding : Catching all exceptions is usually regarded as a bad idea. I'm not saying this is the case, but consider catching the specific exceptions you expect to happen, e.g. , , etc. Why does the method return a if the string is always empty? Why not just ? Similarly, your checks if the string is null: , this seems redundant. Also, returning a empty/non-empty string to signal that something went wrong does not seem right. Surely, if the API call fails, that would be an exceptional scenario, would it not? Consider letting the exception bubble up to the controller, where the error can be handled. Then, change the return type from to simply . This is how I'd report errors: Web Api: 

So, unless you're doing true async I/O, do it synchronously. Alternatively, if you want to expose an async interface, where the implementation may or may not perform asynchronous I/O, synchronous implementation should use instead of . Example: 

Now you don't need a global but can use the parameter instead. Similarly, you are computing/updating in the function, but this can and should be just a boolean return value: 

Now you have tuples where you can ignore the [0] element, and the [1] element is the index value. You can either make a pass to replace the indexes with values, and then merge the static and dynamic lists, or you could do it all in one pass. I suspect that the sizes of the inputs will determine which is the right solution: for very large inputs, especially with smallish s, using bulk operators (array slices) is worth getting right - that is, figuring out how to do . On the other hand, for short lists, the single while loop that merges like you have now may be faster, or at least fast enough. 

Given , how can you predict (above)? What's the number at the root of the tree? Given the number at the root of a tree, what are the values of the numbers at the root of the next lower subtrees? (Hint: easy for the left, harder for the right.) 

Your implementation is technically correct, but... There is no benefit in using in an web application. All you're doing is deferring work from one thread to another. So, in fact, not only is there no benefit, you're actually adding overhead. I'll quote Stephen Cleary, because I could nevet put it better: 

In a sense, your usage of properties is somewhat incorrect. From the book Effective C# by Bill Wagner: 

Also notice how you're returning a 200 OK response, even if the request failed. This is definitly not right. You should serve a 500 Internal Server Error instead. 

HTTP and Web Api The route does not seem RESTful. RESTful APIs are resource-oriented - a more natural way would be to simply issue a POST requets to . If you're using Web API 2, your method could be re-written to leverage the family of classes 

If you take a look at its implementation, you'll notice that it's very similar to yours. It might be just a tiny bit less efficient - so if performance is an issue here, measure both approaches, and then weigh readability/maintainability vs performance gains. On a different note, I would rename the method to and consider it a "specialization" of for lists. I would also consider throwing an exception if either argument is null. This would be consistent with the BCL's own extension methods (, , , , , , etc).