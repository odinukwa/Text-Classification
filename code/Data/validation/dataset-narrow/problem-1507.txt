Having a discussion about the plusses and minuses can be valuable, but sometimes what you need is a motivating example. It's true that loops and recursion are equivalent in the sense that they can provably accomplish the same tasks. However, some problems are simply astoundingly easier with recursion, such as iterating through a tree, or finding all of the anagrams of a set of letters. I mention this second example because it can be brought up in a introductory class long before trees come into the picture. 

. But then I tell the students that there is a hidden limitation. I want to see if they can spot it, and I provide them with three re-writing exercises (that are also practice exercises on the prior concepts) to help them find it: 

Simple de-motivation. Upon hearing that this very hard thing that they are faced with is partially false, the student simply despairs and gives up. Why do all of the hard work to understand something that isn't even true? Brain-scrambles. What happens in a student's brain when they hear that there is more to the story may not exactly be the blank "okay, there will be more later" that we might hope for. Instead, what might happen is a series of rapid mental transitions, in which the student mentally loops through the components of what they have learned and tries to guess at which part might not be true, exactly, and what that truth might be. This involves a sort of miniature cognitive scramble at each pass. "Okay, so if this part isn't true, then maybe things don't quite connect the way I've just been shown." The reason that this matters is that, if the connections in your student's brain are already quite tenuous, the process of scrambling can muck everything up. When faced with the revelation that the topic has even more to it, confused students still go through that same mental process described above, but what comes out of it is essentially spaghetti. That tiny, inchoate thread that they were constructing about your topic will simply come apart. 

I'm sure that basically every introductory course involves teaching about the ubiquitous mod operation. In my experience, and I'm sure I'm not alone in this, I've found that teaching my students that "mod is the remainder of division" is insufficient if I want them to make any use of the concept later on. Beyond showing them how to use mod to check divisibility, I have for the last few years gone into far more interesting operations in order to help them achieve some intuitive understanding of what mod is and how it works. So, for instance, I show them how they can increment within a modular circle of numbers from to (a circle of size ): 

I have explained big and little endian from time to time in my teaching career, but it is quite dry, and asking my students which direction each one goes three months later has revealed to me that my lesson doesn't make which "end" goes with which part of memory really stick for my students. I would like to explain endian-ness so that it is fun, memorable, and makes clear why the two systems exist, but I haven't found a good way yet. It's a small concept, so it can be a short demonstration, but I still want to make it effective. Does anyone have any classroom tricks up their sleeves for this one? 

First, I will note that curriculum-design and self-learning are both on-topic right here on CSEducators, so this very site can be a great resource for the self-learner in computer science! There is a saying about the self-taught student, "great student, but they had a terrible teacher!" When designing a curriculum for yourself, there is no single, easy way to make sure that your education is comprehensive within unfamiliar topic. You are dependent, then, on organizations of the material provided by other people. When I am self-teaching, my first job therefore becomes to find a textbook. Sometimes the textbook itself is rather too difficult to use as a single source, but this is okay! The introduction and the Table of Contents are actually the most important two items in the book for my purposes. The introduction typically lays out the central thinking behind a topic and a coherent philosophy about how to best learn it, and the Table of Contents lists all of the important topics. If the contents of the book are also useful, then I simply count my lucky stars at having found such a wonderful book! For secondary resources, students can seek out tutorials (either written or video), documentation (if they are capable of learning from APIs), or online coursework. They can then use the textbook TOC as ther guiding star, and work their way through the topics that they need. Using the TOC as a basic guide about what is contained in this topic means that students can make informed choices about what they need to study as they work their way through the program they've designed for themselves. 

This is a topic very close to my heart. I think that the skeptical attitude you've alluded to simply comes from the fact that most people were taught imperative programming first (and some were never exposed to any other paradigms at all). Turing's Machine was easier to conceive of as a physical, mechanical device than Church's $\lambda$, and it is presumably by this historical accident that mutability rules the day almost everywhere. I am not even remotely convinced that imperative programming is more obvious or intuitive than functional programming. In my experience, setting values is a consistent cognitive trap for students, and one that I have to treat with great care. My very first unit for AP is modeled rather loosely after Tom Rogers' phenomenal opening AP unit, Java Ain't Algebra, which takes exactly this issue head on. In my (by now heavily modified) version of Roger's mini-unit, I make explicit that values can change, spend time tracing them, show why is not the same as , and spend a lot of time making clear that the programmer's is only barely related to the mathematical $=$. We also begin to explore the runtime stack. Teachers often miss that this even needs to be covered because, once they are thoroughly inculcated in imperative programming, it can become hard to even see why this is hard in the first place. The variable was , but now it is . What could be simpler? But of course, students exposure to variables prior to CS comes from algebra. And in algebra, when we say that $x + 3 = 7$, we mean that $x = 4$, and it cannot suddenly become $5$. We can solve for values, but we cannot alter them. Here's the takeaway: if we, as teachers, don't make explicit how very different it is to be able to change values, a certain percentage of students don't ever fully pick up this idea. They'll get hazy bits and pieces of the idea, but have trouble operating, and ultimately fall behind. In my experience, they don't appear to get noticeably lost until far later in the year, but by then, it is very hard to get them back on track. (When I take on a new tutee in the months leading up to the AP test, this is one of the first areas I check if they seem generally lost.) I have also come to believe that this is one of the key ideas that most CS teachers miss, and is responsible for a substantial portion of computer science's very bimodal results with students. There is a real cognitive load to considering not the value of , but the value of right now, and having to both track that value and figure out when to change it. In spite of what this all sounds like, I'm not suggesting that functional programming is necessarily easier; it has its own cognitive load, since suddenly we are contemplating many, many simultaneous 's taking place during recursive calls. It's almost as if learning to talk to something as alien as a computer is always going to be a bit tricky :)