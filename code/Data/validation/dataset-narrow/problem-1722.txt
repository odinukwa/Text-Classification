If you have nmap installed on your laptop, you can use it to scan your network in order to identify your Pi and its IP: 

The return value is probably one of: conservative, ondemand, userspace, powersave, performance. If you want to follow my recommendation, choose "ondemand". If you want max frequency (no scaling), choose "performance". If you lowest frequency (no scaling), choose "powersave". Here I choose for cpu0 the ondemand governor: 

The recommanded way is to follow Docker installation document. It works on my Raspberry Pi 2 (I have 2 of them one with Raspbian the other Ubuntu). See my detailed answer here: $URL$ 

First guess You did not say, so I'm going to ask and tell you how to do it. Did you create SMB accounts (for each of the users in the group users) and did you connect using such an account? In Samba when using the smbpasswd backend, you need to create a corresponding account in samba itself. Let's assume you have the user foo in the group users on your RPi, then you want to run: 

Defining what a decent speed is is not possible. Perhaps for the type of development and for the need when testing the developed software, a qemu VM is perfect for you. Just try it and see for yourself if the time it takes is acceptable or not. Then depending on the type of development you want to do, portability might be an issue or not. What is your programming language? If it's C it might be less portable than if it's Python. Then what 3rd party library do you plan to use? Are they portable? So depending on what you do, you could develop it on your laptop without qemu, directly under your OS of choice (Linux, OS X or even Windows) and then test it either in qemu or a real RPi. Even for C development it is possible to cross-compile it from a x86_64 machine to run on a ARM board. Only limitations you could encounter is when you want to use really specific RPi interfaces which you can't emulate (or have the same library to interface to them) on your laptop, such as the GPIO pins, SPI bus, etc. So your question is too vague to have 1 answer. It all depends of what you want to do and how you are going to do it and how you are going to test it. 

The current Docker hub does not yet support multiple architecture for an image. So the image you are trying to pull when doing is the x86_64 one and it won't run on Raspberry Pi. Update: Docker has now multiarch support. So many images now can be pulled on both x86_64 and armhf (e.g. will work on your desktop/laptop Intel/AMD CPU as well as on your Raspberry Pis). Some images are still not multiarch, for those you can check this Docker repository for images for your specific architecture: $URL$ For other specific ARM7 images, you can use 3rd parties. But you need to trust the authors of these images and many are still experimental. Here are 2 links with what I think are "quality" images: 

You can use the same password for the smbpasswd backend as you use for the RPi login of foo. Or you can use a different one. It's your choice. Now using smbclient, you just need to make sure you add (or whatever username you chose) and enter the password. Repeated environment So on my Raspberry Pi 2 which is running Raspbian (but upgraded to the Jessie baseline) I have install samba ( version 4.1.17+dfsg-2) from Debian main repositories. I've copy/paste your configuration (so replaced my entire /etc/samba/smb.conf with the one you provided) but only set-up "media0" and changed the path to an existing directory on my RPi. I have added the user pi to the smbpasswd () and I made sure that the path to media0 is writable to the user pi (to verify that try to do on your RPi: if it created an empty file, it works). And I started the smbd daemon (). On my laptop, I used both smbclient and Nautilus to connect to the RPi samba share successfully. So your samba configuration file is good! What can be the problems: 

Note: answer amended with input from @goldilocks. What your friend perhaps meant was to check the SD card for bad sectors. A SD card, just like SSD, are subject to wear when cells are written. Depending on the card quality and how full the file system is, corruption of cells can happen rather quickly. On a SSD, the embedded microcontroller usually take care of managing this bad cells and has often many spare cells which it can use instead. On a SD card, there are no spare cells and the microcontroller in it does a much simpler job at managing bad cells and there are no interface to report back to the OS of this issue. So basically once a cell has become bad, you need to check your filesystems. Trying to fix your SD card Note: the Raspberry Pi has at least 2 partitions, a FAT32 (aka vfat) one where the kernel and releated data (aka firmware) are located. FAT32 can avoid bad sectors if instructed to do so, but I am not sure that the Linux tools support that for FAT32. However, it would be surprising that you have bad sectors on this partition as it is seldom written too. You need to repair your filesystem and do some simple bad block checking. Run on the other partitions (with the exception of the 1st vfat one): 

Anyway, if you want to go for the first route, then there is this pretty neat guide from the Raspberry Foundation itself detailing you the different steps to configure manually (command line) WiFi. It shows you how to use to list the WiFi network names (aka SSID) which you can connect to and explain you how to configure the wpa-supplicant configuration file with this information. You can still use a fix IP address, make sure it is in the same subnet as your other devices on your home network, and that it is outside the pool of IP address your home wifi box (aka router) will assign. For this check your router documentation or administration interface. It is possible on some router to reserve a fix IP address from the DHCP pool to a specific devices (by mapping a particular MAC address to an IP one). So you could configure your RPi to use DHCP, but still get a known and fixed address. And if you want to have an almost complete reference to wireless on Linux, I highly recommend the great wiki from ArchLinux! It does not apply only to ArchLinux, and can be used for other Linux-based distro, albeit not all packages might be readily available. 

But do not trust me blindly :-). Look online at resources for Docker on Raspberry Pi and make up your mind. 

You are confusing me between UUID and PARTUUID. Which one do you want to use? It was reported that UUID does not work in the configuration file as the Raspberry Pi official kernel is not compiled with the right option. However, it seems that one can use PARTUUID in this configuration file (as you said). To get the PARTUUID you should use which report both UUID and PARTUUID. For example: 

(replace by the partition, example: or ) As a last resort, you could use the badblocks utility (run on each partition of your SD card, obviously you need to do that from another Linux computer or from within a VM running on your desktop/laptop). This will tell you how many bad blocks are. If you have any bad blocks, you can let know your filesystem so that it avoids them. However there is a limitation, the badblock utility on SD cards will only work for allocated blocks, not the free ones (where you might still have bad blocks). If the card is not repairable If you have too many blocks broken, it is possible that you cannot use your SD card anymore as you might not be able to flash the image on the SD card without ending up with a corrupt file system. The solution is most likely to buy a new SD card, but this time not a cheap one :-) I've bought 2 safe brand for SD card, and one is running now for 1,5y and the other for 1y. 

Docker supports ARMv6/v7 and even ARM64 (v8?), so you can run it on your Raspberry Pis. Follow the official instructions from Docker here: $URL$ If you have Raspbian Jessie or Stretch (check the above documentation for others), this would be: 

Note that I haven't tried this my self. I'm booting from the MicroSD card, so I don't need this feature. Update I would give another try with UUID. Using the output from and the UUID keyword in the . 

As said by the others, IP addresses in the range 169.254.0.0/16 are link local only. It is undefined what will be the behaviour of a system if you try to use it by setting those as static IP addresses. Most likely it discard it, and try to configure a link-local connection, so it is reassigning a new IP from this range and its algorithm always make it peak the same one. Try to use an IP address in the 192.168.31.0/24 defined statically on both the Mac and the RPi. You should be able to get a direct connection. Or if you want DHCP, then either on the Mac or on the RPi you need to install a DHCP server. If you fail to do so, they probably both fallback to link-local IPs. These link-local IPs are usually set-up by zeroconf/avahi/bonjour or possible being implemented by your favourite network manager (using the same kind of protocol). 

The path to the shared directory are incorrect or are not accessible by the user pi; A network problem, maybe you have another computer competing for the group WORKGROUP. Try to change the workgroup name and restart smbd. Check your firewall(s)? Do you have any in between the test client and the RPi (including on both end)? Maybe a problem with nmbd? is this daemon running ()? Does it work better if you stop it? Is samba really running? Check both: and also 

Edit: Sorry this answer only works for RPi 2. The problem with the RPi 1s is that Debian does not support this architecture by default (ARMv6). So you need to wait for a project or someone to do the build for you. The following answer only applies to RPi2. Collabora provides Debian 8 Jessie images for the RPi. They claim it's the official Debian 8 Jessie for armhf architecture but with the Raspberry Pi custom kernel and recompile by them. The instructions and download links are here: $URL$ Or check directly Collabora Blog for more recent news if any. 

Then boot your Pi. Make sure the IP+netmask on the laptop will allow to see the Pi IP address from it. Then try to ping the Pi using its IP address. If you don't like link-local addres, you can use other IP ranges reserved for private LANs, such as any subnetwork within 10.0.0.0/8, 172.16.0.0/12 or 192.168.0.0/16. For example, you could pick up for your Raspberry Pi (note that /24 is equivalent to a netmask of 255.255.255.0) and for your laptop if it does not conflict with other LAN IP ranges in your network(s). So on the Pi side you would have: 

you will need to clarify a bit your question: what is exactly the problem you are seeing? I will try anyway to provide some clues. Background Info Most (if not all) consumers router use what is sometimes advertised as a firewall (but which isn't) NAT or Network Address Translation. It means that your router has one public IP address while your other devices on your LAN share a subnet which is not routable and is part of a private IP range (e.g. 192.168.1.0/24). Because those private addresses are not routable by definition, they are not accessible from the internet. So this create a barrier between the outside world and your local network. So it accomplishes the same as a firewall which would block all incoming traffic but allow all outgoing traffic. NAT is not something you can disable, unless your ISP can provide a public IP address for each of your device on your local network. It would mean also that you would really need to build a firewall to protect each of your devices because by using public IPs, they would be all accessible directly from the internet. However, when you need to allow one of your local computer (with a private IP address) to be accessible to the internet, what you do is actually open the port on the router public IP address and ask the router to forward any incoming connection to this part to a particular computer in your local network. This is called "Port Forwarding" on most Netgear router administration pages. Setting Up your router to make your RPi a public web server If you want to set-up port forwarding to your Raspberry Pi (RPi). First login to your router, and set a fix IP address for your RPi, this is done in "Advanced > Setup > LAN IP", see your router's manual at chapter Reserve LAN IP Addresses). Choose a fix IP addess for your RPi and remember it. Then go configuring "Port Forwarding" (the manual does not have a dedicated section on that, so it is possible that it does not support it, however there is one knowledge base article for your device), look at the intructions on that page and add a new HTTP service on port 80 or HTTPS on port 443 and specify the IP address you chose for your RPi. On your RPi, it might be necessary to reboot it (or disconnect and reconnect the network) if you choose a different fixed IP address than the one currently assigned. Then you will need to install your web server (e.g. Apache or Nginx ) and make sure that if you use a firewall on the RPi that it allows incoming connections on port 80 or port 443. To know if you have an active firewall: . 

The only thing you seem to have misconfigured is that SSH is a TCP only protocol, so you do not need to forward UDP traffic on port 22. Now why it does not seem to work is probably because your router does not support NAT loopback. What it means is that the NAT rules (such as your forwarding one) are not applying when the origin of the connection is from your internal LAN. Not all routers have this feature ON. Thus if your router does not support NAT loopback, then you will not be able to connect to your RPi using SSH when using the no-ip.com domain name and when doing it from your LAN. To try if your configuration is working, if you have a smartphone with some data connection (3G, LTE, etc.) and there is an ssh client on it, try to connect to your RPi using the data plan and not your WiFi connection. If you don't have an ssh client on it and you are allowed to do tethering, then use your smartphone together with one of your computer by unplugging it for your local network and using the tethering link instead. 

In order to avoid typing for every Docker invocation, you can do the following extra steps: $URL$ Enjoy! PS: I've installed Ubuntu Server 16.04 for armhf. I have then followed these instructions (for Ubuntu) to install Docker on it: $URL$ It works like a charm as well. 

It should work specifying a link-local address (169.254.0.0/16) on both sides of the connection. And ideally both sides of the connection should have the correct netmask (better use 255.255.0.0). So on the Pi, make sure you have the IP data express like this: 

Note: I'm on the Pi 2. Strangely it should be 100baseTx-FD (full-duplex) and it seems I have a problem that my Pi negotiated half-duplex. But says that it is full-duplex 100Mb/s () So I'm not sure about reliability. But looking at the source code of the module, there are some codes which is your interface is full-duplex could set up flow control for rx and tx. You could use mii-tool to verify your current settings or to change them.