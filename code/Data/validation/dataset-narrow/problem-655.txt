Returning is a terrible idea. Firstly, can be a valid value. Secondly, it won't compile for an arbitrary type of values, so it makes the use of your cache extremely limited. Here're several ways to fix it: 

because the same variable holds a compiled regex in the first line and it's reassigned to a string later on. 

Functions and variables naming: it is conventional to name functions with a verb(to describe an action). I would use instead of and instead of , for example. You class violates the single responsibility principle. Despite managing memory allocation(which is its main responsibility) it also implicitly implements some data structure(a stack?(I mean things related to the , the pointer and so on)). It makes the code rather hard to follow: those operations with and pointers are not easy to understand(it is not clear why they are performed in the first place). There are two ways to fix it: 

I would delete it. Error handling. It looks like your does not expect to receive a negative number. Instead of returning a wrong result, I'd throw an exception: 

This way, you just need to define a new subclass of the and add its instance to the map to define a new operator. You can make the code even more flexible by passing this map as a parameter to the method to decouple reading the input from the computations (this way, a client will be able to define his own subclass of the and pass it to this method). I'd also rename the . or seems more appropriate to me (because a number is also a token, so this name is more precise). There's also no point in having static members in the class. It makes it non-reusable and might create a bunch of issues in a multithreaded environment. I'd suggest to make all members non-static and encapsulate them properly (and pass a reference to an instance of this class to the constructor of the concrete subclasses). You can also decouple the operators from the calculator completely by changing the signature of the method to (it might be an issue for non-binary operators, though). You can improve your code by handling the errors more carefully. For instance, if the number of tokens on the stack is more than one in the end of the evaluation, your code will return some value, but it should be an error ("1 2" is not a valid expression, is it?). You can check such cases and throw an appropriate exception. 

Now it is clear that these are the coordinates of the bottom of the player without any comments(it would also be good to change and to something more descriptive: what part of the player do they represent? Why do we add to ? Ideally, the code should be written in such a way that answers to these questions are obvious). One more example of an unclear method: 

Your algorithm is very far from optimal. In the worst case (if all numbers are equal to in the input), it does operations, which clearly way too much (not just for python, for any programming language). What they're asking to compute is , where is the Euler's totient function. Using the fact that the function is multiplicative one can derive a formula . Using this fact, we can compute it efficiently in time for all using something that looks like the sieve of Eratosthenes. After that, we can answer each query in . A C++ implementation is ridiculously concise and easily fits in the time limit: 

One method should be responsible for one thing. There're at least 4 different (very different) things here. In fact, I believe that the first thing (and probably the second and the last thing, too) doesn't belong in the class. Why? It makes sense for the counter to count occurrences and do just it. It'll make it more reusable. Think what happens if you want to change the output format, the way the user choose the file or just use it as part of your different project. I would redesign the it so that it has one method that takes a string and returns a map with different words and the number of their occurrences. The reading/writing stuff and the user dialog belong to a different class. These are different concerns. So I'd create another class to handle file I/O and one more class to interact with a user as these things have nothing to do together. They can change independently and they don't need each other to work. They're separate entities. You don't handle the case when the is (that is, when the user doesn't choose a file). A isn't very user-friendly. This piece of code: 

There are too many blank lines inside methods, in my opinion(it is conventional to separate methods from each other with an empty line, but it is not common to insert random blank lines inside a method's body). 

I don't think there's a point in having multiple constructors in the class. I don't see why it should have any fields at all. I'd suggest to store the data in its subclasses (so that each subclass has only the fields it actually uses. It makes no sense for the to have the field, for instance). Actually, the could be an interface with just one method for computing the area. I would also create methods to read the input for each specific figure and print the result (so that each clause just calls the corresponding method). It will also help to get rid of a bunch of variables declared at the top of the method (they reduce the code readability because their declaration point is far from their first usage. Moreover, some of them are never used depending on the user input). 

It might look the memory management works properly in your code. Well, not exactly. Your code is not exception-safe. A node is allocated with a call in the member-function. A pointer to it is added to a vector using . If fails with an exception, the memory leaks. The pointer isn't stored anywhere, so it'll never get deleted. There's no such problem if you use smart pointers. Setting the of the to a negative number is confusing. Moreover, isn't guaranteed to be signed. An overflow of a signed value is well-defined, but it can break if the string has non-ascii characters. How to fix it? Firstly, Let's do a simple thing and add a flag to indicate if some word ends in the (it shouldn't be called a leaf because it may not be a leaf). I'd call it or something like this. It's makes more sense than storing a negative value. I think that keeping the in a is quite confusing. There's no value for the root, is there? In fact, the letter marks an edge from to another. That's why I'd rather store a or an from a character to a pointer to a . It has a clear meaning: an edge marked by a specific letter. This design is closer to what a trie is from a theoretical point of view. There's no reason to use raw pointers. You can use . It'll take care of memory clean up. It'll simplify your code and make it less error prone. So the can look like this: