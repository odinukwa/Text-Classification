Looking at your , I have the feeling that you are doing only integration tests (from the request to the database). You should split you tests to the individual layers (the current one if for routing: it could use a mocked DB). With this approach, the could be deleted (do only the setup that is necessary for each test). 

go-torch beein able to generate a FlameGraph ($URL$ Here is a video introducing profiling in go: $URL$ 

Since you know in advance, you can hard-code it's square root. You can then perform a binary search between 1 and this pre-computed maximum. It will remove the questionable "exponential search". You will then also achieve a \$\mathcal{O}(\log \sqrt{Long.MAX\_VALUE})\$ complexity, which is actually \$\mathcal{O}(1)\$ as observed by @Simon Forsberg. This means that the execution duration can be bounded by a constant time (this does not necessary means that this algorithm is the fastest). 

In the end there's not much code to review, and perhaps you should consider posting the whole class. 

I'm not a fan of classes that are called a plural but aren't actually a collection of items: , , etc. This gets especially bad when they're properties: 

I note that you keep the Excel file open and then parse one or more text files. Have you tried closing and opening the Excel file for each text file you parse? Also, have you considered other ways to open and edit Excel files besides Microsoft.Office.Interop, like OpenXml? 

doesn't convey that it returns a . Name it . (Also, is looping through all coordinates in your grid efficient?) Same for . 

I don't think you need either to be stated explicitly, since the previous code will always return a value (or throw an exception). 

The key is the microserie and the value is the number of series done by the user. For microseries without any result, you will need a default value (0 here: . With a similar technique you can have the total number of microseries. 

I would recommend Don't repeat yourself As you can see, the two branches of your are very similar. Instead you could do a 

Grid entity removal Maybe instead of actually removing the entities, you could mark them as 'visited' (via a boolean property). It might prevent some heavy memory usage. 

Readability To ease the readability (and testability) of your code, I would recommend you to split it in multiple functions communicating via multiple channels. For instance, for the client: 

Miscellaneous If you use Python 3, you can use iglob instead. For the , I prefer using it like this (instead of the index): 

If it isn't, then your DOM should be corrected. == and Type Coercion As a general rule of thumb, you should always opt for over (and conversely opt for over ). basically means does a sort of equal b. It doesn't take into account the variable's type. passes as true (even though one is clearly a string, and the other clearly a number). means does a and b match the same type, and does the value equal each other. In this case, will return false (because of the difference in type.) I know this might sound small and nit-picky, but in reality it really isn't. Using will lead up to unexpected behavior that can be hard to spot. Additionally, is faster than . will stop trying to compare two variables if they do not have a matching type. Simplify Conditional I want to highlight the following conditional: 

I find your variable naming quite good (but it took me time to really understand the goal or your code). Code simplification I consider that should only contain the results of the user (or better: its assessments): 

So the kwargs does not seem to allow you to set a new . Hence it seems that the only way to set a new is to remove and recreate the attribute. From this case, it seems hard to further simplify your code. 

Looking at the random number generation, a lot of duplicated code can be easily removed. Starting at the 4th line: . The only function that is used is , so you could do and then use everywhere, instead of . Another repetition that can be avoided concern the arguments of : you can unpack the tuple using the . 

But MSSQL isn't one acronym, it actually consists of two: MS and SQL. And there's a word missing: Server. So it should be MsSqlServer instead of MSSQL. Also, I don't know of any rule that explains why MSSQL should be converted to mssql when camelCased. 

I'm a bit worried about how this one method seems to be dealing with distinct requests. The value of for instance is only relevant for a small part that involves neither nor , so why then clutter this method by inserting that logic here? Why not instead have: 

This is still a fairly short program with limited functionality, but you could already consider moving both the logic and the logic each in a method of their own, perhaps even to a class of their own. Keep your lean and clean, use it to stitch together the various independent parts. Ditto for the output part: move that to a method of its own, and provide parameters with all the necessary data. 

(Note I strongly recommend using over , you'll run into less problems in the future this way. Event Binding You should try to get into the habit of using instead of `$({selector}).click(function(){}). applies an event handler for every instance of , whereas the will apply a delegate event handler to , and listen for any within . The difference is making 1 event handler compared to making many. Right here, there shouldn't be too much of a difference. We are assuming that there is only 1 . But, as you can imagine, using can give huge performance benefits over directly. But, most importantly, by using , you are binding the click event to . Should you remove and re-add a new in its place, the click event will be lost. This is not the case with applying the to a parent element.