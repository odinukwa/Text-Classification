No, nothing is stored on the Pi hardware itself. Everything is saved on the SD card, and as a result SD cards are interchangeable between different Pis. No one could recover any information off the Pi (sans SD card) as it simply isn't there. 

You may be able to create a network bridge. This essentially lets your Pi act as a network switch between the Wi-fi and wired networks. 

You can use a dynamic domain name server like DynDNS if there's internet access to keep track of the IP address. Alternatively, your router may do this automatically. On my network a simple "ssh raspberrypi" almost always works because when the DHCP lease is requested, the Pi sends it's domain name along, which the router then puts in its local DNS service. 

I suspect it might be a color saturation/white-balance problem. The software will try to adjust for the available light but it doesn't always get it right. Think old web-cam or mobile phone camera. According to the camera documentation, you may want to try playing with argument for saturation, it ranges from -100 to 100. for white balance, try setting it or . (There are other options in the linked manual.) 

Both those approaches you've linked are WPA based. If your network really is WEP, it's a slightly different process. Try editing the /etc/wpa_supplicant/wpa_supplicant.conf file and adding something like this: 

As Guzunty mentioned, I've used both pi-blaster and servoblaster for using PWM to control LEDs. The latter includes a kernel module, but the recommended method is now the user-space daemon. Both methods create a /dev/servoblaster file which you can write to change the PWM status. (The advantage of the user-space method is that you don't have to match the kernel module to kernel version, which could require compiling.) How they work is they use the DMA timer of the single PWM pin of the Pi to time the signals on any of the other GPIO pins. I've found them to work pretty reliably under varying CPU load conditions, so I'd say it works well. Much better than pure software PWM. 

The libraries should be compatible unless a completely different major version has been installed. Keep in mind that the Pi is ARM while your Ubuntu system is probably x86. Any software will need to be recompiled, which means you'll need gcc, etc., installed from the build-essential package. You'll also need all the relevant dev packages. On that note, bear in mind that openssl is a binary utilities package, you probably want libssl and libssl-dev if you're using the libraries directly. 

The MoPi board would do the 12 V power conversion and provide battery monitoring capability to the Pi. Without a separate circuit there's no way to do it. 

If you have a Revision 2 Pi, there's the P5 header, which adds another 4 GPIO pins. This could be an easy way around it. 

The closest you can get are the ShevaPlug and its derivatives I think. Specifically TonidoPlug2 or DreamPlug. They're more expensive and are enclosed, but are the closest thing I can think of that's ARM. There's the Intel Galileo but that's 100 mbit. It does have a mini-PCIe slot so you may be able to add gigabit ethernet. It may make more sense to add USB3 to it though, that way multiple fast devices can be attached. 

In general part of the problem that you're experiencing is that screen updates to the Pi are slow because it's a framebuffer device. You may get better performance if you lower the resolution using config.txt. Also, it may be worth looking into the official optimised browser. 

It depends on exactly what sensors you need to connect. Are there lots of analog sensors? The Arduino might be better. I personally don't know how easy it is or not to detect counterfeit currency? Is there a sophisticated algorithm involved? Maybe the Pi might be better. How are you communicating the data? A continuously running log file? Raspberry Pi. Some status LEDs? Arduino. Does it need a camera? Raspberry Pi. What are you most comfortable programming in? Python? Java? C++? Raspberry Pi. Embedded C in an IDE, Arduino. I really think it could work either way. You need to investigate what's involved more (or tell us more!) to help narrow it down. I think it's a feasible project with either device. I'd go for the Pi simply because I don't have much Arduino or mircocontroller experience, but that's just me. 

For 1, I believe the configuration file is created only once the software is run. Then it's placed in a hidden directory () inside of the home directory (). If the file isn't automatically created in like your link suggests, I think you can just create it yourself and it will be read when running VICE. For 2, it sounds like something is trying to enter a bad video mode. The software is probably trying to use a higher resolution than the Pi is configured for, causing the screen corruption you see. 

In general I'd say 4 AAs is cutting it close. If they're rechargeable, they're actually only 1.2 V which adds up to 4.8 V. That doesn't even make the recommended 5 V cut-off. You can technically get away with using only 3.3 V to power the Pi, but then you loose all peripherals. Like USB, ethernet, and HDMI. Not so useful in most situations. (The weather balloon people are having a field day with it though!) Using alkaline batteries, you get 6 V which is enough to power the Pi. Nominally you'd expect around 4 hours power with them (given a 500 mA draw of the Pi and a 2000 mAh capacity of the battery), but there's a catch. Alkaline batteries have a very steep initial power drop. They go from 1.5 V to 1.2 V very quickly, and then remain around 1.2 V for most the rest of their charge, before dropping off again. Ever wonder why rechargeable batteries were ever only 1.2 V? That quirk of alkaline battery chemistry is why. So you really do need at least 6 AA batteries, no matter what. 6 AA batteries gets you probably between 5 and 7 hours of life. 8 AA batteries 8 to 10. The MoPi board is a convenient mechanism for hooking up the AAs nicely, and also lets the Pi know when the batteries are low so that it shuts down nicely. It also accepts dual power inputs, so you could potentially feed solar power directly into the Pi, as well as charging the batteries. 

I suspect either the config.txt file or the version of the firmware for the Broadcom chip used in Fedora are causing problems. Make a backup of everything in the FAT32 boot section of the Fedora SD card, and then copy everything EXCEPT kernel.img and cmdline.txt from the Rasbian boot section to the Fedora one, overwriting files as necessary (that's why there's a backup!). Hopefully this would fix the problem. 

Now here's something I haven't come across in ages, but I do remember a bit of software that would do this. Found it. Streamripper is designed to rip streams to MP3 files, but more importantly also create a relay server (the -r) argument. You can use the relay feature to listen on more than one system. On the downside you'll have to have a system with some free space to hold onto the MP3s it generates until you get around to deleting them. 

This activates a pull up, and my switch on PIN is connected to ground. If that doesn't fix it, you may be hitting a weird edge case in the code with threading that I wouldn't have though possible on a single-cpu system. You might need to implement your own software check for debounce or to try adding a small capacitor (0.1 uF) across the switch. A further increase of bouncetime might help, but if it doesn't I'd suspect bug. 

It's hard to tell from your photo, but it looks like you've connected the +5V to the GPIO pin. The GPIO is only +3.3V tolerant. Any pin you're trying to pull high should be connected to Pin 1 only. It might be worth investigating the use of a pull-up/down resistor. I've outlined how to do this in software in this previous answer. 

The first thing to check in mysterious situations like this is do you have the latest version of the GPIO library? The newest one should be 0.5.4. The second problem may be that you're not setting a pull-up or a pull-down. In an electrical circuit with only a switch, when the switch is closed, you know what it is. However, when the switch is open there's no physical electrical connection and so technically the Pi could read anything on the GPIO pin. (What it actually reads is some weird combination of electro-magnetic radiation from your refrigerator and static electricity from you sweater, that sort of thing.) To prevent the "unknown" state, a pull-up or pull-down resistor is used. This way, when the switch is open, the resistor comes into play and the circuit is still defined. If the switch is connected to ground and the GPIO pin, you want a pull-up resistor. By default it "pulls the circuit up" by connecting the pin to +3.3 V, so that the pin reads 1 unless the switch is closed. The swtich has no resistance, so it short-circuits (in a good way!) the resistor and the pin now reads 0. The switch opens back up, the resistor comes back into play, and all is well reading 1 again. A pull-down resistor works the same, but exactly the opposite. It connects the pin to ground, so that the pin always reads 0. The switch then connects the pin to +3.3 V. When the switch is closed, the voltage short-circuits the ground connection and the pin reads 1. Etc. The resistors can be added in one of two ways. A physical resistor can be put in place, or the Pi has internal resistors that can be used. The GPIO library has support for this. For example: