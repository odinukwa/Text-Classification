nice! The code is generally rather good. I don’t have a lot to say about the language usage in the individual lines. The idea of using an abstract base to do different implementations selected at runtime is classic, easy to follow, and costs one indirection at calling time. Any run-time system to choose between different impls would have the same cost at least. I don’t understand the part about making a matching copy on the device. Why do you have on dummied on the controller? Can’t you just leave it out? Since its only use is to set from a lexical string literal, why not keep it as a ? The base class should take this as a constructor argument and the derived class supply it in the init line. one thing stuck out… and are called from the constructor and destructor respectively. But they are virtual functions. The object "is" of the type being constructed here, even if it is really of a derived class: it runs the base class ctors and then updates the vtable for the derived class and then runs the derived ctor body. So, don’t call virtual functions from the ctor/dtor. To do what this actually means, make it non-virtual. other Passing everywhere when values have different meanings is a good way to crash your spacecraft on Mars. Consider a zero-overhead unit labeling template, or at the very least typedefs for different meanings even though they are not checked by the compiler. should be the type name, not the variable name. But even better, just and the choice of degrees or whatever is made by the caller and it converts (perhaps at compile time!) to the unit that the type really holds. 

speed of Look at branch prediction. If an statement will go one way or the other at random (as when traversing a tree) the predictor will never get it right and you have a huge latency. 

The is an id of some kind assigned by the even manager on the object that you registered the callback on; you use this if you want to revoke the callback. 

Whenever you need to write an iterator, start out with Boost.Iterator. It has a and class that makes short (and accurate) work of it. If you never store the combinations at all, but compute them on the fly, what you really have is a Range Adaptor. If you have a function that maps input (index?) to outputs, it is quick work to use an existing library to do that. Calculating changes with ++ and −− rather than computing it from scratch is more difficult, and I think can be done with where you just supply increment and decrement functions. 

Hmm, I don’t see public , , , . So your list will not work with any of the reusable algorithms and other templates or the built-in range-for loop. Why not? 

※ In the past, I’ve implemented something like that handled and resolved them in order to invoke the function. With C++17 getting this done is easy, as shown here using a lambda and explicit capture initialization. 

I skipped in my first answer. I come back to it now. First, rather than knowing about the grade and letter members of the student class, it should be a separate function that the student class then can use. It is a function that takes a number as input and produces a letter grade as output. It doesn’t have anything else to do with the specifics of that class, so it should not know about anything else. The only thing it needs to know is passed as input. The result is returned. 

That might be how you are used to doing things in other languages, and it works as you expect for values. But that’s not the normal way to use the container. On the other hand, pre-allocating it like that makes it simpler to do without the hand-written loop: 

Instead, have a way to convert to polar regardless of what I start with: if already in polar, it’s easy! Internally, have two separate functions with different variables; your , , ⋯ , is just too muddled to deal with. Your comment “intermeditary variables used to stop math errors in the conversion” makes me think you just added them to fix a problem. Declaring all the variables you might need at the top of a function is bad. If you declared where needed, you see you only need half of those in each branch. And the function to do the converting should be (drum roll…) the constructor! 

In C++, the style is to put the modifier with the type, not the declared name. This has been true since Bjarne’s original book, where it is pointed out explicitly. 

Your and functions don’t check for zero length. You have a function, so the user could delete all of them! Speaking of , you seem to duplicate the code first. Just use ! 

You duplicate the same thing on each branch, and the other statement is just different assignments to the same thing. How about: 

No, this is not a visitor pattern. You are trying to do double dispatch. You are actually calling every time. There is nothing I see that will then do the second dispatch to the right derived class for the actual type of the parameter. What did your test program print?? 

or better yet, do the next line () first, so the names match up with the condition. Data model: It seems awkward that you have and a pointer both doing the same thing. has its own enum rather than pointing to the winning player or nullptr. Most of your code is in matching up different representations of the same internal meaning. Having two separately named variables for the players is making more work. Everywhere you need an statement to choose between them, or duplicated code. Always use an indexed collection instead of separate names. So make 

Now isn’t that better? And you didn’t even have to fix it when you changed the function parameters to be const references! 

Don’t do that. If you have a section of code repeated with only the variable changing, and they are numbered in consecutive order, you are crying out for a loop. In this case, since you are not doing anything with the string other than this action, just make it part of the subroutine. 

You take by value in all the functions. What if is a substantial type? You want to normally take it by const reference, except for functions that will create a , in which case treat it as a “sink” parameter. 

Don’t go through the collection by index. Look how many times you use in the block of code! Use the range- construct to iterate directly over the vector! 

Don’t write a member for this! Make a non-member that uses the general-use public abilities of the list to be traversed. 

By making a portability header for a specific feature, the code includes that file, which itself includes the correct choice. The names, wherever they came from, and placed in a namespace of my own. The code uses that. It is further packaged inside a uniquely named namespace, so code outside of this library can just pull in that group of related symbols easily. Any link-time dependency will be noted using the proper based on the compiler (that is not needed in the following attempt). I figure I’ll use a set of preprocessor symbols so the user can command the choices at compile time directly, overriding any auto-detection. In the file here, it is structured so the detection happens first. Then, in a second section, the choice is applied. The detection and implementation are independent and separated in the file. Now, how do you detect in the first place? If it involves a new header I could use , but updates to existing std headers don’t make that applicable. Using metaprogramming, I can detect specific names in . But, the results of that do not feed back to the preprocessor! There are detection macros defined, but these tell of the existence in and won’t be seen in the final home. From the form of the symbols (e.g. ), it is clear they apply to the experimental header only, and the TS doesn’t define other symbols to indicate presence in the once adopted. So the only solution is to check individual compiler, version, and platform versions and configuration options. I’ve populated the answer conservatively, letting it through only for compilers that have been tried. Others, even if filled in based on documentation, lead to a so they must be vetted when actually used on that platform. Any unknown configuration choice also gives an . Any other advice? Anything I missed?