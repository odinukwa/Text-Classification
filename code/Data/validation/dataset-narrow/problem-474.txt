And most likely more problems but as the code is so hard to use I have not looked any deeper into your algorithm. Conclusion. I would say "Try again." as it is not at all what I would expect from a function that solves quadratics. 

Using objects Ouch your code is a heading down a road to many problems. You need to organize the code into clear related object. Rather than a full review this is a suggestion example. See the code sample . Some info regarding sample. Code has settings together at too. Uses a canvas directly rather than a library. sets what you had as There are two object. hold all that is needed for a room. Where it is, if it has been add (open). Rooms that are on the edge (your pick rooms) are call candidates and a room will have a flag to indicate it is a candidate. creates and holds all rooms. It has 3 Arrays, one for all rooms, one for open rooms, and one for candidate rooms. When a room is added it is moved to he open array. All the rooms next to it that are not open and have not yet been put on the candidate list are flagged as candidates and added to the candidate array. After a room is added a random room is removed from the candidate array and opened. It is done what no more candidates are avalible or the open room count has been reach. Then it draws the rooms. This code is many times faster than using the tedious iteration searches as it does not waste time iterating over unrelated rooms. Also dist calc is done as the rooms are added. BTW for positive numbers floor them with logical OR zero (see code). ~~ is two operations so half the speed of a single operator. 

Recursion This particular problem can not be solved via recursion without proper tail calls because you can not know the max steps in advance. Memory Even with tail calls on you are still fighting JS because you are not being memory aware. In the function you create a new copy of the maze and then make the next jump via recursion. This means for each jump you create a complete copy of the maze and hold it in memory until the end. So if you have a maze with 1024 items and it takes 2048 jumps to complete you will have 2097152 unique items. This is very wasteful by any standard. You should release the previous maze before you make the next jump 

Naming Use a well defined naming convention, and use it consistently. Each language has a set of conventions that define how you create names for various things. In JavaScript we use lower camelCase for everything except objects that you create with the token, for which we use upper CamelCase Unfortunately JavaScript shares its environment with the DOM (HTML and CSS) and they have a completely different naming convention called BEM, which is incompatible with JS (you can not use BEM names in JS as they break syntax rules) Article regarding BEM and CSS Ideally you use the correct naming convention for the correct content and learn how to convert between them (when its automatic, when not automatic, and the exceptions) eg CSS becomes JS , element data attributes are automatically camelCased, ,any element attribute values (like ids) are not converted and may need to use indirect queries or bracket referencing.) You will note that these are conventions. Some (like me) opt to follow only one convention. JS camelCase, using it in the DOM and CSS for all names I define. This is not main stream. You have followed no apparent naming convention and that will make it very hard to know when and where to put capitals, '-' etc. You remember a variable by name, that for mere mortals does not include the naming format. Use class If you find your self setting class properties directly to elements you should give a moments time and consider if it is done better using a CSS rule. You do the following 

Even though it saves a lot of lines and typing, it's at the cost of performance and readability. Import each class individually. 

Since Java 7, there is such thing as a try-with-resources statement, which automatically closes the reader when an exception occurs, which you are not doing here. Your current code has memory leaks! With some other improvements: 

What??? confuses me. Might want to do some naming changes. I would simply remove in and use instead: 

Now let's do some actual reviewing... OOP Java is an Object Oriented Programming (OOP) language, which means it's based on objects. You did a good job trying, but if you leave a default constructor and let the calling code do the work, it's not OOP at all. Let's do some serious redesigning: 

This code seems to be a specific BucketSort made for a specific program. I would instead create a more generic BucketSort: 

It's really just performance. There's gotta be a better way to do this, but I can't think of a single way. 

EDIT: The above review, if not using Java 8, should be replaced by @EricStein's code. Also, is a bad name. Try . 

Your solution seems generally sound. I would make a few changes: You are surrounding your whole code in a try-catch block. Instead, surround the area where the has a chance of being thrown (Also, use to print for errors): 

This is the end brace of the previous method plus the new method. Again, a couple of things: Lines 1-2: Extra newline between Line 2: Should be separated into two lines: and declaration Line 2: Space before brace Line 3: Already mentioned, space before brace Line 6: Extra newline serves no purpose, but can be left there if wanted Result: 

At first glance, this makes no sense. These numbers are more like magic numbers: make them a constant: 

The assignment is not necessary because is already false. About recursion: It is possible. With it, here is the final code: 

Never import the full package. It is considered bad practice to do so. Instead, import what you need and only what you need. Instead of just reading a file then printing it, why don't you create a method that reads all line of a file and returns a list of all the lines? This way, you can do more with the result: 

Since I don't have a C# compiler (sorry), so I converted both programs into Java in order to test. First Code: Average speed: 80000- 90000 nanoseconds Review: 

The second line is only two-spaced. Make sure that your spacing is consistent through your code. Don't import the whole package: 

Some points: Formatting Your formatting is a bit hard to read. I have fixed it for you, but keep in mind of these standard Java Convention rules: 

And add your method in another class in another file called . That would look like (if you want to time it): 

Your solution seems to be the most efficient, except for the fact that it doesn't seem to work. You could try finding all possible groups like so: $$18=4^2+1^2+1^2$$ $$18=3^2+3^2$$ $$18=3^2+2^2+2^2+1^2$$ $$...$$ Then find the smallest group. Your code would sure like some space. After some nice, wide spacing: 

Again, consistency. Always put a space before the opening brace, or never. I recommend always, as that is more readable. 

I don't think creating a object is necessary. Instead, there is a method that returns a object, which stores all the necessary solution information. is now the overrided in . It seems slightly faster (2000 miliseconds -> 1500 miliseconds) 

The spread operator is a short cut way of turning a array like list into an array. Be wary as IE 11 is still popular and does not support many ES6 features. If you use things like the spread operator you should consider using babel.js so that your code can run on legacy browsers. 

Dont define what you do not use its just noise Why redefine window which remains in scope even when redefined. You pass it and then ignore it when you set the timer events so why pass it. It may have made a little more sense if you did rather than letting it default to the window object (not the one you passed) And , you don't use it, its not needed so why define it. Use quotes consistently preferably "" don't mix and match. You use single quotes for everything bar the progress bar class name. Though I can not work out why. Use in preference over if you don't plan on reassigning the variable. The only good variable names are and , 

Ahh so sweet, no overflow fitting in the one panel, all functions should be like that. And a more standard version if you are having trouble reading the above. 

Object assign via operator There is a sorter way to do the property order if you use the spread operator to assign properties. 

Some extra items that have not been raised and are so important. Declare vars Every variable must have a declaration. If you dont define the variable it is automatically defined and placed in the global scope. This becomes a major source of bugs, headaches, frustration and madness. 

Now you can add to the HTML as many episodes as you like, and don't need to change the code saving you a lot of time, and reducing the chance of bugs creeping in due to typos just because there has been a content change. 

The first call to executes the function immediately, this is not what setTimeout does. On the first pass should it not set a timeout rather than execute? Memory leaks? That would be up to the functions being called. Your timeout will eventually release any references that are held pending the timeout so you are not causing a leak. There could be memory problems (not a leak just running low) if there are a lot of timeouts and the delay between them is long, but not a real concern. Timing issues. You set the timeout after you call the function and do not account for the time spent running the function. The timeouts will always be late and any error in time will accumulate with each call by the amount of time the takes to execute (and any other page blocking events). The way to deal with this is to record the start time and adjust the timeout to be at the correct interval. That then introduces the issue of catching up to late calls. There are any number of ways the page can blocked making your calls is late. If late do you still make the call or skip it. If you make the call and the function you call is taking longer than the interval do you create a stack of pending calls? A quick rewrite As a suggestion only to demonstrate the use of closure to keep stats on the timeout and keeping track of the next scheduled time out, adjusting the time to keep things on time if possible (if more than half a interval behind the timeout is skipped) (though I did not test that) 

The last case is not required if it does nothing. If you really want to tell a reviewer/code-reader that it will do nothing, simply use a comment. It is also understandable, as only the and options should do anything, and the button should be completely ignored, as it is in many real-life applications. I cannot think of a single situation where a button will do anything... SwingOverviewView 

is not only a bad name, it is also hard to read and understand. Cramming too much information in names is bad. Sure, names like are bad, but so is . That's what class-level javadoc comments are for. As for readability, java class names are in PascalCase, and method and variable names in camelCase. I suggest , and you can add a short comment about the class at the beginning, like so: 

Now, why is the first line not necessary, and even discouraged? Well, because you should declare variable right where you need them, and not before: 

I am not sure if this is the formatting problem in copy and pasting from IDE or it was like this in the IDE in the first place. To correctly format your code here, you can copy and paste from your IDE, select all your code, and press or click the button at the top of the editing pane: 

Well, read on! Immutable classes should not have any methods. This is because an immutable class should only represent objects that don't change. If a person needs to be changed (not likely though), then the most obvious way to do so is to directly call the Constructor for a new Object, as a person with a different characteristic would not be the same person. 

Similar to , but and result in , and every other combination . What is happening is that the ASCII values are 'd and 'd. Is this really what you want? In this case, you have to do it the tedious way: test each of them to : 

For practice in Python OOP (first time) and for some relaxation from trying to learn Serialization in Java, I decided to write a LinkedList in Python. Now, this class would be pretty useless, because in Python, instead of: (Java) 

Yes, I know it looks 10x more complex than it need to be, but this can be used for further applications. Since you asked for an explanation of the array... The separator's array is there so that the method can know where to separate it into buckets. For example: 

I wouldn't create a new temporary map for each loop. Instead, I would create one outside the loop, and dump the contents of the temporary map into the map at the end: 

You have a constant, which is pretty much a . You use it to append. Instead of doing that, you can easily append the char itself, which saves a String creation. 

Don't reinvent the wheel, unless you were required to. Java has a method that you can use easily, e.g.: 

Though this program tells the truth (unless you change the source code), it does tell Fibonacci numbers, depending on the user's input. Keeping in mind of all (or most) of the feedback given from previous questions, I wrote this program to see how well I have progressed. 

This looks confusing to me. return the title, which is understandable, but returns the old title and sets the title to the argument. What? I would rename the first methods to and the other to . Also, consider adding . This is the same with: