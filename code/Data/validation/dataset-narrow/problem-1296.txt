You should take a look at quad trees. Its a common datastructure to store spatial data in cells. When you do the collision testing, you simply test against the objects in the same cell... I use the same datastructure for rendering. I pass the rect that defines the viewport into a selection method of the tree and receive a list of cells. Now i just have to render all sprites from those nodes... When the object spans over multiple cells ,you can add it to both cells. Just make sure to remove the duplicates ,when you use the results from the selection method. I'm currently on my phone, so I have no code examples here ,but a quick google for quadtree should help. 

The first two parameter define the window resolution, the third if slick should be opened in windowed or fullscreen mode (true for fullscreen mode). You should head to the slick2d wiki, as it has some beginner tutorials explaining such things. For example in this tutorial the basic things are explained step by step (also your question is answered there): Creating a Basic Game tutorial All tutorials: Slick2d Tutorials Index 

As the engine is pretty well known and documented by the community I think you can will be able to find a lot of detailed information about that type of map rendering in the GemRB community. 

Another solution often used to "hide" the game files is folder structure. Keep only your executables and maybe a readme in the main directory and move the game files into a sub folder "data". I don't think that it is very uncommon to do so. Many games I know store their content in such a way. 

From your example I can tell you're making a "connect the pipes" type game. You have two possible approaches here: 

TL;DR: In order to do what you want to do, you should be using the Boussinesq Approximation, which does not assume a flat seafloor surface. This is a very interesting question by the way, I don't see many people try proper water simulation often. 

In a nutshell, what makes a shallow water equation a shallow water equation is that the water height is not zero and it assumes no variation in the seafloor. Note: No fluid dynamics equation will allow for a water depth of 0, as that would mean you have no fluid. You should read the Wikipedia article on the shallow water equation. Basically, in shallow water, the vertical velocity is ignored because the value is so small and has minor impact to the wave propagation. To quote the section in case of modification of the source page: 

One thing to think about here is that you are updating the entire mesh UV state for each tile you modify. I'd be sure to check and make sure it's not refreshing the mesh after each tile. you might return the UV updated array one level up and marge them all at once. Basically restructure so you calculate all, then apply the changes to the chunk/mesh. I also notice you're searching for the chunk index once for every tile you update. Do this outside of the tile loop, and pass the result to the SetTile() so you only do this search once per chunk instead of once per tile. 

That is a very nice question! I have been thinking about the same thing lately. I don't know how are you doing your development. But you always need beta testers. If you don't have any. I would start there. Beta testers could give you great hints about your game. What is wrong / what is right / what should be changed. Beta testers are players as we all are. They know what entertains them. They will help you make the game better. In my opinion it is far better then releasing the game as ClassicThunder mentioned. If you released the game as a demo. You could get very bad ratings and it would ruin your game awareness. Just because you want to test if public likes it. If you have beta testers and / or you feel very confident about your game. You might want to release a preview of your game to Youtube and then post it to Reddit and such. It will take some time, but you will see just from the comments if the game is looking good or bad for potential customers. This is again to avoid bad ratings. Then you might want to release a demo. But I would not recommend it. 

Well I would say it depend on the platform you are using and what exactly you are trying to accomplish. Because every software you mentioned does something different. For example Daz studio is more about posing and making animations, scenes and not about modeling itself. So is Poser. Maya, K-3d and Blender are about modeling. I think you don't want answer like this but I would say the best choice is the one you like working with the most. Some people prefer Maya over Blender, some people prefer 3DS Max over Maya, its about preferences and how does the software suite you. People like to combine modeling software with Zbrush to add texture to their creations. If money is not an issue. I would go with Maya and Zbrush, but my preferences might differ. 

The second option will be better for you in the long run, as it means less work for you to design new levels. Do a little research for finding paths in an array between two points. It's an old problem with many solutions. The most optimal solution, if my memory serves me, is the A* (A-star) algorithm. 

You can hard code each level, testing the map array for a specific total state, making sure that A2, A3, and A4 are all orange. You can program a pathing algorithm to test if there is a path between the two colors. 

There's a trick to this: Selecting Areas: As you move the mouse, the only tiles you need to check for new impassable tiles are the newly highlighted tiles. If the mouse is dragged from X=25 to X=26, then you only need to iterate over the tiles at the X=26 column from the Y of the starting tile to the Y of the tile the mouse is over. The worst case scenario is you cross both X and Y axis, in which case you will only iterate over L+W-1 tiles. Deselecting Areas: The catch is if the player selects a large valid area, crosses an invalid tile, then backs off of it to go back to the large valid area he had a moment before. To keep from having to check the entire space when your area shrinks, keep track of how many impassable tiles were crossed as you cross them. Then when bounds change, subtract the number of impassables that were in the column or row that was deselected. As soon as your impassable count is 0, you no longer need to check so long as the selected area is shrinking. This still ensures you never iterate over more than L+W-1 tiles at any time. Highlighting: While Selecting areas, as you iterate over, spawn a red rectangle at the location of the impassable tile you are currently looking at. Store them in a 2D array for when you need to remove them. You could do some magic and scale a single rectangle for contiguous blocks of impassables with a little thought. While Deselecting areas, iterate over the column or row in the 2D array mentioned above and remove any object found in the row or column. this will be fast, as you know the column or row you're looking at, and since most will be empty, they will more or less be skipped. 

And we could also switch one of the sand tiles and the grass tile on the right to different terrain types, it would still produce correct results. 

The commandos titles look like they use prerendered backgrounds. This means that one or multiple artists design the whole wort in a 2d or 3d programm. Commandos looks like it was done in 3d and then post processed in like photoshop. The exporter of the 3d programm used a special export method, as the viewing perspective is not physically correct. Objects more to the north should be smaller, but the size doesn't change correctly according to the perspective. If I'm not mistaken this mode is called "Orthogonal Mode". Parts of the generated map are splitted into different groups. There are some graphics, that only are used as ground texture (this may be the biggest part of the exported map), there are parts that are animated or can change (a door for example can have an opened and a closed state) and there are graphics, that sometimes are drawn behind the soldiers and sometimes in front, depending on the standing position. The Baldurs Gate and Icewind Dale series used the infinity engine, which uses a similar rendering style (the setting may be fantasy, but the graphics always looked kind of realistic to me, just like commandos). There has been a strong modding community around the infinity engine and a quick look to wikipedia revealed to me, that there is an open source clone / implementation of the engine in the works. 

Define your viewport (position and size of the viewport). If you have this, you can define your borders. When your viewport position defines the upper left corner of your screen its pretty easy to restrict the screen position. First of all you set the screen position to be centered on the player: 

One thing I would be careful about is using the correct input callback. I would suggest one of two things, read the API's on the input methods available, and choose the one appropriate to your desired behavior. Some callbacks only fire if the key is held down, and others fire on a tap. Secondly, your architecture should change a little bit. The callback should only set the Target transformation. When you click on a pot, copy the transform from the pot to the target of the move script. The move script should be changed to automatically strive to achieve it's current target transformation until it reaches it, at which point it will wait until it receives a new target. This is best done by having your movement code in the Update() method within the script. For a small game, this will achieve your goal, and not cause much overhead. (Bigger games with many moving entities need to approach the problem a little differently) These changes will mean when you click a pot, the target will be set, and on each frame the movement script will adjust the chef's position if it doesn't match the target. The beauty is that you can reuse the "moveto" script for any other objects, with either a fixed, random, or controlled target transformation to add a little extra to your game. (a rat, or an assistant for instance) 

I think the issue is that the input is being polled every frame as part of the Update(). I would suggest pulling the input from the Update() and using input callbacks instead. That way the input is only polled when fired, and not every frame. That should cause the direction to only update with input changes, and the Update() will continue to render the same direction until the value is changed the next time the callback fires. Unity doesn't have callbacks, I forgot that I emulate them. This is going to take some more thought on my part. I will update soon. If your game is a top down on an 8 point compass this gets a lot easier, but I'm trying to come up with a generalized solution. 

I would say it depend on what kind of feeling you would like to achieve. If you would like to have some creepy game you will have differente palette (gray/dark colors), then for game some casual "happy" game. I think the link Sullivan provided is good, if you need Gameboy like palette. I can't give you exact colors, nobody can. BUT if you are looking for an inspiration I would recommend $URL$ Be aware, colors presented at kuler.adobe.com are usually for web designers. But they might give you some idea. 

I am currently studying at University of technology in Brno (Czech Republic). This semester is almost over and I might say I have some knowledge of C. Since I went to this school just for the purpose to become a game programmer I would like to start programming a game asap. My school project are almost done so I have been thinking about writing something already (story driven game running in terminal ^^). But this won't satisfy me. My question is how should I proceed next? I did my homework and went trough similar questions but I didn't get the answer. I hope this question won't be closed. People are usually mentioning C++, C#, OpenGL and others and I simply don't know which one to choose. I am currently interested only in 2D games and that won't change for some time. I don't want my game to run on a mobile device yet and I want to make games for PC and Mac, not for consoles obviously. Which language does fit my needs the best? 

In the first grid you see the terrain configuration. W stands for water, S for sand and G for grass. The second grid shows, how the blend tiles are applied. Like I mentioned earlier, the width and height of the blend tiles is the half of the terrain tiles. Here now the first render action happens. The lowest terrain type is water, so we fill all the cells (and all adjacent cells) with the water tiles. So allthough the water tiles only fill the first column of our definition, we have also to fill the second column. Now we draw the next layer, but we only draw the tiles, that won't be blended. Water is a lower terrain then sand, so we do not need to expand to that side. But because the grass is higher, we have to fill the adjacent tiles with sand, where the grass blend will be rendered over. Now based on some patterns, we render the blending parts of the sand. (Now you see, why we need to also fill the adjacent tiles). Here we have repeated steps 4 and 5 (allthough step 4 wouldn't produce any output, as all grass tiles in this examples will contain a blend). 

I think I stumbled upon this link here on gamedev and I really found it enlighting. $URL$ It explains some basic methods of implementing tile based levels, but there are also some important parts about how certain mechanics work in 2d platformers. I think you should look into slopes, as they can solve many problems you come across in platformers. Good to know is, that most platformers don't even bother with implementing proper physics, but implement certain rules, that mimic some physical behavior (like gravity), but allow certain behaviors that wouldn't be allowed with proper physics (air control for example).