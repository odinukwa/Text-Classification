I want to deploy a RPi 3 in quasi-headless mode, i.e. no display attached, with an application running that takes time-lapse photos (with the standard camera module). Power is supplied through a battery pack, so I want to minimise energy consumption. I have installed regular Raspbian, i.e. with XFCE, and I would like to avoid having to re-install a headless Jessie lite just for this application. (As I might use some API, I'm not even sure that I can technically run in headless) I read this article, and one thing that seems recommended is to turn off HDMI. I also suppose that not starting the X Server but remaining in text mode might save energy. So my idea is that I temporarily disable the HDMI output, and I temporarily might also be able to avoid booting into XFCE. I take it that I should connect the Pi via SSH and perform these steps. Which are the steps necessary to deactivate HDMI and stop before the X Windows login, and which are the steps to revert to previous behaviour ("desktop computer")? Any additional things I should disable (e.g. on-board audio)? 

I'm just copying a bunch of files from a RaspPi 3 to my laptop using over an Ethernet connection. The speed is abysmal, around 0.5 to 0.6 MB/sec. Is this normal? I read somewhere that with 10/100 Ethernet you should get something like 12 MB/sec. Is the micro-SD card the bottle-neck here? 

I found a similar question/answer over at unix.stackexchange.com. Basically the bottle-neck is the encryption, and the two solutions are either to use a 'cheap' cipher or a different program for copying such as . 

I want to write a software that runs on the JVM (in Scala but you can think Java). I am looking for the simplest way to capture images from the standard camera module (v2). I find the quite clunky, slow, somewhat unpredictable with respect to exact exposure times, glitches etc., and I would like to avoid writing files (I process a batch of images in memory before writing out averaged pictures), so if there is a direct API I would prefer it. For example, here is a tutorial on getting the Java bindings for OpenCV to work with the RaspPi camera. Are there better or more simple options (also considering the build time and disk space required for OpenCV)? 

You can attach a very cheap USB "stick-shaped" sound card, e.g. I have something like this (although it was Goobay branded, but I think they have all the same chips). They are class compliant so work out of the box. If you run a professional computer music software to capture the microphone signal, e.g. SuperCollider or Pure Data, you may also want to install QJackCtl as a simple interface in wiring up the sound app and the card. 

But nothing happens when I reboot the Pi, the program does not get started. I will also want to have a terminal window if possible. 

Edit: Here is the ffmpeg document that lists the "profiles" that one could enforce. Is there any statement which profiles omxplayer does not support (apparently high444 is one)? 

I am looking for the possibility to produce a two channel video output with a Raspberry Pi 3. That is, a device that splits the HDMI signal, ideally coming from full HD resolution, into two output signals of half width, e.g. 960 x 1080 or 960 x whatever. This can be VGA no problem. To repeat, I produce one regular video output signal, the image is composed of two halves, left and right, and I want the left to go to one monitor and the right to go to another monitor. So I see there are machines like the Matrox DualHead2Go, but that box has DisplayPort input and says it requires a Windows box. It also says it appears as a 3840 x 1200 device which probably is not supported on the Pi, and I would need a lower resolution. Has anyone experience with scenario, is there any machine (as cheap as possible) that can perform such a task and works fine with Raspbian and the Pi? 

Edit: I looked again at this video, and some comments go in similar direction. My theory now is that the board feeds 5V actively back into the GPIO's 3.3V supply. This is probably bad, but that was the only way I got the relays switching, and didn't notice any problems so far, it also seems to be what the guy in the video is doing. I'm in a very stressful situation, so any help getting this "fixed" with minimum effort would be appreciated (i.e. I have no time or resources to add regulator chips or whatever). 

I am having trouble with a Pi 3B connected to a 16-channel relay board (something like this: $URL$ The problem is this -- there seems a weird power interaction between the board and the Pi. The board has pins for the 16 inputs along with 5V and GND; it also has a separate 12V DC input which is required for the relays. I connect the pins to the GPIO of the Pi model 3B. I have to use 3.3V instead of 5V because otherwise the GPIO pins changing between lo and hi is not detected by the board. But this seems to work fine, and other people have suggested that it's ok to use 3.3V here. Now, I noticed a strange thing, that is when I remove the Pi's standard 5V power supply, the unit is still somewhat powered, apparently through the relay board. The real problem however is that the Pi sometimes, and I don't know what triggers this, shuts down part of its peripherial controllers, namely the USB and the Ethernet (HDMI is not affected). At first I thought this was solved by powering the Pi first, followed by the 12V of the relay board. But now I had a situation where USB and Ethernet shut down after a random period running the system (around half an hour I think, I only noticed by coincidence). I also have to say that I have stacked 9 Pis and 9 relay boards on top of each other, without using closing cases, so I think ventilation and temperature are ok. I am looking for any hints as to what is causing this -- is it harmful? can I recover without taking down the Pi and repowering it? Can I fix this somehow? Is there some message logs I should be looking at (can only do this after cold reboot, because I have no network and keyboard after the shut down). Below is a "schematic" and an older photo that has only two Pis set up so far. 

It will activate the window of gqrx and synthetically hit ctrl+d, starting the dsp. On the Pi (Pi 3, Raspbian Jessie), this does activate the window, but the key press is not registered, at least the application doesn't react. I also tried keydown, keyup, windowfocus. 

I can confirm that the problem disappeared after inserting those Logical Level Converters. I used two 8-channel converters, each with 3.3V, 5V, and GND attached to the GPIO, and the relayboard only having GND and the input pins attached, no need to connect its 5V "inputs" (which I think are reference outputs). The boards I used look similar to this: 

In my understanding, the Pi 3B can be configured to use 14 GPIO pins as low/high outputs to turn on and off relay channels; so people suggest extension boards and things to drive all 16 channels of 16-channels relay boards. However, in my case I only need to switch 10 channels of a 16 channels board. Do I assume correctly that I do not take any additional steps to get this working, just the relay board and a standard Pi 3B (and external 12V if I go for a 12V board). I just configure 10 pins as outputs, and that's it. Correct? 

The laptop runs Debian Jessie. I have set up Ethernet with manual IP to talk to the Pi. Wifi connects via DHCP to my local router and Internet. When Ethernet is unplugged, all is fine, I can browse the Internet through the Wifi. Now when I connect the Ethernet, somehow the Wifi is "overriden", i.e. the system (e.g. browser) only seems to try to connect to the Internet through the Ethernet and doesn't care about the Wifi. Can I keep browsing the Internet from the laptop with the Wifi while talking to the Pi on Ethernet? Note: I'm not interested in connecting the Pi to the Internet, I simply want to avoid that I cannot browse while connected to the Pi. 

I have packaged my app now with a shell script that runs the java command. Then I have a file like this: 

I have a Pi 3B that until today was working fine on the local network, it has a fixed IP address, e.g. 192.168.0.25, and I can ping it, and I can ssh from that Pi to any other device on the network. But ssh the opposite way is not working any longer, nor is UDP which I use for OSC communication. I have several identically configured Pis, they all behave well. That particular machine was working fine all the time, and I didn't change anything to the configuration. What could cause this? works fine, but simply says 

I need to process some mp4 videos on the JVM, so I understand I need something that calls into OpenMAX for performance reasons. I read somewhere that the JogAmp or perhaps the JOGL sub-project provide such bindings. I found some references on the Internet that suggested that there by something like a 'GLMediaPlayer' and a demo 'MovieCube' showcasing this, but I cannot locate any further information or source code. There is some broken applet without references to source code: $URL$ So the question is: How do I efficiently decode the frames of an mp4/h264 video on the JVM on the Raspberry Pi with performance ok for the Raspberry Pi? I know omxplayer, but I need to do further processing such as triggering specific sequences in time, applying fade-in/fade-out etc. So I need an API I can call from Java or Scala. 

and Open Sound Control messages via UDP simply don't arrive any longer. says ssh daemon is active and listening on port 22 (0.0.0.0). ifconfig confirms the IP address is set as I thought. I have no idea what's wrong now. My only idea now is to duplicate the SD image from one of the other Pis. But sure there must be an explanation. 

I'm developing an application that runs and controls the omxplayer. I very much prefer to develop on my desktop machine, though. So I wonder if it is possible to install omxplayer for a regular desktop Debian (i386)? Are there any builds (I'm on Jessie). 

The question linked to in the comment by @sir_ian provided the answer, linking in turn to this excellent blog: $URL$ - I followed all the steps described there, determining information with and then using . 

I'm trying to duplicate a complete image with Raspbian and a custom video installation software multiple times; I bought eight identical Micro SD cards (SanDisk 32 GB). I made a master image, I copied it using . Now I'm trying to write that image to the other seven cards. I'm using Disk Image Writer on Gnome to do so. This went fine for the first six cards, but somehow the seventh is rejected, saying its capacity is too small (700 MB or so are missing). That one had been formatted before, so my hope is this is just a bug in the image writer. Because technically the cards should be 100% the same size. What can I do? Can I force to write the image nevertheless? (The actual data only occupies like 2/3 of the 32 GB). Can I "shrink" the existing by throwing away some of the blank space? Can I reformat the card with a trick to look like a brand new one?