The i5 is not properly indented. Since the code brackets all and the i5 loop should also be bracketed as shown above. Declare the Variables as Needed The control variables can be declared in the beginning of the for loop as shown for , and . The variable is properly declared outside the since it is used in statements following the . It's easier to read initiations when they are on separate lines as shown above. 

There are two programming principles that might aid you in your future programming, they are the Don't Repeat Yourself Principle and the Single Responsibility Principle. Following these principles generally make is easier to create good code, reduce the amount of code written and reduce the complexity of the code. Don't Repeat Yourself In software engineering, don't repeat yourself (DRY) is a principle of software development aimed at reducing repetition of software patterns, replacing them with abstractions; and several copies of the same data, using data normalization to avoid redundancy. Generally when there is repeating code in a software module it indicates that a function should be written to contain that code or a loop should be written to perform the repetition. When code repeats in different functions it becomes a maintenance problem. Someone can fix the code in one location and miss it in another location. The solution to this is to write a function for the code that repeats. Reduce Complexity, Follow SRP The Single Responsibility Principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. 

First, @Kerndog73 did an execellent review and mostly I will try to address things he didn't. You mention that perhaps you should have used functions, you are correct. Generally the main program is used to control the rest of the program. The main program should call functions that parse the commandline, functions that set up for the rest of the program, functions that perform the main logic of the program and functions that clean up whatever needs to be cleaned up. Common Macros The code already includes stdlib.h. The include file contains two macros that are widely used, and . The code might be more readable of these two macros were used. It is possible that the values of EXIT_SUCCESS and EXIT_FAILURE may change from architecture to architecture but the macros are defined on every system. 

Use Descriptive Variable Names @D.Jurcau point about variable and function names is correct. The function has a fairly meaningful name, it is filling a matrix. The function isn't clear at all. The code should always be as self documenting as possible. This means that the variable and function names should be as descriptive as possible. If you or someone needs to come back and modify the code in 2 or 3 years the code needs to be instantly understandable. Variable names like , , and can be used in for loops, but it would make more sense to name them so that the algorithm is clear. DRY Code DRY stands for . This is another item where D.Jurcau is correct. One of the ways to correct this is to put code into functions, another would be to use loops, which is already done. Reducing repetition makes the code easier to write, debug, and maintain. Use the standard library and container classes whenever possible to reduce code. Use the Single Responsibility Principal When designing functions and objects (classes and structs) reduce the complexity of the functions by dividing large complex functions into smaller functions. This is called the Single Responsibility Principal. Both the function and are too complex. Each of the loops in the function should probably be separate functions. It is also unclear what each loop is doing in the function. Having each loop be a function would better document what each loop is doing. The purpose of the function is to set up the environment to run the program, execute the program and catch any exceptions, all other code such as input, output and actual execution should be in other functions. The actual logic for running the program should be in another function. Additional Topics to Research Knowing good programming principals is a good thing, additional things to research would be SOLID and KISS. 

I thing that's a little more unique, possibly better. MAGIC NUMBERS: You still have a lot of magic numbers in your code: 

is unnecessary. Move the new line printf outside the inner loop and it will execute when the inner loop ends. Algorithm The algorithm doesn't seem to be using the diagonals which means there are 4 additional spots a character might go to. It's not clear that the program works completely when I ran the program it went up to and then quit so the grid was mostly . Variable and Symbolic Constant Names There are some pretty good names such as open_spaces, examined_spaces, placed, grid, TRUE, FALSE, START, END and then there are names such as N, i, j, next_j and next_i. In particular i and j seem to indicate directions so horizontal and vertical might be better names. N might be better called GRID_SIZE. There also seems to be a missing symbolic constant for (OPEN_SPACES_SIZE). Functions Just because you haven't read the chapter on functions doesn't mean you shouldn't use them if you are accustomed to writing code using functions. It definitely would help the code. 

While this is primarily targeted at classes in object oriented languages it applies to functions and subroutines in procedural languages like C as well. There is a design methodology for procedural languages called Top Down Design. This concept is basically that the task of the program should be broken up into smaller and smaller pieces until it is very easy to implement each sub-task. Each atomic sub-task should be a function. A second reference can be found here. By break code into atomic functions the code become much more readable and bugs are much easier to find if they exist. Another reason to break up code into small atomic functions is to reduce the scope of the variables. If the function in server.c had been broken up into smaller functions the bug mentioned above might have been caught earlier. It also might have been easier to write and debug this program. The function in almost all programs should be a control mechanism but not the actual implementation. The main should function should make sure the program is set up properly, call the main implementation function and call any clean up functions before exiting, but that's really all main should do. The main functions in both server.c and client.c can be broken up into multiple functions. Sub-functions that might help the function in server.c: 

Not only does it make the function shorter, but indexing into the array is faster than the switch statement. @MegaTom is correct, this code would be better using enums or named constants. The string compares are much less efficient that integer compares. Multiple Statements on a Line To make future modifications easier, there should never be multiple statements on a single line. Let's say some code needed to be added to each case in the switch statement. Each of the cases in the switch statement would then be need to be broken into multiple lines which makes the edit more complex, and can create typos during the edit. It is much easier to just add another statement by adding a single line, rather than trying to add it to a single line. 

Check ALL Possible Errors The function read_certificate_file() should make sure char *file_location is not empty before using it. Never depend on input being the proper value. This function May Not Work for Binary Files As forsvarir points out fseek() and ftell() may not give the results expected in all cases. See this reference. 

Reduce Complexity, Follow SRP In both this question and the Binary Search Tree in C++ struct definitions have been embedded within the class definitions. This goes against good object oriented programming principles, specifically the Single Responsibility Principle. One of the basics of object oriented programing is to be able to reuse objects in multiple programs. Each object should be defined separately so that one builds up a library of objects/files that can be reused. In C++ a struct is a class where all members are public, since they are classes they should be defined on their own. In this program it would be better if there be three header files and possibly two source files, one for Graph and one for Vertex. Vertex may not need a C++ source file since it is fairly simple. The color class also deserves it's own header file. In the Binary Search Tree question Node should be defined separately from BinaryTree. You might also want to look into SOLID programming principles (the is the Single Responsibility Principle). The Single Responsibility Principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. 

Please note that the case should probably have a statement as well, especially if is embedded within another control statement such as a loop. Readability and Maintainability Making the code more readable makes it more maintainable by you or anyone else that needs to add functionality. The code would be much more readable if it was consistently indented as I show above in the included section of the code. Blocks of code within and should be indented. Operators in control statements such as loops, loops and if statement should be separated by spaces. Use vertical spacing to make the code easier to read as well. In C++ and more modern languages it is more common to create variables as you need them. I would change the above code to 

You did well with the #ifndef #endif guard banding, and the indentation is nice. Initialize Variables The empty constructor is not initializing parent, my compiler gives me an error on this code. 

A few observations to help out: Bug in Pop In a LIFO structure the value to be returned is not . LIFO structures are definitely different from FIFO structures. The Code is Not Portable Right now the code will only compile on Windows because of the use of . It might be better to just use standard C io, in this case probably . It might also be better if was only included where it was needed rather than in utilit/ssbl_stack.h. Struct Name May be Incorrect It might be better to rename to , an unsigned long is not guaranteed to be 32 bits, it may be 64 bits depending on the architecture and compiler used. Prefer Calloc() Over Malloc() in This Particular Instance Calloc by default zeros out the memory it allocates, so rather than calling malloc() and then using memset() to set the entire array to zero, call calloc() and the entire struct is already zero'd for your. LILO Versus FIFO @vnp is correct in his comment. Is there really a difference between these two, as far as I can tell the both equate to FIFO? The same question applys to FILO and LIFO, in each case it evaluates to First In Last Out? Typical computer science terminology refers to stacks as LIFO and queues as FIFO, the two alternate forms could confuse people using the structures as a library. Incorrect Order of Execution of Create Functions If the code continues to use rather than the call to should clear the entire struct and occur immediately after the malloc rather than at the end. This would change the existing code from: 

Constant Values The value for MYHEAPSIZE is 2000000, however the comment indicates this is 2MB, and it's not. The difference is important when writing this kind of code. Two Mega Bytes can be expressed as 2097152 in base 10, 0x200000 in hex or 1 << 21. 

Error Handling The function returns allocated memory. The pointer is never checked to see if it has value before it is used. Witin the function there are 2 calls to . The function returns NULL when fails, but the return value is never tested. There are a number of ways to handle issues like this, in a program such as this one it would be best to report the error and quite the program. Some changes I would reccommend for main.c are: 

Generally I would expect a command line parser to set variables that are used by the program to configure the way it works. If the command line parser is used by programs such as , and other programs that are primarily run from the command line I would expect them to report errors to . Graphic tools might report errors to the console, they . The use of should be avoided in most cases, it will prevent a program from cleaning up after itself. When an error occurs it might be better to use setjmp() in main() and longjmp() where the error occurs. More General Declarations The code 

Performance First, the best way to optimize C++ code is to compile it -O3. Then profile the code to find out where the bottlenecks are. In the bad old days when inline functions needed to be explicitly declared, incrementing a pointer through an array would have been a good way to speed up the code, iterators are preferred over pointers now. Using iterators would mean changing from the C style integer arrays currently used to the C++ container type std::array. After utilizing iterators you can then look at the STL algorithms and see if any can help. All of the STL algorithms have been optimized as much as possible to make the STL library perform as well as it can. It might be good to think about data heuristics in . Rather than starting with 9 and working down to 1 it might be better to find the most common number and solve that first. After that solve for the next most populated number. For example, the hard Sudoku has three 4s, two 1s, two 2s, two 7s and two 8s, try solving for 4 first. Try solving the 3 x 3 square that is most populated first. Algorithms will supply faster solutions that optimizing the code. Add Test Cases It might be good to get multiple hard puzzles, get all the times and average them. Maybe have 3 loops of tests that have averages. An average for easy puzzles, and average for medium puzzles and an average for hard puzzles. Remove Unused Code The functions and are unused. It might have been better to remove these functions prior to the code review. Unused code can confuse anyone that needs to maintain the code or review the code. The function is using pointers. The use of C style pointers is discouraged in modern C++. Style Improvements It might be better to have one declaration and initialization per statement, someone that needs to modify the code might miss part of this line in the function : 

Global Variables The code contains the variables and declared as global variables. Global variables are generally frowned upon. 1. As programs get more complex they are created in multiple files, global variables are very difficult to find when used in multiple files. 2. Using global variables makes it harder to maintain the code. 3. Using global variables makes it harder to debug any problems. 4. Using global variables may prevent adding external libraries. Variable Initialization in Constructors In both of the classes the variables are initialized within the body of the constructor. The more accepted way to do this is this way: 

For the following keep in mind that is a compile time expression for the following cases. The following suggestions might make the code more portable between different devices. It might be better to express ALIGN as sizeof(long long) rather than putting that in the comment