The one defined at or the one defined just before the ? The quick-fix is to rename one of the variables, however another thing I ask myself when I'm about to copy-paste is if there are variables I'd have to hunt down and rename like that. If so the code is better off typed from scratch, plus you get to think about your logic a bit more as you type it out. Indexing The difference between and is significant, but the data in that gap is not. Also, going past will give an index-out-of-bounds/read-access error on , so: 

This works because is already scoped to so every member function already has access to . Then there's the bonus of not having to make a copy of the array pointer each time, which speeds up your code a bit. Variable Names More of an aesthetic point than a functional one, but would be easier for user's of your to understand if it were or the like. Two reasons for this: 1) The name is typically used as for template parameter types, and 2) itself doesn't really express what the variable is used for. This means well named variables add the benefit of making your code self-documenting. Storage Space Only one decimal place precision is checked for in , so a is more storage space than is necessary. would work just as well and saves some memory (on most machines). Memory Management Your code s the block of memory it intends to use for after its been assigned to , namely: 

This heap will be used for A* search pathfinding in my 2D isometric game engine. It uses lambda functions (instead of or ) to allow me to dictate min-heap or max-heap more dynamically. It also uses lambda functions for , , and so that the search key can differ from the compare key (for example: sorting by priority, but searching by name). Typical use: 

The first parameter indicates the starting address of the memory block you want to assign values to. The second parameter indicates the value each byte of the memory block will be filled with. The third parameter indicates the number of bytes forward of the starting address to affect. For example, if then all your s will be thanks to twos-complement. Beyond there are functions that allow values longer than one byte to be assigned to each index of an array, as other answers have mentioned. Copy-Pasta Bugs Copy-paste is a useful tool for repeated segments of code. However, I always ask myself if the code I'm about to copy-paste would be better off in its own function. One of the goals of writing efficient code is to reduce the amount of repeated code. The copy operation in : 

This prevents the indexing from going beyond automatically (no bounds checking required). The downside is it will cause more collisions on average compared to , but its something to think about given that you're already handling collisions. 

Performance Bitwise operators are significantly more efficient compared to modulo and other binary/unary operations. For example, since is -scoped a second variable could be declared as part of . So when a is constructed, and after in just set 

Problem definition it is not clearly defined whether shall result in. your implementation suggests as desired result. other possibilites include 

If you want to design a class you have to remove the from it. then you notice there is a little problem with the which forces you to expose internal implementation details to the main loop by requiring a call to as well. by the way does the job correctly, one input resulting in one call to the board. ensure functions/methods do what the name promises does not rotate the board, but a matrix only. it would make a perfect name for a method of a matrix class. a board method should do the complete job and apply the gravity as well. reuse what you have you could insert tokens on the top only and use to let it fall down. not only this resembles physics, but also there is less code to test. shows high complexity and repeated code. handle errors your does detect an error if a column is full. however it does not forward this to the loop, so the player is turned over. separate I/O from core do not do I/O from core functions, but from main loop only. this requires providing state and error information to the loop by return values or raising exceptions. or by providing getters for state. this will immediately lead to better design and testable functions. there shall be no magic numbers in the code, define constants when you decide to go for a 9x9 instead of a 7x7 board, there shall be only two edits. you make it worse by having those numbers as attributes, but you do use them only for drawing. when checking for wins, applying gravity or handling input you have raw numbers in the code. this is the worst possible combination, pretend to handle your constants properly in the but ignoring these later on. seriously, this is an absolute fail. also have a definition for and write correct expressions for all the dependent values subtracting it from or . some python sugar 

I think you got the optional part wrong. the task is to reduce the given square, not to construct one from scratch. This requires you to hold the square in a representation allowing you to shuffle columns and rows. a set does not keep the order, i suggest a simple list of lists. the challenge requires sorting the first row and the first column, very similar tasks that can be done by the same sorting function if we transpose the matrix. so i suggest to start with a list of rows 

You already got some advice on coding style. however there is a big flaw in your algorithm which is not addressed by the accepted answer. you try to iterate downward to get an effective implementation but you got the inner loop wrong. while you expect the outer loop to do few iterations your inner loop does check relatively low numbers early. you tried to limit that by stopping the iteration at 900, a magic value without reasoning. so your implementation may give wrong results as a pair of 901*901 is much smaller than a lot of untested pairs. you need at least a check if your product is bigger than the biggest untested one 999*900. on the other hand if we do the inner loop right all problems are gone. we use the outer loop for the lower value and the inner loop for the greater one. we do not need an arbitrary limit any more and we are quite efficient. 

The brackets are redundant in , and also in . You say "The 65 comes from the CHARACTER_SET length, which I have found out before". Well then make it clear! Ideally your code should be self explanatory. So instead of using , use . is redundant: is already a String... Strings in Java are immutable, so prepopulating the string with spaces is a waste of time because that string will be discarded anyway. 

The method should probably be called . I don't think your helps very much in terms of clarity - I would keep it simple and leave the logic in the main loop. You could also use the loop fully and put your condition on the number of divisors as the condition of the loop instead of breaking. The main method could look like this (and no more need for the method): 

What your code seems to be doing is to add spaces at the end of a string to make it at least long. You could write it in a way that better expresses your intent: 

Synchronizing within the constructor makes little sense - your object can only be constructed in one thread. Your fields and one method are , meaning that one could extend the class and modify the map outside of a synchronized block (for example), breaking your synchronisation contract - this is possibly undesirable. It may be useful to (re-)read Effective Java #17: Design and document for inheritance or else prohibit it. 

A good improvement would be to store each tweet as a object instead of using Strings only. It could look like: 

Regarding your question about efficiency - a more efficient way (less time to code and fewer lines of code) would be to use existing libraries. With Java 8, you could use the java.time API: 

Your naming is funny and all but quite counter-productive - names primary goal is to explain what the code does, not to give a lol moment (I know, boring). 

Once you have done that, you can start optimising the method, for example by caching the results as you calculate them. 

Your benchmarks look fine. Instead of using the BlackHole you could probably have simply returned the number of sentences although that would have created an (unlikely) window for optimisations and using the BlackHole is safer. 

Your method is not very efficient because you create a lot of objects. Everytime you write you create a new String. The proper way to concatenate characters into a String is to either use a or create a , populate each char and create a String from the with . 

which is more compact (7 vs 18 lines) and I think also clearer (fewer lines of code to read => fewer lines to understand). 

You are picking the characters randomly - so whatever the order should not have any impact on the randomness of the password. 

There is no need to add to your methods signature - this is an unchecked exception. You should mention any exceptions (checked and unchecked) in the javadoc though. You abuse asserts - they are supposed to check things that can't happen, not to validate external arguments. You should replace them with more standard idioms, such as: 

the first definitely do not belong there, this shall be done in main or in a UI. for the latter if no user interaction is required this could be logging. if requred it should be done on the dedicated UI. getting the message there could be via return values or more pythonic via raised exceptions. so we remove the print from 

EDIT: also, from a design point it is strange that and are returning nodes instead of values. you should get returned what you insert. 

explicit loops python has list slicing and list comprehension. in you use comprehension but could use the more dense slicing 

Your loop has a potential complexity of R * M (R number of words in ransom, M number of words in magazine). Additionally you use in the inner loop which which does linear search in magazine. The solution is to count occurences of words in both, magazine and ransom. this is done in a single sweep and of linear complexity R + M (dict get/set is average linear). the moste dense and readable solution is 

No I/O from core functions We already did remove a print from . We now do that for others as well. When you do print from core functions you either 

Before adapting we have a look at the names which are not reflecting reality. the loop shall be because it is a single row. likewise should be as there are several data/spacing/separation parts in there. That said we change to (still not perfect) 

so any other variable referencing a node or even the root node will possibly reference something old. 

still there is an if clause which we could make shorter. there are numerous techniques to toggle/select/cycle values from a limited set. here i am tempted to use a very lazy one (as the number of iterations is small) 

When writing library classes you should follow the python guidelines to enable generic duck typed interfacing. have a look at the python datamodel and try to make e. g. the following tests work by implementing and . 

we also fix all the column indices in (where we find 9 winning cases which is one to many). Do not repeat yourself now we have a close look at as it looks now. 

it is clear and readable and tells all and shall not be done any other way. Now about sorting a . You rely on a 3.6 implementation detail that will be guaranteed in 3.7 when released. whenever you do such a version-stunt you shall check the version and either raise an error or implement a fallback (e.g. ). However when 3.7 will be released there might be a sort for implemented as well. Your solution is most likely becoming obsolete when becoming legal. About coding You define an inner function for no reason introducing a lot of complexity. In your inner function you check the existence of an outer to decide on returning a , that's awful. You mix and exception handling in for control flow. your clause is a completely regular case. You shall not implement a silent fallback to sort by string (or whatever the type is) when the user requested sorting via . this is a complete fail, hiding a user error and presenting false data as regular result.