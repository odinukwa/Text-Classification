You forgot GeexBox. All of them are approximately the same, they use latest build of XBMC and the features are mostly similar. Raspbmc has a bit annoying tendency to update itself at the most unpredictable moments, others -- not so much. OpenELEC and XBian are (in my opinion) customized a bit heavier than others, that makes them a little snappier. Regarding using as a classic Linux -- yes, there's a linux inside, but using is discouraged (at least in RaspBMC) and may lead to a broken system. So as long as you don't install and upgrade packages -- you'll be fine. Or you may try to install the plain old Raspbian and XBMC on the top of it, it might be a tad slower because of more running services, but you could watch movies and have a good linux experience at the same time. 

there's no way to use this module as a primary display, it's intended for being accessed through the 4D Systems C Serial Library to draw things on the screen using commands sent over a serial interface. please, check the github repository on the page you get this module from. you might be able to redirect some system output to the serial port and see it on the screen, provided your display module has "Serial Environment" software loaded inside. 

touch +5V with the probe end, the LED should become ON, otherwise you either missed the GND and +5V or the LED polarity (the longer lead should connect to the probe). from now on, you may safely ignore +5V pin, because it's not required for a proper operation of the serial port, unless you're going to power RasPi from USB port, that's generally not recommended and will eventually fail. if everything works so far, connect the probe to the probable candidate to TX pin and type something into the terminal window (choose lower baud rate in the terminal settings, something like 2400, 4800 or 9600), connected to USB tty port on your PC. see if the LED will flash when you type. if nothing happens, try another possible TX candidate pin. at least one of them will make the LED flash, and the other will be RX pin. ps. I have mistaken TX and RX pins many times in the past, with TTL serial levels it's quite difficult to do any damage, you should not worry much about that. 

replacing the and numbers with the ones you've found with command. Finally, you have to add yourself to the group 'plugdev': 

just make sure your partition is not encrypted and is already mounted during the boot process, otherwise you might need to change the place for your script. 

There's a nice explanation about emulating Raspberry Pi with QEMU available: $URL$ Or there's another one, including the pictures!! $URL$ Please, read 'em and follow 'em and ask questions if it does not work. 

get rid of , rc.local is already run by superuser put the complete paths there (environment might be not as you remember it) add at the end of command, because is supposed to finish fast redirect outputs so your script does not get stuck when buffer is full 

short answer -- please, don't, because Raspberry Pi is a wonderful piece of hardware to play with, it's going to be a waste to use it for such a mundane task -- turning lights on and off. wifi is very expensive and basically overkill, when plain old X10 or RF module will suffice. 

the short answer is "no", you won't be able to use your 2.7" touchscreen display with Raspberry Pi. you need an SPI-enabled screen to be able to connect it to the Raspberry Pi, otherwise there's just not enough data lines to send data back and forth and there are no ADC converters on RasPi to convert your touch position data, unless you want to get your hands dirty soldering away a breakout/conversion board, that might be quite an exercise in electronics. 

you need a TV set that supports CEC (Consumer Electronics Control) protocol over HDMI. it might be a good idea to consult your TV manual or company web site to find details regarding your particular case, also quick search for "TV_model + CEC" might give you a few pointers. basically, if your TV set is made just a few years ago, there's a good chance you might find how to setup and enable CEC, but for older models chances are not so good. Samsung CEC implementation is called , you may try to search for that too. 

Both RasPi and USB-WiFi consume quite a lot of power, so unless you're going to power them from car battery or something of similar size, you may forget about running them on batteries. An usual pack of AA batteries will give you about 1 hour of run time, with very unstable performance after the batteries are half-depleted. 

should do the trick of cleaning your current setup, or you may use the particular chain name you don't like: 

If you are referring to the Gingerbread image build circa beginning of the last year, it won't work on the recent Raspbery Pi's, probably because of different memory size and other hardware changes introduced since then. Might work on early 256MB models, perhaps. 

Short answer -- use 2GB SD card. Long answer, has no idea where the "good" data ends, you have to tell it somehow. There are two ways, easiest is to use 2GB SD card, that will automatically stop copying beyond 2GB and will result in 500MB compressed file as you desire. The other way, more complicated an involved one, is to calculate the correct data size from your partition table and specify this correct size as a parameters to command. You may use (block size) and (block count) parameters for that purpose. For example, you may specify for 10MB block size (that would definitely make copying much faster compared to 4k block size you use in your commands) and to copy 10MB * 200 = 2000MB (2GB). You may need to adjust block size and block count according to your SD card partition scheme. 

You're doing something really strange, because Raspberry Pi usually runs with 0 (zero) swap, and most people even disable it outright (i did not, too lazy =): 

you may try this script to find the largest existing files on your file system, helps a lot to answer the question: "where all my free space went?" =) 

the original description says: "Can drive 4 DC motors or 2 stepper motors or 2 Servo", that most likely mean you CANNOT drive 2 motors and a stepper at the same time. also, i'm afraid you won't be able to easily interface this board to the RasPi. finally, software based PWM is fun and could be used to create a proof of concept, but I would not recommend to let any SW PWM anywhere near you designs, unless you don't care about precision and don't mind your mechanical parts jitter back and forth when you move a mouse or get some network traffic with plenty of interrupts. 

most probably (constantly scrolling "pi@raspberrypi ~ $" and hundreds of open windows) you just have an "enter" key stuck on your keyboard, or there's something else funny with your keyboard. please, try to get another keyboard and see if the same thing happens again. regarding the original question about dist-upgrade, this should not take more than a few (maybe 10) minutes. 

also, for changing your time zone, the recommended way is running , then using and to do the trick instead of manually editing config files. 

cable quality (coaxial would be the best) signal levels (5V are fine, but 15V or 20V would travel better) signal frequency (1-2Hz can go very-very far, 1kHz might reach kilometers, 100kHz won't cross a football field) 

you should define "turned off" you may easily realize there's no power when red LED is dark. and when only red LED is shining, the CPU is most likely halted and the system is stopped. sorry i cannot offer any help besides that without knowing what exactly you're looking for. 

there are several parameters you may change when overclocking, the CPU frequency, memory latency, CPU voltage. as long as you change frequencies, you are safe. if you change the voltage, you blow the hardware fuse inside the chip and void your warranty. to reiterate, DONT change the voltage settings if you want to keep your warranty. 

besides the obvious (removing MAILTO line), you may also try to redirect the output of your scripts to /dev/null, since if the script has any output it will be sent to the user this script belongs to by default. add something like this to the end of offending scripts in crontab: 

Lithium batteries are prone to overheating and burning along with your house, if charged improperly or handled improperly or, sometimes, just for no reason. Google "lithium battery fire" and try something else, like lead-acid, these are much heavier, but much, much safer. Personally I would not even dream leaving lithium battery charging or discharging at home unattended. 

You'd better choose a different scanner, something like Microsoft Fingerprint Reader 1033 (or the same model in the different box -- Digital Persona Pro UareU 4000B). Both are dime-a-dozen, well supported using and there are plenty of software available, including PAM modules for easy identification using the finger instead of the password. Also, since these scanners provide a raw 8-bit grayscale picture, it's easy to change recognition backends or even write your own software, and the database of the fingerprints will be limited only by your imagination (and your external HDD size =). Sparkfun scanner does not allow to capture raw images and only stores about a hundred of templates -- it's not nearly enough for a family of 3 or more, let alone using it for a small company office or any communal space. 

Cannot vouch for your particular BT adapter, but my RasPi has an external HDD connected directly to the USB port without any extra power supply, that regularly achieves 5-8mb/s transfer speeds over a multi-gigabyte transfers, that are read over the network (Ethernet is also basically connected to the same USB due to RasPi architecture). Haven't seen any issues yet. 

Raspberry Pi does not natively support 1920x1080 mode. when displaying UI or rendering video, the image created is about 1280x720, upscaled later to fill the whole screen. seems like there's nothing to do about that. 

it seems very unlikely the 4GB (or 2GB) SD card image becomes this small without compression, and even then, 1)it's still too small and 2)requires decompression of some sort. and, finally, you're supposed to transfer the contents of /dev/disk1, not the single partition, that is /dev/disk1s1 -- only then you'll have the full backup image, as opposed to now, when you have only small part of it.