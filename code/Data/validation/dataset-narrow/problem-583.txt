To ensure it has consistent behaviour with . I'm sure that this answer is less performant but I find it easier to reason about (but I am a Regex nut). As a final point, I'd rename the method or :) 

If time performance really is critical (I doubt it is), you can create the lists with an initial capacity equal to the size of the bigger list. That way the lists won't need to resize and will be O(1); if you did that then this is O(n). 

Now, why is your Poker Game also a Poker Table and a TableAction? It seems to be an odd inheritance structure to me. 

I'd argue that your model is a bit off here. Espresso is black coffee i.e. it doesn't have milk in it. 

You'll notice my Regex uses a negative lookbehind and a negative lookahead to only capture non 'esacped' curly braces. I then use a MatchEvaluator delegate (called on each match) to replace it with the value from the args object or put the string back in its original format if there is no entry in the args object (). That could be modified to throw if you'd rather. I'd also suggest the following additional test case: 

You should throw the most specific exception type available. If the argument is null and that isn't allowed. . 

Why create a class to wrap the validation strategy at all? A common pattern with immutable objects is to have an empty or seed value to start construction from. 

The message isn't accurate Don't end messages to the user with an exclamation mark, it makes users feel bad Your comment doesn't add anything to the code Your comment isn't grammatically correct 

I wish I could suggest something useful but I still haven't figure out what you intend on doing with this thing. 

Break the underscore key off of your keyboard. Just use camelCase for variables. Edit I think one of the other reasons for saying it isn't very OO is the fact that your CalcTax method (should be CalculateTax) takes a list of parameters when it would be better served by taking a object. 

You aren't using you should remove it. I was part way through writing a better solution but Janos beat me to it! 

I like this more because it also promotes the calculation to its own line where nothing else happens. You could also have written: 

uses an inclusive lower bound and an exclusive upper bound. That means your code will always return . It should instead be: 

I don't see why you need the method to be generic... You're only adding the hook to an internal list of . I think you'd minimise noise by removing the generics: 

Your code is really hard to follow, the method is a bit too long for my liking and you have a which IMO should never be used. 

That is a detail but you're tying to it! It should be possible to replace that dependency with a different one if you want. The standard way of doing that is with Dependency Injection. e.g. using Constructor Injection: 

Notice that the explicit operator can throw as not all strings are valid Skus but the implicit operator can't because all Skus are valid strings. I feel like I've rambled, but hopefully something in the above is useful. 

I've used spaces rather than a tab as I prefer that. I'm not going to recommend one over the other as I don't want to start a holy war. Spacing You're inconsistent with spacing around your brackets, sometimes they get a space and sometimes they don't: 

Checking if is less than or equal to zero is pointless because you already know it's at least twice as big as and you've just checked that is greater than 0. I think you're missing a check on . Surely that has to be >= 2. If the argument is outside of the allowed range throw an as that's more descriptive. 

Don't use unless you want to specify advanced options; use . However, don't use for fake asynchrony - you'll just slow things down. 

and should be . The same applies here change it to . It would be even nicer if you changed to something meaningful. I know it all seems really trivial but code will be read far more often than it's written/edited so you should be optimizing for read time not saving the odd space characters when you're typing it. 

Did you know that blocks? Your code isn't asynchronous at all - and it can't be unless is. Effectively your code is starting a new task and then blocking while it completes - there's no benefit to starting the task at all! As a small aside, is easier than using . If I were you, I'd just remove the Task. 

I think it would be sufficient to only check that step has gone over the length of one of the two strings and not both but I left both checks in for completeness. It's not as elegant, but make something work first and then make it pretty :) 

Now, look at your code: which rule will be in-lined first? Now, I haven't actually compiled your code, let alone run it, but I'm sure you'll apply the styles in the wrong order. And another example: 

Naming this is pretty tough - you'd probably need several attempts to get something good. Your is normally referred to as a . 

I think that Heslacher is right and you don't strictly need this class, but as you've written it I'd like to point out a couple of things: 

First of all - I like it. It's definitely readable and the naming and style seem good. I'm going to focus on a single point really (at least for now): Is a bird class or a plane string? It looks like it's both: 

For what it's worth I think you've over complicated this. It seems to me that you care if you succeed or not and then want to pass as much information on to someone who can figure out what went wrong. The only 2 lines that are in the try block are parsing to doubles so just catch and beef up the information included. 

Following on from my previous question, I finally got round to actually doing the A* search for the . The changes to the code from the previous question were pretty minor (and no API change) so I won't include the code again. First, I defined an interface for a hueristic. 

Your code change introduces a change in behaviour which is just as likely to adversely affect performance... A streams the data one row at a time whereas the loads all the data into memory. The being passed in means that the underlying connection will be closed when the DataReader is. If the calling code isn't disposing the reader then it is wrong and you should change that. i.e. 

I must admit, personally I think the api is really good, I've never needed an implicit conversion to a string or felt the need to rather than append to them. 

As Adriano Repetti mentioned in comments you can already achieve this with extension methods on IQueryable. E.g. for your users example: 

Without knowing why you currently believe that they are bad it's difficult for me to make a case for why they're not :) 

(My emphasis) You can read about best fit fallback here: Character Encoding in the .NET Framework. This is generally the canonical link for an introduction to character encoding (and why unicode): The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!). 

Your namespace is far too generic - it's much better than but you should use something like in your real app. 

In this case, your manual reset event will never be signalled and the code will never finish executing. Eeek! As was introduced in .Net 4 you may as well use another class that was new at the same time . 

Note that I have also added in braces as I personally think they should always be included, even for single line blocks. Asynchronicity I had to type something that made me very sad. 

Fields should be camel case. Either: or . A setter that keeps a running total isn't a good idea. Consider my example: 

Although there's nothing wrong with your code, it is generally easier to fall back on framework classes for this kind of thing. Namely and . 

A better alternative would be to create a class to encapsulate gender, age and name. Chain of responsibility doesn't fit here IMO. You only have 3 independent factors making up part of a string - CoR is too complex for it. 

Most people writing C# prefer braces on new lines. What is ? A property that gets input from the user? I could go on but that's not very constructive. What you need to do, is go back to the drawing board and come up with some classes to encapsulate all the different things going on here. 

Seeing your code could help me attack your passwords - it has a couple of flaws which mean certain characters are more likely to appear than others. Here's the offending part: 

Your will hold an instance of and since your is a singleton - there's going to be an instance of around forever as well. As it's apparently fine for your to use the same serializer throughout the lifetime of the app, and the implementation looks completely fine for sharing an instance, I don't see any reason why you can't just make a singleton too. I think that this isn't quite a captive dependency as the default lifetime of is transient but it's certainly a related topic that you can read about on Mark Seemann's blog. 

By modelling your stylesheet as a simple you lose the order of the rules. You have to know which rule came first to in-line the rules in the right order! That's why it's called a cascading style sheet. It looks like you're only doing a simple thing so I think you can reasonably ignore specificity and media queries. Build up the domain! 

I've been a bit wooly on the specifics here but hopefully you can see yourself to a working solution! 

If you are using the Enterprise Library it is often better to set up a default connection in the configuration file: 

Now, because is an int, you can't inject anything malicious, but what if you wanted to get the operator by name? Do you promise that you wouldn't write: 

Firstly, here's a link to the fiddle. Basically my situation is that there is a requirement to show tooltips on textboxes on some forms being created for a website to allow employees to update their personal information (among other things). The customer likes the idea of the tooltip being displayed to the right of the textbox when the user clicks into it rather than jQuery UI's default of when hovering over it. To that end, I created the following code that shows and hides the tooltip when the user clicks into/out of the textbox: 

Many people, myself included, don't like to use s. They just add noise - especially on such a small class is one step too far IMO. The method name isn't accurate either, you're setting the value if it exists or not. The exception message is really odd if you specify a property without the attribute: 

I've chosen IQueryable over IEnumerable as it looks like you're using entity framework. If you're not, feel free to use IEnumerable again. Then your queries look nice: 

As for your question about directives: should be killed with fire seems like a good candidate but execution isn't great (will come back to this if I get time) By removing the directive you can change your view to: 

I haven't done this sort of thing before (and I have a Physics background so no CS classes to fall back on) so I'm looking for comments on all aspects of the code. Is putting the on a tile a reasonable trade off for simplicity, or should I introduce a more modelled edge with the cost on that instead? 

3 It's better to be in the habit of using and to avoid subtle bugs caused by type coercion. 4 is better written as 

Shuffle the remaining socks to be paired Draw one sock at a time comparing to the previously drawn sock If the socks match, put them in the matched pile Otherwise, add the previously drawn sock to the unmatched pile Compare all socks this way Start again with the unmatched pile 

Other than that there's some style points that could rely do with some work: Classes should be named in Pascal case (upper camel case). should be . Methods should also be Pascal case should be . What the hell is even doing. Don't mix concatenation and it kills a puppy. 

Further to my comment about my proposed solution being faster - it's not because your code is slow in any way. If you want a dictionary of mappings of property -> index in data array your code will be slower but that probably wont matter. You could just move your array of property mappings to a field. Just change the signature to you'd then populate it like: 

is it really so much effort to type the remaining 7 characters of ? Don't abbreviate. . is a terrible name. I'd suggest . - may be a nitpick but I prefer over and definitely over which is another needless abbreviation. isn't a bad name but it could be better. is a bit of a mouthful but it's unambiguous. I'd remove the default value on and rename it to . I'd also verify that it's greater than 0 and throw an exception if it wasn't. 

Why have you tied yourself to only lists? There's nothing here (apart from the case sensitivity flag) which couldn't work on generic lists. 

Other comments As I mentioned previously, this isn't gauranteed to be correct (but is in every instance I know of): 

That's a lot less typing and a bit easier to scan IMO. We also now have string interpolation (this one is much newer): 

You certainly can! You're currently coding using the "arrow pattern" it's often nicer to return early rather than keep indenting further and further as you nest conditionals. 

You don't need to call on the in fact, doing so isn't great at all... As far as I am aware, this will make your clause execute in C# rather than being translated to SQL meaning a massive perf hit (I would be happy to be corrected here). You should return directly: