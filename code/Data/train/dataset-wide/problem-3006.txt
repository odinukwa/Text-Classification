I would consider whether you should assign value to those URI path segments in this class (i.e. which segments specify controllers, actions on controller, parameters, etc.) You should leave it up to your router and controllers to assign meaning, not the class that is simply trying to encapsulate the state of the request. 

A word of caution though - sometimes when getting into more complex queries with subselects, the can get into performance issues. I understand you current two query approach, which at least has the benefit of using two straightfoward queries. Before moving to something like I have suggested, make sure you look at query performance to make sure it is somewhat inline with the combined response times you have from your two query approach. If you are dealing with response times that are an order of magnitude higher, you probably should not take this approach. 

In you might consider not trimming input, but rather making sure that looking for whitespace at edges of string are part of validation. Do you really want to enable the caller to send you a malformed string, with the class silently correcting them vs. having the caller send correct strings? 

is an odd method. It accepts arbitrary query input, so how to you know that the query is even a vs. some other type of query. Why would a mapper class even need to accept arbitrary SQL? 

Why conditionally encode JSON? If you are sending header, you better well be sending well-formatted JSON to the client (why would you break your own API contract?). What about passing objects? JSON allows for encoding more than just arrays. 

Note here that there are added rows where the values represent case where you have subtotal for the preceding aggregation set (i.e. for each of you values). This could make it even easier for application logic to pick up you group-level totals. Now, if you truly need to get percentages totals in the result set, then I would first take a step back and really understand what the use case is. Do you really need to make this query on an ad hoc basis with a need for exact real-time results? If so, you may just have to live with the fact that your query may take a long time to run, as you will always have to calculate the totals as aggregated at id level and at id/domainIP level. If however you can live with periodically updating the aggregations (like scheduled via cron, or simlar), then your options open up greatly to deliver better performance. Perhaps you runs a query like I have shown above and place the results into a temporary table every X minutes and then use that table as the basis for your query. Perhaps you look at wholly separate summary tables (as suggested in the answer by @Siegen), with trigger-based updates. Perhaps you have a wholly separate ETL process which takes this data and populates in into a data store more geared towards data reporting (i.e. a data warehouse). Whatever the case may be, I would suggest that you might need to take a step back and think about what you use case really requires, and my guess is that you will find it does not require ad-hoc, real-time, query results like what you are trying to get here. 

First, I would ask if you really need the percentage calculation to happen in the query result set (vs. being able to calculate this in application layer). This is really what is causing complexity in your use case, as being able to get row-level data and summary data (the percentage) in a single query is a bit of a challenge in most relational databases. If you don't require this in your actual query, then you can greatly simplify this query to something like: 

What is significance of and portions of template? These just seem like separators between actual fields of importance. What value does it have to put and in the resulting data structure? 

I have recently refactored a REST client library and was hoping to get review for both the class itself and the unit tests that cover it. This code is developed against PHP 7.1, but tested against PHP 5.6, 7.0 7.1, HipHop VM, and PHP nightly builds. The full library can be seen on GitHub RestClient.php 

I don't understand the property at all. It seems unnecessary. You can use to design away your two code branches in method (or change operational order of update/insert if you wanted to perhaps remain more database agnostic as suggested in another answer). I also think that perhaps you are thinking of these method calls being made in more of a linear fashion than what might actually be presented. You may want to take a look at this great article on how session handlers are called relative to session management code in PHP. By looking at this, you can see that things like session ID change can happen between calls to the other methods. I especially like this summary comment from the article: 

Glad to see you using doc blocks, however these property blocks should probably be changed to , , etc. 

I worry that you are arbitrarily setting expiries on cookies that may or may not match your session cookies lifetime value. You could really get your application into a bad state of perhaps have valid authentication cookie values but invalid session cookie or similar. 

I would suggest wrapping this whole thing in an IIFE such that you can modularize all of your slide show functionality into its own scope. That might look like this: 

in within this function context will have everything you need to know to perform a validation. From it you can reference the current value for the field, the type of validation rule that should be applied, and of course the element itself should you need to modify it (not discussed here). Inside your validation method is where you should hold the logic on how validations occur, not outside of it, otherwise, why have the function at all? Now for the validation method... At it's simplest this method needs to: determine input value, determine validation to apply, and return validation result. That could look something like this: 

Why do you need three different method calls to start this game? The caller should be able to just do something like: 

As opposed to directly modifying before making assignment to like shown below , which would not double memory utilization: 

Should this this whole row only be shown conditionally based on whether there is error info to display? 

It seems odd to actually perform the login action (verifying password, changing session authentication status, etc.) in a form validation callback. Separate these concerns. Validate the form data and if successful then perform the login verification. 

You should strongly consider using a PSR-4 compliant autoloader. This can move you out of the world of having to write a lot of code around locating and loading class dependencies. 

I think this approach of mapping your request to an action in the controller may not scale well over time unless you only have to simplest of database models you are trying to make available via the API. You will inevitably find that the paradigm of one URI to one set of actions in a model will tend to break down for even the simplest applications. Let's use an example use case of an application where you have a post (like a blog) post and O to n comments that can be made against a post. When you go to serve up the data from your API, you may find you need convenience methods to allow the caller to get the full post as well as all comments with one API call, such that client doesn't need to get the post data and then make a series of follow-up API calls to get the data for each comment related to the post. So you might decide to expose an endpoint like: 

This way you can let the caller know that they are trying to access the object in an invalid manner such that they might do something about it. Your current code just silently fails without returning anything to the caller. Similarly, in your constructor, you would seem to be passing a PDO object. Enforce this with a type hint, so you are guaranteed to get a properly set up PDO object passed to this class. 

Your class, as shown, doesn't really provide a method for getting at the user data. What is the point of instantiating a user object if you can't read any data out of it? Are you planning on implementing to perform lookups against the array (something I would discourage in favor of proper properties)? How does a developer even know what properties, besides are available on the user? 

I would suggest you use rather than if rewriting this. With you can work in exception mode to where you don't have to create your own exception throwing logic around . It is also provide compatibility across a variety of relational database types. 

I don't see need for checks in instance methods. You do a good job of throwing exceptions in constructor such that a concrete cannot be instantiated unless this is true, so this code is just redundant. Another related note is that, although you do a relatively good job of exiting early from your functions in exceptional cases (a very good practice), there are cases like in your method where you have pretty much all the method code nested in an conditional when early exit from function would eliminate the need for the conditional altogether. If you decide to keep the check this check, a failed check should throw an exception. Try to be consistent on how you approach this in your code. 

All of your DB operations are happy-path. You just assume they will work (which is especially problematic based on data validation concern noted earlier). What is prepares fail? What if execution fails? 

Why have in the callback, when you don't do anything for the case where this evaluates as false? Furthermore, you still evaluate data in subsequent conditionals even if this evaluates as false. Perhaps consider checking and failing out appropriately, so you can then move mapping to out of a conditional altogether and reliably evaluate in subsequent conditionals. I do also question whether you should be evaluating against instead of since truly becomes the primary subject of your logic after has been mapped to . I know this may seem like semantics, but you could technically make the memory allocated to available for garbage collection after it is mapped, as it really no longer needs to be used. If is large this might help you out, though I guess if data were large, you might have best iterated data and changed it in place rather than using map operation which would double memory utilization. 

This approach is scalable as you add more elements into your test cases, as you could just add new id keys into the element array and not worry about polluting your global namespace with a bunch of variables. You also now have the ability to simply look at the value stored at each key to determine if the element was found. So for example, if you are going to perform a test action against a certain element, you can test for it like: 

I would tend to agree with comments from @sensorario that fluent interface may not make much sense here. I am going to operate under the assumption that this class if being instantiated from a controller or the like. If that is the case, why would it make sense to have this fluent style? Presumably that controller know all the information it need to know in order to create a response and there are not going to be other things that decorate the response during it's short lifecycle. If this is that case, why make code more complex in the controller and make this object more fragile in terms of being potentially put into a bad state (i.e incomplete field completion, etc.). I would prefer to see the constructor enforce the data to be set on the object at the point of instantiation such that you know that the object has all the dependencies it needs to fulfill it's main method calls. For example: 

So at the end of the day, it really is preference to what you (and any peers you may be working with) find to be a style that you want to adopt. I almost always stay away from "in-lining" SQL into other language code like this: 

This eliminates all those nested ifs. Your code is also extremely densely packed making it hard to read. You should really try to keep your lines under 80 characters, breaking longer lines across lines. And while I am normally a big proponent of meaningful variable and function names, you seem to almost take it to the extreme, using overly verbose variables when sometimes it does not seem necessary. Take for example how in your for loop you store the array length into when something short and simple like would be just fine since it is clear what is happening here. 

First, you should strive to separate your PHP logic from your HTML output. Right now you have the classic "spaghetti code" which is very hard to maintain over time. Do your very best to write all the information you need into PHP variables, such that when you get to rendering your HTML (ideally in a different file from your main code), all you are doing is simple variable insertion and perhaps some looping in your HTML template. 

This example also creates an early exit from the function or code path, which is almost always a good thing. Fail fast and fail loudly. 

It is generally a bad idea to just echo errors to standard out. Consider at least logging an error here. You also might want to have portion of code closer to display layer handle the actual end user messaging. 

A comment about validation... You are doing a good job of trying to enforce typehints on your methods, however I do wonder if it might make sense for you to have classes defined which deal with say a collection of objects. These seem to be critical dependencies that can only be enforced to be an array via type-hinting, meaning that if you truly wanted to be able to validate that you have valid place objects in your array, you might have to go into undesirable approach of inspecting each array item to validate it. If instead of passing simple array, you passed or similar, you could be ensured that everything in that collection is a valid object. Certainly, this adds yet another bit of code to the overall system, so really only you can determine if it is worthwhile to do this depending on how you are planning to use this code. But it is something to consider when these are key items you are working with (vs. say optional configurations or similar). Do you need any error or exception handling here? Typically one of the things a factory would do is raise an exception if the dependencies that are passed are not valid (typehinting can do a lot of this for you) or to handle any underyling exceptions that might happen within method execution (i.e. can instantiation of a , , etc. object throw an exception?). I don't really see any consideration here in your code for error or edge conditions. It seems as if this is considering happy path only. 

Why should any one concrete model determine when the DB connection is discarded as is done in your method? What if there are other models still active in the system that need this connection (you are trying to use a singleton after all. Again, just pass the PDO dependency to this class and leave the management of connections elsewhere in your code. 

In class A, while I appreciate that you are trying to work with PDO in exception mode (a good thing) and using try-catch here around the instantiation. Think about what impact this has on your code. Here if PDO instantiation fails with exception, you basically just swallow it up with only some output to standard out to indicate there was a problem. Subsequent code could call this class, expecting an instance without knowing that the class was instantiated in a bad state. You should be failing loudly here and letting the caller to the class make the decision on how to handle the situation. I don't think that there is really a case here to even use try-catch, as I would think it reasonable that a bubble up from a PDO singleton class. Maybe the only reason to use try-catch here is in case you wanted to log some information about the internal state of the class before re-throwing or wrapping the exception. Either way, an exception should be thrown externally when you can't instantiate in an expected state.