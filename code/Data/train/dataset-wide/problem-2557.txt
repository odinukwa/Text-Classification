I'm very wary of having any method named outside of classes which implement the interface. This isn't something you'd know about as a beginner, but basically has a very specific connotation which regards using multiple threads. I might rename this method to or something of the sort. It looks like you have a lot of functionality tacked on that is just needless overhead. For example, you have a method which only has one line of code: . There's no need for you to have a wrapper method here. The name of your variable and the method you invoke from it state what you're doing very succinctly. Because you've chosen your variable names well, the code is somewhat self-documenting. Over-architecting your solution can be as big of a problem as having all of your code just slapped in the method. (This comment applies to a chunk of your methods below ). If you're going to have big block comments over every method, consider formatting them with JavaDoc. It's never too early to learn how to properly document your code. 

It's okay if you don't know what all this does. Basically it's just checking to make sure that the returned by is actually an before trying to downcast it. If it's not, if will throw an . I might've rewritten this method like the following, but in my production environment I really dislike using and this kind of downcasting. (In general, it creates "code smell".) 

Don't take it personal but your approach is not good and will be very difficult to mantain. Reflection is the way to go but take a look to validation attributes, component model and data annotations. Here is a link that may point you to a better direction: $URL$ You can create your own validation attributes or use existing and have a class that takes by reflection those attributes and evalute them. Edit Some reasons why the approach is not good 1) A field can't have multiple validations (mail + required + maxlength,...) 2) Your validation can't compare values with other values (bigger than x, required if,...) 3) class will become soon fat class, as it handles all the validation rules. 4) You will have to duplicate this code every time you want to validate, what could be in multiple places and in multiple applications, if new rules are comming you will have to update all those places. 

I would remove the try catch and do not return any boolean. As a general rule, you should only catch exceptions you can handle. For example, if you use this piece of code in a user interface, the boolean cuts any possibility to give feedback to the user. Instead, if the method will simply throw, you can probably handle it in a more convenient way and display a message to the user (for example, can't connect to...) Additionaly, if you catch and return booleans everywhere, your cyclomatic complexity just grows as your code will look to something like this 

If you don't know what an enum is, now's a great time to learn. It's a very useful data structure which lets you define exactly what its potential values are. Here, it seems like your missile types are PAC-3s, GEM-Cs, and GEM-Ts, so that's what we have above. This is why object-oriented programming is so powerful. A missile is a thing in the world with its own properties, and so it is here. This enum may have been more appropriately named , depending on your preference, since technically it will hold values for multiple missiles, like the . But having this data structure set up is what will let us completely rewrite your method in just five lines. 

You should try to use consistent style in your code. If you're going to put these checks and return statements at the beginning, either put them on the same line as the statement or don't. It doesn't matter which you do, as long as you do the same thing throughout. Makes your code much more readable and easier to maintain. 

This is a small modification which I just thought prettied up the code a little bit. It just uses the ternary operator to shorten all the variable declaration and if/else assignments into one line. I think everything else pretty much follows what I've already said, so that's about it! Let me know if you have any questions about the code. 

DALEmployee What is the concept behind this class? Do you really need it? If yes, my recommendation would be to inject IService1. You can google dependency injection to get more details. Controller If you don't need DALEmployee, you can simply inject IService1 directly in the controller. getEmployees Generally is weird to me how you achieve the pagination. Generally i would use as parameters CurrentPage and PageSize and for me it seems you that you are using the employee id. How would you extend this if you have to sort by other criteria rather than employee id? Additionaly, you are using a different where on the get count and on the procedure itself, what will lead to wrong pages. Finally, depending on your sql server version, you may use this operators to paginate. SELECT * FROM TableName ORDER BY whatever OFFSET 10 ROWS FETCH NEXT 10 ROWS ONLY; 

I totally agree with @RobH answer but I would like to mention some extra things. You have 2 unused fields that I guess are there for testing reasons but they are good to illustrate the concept of readonly fields/properties as you only set them in the constructor. Your class could look like this. 

regarding your concerns. 1) I do not believe this initialization is a problem but if later on it will be a problem, you can always change it to lazy initialization. 2,3) I just paste a similar code that I find more readable and improves your loop when you want to find the parent area. 

I just picked this bit out because it contains a lot of your variable declarations. Your code was very, very difficult to decipher because of the names you chose for your variables. If you intend to ever work on a large scale project, you will likely be working with other people. And if you're working with other people, code readability is much, much more important than anything else. There's a common adage that goes something like "A programmer's job is 10% development, 90% maintenance," and that's incredibly true. You'll find that even if you're the only one working on a project, you'll come back to your code and look at this and ask yourself "...What in the world was I thinking here?" Believe me, it happens more often than you think. Bottom line: pick good variable names to try to make your code self-documenting. Note that in the final version that I post below, you can pretty much know exactly what every line of code is trying to do just because I've chosen my variable and method names intuitively. Also, if you want to be really Java-esque, follow the naming conventions. No underscores in variable names (unless they're ). 

Have descriptive, intuitive variable names. (Example: what is ? No clue.) You have a of a . It looks like the your custom class is much like a key-value pair in a . I think it would simplify your code a lot if you just went ahead and used instead of jumping through needless hoops. Be more consistent in your naming conventions. You have some variables which are named in (which is the accepted way to do it in Java), and then you have some which have the elements separated by underscores (). The capitalized/underscore format is good for constants (like your ), but that's it. It's good that you're trying to comment your code, but some of your comments are overkill and unnecessary. Because you chose good names for your methods, the code is self-documenting in some places, which is a good thing! So the following comments are pretty much useless, as they say exactly what the method names express: