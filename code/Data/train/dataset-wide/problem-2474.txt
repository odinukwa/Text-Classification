but for consistency I would expect the result to be a list of two elements, the first being the part that was split off, the second being the rest of the list. Thus I'd expect a result like this: 

First, is not a descriptive name, and it's reused for (though only slightly) different behaviors. But, more "serious", neither of these functions actually does what it says: The first is not creating / making a "remove playlist duplicates" action, and neither is the second creating / making a "playlist path action". They are creating an action that takes (one or two) values from the parser, opens the first as a file, and then runs some given function with the file (and the remaining argument, for the second function). So, they're one the one hand far more general than their names try to tell, and on the other hand IMO they do "too much" by doing two unrelated things: one, feeding values from the parser to a custom function. Two, opening a file. Thus, I'd probably try to make a function that passes all values from the parser on to a custom function, and then either handle the file opening in the custom function(s) (probably not a good idea, DRY) or make a wrapper function that takes care of it. 

Some thoughts: choose good names is IMO a bit "generic". Perhaps something more expressive like ? Moreover, the inner function's parameter is named , but it's actually not some count (number) but a text string. Furthermore you're using the term "sentence", but you're not actually requiring sentences, but rather character sequences / strings. don't call the function twice 

IMO this is a huge imbalance. The basically controls and does everything with the small exception that it's not shuffling the cards nor handle the player's bets / funds. As such, it's a violation of the SRP. 

I'm pretty sure (though I haven't measured yet) that my version is a lot faster than the legacy one on one of the target platforms which doesn't have hardware floating point support. I'm also guessing that on the other platforms the actual speed difference will be negligible. What I'm more concerned about: Do I correctly detect all circumstances where the conversion result will be +/- Infinity (when the source is not) and where the conversion error ( so to say) will be more than ( in my example call above)? Apart from that, any other suggestions on how to improve my code? Other ways to get the job done without any floating point arithmetic? 

This isn't facebook, don't share that much ;) This is just a guess, but I'd assume that you misuse . Think carefully about who owns (for example) a . Who controls its lifetime? If it's the , then you are far better of using . The s are useless That said, putting s inside a (with the default compare) means that its is used by the set to prevent duplicates. But, from above link (emphasis mine): 

This looks strange to me. First of all the (a typo? This shouldn't even compile.). But especially since your has the same content. So ... 

This is not directly applicable to above example, but ... Hide the initial value ... works nice with this, which should behave as you wanted (minus the default parameters): 

Now that's not correct, is it? The only tail recursive functions in the code you showed are (thanks to the short circuiting ) and (where the recursive call actually is in tail call position). In there's in tail call position, in and it's a . An example of how to transform such linear recursive functions to being tail recursive is shown in Renzo's answer. "Only car, cdr and a bunch of basic predicates" If something like that's ever a requirement (for example in a test you have to take), then ignore it at first. Write your code using , and all the other handy utility functions. Then just write each of the functions you use yourself, using "Only car, cdr and a bunch of basic predicates". Everything else leads to a nightmare. Oh, and don't forget to also test the utility functions you wrote yourself (including edge cases)! Nothing's more frustrating than finding a bogus after hours of debugging ... Being fast Renzo already showed the IMO correct approach to such a function. If (and ONLY if) you need a faster solution (e.g. when this is run in an inner loop) then you can also achieve it in a single pass over the list by remembering the cell before the last occurrence and modifying its cdr to point to the cell after the last occurrence. 

Note that we can make this change with confidence of not breaking existing requirements due to the previous tests we wrote. Finally, let's include the known values for a leap year: 

Look at the capitalization. Your (and ) function parameters are completely unused. That's why you constants to be ALL UPCASE normally. Naming Functions are usually named for what they do: "erase" something, "sort" some elements, "activate" some timer, ... (and it's variant) don't follow this style. They name what they return, not what they do in order to be able to return that value. How about ? (measure used as a verb then.) 

You could also solve this by accepting non-const references, though I'm not sure whether that's really better. (Accepting the function object by value does not solve the issue because then any changes to the internal state cannot be transferred "back up" the call chain or past "major" iterations of the top level loop.) 

You don't compare strings for equality. You (try to) compare their lengths. Also, your comments should explain why you wrote the code the way you did. Don't tell what the code is doing. With well written code that should be self apparent. do one thing per function calculates the length of two strings (code duplication!) and then compares these. That's too much. Delegate that length calculation to another function: . Or - for learning purpose only - write your own replacement. vs Wondered why returns a instead of a ? That's because a string might be longer than the maximum difference that can be represented by . Thus may actually be undefined behavior when done with really long strings. Better keep a that you increase while searching for the . program output should end with a This is only minor, but otherwise it may corrupt the controlling terminal a bit. Or like in ideone drop the output completely. 

You can also go one step further and use , possibly making use of execution policies when (if) you switch to C++17. Getting rid of more "manual" loops Using you can get rid of more of these manual indexing loops: 

This means one or more sentences! Why? Because they should explain why you wrote something the way you did, not what the code is doing!. Generally speaking your comments don't help in any way, they just hurt readability. Better remove them! It's important to make your code so readable that you don't need a comment to tell the reader what the code does. Enumerations Since Python 3.4 there's support for enumerations, which is exactly what this is: 

According to the above specification you accept elements of type ... What would you expect to be the result on these arrays: 

This point is highly debatable though, so if that's just "your style" then feel free to ignore it ;) C style arrays are out of fashion Instead of 

The benefit is more information - the array size - for you (and the compiler) in some circumstances. A C style array "decays" (is implicitly converted) to a pointer to its first element in most situations. This conversion loses the information about the array size. I doubt that this has any benefit to you in your particular case, though, because you can use ... range based ... even with plain C arrays, too. This saves you from accidentally wrong indexing and other, often hard to find bugs: 

It's a "trick" that's fun to show once, but really don't use it. If you want to avoid the sequence of commands to compile, run and possibly delete, then write a shell function to do that for you. Global variable 

This only holds a single set (with a single content type). I generalize to multiple content types (and multiple sets) via variable template arguments: 

You're wasting an opportunity for some useful testing output: For example, you could print something like . If you want to "beef it up" further, then keep a line / instruction count and output that as well. 

Test, test, test! Next, I'd like to introduce you to TDD (test driven development): Instead of first writing your code and then test it (as all - or almost all - code should be tested!) you start off writing tests, specifying the desired behavior, and then make these tests pass by actually implementing the logic to achieve that behavior. Normally, you'd look into some testing framework / library, but we can go with a simple macro here for now: