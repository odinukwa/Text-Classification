ReuseableClass Each class is (ok, might be) reusable so naming it like this does not have much value. It calculates something... name it simply . And... it's not really reusable either because you write to the console there. You should write to the console somewhere else and let the methods just calculate the results. NumberOne This looks to me like a class but it's a method. You should name it appropriatly ie . 

Generating indexes There is this principle that says that a class should have only a single responsibility. We call it the Single responsibility principle. This means, that all the class should do, is to generate the indexes and not render the strings or write them to the console. Apart from removing the print methods from it, there are few other things you can improve becuase the current implementation is really complex. There's also a bug here where you increase the first index so the resulting array skips one item - the first one so let's fix the method. 

The most weird part of it is this where you . This is so unconventional that I cannot think of any resonable explanation for it. Usually you roll everything back there and not begin a new transaction. Overall I think this implementation is very confusing and I'm not sure what is the actual benefit of it. 

One more thing about it. I think the loop is a good candidate for a general purpose extension, I named it 

As far as the code is concerned you should always use and perhaps parameter names longer then a single letter . 

@RollanIllig already said what is wrong with . I'd like to add that even if it was ok to do it then there is no need for it to use either or . It would more linq-ish if you just used and let the user execute it when he needs to instead of doing it for him. This method also shouldn't be part of this class forcing the user to use your random numbers. 

As a user of this class I most probably don't want to think about which value I should use. I bet it'll be always the latest one so a single property like returning the most up-to-date value would be more appropriate. 

I sometimes write decorators to cache results I get from a repository or I write other caches... I don't want to write another cache anymore. I'd like to have something that'll work for anything. I've build a test-cache that I could use to replace other caches. It provides just the most basic methods. 

In an interview it usually doesn't matter if you actually solve the problem. What is most important is the way you (try to) solve it. If they don't tell you it should be the possibly fastest solution ever you should not optimize it prematurely but instead show that you know how to write SOLID code like encapsulate propertly, make the code testable etc. show that you know the techniques. 

Empty collections aren't considered an error. Most queries should work with empty collections just fine and return empty collections as a result. I wouldn't expect it to throw. You should check for only. 

The data for the tests comes from two methods that the actual test needs to provide. Here I'm testing an that implements the interface and internaly the set uses the and they are considered equal if they overlap. I added the comparer I test just for reference (the question is about the test-base class and the implementation - the comparer works as required). 

Another possibility would be to use named groups and catch the expressions there so that you can just use them without looking them up in the collections. 

With this structure you can create new car types anytime. The feautures could be created with the composition pattern. Then I would reduce the factory to just: 

These two lines are confusing. does not say what kind of a name this is and makes me think it's a file of some kind but it's actually a path. I know this as and . You already use this style with and .net is using it here . Try to be consistant. 

If someone tries to include and excluded id you should throw the which is more appropriate in this situation because the argument is valid but the operation is not so it's not a argument exception. 

Lastly I changed your algorithm. I don't think you need to multiply or divide anything. Just subtract the next largest denomination until there is nothing left. 

This might cost you a lot of performnace because if is a real deferred enumerable will enumerate it alredy for the first time. Then you'll enumerate it again consuming the result. 

Notice that I've also removed all the s and replaced them with a dictionary of s that get the property to be comapared. Now when you use it with a color there is no doubt what is going on here: 

The above method will of course delete only the last directory. If you want to delete directories that are empty after deleting the last empty directory you need to repeat the process: 

I don't like the properties. They look like a bad design. But it's hard to say more from the snippet you've showed. 

ColumnDelimiter & RowDelimiter If these two properties cannot be null you should requrie them via the constructor instead of checking them in the method. Also if the user can change them later then you should check the values in the property setter instead of throwing exeptions later and causing astonishment why isn't this working. 

This is a really bad idea. A repository should encapsulate the data access and make it easier to use. Usually tables in a database are related but if you split it into single table per repository you won't be able to use the relationsships. How are you going to join any tables? A repository represents a storage like a database not a single table. I really discourange from splitting it. 

You should try to avoid nesting and actually use the as an . This means you should put the condition for the loop where it belongs (and adjusting it of course): 

The class shouldn't be netested. I'd also add a factory method to it and make it much simpler like this and create an instance only when a lock could be accuired: 

Then with a small helper lambda you can encapsulate the first-image-or-default logic and use linq to retrieve the first image found: 

This looks like a really bad idea. Why are you getting all data from the database first and not filter it before retrieving? 

The last step is to put everything together, this is, create the calculator, read the the numbers and calculate the result or handle the exception if it wasn't possible: 

Next you modify the base client class to accept a list of notifiers and that requries the derived classes to implement the method (this is one of the Factory Patterns where the derived class provides something conrete for the base class - here just strings): 

The are those marked with - they are not the same as database keys and they are for aggregation later. 

This is very inconsistent. Once you use a full type name and another time just the and this interchangeably. Not sure which one is better? I suggest using everywhere. 

Overall I find this code is very messy and contains a lot of misleading names and comments. You should work on smaller methods with precise descriptive names so that you don't have to write comments trying to explain what you code does. Comments are to explain why you are doing something, not what or how. 

There's been a lot of questions lately about database provider and repository design especially without entity framework or alike. I thought I try myself to create a reusable framework for this kind of stuff. So let's begin ;-) TL;DR - There's an example at the bottom 

This comment would be unnecessary if you named the variables properly. For example instead of you could say . The method is also not helping. What does it mean that a path is valid? Is it valid because it doesn't contain any invalid characters or is is valid because it exits? You should decide and use the proper method. If you check if something exists then call it if you validate it then call it but with all the s and s such a long name might be a problem I guess ;-) 

Sometimes I need to get a single thing from a collection but I'm not very happy with the extension. It does not differentiate between empty and more than one element and throws the same in both cases. I find it's an important disadvantage and it helps a lot if you know excactly why and exception was thrown. 

Your class works the same way. It implements everything you need so you can either use it inline or to define new types. I find it's perfectly fine. 

I often write small classes to make undisposable things disposable so that .NET can handle something automatically, like stopwatches or logs. I thought why not write a small helper that can be used instead of implementing a full class for simple things. The requries two delegates, one for the initialization and the other one for cleaning-up. (null checks removed for brevity) 

This one isn't wrong per se but it's not any simple logic either. One in the wrong place and it doesn't work anymore. A unit test should verify this works as expected. Actually you can simplify this one too. You don't need the ternary operators here because you can just chain the experssions with 

I can't find any common denominator in both s. They are similar but too different. You could however refactor them into separate methods: 

Calling on this is counterproductive because this method returns directory names one by one (in a deferred fasion) as you go and request them. By using you go over directory names twice. First creating the array and then in your loop. The is a perfect candidate to be used with or with . For example this is on my machine with 20k empty directories faster by approx 3 sec then the normal loop: 

should not be adding new elements if the is used. The closest collection type that has a similar behaviour would be the but even this doesn't seem to be right in this case - a lookup returns an empty collection but does not change the lookup itself. I suggest naming it a and documenting the unexpected side effects of the getter. This collection does not need to implement the interface because you use only the indexer anyway. would be enough so that you can use it a loop. 

This event handler should be and if you want to follow event handling conventions then its name should rather be . By giving it a different name the readability suffers and in few weeks you'll need to look up how it's wired to know what it handles. Save your time by not using shortcuts and by giving things proper names from the very beginning. This was actually the only bad name in your code, the rest is fine. 

This way you could save a few loops over the buffer. Even better you could turn the buffer into a at the top and use it later to clean-up the code a little bit: 

The code mixes the hungarian notation - this actually should be becasue stands for - with the human notation: 

I think creating such objects is generally a good idea and I often do it myself but they have to offer me some advantages over using a primitive. In case of this code I don't see them and the examples you linked give bad advices. 

has become much smaller but it's still to large. The entire database code shouldn't be there. It belongs to a different layer. 

Now you can easily add more storages anytime and you can test the ones you already have without affecting the others. Their constructors require less parameters and are easier to use. 

ValidateAnimalOrder Usually when a method's name is then it throws an exeption if the validation fails. In your case it would be better to call it because it returns a . 

Why do you invent new names for the parameters? Isn't it easier to just copy/paste the one you already have for the columns? Besides with so many colums consider using an array and build the query dynamically. You can create an array with a collection initializer like this: 

You have a single class for all your methods. This is not an optimal design. You should move members that are responsible for controlling the same thing into separate classes. Every few methods you put comments like which are an indicator that a particual group of methods (or other members) should probably have their own class. Currently everything is connected somehow with everything else so it's virtually impossible to test it. They are also all but one method so they would not be even accessible to tests. You should strive to develop small units that are good at doing something and nothing more. Later you use these units to compose some larger units that can do more and more util you have a complete game. Other then this I think you use very good names and your methods are nice and small. I didn't check every one of them but they look like they were responsible for doing only one thing, which is again very good. Now you just have to give them a few smaller classes so that you can either test them separately or exchange them if necessary or even reuse them in other projects. Maybe some classes will be so similar that you can use an interface, who knows. I think this is what you should practice next. 

I'm assuming the css does not require any vaidation because it's been created and validated with an editor like jsfiddle etc. The result of is 

If you are doing this then the descructor should call because the finalizer has already been called. Then in your finalizer you should set the because if the GC calls it again later it will crash as the object has been deleted but it's still pointing to it. 

To support this new type a new was necessary. It takes care of deserializing the value and creating an instance of the and of serializing it by extracting the from it. 

You call here the delegate via an expression (the setter does the same). This is like you've just called the delegate. Use can use the expression to call the property directly: 

Bang! NullReferenceException! This will blow if is so make sure to check all parts of the expression. 

I wouldn't provide such members as or because they are very subjective and what for you currently is slow might be in my application still too fast. does not make any sense ;-) Why should I want to never try to execute something? I might as well not write the code at all if it shouldn't run :-P 

Alternative solution There is a much shorter way to get the same results. You could use two different regexes: 

WeightedGraph This class shoudln't implement any search algorithms. They need to be injected. Let's do this... First you change the signature of the method to accept an interface instead of a magic string: 

There is one more change that I've made. I put the cretion of a resource into a factory method of this class: 

Later in your application you can reuse it everywhere which would result in a nice short and clear code ba also getting rid of this ugly condition: 

Where would be a type derived from that carries your parameters. This has the advantage that if you later decide to extend it, you won't have to change each and every usage. 

Also the name is not a good name. What does it stand for? You should always use meaningful names. For everything. But even this is not necessary. You can enumerate a string so the loop could just be: 

You receive the object via the . This means that you should not dispose it. The owner takes care of the graphics object. You just use it for drawing. I wonder that this works at all because as soon as the graphics is disposed the DocumentDrucker has nothing to print. This should actually crash. 

Let me post another answer because this is completely different from the first one. You want to have it less messy so how about this solution? I introduced a simple class that stores the token char and its position. 

You already know that you cannot test this extension because is hardcoded so tests will yield different results each time. To overcome this problem you can make it a extension instead an all problems with testing will disappear because the only calculation that you need is to add the number of days and the time to the date. Then you take the advantage of the method for counting how many dates you'll get. With this you only need a single test that checks if the two additions work correctly. 

Most of the parsing work is done in the class by the methods. They build the regexes and try to match the values either numeric or literal. 

These two lines I think shouldn't be there because with them, the wrapper is tigthly coupled to the app.config. I see three possibilities how you can decouple the wrapper: