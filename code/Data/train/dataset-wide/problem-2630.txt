Your setting of should be immediately before the appropriate loop, not after it, and I would actually call that variable (renaming your to ) since it's not really a "count" at all, e.g: 

Did you turn on the Swift compiler's optimiser? On my early 2016 Macbook Pro (3.1 GHz dual core i7) your code runs in 15.5 seconds with it off, 4.1 seconds with on, and 3.3 seconds if I move any loop invariants outside of the relevant loops: 

The use of the as the return type from the function allows the return of 0, 1 or 2 results, depending on the coefficients. This class can now be used for non-interactive calculations - in fact I might even build something like this into my ray tracer since I've currently got a sphere intersection test that requires a quadratic solver but I'm expecting to need that solver in some more places too. Also note that separating out this functionality and removing the interactivity allows the class to be trivially "unit tested". 

As far as the code around addExtra: I wouldn't set $posts['Data'] to overwrite it immediately. Instead I would loop on the sql results and append to $posts['Data'] (IIRC the syntax is ). 

I'll criticise the general design of the function. can't accept general input, because that would produce invalid xml. It special-cases empty contents, which prevents it from being generally useful; there is no way to use it to get an empty tag (breaking a weak requirement of good APIs: making simple things possible). It only makes sense as a private part of a slightly larger program that produces valid xml, which you did not include. 

I assume you are aware of Chrome Canary, which I gather is able to use binary deltas? I don't think it's pure Chromium though. Your code is pretty clean. You could be using argparse for parsing the command line, currently you are ignoring flags that don't match. You could wrap the exit call around main, like this: , and use / statements instead. You could replace with , or pick up some defaults from the registry, but that's not necessary unless you plan for a larger audience. You could also reduce the window Chromium is unavailable by unzipping somewhere else, then moving the directories, then clearing the previous one (but I don't think you can make it atomic without something like symlinks or hardlinks). 

I'm surprised that no-one has pointed out the O(m * base) complexity caused by the inner loop that performs a linear scan over the (unnecessary) array. This version of the outer loop removes the inner loop, supports lower cased characters, and also breaks the loop as soon as any illegal character is seen. 

The point being that you should be setting the variable in advance of the loop, not resetting it afterwards (that being a pointless operation on the final iteration). I would probably also move into a class member, calculated in the constructor. 

Note also that now that the loops are the other way around there's no need to pre-create the objects that make up the array - it's initialised with an empty object in the first line of the outer loop. 

So, yes, I know that "you shouldn't derive from std containers" but by now it's more of philosophical rule in my mind than a technical one. I've googled again for the one fundamental reason one should never-ever-ever-ever-do-that-ever-ever-ever-or-you-die but couldn't find it. So, if there's nothing fundamentally wrong with the following and if we set aside performance considerations, can I a get a plain-old code review of this: 

Another call to the family. This is a plain copy and it will copy all elements where I tell it to. In this case, all elements will printed to standard output, with a newline in between. They will show up from the longest to the shortest. And we're done. 

Good. Now, I have to read in s from the user, decide if they are palindromes and save them in my special container. The following lines of code are quite compressed. It's a single statement that does all what I just described. 

listen in on someone else's sockets. read another user's files otherwise learn the secret execute random python code in your server And the inability for a remote attacker to connect to your socket. 

First option is best. It is readable and KISS-compliant. If you ever need to share a flight implementation, you can write a mixin. Also, unrelated, you should look into RAII and get rid of these assert/new/delete. 

Make yourself a "template" that you immediately convert into html (using innerHtml or whatever your framework has handy), then use the dom to fix up the few variable bits. You may use ids to locate the tags that need substitution, if you can guarantee they are unique. Otherwise use XPath. 

The important thing you want to enforce is that only the same local user can see the hello world. You're relying at least on the inability of any random user to 

I offer this code as something to look forward to be able to write in the future, not as something I would want you to come up with right now. What you have is great for someone at your level of C++. The most important aspect of this code is its use of . is a container that keeps its element ordered, even as you add more element to it. It's contents will always kept sorted. By default, will perform it's duties by comparing elements with a plain less-than comparator, i.e. . So, by default, a will keep a bunch of s ordered from the smallest to the greatest. Though that's the default, you can change the comparison function. The standard library already has some options ready for you to use. For example, to keep the s sorted from greatest to smallest, use instead of just . But what we want to do here is keep sorted according to their length, from longest to shortest. The standard library doesn't have something ready made for us but we can follow the example of . It would look like this: 

General SQL-related advice: I would factor most of these queries into a single view; you can then add WHERE parameters when selecting from the view. You can also remove the few instances of variable expansion inside the queries, and replace them with named parameters throughout (you have already). For example: 

1, 2 and 4 depend how well you've secured your system (no privilege elevation or random suid files lying around). 4 also depends on the security of flask and the rest of your python stack. Five can be broken, depending on how your firewall is configured (someone could use connection tracking to get your socket forwarded, even though it is bound to localhost). You'd be better off using unix domain sockets. The second is broken, because you chmod the file only after you've written to it. That gives a window for the attacker to open the file. In fact the attacker could even write to the file and execute arbitrary commands, which is why you should never use os.system, and you should use urlparse to build the url. The third is broken in two ways: 

Again, I don't expect you to grasp this fully. Just keep it way in the back of your head and revisit this post in a year... Ok, so I have my custom-made comparator. I can declare my container that will hold the palindromes. As I add s to this container, they will automatically be kept in sorted order by length. But wait, here's an important detail, it's possible that I may have more than one palindrome of the same length! No sweat, use . It does the exact same thing as but allows multiple values where the comparison will say they are equal, i.e. of the same length in our case. 

I will add one last thing. The fact that I use a (or ) does mean that this code is doing a bit more work than what you needed given your problem statement. That is, you did not necessarily wanted to keep all the palindromes sorted, you just wanted to know which one was the longest. But I offered this solution as an example to leverage stuff from the standard library that can do a lot of work for you transparently.