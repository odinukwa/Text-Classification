And maybe even change the naming for . Also, checking for Straight beforehand is not necessary, as your code checks if it is a flush and later checks if it contains , , , , and anyways. will take about the same time to run as , making the possible performance gain from a evaluation not worth it. Others In 

As @janos notes, more spaces. Why is it a class? Since the class is not used outside of your program, make it either or default level. 

And there you go, small methods! As for the extra methods, I think they are unnecessary. Final code: 

Put spaces after the commas; this will make it easier to read. Naming Usually, setters' method names begin with . It is also suggested that it is so. should be . Immutable Class Suggestions 

You can just as easily return in the inner statement immediately, without going through the checks in the loop: 

Putting it together, I get: $$O(\frac{n(n+1)(2n+1)}6)$$ I am not sure if I'm right; correct me if I'm wrong. Since , , , and are not significant, we can remove them, to get: $$O(n^3)$$ I can't think of a better algorithm, but maybe there is one. I will concentrate on the naming of your variables, and other conventions. Formatting All right, time to complain about how bad your formatting is, part by part... 

Well, read on! Immutable classes should not have any methods. This is because an immutable class should only represent objects that don't change. If a person needs to be changed (not likely though), then the most obvious way to do so is to directly call the Constructor for a new Object, as a person with a different characteristic would not be the same person. 

I was recently given a Sudoku Puzzle to solve, and since I began solving many Sudoku puzzles after, I decided to attempt to create a Sudoku Puzzle viewer with JavaFX. I am not done yet, but have decided to split it into parts so that it is easier to fix future problems. Part 1 is the class. The class does: 

A couple of problems: Line 2: Space between and Line 2: Space before brace Lines 3, 5, 7, and 9: Newline can be removed but may be left in wanted Line 11: Space before brace Lines 13-14: Should be merged Line 15: Space between and comment Lines 17-18: Should be merged Line 23: Space between and Line 23: Space before brace Line 25: Space between and comment Line 25: typo, I assume? dont -> don't Line 28-29: Should be merged Line 30: Space between and comment Line 33-34: Should be merged Line 37-38: Should be merged Line 41-42: Should be merged Result: 

Even though it saves a lot of lines and typing, it's at the cost of performance and readability. Import each class individually. 

variables No, no, no. Rarely should you use static variables, such as a class constant, or something that needs to be when there is no other option available. You can easily redesign your code to not need variables: 

In the statement, if you don't put a new line before the method brace, you shouldn't put a new line before the brace. You are inconsistent in order. You set the foreground color first in one, and the text in another. Be consistent. You should put 2 new lines between methods, and any non-related lines. It is recommended to have a space after the . 

The biggest problem I found with your code is that IT DOES NOT DISPLAY ANYTHING. The constructor, according to Java SE 8 Documentation: 

Naming What's ? How about ? What is ? Why are they one-letter names? One-letter variable names are not good, as they are confusing to understand. The only place you should use them is, for example, a loop counter. Change: 

Well, it really isn't a big pain: but I fear of security risks (if that is even possible). Background: I decided to (sort of) abandon my Sudoku project (because I accidentally deleted it from disk), and was given the idea of a JavaFX Helper Library. I started with the , as I find I use login popups quite often. The code is here: 

Many of the board's methods require you to pass a object as a parameter, whether you are calling , or if it is . A position simply is two integers, stored in an object: 

Here, you have some shortened names, like , and extended names, like . Names should he concise, but understandable. Try: 

Naming should be : names are concise names that shouldn't be abbreviated. could just be . I know you are using a , but is a more readable name. Final Code: 

The colour of your font, as well as the font itself (which has already been mentioned), makes the text hard to read. Try something more simple with the font coloured as black: 

Create a new that holds all the numbers from to the first integer in the array. Loop through each difference. Set to . to the first integer in the array if it was not already . Check if the first integer in the array is . If it is, return , otherwise, return . 

I don't think creating a object is necessary. Instead, there is a method that returns a object, which stores all the necessary solution information. is now the overrided in . It seems slightly faster (2000 miliseconds -> 1500 miliseconds) 

First thing's first. Never catch . Always catch the specific exception that might be thrown. In this case, (I believe). Next, it can be improved by using Java 7's try-with-resources: 

Because does not need to return , , or . It returns , , . If you want to retain your way of result, use : 

And you can possible warn the user about only requiring one argument if they provide too much. Something like: 

If you don't understand why this works, all the AI does is counts up to the next multiple of 4. Why does this work? Well, this is what happens: 

Here, you calculate , add it to a , and then return the minimum in the . It can be faster if you have a variable that holds the minimum of s: 

At first glance, this makes no sense. These numbers are more like magic numbers: make them a constant: 

The issue with that code is that everything is in the method. Another issue is that it doesn't follow any OOP principle. But first, let's fix the code. A lot of it can be replaced with ternary operators. 1: 

Your solution seems to be the most efficient, except for the fact that it doesn't seem to work. You could try finding all possible groups like so: $$18=4^2+1^2+1^2$$ $$18=3^2+3^2$$ $$18=3^2+2^2+2^2+1^2$$ $$...$$ Then find the smallest group. Your code would sure like some space. After some nice, wide spacing: 

But most of my complaints (apart from the Exceptions) now don't really apply to the new answer that @rolfl has given. Just keep in mind of these things when writing some other code! 

I don't really like seeing empty statements in Java, as there is always a way around them. It's my opinion; you may think different, and that's fine. 

Declare variables where you need them, not before. Multiple declarations on one line isn't very readable. 

Some points: Formatting Your formatting is a bit hard to read. I have fixed it for you, but keep in mind of these standard Java Convention rules: 

Note that this is adding to @EricStein's excellent answer on normal concatenation instead of s. (I'm just starting to look into , so if this is bad, please comment on why) Otherwise... Just a small comment: 

One word to describe this: inconsistency. Be consistent. Either have a newline, or don't. I suggest not have a new line, as it wastes newlines, and doesn't it make it a bit more readable. It also follows Java conventions. This crazy code: 

You have a constant, which is pretty much a . You use it to append. Instead of doing that, you can easily append the char itself, which saves a String creation. 

There are tons of areas where there is more spacing required. Try to fix all of them (without over-spacing). Braces 

Yes, I know it looks 10x more complex than it need to be, but this can be used for further applications. Since you asked for an explanation of the array... The separator's array is there so that the method can know where to separate it into buckets. For example: 

Also, the extra spaces you added for line three of that snipped can be removed without affecting readability: 

Horrendous useless methods... Use a instead; it's pretty much the same thing, the only difference being you don't need to specify all the methods: 

Though this program tells the truth (unless you change the source code), it does tell Fibonacci numbers, depending on the user's input. Keeping in mind of all (or most) of the feedback given from previous questions, I wrote this program to see how well I have progressed. 

Since Java 7, there is such thing as a try-with-resources statement, which automatically closes the reader when an exception occurs, which you are not doing here. Your current code has memory leaks! With some other improvements: 

I know you wanted it without recursion, but I only came up with a solution by using recursion. If you really don't want to use recursion, then your code is fine. 

Notice that vertical checks are easier, due to the easy creation of a with a array. Horizontal and diagonal is similar in structure. 

EDIT: The above review, if not using Java 8, should be replaced by @EricStein's code. Also, is a bad name. Try . 

This code seems to be a specific BucketSort made for a specific program. I would instead create a more generic BucketSort: 

In , my code will still iterate over the remaining elements even if the array is already sorted. To break out at a solved array, I should do: 

In , all I see is a mess of code. What I want to see, or what I should see, is a properly formatted code: 

Remember that s are immutable. Since is concatenated multiple times, you should use , and add s with . All the code in the loop can be at least broken down into two methods. But before we do that, the variables should be instantiated outside of main, with . 

into into into (or, optional: remove the n variable completely, and directly use either or the number itself, or change it into a constant, as I will do) 

First check if the element being attempted to be added is . If it is, throw a , as I want the list to be "-free" (Only because can't really be compared, because it will throw a when attempting to compare). Increment . Check if the list is empty (i.e. if the Node it ) If it is, create a new with the value of the added element and set it as the first. Otherwise, loop through the elements in the list until one larger than the element attempt to be added is found. Then, add the element there. return . 

Thoughts I think they are both equal at 1000, but as the numbers get larger, the first one will slow down significantly. 

I was recently learning about and how they work in lists, and to test myself, I decided to write my own implementation in Java. Then I decided, that since there is already a LinkedList out there, why not make it sorted? So now it is a . 

But it didn't work, so I did it on my own, ending up with: $$x_{n+1}=x_n-\frac{{x_n}^z - y}{z{x_n}^{z-1}}$$ My guess is that either I got it wrong, or the person writing the formula made a mistake in simplifying. Is my JavaDoc good? I feel like it has some redundant or missing information there... 

fields are usually . You do fine with that everywhere, but here... should be . EDIT: I know that you don't like the spacing, but I will leave it here as a reference as it is the standard java conventions (eclipse formatting implies that too). 

A couple of things: Indentation Indentation seems a little off in your question. Is this because of formatting issues when copy and pasting from your IDE, or is it your code? Most IDEs have a format function that formats the code for you. In eclipse, that is found in -> or the keyboard shortcut . Spacing You have what I call overspacing: 

Your variable names are very hard to understand. What's ? Distance? Then why is it an array? What's ? Visuals? Why is it a 3D array? Make your variable names clearer, and add comments what it does. Also, there is inconsistent spacing. You do stuff like: 

It is in fact pretty good code, just some small nitpicks: Order The fields should go before the methods; in fact, it should be near the front of the class, only after the and fields. Conventions This piece of code: 

Note there is two methods; one is for a class that implements the interface, and one to allow a to be passed as the for the class, where there is no comparator, or if you want to compare it in a different way. Then the only problem is that you don't know the bounds for the buckets; the simple way would be to use bounds provided by the calling method: 

Straight Flush Checking - Two things gone wrong here. a) You're only checking for a Straight Flush in the flop. What if the Hand contributes to a Straight Flush? b) Don't feel bad about this one too much; this is a common mistake that even I made when writing a Hand Evaluator (I figured it out and decided it was way too hard; so I gave up). , , , , as flop and , in the hand will return (after you edit it so that it checks both the hand and the flop), even though you see that there is no Straight Flush. 

Then replace all the with length. What does exactly mean? Use a more specific and more detailed (but not too much) variable name, such as . The is completely unnecessary. Instead, use : 

Standard conventions for class names are PascalCase, not camelCase or alllowercase. Also, I think all your variables need some breathing space: 

Choose one and stick with it. I suggest the second option, as it is easier to read. Your method looks nice, but statements without braces makes me nervous. Try: 

Since also has to deal with stuff like \$2^{1.5}\$ and has to use a more complex algorithm to figure out the result, so a simple recursive algorithm can easily be more efficient than . 

is not only a bad name, it is also hard to read and understand. Cramming too much information in names is bad. Sure, names like are bad, but so is . That's what class-level javadoc comments are for. As for readability, java class names are in PascalCase, and method and variable names in camelCase. I suggest , and you can add a short comment about the class at the beginning, like so: 

I suggest you use instead, because uses arrays to store variables, and since arrays have a limited space, when you run out, it will create a new array and move everything from the old one to the new one. This takes a lot of time, and doesn't do that. You should also add a serial version ID, because that will then save the time the compiler requires to generate one for you, like this: 

This is because quicksort is \$O(n \log n)\$ while bubble sort is \$O(n^2)\$. How I would do quicksort: 

The first thing I should say is that your code looks very messy and requires "cleaning up". I don't know for sure if this is because of formatting problems when transferring from IDE to Code Review, but if it is not, then formatting needs work. After formatting, it looks like this: