Since changing trhe data type in the column is not feasible, the above query has been edited to do the conversion in just one pace... Here's the from/where clause if the table had numeric .... (Replace the original from and where clause ) 

So, if the suggestions from your reviewer are consistent with the common-practice at your location, then, absolutely, do them. Even if they are not common practice, still do them. But, I have some comments to come after a small diversion..... 

are not efficient when it comes to Linked Lists. Those lines would require a scan of the entire list because are not suited for high-performance random access. An would be fine.... but, you don't always have an Additionally, note that there is no reason why you have to fix the Generic type at . You force your comparator to do an "auto-unbox" of the values here: 

Other issues I have with your code are the exception that's thrown in the event of a window size that's larger than the data. That should not be an exception since there's an easy, and logical solution, which is to just return the input data as the result. On the other hand, you treat the with an if it is even, and that should be an instead. If it was me, though, I would rename the parameter to be "shoulderSize" instead, and that would make an even number impossible to provide. (a window of 1 would be a shoulder of 0, and a shoulder of 5 would be a window of 11, etc. One final note, is that it's often easier to solve a synchronous problem first, and then wrap it in a neat asynchronous pattern afterwards. This also helps a lot with testing. So, putting this all together, I would instead have your code similar to: 

This has some advantages. The first is that it becomes easier to separate Server problems from client problems, and the second is that the can be easily moved off to any thread we want to use. Right now, using a single thread is probably fine, but, the Error handling would be much better with this distinction. Consider the following: 

Note, that while we are there, you have one of those wtf moments in your variable names. the name is a really, really bad name. is very easy to confuse with , and should never be used as a simple 1-letter variable name, and then, to make it worse, you put them together? Huh. 

That's the progression we want to follow. We increment the right-most digit. If it becomes 3 (the number of characters), we set it back to 0, and move 1 digit to the left. If these were decimal numbers, it would be the same as there being 10 characters in the alphabet. You can think of the logic you would go through to roll 999 to 1000. Add 1 to 9, it becomes 0 carry 10. Add that 10 to 90, it becomes 100 carry 1000, and that's the result. That's what the inner loop does... it starts at the right, and adds one, and carries it back if there's an overflow. The overflow is configurable though, by the number of characters in the alphabet, and the number of digits is how wide the value is. Each time it changes a value in the array, it copies the corresponding char from the alphabet back in to the . So, if the last password was we will add 1 to the last char, which 'wraps' it back to but we also then loop again with the next char, making it with another loop making it . The is not an overflow, so that's the last of the inner loops. Note that, because count is strictly calculated, the inner loop will never have a negative overflow.... 

This will save a lot of performance. The second issue is the 'convenience' of using a try/catch block for the ParseInt. Creating, throwing, and catching an exception is a surprisingly slow and complicated process. Using a try/catch as part of a 'routine' code-path is a mistake. Especially in something as frequent as a compareTo method. You should first make an attempt to see whether the input has a small hope of converting before throwing an exception: 

Like @palacsint I will recommend an external library. Apache commons-cli is a decent choice. Another choice (my preference) is java gnu-getopt ... I like it because I am familiar with the notations and standards from previous work. It can be a little complicated the first time around otherwise. On the other hand, I tend not to use an external library unless the code is already going to be relatively complicated.... But, back to your code. Why do you have everything in a single String? Why is it not part of the ? The first thing about command-line arguments is that they get complicated very fast. What if the argument was: 

Then, in your loop, you set the limit at 3399 ... why? Well, element 3399 is prime 31607 which is the largest prime who's square (999002449) is less than 1000000000... OK. So, you have magic numbers.... I would define them and move on... having them as constant numbers in the code is confusing. Bugs Your code does not successfully output 2, ever. You need to work on that edge case. Variables The names are all wrong, except the array . I would use instead of , as it is not a classic for loop. and are meaningless.... use a variable name that makes sense, like and Performance There are two things I can suggest to improve performance.... 

Now, you can use that to get the ID and solution, once you have the instance you need. To get the instance, I would go the traditional route of adding instances to an array: 

newInstance() This code will work, but only for a subset of Collections. For example, there are many Collection implementations that do not have an accessible default constructor. What if the input collection is: 

OK, the above code will check whether the characters between two points make up a palindrome. Note that it does not need any new memory structures like StringBuilders, Strings, etc. Putting it together How would you use that? Well, consider this outer loop: 

Variable naming is very important for readability. Now, as some background, when I first saw your question, it had the title: 

Now, that's a method that wraps up the not-so-convenient Exceptions that JDOM throws when there's a problem (Exception handling in Streams is going to be an ongoing PITA in Java - how to handle checked exceptions...?) That method has a different behaviour to your code, it throws an exception if there's a problem, but it also alerts the presentation layer. I am not certian that's what you would want, so remove the onException calls if necessary. Note how it is a traditional method. This allows the logic to be easily called from either a Stream, or traditional context. If you want, you can also: 

There are two issues here, both are related to the fact that only counts the number of characters in the input - where character is a 16-bit value. The first symptom here is for wide characters which your code anticipates, are 2 characters wide, but are only one code point. Since your code deals with code points, it should only treat the number of code points in the text, not the number of values required to store them. The second symptom is that your text may not be similarly represented. A simple character like could be represented in multiple ways in Unicode, with some of them requiring "combining character sequences" to append the accents to the base character. In other words, the input string that looks like may be one, or two characters long..... Also, not all combining marks can be composed in a single character. Unicode is complicated. The bottom line is that your very fist step in your code makes assumptions that may be untrue, and as a result, your code will possibly choose the wrong input as being the shortest, and, subsequently, report the common characters in the wrong order. Big Bug 2 By the way, this same issue results in another bug - you may not identify common characters. A Character using combination marks in one input string will not match a character in composite form in the other. Here are two additional test cases you need to solve: 

By performing only two scans through the file (the first is a full scan, the second is an in-order-but-random-and-selective scan) you reduce the amount of times you process the data. In your current system, you are scanning the file many times (once and then an additional one for each KEY_FRAME record and an additional one again for each second...). The loops you have at the end are very costly: 

EventHandler I thin kit is naive to have the method have no error handling (it swallows all exceptions). I think you should at least document that there is an unchecked exception thrown from the method.... (these are significant problems) like: 

That would also remove the ugly exceptions you declare to throw... as it is, I would probably (bad practice) 'try' the whole loop, and 'catch' the ugly exceptions and replace them with a wrapper of an that explains that an inner Collection could not be instantiated. General Overall your method is neat, and well structured. I can't really fault it, given the constraints of the problem. Update: Actually, the method should have a lower-case 's' to start the name. How did I miss that the first time? Should be not I would prefer that the method declared the input as : because that is a habit I am in... Typically I would recommend against returning the data typed as an because the implementation should not be reflected, it should just be , but, again, in this case, the specification requires an ArrayList return value. Bonus A Java 8 implementation of this would be a good exercise. This is what I would try: 

When you use a class in a 'hacky' way, like you do by using a PriorityQueue as a TreeSet, you should make sure that you document why the class is used, and what properties of the class are being leveraged. 

Because your code uses the StringBuilder.insert(0, ...) mechanism, and because that is an \$O(n)\$ operation (because it has to move all the other characters that come after the inserted value), the overall complexity of the code is not \$O(n)\$, but rather \$O(n^2)\$. Changing to an append will bring the code back (closer) to \$O(n)\$, where each character is copied only once.... See the differences between: 

Sub-Categories The sub-cateogory option is not awful, it is done by grouping related parameters together. For example, the two times could be one class: 

This is a decent concept, but by looping on the you loose some of the value of the function in the shell. For example, I often use the special construct in a shell, and that changes directory to the one you were in before. Your code will make that impossible. I would instead recommend that you instead build up a chain of string values, like for 4 directories, and then just call once, which will preserve the function, and the . Additionally, this would be a good feature to include as a function in your code, rather than a script. Bash shell likes functions, and they make life easier. Finally, if someone supplies a non-number as an argument, it will do odd things. I played with your code, and came up with: 

That function takes an input function and the test data as an argument, and returns the String summary as a result. You would use this function like it's used in the main method.... 

This code would benefit from a variable...... and it would also benefit from being real code, not this hypothetical example..... This code is also really short, so it's hard to simplify more. Still, using a foreach is better than the indexed iterator, and the logic is more obvious with named variables, rather than indexes... so: 

Being particularly pedantic, but I have the following observations: Annotation @Event You go to great lengths to document but not to document the setting .... just saying... The priority is the sort of thing that needs documentation... is priority == 80 more or less important than priority == 0? EventExecutor 

Which requires 1 character, and then up to 18 'broad' characters followed by a constrained alpha/digit character. EDIT: 2 things: 

Note how there is no need for the days-in-month list/set at all? Also, note how I rename the 'inputValues' members to names that make sense. 

As an example of a singleton 'best use case', this one has some problems... ;-) But, that's sort of OK, since Earth has problems anyway!