That is an inefficient way of doing that. Instead, make Triads a set and put tuples rather then lists in it. That'll be faster and easier to read. 

Don't catch all exceptions, you'll hide bugs that way. Instead, catch only the specific type of exception you are interested in. Also, you want as little code in the try block as possible to avoid catching other stray exceptions 

The problem is that if someone passes frequency along with one of the other parameters, this function will go merrily onwards and probably not even produce an error. I recommend having a get_LOS_from_frequency function which takes the frequency and then calls this function. 

Use for source, dest, value in row: li.append(float(source), float(dest), float(value)) Do you really want floats? Are the source and destination really floats or are they ints? 

Don't report error by returning strings. Throw an exception, or at least assert False. How I'd do this: 

Create a list with a single element, putting that in a set, simply to call issubet is silly. Use Edges[i][j][1] in firstgen. 

You should be able to find and change the edge weight directly. Reconstructing the whole graph is going to be kinda slow. 

Your math seems inscrutable, but perhaps it makes sense in context. Consider some comments to explain the reasoning 

I recommend putting the comment on a seperate line from the if. Otherwise it tends to wrap off the side of the screen and that's annoying. Also, iterate over the container, not the indexes. Use something like for source, dest in edges: 

Rather the constantly checking whether a value is in notr, use a set. Then the last three lines can simply be notr.add( xrange(om + 1, cm - 1) ) 

No explanation is given for what you are putting inside found. I have no idea what the return value means. return found General thoughts: The code is complicated, it really should be split up into a lot of functions. Rather then all that code matching different types of comments and strings, have a set of ignore regexes. The regex should match an entire comment or string which can then be removed. Your code builds lists of everything which would only serve to complicate what is going on. Lists can be great, but they aren't the solution to every problem. My rewrite of your code: (I didn't start with your code, but it should support the same features:) 

When the reader sees the first one, he needs to remember what "m_firstMove" meant. On the other hand, if you read "isThisTheFirstMove" you are given the whole information and you don't need to go to the declaration of the variable to see what that means. 

When I read the last one, I had to figure out "how" you were doing the thing to know "what" you were doing. Note that I did not write the method but you get the Idea of what is happening. Considering . Is it necessary to know that the initial col is 2? or Should I only know that you are moving to the next line if the line wraps? It reads more like "well written prose" (as Uncle Bob in his book 'CleanCode' says) You can do similar with the block. In the method , I think the correct name for the parameters is and instead of or given that they are not changes but just absolute values. This statement in the update method could be its own method 

Regarding the code style I have some observations. This is based on the book "Clean Code" by Uncle bob and my experiences as a software engineer. 

The names 'txtX' and 'txtY' don't say anything about the domain as 'line', or 'length' do. Someone would need to see how are you using that variable to figure out what it is. If you want to make the code more readable, make explanatory variables and helper descriptive methods for example 

Not only did we eliminate the need of a comment but also we increased the readiblity. In my head it goes like "if m_firstMove" (...what was that?) "// first move" (ah if this is the first move) you are making the reader stop and think what was the variable with the weird name used for. but if we read "if isThisTheFirstMove, then play the first move". Easier for the reader an cleaner code, showing intent and maningfull name. You should take a look a the book "Clean code" by Robert Martin. You could improve method names, Take a look at your method and variable names. Another piece of advice that I could give you is this. Consider, 

In your example, you have two passes over the list - works in linear time unless it operates on random access iterators. A naive way to fix this is to calculate the number of elements inside your loop and check it afterwards. But this way you'll pessimize performance for random access iterators. To avoid this pessimization you can examine the of you at compile time and decide whether you're going to call or count your elements in a loop. The simplest way to do this is in C++14 is by tag dispatching. Here is an example: 

Notice that you don't have to perform any checks on the stream this way. Once will reach the end of the stream it will set the on it, so the loop condition will evaluate to on next iteration. Next, use can use to find an index of the occurrence of the character in strings filled by : 

This function is immune to memory leaks since it doesn't perform any explicit allocations and is guaranteed to give you the desired "50/50 chance" ( won't do the trick). The only catch is the dreaded specialization, but in this example, it's not going to do any harm. 

First, you can use to extract key-value pairs from the original string. This can be done by passing as a delimiter to : 

But that's not everything. The 's arguments are either copied or moved, they are never passed by reference. Thus, despite , you might end up copying your arguments. To void this issue, consider using perfect forwarding (as well as ditching ): 

Notice that you can omit the second argument of , since it has the default value of . This value is very huge (in fact, it equals to the maximum value that can be represented by a size type of ), but never reads past the end of line, so everything will be good. Tie all this together and you'll get a small and readable solution: 

Why not use the string search functions rather then having built a newline list? Also, if you need to treat the end of input as a newline, put that in when you create the list not in an exception handler. 

Don't execute loop at the module level. Code written inside a function will run faster. e = random.choice(li) # Choose random edge 

np.ones, returns an array. There is no reason to pass it to np.array afterwards. If you aren't going to use the ones you store in the array use numpy.empty which skips the initialization step. 

The python style guide recommends lowercase_with_underscores for global function names. The name also suggests its a generic summing function which its not. No indication is given for what kind of data it expects. A docstring should at least explain that. 

What you should consider doing is writing a function which given a node calculates the change in "energy" that would occour if it was flipped. Right now you calculate before and after, but you should be able to simply calculate the delta without changing it. If you can effeciently calculate the delta, that's all you need. 

Use sys.exit to indicate success or failure of the program. file is a builtin python function, its best to avoid naming your variables the same thing. 

I have to recommend against r, as its not a common abbreviation and I think it makes the code hard to read. 

I'd store these values in a list which makes it easy to pull them from configuration at a later date if neccesary. 

Use the enumerate function. It lets you use a foreach loop and get the indexes at the same time try: cm = next(v for v in cl if v > om) + len(mn[1]) add a line like: start_comment, end_comment = mn, that way you can avoid the indexes are your code will be clearer. 

you can sort of guess what is . Is it the position of the text area? why just don't just put and , not perfect (I mean, for sure there should be a better name) but at least it improves a little the readability. In the book "clean code" you can find "A name that makes you go into the code to see that it tries to identify, is a bad name" That's all I would recommend based on the book and experiences I've got as a developer. Happy coding! 

If you did that with every awful-to-read if statement, the method would be less than 10 lines and would be easier to read. There is a LOT more to cover, but I would spend my entire night doing it. However, this hopefully gave you a starting point of improving your code readability, please take a look at the book and Happy Coding! 

Note that we won't need a comment to explain the variable because its name does it! One of the advantages of this is that whenever you see the variable you see the complete information. Compare 

A collection should be plural, and names should be in English. Here we see and example of what I said 

Which is a LOT clearer and you don't need the comment because the method speaks for itself! The next else, 

If a name needs a comment to explain it, it's a bad name! What does m_move mean? "cpu's move" isn't a good comment. By the way, there should be as little explanatory comments as possible and "cpu's move" does not explain what is the variable meaning. Does it say if it is the CPU turn? or does it say how many moves has the CPU done? No one can tell.