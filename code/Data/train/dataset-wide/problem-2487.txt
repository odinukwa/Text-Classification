I was going to suggest that you use a header element, but then I realized that this isn't a header, it's a nav element. You should use the semantically appropriate elements whenever possible. s are supposed to be for formatting purposes, when there is not a more semantically correct element available. I like the choice of an unordered list for the links themselves though. Now, this is a , but you didn't add the tag. 

That ternary condition has no place in a function called . I would try to keep those separate. You should be able to call on any array of numbers. 

Etc. The Boolean is unneeded. If you were calling more than once, I would say to leave it, but you're not. So don't. 

Without declaring and setting a new instance of the class. It's a cool feature, but it's not what allows the list to be iterable and you don't need it here. The is what allows the syntax. The method doesn't need to . Drop that line and just set it to a new instance of . Lastly, I find it really odd that you have a list with no way to get an element back out of the list. We can add and remove items, but not retrieve them. I would rethink implementing an method. 

You're not always using in what I think of as a good way. We should only use the keyword when it's obvious what type the variable is. Consider this line. 

Don't bury all of your private fields at the bottom of the file. I almost voted to close this question for being broken because I thought they weren't defined anywhere. Most developers will expect to see them defined at the top of the class. Also ditch the prefix. It's unnecessary noise. Use an underscore if you like, but no more. Even using an underscore to denote private fields is a debatable topic. You also missed filling in some documentation here. 

You could create a generic abstract base class to inherit from. I wouldn't, but I'll get to that later. First, let's look at the base class. 

Well, first off, it's much better to wrote actual unit tests instead of manually verifying by reading output from the console. This is a bit of a tricky task, so it would be nice to know we're getting the correct output as we make changes to the method. The second thing I notice is that you repeat this logic a lot. 

Unit testing in VBA is... lacking. (What isn't lacking in VBA though?) Since I've become more interested in unit testing lately, I decided I needed something better than , so I started building this framework. Currently there is a ton of functionality missing, but since I'm new to unit testing and interfaces, I don't want to get too deep before realizing I've made a huge mistake. The code is simple, but works just fine. I want to be able to run the output to either a file or the immediate window, so I created a simple interface that contains one subroutine. IOutput.cls 

It's much better to use proper constructor injection of dependencies. That makes it crystal clear what is needed to make your class work. 

But does it perform? Well, actually, yes it does. I wrote some benchmarking code and it turns out that the Linq version out performs yours by quite a bit. I was kind of surprised by this, but here are the results. 

Personally, I would use constructor chaining instead of setting the same backing field from multiple constructors. 

I maintain a VBA process that prints a large number of PDFs. It was awful when I inherited it and I've been making improvements over time, but I'm a bit stuck on this one. There are at least 4 functions with this exact same code used to check to see if the program has been initialized properly. They could all be called individually, or together depending on circumstances. I do not want to initialize again if I don't have to. Hence the check in every subroutine, but I just can't figure out how to do it any differently. Thoughts? Is there a design pattern to deal with this kind of thing that I don't know of? Please try to focus on the pattern and not the supporting intitializer. I know there are a few issues there and intend to deal with them soon. I included it in case it was relevant. Main code: 

In my opinion, your view is doing too much work. This is happening because your model is missing a property. If you add an property to your model, I think we can simplify the view a bit. 

Those comments are obsolete. Remove them. They only serve to confuse the maintainer 6 months from now. The other issue there is that you really shouldn't be writing code just to "make the compiler happy". The other big issue I see if your use of as a magic number. You've effectively hardcoded yourself into a corner. What if you sometime later wish to make your grid larger, or support multiple sized grids? You would have to make changes to no less than 5 lines of the code. Minimally, you should create a constant and prefer it over the hardcoded number six. This would allow you to make one change that cascades through the code where ever appears. With that all said, you are doing something very right. Your style and naming is great. The only thing I would change there is and . I usually advise against shortening variable names, but I find those to be overly verbose. and would be just as crystal clear to the maintainer. 

So, what does this function do again? Does it leftpad a number with zeros, or does it strip them away? It does both and that breaks the single responsibility principle. Kind of... You could rename it and then its name would reflect it's one responsibility. The only problem with that is we already have , but I'll get back to that. First, I want to talk about this. 

Ok, so I only touched on the "Simple Form" (and just a bit on resources), but I suspect I could only give more of the same kind of advice. So, I'll leave the rest of the code for someone else. 

VBA suffers from a lack of proper inheritance and we have to make up for it with composition. In a sensible language, like Ruby (hardy har har) or C#, I would create a class that implements and would then inherit it's method. Like I said, that's not an option. So, have you cleaned it up, or made a mess of it? Yes and yes. You can now cleanly dispose of your presenter, but it's not so clean underneath. Interfaces shouldn't implement other interfaces, as you've noticed it's nonsensical. Remove all of the dispose code from . I'm confused by your assertion that Implementing more than one interface is a pain. It's exactly as it should be. What you should do is create a class that is responsible for defining common code. In this case, the Dispose method. Here is an extremely stripped down example. and should remain the same (with the exception of removing the disposable code from ). PresenterBase 

First, let's talk about what I consider to be a bug in the fraction class. Running this code results in an Overflow error. 

Instead of storing all of the CalendarIDs in project properties, it is much better to store them in an array variable and create a UI to allow the user (me) to select which calendar to work on. This means I only need one Project Property . 

Do some defensive programming and check all of the incoming args before the real work of your method begins. If something is out of range, or otherwise invalid, raise an error with a meaningful and clear message for the developer calling your function. For example: 

Which brings us to the loop. Friend, that is just awful. You've intentionally created an infinite loop. Once the is called, it never exits. Never. The only way I can figure to kill this is to open the task manager and kill Excel. What you should do is have a loop that exits when the game is over. For example, consider this code where is a function that returns a boolean. 

Okay, now you can skip the Replace and split directly on . Speaking of, that string seems to show up an awful lot. You should replace it with a constant. 

This has been my exact approach to exception handling in .Net and it's served me well so far. There are times when you just know that you may get a or an , but generally speaking, you really don't know what exceptions are going to happen until they do. What you shouldn't be doing is this. 

I'll try not to duplicate advice, but seriously, use an error handler and make sure the application gets set back to a workable state. There's nothing more frustrating for a user than to end up with a "frozen" instance of Excel because screen updating has been turned off. 

That's the faithful translation. I would find out if the requirements can be adjusted to only return the records that are in error. If the valid records are of no interest to the business, then something like this becomes possible. 

This way reduces (no pun intended) each step of the problem into a simple function and applies each in turn. Get comfortable with the filter/map/reduce concept. It greatly simplifies your code. 

Now, you still actually load all of this from the same view, and still all at once (although, now you have the option of going to the database for any one of these objects!). Now, you just create each of these objects from the view data and add it to the PDV. 

This seems to be in violation of the Single Responsibility Principle. It does two things. It prints a message to the user and returns the initial value. I would much rather see your main routine look something like this. (Remember, I don't know Java, consider it psuedo code) 

I have an SSIS package for SQL Server 2008. In this package, I need to verify that a file exists that matches a pattern of where the wild card replaces a date. It doesn't matter what the date of the file is, just that any file matching that pattern exists. If a file does not exist, I need to fail the package before using the built in "For each file loop" task. This allows our server to alert me to the package failure. It's a pretty simple bit of code, but it has a huge smell. I'm catching . I think I'm doing it for the right reasons though. Basically, I'm saying that if any exception gets thrown, fail the script task, and thus the package. Is this a case where it's okay to catch all exceptions??? For reference, these are the possible exceptions that Directory.GetFiles can throw. Of course, I'm pretty new to c#, so please let me know if I'm doing anything stupid. (Yes, I know I'm programming in , but this is short and sweet. I don't see the harm just this once...) 

The biggest problem here is that an IPv4 address is really four unsigned 8 bit integers, but you're using 16 bit unsigned integers to represent them. You should be using an array of bytes instead of ushorts. Obviously, you'll still want to leverage the other answers and them as well. 

Execute your stored procedure once, and store the result in a variable. Try to reduce the layers of nesting. You anytime you reach for cntl+c, stop and consider how you could reuse that particular piece of code. 

So, let's start with the Worksheet event and what you're trying to do. You only want to trigger the pivot update if the changed cell is . There's no need to intersect, just check the target's address. 

I would look deeper into this problem, because this feels hacky. (Mostly because it is a hack to make it work.) 

So, finally, we have the right level of abstraction, while letting the framework take care of all the nitty gritty details of binding the data to the UI. 

But at this point, it becomes obvious that we're just walking the tree, which makes me wonder if it wouldn't be best to just implement a and just walk the tree. Of course, if we use a and a , then the custom Lexer code might as well go away and just have the Listener count the tokens as we walk. 

Honestly, it looks fine to my eyes. There are a few things that jump out at me, but all fairly minor. This is the biggest red flag to me. 

I did not implement any checks on the place parameter, but it should check for both and . Note that I used for both parameters. You had only used it for one of them in the code above. By default, references are passed , so it's good practice to declare it so we know that functions won't have side effects and go changing on us. Speaking of , single letter parameter names are the devil in VB6. The IDE isn't smart enough to replace all instances of it like in VB.NET. Try to do a find and replace on "s" and see what happens. Opt for a longer more meaningful name. Even dsmvwlng to would be preferable over . I think the old VB6 conventions should be dropped in preference of the new VB.NET naming conventions. Methods should be PascalCased. Note that I changed to . VB.NET There is a built in string function to do exactly what your function does. It's called . MSDN documentation. 

But, I think you made a wise decision to do so here. It reads very nicely. I think expanding the braces to newlines would have hurt a bit. What are all these magic numbers though? What do they mean? It could certainly use some constants. 

This will make it much easier to pass your database connection in so it's trivial to deploy your code to different environments. 

You can fake overloading and doing so will make for a friendlier API. First, make and private. Then add an optional argument to and . Simply check to see if , if it is, call the appropriate private method, else run the code that returns First/Last. 

TL;DR I wasn't going to review this, but I couldn't stop reading it again and again. So, here I am reviewing it. I'm going to go down line by line, but first let me address your question. Would creating a data service class be overkill? Right now, I think it would be. Overall this is a pretty clean implementation. Yes, the presenter is technically doing two things, but adding a data service just adds to the complexity. Add it when it makes sense to add it. YAGNI. Another thing I would like to mention is that you're using a number of custom classes. Which is good. Developers should have a tool box. BUT.. the average VBA developer is not an actual developer. So, take into consideration who will be maintaining this after you've moved on. Will it be a business person who thinks they know how to program, or will it be a legitimate developer who has somehow been suckered into playing Mr. Maintainer for the project. (Let's face it, someone must have blackmailed him or her into it.) I think it makes a big difference on how much you rely on your toolbox that lets you program in a more C# type style. Ok, on to the review... Form's Code Behind 

You have this filepath hardcoded in several locations. Define a module level constant for it so you only ever have to change it in one location. 

Visual Basic Naming Rules - Office 2013 Language Reference This pattern is a bit more restrictive than need be, but I think it will certainly cover the cases laid out above. 

I don't like relying on default properties when I can avoid it. It's better to be explicit. This would be more properly written as: 

This needs some breathing room and may or may not break the SSP depending on screen size, but all in all isn't too bad. Although, it would read better like this. 

First, to address your question, cleaning up should be a simple fix. Unfortunately, isn't shown. However, that's where the change needs to be made. It should be responsible for setting when it terminates. Honestly though, I can't quite figure out why it isn't doing that implicitly already. Perhaps because of the reference to ? I don't see a need for the error handler in . All it does is re-raise the error exactly as it is. Unless you intend on adding information to the description or source, just remove it and let the error bubble up. The same can be said for and . Actually, I take that back. Now, I'm not 100% on this, but if errors, should it try to ? I'm not sure. Consider it. I don't think there's much more to say. Except maybe that I find the readability to be top notch.