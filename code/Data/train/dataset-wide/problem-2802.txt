The interview defines 4 user stories but you have only really implemented 2 as far as I can see. Story 3 says that the amount should be rounded to 2 decimal places. You have done that by applying the rounding to the result as part of a unit test which misses the point of the story (imho). The story says something about "should be displayed rounded to two decimal places" so it might need a tax calculator view which displays the results as per requirements. You should avoid having two ways of creating your objects. If you have a factory then you usually don't want the user to instantiate new objects by . If I were to use your class I would not know which way to use and if there is a difference or not. smells like hungarian notation of which I'm not a fan of and which is generally frowned upon. I would prefer over as method name in the factory. Remove the factory method - you can pass a mock repository in unit tests which always returns a fixed amount. 

Your caller very like doesn't care of the exact internal workings of a course - it should just dispatch the notifications and see if it succeeded. So a should probably get a method like . When you use expressions like in several places then it is usually better to put it in a local variable which expresses the meaning of it and also makes the code shorter, for example like this: If you don't actually need the index then will usually suffice and is shorter. 

I might be misreading things so correct me if I'm wrong but Ithink your assignment operator can deadlock. A only makes sense when accessed from multiple threads, doesn't it (otherwise what would be the point)? 

Pass via the constructor as an external dependency (preferably an interface). This will make the current implicit dependency explicit and visible which should yield in better maintenance in the future and easier unit testing. Pass the tick handler in as an parameter - no dependency on a specific object at all. Expose a event and raise the event handler on tick. This way anyone interested in the clock can subscribe and the clock doesn't need to know about them at all. 

I don't like repeated calls like this . should be called once and stored in a local variable. You will run into trouble when writing unit tests. Right now you have no way of mocking out the database access which forces you to run against a real MySql database which tends to make unit testing a pain in the backside. Create an interface for against which all your business logic should work and inject it into the classes responsible for creating the database queries. Then during unit testing you can pass in a mock-implementation which simply checks that the methods are preparing the statements correctly without having to run a query against an actual database. 

The idiomatic way of accessing an item in a map and adding it if not present usually goes like this: 

The main issue I can see is that you have duplicated your statements mapping styles to colors about a gazillion times. This is not very maintainable. Imagine you add a new - you now have to add this to a lot of places and hope you didn't miss anything. As far as I can see there are two types of mappings: One for and one for - you should have two dedicated methods which translate the into the colors you require and then call these two methods in the appropriate places. I would also consider making the an rather than a as there seem to be fixed values. At least define public string constants for the different default names - this way someone could just use those constants and doesn't have to remember the correct name to put in. There are other code duplications as well which you should try to avoid and extract into common methods. 

and can potentially remain null and therefore your code has the potential to throw a . You need to check for first before calling methods on these objects. The way you re-throw the exception will destroy its stacktrace. Instead of this: 

The .NET library team had the same problem you did. Before generics where introduced classes like were provided which would operate on and thus box value types like allowing it to actually return if the key was not present. After generics where introduced this was not an option for classes like . The solution to this was to have throw a and to implement a method which provides the value through the out parameter and return or depending on whether the key is present or not. You might want to implement an iterator for your list. This will let you use LINQ for a great many constructs usually resulting in more concise code. Something like this: 

If speed is your goal then the next simple step would be to first use which in C99 or later is guaranteed to have at least 64bit. The next step after this is using streaming intrinsics, for example allows you to compare 64 bytes at once. However this is pretty much leaving the land of portability so depends on what exactly you want to do. In general is probably by and large mostly memory bandwidth rather than CPU limited, so once the memory bandwidth is saturated comparing more stuff in parallel won't achieve much. For learning and educational purposes this might be a fun exercise though. 

This would get rid of a bunch of small helper functions which just clutter the code. In string literals are compared. This means they are also being generated somewhere else. Now you have the same string literal at least twice floating around in the code. Ideally they should be turned into s. but if that is not possible then at least they should be public constants on the class so you can reference the constant instead of using the actual string literal. This way you have to change it only in one place and the chance for bugs due to typos is greatly reduced. In the blocks should be turned into a statement. Alternatively you could take a more data driven approach and define a which contains the actions to perform for each message. You then would only have to lookup the message as the key and execute the action if it's present. A fair amount of typos are present. The ones I found on a brief glance are: 

You don't really gain anything by abbreviating your queue related functions. So name them , etc. You are also being inconsistent with naming. Sometimes you have a suffix like and sometimes you don't like in . You should use a common naming convention for your data structure. Extract the data structure in to separate files. The queue implementation is independent of the algorithm and should be treated separately. A dequeue (double-ended-queue) is a generic enough structure to possibly re-use it in the future. is a rather bad name for that constant. would have been better. should not do a - it should take a function pointer as callback which gets called on every node. This makes it more versatile and the user can chose what to do (dump it to stdout , write it to a file, send it over the network, etc.) There could be some merit in checking the return value of for and in that case. Your code will probably most likely crash as it stands (which is what you want in that case) but technically per C standard dereferencing a pointer is undefined behavior and theoretically your system could do all kinds of stuff in that case.