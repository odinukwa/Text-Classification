Well, setters are meant for object encapsulation and part of this is validation. It would probably be clearer to validate in a setter than to set in a validator. Setters are meant to block people from directly modifying and accessing a variable, else you could just put it as public. You could easily rename your function to and throw an exception or return false or w/e that suits your need in the setter function, and that would be clearer (to me) than having a validator that sets a value. About function length, well I do think it's OK. It makes it easy to test the class. 

Also I've seen that you wanted to call one method , the name is verbose,(that's great) but try staying in the Java conventions which are camelCase method name. It's OK to capitalize an acronym (eg: URL) but try to keep words in lowercase, and caps only the first letter of any word following the first one. That make the code easier to read and makes all the code look the same way. 

naive: 10.82 incremental: 4.74 There are some asserts in the code which all hold and might help you read it. The given benchmark parameters and grid are all typical of my simulation. Background: Imagine a geographical area divided into disjoint regions (cells), where each cell has a base station which provides service for cellphones within its area. Two mobile callers within some distance of each other cannot use the same radio channel, lest their handsets will interfere. When a new caller requests service, we must therefore find the set of channels that are free in the cell of the caller and the neighboring cells within some given distance. We can represent such an area and the channels in use with a boolean 3D matrix where the first two dimensions represent the geographical position (i.e. the cell) and the depth represents the channel. Cell areas often are circular in the real world, and we can approximate them as hexagons instead. Finding the neighbors of a cell we must therefore use the hexagonal distance. Assigning new calls requires to find the channels that are free in the nearby area (eligible channels). However to select channels that will optimize grid usage as a whole, statistics, i.e. the feature representation, are useful. So when an action happens, i.e. a caller terminates a call or a new one requests service, there's a set of legal actions to take depending on the action type ( or ) and the grid. The afterstate is how the grid would look after performing an action, and the feature representation of that afterstate, when compared with the others, informs the decision making. 

the above is not good. on every call to this method, two String objects are created , e.g. (sum+"") , before they are parsed into an int. considering the method is called billion times in my test, that produces two billion String object creation operations. since you know that the value is an int (according to the math in there and based on the links you provided), it would be enough to use casting: 

An additional point to the ones mentioned by @palacsint is the check for the object removal: according to the challenge: 

Running the code takes 5 minutes 8 seconds. now we can start optimizing it step by step. I will now mention the various points in the implementation that can be optimized. 1- in the method getDigitSum(long num) 

The code below is the core of a Genetic Algorithm (NSGA-II to be precise, without crowding-distance calculation), but I've taken out all the GA-specific parts and made a generic example. I think I've carried over most of the principles/'constraints' from the original algorithm, but I might have missed something. As you can see in , I need to convert a nested list (2-dimensional) to a flat list pretty often and I'm curious of if there are any better ways to do it. I've added some so that it's easier to follow the size and type (nested or flat) of the lists. Since expected size of input is m=100 individuals () for 500 generations (loops), speed is important. Memory usage is not that important (although knowing how to reduce it would be interesting), but execution time is. Any comments performance-related or otherwise are appreciated. 

About your edit : To me your class looks pretty good. One thing you could do is catching the cURL exceptions to throw your own exception based on what happened (be sure to keep the old one in the stack trace though). By throwing your own exception you increase encapsulation because the person using your class doesn't have to know whats underlying in it. They don't have to get the cURL exceptions directly. But that is not necessary. 

Edit : I know this is a little late, but I wanted to complete my answer for the sake of completeness. Your code style looks pretty good to me. The functions names are well chose. What I mean by that is by putting verb first you make the function a lot easier to find and understand. Also, putting the logic in the model is the good choice. Continue to keep thin controllers. 

Running the code takes 4 seconds. the billion iterations cost 4 seconds instead of 5 minutes 8 seconds, that is an improvement. the only issue left is the actual calculation of the sum of digits and sum of squares of digits. that code i commented out (as you can see in the code i posted). if you uncomment it, the runtime will take 6-7 minutes. and here, there is nothing to improve except if you find some mathematical way to have incremental calculation based on previous results. 

here there are few issues: a- set.contains(longArray[0]) will create an Integer object (with autoboxing) because contains method requires an object. this is a big waste and is not necessary. in our example, billion Integer objects will be created. Also, usage of set, whether it is a treeset or hash set is not the best for our case. what you are trying to do is to get a set that contains the prime numbers in the range 1 .. 1600. this way, to check if a number in the range is prime, you check if it is contained in the set. This is not good as there are billions of calls to the set contains method. instead, your boolean array that you made when filling the set can be used: to find if the number 1500 is prime, simply access the index 1500 in the array. this is much faster solution. since its only 1600 elements (1600 is greater than max sum of sqaures of digits of your worst case), the wasted memory for the false locations is not an issue compared to the gain in speed. b- int[] longArray = getDigitSum(num); an int array is being allocated and returned. that will happen billion times. in our case, we can define it once outside the loop and send it to the method where it gets filled. on billion iterations, this saved 7 seconds, not a big change by itslef. but if the test cases are repeated 1000 times as you plan, that is 7000 second. therefore, after modifying the code to implement all of the above, here is what you will have: 

I have implemented two genetic operators, which is really just a fancy way of mangling lists. In particular OX-1 (illustration) and displacement mutation. I found it necessary to extract out the randomness from the algorithms in order to do unit testing with some known examples. Is that a decent way to go about it? Any comments on performance, structure, clarify and so forth is appreciated. 

Given a boolean 3D matrix and a set of actions specifying bit flips at certain positions, a set of resulting matrices can be obtained, one matrix for each action, as if executing each bit flip individually. A statistic (feature representation) defined on a matrix which for each row, column and depth counts the number of active bits at the same depth within some hexagonal distance in the first two dimensions of that row and column. What's the fastest way of getting such a statistic for each of the resulting matrices (afterstates), given the previously mentioned original matrix (grid) and actions (, and )? For example, given , , the first afterstate of can be obtained by . Actions are guaranteed to be bit flips. If the feature representation for is known, the feature representation for can be derived and need not be found from scratch. In the code below, the naive approach () and an incremental approach () are given. The naive approach should be easiest to understand. This is the hot hot hot path of my system and I want to make it faster, but I'm no speed demon. Any tips and comments on anything else, small or large, is also appreciated. Below the code is some background which is not required reading but may make things more concrete. 

There are few places in this implementation that can be improved. In order to to start attacking the issues i made few changes first to get an idea of the main problems: made the total start cases be the value 1 and set the range to be a billion (1,000,000,000) to have a large amount of iterations. also I use the method "getDigitSum" but commented out the code that actually makes the sum of digits to see how the rest runs: following are the methods that were modified for an initial test run: 

You are marking wrong when the list has a single item or is empty. Obviously this is not what the challenge requires. Therefore, you should discard this "if" block and only check the return value from the remove on the list: