I believe this isn't what the problem statement intended. Maybe if you changed to , you'd have the right idea... but then conjured brie wouldn't pass your comparison. 

Okay, so that thread won't be doing anything anytime soon. And with that code out of the way, the rest is pretty much irrelevant; it looks to me as if it will end up blocking forever, since there's nobody left to notify the condition variable. Your problem might be suited to a TBB flowgraph; consider using TBB instead of hand-rolling your own stuff. 

is a guaranteed segfault, as soon as I throw a malformed request at your server. Don't even give me the opportunity to segfault your code. Say what you mean: 

which never hits and so your inner loop (the loop) never terminates. In this particular case, you can fix the infinite loop by checking for instead of , so that the inner loop will stop on overflow-to-negative as well as on reduction-to-1. However, this will not solve the general problem that can overflow to a positive number; and it won't remove the undefined behavior that results on signed integer overflow. (Which is to say, the compiler is allowed by the language standard to assume that overflow never happens, which means that if overflow does happen anyway, all bets are off. It's your job as a programmer to make sure overflow can't happen.) So what you need to do is check for overflow before doing the multiplication, like this: 

Consider inheritance, upcasting and downcasting. This will require fleshing out your pointer from to , and careful consideration of what metadata you need to keep in there. 

Compile and run that program. Look at its output. Then, make a relatively small modification to the program so that it outputs the square and the arrow side-by-side instead of one-above-the-other. Then, add the circle and the diamond. 

You could also introduce a helper class implementing the method, and have inherit that method from . That's called the Curiously Recurring Template Pattern (CRTP), and you've already seen it in action, in above. This would be useful if you're going to have the same kind of view on many different kinds of data: 

Another thing to try if you have lots of headers, or if you're planning to do lots of lookups in the resulting map, would be to try using instead of . Less pointer-chasing often means faster code. 

With this function expanded out, it's easier (but still not super easy) to see that the here is trying to do an atomic CMPXCHG on objects of type , i.e., 16-byte quantities. Check the assembly code (e.g. by compiling with ); is your compiler actually generating a instruction, or is it (more likely IMO) generating a call to a library routine which will use a mutex internally? To get codegen with Clang and GCC right now, I think you need to be either compiling with some flag that I don't know, or explicitly enabling . 

and then inspecting and trying to figure out which was getting instantiated. In the cases where overloading and/or templates rendered the question meaningless, I would try to at least give a nice error message, if not actually produce a tag type so that . 

This loop is extremely confusing. You're looping with one condition outside and a different condition in the inner lambda. I strongly recommend removing one or the other of these loops. Specifically, I would remove the inner loop. 

FYI, that's a suffix (appended), not a prefix (prepended). This is fine; but you are courting collisions with the standard library. For example, the standard library already defines and ; if you get in the habit of using the exact same naming conventions as the standard library, then you might one day run into trouble when you need a name for an entity representing a "time" type or an "offset" type. Therefore I would recommend at least namespacing the identifiers as , , etc. (Also notice that I wrote out "offset" instead of "off", because it's clearer and the compiler certainly won't care that we're being a little more verbose.) 

Notice that I placed parentheses around the macro arguments and when I used them inside the macro itself. 

I'm pretty sure that by the time you get down to the , the compiler will already have complained about the initialization of ; so the isn't really doing anything here. 

This version loses some of the details, such as your custom-named accessors for the parameters; but it preserves a lot of the details "accidentally". For example, I didn't try to preserve your default constructor; but it turns out that it just works anyway, thanks to the default constructor of the standard . 

This is the function you want to be writing. There's no reason to drag object-orientation into it at all. Your main function had been multiple lines long because of the mutation involved (and honestly it's not clear from reading this code that all the expensive work occurs on line 2 â€” so that's another downside to the anti-pattern above)... 

Notice that they are all very similar in flow: the four shift counts are always "power-of-two, half-that-number; non-power-of-two, half-that-number" for right rotations. This is unsurprising in retrospect because our cube-rotations are naturally isomorphic in terms of how many sets of bits are switching places. The only difference is which indexes are contained in those sets of bits. Notice that the 32-16 swap that shows up in the "x" and "y" rotations is a "reverse-words-in-the-qword" operation, and the 8-4 swap in the "z" rotations is a "reverse-nybbles-in-each-word" operation. The x86-64 processor has a built-in "reverse-bytes-in-the-qword" operation () but does not have any faster way to do the 32-16 or 8-4 swaps as far as I know. (We do the former in 9 instructions and the latter in 17.) The code for these rotations, and (non-exhaustive) test cases for them, is now located on my GitHub at $URL$ You can investigate the assembly code for these rotations on Matt Godbolt's Compiler Explorer: $URL$ 

This is fine (and 100% correct, because it avoids implementation-defined casts!), but you should know that in practice most codebases will do simply 

The above fails because tries to find a match for . This would be an okay match for the implicitly defaulted copy-assignment operator , but unfortunately it's a perfect match for the specialization . So we end up trying to call the equivalent of