After you have captured lock escalations and blocked processes you have to determine if the lock escalations are the root cause of the blocked processes: 

There are two different approaches to achieve this. Solution 1: The hierarchy is in the employees data Add a field to your employees table Each employee has an ID. This can be a unique identifier or an employee number that is given to each employee when she/he starts at the company. Each employee will have to report to another person (e.g. manager, team manager, ...) Here is some example data for such an EMPLOYEE table with a REPORTSTO column Example EMPLOYEE table: 

Start the SQL Server Configuration Manager Right-click the SQL Server Agent (INSTANCE_NAME) service to bring up the properties. In the properties change the service account to start with either your Windows account or switch to "Local System". Close the properties Start the service in Configuration Manager. 

Continue with step 7. If the instance can not start with the PFILE then you have to create a new one with the following command: 

As you can see in this example the LSN of the TLOG backups always match up. The of a previous TLOG backup matches the of the next TLOG backup. However, the FULL backup has an LSN that begins inside the LSN range of the next TLOG backup and ends inside the LSN range of the same TLOG backup. Restore based on your example table If you were required to restore your database to 18:00 because of an error at 19:00 then you would require the FULL backup from 12:00 and your Transaction Log backups from 13:00 through 18:00. The LSNs would be without interruptions. No need for the 3rd-party FULL Backup. You can verify this by checking the and column of your current backups. They should match each other. End of Explanation You could end the explanation here and now, but there are considerations to be made regarding the 3rd-party solution and the solution you are using for your backups. (To be continued...) Reference: SQL Server - Understanding SQL Server Backups (Paul S. Randal) 

The TLog has come around and because their is free space at the beginning there is no need to increase the TLog size More modifications 

I was given a problem to solve , in which there is table called Scenarios in the Master Db which contains the details of all the Tablespace for which I have to find the size. The O/P should contain Table size(actually consumed) and index size and no of rows. So, I wrote a sizing script(PL/SQL) to find the size of all the Table Space on that particular DB server. But I am getting this particular exception after it runs for days. ORA-01555: snapshot too old: rollback segment number 9 with name "_SYSSMU9$" too small I am not sure what might be causing this, as the data size is not that huge. I am attaching the Script 

So, my question is does the order of columns in Where clause matters or does SQL Server re-arranges them as per the index definition ? Thanks !! 

I was expecting a full table scan to be followed by a select in the query plan but to my surprise the output of plan was a index scan folowed by select. 

I was reading this use-the-index-luke.com which explains in detail how indexes work. One of the things this person has re-iterated that the order of indexes matter a lot and to make the query fast the where clause columns should be same as that in index. Today, I was just corroborating this theory and created a table (id int , name nvarchar(100) ) on SQL Server 2008. I inserted some 5000 rows in it and created a index and fired the query 

If the field is of type Lob then to calculate its size I use nvl(DBMS_LOB.GETLENGTH(),0) If the field is of type Long then I loop over all the Long values and find their size using the built in Length() function If the field is of any other Type I use nvl(vsize(),0) Just to specify the user has permissions on all the DBs 

I need to connect an application to Oracle. In the installation guide for that application it says that it requires 64 bit version of Oracle Data Access Component,more specifically 10.2.0.3 . I have tried installing it but I am continuously getting the error attached in the image when ever I try running the installer. The crash details are given in the image attached. Has some one ever tried installing it? If yes then would it be possible to give some details or point me in the right direction so that I can complete this installation. 

If you don't want to use this function though, why not just remove it from your code? The only time I can think of there being a valid use-case for this sort of structure is when you're running identical code in two different schemas/on two different databases but this function is useless in one of them. If that's the case the function is still useful in the other and so you will want to do something with the result anyway. 

We need to add a column to a table that gets hit about 250 times a second, approx 170 selects, 125 inserts and 60 updates. The column will be a simple . The does not matter for the inserts or updates i.e. not part of the primary key, which I'll enforce separately. We basically don't want to have to do an over a range scan 170 times a second, as the number executed will drop massively. Does an index organised table guarantee that will always come before when running the following query: 

Earlier today we had a problem logging into a database that had just been created automatically. When on the actual box (Linux) , i.e. a local connection, was fine, though, it was occasionally impossible to do anything once connected. Otherwise, whether using a session on the box or not did not work at all. and DNS testing revealed nothing and there was no problem in . The Listener was accepting the connection but not handing it off to the database. This was confirmed by using on the listener log and watching it accept the connection. There is a logon trigger on the database that inserts the user details / time etc into a table, but this doesn't have any indexes and there cannot have been any locks. We finally traced the issue. There was a conflict in the file that creates the temporary tablespaces for the database. It resulted in there only being 5MB of tempspace instead of the normal 25GB. Disabling the logon trigger and then adding the additional temporary tablespaces, sorted everything out. There were some sessions already running that would have been using some of this tablespace. Apparently Oracle requires some temporary tablespace in order to accept an incoming connection. The specific version used on this DB was 9i, though I think this applies to all. Why and what is it used for?