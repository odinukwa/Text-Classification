First of all, thanks for the feedback. I answer my post myself, because I have to describe my decisions. First of all, here the current code. 

Use C++ not C First of all, you are making a lot usage of C, not C++. In C++ you either use the keyword class or struct to declare a class/struct, not together with the keyword typedef. You are using uint32_t a lot. This is also C style, the proper C++ style is the std::unit32_t type. But most of the times you don't really need to specify the width of your integer directly. This only makes sense if you want to serialize/deserialize them. Use new and delete instead of malloc and free. Better: use smartpointers like std::unique_ptr and std::shared_ptr. declare properties private (encapsulate them) The problem here is, you are using public available objects inside of the IMAGE_STRUCT struct, which can be modified from the outside. split-up your functions Your atImageEvent function is huge! Split it up into smaller parts. name conventions There are no explicit name conventions at all, but you should not declare your classes/structs with only capital characters (like IMAGE_STRUCT). Most of the times words with only capital characters are macros. It's not a mistake rather than a bit of taste. if I am not totally wrong names beginning with _ are reserved by the standard and should not be used for custom code. To be honest, I am using them by myself, but I think its worth to mention this. undefined behaviour 

Now you can access the created IDs using . Of course you'd want to store the or something in the same table, to relate them. EDIT: Untested replacement So I've just roughly written some SQL I think should work instead of everything including and below the statement. The main issue I have with that part of your trigger is that it will only work for one-row updates, and it performs an INSERT then an UPDATE on that inserted data, which can be optimised. 

Now you've got the table with a single column and a single row with the new ID you just inserted, so when you need to access that ID when inserting addresses and phone numbers, you can join or subquery like you would any other table. As far as I'm aware, variable scoping doesn't matter in SQL Server stored procedures – if you declare inside the block, it will still be accessible once the code has left that block. So you could declare the table right before the insert to keep its use obvious, or near the top of the query like normal coding languages, to imply it is used not only in that block. Everything else looks good to me. 

Inheritance is the devil. Never implement an "is-a" relationship with inheritance. Any time you reach for inheritance, you need to cultivate an instinct to stop and do something different. Note this is different from abstract definition and sealed implementation - that's just a strategy pattern, which is absolutely fine. Make more classes, that do fewer things. 

Your code is going to log an awful lot of "GameObject is not null" items, for very few non-null game objects. Basically, you've made an O(n * m * p * q) algorithm, where all you needed was (at most) an O(n + m + p + q) algorithm. This would achieve the same effect - beyond the fact that you'll get fewer logs of the same non-null combination over and over again. This code assumes that the library requires an enumerator. 

Rather than inserting the EpisodeHistory, then checking and updating based on the data we've just inserted, this code just does the operation all in one. First I'll explain the left join. The point of the join is to find the of the earliest matching row (since we want to put it in , right?). So we do a normal select of the table, except we also add a column for , which, when combined with the fact that we've put in the join condition, will means it will only join to the first that matches. This makes sure that if there are two rows with the same , and , it will only join to the one with the lowest . Now the actual columns that are inserted are fairly simple. If the left join fails (if no rows in EpisodeHistory match), selecting will return . Therefore, means that if a was not found in the join, it will just do a normal insert of . If one was found, it will blank that field. The next line is fairly simple in that it inserts if the join happened, otherwise it puts in 0. Since the entire operation can be done in one statement like above, so you can ignore that bit I said above about temporary tables and an clause. This code above also has the added bonus of working for multiple-row updates. It's a trigger... You may already know, but the SQL Server community is fairly divided when it comes to whether triggers should be avoided or not. They can be easy to forget, hard to debug, and can hinder performance as they become part of the write operation. Since you mention performance I'll elaborate on that aspect, and I'll make some assumptions I hope you can forgive. I'm going to assume there's an application that sits in front of this database, and the application prompts the insert/update. Say the user is on a form and makes changes to an episode, and submits the change. Usually the application will wait for confirmation of the update/insert operation before proceeding (before loading the next page, for instance). With the trigger, the application now has to wait for the initial insert/update, as well as the trigger to complete its operation too. Therefore, if you haven't already, consider the possibility of separating out this process. In this example I gave above, you could have it so that the application still waits for the initial insert/update operations, loading the next page normally, but then in the background (asynchronously) it tells the database to perform audit operations. Boom, you've reduced page load time, better UX. This also has the benefit of you not having to worry so much about performance tuning the auditing operation. Checksum? I'm going to assume since performance is an issue that you've considered indexes, and have an index set up to optimise this and comparison. Have you considered the use of ? I don't have any experience with it myself, however I'd imagine you could use it in combination with persistent computed columns to improve the load when write and maybe reading to the indexes. In this instance you'd have an extra column on both tables called something like , which would be a checksum of eDescription, and you'd put that column in the index instead of . Then when you perform the comparison to see if they're the same, you'd be comparing the relatively small and light checksum column instead of the potentially-huge column. Minor issue I see when you set the , you select from multiple tables. It's recommended to use joins instead – use of multiple tables in the clause is being depreciated by all DBMSs. If anything's unclear, let me know. Hope you found this helpful. 

In the end I did not review the correctness of your code, I just stepped over the obviously mistakes you made in your code. 

As you can see, I renamed my class to SynchronizedValue, because I find it more descriptive than LockedValue. The behaviour of the class stays unchanged, I only did some minor changes and I want to describe why. In every state of this class, only one mutex gets locked. Even in the move parts, I only had to lock one at the same time. This prevents me from getting into a deadlock. The real important part is in the function. In the last state of this class I returned a rvalue reference, which was bad, because when I really started to move the value from other, outside of the function, the mutex already was getting unlocked. This means a race-condition could occur, which is absolutely bad. To fix this, my only change here is to return a real object instead of a rvalue reference. The second important change is no code change at all. It is also closely related to the function. I am talking about the move assignment operator. While I had to check the self assign in the previous version, I can now just take the value and store it safely. The cleanup, which is the bad thing of a self-move, already happened inside of the function. Thus, it should be absolutely safe to deal with the self-moving problem. Why no noexcept The lock functions of a might throw, this means I am not able to make a guarantee for exception safety, unless I would write the whole function inside of a block, which is never a good idea to deal with exceptions. It is not a mistake to declare a move-assign not ; it just makes some optimizations for some classes impossible. why a and copy ctor That's a good question. While I know, that usually a copy ctor is enough, unless you have to modify the original object, it is here required to make the templated ctor possible. If I delete the non-const version of the copy ctor, everything works fine, unless I try to copy from a non-const SynchronizedValue object. A conversion from to is required; and a templated overloading always has a closer match than an overloading which requires a conversation; even when it's just the to a reference. I played a little bit around with SFINAE, but I got no nice solution for that (there might be a solution; but I wasn't able to make it work), thus I used this easy way to deal with this issue. The problem is, I can't SFINAE the copy ctor, this is the wrong way. I have to remove the templated ctor from the match list when I want to copy; and that's the real issue here. The idea, which someone came up with, was to try this one: 

The advantage of this design is that you'd quickly find that you don't really need much inheritance at all. I would aim to have at most a single pure abstract base class, and implementations for the different abilities. Any time you need to share some code, just make a new class, and have the other classes own one. LEAKY ENCAPSULATION Make everything private. If something needs to be public, check to see where it's used. If it's only used somewhere else, move it. Never use public fields - anything public should be a property. Never set data on another class instance - all setters should be at most private, but better, simply non-existent (i.e. either set in the constructor or implicit functions). That's it for now. Two general points to always bear in mind: 

It would be nice to get an explanation of what your "needs" are. But either way, here are some recommendations for your coding style and other simple stuff. enums You are using an , but instead of using it as a parameter, you are using ? In the comments above, you are explicit defining the values. That isn't necessary, when you accept a parameter of an type. You should also use the more strict type. This prevents users, to accidentally passing any other values than the types. That means, your enum would look like this: 

You are running into undefined behavior here, because you are reading from a union property without writing to it first. Unions should not be used to convert types to each other. It is not safe! I am sure, the code doesn't do what you expect. Your code says, you are converting a uint8_t pointer to uint16_t integer. You are not accessing the data, just the address! 

Per billinkc in the comments, before would do what you intend. Per Michael Green, avoid using where possible. I recommend using instead. Here's an example: 

Since s are used, you'll only ever be returned rows where the is smaller than the , so the code works as intended. If I understand correctly, you want the code to check that is smaller than AND is bigger than . However, those two conditions are the same so you only need one of them. As a sidenote, your code will not work as intended for the following reasons: (1) It will bring back any actors who have starred in ONE movie together, rather than two, and (2) it does not list the movie names they have starred in. The first problem is easy to fix; add to the end of the statement. The second problem depends on the version of SQL Server you are using (use to find out): 

Most of the points are already mentioned by others, thus I will only tell you my opinion about the missing ones. I don't really like your function. You obviously know how to use , why don't you simply use them for your purpose? It all boils down to something like that: 

You make your code more self-descriptive. your Socket class Your class suggests an other meaning, than it provides. It should handle the sending and receiving without the need, to specify the explicit. The user shouldn't be forced to pass the themselves. That's up to the class, to provide the correct socket (at least you are holding a socket as private member). Think about that, perhaps your class has simply the wrong name for its purpose. use instead of heap array You are using a heap array as a read buffer. This yields exception errors, and it isn't totally clear (at least for the user of the Socket class) who is responsible for the cleanup () of this buffer. It is never a good idea, to hand back a pointer, and let the user cleanup the stuff by themselves. Instead, you should simply return a . That's clean, smart and has no hidden traps. If the user decides, he doesn't need the buffer anymore, he can simply let it go out of scope and it will be deleted automatically. The problems are even bigger, when an is thrown by any part of your framework, the users code or any other part of the program. If you want to pass ownership, use the provided classes. For strings it's , for every other point it is or . When you think, "returning a char* has better performance than returning a ", that's not totally true. Most of modern compilers can optimize that. You should google for "" (). In it is guaranteed, but in or it might fail. But even in that cases, a simple move of the happens, which is not as bad as it sounds.