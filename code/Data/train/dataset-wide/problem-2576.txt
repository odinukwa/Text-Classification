Other, similar libraries don't require you to pass everything to the constructor. What if you want to send an email to more than one person? You should be able to call more than once. For now, I would suggest getting rid of the constructor entirely, and calling the setters manually as needed. After all, if you're planning on doing the entire operation in one call then you might as well write a function instead of a class. If you're going to implement setter methods then you should make your properties private or protected so they can't be changed manually by whoever is using your class. Usually, the setters are implemented so you can validate input before setting them, for example, 

You, my friend, are an architecture astronaut. Holy moley, dude, 110 lines of code on top of 4 libraries to do something that would take a couple dozen lines of code to do in "vanilla" JS sounds to me like you're abstracting way too much. I have the exact same problem and it's led to hundreds of hours of wasted coding so I know it's hard to hear, but my honest opinion is that you should come back down to Earth, take a vacation for a few days and look at this again and ask yourself, do you really need all this? Your buttons only respond to the event listener once, it's not immediately apparent whether that was by design or if it's a bug. Does the component make sense? Not immediately, not to me, though I've only worked with mustache a few times. Is it easy to follow? No, sorry. You required a 4200 character explanation without even mentioning core observable library (which is what you should really be asking for a review on) - that's a pretty good indicator of how easy it is to follow. Can you foresee any shortcomings or disadvantages with the design approach dictated by the framework? No, just a little over-engineered IMO. 

I would say, yes, definitely. That saves a lot of manual code writing and makes it easier to change in the event you need to change all of them. The only difference I would probably make is, add your different properties when you create the object, that will not only slightly improve speed, but will also make the code a tiny bit smaller. 

Now you just need to write a short description on the first blankk line and fill in the types (if NB wasn't able to guess them already). eg.. 

the HTML string on , doing so will leave the tag name as the first word in each string in the array. Loop the array and explode each string on (space). Even if there is no space, this will result in an array of which the tag name is the first index, possibly followed by a if there are no attributes. Get the tag name, trim it up and if it's unique, add it to an array of tag names. 

Your current code gives you a bunch of booleans, duplicates a lot of code and does unnecessary computations.. You should aim to get the time of day itself rather than a bunch of booleans. 

Your code is difficult to follow as you have a class with one single, very long method. Break that method up into several methods, you will thank me later. 

Stupid nitpick.. There's no such thing as a JSON object in Javascript, they're just objects in Javascript. JSON stands for JavaScript Object Notation - Talking about JSON objects in the context of Javascript is like saying "strawberry flavored strawberry ice-cream which is strawberry flavored." Sorry. </rant> Best option If this is a realistic representation of your objective then the third one is the best, fastest and most concise. Creating a function to add two numbers is a waste of space and memory. Creating a variable is also a waste of memory as it will just have to get garbage collected. Approaches you aven't considered 

The reason your page is initially loading without styles is because you programmed it to wait for he DOM to load before loading the styles :P 

It's not technically wrong, but when you're writing re-usable components it's better to use than to create methods in the constructor itself. For example, 

The point that I'm trying to make is that new programmers and even old ones for some reason spend way too much time worrying about stupid buzzwords that they completely forget about common sense. The only buzzword you need right now is K.I.S.S. Good luck and godspeed. 

No, this is not the "normal" way to build a responsive website. "Normally" people use frameworks that are built specifically to remedy this problem. Bootstrap, made by the guys who run Twitter, is the most popular responsive framework. Basically it's a set of styles and (opionally) javascript that you include in your sites and then you just add class names to your HTML depending on how you want things arranged. It's really easy to learn and use. Much easier than writing 1000s of lines of JS or CSS. 

(For some reason the markdown parser didn't want to format this as code unless i also formatted it as a quote.) 

Your 2 search functions are similar enough that you can pass it a parameter to determine if it should be a case sensitive search or not. The function seems redundant, but if you need it it would just be.. 

So, your stack is storing three different types of things: , , and . These things are repeating in that specific order in a single stack. This seems like a very fragile system, if one thing is added or removed without the following two your software will break. Since these three items are always added and removed together you should group them so each set of three is always together and your order is never broken. 

Your functions are small but, really, there's too much happening in them. Your function should only have to change the stylesheet. This type of stuff should be done in the stylesheet itself rather than with js: 

The only suggestion I have is.. ... why? what was that person thinking? is both faster and shorter. Aside from that, looks great! 

The answer depends on what your definition of "better" is. jQuery was intended to make developing easier, but it has trade offs: it requires you to add a large script to your page that will slow down load times, and it a lot of cases, yea, it is slower than vanilla JS. The thing is, a few years ago there were a lot of discrepancies between browsers and people used jQuery to bridge that gap. Today, with ES6, there are a lot fewer discrepancies and that's why jQuery is slowly dying. In most cases, I would say, If you can reasonably do it, try to avoid jQuery. However if your entire codebase uses jQuery and it's gonna be there anyway then there's no reason to go out of your way to avoid it. 

contains both and data, so you can use that in place of . Now, everywhere you have that request method check, instead just do , and everywhere you use , replace it with . Then your code will work with both GET and POST and it will also be quite a bit shorter. 

You can shorten to a single function that checks both, . Also, there's really no point in breaking the switch after you've returned. 

TL,DR The biggest problem I see with your question is your use of the word "better," as if that's an objective term that means the same thing in every context. Faster !== better. Assuming you're the one maintaining the code, the best one is always whichever one works and whichever one you like the most. Synopsis First, let me mention jsperf - a site that was built for javascript performance testing. If you insist on testing server-side code on the client side, you should really use this instead of building your own, for many reasons, the main one being: because it's easier. But to get the most accurate results, you really should test in the environment it will be run in (on the server side). It is good to know how to write your own benchmarks, but if you do, you should make sure your benchmark code has the smallest footprint possible so as not to affect the results. Among other things, every time you concat a string with the computer has to load the entire string into memory. It is better to put your string parts in an array and then join the array at the end. As Blindman67 noted in the comments, benchmarking Javascript is tricky and generally unreliable. There are simply too many variables (different JS engines, other things running on the computer, etc). 

I wouldn't have a function that sets the event handler since this is usually something that is only done once. Instead of using you can use assign the keyup listener to the document and have jQuery only respond when it lands on that element, this way you never need to call it more than once, which mean you definitely don't need to put it in a function. 

If you're not sending an HTML email you should wordwrap your parameter at 70 chars. (You can create a variable to determine if the email will contain HTML). 

Now, not only will this be easy to read and maintain, but NetBeans will actually parse these comments and show you what parameters are required when you start to type the method name: 

When you build a string like this you are loading the entire string into memory every time you add to it. In this case it's likely not going to be a big deal, but it's generally a good idea to use a buffer to build your strings, which basically means ing string segments into an array and then ing them together when you have all the parts ready, eg.. 

Condense all that duplicated code. Don't concat your strings like that. Every time you do that that string has to be re-loaded into memory all over again. It's more efficient to put your string pieces into an array and then join them later. 

If I understand correctly, each test can only return a single result, therefore if you want to evaluate all list items you would have to make a test for each one. You could also create a separate test for all of them. Disclaimer: This code may or may not actually run, I've never used Jasmine, but it should hopefully at least get the point across 

In this case, you're wasting more of your own time than you are of the user's time as any difference will be minuscule. Therefore you should choose the approach that is more readable and easier to maintain. IMO, that would be the first approach. Micro-enhancements & Considerations