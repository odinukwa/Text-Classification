I don't think there are any possible edge cases here, at least some initial tests don't reveal any problem. I think it's short and readable, but readability is often hard to judge when you're the author. Any remarks? 

One thing I'm not sure of: is the readonly property necessary for or can I write ? I'm not worried about the tiny chance of multiple calls to the same uncached object causing multiple and I'm also not worried about stale data. The main goal is to cache some informational data that is simply displayed on the screen, instead of retrieving it every request. I've tested this with an expiration of 1 minute and a class that gets on creation, and it worked fine, so I believe the code is bug-free. 

The goal is to construct a with a connection that uses an access token. The access token is acquired with ADAL (Active Directory Authentication Library). The problem is that acquiring an access token is an async operation. Luckily, ADAL uses for its async calls, so it should be safe to do sync-over-async without risking deadlocks. Full code is provided below. The focus for this question is on the sync-over-async code and method of registering the , but remarks for the other code are welcome too. Container configuration 

I understand his argument, but the code is harder to read and there's a higher chance on bugs when doing date/time calculations without using date/time objects. I also can't cast it to a in the query because I'm using LINQ to Entities. Which method is the better one? 

Is way better! Think about it: In the previous case, you 'return' and terminate the function. But, in this condition you have no idea if the job was done or not and if not, why not. This is pre-condition checking and an ideal case for it 

Craziness? You only need to do this if you want to assure yourself (or the compiler) that it won't be reassigned. This is hyper defensive and, in 15 years of writing code I have never found it to be a necessity. Frankly, 'final' in this case is repetitive and distracting. Unless you have a need for it (which, from this code, you don't) then ditch it. this: 

by shifting the digits left, performing your digit selection and bucket sorting, then outputting them back in decimal form? Like, take your random set and first convert all of them. I would expect better overall execution time. 

Delete all of your controllers. The endpoints are created and the content-types managed by spring data rest for you. Read more about for details on that Delete all your DAL code 

I would also suggest that you might be able to make use of Java 8 streams to improve your performance on large numbers. 

First, I applaud your effort - I must confess: this is definitely lacking in the js world. A few things come to mind: 

I don't know enough about android but in Swing, for example, a combo box took, in it's constructor an 

The compiler can complain if you double declare, is strongly typed, ... Cache sizes of containers while iterating Depending on the container, calling GetSize() and operator[] can be expensive. Cache the size up front or use a range based for. 

has lower precedence than , so in this case it is correct, but it may become wrong if you use another operator (such as bitwise operators) and it is confusing to read. So just add them! 

I want to be sure my parameters and base object will not be modified. (If calculating if two rectangles intersect requires non-const parameters (so possibly changing that rectangle), something fishy is going on). The general rule should be to mark everything as const unless it is inpossible: 

Another tip is to use lowerCamelCase for variable names. Try to avoid useless comments Comments such as inside of a constructor don't say much - the syntax of the language and/or name of the function should be good enough to describe simple actions. Comments are very valuable, so feel free them on places where they are useful (in complex methods), but don't add any that add nothing. Use nullptr over NULL NULL is defined as a zero, which can also be considered as an integer by the compiler. This can get some weird issues when you have a pointer and integer overloaded function. Pass arguments by const reference where possible If an argument has a complicated copy constructor (e.g. if it has to copy memory (such as ) or has to do atomic operations (such as increasing a refcount)) 

We have a table with calculated data that groups sales by product, year and month, to provide fast querying for statistics. My colleague argues that the year and month should be two separate fields, because a day is meaningless. I want it as a date field, because using two separate fields leads to awkward code like this 

A user first has to choose between Red, Blue and Green. Upon selecting an option, additional form elements are displayed, depending on the choice. For Blue, a Date and Font are required. Currently, there's no need for a third level, but who knows what the future brings. In order to represent this data, I've come up with the following model (after many attempts). 

A picture says more than a thousand words, so here's a mock-up. The actual choices are different, this is just a sample. 

I'm using s for hard-coded choices, so I can make decisions based on the value. s come from the database and do not matter in the programmed decision flows. This works, but I can't help but feel like this is an ugly solution and I'm worried about future modifications. I've never had to make something like this before so I can't make decisions based on past experiences. The UI design is more or less set in stone, unless strong arguments can be made against it. (I'd need to bring them up to the designer and project manager.) 

180 is an integer, not a float. So you'll get a whole devision instead of a floating point devision if is an integer as well. This is not the case, but it is dangerous so I recommend you change it to Clean up a little Remove empty functions, don't pollute your main function. So either remove or transfer some of the logic that's currently in . Polling versus events In your function you're polling the state. This means that every single frame, you're requesting state. In this case, it's about a few keys but if you have support for multiple players and controllers, this method is going to get computationally expensive. Responding on events is a little more complex, but worth considering for larger projects. Have a look at events in sfml. Use parenthesis They're free, so why not use a few extra. Take a look at this piece of code: 

Do nullptr checks In some functions (e.g. ) you pass a pointer while you're never checking if that pointer is actually valid. If the pointer cannot be invalid, pass a reference instead. If the pointer can be invalid, get some logging (use some form of asserts). Watch out for integer divisions 

The same happens in your where you create a temporary and then push them on . Why not add them directly to ? You know the size beforehand, so you can call on and acces the elements using the operator. (This way, the vector has to reallocate only once) Use namespaces You have some places with generic names, such as , which might collide later on when you include some math library. Use namespaces from the beginning to prevent issues later on. Prefer the compiler over the preprocessor If you can, prefer a const variable over a preprocessor define. 

And now, a line is gone and your code flows naturally and doesn't abruptly exit the function. Finally, this thing where you put your 

Here is how I would simply this: First, I would create a reduced method for getting "body" in fixture as such: 

Shorten the code Create a type of factory method for these "fixtures". This may not be appropriate for your case but with no other context that is what I would do 

Your variable names mean zilch to me. You HAVE to give them a better name. Also, create them up in groups of 2. This code here is also problematic. 

People generally took this to mean a String[] as that is what they saw in the dropdown. But ask yourself: Why Object[] then? Assume we transpos your case to Swing for a moment. You could pass in your Object[] into the constructor and override the toString() in your enums to display something useful as that is what would show up. Then when the selection is made you receive the callback telling you what it was (as an Object). But you know it's your enum. So, you downcast it and blindly call the 'attempt' method on it. If you have something similar in your arsenal, consider it. What you have here, actually, is an example of the Command Pattern 

You're using ramda for currying and nothing else? Ditch it and implement your own currying; it's not hard. Since usability is of a concern to you then making this an actual nodejs stream would be hot and also not difficult. Integrating it with iterators/generators would be handy A more natural usage would be 

Now, regarding your animation smoothness/stuttering problem. The following while loop is a bit weird: 

Since update is inside this loop and render is not, it is possible that we do not update and render the same state of the game again. The other way around: it is possible that we update the game twice but only render once. Both of these scenarios are wrong. The first one because we are going to render the exact same scene again, the second one because we're going to calculate how the scene should look like and then do nothing with the result, but rather calculate it again. For starters, try to replace this second while loop with an if and place the functions inside of it. 

Work directly on an object instead of a temporary in you use two temporary variables and just to copy them over into . You can the following code and work on directly: 

First suggestion: clean up your code. There are a ton of inconsistencies in variable names, indentation, brackets, defines ... Variables I was confused when seeing variables in your file, suggesting that these were global variables yet they are declared as member variables. My guess is that you moved away from global variables (which is a good idea) but forgot to fix the naming. I know it's annoying to change all those names now, but it'll save you a lot of time in the long run and many modern IDE's offer refactoring tools. Keep in mind that full-caps member names (such as ) are used to indicate constants or defines. In another file, , you use as prefix. Be consistent, either use the and or and prefixes everywhere. Moving away from global variables is a good idea because they are often quick hacks but often they can do more bad than good in the long run. Imagine declaring as a global variable, and using that in every manager. But when we want a single manager to update at half speed to mimic slow motion, we'll have to do nasty things. So in my opinion it's better just to give the time as a parameter to every manager. Defines Header guards should be the first thing in a header file. In this is not the case, so move those ifdef's up to save some compile time and potential compile errors. Const correctness If I call a function such as