Look like they should have been declared as class members (which now that you have added the header I can see that they are in there as well), rather than globals. The globals should be removed, they're just going to cause confusion. What's in a deck When you're dealing cards, you're deciding what card to add using a random generator. 

If you're running tests from within Visual Studio, then Categories are interpreted as 'Traits', so again you can easily exclude them from the tests that you're running, or just run the specific category/trait. NUnit itself and the console runner support multiple category attributes (so you can mark all tests 'IntegrationTests' and mark db tests 'DBIntegrationTests' then run subsets), however not all test runners recognise multiple categories (the default VS runner seems to just pick the first one). 

Don't silently fail This should probably throw an exception, swallowing errors like this leads to hidden bugs: 

Magic Numbers You've got some magic numbers in your code. I'm not totally against using numbers when the context makes it obvious what the numbers mean. However, this isn't always the case with yours. For example: 

This isn't really what you're looking for, just some general feedback on your code. I find the code quite difficult to follow, resolving some of the issues below to help with readability might make it more likely that you will get feedback that aimed at your algorithm. Naming Your names seem overly concise. A few extra letters won't make any difference to the speed of your application, but make it a lot more readable. Variables in are ,,,,,,,,,t2. Without looking at the context, these names are meaningless. Your method is similarly nondescript. Perhaps might be more appropriate? Consistent expecatations In main, you reuse the variable name for both an and an . Switching variable types like this makes your code harder to follow than necessary and illustrates that you could benefit from more meaningful names. Indentation Your indentation is all over the place. This makes it difficult to read. Sometimes you have indentations next to each nesting level, sometimes you don't. If it looks like this in your development environment, you should fix it. If it doesn't, then you need to check the preview when adding code to questions. Usually copying the whole thing from your IDE, selecting it and clicking the icon will format the code correctly. Consider this: 

I think you've missed the point The code that you've presented isn't what I would have been expecting given the assignment that you've described (I'm assuming there's probably actually more detail to the assignment than you've included). Stepping back from the code as written, you've been asked to write a server that uses multiple threads to service a client. The threads should be managed by a semaphore. Threading has a cost, so based on that description I'd be asking why do I need multiple threads to handle a single client. The reason that springs to mind is that the client can supply multiple requests to the server, which should be able to handle multiple requests concurrently. For this to be worthwhile the server needs to do something that takes some time to process (otherwise you might as well be handling it on a single thread). Note, the code supplied below isn't production quality, I've taken short cuts by making variables global and skipped error checking, it also hasn't been extensively tested but should illustrate my points. client.c Firstly, I'd have changed your client so that instead of sending a single message it was capable of sending multiple messages and processing the responses asynchronously. To do that in the code below I've created a second thread. So I have one thread responsible for reading from the console and writing to the FIFO and a second thread responsible for reading from the FIFO and writing to the console. This gives the following basic client: 

If the target value isn't found in before you get to the end of it, then you fall out of the loop at which point the code will return an unspecified value to the caller (you have a similar issue in ). 

Clean up after yourself Commented out code creates noise that distracts the reader. When you've got your code working, remove any commented out code. If you feel the need to retain it, use source control to maintain different versions of the source. You've also got an unused field declared . Again, if you're not using it, get rid of it. Be descriptive isn't a very descriptive name. It's a wrapper method for getting the calculation variables, so maybe would be better. is really checking for . Avoid over nesting Overly nested code gets distracting. One of the easy ways to avoid it is if it's possible to return early. So for example, your could look more like this: 

This would make it easier to handle errors (by throwing?) if you make it out of the for loop without finding a duplicate. At the moment, you'll return which could be misleading, since you're using s, not s in your array and -1 is a valid answer. 

Which to me looks odd. Fields Vs Properties In your equals you reference the member fields for the class the operation is being performed on, but the properties of the class it's being compared to. 

The Interface You've done some good centralisation of the interface with some of the board elements , centralise the interaction so that you could replace these methods and maintain the core logic of the game. However, your interaction with the Serial interface permeates your entire code. If you centralised this interaction, then it would be easier to remove the dependency (for example to run it on a computer, or if you wanted to use different components in the future). Consider using function pointers There are various points in your code where you are calling different methods based on an index like this: 

Comments Comments should tell the reader why you're doing something, not what you're doing. Comments like this are redundant: 

It's basically saying write s to the Console, but only until you find an error that isn't an . Then throw that exception. I don't like it firstly because it could have different results based on order that the exceptions have been added to the queue and secondly because it discards any exceptions after the first one. Exceptions for program flow Having which is a private method return void and throw an aggregate exception, which is immediately caught in the public caller, feels wrong to me. You've already collected the exceptions into a queue, why not just have the method return the queue? The caller can then decide what to do based on the collection being empty or not. 

You're not making the most out of your regex's. Regex's are good at checking for pattern matches, but they also have support for capturing elements of the expression. If you use the regex's fully, I believe it will simplify your code significantly. Consider this expression: 

I get every line that ends in a newline (i.e. every line of the file). -h -i and arguments If you're going to implement programs that take in arguments, it's a good idea to give the user some way to find out what the arguments mean. When I use , I'm trying to do a case-insensitive search. Your program advertises a '-i' option, however it doesn't do the same thing as grep. Instead I get told it can't open a file: 

Approach 2 I know I'm going to need to add some more states in the future (for character creation) and the from approach 1 already felt like it was getting a bit busy handling all the state transitions in the switch method. I'm also not super keen on using s for states that have branches (where a higher value doesn't necessarily mean you're further along the process). So I've refactored the code to user state handlers. This means that I don't have a anymore, I just have a and multiple state handlers. PlayerSession 

Formatting Your indentation is all over the place. Using a consistent form of indenting that reflects the scoping of statements makes your code much easier to read and makes bugs easier to spot. Consistency Be consistent with your interface. You define in terms of the data item that is to be stored in the queue. This is good, because it hides the implementation. However, you define as returning a . This is bad, is an implementation detail, there's no reason for the caller to need to know it exists. should instead be returning an (as this is the type stored in the queue). Print statements Your print statements don't belong in your queue. Part of the reason that you originally submitted code that didn't allow access to the values stored in the queue is because you put the print statements within it. Separate the concerns of your classes and test the boundaries. If you had originally tried to write your print statements in your is would have become clear that you needed dequeue to return something in order for you to be able to print it. Mains don't belong in collections Your main method doesn't belong in the Queue. It's not part of the Queue, it's part of your test harness. You should put it in a different class. This will help to enforce the boundaries between what is the Queue's responsibilities and what is not the Queue's responsibilities. Returns & Elses Where possible you want to avoid nesting statements too far. In your dequeue, you're doing this: