However, now that you have actual code to review, I will also point out that there is no reason to be using a loop vs a loop. I would write that as follows. 

Lets kill that giant nest of code. When an Exception is thrown, it interrupts the flow of the program. The code does not continue to execute beyond that point, it is like an early return in that regard. This means we do not need to nest our next statement in the Else block, because if an exception was thrown the program has returned. You should not be throwing Exception, not to say you should throw exceptions, but just not throw the base Exception class. Instead make your own exception class that inherits from Exception. An incredibly simple way of doing this is just... 

Make sure you are disposing(closing) your database object. I presume by the way you have your class setup that when your database object is disposed it will close, in which case I would recommend using the keyword. Which would make your above code look more like this in practice. 

Your program is a bit flawed. Technically just 0 is a subset of {0,1,2,3,4} however you appear to only care of subsets of 2 or more numbers. 

Follow pep8 Use duck-typing. So, for example, use It will be much more efficient to filter items in another list comprehension, since it only requires one search through the list rather than many. The simplest approach would probably be to change the first list comprehension to a generator expression, then feed that to a list comprehension that filters out empty strings. This could conceivably be a single list comprehension, but I think it would be too verbose. Further, it would require stripping twice. 

You recalculate and a lot. You should define them once and re-use them whenever you need. uses . So you can define in terms of . You can use something like instead of something like to make your code clearer (in my opinion). If you use , you don't have to do so immediately. So you can define your words, and define your separators, then combine them later. You can short-circuit your last clause by putting it near the beginning and having it the result. This allows you to unindent a large block of code. You never use the initial you create. Get rid of it You re-use variable names for different things. That is confusing. You should use more descriptive names (I have taken a shot at that in my example below). If is expensive, you should probably only do it once and store it as a global variable. You can then pass it as a default argument to speed up access. This also makes the code more flexible since you can specify an alternative word list if you want. You should use boolean operations rather than to check if multiple booleans are the same. In this case, you can reverse your test and use , which will will return if and only if exactly one is . Python doesn't explicitly have . Since you are sure in this case that both are , you can use instead. and are just used as test values later. You can remove these by moving the test into the code block where you originally create them. 

I'm working on some precompilation operations for a world compiler. Currently to identify flags placed by the level designer I need recognize when a specific entity exists at specific coordinates from the flag's origin. I need to generate a list of offset coordinates from the origin(and include the origin) in string form. That is 7 coordinates. this operation is done for every flag in the world, so it is preferred to be efficient. It is not an operation that takes place during gameplay, so I don't have to worry too much. My current implementation works correctly, and quickly, however I still would like to get a review on what I have written, and hear any advice to better this operation. 

I just wrote this short little program to increment up the build number for my projects every time I build them. After compiling this exe, I just call it in the pre-build command line. I did take out the filename string because I used it thrice, and I figured I'd get some flack if I didn't. 

Some people prefer that, I just am not, and that is up to every coder to decide. If I was to put brackets arround that, I would probably do it this way 

Because the TryParse method returns a bool you can just use this in an if statement which is conditional on the TryParse returning true. 

This can be improved even more by separating out the rows that can be vectorized from those that can't. 

So you can see it takes the same columns you did in your original, but keeps them in a single 2D array. And it greatly simplifies the code and speeds up the computation as well. 

A few things for the function: First, your code won't work when an item is an iterator and , since it will consume the first sub-item in the iterator, making the next loop skip the first item. A better approach would be to run the test, then check if has been defined. If it hasn't, then you can yield the item. I personally use a short-circuit to avoid nesting too deeply, but this again is personal preference. Second, you really shouldn't use here, you can just use an test to short-circuit. Third, this may be a personal thing, but I don't like explicitly testing if something is a . For example, if you don't want to flatten a , you probably don't want to flatten a , either. I prefer to duck-type for a -like object using , which tests for the method. This should really only be present on -like objects, although I admit it isn't perfect. Fourth, some of your other functions would be easier if you include an option to split strings. Fifth, just because an item has the method does not mean it is iterable. It may have something in the method that raises some except. So it is better to test if it raises an except if you try to make it iterable. For the function: I don't see the point of here. How would adding an empty iterable to anything do anything? Second, I would really put the string-handling function as an option. So perhaps if , then you can raise an error since the items cannot be combined. And I would use a more descriptive name ( is common). Third, again this won't work if any items are iterators, since it runs through them twice. There is no way around this other than to convert the items to a list or something like that. Fourth, I think a generator expression is easier to understand than a map. For : If you include the option I mentioned above to flatten strings, this becomes much simpler. You just pass that argument along to the function. So here are the resulting functions 

Point of affirmation, this is indeed a good binary search. finding halfway between your highest and lowest values will get you to the answer on average the quickest. 

Review I don't know if this is something you should implement, because I don't know how you intend to use this class. In C# you can place access modifiers on the individual parts of the getters and setters. A way you can use this (again, not sure if you need to, but this is isncase you do): 

Yes... there is a simpler way. You have two choices, but each about the same. Use an Array, or a Map. The more advanced way of doing this would certainly be with a Map. Think about a map as a type of array where instead of using an integer to index the array you can use anything. In our case here we'll use char as the index. Because chars are ints you could just use a simple array in this case, and just mentally think of 'a' as 0, but we're going to take the larger step today. 

A good alternative to your current implementaiton would have been to create a recursive function which takes in , and the method would simply loop over the remainingNumbers and making new composites to check on, each time you would want to check just the currentComposite to see if that is a valid set. The way I would do it, would be to create a list of number arrays which hold every combination of the given numbers, then I would simply loop over that collection to determine which sets fit my conditions. Here is some code I found online (specifically here), because I did not want to make my own Combination generator. I'm going to post this code on CR, because I'd like to see someone take a stab at making it better. 

Follow the pep8 style guide The initialization should be moved into its own function. Many parts can be greatly simplified by optimized by using with vectorized operations. In (which shouldn't be called that, btw), you can use rather than keeping track of the vertex number manually. You can do . You should probably use single leading , since your code doesn't benefit from name mangling. You can reverse and use a to reduce the nesting by one level. You can use string replacement, for example . In , at the end define the string outside the loop with and then on each cycle of the loop replace it with . In , in the final loop you can use to avoid having to index into . In , you can do instead of using a set comprehension. You can do to make list of tuples. Do not do , though. You should use or instead of or . You don't need to wrap single tests in . You should make a function and put all the code in in there. Then just call that function in . 

They key point to these two approaches is that they only ever keep one line in memory at a time, which saves on memory enormously. Or, if you want to do some other manipulation on the lines before saving, you could do something like this: 

I was able to compile and run using , perhaps I wasn't using c99. So perhaps just don't use c99 :). If you have to use it, then declare those ints as symbols or consts above , then you can say 

Edit: This is of-course personal taste, but I dislike (what I consider to be unnessary brackets taking up newlines). 

Now the succeeded value is available after the method returns, and will only be true if all values past the test, and now there is no nasty exception throwing, which hurts your application's performance and is just bad practice. You can call the method like this now. WITHOUT a try..catch surrounding it 

Separate your main-loop logic from your main menu rendering logic. You should have a main-loop, which calls recalculate, and draw, then in your draw you should draw the appropriate menu, based on the games current state, the logic should stay in its own class away from the main-loop. 

Contact and ContactItem should in some way be child and parent, or at-least share a common ancestor so that you don't have to manually copy over all that identical contact information. I'm not certain, but I think you might have wanted all this to be done with the and not the of this contact. You should be using in-case these strings haven't been trimmed or something. As for simplifying your nest of ifs there are two solutions that fit the program as is. 

Without knowing what your file is structured, it is hard to give too much concrete. I do have some suggestions, however. 

and are not very big (on the order of tens of megabytes, tops). You can vectorize those and re-use the values. In fact, they are identical, so you only need one. You not only never use the other values of and besides the current one, you overwrite them repeatedly. So these are better off as scalars. You can vectorize many of the values for the two innermost loops. If you put the third loop as the outer loop, you can vectorize and . 

You can improve this further by making the column list comprehension a expression. I think this will give this a space complexity: 

The functions can either be s or external functions that are short and easy-to-read as values. Usually this is better with only one or a few consistent arguments. The functions are so long that putting them in an chain makes it hard to keep track of the flow. Again, usually this is better with only one or a few consistent arguments. There are a huge number of possible inputs, which makes for an overly long test chain, but where there are again only one or a few consistent arguments. 

Edited additional points In this line you'll notice that you are printing the address of not the value of as denoted by the , remove this if you want your program to run properly. 

will replace the condition for checking null-ness and emptyness, I would recommend you look at as well, this is good if you may be getting some blank spaces newlines or tabs with your data. (Optional) Instead of comparing your Enumeration to 0, implement a value, this way in-case someone ever changes the default values of enum this code will still work. Or if you don't want to change the enum, you could just check to see if the value given is a valid value in your enumeration. 

Over all, your program could look like this. Note: I didn't programatically address the issue of the user escaping your program, I noticed you updated your OP with that. 

use iterator instead of , I also took the liberty to use ternary operators instead of giant if-else bocks. 

Use Statements.... Or not, if not... this is probably as optimized the code is going to get. Here is my rendition of what your code will look like if using switches instead. I just switched the regular flag enums, although you'll probably want to bitwise OR them with the rest of the values as you were doing in your OP