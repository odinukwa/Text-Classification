we can make some minor optimizations by skipping the comparison for , , and since we know into which partition they should land. The first two are already in their correct partitions, so we start by shifting in the looping terminals one slot. By performing a swap to place into the second-to-last slot, we can skip comparing it as well. Here it must be placed at the far right end of the partition, next to . 

You'll need to add synchronization to guard any access of the pointers and size. Sometimes you can merely add to the method, but this usually hurts performance. You want to shrink your synchronized blocks to the bare minimum; prefer using blocks over synchronized methods. Here are some other suggestions unrelated to concurrency: 

Map vs. List To your comment, since the caller is free to use sparse keys, e.g., 1, 29187, 23957172, 6832, 4772589, etc., the map (assuming it's a hash map under the hood) will give you \$O(1)\$ access for the most part. If you were to assign the keys as indices into a list in and return the new key, you could use a list instead. I don't know how Go's internal map and list are implemented, but I assume it must provide some sort of growable array class. If not, they aren't difficult to build. As a user, I would prefer to have the graph assign the keys for me. 

Overall Design For such a small amount of code, I find the logic extremely difficult to follow. I understand what is happening at a high level, but it seems every function is responsible for managing everything, and program control bounces around a lot. As an example, the final function assigned to has several responsibilities: 

I highly recommend Clean Code: A Handbook of Agile Software Craftsmanship by Robert C. Martin. It's an excellent source of great advice precisely aimed at your questions. The earlier you start, the fewer bad habits you'll need to unlearn later on. Formatting Your line length and whitespace seem okay, though you a little off from Sun's (now Oracle's) Java Style Guide. I always put whitespace around keywords (, ) and between closing parentheses and opening braces. Naming Ignoring and which you've already explained, I would get in the habit of using fully-spelled-out variable names now. They are clearer and help you practice your typing skills. There are a few abbreviations that everyone will understand such as and , but they don't make good names by themselves. 

You are duplicating the code that advances the cell indices in : once if the cell comes in already filled and again when you place the next guess. You can drop the latter and simply pass in the same cell indices since you're setting the cell's value first. 

Note that I would probably store the three variables into an array instead of individually-named variables, but I have no idea how they're being used in the wider context. The code here should be a drop-in replacement for yours. 

Brian has some great suggestions so far, especially extracting reused functionality. When cleaning up a large method such as this, my first step is usually refactoring it up into smaller methods. I find short methods easier to conceptualize, clean up, and reuse (when possible). I highly recommend the book Clean Code: A Handbook of Agile Software Craftsmanship for great coverage of writing clean, manageable code from the start. It also provides many tips on cleaning up existing code. While its examples are in Java, it applies to most every language. 

Here each holds the specifics for a single unit belonging to a team: its position, health, action points, etc. The table lists the things that don't change about a unit: its ammo and fuel capacity, strength, etc. This minimizes the data duplication across tables and allows you to load up all unit types at the start of the game or in tools for easy reuse throughout. 

Beware of storing calculated information in the database, especially time-sensitive values like . You must ensure to have a (yearly?) process update this column based on the current date and . What happens if that process fails? How do you catch it later? What happens if you restore from an old backup? Is it worth storing, or could you recalculate it when needed with little cost? The and tables are nearly identical. Could you benefit from a table to allow a more generic data-entry form? It may not be worth it since they would probably create a new record if a student were to become a staff member. I find it much easier to analyze a schema with a couple rows of sample data per table, except for the obvious tables like . I assume is grade level (1st, 2nd, etc), but I'm not sure. I think and should be merged. Each row tracks the scores for a student plus grade plus year, or in your case, student plus grade-instance. is a joining table for , , and year. The use of the word "instance" here works somewhat but I think could be replaced with something more meaningful, maybe even . In the U.S. we call a grade, and a class, at least that's what I get from your table definitions. Again, sample data would help. You might be missing an actual table for to which you can relate the s that are taught that year? 

Without seeing the greater context in which this code appears such as how the components are constructed, and not having kept up with Spring since 1999, I can only address the immediate code. The above could be converted to use two maps: one for the text fields and another for the strings. In the code that builds the components, create the two maps and store them in instance fields of the same class. 

If after adding the index on and you still see poor performance, trim the query down to the bare minimum to isolate the source. Remove all of the joins and the where clause referencing those tables. Once it's doing just the distance calculation (which should be move to a deterministic stored function), you can get a better time measurement. On an unrelated note, you can set the three variables at the top with a single statement using . 

You can simplify your intersection methods by employing and . It would be nice to make these instance methods of the rectangle classes at the same time and introduce some static factory methods. 

I'm going to hit the high notes on my phone and swing back later with details unless someone beats me to it. Allow Add a separate boolean field to track when holds the actual next element rather than using as a signal that it needs to be populated so that elements can be supported. Avoid Recursion In this case, there's no reason for to call itself. Continuing the loop should have the same effect. Use Generics Even though you're stuck using for variables which may hold an element or an iterable, you can still add a generic type to the class and specify it as the return type from . At least, I think you can. :) Testing When using the annotation, you don't have to prefix each test method name with . However, you really need more descriptive method names, and each test should validate one specific condition. Burn this into your brain: Arrange, Act, Assert. Arrange the test fixture in the initial state, perform the action being tested, and assert the results. It can become tedious to setup the fixture each time, but helper methods can ease the pain and promote DRYness. 

One thing I definitely don't like is leaking outside of . I think should return the node's name instead of the node itself. should be a static inner class of and entirely an implementation detail. Finally, as Banthar said, you need to look again at the case of removing a node with two children. It's hard to tell from the code, but it looks like you drop the right subtree instead of assigning it to the replacement. As well, you should be promoting the right-most (largest) node from the left subtree, yet I see you moving left in . A better name for this method might be since it should be removed from the left subtree. 

How does this line up with there being 3! permutations? Consider that each permutation requires at most two swaps to create. The worst case is which takes only one swap to create from --swap and --requires all three swaps to revert using the brute-force algorithm: 

each time through the loop. Otherwise, the code looks the same as RoToRa's solution (+1 for the formula, btw). 

Importing Classes I used to prefer to import each class separately (no ) so you can see at a glance what the class uses. However, as I focus more on creating smaller classes it's not such a big deal. I still do it, but I'm not anal about it like I used to be. Pick a style and stick to it. 

Drop one-time use local variables and use libraries such as PyHamcrest to improve assertion readability. Compare 

As to your question about the time complexity, my gut says that it is probably possible for the worst case to cause an infinite loop, but I haven't delved too deep in the actual algorithm yet. To rewrite this iteratively you'll need to use a stack to allow backtracking since you sometimes need to branch both directions. Here's a quick stab at it in psuedocode: 

This eliminates much of the -checking that complicates code and makes it harder to read and follow and is a common source of bugs. 

PostfixCLI This class is very simple, but there are a couple small changes you can make to start teaching good habits to your students right away. 

While this will require more code, it will be pretty straight-forward and allow you to make moves without iterating over the same possible numbers again and again. 

One improvement you can make for DRYness is to replace the with a simple . This is possible because the AJAX call passes the field name in the parameter (they all seem to match). 

The Java memory model guarantees that the reference will not be written until all writes have been flushed. The field will be initialized when the class is loaded and safely available to all threads. This has the added benefit of avoiding synchronization to access the DAO. 

I see no reference to . Is this a bug or intentional? Does the system ensure that forces to be ? Assuming the code is correct we can define 

And now for something completely different. You could completely bypass the question and simplify the API by employing two Null Objects: one each for an empty set of contacts and resources. 

but I found it easier to move the first/last element handling out of the loop. Also, negative list indexes reduce the calls to which cleans up the logic a bit. My first refactoring built a new list in-place with similar procedural code: 

The linked controller, however, is doing way too much work. It should be passing data off to a model class (not the entity manager directly), placing whatever the view needs into the , and that's it. Controllers are glue code. As you have it, you'll need to copy all of this code and modify it slightly to expose the CRUD interface in another form. For the code you posted, I would prefer to separate the actions so each handles one specific use case: all items, items matching a category, and one item (not in the code but you mentioned it). Create a regex route for the last two. The beauty of this is that you don't need to do all the conditional checks--the dispatcher does it for you. 

Update: Start by replacing named variables such as and with an array of number/styles so these become and . Add another loop to assign the numbers and styles. 

The parser is doing way too much to cram it into a single method, and that it knows every operator requires two operands paints yourself into a corner. The first step is to move this code into a separate class that can maintain the stack and do the work to manipulate it across methods. The parsing method needs to be refactored into methods to scan the input, parse each token, apply it to the stack, and finally return the result. Here's a rough cut: 

If you can assume that every index in the encrypted message is included in the key, You can loop over the key and encrypted message together, placing each letter into the correct decrypted message slot directly: 

Without the real code to be tested, I can only provide an example of how I've tested something similar with QUnit and Sinon.JS, though you don't even need the latter. You can either use Sinon.JS to mock a response to the AJAX call or substitute your own manual mock for or . I find the former preferable as it documents the AJAX call and tests the full front-end code, but it's beyond the scope of this question. You could argue that you're needlessly testing jQuery itself, and you'd be right. YMMV :) Mocking JQuery Let's assume this click event handler that uses the AJAX call to acquire a JSON string. I've omitted the extra deferred for simplicity as your current test of the promise attached to the element is fine. 

That's better, but is still doing too much. I don't like that it has to parse the original message, check for an empty chat message, and send the formatted message if it's not too long. Let's extract the parsing first.