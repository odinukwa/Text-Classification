This makes the purpose of the code more apparent. Also, a bug is that you have to declare this ourside your method. It should be a class-variable, not a method variable, otherwise it will always be the wrong value. The bug you have is a technical one (but important that you learn) ... will never return the input . It will retrun (inclusive) to (exclusive). In your case, with it will only ever return , or . Change that to be and you will get the values , , or and it will be 1 third of the time. 

is an interesting one. It may, or may not be more complicated to consider, but XPaths can be compiled, and reused. You can also have variables on them. I would consider the following: 

OK, so now we have a client that can process incoming messages, let's look at that code, but using a scanner now instead of a reader, and it does not need to do the or the related "publish" of the deletion. It also does not need to close the connection: 

Then, you should have an anonymous listener that handles just that one view, and it calls back to the non-anonymous handler: 

The advantage of the above code is that is plays much closer to the operating system. In theory, it should be the fastest possible way for a Java program to read the file, and it should never transfer the actual file content in to the Java memory space. It removes at least one data copy between the file represented in the OS on disk, and the copy in memory. There is no limit to the size of file you compute the hash on. 

What's interesting, is that, in part, you have the concept right for the inner-map... This code is OK: 

Every time is a multiple of a million, report it. You can incorporate this in to a stream as follows: 

The one that is missing from those is the use of XML functions.... It is a relatively commonly used 'hack', to use the XML-processing functions in Oracle (and other databases) to reformat the data in a more convenient way, and then to extract from that XML just the parts you want. So, ideally you should create a user-defined function for your problem, but, you can accomplish the same thing, perhaps faster, with a hack of XML.... Consider swapping the nested select: 

The title of your post puts a lot of stress on removing the loop. Can it be removed? No, it cannot. You need at least one loop to solve the fizz-buzz... Additionally, the 'print' statements are by far the largest bulk of your performance problem. I don't really believe that this code suffers from a problematic performance issue, but, if you want it to go faster, your best bet would be to accumulate all your String values and only print the line once: 

There are a few things in here that make sense. The first one is to use a function, and to return a List of words from that. The next thing is to use a do-while loop instead of a while loop... actually, truth is that I would personally use an assignment in the while condition. This is relatively uncommon, so let me explain: 

Sometimes (actually, normally), simpler is better. I'm going to present a different way of doing this that's really simple, if you understand the tricks, then I'm going to explain what makes it better. One of the reasons I am doing it this way is because your code is hard to follow.... simply because there's so much. I suspect that when you see a different way of doing things a penny will "drop". Here's the alternative: 

Now the 'tail' part is obvious. As for whether tail-call optimization is performed, I don't know. I expect that the compiler may completely re-write this recursive function as an iteration..... which leads on to the next question: Which one is better? In this case, the iterative solution is best. It has the least impact on resources (stack space), and will be fastest. It is also the most intuitive (readable). Your iterative solution would be preferable 

You are doing twice as much work as you need to.... you fell in to 'the trap' of making the code follow the instructions, without thinking about the implications of the instructions. In the grid: 

Note the use of the atomic Files.move(...)` command. One day, when your file-system is full, and you run out of space... you will appreciate that change. 

Observations Note that your query (and my suggestion above) will return the answer multiple times if there are multiple 'thank you' comments. I would consider adding a join back to posts to only consider comments made by the owner of the question that was answered too. At the moment, anyone can add a 'thanks' comment to any post, and make that answer appear. Joining back to the questions would also allow you to remove closed questions as well. In general, the code style is consistent, and that's always good. I considered recommending an in-memory table containing the values to search for in the comments, something like: 

This array represents the buttons that you check for a winning condition (except is only in here once ;-) ) Now, with the above structure, consider the following loop: 

This makes it look like there's something you are guarding against, but that's not true .... nothing else is calling this method, and no other methods are synchronized, so there's no protection here at all. instead, what you should do, is a checked set.... Your code is essentially: 

Your code does not have a base case and a recursive case..... unless you consider to be the base case... but that is just the recursion-terminating statement. What I mean, is that, consider this loop: 

This reuses the same word again, and again... The description does not give a clear indication whether that is valid or not. The code in the example says it is valid, but, am I to trust the code? Your Solution I considered how I would solve this problem, then looked at your code, and could not find that pattern. You do have extensive error checking (for nulls, empty, and otherwise broken input). This is good. Bug1: - then I noticed that you have room for just a single matching start pattern... and that made me think there is a bug.... what if the wrong word matches, and there is not another word that can carry-through on the problem Bug2: but, then I found this code: 

Using this system, the socket STAYS OPEN ALL THE TIME... do not close it! This is the way that TCP is designed to work. NOTE, you need to make the corresponding changes on the server side as well.... The server cannot keep closing the socket after every transmission... it needs to read a line, process it, and wait for the next line without closing the socket. Read up on the Java Socket Tutorial.... 

Using a Stack (really, a Deque - or ArrayDeque ) would ba a typical choice, but in this case, I feel that converting the primitive int values to an Integer would be unnecessary. Using an array would be simple enough.... especially because there is an upper-bound on the stack size. So, taking that all in to account, I would suggest the following changes: 

Then, I recommend you process the fields you don't need, and it helps you keep track of the specification: 

The answer is: yes, it is large, and the code is ugly.... and he's right. But, not everything can be small, and pretty. This is the lesser of the evils. I would not change it. Your class has a lot of related data, it has to get in there somehow. Other Issues Your constructor has the input but does not store that as a property. You should consider using a generator in your : you should each File, instead of returning the completed list. 

Note that many text books extract the first 3 stages in to a 'partitioning' function. The purpose of that function is to identify the pivot value, move the candidates around, and then insert the pivot value back in to the data at 'the right place'. That last part is key, it leaves the pivot value in the exact place it is supposed to be. This means you never have to include that pivot value in the sorts again. Let's break that logic down in to it's methods, then, with the assumption that' there's a 'pivoting' function that does the first 3 steps. That leavs a simpler quicksort that looks like: