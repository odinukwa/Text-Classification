You do not need to take the numbers by reference. Do not put an underscore at the beginning of the variable name. A variable name beginning with is used to say to the compiler that the variable is unused. 

This cannot work as-in, because cannot be borrowed twice, but if you rewrite your data structure differently, this could be ok. Do not use Use instead. Be careful about code formatting This could seem meaningless, but people can be embarrassed by missing spaces, or other badly formatted things. Do not be afraid to use the official code formatter. 

I would try and approach this more generically. Define a rules interface, run each section of the string through the Rule and add the result. The rules can then check individually for all caps, exclamation marks, etc rather than hard coding it into your central method. (i.e. a rule that returns 1 point for every exclamation mark it finds or something). Might be worth having two types of rule - "full string rule" and "word rule". the full string rule can process things like total number of exclamation marks and stuff, then you split the string on whitespace and run all the found words through the word rules. For things like nice/nasty words I would have a configuration file somewhere listing words and a positive or negative score next to them - for example please -10, swearing +10, etc. Your word rule can then scan your words against that dictionary and apply the result to your score. 

If you only need to read one line from a file that will not change at runtime, you can use As already said, the whole program can be simplified a lot using a functional programming style on iterators: 

My question is not only about the algorithm (I think that it is ok, and the problem is not that difficult) but also about the "haskellish" style. Because I am used to Rust/Ocaml/Elm etc., at first I wrote: 

Explanations: gives you a shifted string. makes the iterator cycle infinitely, remove the first (replace it with for the second part. You the zip the two iterators: one on the string, one on the shifted string. Then you keep the pairs with same numbers: Then you convert each to and you discard the failed conversions. Then you make the sum of all the numbers. If you want to do the two days in one like in your code: 

You are using a lot of different variables to store the objects in and declaring them for your whole main method. If you really needed four it would be better to have an array of but in this case you are better just having 2 (maybe still in an array) but only create them when you actually need them and set them to the right type then. By using the array that then lets you change the player 1 and player 2 while loop into one for loop to run over the array[] and you can remove all that duplicated code. It also lets you support any number of players virtually for free. For the loop you can use a do-while loop as you know you always have to run through the loop at least once. It would be more efficient to use one Random object created in Main and then passed into anywhere else that needs it. Other than that your Pile object looks fine. Your Player object is a classic case where inheritance should be used. Create an abstract base class Player and then create subclasses HumanPlayer, ComputerPlayer and SmartComputerPlayer (the computer players may or may not also have a common ancestor). Then you just have a Player object reference in your main class and it calls the relevant method in that - which gets sent to the right subclass automatically. 

I am learning Haskell, and what is better than advent of code to do so? The day 1 problem is about adding together the digits that are followed by the same digit from a "circular" string (the next of the last is the first). My solution is the following: 

then I read that Haskell people prefer to compose functions and then pass the parameter, not doing the forward thing. What do you think about that? Also, I searched over the Internet, and I found some divided code, more like that: 

The separate variable h is needed for thread safety. Otherwise you could potentially have a second thread see a partially computed h (or as already mentioned have two threads calculating a hash at the same time and interfering). Both will break things badly (for example inserting a string into a HashMap with the hash wrongly calculated and you will never find that String again). Copying value to val[] looks like a now-obsolete micro optimization. Again the immediate check for the array being empty is a micro optimization to handle the empty string case without entering the loop. 

This is a very broad question. I advice you to think things differently. In Rust, you can give a thing, or only lend it (the thing is borrowed). The general answer is: if you do not need anymore the thing, or if the receiver needs a full control on it, give it away. In this specific case, the thing is copyable and small (as small as a reference, in fact). So, borrow it does not give any advantage: just take it (or take a copy) and do not bother with references. 

In general for OO programming you separate out code into objects and each object focuses on doing one thing and doing it well. Each object should then generally have it's own source file in your code tree. 

Something to remember about the Java libraries (especially older ones) is that they were written when Java was a new language. Some of the techniques and patterns we use as standard now were not available and the compilers, optimizers etc were a lot less smart. A lot of things we can just ignore now and let hotspot handle had to be considered in the code, and since these are core libraries that must run well on every possible Java device they cannot assume anything about the environment they run in so have to do as many optimizations as possible by hand. Sun's code to compute hash of string: 

Not sure if my explanation is legit, but when you give a thing to another function, this function can do whatever it wants to this thing: it can take it as mutable or not. That is not anymore the problem of the previous owner. 

You better express your attempt with this. Also, you do not need to put the type of depth, this is by default. If you want to run at least one time the block, this is better (in my sense) to write this: 

This is a very nice implementation, and in fact will be just as fast as the sun one since over an Array internally uses a style approach. The problem with it is that it is not compatible with earlier versions of Java since the loop is a recent addition to the language. Micro optimisations You will see this term a fair amount in this sort of discussion and in general it can be read to mean "something that makes such a small performance increase that it is not worth the increased code complexity". In the usual development scenario keeping code simple will reduce bugs and increase developer performance in terms of functionality provided for time spent far more than the micro optimisations can increase application performance. In fact in some cases micro optimisations actually degrade performance as they confuse the compiler which otherwise would make the same or better optimisations behind the scene. "Premature optimisation is the root of all evil" - Donald Knuth This is a well known quote in this field, although actually if you go hunt down the full quote there is far more to it than the catchy tagline. As a developer you should focus on writing clean and well structured code and on the big optimisations such as choosing the right algorithms, data structures, etc. Once that is done if you still need to increase performance then assuming you have the right algorithms and data structures (which will save far more than any amount of micro optimisation) that is when you look at progressively finer optimisations. But keeping the code clean and readable will gain you far more in the long run...quite apart from anything else it makes it easier to get the algorithm right! The core Java libraries are a special case as every single Java program is written on top of them, so slow performance there slows down everyone...and they have to run on every single JVM so they cannot rely on clever compilers or virtual machines. In many cases the core Java libraries are a bad source of coding examples. Partly for that reason and partly because they were written when Java was new and people were still learning the best ways to do things. In fact the book "Effective Java" by Joshua Bloch uses examples from the core Java libraries as things NOT to do. That's an excellent book by the way, you need some Java experience to appreciate it but I recommend it to all developers with a year or two of Java behind them.