This translates each of the items in the array returned in the previous into their value. Finally you assign that to beverage_links. If is an array of beverages, I recommend you rename it to . It is obvious that if you have a beverage, you have the info of that beverage. If beverages are a custom class, give it the method because nothing else will use that (unless you have, say, burgers that are also menu items. In that case, both and should extend some class that has the method). The way you have it now, it doesn't look like you need to be using the keyword, but it's hard to tell without context. 

Now you can uncomment those extra rules or throw your own in with ease. If the method for determining replacement or not changes from being to , you only need to change a single location instead of once per rule. (This practice is called DRY, or "Don't Repeat Yourself".) I can explain the code further if you want, just leave a comment below. 

Returns nil when the search fails or false when the group param is not an array. If you are confident in your ability to pass in Arrays only, you can clean it up by getting rid of the call to 

A final thing to consider when you get more familiar with Ruby - do not use Class variables, use Class instance variables. Class variables have wonky behaviour with inheritence. 

You have way too many comments, delete pretty much all of them except for the ones that are REQUIRED to understand what the code does; 

In , you say that and are attributes but you are not treating them like attributes. You pass them to the function when that function could just access them as instance variables using and syntax. This will first require you to set those variables, however. Either pass them in to the initializer and set them explicitly, or you could use in much the same way as above to create the and methods. Then you can set the variables whenever you want by calling, for example, 

QPaysTaxes has a lot of great points, but one thing that stands out is that you are asking for the "Idiomatic" way of doing things in ruby. For fizzbuzz, that would involve a hash mapping numbers to words so you could easily and arbitrarily extend it. I would rewrite QPaysTaxes function as such to get more idiomatic ruby: 

When you use a method that takes arguments, surround the arguments in parentheses unless it's a Kernel method (like , and ). That line should be: 

I wouldn't use this with your current requirements, but the possibility is there if you needed the extensibility. 

and now people can answer "yes", "yeah", "no", "nope", "y", "n" and still get the desired result. If you don't use a case statement you can still add this functionality in conditions: 

Adding to what rui said, it is usually nicer to present well-formatted data to the user; in this case, "Florida" instead of "FL". Store your STATES as a hash, using Hash#values for the display and Hash#keys for the internal logic. Also, considering using Symbols for the Hash keys 

This should be a constant, declared in the Dinosaur class and not in the carnivorous method. Also it doesn't make a lot of sense. If means carnivorous, what does mean? I would change this to 

REALLY not needed. Now get rid of the rest of the comments too, and reword your code so that you can understand what it does without needing the comment. 

Lines 2, 3 and 4 are indented further than 1 and 5 because they belong to a deeper scope. Doing nothing but re-indenting your code gives us this: 

You can do some nifty meta-programming to dynamically define the methods. The code below is slightly modified to show the results, you should find it trivial to change back to suit your needs. 

So I created a function that takes a pattern to select a file, and then optionally opens it with a block so that I can pass in the block above in the case of the xml file. How do I reduce the repetition in the code? 

(Note that I dropped the , the parentheses, and the as per my previous point). You typically don't use parentheses on conditionals unless it would be prohibitively confusing without; see the style guide Make a similar fix for this and other lines: 

Avoid using . In this case it's not too bad, but imagine in the future you want people to also be able to answer "q" to quit the process and "a" to automatically rename them and "c" to move them but keep a separate copy, etc. You'd need a separate condition in the elsif for each. Instead you should use a case statement: 

Your current regex is WAY too forgiving. First of all, every one of your example starts with a P followed by some numbers, but you accept ANY COMBINATION of letters at the beginning. I'm assuming that isn't a valid key, so you should take steps to reject it by using hungry quantifiers as little as possible (, ). Using matches a digit between 3 and 4 times, so that will let you limit the sort of input you accept. The same goes for the 5th group - according to your examples, it's either , , or 4 digits. In Regex, that looks like this: Next, you are using alternation () to capture the different "forms" your string comes in as, but you are repeating a bunch of stuff (for example, the at the beginning). You can limit the scope of the alternation by surrounding it in brackets (). You can see this in action with the example - that whole bracket group becomes a single token that matches somewhere in a string (or doesn't). Sometimes the string ends after the 4th group (Before the L/R group), and sometimes it doesn't. Instead of using alternation to solve this, which makes the regex VERY long, you can just surround the entire regex AFTER that point in brackets with a question mark (). This makes the entire second part optional. Finally, your problem asks if there is a simple method to improve the regex. By ending it in you can match ANY length of additions to the end, assuming the all come in the form or or whatever. If you knew that there was always a max of 15 numbers added to the end, you could change that star () to a max quantifier (). If sometimes the number only has two digits, change the to , etc. See it in action here 

To access a*b where a >= b, the answer is in arr[a-1][b-a] To access 3*4, the answer is in row 3-1, element 4-3 = arr[3-1][4-3] = arr[2][1] = 12 To access 5*2 (= 2*5), the answer is in row 2-1, element 5-2 = arr[2-1][5-2] = arr[1][3] = 10 To access 100x100 (assuming the range goes high enough), arr[99][0] You'll need to do something slightly different if you are passing an array that isn't 1..x - in that case, first look up the index of each of the two numbers in the original array and use THEM in the arr[a-1][b-a] lookup. I suspect you'll need to subtract 1 from the indices but I haven't worked it out in my head. 

That's a direct translation and a much more 'ruby' way of doing it. There's another way to do it as well, but it's not necessarily better. It lends itself nicely to extending the number of players - imagine you later wanted a 4 player tic-tac-toe game. 

Ordinarily, you would just use instead of , but in this case you can exploit the fact the ruby treats EVERYTHING that isn't or as true; change this line to: 

@Borsunho made some points on functional improvements, so I'll address some style points. - Folder name is already a string, so you don't need to wrap it in a string and then interpolate it. Just use . 

and if you ever need to look up where , instead look up This will create a multiplication table that looks like this: 

I need to open and read several files for a project. Some of them are plain text files, and I just want a standard to read from. One of them is an XML file, and I want it automatically loaded into Nokogiri in the following way: 

This requires you to have methods for all your queryables, which you seem to already have by using . If you wanted to get really fancy you could modify your options hash to look something like this: 

In in your vast amount of getters, you don't need to be specifying the keyword or the keyword. Methods are automatically invoked on first if they exist on self, and everything in ruby automatically returns the final line it computes before exiting. You use the keyword in a few other places as well and for your cases it's not needed. You DO use it when you want to return early from a method, but you're not doing that here. (Edit: I'm not entirely sure about not needing to use the keyword, because your are not instance variables - see below`) 

Don't use for simple conditions, use . But in this particular case you are just checking against , which is already 'falsey'. Just do this: 

If you didn't know, creates a method called (in this case, ) that simply returns the instance variable (, exactly what you already have). Remember to change the places you call it from to . This use of wont' suffice for some of your other getters, as they have a bit of logic behind them that you need to state. This leads into the next point - rename all your methods to . This will keep in line with the standard. 

First of all, put a space after , but more importantly, either use a heredoc for large multiline text or read the text from a file . 

You don't actually need a loop because Ruby has built in functions that simplifies all this. To grab random UNIQUE numbers in range , do: 

You've got a solid start here, but consider a real world problem (and the common follow up question to Fizz Buzz): The customer now wants your program to also print "Bang" when the number is a multiple of 7. So, with your current process, you'd need a couple more statements (for 7, 21 and 35). Not too hard to do, and you can just copy the code you already have for the most part, so this is doable. But then a few years go by and the company gets bigger. Now, when the number is a multiple of 11, you need to print "Boom". So are you going to write out a chain of 24 statements? What if you mess up a number somewhere? Or put the conditions in the wrong order, like having the check for 15 before the check for 165? You have an unmanageable mess. The correct solution is to use a list, pairing each number requirement to its word, and build the "FizzBuzzBangBoom" string as you iterate over the list. The method to add a "word" to the string operates the same no matter what the number input is - it's just a modulo function - so you can cut down on a lot of repetition. As a challenge, try to repeat your project with less repetition (the DRY principle) and SPECIFICALLY do not have the numbers 3, 5, 7 or 11, or any multiples of them, appear in your code more than once. 

Your regex looks wrong, see my link below. If your functional requirement is that usernames match a certain regex, then your tests should reflect that. It is wrong to test a bunch of edge cases that a generic regex catches. See this. All you need in your test is to do: 

Finally, in your and other things should arguably be instance variables () but I'm not entirely familiar with how sets things up so this might be more trouble than it's worth. 

You should use to output to the console, not , unless you actually want the output to stay on the same line (useful for, say, a progress bar or a question waiting for an answer). Using automatically appends a new line if there isn't one, so each line of output gets its own line in the console and you can read it more easily.