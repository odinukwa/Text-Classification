That's a lot of code It looks like it works but since it's apache specific what's wrong with using virtual? It's an apache-specific php function for serving files. I.e. 

The function invoke handles everything - there are 10 "actions" in it. Each of these if statements would ordinarily be a separate action (function) in a controller. include view That's not how views are rendered in CakePHP. Like that there are: 

No I'm not sure why this question is tagged CakePHP but since it is: This is not CakePHP code =). Some specific points to elaborate: session_start, $_SESSION This should not be in any CakePHP application code - The session is started on demand whenever it is first accessed via the Session component, session helper or the CakeSession class. include_once Files shouldn't need to be included explicitly at all in CakePHP, there's a standard way to load everything. For classes that is using App::uses, for template files it's Controller::render and View::element. Model By defining a class called Model, even if it were loaded correctly - CakePHP's base model class cannot be used. new Model This is not the right way to construct a model in CakePHP - the normal way is: 

While these examples are pretty far out there, consider if your Queue class were complex enough that I might want to add an extension method to it and need access to internal variables in the method to do some algorithm in a way much better than possible with the available public interface. 

You could do something more fancy using a regex replace or whatever, but I don't think it should be necessary. 

You don't need to check for existence or remove an item from storage to change it. The logging code is unnecessary. Using and is considerable overkill for converting between a string and a number. 

As this same if statement is used twice (with different values) I would prefer to pull it out into a function: 

Most obvious there is that the statement is exactly not what is actually happening and thus is wrong. Since I would prefer to be explicit I would probably do this: 

However, you aren't just toggling a single element's visibility here; the link text is changing at the same time. Atop that, the overall logic is that the system can only have at most one dialog open at a time. Cause I think the structure of this code fails to make that logic immediately obvious. Solution Let's abstract the implementation away a little into a method (to be written farther down) and rewrite the click event as if it already exists: 

If you want to initialise your data from any range use templates and constrain its type to guard for errors at compile time. Prefer regular functions for computations This means, that an implemented function is also a function in the mathematical sense. Same input data produces same output data. I found that this almost always leads to evaluations which do not change an inner state. Thus it smells to me that 

Makes a copy of while returning . Imagine val_ is a very big . This could be very expensive in code which calls multiple times. If you want read-only access, prefer to use 

2.) Don't use abstract base classes for function objects 2.1) Use instead of abstract base class 2.2) Use instead of abstract base class [ Note: Or just take these as template parameters only. ] The rationale is that the way you do it is intrusive and a client has to define adapter classes to use your library. Since your abstract base classes only require virtual you are better of with which is just such a wrapper around any function-like type. Defining abstract base classes here might also introduce a lot of subtle misuses and errors. For example: you do not define a virtual destructor! Since you do not store your function objects polymorphically it seems to be okay in this case (and might leak otherwise), but on the other hand you take pointers to such objects without -checks... and your classes invite users to misuse them by letting the pointers dangle. I have no experience with fluent interfaces but I do not like this particular example. You gain pretty much nothing but a code bloat -- one selector-class for each parameter plus it seems to be easy to misuse. Maybe one can generate selector classes and avoid code repetition with Herb Sutter's announced metaclasses. IDK. 3.) Don't use an abstract base class to require a ForwardIterator Just rely on substitution errors or constrain your Node type with Concepts / + . This adds again unnecessary coupling for the client to your library. 4.) Issues in A*- 4.1) is not a good name. I suggest something that indicate what you search for (an element? a path!) Suggestions: 

and changed accordingly (and remove ). Instead of and , out the smallest element I have no idea how big of an affect this will have (if any), but I think it would be faster to just splice out the smallest element rather than sort every time (again depends on size of your map). In the meantime there is no benefit to having at the end of the loop rather than right after the sort and caching the lookup into a local variable: 

(but you probably already have a method like this in your code where these things would belong) A better question: Why do you need this property anyway? It looks like it is just holding private data for the route. Why not make it private to the route then? 

This resulting code looks to me like it has too many indents. I also notice that it fails on passing in an object that is an array or contains an array of arrays. Reordering some code we can check both of those cases at the root level: 

Assuming is unique (if not then so you get the exception for more than one element). In both cases you should probably catch the internal exceptions and throw your own in its place to hide the implementation details (or specify in the method documentation that it will throw these internal exceptions, but I would think of that as bad practice). 

Either invert the test (!) or put some logic in there - e.g. redirecting the user to their profile page. 

When the time comes to write unit tests, the code shouldn't need to be modified. Changes to make code testable are usually trivial - and just mean planning ahead and having appropriate methods to set and get data. Be secure As indicated by other answers an unsalted sha1 password is weak. Passwords should be stored such that even if someone gets access to the database, they can't determine the original password. It's not hard to store passwords securely, here's some pseudo code: 

DRY - Write less handle more You can make your function half the size by designing it to work with scalar vars only, and handling arrays with a loop: 

I use gearman as an example - but you can implement it any way you wish. Just ensure your solution account for jobs that fail intermittently (job fails once, reschedule for later) and for jobs that fail consistently (something wrong, job fails 3 times - flag for action). 

That means in all cases the variable is tested 3 times if it's null, and twice if it's an array. A couple of side points: The first use of is really testing if the variable is a string by inferrance - it would therefore be more appropriate to use . Also by using type-insensitive checks an empty array or empty string are caught by the first if block (perhaps that's deliberate but it isn't obvious). Instead the code can be written as: 

Prefer value type semantic Try to make classes default constructible and equality comparable whenever this makes sense. Currently your class doesn't fulfil neither. The following code will not compile 

Since stylistic comments are also welcome I will start very simple. I prefer to reserve upper-case names for macros. Instead of 

You will see that implementing is very simple and beautiful in comparison to a direct . Edit: What I call here "upper_bound"-like search is implemented in the STL as not to confuse with . 

A note on performance As for the performance. I can not imagine that this is a particular fast implementation. You use a lot (which means a lot of scattered allocation) your memory access patterns are not very cache friendly and so on. But this is a VERY hard problem to solve generally for all graphs since it is so dependent on its details. solves this with a lot of trait classes and a Visitor concept and is IMO quite hard to use too... and these guys have a lot more experience than both of us. A cheap trick one can do to boost its performance is to supply an allocator-overload to your function. This way you could preallocate a memory arena or even use the stack. 

Code separation What you have there is everything mixed together - just by moving the php logic to the top of the file, makes it easier to read. With some minor reformatting it becomes easier to read/maintain: 

What is going to happen if $label is or any other innocent string that will cause malformed html as a result? Why is the class not taking care of that automatically? Note that there will be use cases where you want to put html in some tags - such as using an image for a label, or where tags are nested - attributes should always be escaped though. And that's just talking about how innocent users could break your code, not those with malicious intent who submit as their name. Big Point: Write real tests If you write a real test (by which I mean using phpunit) you can quickly test normal and edge case scenarios (What if the property looks like this?), which will highlight any difficulties in using the code. It'll also permit you the confidence - if you choose to rewrite any of the code in the future - of knowing that it still works in the same way as it did originally. Mid Point: Inconsistent constructors You have all these different constructors: 

not caching the inner jQuery object checking the state of each dialog by checking its implementation when we already have a structure modeling it 

So the question is how can that function be written? If you can alter the html, you could add a attribute (or something like that) to the div tags with the ids of the big div tags: 

Use instead of ; it is shorter and faster in all cases I've ever bothered to test. Don't use inline, javascript doesn't have block scope (only function scope) so it is better to declare all necessary variables at the start of your functions. Cache to make code more readable. Use toString instead of a regex test for checking for the bool type simplify loop and store the upper bound in a variable instead of computing it every time Use a check on the loop. 

the partition loop was moved into a function to not repeat the same code 3 times the differences between the parallel and serial sorts were superficial so they were joined into one method getting rid of the second array and simply copying into the first one twice enabled memory savings that allowed me to enable the last length trial