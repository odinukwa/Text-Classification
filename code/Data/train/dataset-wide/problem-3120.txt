Again, following protocol specs, I'd make a . The unofficial spec use as the length, I'm not sure what you're computing here. Minor note: I always write to future-proof (unlikely to matter here but still). 

Deduction can't work here. C++03-style code uses at the return type, or when there is no return type (e.g. constructors) as a default argument. Maybe you tried to 'collapse' the default argument with the actual, interesting parameter, but you can't do that. C++0x-style code can put as a defaulted template parameters but that's moot since you really want (credit to CatPlusPlus): 

I don't see the need to copy the final message into a buffer. Why not use two calls to ? You could replace the members (which you already dislike) with a member like the fixed-length messages. 

Lately I've been making my traits more convenient to use by adding forwarding specializations: , and another one for . They help with perfect forwarding because if you have e.g. then might be for some . Since you're not doing that in your code I don't think you need it -- just a head's up. 

Instrument Class Why not make this class an enum? By declaring the display Strings and key values as static variables in your class, it's already constant. For example: 

Back to the class, and the GUI class. Do away with . I view your UI as having rows. Each row is for an instrument, and each row has some checkboxes which represent beats. To model this, we can make : 

Midi class. If Midi is no longer to be sharing the MusicInfo object (since it doesn't exist anymore!), it needs to know when to update the track, and what to update it to. One option (there are probably better ways) is to expose a method such as: 

BeatBoxConstants Constant Class (of Interface) are a bad anti-pattern. Instead, we can easily just pass in the number of beats to the constructors! 

Added bonus: You can select new check boxes and the player will now start playing the new track without having to pause and restart the player InstrumentRow.java 

You obviously want to benefit from both strands of data reduction. As for the reduction in number of rows, there's no way to make Entity Framework join with local data other than lists of primitive values. Even then, joining is rather inefficient because EF has to convert the local list into a temporary SQL table (sort of), which requires a considerable amount of code. It's more efficient to use , which translates into an statement: 

I don't understand why repositories insert, update and delete themselves. For example in the method, you have: 

It can't be any shorter. It's basically a thin wrapper around a . But I do have a remark about the design. IMO you shouldn't return from and , but . There reason is that by returning you can compose queries comprising multiple repositories that will result in one expression tree and, hence, one SQL query. (I'm assuming that all repositories in a unit of work will receive the same instance.) With your current code, if you'd join two repository results, like this ... 

I prefer to accomplish this by creating the view, and injecting it into the controller in the constructor as follows: 

No need to say the method name again - the method name is automatically part of the Javadoc. What are the parameter constraints? (To be fair, you don't enforce any constraints in your code, so it makes sense to not mention any in your Javadoc) That said, you should at least have some minimal constraints on your public methods and constructors (eg. The GUI constructor takes a object - do you want to allow a consumer to pass in ?) When are your exceptions thrown? I see lots of classes which throw a , but as a consumer of your code, I would want to know what causes that exception to be thrown. Private methods. It's not wrong to add Javadoc on private methods, and some people will argue that every private method should have Javadoc. I don't necessarily agree (Feel free to come to your own conclusion on this one), and I am of the opinion that if a private method is so long that it needs documentation on what it does, you should probably clean that code. 

If only the specializations are meant to be used (I couldn't tell from looking at your code), I usually 'forbid' the base template to catch mistakes early. Errors about how has no member are confusing and not necessarily near the code that instantiated the template. The simplest way to do it is to leave the template undefined but lately I've been using a trick: , where is always but won't trigger the assert until instantiation (whereas always triggers and won't let you compile, ever.) 

Do you have a specific reason (e.g. protocol requirements?) that this be signed? Bit-level stuff usually involves unsigned types. The protocol specs also explicity mention the size of the message type field: a single byte. So I recommend here. 

Final remarks on the general design: I think you're somewhat abusing specializations here: there's is no need (IMO) for a catch-all template since the three kinds of messages are not similar in use. This really shows I think with the constructors that aren't compatible: you can't write a generic . Personally I'd have used overloaded function templates to return those three types. Also I personally typically use for binary stuff rather than but I don't think that really matters (plus you may have a use for some -specific stuff that is not in the code you presented). 

As I explain here, the EF model is primarily a data layer. Its classes may be suited for other roles, but their primary responsibility should always be: smooth data access. Your question is about combining three possible roles an EF model class could play: 

is a materialized list (for example, ). After running , a new enumeration of will produce the same, modified, objects. is an enumerable that produces new objects on each execution. After running , a new enumeration of will produce new objects. The changed objects are out of scope and will soon be garbage collected. 

Where's Commit? No, I didn't forget the method. The fact is, repositories shouldn't commit. Maybe this is surprising, but if you think about transaction management it becomes obvious. There may be business transactions in which several repositories are involved. When each repo has the potential to save all changes, it may be very hard to figure out which one is able to save at the right moment. That's the reason why generic repos always come with a Unit-of-Work pattern. This is all explained well enough in the link above. You can see this problem lurking in your code. At the end you have 

Private initializers. I try to not use them if possible, but I do understand that they have a place. When code is short and simple (like this project), then I find it much easier to read if all of the UI components are setup directly in the constructor. I've found that it's easier to understand what is all happening and build a proper UI hierarchy when they're setup sequentially. A little documentation of what is being setup can go a long way as well. Plus, any variables that need to be accessed elsewhere in the class can still be final since they're initialized in the constructor. That said, in a very complex and large class it can be more readable to break apart the constructor work into some private methods. But even then I might argue that your constructor is doing too much, or that your class is responsible for too many things. 

Having these filters added to the model builder in , you'll see that whenever you query any of these entities, the filter will be part of the SQL query. Also when using s. If you want deleted items as well, just disable the filters in a context instance: 

All other pieces of code that wrap this part can be deemed redundant. As the ultimate (over) simplification you could even write this code directly in an MVC controller's action method. No added layers involved and the job is done. Useful layers? Anything added on top of this base line should be carefully considered. Additions should be useful, not restrictive. Your proposed architecture is restrictive because it is "vertical". You seem to have a column of abstractions for each entity: , (as ), with subclasses like . Then there is a class, maybe part of a similar column. This architecture has the same drawbacks as Data Access Object: it will lead to multiple isolated queries and repetitive code. Alternatives? This columns-per-entity setup defeats the purpose of an OR mapper like Entity Framework, which is to work with object graphs that map to a relational data model. When you need orders and their related customers you can get them in one LINQ query. Likewise, when you want to save orders and customers, you can add them to the context and do one call to save everything in one transaction. This has made me move to API-oriented architectures. I usually create services that live for the duration of one web request. Each service has a number of methods that execute some business case, like creating orders. For this, the service has one context instance that can pretty freely be used inside the service methods. This works best in combination with dependency injection (or Inversion of Control, IoC), but that's not a prerequisite. This is, very briefly, what it could look like: 

Who cares if it's not selected already? Doesn't hurt anything to set it to false again, plus now it's even more clear that each method is an unnecessary wrapper. Midi Class 

Now, you might be wondering how that helps at all. For one, it abstracts out (to a reasonable extent) all of the work needed to create a row, add the label, handle changes to a checkbox, etc. This also helps with extensibility. Say you wanted to add a button to your app that adds a new instrument (or even one to delete). Previously you would've had to do a bunch of work to update and maintain that 2D array of objects. Now, all you would need to do is add a method to your UI to addInstrument(), which would create a new InstrumentRow instance and you're all set! I won't go into much detail on this, but one thing that is also a good practice is to separate your view into an interface and an implementation. The implementation would be specific to the UI framework that you have chosen. For example: 

You may succeed in implementing the interface methods in a way that they display the same behavior as . This is hard enough. is far from trivial. affects an entire object graph. In fact, all methods affecting an entity's tracking state have nitty-gritty details when it comes to the adhered object graph. If you don't respect these details, saving will behave differently. If forces you to use LINQ-to-NHibernate. This in itself inevitably introduces differences. Both types of LINQ have their own set of supported methods. Both have their own bugs, or run-time issues (like generated queries that perform poorly). NHibernate has other powerful query APIs that you can't benefit from, at least not fully. NHibernate's workflow resembles that of EF. But there are important differences. For example NHibernate's auto flush (auto commit) feature. The standard implementation if , , has other important methods that are not part of the interface. For example, . An NHibernate implementation should also implement these to be even remotely interchangeable (which it never will be).