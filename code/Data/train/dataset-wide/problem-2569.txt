Wich is nicer as you don't have to worry about the extra space between the two values. Encoding You don't need to convert to UTF-8 before writing the file back. What's wrong with ? 

is indeed an interesting optimization (x2 improvement). It would be more readable to make m go from to . You can avoid computing . is enough to compare the distances. When printing the distance, you can use . First set to , this will avoid you the case and the resulting duplication: you'll always find a distance shorter than infinity. 

I/O bottleneck Your first bottleneck is not the algorithm. As you see from your output (), your program only spent 10% of his time in the CPU. This means that even if your program took 0ms, you would only gain 10%! You need to understand what takes that much time. Is it because the disk was busy? Or is it full? How long does it take when you run the program a second time? Is it faster? Is it still only spending 10% of its time in the CPU? Measure the time taken in the three main parts (read file, color map, display map) and see where it is slow (using which takes into account I/O latencies that the Ruby profiler does not). Other bottlenecks Once the I/O bottleneck is solved, you can turn to other optimizations. They are called micro-optimizations since the algorithm doesn't change: you're trying to use a few tricks to make it faster. Since the your code was very fast with the provided map, I created a bigger one with a few copy/pastes and ran the standard Ruby profiler to see where it was spending time. 

till are lousy names. What's a ? What's a ? How do they differ except for the order in which they're used? 

Did you notice the similarities between the tasks? Have you considered migrating those parts to their own function? Your entry is not particularly useful. It's not saying why or where it happened. How about: 

However, it's often preferred to include explicitly. If you use threads, include . Even if you don't have to because it's already included by another include or because your compiler sorted it out for you. If you refactor your code and removing one include suddenly breaks functions you didn't expect to break, you'll know you didn't include explicit enough. It's also a good overview for the next guy reading your code about what features are used. Including the same include twice won't matter for your program since the compiler will notice the include guards and only include every include once. The following function could use a better name: 

Naming Illegal names The following is quite important. Don't EVER name a variable or function after a built-in. It confuses everyone including (possibly, although you usually get away with it) the interpreter. 

Congratulations, you just came up with a prime sieve! And indeed, it's faster than always considering all the multiples of 2 of 3. But why do you stop at multiples of 2 and 3? What about 5? And 7? But why stop somewhere? Let's be more ambitious. What about skipping all the multiples of all the primes encountered so far? This is called the sieve of Eratosthenes. It uses more memory (if you double the maximum number you're interested in, you need twice the memory), but it will be faster and will tell you if any number below your maximum number is prime. If you want more improvements, note that other prime sieves exist: both the sieve of Sundaram and the sieve of Atkin improve over the sieve of Eratosthenes. And of course, if you're interested in raw speed, use numpy or even a language like C. 

Quite a lot of things change, actually! At this point, we don't know yet if avoiding duplication is worth it: it often leads to more complicated code and it can be longer, too. But let's try it. I took your code, created a function, and tried to see what could fit in it. When writing this, I realized that it was simpler to put everything in the function, so I tried it: 

was provided, as was the empty function (and no, it is not allowed to pass as an argument to the function). The required code is as straight-forward as it gets, but I feel there's a more proper way to do the string formatting. 

Of those 5, arguably the first and latter are acceptable. The 3rd and 4th are the most magical of the lot. You explained the first in a comment, but I'd personally move it to a variable. 

Disclaimer: No actual kittens were harmed while writing this program. The number of iterations is held in the variable . I know is a more fitting name, but that's already claimed as a type. The above is compiled using the latest lci using the 1.3 specification (thanks to Pimgd for the link). Since the 1.3 specification doesn't contain every feature of the language, see the 1.2 specification as well. I don't think LOLCODE has templates or the likes, so getting all the output on screen is a bit tedious. Output: 

You're only focusing on one-letter edits here, but what about deletions, insertions and even transpositions (dog -> dgo)? The Damerau-Levenshtein distance handles them. And finally, is poorly named: I already know that the type change, I want to know about semantics! Something like would be better. 

Don't store account and password in your source file. You could move them to a configuration file (that would not be tracked if you used git or svn) or retrieve them from the environment (but then they would show up in your shell logs). Don't Repeat Yourself 

The first thing to do is to profile your code. Hashcash is really designed to make you perform 2^20 hashes: if you do more work than those hashes, something's wrong! Profiling 

This is quite confusing, why don't you do this when adding chances? (If I understood correctly, you're removing already done moves from chances.) 

Notice that you never use because you always go from the Input to the Synapse, not the other way around. So this is nice object-oriented code, but I think this is overly complex: most of the code ties the objects together: you could get something much shorter: 

That's and having non-descriptive names. is input from the user. isn't a great name, but better than . Perhaps even or . could be named , , or something similar. 

Stop. Regardless of what you're doing here, you should not be doing so many things in one condition. This looks like you need to write a new function instead. Talking about functions, they'd greatly improve the readability and maintainability of your code. Now you got everything in one big . Your could use it's own function. The data changing, inserting and replacing could probably use a wrapper as well. If you give those functions meaningful names, the readability will increase big time! Imagine the following: 

Naming is important. Try to avoid variable names like , and . and are widely accepted as iterators, so those are fine. 

However, this would violate the maximum line length noted in PEP8. Whether or not this is a problem is up to you. 

Maintainable code has proper naming. Single letter variables are only acceptable for indexes in loops. contains a bunch of strings. Although I understand why it's called , it's a counter-intuitive name. is in a place where no actual generating takes place. The appropriate place would be a function which actually generates something, not right before a statement. 

Your module lacks a docstring. It could contain the explanation you gave us. Read more about Python code conventions in PEP 8 and docstring conventions PEP 257. 

But that probably wouldn't be very useful because you couldn't do anything about that exception. This is why you need to find a middle ground: 

To answer your second question, you don't need to explicitely check for null: it's simpler to compare and directly. If the latter is null, then the comparison will return false. If is null, you don't want to return a value but throw an exception anyway, and this is what happens with your current code because throws. It makes more sense to check for success and return if something went wrong. If you have an type instead of a boolean, you have to return more explicit codes! Otherwise just return the condition directly. 

Besides, I'm not sure is a good choice for an attribute name. "Context node" already has a specific meaning in XSLT. 

Importing everything from a module is generally frowned upon because it hampers readability, can cause confusion ("where does come from?") and breaks useful tools like pyflakes. However it is acceptable with tkinter because it was designed to work like this. Just keep in mind that tkinter is not an example of a good Python API. 

That's 3 counts of per call. It's obvious you're translating something, but the rest is vague. Afar from that, are you familiar with the Python Enhancement Proposals? Some of them include style suggestions, most notably the PEP 8. You might want to take at least a good look at it. The most notable violation of your code against the PEP 8 is your lines are too long. Long lines are hard to read, hard to parse by humans. The readability of your code will improve if you split them up logically. The ugly way of breaking-up lines is with line continuations: 

It's easier to maintain and does not use needless repetition. Also, if you ever want to expand this function, the amount of extra characters in the latter function to achieve this are negligible while significant in the first. DRY is more important than code size in most situations. 

I've been thinking about a function which would accept data in JSON and maps it to such functions and which keeps execution order by the position in the JSON (list). However, such a function is way beyond my current skill level. 

Except you're violating PEP 8, which means other developers will have trouble understanding (and sticking to) your convention. Speaking about PEP8, and will help. I won't comment about lexical syntax anymore. 

San4ez has the best implementation, and Winston Ewert raised valid points. I'd still like to add a few comments. To answer your question, you should not use on strings, since this means trying to change your string, and strings are immutable in Python. simply creates a new string, also named w. Note than recursive functions are not Pythonic, since there is no tail call optimization, which means it would have been impossible for your recursive call to be optimized anyway. A simpler implementation: 

Thanks for the interesting question. Since you already have an answer focusing on the code itself, I'll focus more on the high-level bits. Why Consul? First, as you noted, containers bring many benefits, but they also bring new problems. Configuration and service discovery are two of them, and Consul solves them both. However, there are many other problems to solve. In the future, you're likely to need to: 

There's a bug: The checkbox works for all areas except where there's text. , and are not click-able. 

Extract the to it's own variable. This allows you to extend your program to, for example, ask for user input and use that value instead. Perhaps the user prefers or . 

That's responsible for 102.2 seconds out of the 108.9 it takes. If you want to optimize, do it here. The rest is peanuts. Do you notice anything? You're wasting half a minute on handshakes. That's almost 30 seconds you could be doing something useful instead. Unless you find a trick to carry all files over one handshake, there's not much you can do about it. It also takes almost 60 seconds simply to (AKA: download) the data. That's only slightly more than I'd expect with my internet connection, so there's not much you can do about that either. 

Of-course, that's keeping the current way of writing pretty much intact. If you prefer one-liners, this does exactly the same: 

Backstory I collect books. A lot of books. Whitepapers, (programming) cookbooks, transcripts, important letters, overviews, you name it. Usually in PDF, otherwise my house would be too small. To keep track of those books, I use an arcane collection system based on notes referring to notes. This obviously has some scalability problems, so for the past year I've been trying to build a proper, relational database for it. It still isn't finished... However, it's a project in parts and the first part has been ready many moons ago. It also hasn't changed much over the time, so I guess it's ready for review. The problem To have a database of books, you want at least 3 things: 

Also note that you can evaluate XPath expressions using the standard , thus not needing rolling your own. If you need something else, maybe reuse the source code of to suit your needs? 

either you simply set to True, which can only have an effect when the thread goes through your statements, so it won't interrupt the processing: you don't want that. either you also , but this is can interrupt both the processing and the upload... and you don't want that either. 

Your algorithm is optimal for numbers that fit into a int, but a lot of multiplication algorithms exist for large inputs. By the way, is bit-shifting authorized? It looks a lot like a multiplication. Code comments 

Never Trust User Input. Sure, you provided a drop-down, but nothing prevents anyone from sending something else. can be anything: you should check that it looks like a city. 

We only took 0.8 seconds (down from 12.7). still takes time, but only one third of the time. I don't know what to do about it, so I'll leave it as it is, but you got your 10x speedup with two simple changes.