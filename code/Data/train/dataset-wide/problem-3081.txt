Personally, I'd go with the second option. This "aligns" your objects more, so one object isn't doing the work or holding the information of another. And, it makes more sense in real life: at a real race, you could place a single bet that applied to multiple teams; you place multiple bets, one for each team. 

This is safer because this ensures that the function will only be called again after the first one has been completed. 

This seems a little unnecessary; why can't you just put into to begin with, like you did when you put the bit pattern into ? A much simpler way of writing this would be: 

This makes absolutely zero sense. First, you use the canvas to get the . Then, you use the to get the again by accessing its properties. Why not just use the that you literally just defined? 

And, with too: try: conn, addr = server.accept() except socket.error as error: print("Recieved error #%d: %s\n" % (error[0], error[1])) sys.exit(-1) When there is an error with a socket call, a tuple is returned containing the error code (returned from the socket syscall) and an error message to go along with it. I added a to the code that will close the program with exit code -1, which usually means to external that there was an error while running the program. To use this, you will have to . 

Use a conditional for printing values that don't exist yet At the very top of your code, you are setting these two variables to default values: 

This can be refactored into an array and a loop. The array would store what is currently these five similarly named variables, and a loop would be to set the array values. Now, I'm not good with PHP, but I think that code would look like this: 

This will reduce the amount of calls that are made each time this event is set off, thus speeding up your code. 

This looks like the kind of code that would be in a function to print out multiple strings in array. However, since you only have one message that is in an array, this seems kind of overkill, especially since there are only three lines. It would be a lot easier just to print out the message as it is: 

Initialize attributes in HTML Here, you are initializing your submit button to be disabled in your JavaScript code: 

However, you should be catching the type of error that would come out of that line. I'm not sure which error will come out, but I think it is either a or an . Either way, you'd change your to something like this: 

This makes no actual indication to the JavaScript environment that there was any error; it only notifies the user. However, you want to have this function throw errors so you can more easily debug and unit test it. However, you can just have it start throwing exceptions; there's nothing to catch them. So, instead, you'll have to have some other JavaScript code call this function when the event is fired. Here's what that'd look like: 

I didn't touch the keyboard at all; it just flew through the file. I don't think this is intended. However, this time, I think I know why. It's this line: 

Personally, I think your naming is just fine. However, the only thing I'd change is . That name is very general. Luckily, since we are talking about races, we can use information about races to name the variables. As you probably know, in a race, when two or more teams end with the same exact score, it is called a tie. Therefore, you should rename that variable to . And, now that I think about it, your function could use some renaming too. doesn't really tell you what the function is doing; what is a "good winner"? I would name it to . That name tells you if the bet (not the winner) was on the winning team. 

With this class, you can now keep the data separate from your main function. In fact, you could even move that function to be a method of this new class: 

A large chunk of these two functions is exactly the same thing: checking to see if a square is empty or not. I recommend creating a function call which will take one argument that is an element of , and will return if the space is empty and if not. Here is what I came up with: 

See something similar in the value that these classes are being assigned? If not, they are start with this: 

First off, I'd like to say that your code is very neat and well-written for the most part. Objects/Classes I find that, in your classes, you return a unnamed object with all the desired fields and methods. It would make more sense if, instead of returning an object, to set all the fields and methods in the class itself, and then return . Advantages to this are: 

Why is it like this and not how you have indicated it? Here is what your code is doing, minus the conditionals: 

(if you follow the above tip, these variables will probably be in an array instead). Now, you are doing much less constant field access, overall speeding up your code. 

See it? All I did was add s around the method call. This sticks the output in an array and returns the array. This will greatly help your library as I will show later. 

Looking at your function, it could possibly return if it can't find a suitable XHR object to work with: 

Quotes This isn't really important, but I just thought I'd point it out. You are consistent in your code with your quotes. For some strings, you use single quotes and for others, you use double quotes. It is best to stick to one. 

Converting to Now, I don't know exactly how this API that you are using works, so this next part may not work. You could try to speed up your code even more/make it more cleaner than it is right now by storing the player's permission level in the player object itself. Then, you could easily use a to re-write your code: 

This way, to add more routes, all you need to do is add another sub component; this is more readable. Also, it allows you to provide default routes to redirect to when no paths are matched with : 

It seems that you are trying to do some comparison here (considering this is in a -loop). However, you are using the assignment operator so this will always evaluate to ) 

This will return if the expression evaluates to , and if it evaluates to . No conditional needed. Or, if you wish to further simplify this function, just return the length of . Python treats 0 as so if the length is 0, it will act as in a conditional. At that point, it may not even be worth it as a function. 

Indentation I'm not quite sure if this is correct, but from what I know, I believe it is. Indentation in JavaScript does not matter as, before your code is run, it is completely minimized - meaning it removes all comments and unnecessary spaces. That being said, trying to crush your JavaScript into three lines does not make it any faster. Calling In your first example, you call the same function three times with the same arguments each time. This is extremely inefficient. It would be optimal to call it once and save it in a variable. Therefore, these lines: 

ing with 0 will make a bit 0, but ing with 1 will return the bit being ed. And, to enhance understanding, I would create a macro for finding out if a number is even or odd: 

The repeat loops You expressed a concern for these in your post. Yes, you could move these to a function, but the function would require copious areguments. Here is what I tried: 

Why is there an statement? You have nothing in it, so there is no point in putting this here at all. 

You have two entirely separate conditional statements just to add a single character? That's a waste, and it makes your code look ugly. Honestly, I don't think you'll even need to worry about that "s". 

I removed the part from the key names because, now that they are in an object, you need not to worry about conflicting with other variable names. There is practically no difference. 

As far as I can tell isn't going to be changing much at all, right? If this is the case, then you should make them final. This will speed up your code: 

This will help us later because, rather than hard coding these into the code like you did, while we are looping we can just grab these values from the array. Now, let's create the loop. 

This is created every time your function is called. Assuming more drawing will take place in this code, why not put both the canvas and the context in a global scope? There is no point in finding the context, putting it in a variable, and then destroying it at the end of the function every time it is called.