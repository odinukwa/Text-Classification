If something is called "RiemannSum", then it should return a sum. If you want summation to be a separate method, a better term would be "partition"; you could do RiemannPartition.sum(), for instance. Several other variable names are bit unintuitive to me (e.g. rectangles, index). You can eliminate several lines by doing: 

So .. you're repeatedly subtracting a number from another number, and seeing how many times you can do that without going negative? There's a word for that: division. EDIT: Since you want the actual code 

Which method to use depends on the size of the inputs. If you know that each word is at most five letters long, then you have N*M candidates for beginning letters, four more letters to find, and at most eight choices at each letter, so in this case that's an upper bound 9*8^4 = 36864, which is a large number but doable. For a larger board, and longer words, this can easily get unwieldy, though. If the inputs given are representative, then with only four words in the dictionary, the fastest method is to just check each word. So, for instance, for the word "geeks", you would first get a list of places where the letter "g" appears in the boggle, and for each location you would get a list of adjacent "e"'s, and so on. Note that you will have to keep track of what letters you've used in a word; if one of the words in the dictionary were "gig", your program shouldn't use the same "g" twice. As for your code, it doesn't seem to check multiplicities or adjacency, so the following is somewhat moot, but most of your code can be replaced by a single line: 

In short: your method should be two lines long, your method should be three lines long, you shouldn't have more than 2 global variables, and all errors should be caught on . 

In , you're needlessly allocating strings by modifying the variable. It would be a fairer benchmark to write it in the following way: 

Naming conventions aside (short names in camelCase are typically used in Go), this is the right way of doing what you want. The authors of Go have a different view of what is more readable & maintainable than the authors of Python :-) 

If you can't guess, try it; it's a good way to learn =) Anyway, you don't want that to happen. So you can do this several ways. Before I'm going into two idiomatic options, let's talk about your interface definitions: 

It doesn't seem that the library has a query builder or a specific type. So building a query in an idiomatic and readable way should be done as you would do for a normal string, and that is using the package. This will allow you to get rid of many code smells: 

Consider all of the above as extreme nitpicking, your code is way past the point of obvious flaws. The real value of the answer, if any, was to point you towards the SPL. If you did consider it and rejected it, would you care to share why? 

Why reinvent the wheel and not build upon the Traversable, ArrayAccess and Serializable SPL interfaces, or more realistically upon one of their concrete children? On similar requirements I would have possibly build my upon an ArrayObject. 

Everything seems to be working as expected (repo, with a simple demo). Since this is my first plugin, I'd be particularly interested in critiques of its structure. That said, as always in reviews, any aspect of the code is fair game for criticism. The plugin code: 

Obviously, what's more important right now is to minimize that glorious readability mess, hopefully the (small) performance gain might be just the incentive you needed. Cache your jQuery objects You are using in and twice in . That's three times jQuery traverses the DOM to find , what you need to do is: 

You client code is incompatible with the argument type of (I guess you meant to write instead of ?). But this is strange to have for an expiration time, most probably should just be renamed to and be an . The code could be more idiomatic. Your variables/functions have long names that aren't really useful. You could replace by , by , by , by , etc. Your function does many things (type conversions everywhere!) so that's confusing. You should probably refactor away a function like: 

→ . When a function returns and you want to return an error, you usually return the default value of along with the error. So in , you would return rather than . This helps you make sure that you're not going to use the return value when you return an error. Instead of printing the error with , you probably want to use and add an error message. Or not print anything at all and let the callers deal with the error (after all, it's why you return it), possibly returning instead of just . Close the file after usage. Add . Use a with option instead of trimming whitespace by hand. Your CSV file shouldn't have space after values (arguably, it shouldn't have spaces anywhere). On "does this look like Go", I'd say you have too much whitespace (empty lines in functions are seldom used), line returns (you never see them right after declarations () or assigments ()), and your variable names are Java-level verbose. In Go, you would use instead of , instead of , instead of , etc. 

One thing to think about is what is being run how many times. That depends somewhat on the use case. No matter what, you're performing the check every time you run this function. Instead, you can just separate the words by length up front; create a dictionary where keys are integers and the values are lists of words of that length. The next question is whether you envision this function being run once for a puzzle, or repeatedly every time a new letter is guessed. If the latter, @200_success 's answer will be recreating regexes for each letter that are only slightly different from the previous letter, when you only need to check the new letter. So suppose you have a function that returns a list that is empty if the puzzle is finished, otherwise the first entry is the last letter guessed, and the second entry is the positions that letter appeared (if the letter didn't appear, then the list is empty). 

This is not a Controller. The purpose of MVC is separation of concerns, more specifically the separation of domain logic from the user interface. Let's see where it fails: 

Don't know if this is just poor question formatting, or your style, but please indent properly, this isn't really good: 

checks whether the value is an integer and whether it's a string that only contains digits (thus a integer in string form), any of the two is acceptable for the following check, . I've also moved out of the check, I'm initializing it to zero and will override if and only if there's a need. But let's see what happens if the check is true: 

The code is equivalent, and will work (?) if you replace it in your script. Hope it clarifies things a bit. The overall quality of the code is bad, there are some hints of an amateur developer there, and you shouldn't really worry that you didn't grasp what the code does, since you are unfamiliar with the language. It's an incomplete and mostly poorly written piece of code, good luck with it ;) 

Yes, this is the way to do error handling in Go. By design, you can't let exceptions propagate to the callers "silently", you have to consider what makes sense at each step. I found that on large-scale projects, it makes it significantly easier to predict and test the error handling behavior of your code. It also forces you to put the error handling first, which (imho) results in more readable, less nested code. Truly global variables don't exist in Go — if a package exports a variable , other packages will have to call to access it. That being said, it pretty much never makes sense to do that. In the example you gave, cmd.go and project.go are in the same package, and all package-level variables are shared, so identifiers conflict. If you want this variable to be shared, it's more readable to put all functions that use it in the same file. When you want to mock some of your functions, it's the sign that there should probably be an associated interface. You can then "mock" an interface easily, by re-implementing your interface in your tests and making it do whatever you want. I find this more readable and idiomatic than using complex frameworks.