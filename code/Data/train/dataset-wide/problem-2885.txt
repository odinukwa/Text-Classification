Similarly move and inside . Remember encapsulation. Ball's location remains inside Ball. You have this in the method of 

The second one is more efficient. Simply because in the first one you are calculating the times but in the second you are calculating it times. Also it can be made more readable and efficient just by using this. It eliminates which you aren't using anywhere. Readability doesn't need explaining. 

Note that I am not familiar with Swing, only Java. You should remove unused variables. Like and in . They just confuse the reader about the logic. This can be improved. 

Background This is my first experience with functional programming and totally self-study. I just have 2-3 days' worth experience in Haskell. Now let's continue with actual code. 

You are opening the file(never closing it) and then using a loop. Try using the statement and list comprehension to open, close and get your list. This goes for both and . and are declared before the loop starts so you can declare and . For the reason see the part "Avoiding the dots..." in Python performance Tips. You can try to use instead of if you are on Python 2. Using generators might be better instead of creating the whole list. You'll have to time this. This isn't much but might be helpful. 

edit: When designing the algorithm, design also "memory". Where the data are stored, how much of them, why (purpose), when you want to create (temporary) copy, or when you want to use semantics, etc. I'm not suggesting to go after full "Data-Oriented Design" (unless you are designing some big-data processing application, where performance is main goal), but still some level of awareness how your data are flowing under the hood is good to have. Often by keeping data life cycle lean and without useless moving around, you will not only gain performance, but also simpler algorithm implementation and less code written = less bugs. 

Hmm... ok, one bit of source just to make it look a bit less like "wall of text" (although I'm afraid it's too late for that :D ). 

performance ideas (from comment): If you are already assuming ASCII alphabet-only word inputs, you may do direct , which will yield only values, and for vs it will produce the same values too (functioning as fake ). I also personally prefer non-else/non-nested variants (when they make sense), so I would do and the would go after that in the loop block. This is part of answer is level golfing advice, i.e. lowering readability and robustness of source for some hypothetical performance gain, not suitable for real world production code ;). 

It is much more readable. Ditto for . Also why are you waiting till the API call is complete to throw exception in case there are more than two users? Just stop the whole thing when usersString has more than 2 user Ids when the class is created. And instead of this 

This code is not completely working. is missing. But still there is a lot of effort. In case you are not aware Code review is only for code that works. You didn't add what you were expecting so I guess you were expecting a fix. Sorry. I won't solve the problem but I will add some general things that can be improved in the code. Use for-each loop if you don't need the index Instead of 

I am going on with refactoring my code base while migrating from Python 2 to Python 3. I am using generators to make reusable components this time as I am more comfortable with them this time then last time. But there are times when I am stuck at their use. Like below example. These two are essentially same with one infinitely generating and other with a limit. Is there a way to make these as one function? Normally an extra optional parameter as limit will do the trick but with generators I am not sure how to use them. Is there some way to do that? 

This new set of types correctly describes what each node can contain, using the type system to enforce everything rather than just implying how the levels are arranged with empty lines. Now nodes from Lvl1 can contain children from Lvl1 or Lvl2, nodes from Lvl2 can contain children from Lvl2 or Lvl3 (Classes and Structures may also contain Constructors), and nodes at Lvl3 cannot contain any children. Now that I've used the type system to make sure I can't accidentally add a Namespace node inside a Class node, are there any other obvious changes I should be making here? I'll also admit I was originally using list references for each list of child nodes, because it made it easier to reason about in an imperative way; I've since revisited my code and have removed and started making use of map/fold/etc. 

I'm working on a parsing engine as part of a personal project, and I'd like to expose certain .NET APIs to the parsed environment. I put together a very simple tagged union that allowed me to nest types, and put together a few functions that built up a tree of namespaces. Before going further, I decided I needed to refine the types I was using, and came up with this: