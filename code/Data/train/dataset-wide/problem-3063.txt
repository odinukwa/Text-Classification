I believe that makes it a lot easier to read. Don't put inline where it is not needed. The keyword plays absolutely no role in code inlining. Don't use it for that. It only plays a role in the one definition rule so you need it if a function is defined in a header file that is included into multiple compilation units. 

Simplify The move operators are usually just implemented as swap operations. This delays destruction until the moved object is destroyed which is a potentiall optimization if it is not destroyed but re-used. 

It also shows more clearly you are using non idiomatic C++ (the -1). Ranges in C++ are expressed in terms . ie. is one past the end of the container. This is done everywhere in C++ code; breaking from this idiom is going to cause you a lot of confusion with other C++ developers. Compilers Job Don't do work the compiler can do for you: 

Alternative to Project Euler 22 solution. Project Euler 22 Slightly more brittle than the original. This code depends on the input stream being exactly as specified. But on the other side of the coin it's slightly easier to read because you don't have to wonder about and code that uses like (which few people understand how to use). 

Is top being -1 really overflow? Would not overflow be when you ran out of memory for list items. Especially since there is not interface that allows you to get the size of the stack. Also I don't expect a diagnostic message. If something fails to happen its an error (by that I mean exception). If you fail to push the code that called push needs to know that the operation failed otherwise it will keep on doing what it is doing. The best way to indicate to the calling code something went wrong is an exception. Design You push and pop to the back of the list. Why not push and pop from the front of the list then you will never need to traverse the list to find the item. Bug When you pop, you don't actually remove the item from the list (or delete it). So poping gives you the last value but does nto remove it thus it will continue to give you the last item. Efficiency Checking for underflow/overflow. Sure this is good practice. But what about code were I know it is not going to under/over-flow. Do I need to check then? In most C++ code effeciency is paramount and you usually provide unchecked versions for situations where the check is not needed. 

Const correctness. Const correctness is really hard to add in afterwords (believe me). So best to start with your classes with it already in place. So any method that does not mutate the state of the object should be marked 

You are in a constructor.The member has just been default constructed (because you did not do anything in the initializer list). So this call to is redundant. 

Is repeated in two places. Refactor it into its own function. You will also find that such a function already exists in boost 

Commonly referred to as the pattern. Simple tests can sometime be replaced by the trinary operator. BUT be careful if overused or used in bad places this technique can make the code work (so be careful of using this). But in this instance I think it makes the code easier to read: 

Non Standard Copy Semantics Interested in why you chose to implement the copy constructor in terms of the copy assignment operator and not the other way around. Noting that the standard way to implement this is the copy and swap idiom (other way around). I can see this is probably slightly more efficient. But is the decrease in readability worth it. Only you can answer that. 

Bugs You have several race conditions: There is no guarantee that a worker stays joinable between these two calls. 

In moneyTransferCTX: You are using pointers. As you never expect these to be NULL (and they can't be changed) you should be using references. The constructor is casting objects to things that are not necessarily valid. 

I don't like the interface as it stands because you can call the functions in any order (which makes no sense). The interface should be designed so you can not call the functions in the wrong order. Which points at a design that does not involve explicit functions calls but a more declarative approach. 

Design Getters and setters are horrible. The expose your code to the possibility tight coupling as they expose the internal representation. So remove them. You should be thinking in terms of what actions can be performed on the list and secondly (since this is a container) how do I expose the contained elements. So I agree with Anton Node should not even be exposed outside the list. Why does the user of the list need to know about Node(s)? Why does the user need to know about the head and tail of the list. That's an implementation detail. Exposing those will tightly couple your code to require to implement them even if a future version does not have the concept of head and tail internally. Now I can see getting the first and last element of a list (but they don't need to know that internally you have head and tail pointers) and also iterators (but iterators have a much simpler cleaner interface than node*). Actions that can be done on a list. 

Put the next to the type In C the usually goes next to the variable. But in C++ the and go next to the type. This is because type information is much more important than in C and this is information about the type. 

I suppose there can be. But I don't think you are at that level of sophistication yet (not saying that in a bad way). Would this not just be a method on the Library. 

Create an new stuff that can throw (int temps) Change the state of the current object (using no-throw actions). Destroy the old stuff. 

Exposing the iterator type here locks you into that type. I would define my own iterator type locally to the CardStack (see below). 

So though points at valid memory the content of that memory is in an indeterminate state. Thus it is UB to read from the memory (before it is initialized). Also with non POD data (i.e. if T is not a simple type the constructor has not been run so the data will be undefined). When you construct an object the whole object needs to be in a valid state so you need to make sure this memory is initialized with a default value. No prizes for writing compressed code: 

You have done the correct thing by putting a sentinel element into the list. This makes adding/removing and generally manipulating the list trivial because you don't need to handle NULL links in the list. But you have done it using a two phase create. 

Note: If I was doing the interview I would ask this to make sure you could do a breadth first traversal of the tree. Which involves using a loop rather than recursion. 

You can simplify this even more by using an extra helper function. Objects Why is this a free standing function? 

If we assume that the average size of a number is half this length (so 10 characters). Then the size of the file is: 

The best way to implement the assignment operator is the copy/swap idiom. This makes sure that if there is an issue during the copy you get correct rollback thus giving your object the strong exception guarantee. 

It always worries my bare statement inside an if. Especially with function calls that potentially look like macros. 

Broken road list? Why keep a separate list of broken roads. It would seem easier if you could just mark the roads themselves as broken. I am not convinced that is dyxtra's algorithm It should look like this: 

Building a list. An easy way to have a list is to have a fake node in the list (this is called a sentinel). The sentinel marks the beginning (or the beginning and end in a circular list). It does not contain data and you don't dynamically initialize it. The advantage is that you don't need to test for as there is always a member of the list so adding and removing (as long as you don't try and remove the sentinel) become much easier to write. 

Move semantics are a compliment to normal semantics. Things can not always be moved. So you should do this in addition to the normal copy version not instead of. 

I would expect getPlayers() to get the player information and do any error handling. Thus in the main loop this should just be a single call: 

Turn on your compiler warnings (and treat them as errors) then you can resolve shadowed names with better ones and avoid the trap of using . Avoid if then else to check state of a bool or pointer. 

Turn on your compiler warnings: (Fix this first) Even at the most basic warning level I get a whole bunch of warnings. Personally I compile at a much higher warning level then basic and then I get two pages of warning messages. They may be called warnings but really they are logical errors in your code. You really should fix them all (or at least address them to make sure the code works correctly). Personally I always tell the compiler to treat warnings as errors thus it will fail to compile unless I fix them. Major Comments on code: (Fix this second) Refactor the code so you do not have functions that are 500 lines long. Ideally (not always achievable) one screen is a good rule of thumb. Then you should be able to see the whole function in a glance. Second Major comment: (Fix this third) You tagged your question as C but your file is *.cpp (which implies C++) and you are using namespace. 

This implementation is not exception safe (and does not handle self assignment). When doing assignment you need to do in three stages: 

Usually a prefix or means member variable. These are obviously not members. Excessive use of the auto keyword Auto is very useful of makeing the compiler do work. And I agree that there are a lot of cases where it should be used. BUT I also believe that excessive use can make the code confusing and when it removes information from the person reading the code that is not good. In this case: 

Pre-Size Containers Note: can cause a resize in the vector. A resize is very inefficient as all the data needs to be copied during this. If you know the final size of the vector you should set this so that no resizing happens. 

It access members that should potentially be private. Best to make it a member. Also why are you passing by pointer. Best to pass by const reference. 2) You use pointers where you should use objects. 

I think you are testing here to make sure that you don't fall off the front of the string. But you are checking the content of the characters not the position of the pointers. A better test is 

The difference is that also forces a flush. This is basically never needed. The automatic flushing of the streams is nearly always better. The only thing this does is potentially make the code less efficient for flushing too much. Don't bother with in main 

Don't bother with const on the return type when returning by value. Be judicious on your use of returning Vector by const ref. A lot of the time you want to return as a ref to allow chaining. 

Don't use it unless you really have to. The IO streams library is much better. If you must use it keep it separate from the other headers and comment why you need it. Don't do this: 

Prefer Standard containers Arrays are limited. They don't work well with a lot of other constructs in the language as they quickly degrade into pointers just by looking at them funnily (them people start worrying about memory management). 

Also your variable names are bad. Pick names that make it easy to read the code and understand what you are doing. 

I can't test this as I only have MySQL available and you seem to be using an MS product (and my original query worked on MySQL). But based on the error message: 

When scanning headers. If you fail you deallocate the request but not the list of headers already created. 

Experimenting with vera++ to validate some C++ source files. $URL$ vera++ is expandable by providing your own rules in tcl. To interface with the vera++ parser the following interface is provided: $URL$ Using the above I have written a rule to look for object identifiers and validate that they have an initial lowercase letter. 

No that is completely fine. The general principle is that if you are not going to handle the error then you should not catch it. Logging is an exception to the rule; where you catch log and then re-throw. BUT: Most C++ io functions do not throw exception on error (you can make them do so, but it is not normal). Instead a an error causes the flags on the stream to be set to indicate one of the failure states. Now the stream object itself can be used in a boolean context to check the state of these flags (stream will convert to true if it is in a good usable state and false if any of the error flags are set). Code Review Avoid output parameters I hate return parameters. They are non logical and make the flow of the code hard to read. I prefer to return all the results (even if there is more than one). 

Another thing you should consider is a sentinel link. This is a link in the list that does not contain data but is always there. Note: The list is empty when it only contains the sentinel element. The advantage to using a sentinel node is that you don't have to worry about when traversing the list. This drastically reduces the amount of code you need to write. So from that long description two changes I would make.