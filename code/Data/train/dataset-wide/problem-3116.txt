Why is this a horrible idea? Because you just successfully eliminated the function the exceptions had originally: Error handling. The premise when using LINQ like notations, is that you have a valid set of data in a fixed formate at each step of execution. By intercepting the exception too early, and mangling it into the same format as a valid output, you are breaking with that premise. Instead of the valid input, you are now passing the error message down to subsequent operations. With no way to distinguish the error case from a valid result. 

So yes, the OOP version is still slower and consumes (slightly) more memory. This is expected though. Typing early and properly did have an measurable impact on both performance and memory consumption of the OOP version. The effective memory overhead for the OP wrapper shrunk to about 50% just by typing early. Using the data-structure efficiently and minimizing the number of accesses did yield the biggest gains though, and is effectively more than a full magnitude faster than the OOP approach. When comparing this to the 32bit version, for PHP, you may actually cut all memory requirements roughly in half. PHP wastes most of its memory on pointers, not on actual data. 

Let's start with with revising what a tree is. A tree is coherent, undirected graph with a single root node and no loops. Let's compare that with your sample data (and the implementation based on it): 

That information is key to solving this challenge. Saying that the target sum can't change, is identical to saying that if the sum wasn't found up to now, none of the elements except for the last 3 need to be considered ever again. Your current implementation runs the sum test again every time a different sum is queried, which needs to happen every time a set of fresh summands has been added. This results in an effective run time of \$O(n^2)\$ for single value additions. However, by checking each possible sum only exactly once, you can lower the run time cost down to \$O(n)\$. In the best case, you can even discard all further input for the same run, once the expected sum has been found. You don't need to hold the entire list of previously entered numbers in memory for that either. All you need to remember, is the sum of the last 3 inputs, as well as the inputs themselves so you can recompute / update the current sum accordingly. For remembering the last few inputs you can simply use a , it's specifically made for such scenarios. This allows you to drop the memory footprint from \$O(n)\$ to \$O(1)\$ as well. If you want to express it with OOP, you can now just encapsulate each run in a object of its own, and you are done. 

Why bother waking all worker threads when only a single slice of work was added? is more appropriate. 

No. Your regular expression only tests for the used character class, but does not evaluate the semantic structure at all. While it is - to my knowledge - not possible to inject arbitrary executable code into the context, due to not having access to parenthesis or , it's still easy enough to provoke an syntax error during evaluation. You also don't validate your stack. Not ensuring that it is empty at the end of your function is just a matter of lacking input validation. Not validating that it doesn't underflow during execution is slightly nastier, because this can result in returning , which then when casting to string results in , which then again during the casts to the identifier which can - other than the name suggests - be defined. 

What is 177? OK, I know from the context it's an extended ASCII code. But without looking it up in a table, I don't know which one. This makes a magic number. The problem with that is, you reused it multiple times, and every single time in numeral form. If I wanted to switch out the ASCII symbol used for the border, I would need to check all occurrences of this number. But even if I did - I could not tell whether it had the same semantic. Use constants instead of magic numbers: 

Aside from messing up the state tracking on invalid inputs, your input validation in general is sloppy. Currently, your calculator happily confirms that . Say you only checked whether the input can in any form be parsed as a numerical, but not whether the field didn't contain additional garbage with potentially ambiguous meaning. 

Did you just omit this when posting your code here, or did you actually write your scripts without it? 

If you know that you need multi row updates commonly, provide that by a dedicated function, only for that task: 

Your handling of invalid inputs is plain wrong. While you did right to disable the calculation as soon as an input becomes invalid, you totally messed up the logic to re-enable the calculations. Test it yourself, enter something invalid into both input fields, fix up only one, and the buttons become re-enabled despite the other field still containing garbage. The problem is wrong use of the . Whether the buttons are disabled or not, is actually a function of whether input a and input b are valid. Whether they are valid or not individually belongs into the state - however the computed result of that combination does not! If you had computed the state of the buttons from the state of the inputs in the method, this problem wouldn't have occurred. 

This isn't even valid reverse polish notation, with the 3rd term which includes both an operator and an operand. And yet your implementation did happily process this, including the resulting side effects. 

This is a dangerous design for the interface, as it requires strict type checks in the calling code to distinguish between the error case (non-zero integer) and the success case (true boolean). Stick to a single data type for the return value at all cost. This would have been quite easy in this case, as every error case yields a non-zero integer. So just returning to signal error free execution would have been acceptable. 

You extracted logic which should have been encapsulated inside your function into the main function. That should never happen. If can't handle values between 1 and 99 itself, it's not living up to its name. 

Despite having two instances which are in a trivial relation to each other, you couldn't just compare them, because you didn't implement . Instead you needed to copy the corresponding logic into every single site attempting to compare two instances. 

One more problem with your approach: It only "works" at all for type functions. What with more complex datatypes, e.g. collections and alike? For these, you can't trivially encode the error case in the return value. Simply because there isn't a solution with potentially different semantics, inevitably leading to undefined behavior later on. 

Fetching X and Y coordinates from different vectors is somewhat weird. You should try to group data which is accessed in the same context, rather than attempting to sort it by type. E.g. 

And because it was so nice, we do it again, but this time we prevent the user from terminating the application. 

Half of that stuff doesn't belong into the state or is redundant. E.g. all the "disabled" properties. They are only used in conjunction, and could have been derived all from a single boolean during the method. Neither does the belong into the state. It's a constant. 

This method should have been called , which makes it the constructor for the class and is called automatically every time a new is instantiated. Have a read on the RAII principle. 

That's one way to do it. The cleaner method would have been to handle this in a Coroutine and then use WaitForSeconds. Right now, your code runs every single frame, without actually doing anything useful. 

So much for fixing the inner select. But as a matter of fact, now we don't even need to do it as a subquery any more, but can just handle if as a with and on the outmost query. Whether this actually gains any performance needs to be tested. 

You are not providing any form of authentication either. Right now, Eva can perform a trivial man-in-the-middle attack. While Alice could in theory still verify Bobs identity by comparing the provided public key against a trusted database, Bob in return has no means to verify Alice's identity. A simple band-aid would be to sign the chosen communication key with Alice's public RSA key, so that Bob has the confirmation that the key was in fact chosen by Alice, and not Eva. For that, just apply a cryptographic hash function to the key, and encrypt the hash with Alice's private RSA key. Bob then uses Alice's known public RSA key to decrypt the signature and verifies that he can generate the same hash. Alternatively you can hash the encrypted shared secret instead of the plain text, if you don't wish to leak information on the plain text. Be wary that this is still potentially subject to replay attacks. In order to protect against that, Bob should start the communication with a plaintext nonce which Alice needs to include in the signature. This may be an arbitrary string, but something as simple as the current time stamp suffices. This is still only authentication though, and does not remove the need to agree on a new key via DH to provide forward security. You need to get rid of the temporary key as fast as possible. 

No real point in specifying the content type prior to actually outputting the image. As mentioned in the other answer, can error out in multiple ways. If error reporting is active, this will result in a mismatch between content type and the response body. Even if it isn't, you end up sending a wrong content type for an empty body. 

I would expect that your students will mostly just reverse both lists, traverse in lockstep and identify the last common node that way. Students have a tendency to trade algebra for brute force, if possible. Smarter students will just read the length of both lists, skip the length difference, and then walk in lockstep until they find the common element. Which then also would fit better within the space complexity requirements, and requires no manipulation of the lists. 

Except that is is a contiguous buffer of s. Just mind again the difference between and . Given the possibility of , it can't even be an iterator for in any form. See the is dereferenceable requirement. 

Your approach provides zero forward security. As soon as Bobs private key is compromised, all past communication with Bob is compromised as well. You should use a Diffie-Hellman like handshake protocol for agreeing on a common secret for the actual communication. 

It does mean that, and your implementation using the to provide sufficient allocated space appears to be valid. Almost at least, because your implementation of is not checking types. So if a type is accidentally passed which wasn't covered within , respectively requires more allocated space, it is going to corrupt the memory. 

Well, let's now assume that you had fixed the table layout of the valid/invalid pair sheet, and that you already had loaded all files into different tables of a single sheet, and that all columns you need are named. We also assumes that your data is already properly conditioned, that means trim() and alike have already been applied. Now your task is as simple as writing a single query to do your complete job: 

Why did you make these private? They should have been public with default values - just as all the others. 

There is no longer a need to expose the original publicly, as the only legit caller is now inside the same class: 

OOP is not only about how you encapsulate data and functions into objects - it's also about defining how objects interact with each other. Let's pick the object as an example. As you use it, it's just a container, but not exactly object oriented. This line actually characterizes it well: 

ezxml has a variadic function which allows you to traverse directly to a specific node, terminated by either as the index, or an empty string for the node name: 

The problem of replay attacks also applies to the actual messages themselves. As each message is only protected by the shared secret, you are unable to detect when Eve maliciously repeats a recorded message of the same session repeatedly. A practical solution to that, is to append a fresh nonce to each sent message, which is expected to be repeated in the next message. Now you can tell for sure if the order of messages in one direction has been altered. As for ensuring the coherence of a dialog, you might want to think about acknowledgment messages, which confirm receiving a content message. 

Disabling the inputs without any good reason is providing a bad user experience. The point about using the react framework is, that you can recompute all results (in this case the result field) from the state gathered. So why force the user to discard that state? Just continue updating the state as the user continues providing input. What you should have added, but didn't, is a visual feedback which operation is currently active. Trivial, if you had recorded the chosen operation in the state. 

That is a problem. Because that is not how to properly handle an error case. You literally can't distinguish at all whether this supposed error message was generated by this function, or if it was actually read from the registry. Whenever you encounter an Exception, there are only 3 valid approaches: 

If by design, only links to media holding images, why would you not write this as a single query instead? 

I'm going to stop here for now. There are still many undiscussed problems with that code base, but after resolving the already mentioned ones, the code base will already look entirely different.