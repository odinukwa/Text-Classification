You've defined some method so you could rearrange some things and add additional levels of indirection to run slower and more inefficient than if you had just written the standard way using the and blocks. What did you gain here? I'll tell you, nothing. Any half-decent C# programmer should know what the and blocks do. There should be no question about it. Seeing your block of code, it's not so clear... we'd have to figure out what you're doing here. What if someone saw your block of code and wanted to know what is going on? I look at that and see ... "With" what? What the heck is that supposed to mean? If anything, it is only more confusing to people who are familiar with VB.NET's keyword (which does something completely different). The name isn't very great. You should have given it a more descriptive name. might have been a better choice or something along those lines. Don't even get me started on the ToList/ForEach combo... You can never go right doing this instead of using a simple loop. Why would to take a perfectly good collection, copy that collection into another list, just so you can call some method to do stuff with the added overhead of calling another method to do something on each item? The method has it's place and that's if and only if you start out with a list in the beginning. The overhead of the delegate is more forgivable here since that's what it was designed for. I understand that this particular usage is just a "hack" just to make this loop work, but this should never be the answer. If you must, write an extension at least. See reason number two of Eric Lippert's "foreach" vs "ForEach". The same can be said here twofold, both for the method and your use of . What happens if you need to do more than one statement in each of the blocks: 

Otherwise if you're not able to change it, you should still create a separate logging method and disable to actual printing in the method there. That way your method is called but does nothing. 

Then you could map these board states to the appropriate game state. Just make sure you map out every valid combination if you plan on using a dictionary. 

Your method is removing a collection of entities that exist in some set. When I see , I'd say it removes a single item from something. Now if that collection actually existed in the set, then it would be perfect, but alas it's a collection of items to remove. One thing to consider, assuming you're making an extension method for the EF5 , it already has a method that removes a single item, I think an overload to remove more items doesn't sound like a bad idea to me. On the other hand, LINQ to XML defines a method on enumerables of . But that's an extension on the collection of entities, not the parent set. I'm a little on the fence on this one. , while better as it indicates we're removing many items, doesn't fit well with me. It mimics by name but I'd associate the "Many" part with a projection, certainly not with a remove operation. I'd avoid that one. 

Since we know we are dealing with arrays, you won't be paying for much in terms of performance in the LINQ calls. If that bothers you, it is simple to write the equivalent without using LINQ. 

When looking at months as indexes, you can take advantage that wrapping will be taken care of automatically. So with this, you don't even need to have a method, could be used and accepts negative numbers. This works nicely as it is similar to the methods available. It would be cleaner if you have your enumerable methods in a separate class from your extensions. With this new "indexing" scheme, this simplifies everything and you can make better use of LINQ. 

I would however not do your loop like that using a loop but instead use a loop. Then you wouldn't even need the increment statement there. 

It would be better to store your value as an integer as that is the "true" value that you're interested in. It's value is normalized using C semantics (i.e., if , otherwise as opposed to if , otherwise). That would feel more natural to me but it's up to you. I'd be careful with the operator overloading. Don't do it just because you can, do it because it makes sense. I'd stop at implementing casting operators from the type explicitly (since that's the only way to get at the value), use the constructors otherwise. And make only one of them an implicit cast, otherwise you will run into ambiguity errors if you use this a lot in your code. Consider implementing the interface and other appropriate overrides. If you intend to use this in your code, this could be invaluable. Consider implementing the interface explicitly. If you intend to use this type as you would any other in your code, you probably wouldn't want to see the serialization methods all the time. Otherwise if you are only using this for serialization, implement it implicitly. 

I'd use a format string instead. Any seasoned programmer will not find anything hard to read when using format strings. Though if you have multiple arguments for a multiple argument string (e.g., localization strings), it might be confusing with their orders or how much it requires, but they should be sufficiently documented anyway. It's a shame that the formatting features weren't a lot like python's. If you'd prefer not to use this approach for whatever reason, then I'm afraid you're catering to the wrong crowd for the wrong reasons IMHO. Alternatively, I know you said that you'd prefer not to use this but using would most likely be the fastest and most efficient of these approaches. There isn't anything to parse nor are there any intermediate strings you need to work with. You get your complete string in one shot. Now I've gotta admit, it isn't the prettiest of syntaxes and I too avoid them at times but there are ways to make it a bit more attractive. But at least the arguments should be immediately identifiable as they'd typically not be string constants but variables (which are highlighted differently in any decent IDE). First and foremost, your variable should always have the appropriate and descriptive names. This should be a given. Nothing kills readability as much as having crappy variable names, especially when you have a lot of them. And when dealing with large bodies of text, nothing's stopping you from moving that text into a separate method to encapsulate it. That way you can give your parameters better names when needed, you'd find the string all in one place and it isn't mixed in with your code as much. These could easily be tied in with your resource files to make it that much better. This also applies to with using the format strings as well. e.g., 

On a stylistic note, you should name your lambda parameters after the object they represent, not after what the entire lambda is supposed to represent. Judging by the names you chose in the method calls, you used for key, for element, and for value. These would be poor names and would be prone to confusion for other developers. In the call, I would name the lambda parameter either (or whatever is more appropriate) or simply as the parameter represents the that you are grouping. The call is operating on objects so I tend to use in that case. 

Consider changing your algorithm to perform the task. Every operation that you need to do takes some calculation to perform the operation. Not necessarily cheap as far as the test cases thrown at you are concerned. 

Any time you have multiple independent boolean variables representing a state, consider using a bitfield through the use of an enum with the applied. That way you don't need to maintain multiple variables to represent a single state. 

You could change it to just store the functions and the arguments. Then use the argument unpacking to fill in the correct arguments to the function call. 

Other than that, you've made great use of the computed observables. A big mistake I see a lot on Stack Overflow IMHO is when I see people putting all that logic in the view. I might change the name of the properties however to be more descriptive of what they represent. In particular, change to . Personally, I'd change it around a bit. I'd add an "Other" option in the cars list and make the car input enabled/visible based on that value. Also, consider making not observable. If this is going to be a fixed list and you won't be dynamically adding to it, making it observable may be unnecessary. In fact, I'd pull that array out of the view model as it appears to be a constant value. That way if you have multiple view models instantiated in the future, they all can share the same instance. 

Is there another way you could effectively count something within a range? I'm not sure how I can really explain this but consider this example: 

That's my initial analysis so far. I'll update some more once I've gained understanding on what you are doing. As I've said, it is very difficult to read. I'll probably offer more improvements once I've had a chance to look at it more. 

After thinking about this again, I think it would be better to just group them all at once in the beginning instead of partitioning at every step. Here's an alternate implementation: 

Adding up all the sizes that are less than some factor Counting all those that are greater than that factor multiplying by that factor. Adding the previous results 

This assumes they are in sorted order and there are no duplicates. If not sorted, add a call on beforehand. If there's duplicates, make it a beforehand. 

It might be beneficial to add positional and keyword arguments to the method. That way you'll get your for any call you attempt to make, rather than just the no-argument call. You may want to add methods to delete or redefine singletons if necessary or restructure your class to address naming conflicts. It breaks if you define one singleton and use it, then later redefine a new singleton using the same name. Consider making a property rather than a method. Consider using "new-style" class syntax explicitly. 

While we're on the subject of overriding methods, you should consider overriding the method as well to return something reasonable. Your method should do more validation than that IMHO. You make the assumption that the input will be a comma separated pair of values. You check if you have a pair which is good, but you should explicit perform checks to make sure the values are integer numbers (i.e., digits). It's not as useful receiving a generic format exception coming from the method than if it came from your method. On a minor note, use and for the local variables and not and ... that's not what they're representing. 

You could make it a little bit more useful if you added some supporting factory methods to create the arguments. That way you don't have to use the constructor and its somewhat awkward syntax (having to supply the types). 

Your method is a little unusual. You can merge the second and third conditions into a single . It might make more sense to combine that test with the tests for width and heights. And personally, I wouldn't mix accessing fields and properties within a single method, I'd choose one or the other unless the properties had other logic that I needed to be fired. 

For this, I would not use LINQ at all here. There unfortunately aren't any methods available to make this task easier. In fact, I would say trying to use what currently is available makes it more complicated and inefficient than it has to. As you can see by all the helper methods and whatnot you had to add, you can see how complicated it can be. Just make it work for , there's no sense in restricting it to arrays. Sure HashSets and Dictionaries don't have a notion of ordering, but how else would you make this accessible to other "ordered" enumerables? You'd have to add overloads for each type you want to support since there aren't any interfaces implemented that has this distinction. It would be easier to let it work for all enumerables and leave when to use it up to the user of your code. I actually have some code that does something like this. You only really need to keep track of the previous key that was added. If the current key matches the previous one, stick it in the same group, otherwise create a new one. 

Using a little bit of LINQ here could make this more readable IMHO. It's easier to think of it as "looping through the list of candidate records" rather than "looping through all records and skipping some of them." Personally, I would write the last set of conditions as I have shown using the conditional operator. You may or may not like it this way or this structure so your choice with that part. 

Your code attempts to fetch the values of all keys when it probably only really needs one. You do not want to be doing this. I think it would be better to create a list representing the priorities of what values you wish to retrieve and attempt to retrieve them. 

The function is just a function that frees ("deletes") dynamically allocated memory (memory that was requested from the runtime by a program when running). You will usually see it in conjunction with or (functions that request memory from the runtime). Think of it this way, functions like allow you to ask the operating system for some memory. You're free to do whatever you want with that memory for the lifetime of your program. When you're done with that memory, you'd use to give that memory back to the operating system. 

I might consider to be similar to the LINQ method . returns the set difference of two collections where the result contains unique values. Since this operation isn't quite the same, we'll still need to make this distinguishable hence the added "Entities". Since you are dealing with a set (?), this sounds perfect to me. But after thinking about this more, I'm not quite sure this is the better option since this modifies the collection. I think might be a better fit. "Remove" makes it sound as though we're modifying something. doesn't cut it for me as it is named the same as which removes all that matches a predicate. There's also a which removes a range of consecutive values in the collection, not quite the same. So I'd go with but an overload of the name might be fine, just beware of the similarities of the names in other objects.