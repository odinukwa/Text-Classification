... separate the technologies (Spring service, Spring DI, Spring task scheduling) ... ... introduce a model ... ... make the services depend on the model (observer mechanism) and not on each other ... 

Consider the iterator pattern with the methods hasNextCombination() and nextCombination(). Let your implementation follow the implications. Maybe you have to introduce a buffer. The loadCombination()-method inverts the responsibility and let you do strange things like clearing the given list if the client gives you messy data. The standard iterator pattern is the way to go. Pass your list of elements to the constructor of your Iterator. Make defensive copies to avoid side effects. Return the combination of the elements directly. The Client should be responsible to collect them in a list. Even this suggestion will be obsolete (1.). Do not check for "null" values. If the client gives you "null" then he should expect that the program will not work properly. Giving up the responsibility of the client to not pass null values has serious consequences for your source code. You will end up checking everything for null because you cannot count on anything. There are some exceptions to that which should be known: The parent of the root of a hierarchy may be null, lazy initialization is dealing with null and son find()-methods may return null that has to be evaluated immediatly. In all other cases: Never pass null, never check null and never return null. Break the generateNextCombination()-method into smaller pieces. If you experience problems then it surely has to do with the multiple return statements. Multiple return statements will hinder you to apply refactorings like "extract method". Furthermore: extending your code is much more predictable. Avoid multiple return statements in a method. Provide a proper control flow until the end of the method. As a matter of common usage do not use ++k. Use k++ instead. You yourself are switching between suffix and prefix notation. Keep doing one thing consistently to have the least surprise. Do not forget to adapt your breaking conditions. As it is used in the test, do not take my suggestion too serious here but: Avoid using bit shifting. I do not event know if there is a significant speed up. After all it doesn't matter until your application critical on this. And most of the applications aren't. The reason is you introduce low level language structures in a high level language. 

This implementation may be semantically wrong to your example BUT it does not hide important information. Doesn't matter if my guess was wrong or not. The missing type information makes it hard for others to really help you. The only artefact I was able to use to identify your intention was the variable name "this.variables". Any other suggestion would be reformulating the statement without knowing about any general design issues. 

Model In a similar question I provided an example. As a matter of revisiong I will provide it here as well so you get an idea how to separate the concerns. Main.java 

Naming I think "DogMapper" is quite good with the name. What your are doing is you are transforming a relational representation of a Dog to an object in the sense of php. In Java this is called Object-Relational-Mapping. Getter and setter Getter and setter introduce an indirection that allow you to perform additional actions. But doing this the things are getting complicated. Mostly you will violate the Single Responsibility Principle because your getters and setters should only do what they are telling. It depends on the type of object. In Java we call "objects" that have setters and getters for all their attribute "Beans". They have little assertions to consistency. As setters may put your Beans into an inconsistent state you should think about it if you want to allow this. If you do not want to allow this your Dog-Class seems to be a "Business-Object" or a "Domain-Object" that holds its internal state consistent. Setters in Business-Object will evaluate the input. And Getters of Business-Objects may do more than simply returning a the value of an attribute. They can do calculations or load data. Mapping You DogMapper-class seems to me like a DAO. A DAO will access the underlying datastore and pass an object with a proper representation to the upper layer. Semantic The question is: Should your Dog-Class be a "Bean-Object" or a "Domain-Object"? My personal opinion is: Separate the concerns of the Object-Relational-Mapping and the business logic and do not put all the burden on one object. So you have three responsibilities: 

Derive a Caching enabled ChildProxy from the "Child" and intercept the getParent()-method to check for a cached Parent-Object. If you would have a JPA-Layer you may not need this because OR-Mapper often have their own caching mechanisms that are sufficient for most usecases. 

After that we can start to produce elements asynchronously that will be registered in the "elementJoiner". You see that there is no difference in formulating the element source for the "other" and the "http request". 

... where to receive or how to produce elements (supplier) ... where to register the received or produced elements (consumer) 

After you have the algorithm clear, think about structuring your program. The state pattern is appropriate to represent the game state in every situation. Extract important constants like the maximum marbles to remove in general Identify important pieces of calculation and extract them. Calculate the maximum marbles removable at one specific turn. Do not make the answer of Dr Nim dependent on the user input. This seems to be the easiest way for this case. But if you have more marbles or maybe different rules Dr Nim should evaluate the amount of marbles depending on the remaining marbles. This is a very important semantic issue. Avoid key words like break or continue. They will hinder you to apply refactorings like "extract method". They break the normal control flow and let the breaking conditions be spread all over the place instead of providing a single point to look at -> the loop header/footer. The same with return statements. Avoid multiple return statements in long methods, especially in loops. Try to have one return statement at the end of a method. Provide a proper exit condition for loops. Do not break or continue loops because you mess up the control flow and spread breaking condition all over the place. Extending and refactoring the code will be difficult. Provide the exit condition in the loop header or footer, nowhere else. Other developers should all exit condition see in one place. They should not be forced to collect them through the code. 

I like separated classes instead of inner classes they are more handy in testing I would have separated the algorithm in "generateNextPermutation()" in an additional class. I would follow the recursive nature of the problem and build a recursive structure. This is a slightly different approach. I do not exactly know how the algorithm should behave if you provide an empty list. I assume that you will have one permutation as result. So I adapted your algorithm to work with an empty array of indices. 

Do not return any value (void) from Verify() and only throw exceptions Catch exceptions in Verify and return false, true if everything is fine 

Check only odd numbers Check only numbers to the square root of the number under test You maybe want to count down instead of count up 

My advice is to make rare use of the Optional-construct. It may make the code look "cleaner" and surly "shorter" but it brings a false sense of safety. BTW less code is no metric to follow. I would come from the other side and ask questions like: 

Passing the parent id to the constructor of the Child object and resolving the parent through the DAO: 

I want to underline that these are only indicators. A long method method for example can do only one thing: initialize a hashmap with key value pairs. Although you would have thought about solving this another way it's not violoating SRP. So if you have an indicator you can make a thought experiment if there is a violation. If you think you have redundant responsibilities then you should think about a new business requirement that changes one code fragment and ask yourself should the other change as well. This you should discuss with the business people. BTW consolidating responsibilities is much harder that separating them because this may break the application as one redundant code fragment will be omitted. So back to your question: A class does not become holy or a god. It will become less godly by eliminating violations of SRP. Theoretically the class becomes godless when an 1:1-relationship of responsibility and code fragment is reached. But to ask when there are too much responsibilities does not make sense in the context of code quality. This will only be a matter of costs to maintain the code. If it costs too much (for the business men) and the costs can be assigned to the SRP violation then certainly there are too much responsibilities.