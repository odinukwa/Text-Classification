It looks very interesting. I just find a little bit difficult to read so much code with comments, so I would like to suggest to have even more code but without comments :) Let’s have a look at . It has not so many dependencies to the class, just an attribute name which is never used anywhere else. It also requires a lot of comments which have tendency to become outdated. 

What we consume here are the following (classes are short, so there is probably no need to explain the code – I basically combine multiple implementations of ): 

I found myself in a situation where it is necessary to often decorate connection strings with some kind of metadata, like an extra DB Provider attribute, read it back, and remove the decoration without damaging original content. Here is how it looks like: 

I think I got it :) I removed my previous answer as it was not enough SOLID (too much dependency on subtypes). Here is how it can be: 

Is it about web or windows UI? WPF or WinForms: you could just use PropertyGrid - it is the same component you have in Visual Studio to edit properties. To define properties at runtime if happens to be needed - see TypeDescriptor. 

Supports and where is Entity or Anonymous Type, tested with EF6. Just one class to simplify copy/paste: 

In stead of branching, you could use one of the conditional forms of . Same code size but faster. Having less labels is also nicer. 

Your comments certainly explain well enough the purpose of the code, albeit this one (; Preserve ESI) is a bit superfluous. What would greatly enhance the readability is you writing tail-comments in stead of whole-line-comments 

If you're really interested in becoming better at x86, you should avoid retrieving the parameters using relative addressing. It works and it can shave off a few bytes, but it is very error prone! Imagine at some point in the future you need to preserve more than . It would require closely checking all the code. Using prologue/epilogue code isn't that much more difficult: 

As said before, clear registers using . Furthermore you can compare memory with an immediate directly, no need to do it through using a register. Had you written the (short) 16-bit version above the (long) 32-bit version, the conditional jump could reach the 32-bit version easily. 

Here you see the importance of local labels. No need to invent unique names for all of these trivial locations. Do note I changed the instruction by its unsigned counterpart . The numbers involved are inherently positive, and so seems more natural. 

Here you need to verify your understanding of the count in . It specifies the number of characters that you want to draw. The hexadecimal value 1000h equals 4096 in decimal, but the usual 80x25 textscreen only has 2000 characters to play with! In your program it seems to work OK only because the video memory is much larger than that single display page you're looking at. Nonetheless you should correct it to avoid developing the bad habit of buffer overflows. 

OK, see below, it fetches configuration updates from the db. It is going to be a lot of code :) First of all, we need a helper infrastructure base class to help compare configurations: 

What do you think about non static validators? While making validators smarter, we will sooner or later need to wire up their dependencies (like repositories)... Validators can easily do much more while being instantiated by IoC container. I would suggest to define this interface and class: 

I would like to re-render my WPF chart control when data source is changed. My minimum requirement for a data source is but it could be also or , so collection change notifications are sometimes becoming available. Chart class (simplified): 

I would define API a little bit different. Let’s go with couple types: SizeUnit and DataSize, so they can be used as: 

I removed my previous answer, as it could be modeled a way easier using singletons and reference equality. Demo: 

You can possibly try Domain Events. Or just Event Broker patterns? What I usually use is something like this: 

Azure Service Fabric uses serialization, which is a total disaster – it violates LSP (wiki) - see all those things, making framework development basically impossible. I made the following class be a parent of all to convince Service Fabric actually consume Binary serialization when it thinks about Data Contract one: 

After striking all of the common routines it becomes clear(er) that - as is often the case - there's a price to pay for the increased speed. 

Lookup table. The lookup table (LUT) is filled with classification bytes. No need to have the data in this table repeat itself. There's more to gain from re-using the same lookup data (caching) than that there's to loose on the additional instructions to fetch it. The LUT can either be created at run-time with an initialization routine or at compile-time. It's easy to fill the LUT by hand. For the simple FizzBuzz a mere 15 bytes. I chose to let the assembler do the work. Lookup tables are powerful instruments. I wonder if ever any applicant when confronted with the original FizzBuzz task has used this approach. Not sure about what the recruiter would have said either! 

On FizzBuzzGo the number of divisions was reduced by 49 percent. It is very easy to turn this binary tree into something shorter that doesn't use any conditional jumps. I decided however to not keep it because I feel there's at least some contradiction in branchless binary tree. Moreover it was a bit slower. 

This is the only place where your code conceivably could fail. You store the dword from without making sure the high word has any meaningful content. If the high word is empty you're in the clear, if not the screen will get disrupted. Since modern BIOSes do use 32-bit registers, you can't be sure... The shortest way to 'correct' this is: 

I would say that we should be able to execute different query handlers given the same query parameters – for testing purposes. Simple data transfer object (query) being passed to the repository interface allows us to do it in a well-known and understandable way. The same time the following works well for me (SSAS MDX queries)… To define MDX I use a partial class in multiple files (example): 

Should your object know if it is captured? Probably not. So we can factor out that responsibility. Let’s define: 

We need to project EF Entities to models (), but it should be really cheap to do manually in the repository, as it probably has a very narrow interface. It would help to publish your input and output (query/result) structures. Sorry, everything else could just turn out to be a redundant overhead in this case :) 

Now let's define an active (threaded) component. You could find it useful to pass to resource actions to support long running processes termination: 

P.S. Generally speaking, C# is a pretty verbose language, so it is often punishing good programming practices… 

What do you think about this file system manipulation helper? There is an utility class Folder which I can use to define directory structure of my app: 

Version #2. Disclaimer: it is also just an experiment (more sleep, less coffee :) It is dangerous to eat all the exceptions, so I would go with a list of explicitly stated exceptions we expect and could tolerate. The same time, let’s try expose version + define a special inherited class, named , which will log all the problems for us: 

Size optimizations. To clear the EBX register use . It is shorter than . To jump if the ECX register is clear use . It is shorter than the combo . Please note that I changed the destination to cope with the possibility of the argument Dimensions being zero! Your code would erroneously have used mask3 in this case. 

In this simple program it is what I would do. If the polling section were much longer I would keep what you wrote. 

This is a very nice approach! Although for reviewing purposes I had to read it a few times over, it is definitely better here than the simpler would have been. 

There's little point in first moving the contents of the variable d to a register and then doing a subtraction between registers when there's a possibility to subtract the variable directly from the accumulator writing . 

Divisions are costly. In order to conclude that the current number is prime, you perform a division by 2. 

Everywhere a division was needed I chose to replace the usual instruction by an instruction. This can only work if neither dividend nor divider exceed 255. It proved to be a winning move as it: 

The UPDATE_SECTOR proc deserves a better name. The LOAD_SECTOR proc does exactly what its name suggests. It loads into memory a disk sector. The UPDATE_SECTOR proc on the other hand doesn't deal with the contents of a sector. It merely changes the value of the variable varSect that holds a sector number. Better names then would be UPDATE_SECTORNUMBER or UPDATE_VARSECT. When it comes to actually updating the sector number, I see no benefit in checking if the increase is zero or not. Given that all it takes to raise the dword variable varSect is