All this stuff is exactly what is intended to handle: provide a dictionary that, when accessed with a key not currently present in the dictionary, returns a "default" value generated from a no-args factory function. You can use this with as the factory function, or or even something clever like a of that generates nested s! You can also pass as the factory, which constructs an integer (default value = 0) as the default value. But wait! Instead of using you could also use . This implements a bag that counts the number of times each element is added. (It's much like but with slightly different semantics.) Which one you use ( or ) will depend on your code structure. If you can structure the items as a sequence or generator, the might be the best option - it can take a constructor parameter that slurps them all up. If you have to bounce around from one collection to another because of the way your data is structured, the approach might be best. Something like this: 

If we look at this code, what's in the value? It's the key from the dictionary. But the artists dictionary was built like this: 

This repeats later, with similar behavior: iterate over some grid points, reach inside the object to check for obstacles. Just get rid of this entirely! (I'll talk about this under ) In the meantime, replace all these calls to with . Better still, if getting and setting continues to dominate your performance, make your grid classes subclasses of dict so that you can use C code to do the lookups. : This is another space-for-time optimization. Compute these values once, at startup time. Return the same list repeatedly. Here's an advance hint: if your obstacles are constant positioned, just drop those cells from the list - there's no need to check for obstacles if the cells that contain them never get returned. : This is only called by , so it will disappear if the neighbors are precomputed. : This appears twice - once in which will go away, and the other in in your bfs. There are some optimizations I'll talk about under that function. : This function boils down to this traversal of the grid: 

Because that is the kind of "comment" that you know is true! In summary, please put your comments above the affected line. It provides a warning that I might have to think hard about what's coming. And it hints where I should focus my attention. Also, don't apologize in a comment. If you find yourself explaining something, the first thing you should try to do is FIX IT. If there are funny values, try to delete them. If you can't delete them, or don't want to, then try to make them as self-explanatory as possible, so a comment isn't needed. Some Comments on Programming Style Knowing your limits You handle the special case of zero. But you don't handle any other limits. For example, what if is less than zero? Or, what if is greater than or equal to 1 nonillion? I'd suggest that you include nonillions in your vocabulary, just for completeness (every other array goes up to 9x). Beyond that, you should have a plan: will you raise an exception, or just print "123,456 nonillion", or return a special string: "the rent is too damn high!"? You need to handle it - pick a mechanism. Code shape Here's a picture of your code shape. I deleted blank lines and comments, and removed the constant lists. I then replaced every character with '#': 

Back in the day, even before the official C89 standard was released, people were asking "why the hell does strcat not return the end pointer?" I believe that the C standards committee, in a fit of pique, "doubled down" on their mistake and made a willful effort not to remedy it, simply because it would be admitting that they made a boneheaded error in the first place. It's been a sore spot ever since, and now they've switched to which doesn't return a pointer at all, which leaves the problem unresolved, and leaves as an unloved and underused function. Also pretty much from the get-go, there were libraries of string functions that provided an alternative version of that did the right thing and returned a pointer to the end of the string. Often, those functions were named or , with the meaning "return a pointer to the end." There were also and various functions. (IIRC, Borland provided them with their Turbo C++ compiler.) Considering that you know the size of the buffer, I'd suggest you simply write (or search for) a version of and and maintain your own count of characters remaining. I suppose you could maintain both pointer and count in static variables, and accept a destination to mean "use the previous values". You should read up on first, though, to understand the implications - in general that sort of code isn't thread-safe, interrupt-safe, etc. ( has nothing to do with but it's defined to have similar "use the last string" behavior, and usually comes with a bunch of caveats in the documentation.) 

If you want us to evaluate your code in light of the pseudocode, you'll have to provide the pseudocode, too. That said, it seems like you're doing a lot of extra work. Specifically, whenever you find an you're swapping the and values. The description you give of the pseudocode says to find the min, and then swap. That would be a single swap once the loop is done. You might need a separate variable to hold the index of the min, too: 

The implementation of your Array class still bugs me. So I cloned your repo and renamed Array -> OldArray, then created class NewArray: 

You are doing several things in this function. You determine a filename, which you then never use, you are decoding the data buffer into a structure, and printing the structure elements to stdout. Since the name of the function indicates this is an event handler of some kind, I really don't have a sense of what you're "trying" to do. My recommendation would be to decompose your existing large function into several smaller functions. In particular, here are some obvious candidates: 

Starting from location , the question is not whether but whether . The 45 degree angle will be relative to the start-point of the line, not the origin, I think. That said, your loop over is duplicating the results of looping over . I think you could profit by keeping a running total of lossage during your loop, and just adding it in when appropriate. Viz: 

(Or, going down, a slightly different slice with -1 step.) You'd have to initialize the list to whatever the incremental costs were.