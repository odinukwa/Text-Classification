Maxmind is a good service, though occasionally there can be errors, since we're now in the time period where IPv4 blocks are scarce, and are being traded and resold on a gray market. If you do find an actual error you can report it to them, though this doesn't appear to be an error. This is basically how I confirm the location of an IP address: First, I'll see what Maxmind says about it. Their online tool tells me it's in Malaysia and registered to Universiti Teknologi Malaysia. But is it really? 

The calling service is broken, but there's not much you can do about it unless you can fix the caller. From RFC 2616: 

Set a different temporary directory on a filesystem on which you can execute binaries. For instance: 

Your web application sent the second redirect. Check its config to make sure it knows what domain it is supposed to be serving. Curl doesn't like the SSL certificate because you didn't install the intermediate certificate. 

Note also that you can specify instances in the requirements as well. For instance, if requires of the same instance name, you can say in : 

Matthew Ife's and shodanshok's answers cover the issues in general, but I want to address your specific concern by putting the issues in context, as it is exactly these sorts of systems that I manage. My current build for deploying PHP/MySQL web apps is: 

A file that's created empty, when it was meant to contain data, usually means that the disk (or disk partition) is full and so the file could not be extended past zero bytes. Check the output of to confirm it. 

You have a package installed on your system, but its provenance is highly questionable. No such binary package was distributed for EL6, as far as I know. While there was a package split, it applies to EL7 only. To resolve this, you'll need to remove the questionable package and update the package at the same time. For this you can use yum shell. 

No, that's not possible, because the new server knows nothing about the state of the previous connection. A WebSocket is not stateless like UDP or Ã˜MQ. The client must reconnect in this case. 

nginx is trying to pass upstream to a web server on port 81, as you configured it. However, you probably aren't running Rails on port 81; by default and some other Rails web servers listen on port 3000. Double check the port number that your Rails app is listening on, and make sure it matches what you have configured in nginx. You also need to make sure that the upstream server is actually running. It could just be stopped. 

I feel like I've missed something important, but at this point I really don't know what it could be. What's going on here? How do I get the system fully mitigated? 

Finally, you probably want to rename your item. is very generic, and is already used by common MySQL templates. Something like might be more appropriate. 

Your iptables rule allows incoming connections to port 3306, but only on the eth0 interface. You are probably trying to connect from a different interface. To resolve the issue, replace the rule with one that allows the traffic you need. For instance to allow traffic from all interfaces: 

Or... Create a configuration drive as an ISO CD image containing the metadata which would have been obtained from the metadata service, if one had been present, and permanently attach the image to the virtual machine. You almost certainly do not need to do this. 

Only if you want to rewrite your nginx configuration every time you restart that container. Better to just give it a static IP address. 

Get a Dynamic DNS service. There are many such services available from various places on the Internet... 

The most obvious effect is to keep firewall rules to a manageable level, which does not have a significant impact on performance. At a certain point, you may end up with too many firewall rules and not enough CPU to process them quickly enough. The default limits may seem low, but they're sufficient for most people, who will never create more than a few security groups with perhaps half a dozen rules each. 

RFC 4864 describes IPv6 Local Network Protection, a set of approaches for providing the perceived benefits of NAT in an IPv6 environment, without actually having to resort to NAT. 

So, you were meant to remove the word each time it appears in the repo file and replace them with . Instead, you replaced them with . Once you correct this, you will find that you are able to install the Tor package correctly. 

You don't need to add or even have custom direct chains (though you can if you want to get really complicated. Just add to your existing chains directly. After IP version, table, chain and priority, you simply specify the relevant iptables options: 

You have somehow managed to install and the yum repository (provided by nginx.org) you have installed along with it is not compatible with Amazon Linux. It is intended for RHEL 7 or CentOS 7. Amazon Linux is not compatible with RHEL/CentOS, and packages for these often do not work on Amazon Linux. To resolve the problem, launch a new instance with a supported operating system distribution such as RHEL 7 or CentOS 7, and install nginx on that instance. 

You can't do it that way. Anaconda won't load a driver disk from CD-ROM or DVD media, and besides, you wouldn't want to devote an entire CD/DVD to a couple of megabytes anyway. Nor will it mount a disc image file from CD/DVD media. What you can do is to put the driver disk on a USB stick, and boot from the CD-ROM with the USB stick inserted. Organize the USB stick such that the file and the directory are at the top level of the USB stick, and change its volume label to . In this case the installer will automatically load the drivers from the USB stick. (You could also do this with the installation media on a USB stick and the driver disk on a second USB stick...) 

Looks like mod_security is working perfectly. It blocked the request because the header only contained an IP address, which is what this rule is meant to do. You should be using an actual hostname to refer to your web site, in production. It's also a good idea in development too, but if you need to use an IP address in development you can always disable that rule. 

This will tell you that the package provides . I was a little surprised to see that you didn't have installed, as that's a pretty basic program that ought to always be installed. But, you learn something new every day... In a future version of RHEL/CentOS, will be provided in the package, and should always be installed even on the most minimal system. 

Office 365 has a feature where it can act as a relay for your internal office mail servers, but it's only available on the enterprise plans ($8/user and up). Your best bet here, assuming you don't want to spend a lot more money, is to create a user account ($4) and have your local mail server(s) authenticate to it. Sendmail and postfix are both capable of authenticating to a remote SMTP smart host. 

If you need to handle static files under that directory specially, then you can make a block for them. (You probably should do this, since you seem to be passing everything else to Django...) 

Your nginx configuration doesn't show any redirects on port 443, and you claim not to have a load balancer in front of nginx, so the only other place the redirect could be coming from is ... your application. I see that you are running the app on https, but you have not told Rails about this. In particular, your nginx configuration is missing: 

But to extend this for will require a bunch of extra logic, which is a lot of work for absolutely zero gain, since dnf's yum compatibility will take care of it. Here is a place where that hypothetical "automatically figure out what package manager to use" module would be useful. But even if you had one, you'll still sometimes need to use individual package managers, because some of them have ... idiosyncrasies.