will replace the condition for checking null-ness and emptyness, I would recommend you look at as well, this is good if you may be getting some blank spaces newlines or tabs with your data. (Optional) Instead of comparing your Enumeration to 0, implement a value, this way in-case someone ever changes the default values of enum this code will still work. Or if you don't want to change the enum, you could just check to see if the value given is a valid value in your enumeration. 

Make sure you are disposing(closing) your database object. I presume by the way you have your class setup that when your database object is disposed it will close, in which case I would recommend using the keyword. Which would make your above code look more like this in practice. 

I just wrote this short little program to increment up the build number for my projects every time I build them. After compiling this exe, I just call it in the pre-build command line. I did take out the filename string because I used it thrice, and I figured I'd get some flack if I didn't. 

This is a simple boolean comparison, so you can literally just return the result of the comparison and not have to make a bulky if-statement. I think that Janos did a good job touching on making your class a simple static method. I agree with him about your use of tests also. You put in a lot of code (more than your actual list and program) to do some really basic tests. I would honestly just keep it to one method. 

Room_Dimension Class Overall, I think that this class is laid out pretty well. There are a couple small things that I would question though; 

You never do anything to modify , yet at the end of the method you return ? Some comments would go a good way in explaining that a bit. 

I have an AngularJS function that is used to determine which associative array variable is to have data pushed into it. I would love to be able to remove the switch case entirely if possible but haven't been able to envision a way to do that! My overall goal is to both improve performance, but more importantly reduce the overall number of lines if possible I also considered perhaps some type of variable interpolation, but that seemed like an investment with little return on my effort. The directive is called in my HTML like this: 

Your program is a bit flawed. Technically just 0 is a subset of {0,1,2,3,4} however you appear to only care of subsets of 2 or more numbers. 

A good alternative to your current implementaiton would have been to create a recursive function which takes in , and the method would simply loop over the remainingNumbers and making new composites to check on, each time you would want to check just the currentComposite to see if that is a valid set. The way I would do it, would be to create a list of number arrays which hold every combination of the given numbers, then I would simply loop over that collection to determine which sets fit my conditions. Here is some code I found online (specifically here), because I did not want to make my own Combination generator. I'm going to post this code on CR, because I'd like to see someone take a stab at making it better. 

Here is my updated code per the suggestions given in Joe Wallis' answer. I have changed the main loop in the method, eliminating the if/else statements. I have also added additional methods to aid in easily retrieving data later form a separate module that is used. 

An easy way to detect a cycle is through the implementation of a disjoint set structure, sometimes called a Union-Find structure. You start with a source node and attempt to add a node to that set. If your Find() call for the source node and the other node returns the same root node, then a cycle world result if the nodes are unioned. UPDATE: You could implement a topological sort, arranging the nodes with edges going from left to right. A topological sort can only be completed successfully if and only if the graph is a Directed Acyclic Graph. So, if the algorithm detects any cycles, it will stop. The runtime is O(|V| + |E|), which is better than DFS, in the case that repetition occurs during traversal. Topological Sorting 

I was able to compile and run using , perhaps I wasn't using c99. So perhaps just don't use c99 :). If you have to use it, then declare those ints as symbols or consts above , then you can say 

If you were looking reduce the amount of code further, you could probably skip the whole dictionary part of this, and just compare the lists returned from the , by intersecting them and subtracting one list from the other. I just had to try :) 

However, now that you have actual code to review, I will also point out that there is no reason to be using a loop vs a loop. I would write that as follows. 

Yes... there is a simpler way. You have two choices, but each about the same. Use an Array, or a Map. The more advanced way of doing this would certainly be with a Map. Think about a map as a type of array where instead of using an integer to index the array you can use anything. In our case here we'll use char as the index. Because chars are ints you could just use a simple array in this case, and just mentally think of 'a' as 0, but we're going to take the larger step today. 

So what would happen if a user input a negative number? This would definitely give you output, but is it valid or even usable? Overall, your code is alright. But try to avoid uneccessary spaces or excessive blank lines, it results in code that is tedious to scroll through as the program becomes longer. Try to implement the DRY Principle as often as you can, it will result in elegant code that maximizes re-usability. Putting my suggestions together and leaving some work for yourself, is the code below: 

If this method doesn't actually do anything, it shouldn't be in the code. I would say that having copy constructors can be very helpful... If the method is properly implemented. The point of a copy constructor is that you can pass an object, which is already instantiated, to another object of the same type to instantiate it. The benefit to this is that you don't have to worry about passing a bunch of values to the object manually. You literally create the copy of the object with the values that it contains. 

Contact and ContactItem should in some way be child and parent, or at-least share a common ancestor so that you don't have to manually copy over all that identical contact information. I'm not certain, but I think you might have wanted all this to be done with the and not the of this contact. You should be using in-case these strings haven't been trimmed or something. As for simplifying your nest of ifs there are two solutions that fit the program as is. 

Review I don't know if this is something you should implement, because I don't know how you intend to use this class. In C# you can place access modifiers on the individual parts of the getters and setters. A way you can use this (again, not sure if you need to, but this is isncase you do): 

Because the TryParse method returns a bool you can just use this in an if statement which is conditional on the TryParse returning true. 

You have this copy constructor in your class, which is confusing because your class is mutable. Typically, we only need a copy constructor if an object is immutable. If you wish to keep the copy constructor, remove the setter and getter and change the copy constructor to this: 

This can be placed into it's own method so that you don't have to repetitively type it throughout the code:': 

Also, you should always use brackets in your statements, even if it's just one line. Not using brackets makes things harder for other programmers to read your code and increases the probability that unintended bugs arise. 

First thing that catches my eye.. Where are the comments?! I mean if you write good code, you don't have to write a lot of comments. But you literally have almost no useful comments in your code. What are you doing here? 

I have been working on a script that automatically checks on the state of 2 services that I require to be running 24/7 on a server that I manage. The script works as I need, but I would really like to optimize it if possible. Specifically, I find that I want a way to reduce the need to type the command: 

use iterator instead of , I also took the liberty to use ternary operators instead of giant if-else bocks. 

Over all, your program could look like this. Note: I didn't programatically address the issue of the user escaping your program, I noticed you updated your OP with that. 

I'm working on some precompilation operations for a world compiler. Currently to identify flags placed by the level designer I need recognize when a specific entity exists at specific coordinates from the flag's origin. I need to generate a list of offset coordinates from the origin(and include the origin) in string form. That is 7 coordinates. this operation is done for every flag in the world, so it is preferred to be efficient. It is not an operation that takes place during gameplay, so I don't have to worry too much. My current implementation works correctly, and quickly, however I still would like to get a review on what I have written, and hear any advice to better this operation. 

Otherwise, I would remove the copy constructor; it really has no purpose if your class is mutable. On the topic of mutability, you have one private member and one public member? It's a bit odd that you would expose the next node, but keep the values private. I would change the to be private: and then I would create getters and setters for it. Only do this if you are required for some reason to have mutable Linked List. 

Input validation You do this for your statement, but not really anywhere else. While this doesn't make a huge impact on this particular program, it could on another one you write and you need to get into the habit of checking anything that you receive as input from the end-user. Here is a simple example of what I mean: 

Any other feedback is greatly appreciated, I am new to bash scripting and trying to find the best way to get this to be as optimal as possible!