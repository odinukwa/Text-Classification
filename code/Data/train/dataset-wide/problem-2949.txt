The class's function solves the entire puzzle. Understanding the functioning of this function will be enough to understand the working of the algorithm. The following, 

The following is the header file, containing the primary functions that are used in the evaluation process: 

The following defines bit-field values associated with each symbol accepted by the sudoku board puzzle: 

The program first determines the set of all possible values that can be entered into every blank square in the puzzle board. The possibility set is determined by iterating through the row, column and the block, and eliminating the set of numbers already present. The possibility-set is stored as a bit-filed value for each square. Every blank square with a single possibility gets the number entered into it. The algorithm is repeated from the first step again, until there isn't a square with just one possibility. If there aren't any blank squares left, the current board's state is returned as the result. It chooses a blank square and enters a value into it. The process of choosing the blank square, out of all the available blank squares is guided by an analysis algorithm. The value entered into this blank square is chosen from all the possible values that can be entered into the square. A recursive call to this function is initiated with a clone of the current board's state. Note that the current board state now contains the modification done to it at the 4th step (entering one of the possible values). Steps 4 and 5 are carried over until all the possible values in each of the available blank squares are tested with, or until the puzzle gets solved. 

stream->list Avoid on large lists. In your function it will create a (large) list before passing it on to . There is a stream version of - namedly , and this will process the stream lazily - i.e. it will only generate as many elements of the stream which are needed. next-prime Another way to eliminate the recursion here is to combine with and with your predicate, e.g.: 

e.g. is all the ways of removing one element from the list . Also, using the polymorphic signature alerts the reader that the function isn't specific to Ints. I would also introduce a type alias: 

The method is relative slow but indexing using is very quick. Instead of appending each wanted pattern and then calling to find it again, just append the index to : 

Note that row and column indices start from 0. In the case of diagonals, 0 is the main diagonal, with positive diagonals to the right and negative diagonals to the left of the main. Products And here is how to use : 

This means that your code doesn't cover all of the possible cases. Append to your question an updated version of which doesn't produce any warnings, and then I might have some further comments about it. (Please append to your question instead of modifying it so it doesn't invalidate any existing comments.) Let me know if you are not seeing this warning from ghc / ghci so we can figure out what's going on with your environment. filterEmpty I don't think the logic is right here. What if you have this message: 

This Sudoku puzzle solving algorithm follows a brute-force approach mixed with rule-based approach. To further improve performance, an extra analysis step is added, to determine which squares to be prioritized while choosing it to be filled. The priority value is inversely dependent on the number of possible values that can be filled into a particular square. This value is used in computing the priority weight value of each of the blank square that is to be filled. This priority weight value helps in ordering which squares must be filled first. 

Though this algorithm may seem to provide an alarmingly bad worse-time complexity, this algorithm almost never hits the worse time complexity regardless of the (legal) puzzle entered. List of types defined and used throughout the program : I. BoardGrid 

The signed integer values from represent the numbers in the Sudoku puzzle board. The value zero signifies a blank-box in the Sudoku puzzle board. 

initializes the evaluation for the current iteration. The statement called before these is the program's attempt to try and solve the problem purely based on the rule-based procedure, trying to eliminate the set of numbers that can be entered into each square. The function iterates through each bit-field trying to discover the possible elements (values) that can be entered into the blank box. The set of values are then stored as bit fields. This function runs in a loop because, an empty box getting filled by a value might help provide enough information to figure out the value in a different box. Therefore, until such a possibility is ruled-out the function iterates. The above process configures the bit-fields, which would help the function to compute the number of possible elements that can be entered into each square. The next function, which relies on the result of the function, computes the which assigns a floating-point value to each square in the sudoku board following the expression and later the function is called followed by the function, which returns the list of all the empty cells, along with its associated priority value. The function sums the number of possibilities across each row, each column and each cell (the smaller boxes, which must also contain values from 1 to 9) and stores them in an array. The function returns a priority queue, sorted based on the priority value derived from the result provided by the other three functions. The final depth-first search is computed by recursively calling the function, belonging to a locally declared instance of the class. The sets the puzzle board for the next recursive call. Recurrence is brought about by calling the same belonging to a local instance of the same class, declared within the function. In what areas does my code need improvement? And how can I improve the design of my code and algorithm? I wrote this code intending it to be Object oriented. How object oriented is it? (I.e.., is there a better way to structure the same solution) And is there a better algorithm to solve this problem more easily? For complete code, please refer this URL: $URL$ 

and it avoids having to return the object from the player object. Perhaps my implementation of isn't quite correct, but you can make it work. 

Using Data.Memocombinators Have a look at Data.Memocombinators module. It offers combinators for memoizing functions which is essentially what you are doing with the . Here is the example from the documentation on how to use it to create a memoizing fibonacci function: 

When you add a new kind of song, you can decide which class to inherit from based on which methods are valid for it. For instance, if it has all of the methods of plus some more, then inherit from . If it has the methods of plus some more, then inherit from , etc. This way you won't have to modify any of your existing classes when you create a new song class. 

If none of the rationals in the list are roots of the polynomial, then there are no rational factors, and calling again won't change that. the NaN problem Perhaps your NaN problem is caused by this code: 

Even though they are not needed, they aid in reading the code. Also, aligning the in the case patterns helps with readability. The type signatures on your calls are not needed due to Haskell's type inference. insert You should be getting this warning from ghc and ghci: 

You've gotten rid of a lot of global variables, but you can do even better! Consider writing this function: 

Then you have a list of primes and their exponents: (p1, e1), (p2, e2), etc. and the number of divisors is: 

These are the definitions of the generator functions. This shows the vital functions involved in the analysis process (the process to determine the priority of selecting blank squares): 

I had written a Sudoku puzzle solver that accepts puzzle boards, and completes them with the least possible time. Rather than purely depending on brute-force, my algorithm first attempts to fill in the squares that have an obvious solution. And for each square being filled this way, the amount of information increases (I.e.., more number of squares get filled which aids in filling in the remaining squares) which makes the further iteration process easier. Once this method fails (this happens if there isn't an obvious answer to fill-into any of the squares), the algorithm immediately switches over to brute-force search. (Note, the source contains a few spelling mistakes, like the word recursive misspelled as Recrussive. Please ignore spelling errors. Anyway, it has been a while since I touched this code, and this was my first object oriented code written in C++). The basic working (High level view) 

The value represents a null-set. The values starting from to represent the values in the Sudoku board. For example, the bit-field value represents the set of numbers: . Therefore, unlike this stores multiple numbers in an integer field. An object of this type is used for holding the possible list of values that can be inserted into a particular square. 

This holds the priority value of each square in the puzzle board. This is used during the evaluation process, where each instance is sorted based on the . A detailed explanation will be provided in the later sections.