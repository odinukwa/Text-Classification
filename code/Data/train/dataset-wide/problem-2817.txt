Here's my solution The main reason yours is so slow is that it's reading the HG38 file line by line, which means it has to upper case each line and append it to the sequence up to 4 million times per sequence That's very slow because the repeated appending will mean that the string will frequently become too big for the space allocated to it, and it has to be copied to a larger space before it can be expanded. Copying such a huge string thousands of times takes a lot of processor work I have written it so that a whole chromosome is read at a cctime. Then all that has to be done is to remove the newlines and set it to upper case, just once I've also printed the each chromosome's name when it is encountered, to give some confirmation that the process is progressing. (You can stop this by removing the statement.) The time taken to test the introns at the end is minimal As I said, this code produces the results 492784 /499504 that you expect, but I'm still concerned about the end pair of bases. Please let me know if you have an explanation 

I also created extra variables to hold options objects, to enhance readability, and I added comments to describe the intent and parameters of functions declared. Note that trainingDiary is now declared in the private scope as well. If you need to access it in the global scope, you will need to export it to the global object by assigning it to global this or window: 

You should use the JavaScript Module Pattern to create a private scope for your function declarations: 

You should think about the way you wish to handle the communication between modules. The latest trend is to abstract and decouple the communication using publish/subscribe pattern. You can find more details in The Scalable JavaScript Application Architecture presentation by Nicholas C. Zakas, and you may be interested in the open-source framework that I developed based on this approach, which I presented recently in Paris JavaScript user group. 

The confusion is probably compounded by the fact that I'm working overseas. People here speak little to no English here. Which method should I stick with? 

They essentially do the same thing. I'm thinking first one is better from the standpoint of "Write more code only if you have to" and the second one is better from readability aspect. I'd use a switch statement with default case but I'm using a old version of JDK.. so I can't use it on Strings. Which one is better? 

Without thinking twice about it, I switched to the any version because .Any() is more readable for me. But a coworker of mine sees the change and asked why I did it. I explained that this improves readability but his objection was the following: 

I have a program that seems to work and produce the same results as your own code. However I have a problem in that the intron doesn't seem to be defined properly Suppose my sequence is the alphabet and the exons we have are defined by 

I would personally choose to set up a hash that converted suffix strings to a multiplying factor instead of using a chain of statements. Like this 

Here's my Perl solution to this problem, for comparison. It simply iterates through every non-empty substring of the original and sorts the characters of each one. The hash keeps track of the count of equivalent substrings Once the counts have been established, the problem requires that the number of possible unordered pairs be calculated for each set of equivalent substrings Because all of N items may be paired with N-1 others we have N (N-1) possible pairs. But a pair like N0 N1 is the same as N1 N0, so we must divide that expression by two, so the number of possible unordered pairs of N items is N (N-1) / 2. That expression appears literally in the code below 

When you implement the API yourself, you may either create a building block on top of the scope bootstrap and other building blocks, or rewrite the function from scratch, replacing the bootstrap and all building blocks altogether. In a browser, you can load building blocks with script tags, then load your own modules: 

and last but not least, the i18n API part of the Scalable JavaScript Application framework, which I designed for Legal-Box :) 

For each dependency in the array of needs, a property of the same name is set on the context object which is provided as argument to the function: 

I'm writing a WCF service for validating password and getting company ID for the clients that requests the services. The service runs on a server locally as a windows service, which sends queries to the database and returns the appropriate info back to the client. I'd first like some comments on how the overall design looks like as I'm going to be adding more operations but wanted to avoid any situations where I have to rewrite them all just in case if I'm headed the wrong direction. I have a specific question regarding the stability of this service. In case if the operation somehow fails on the server's end, such as an exception being thrown because the server couldn't connect to a database. 

This seems like a desperate attempt to find a use for closures, and I believe your problem would be solved much more simply by making an object, perhaps even a object that lets you overload indexing Some observations: 

There is absolutely no point in asking for a code review of a translation of a non-functional program 

Now the "exon" starts at 4 and ends at 12, and starts at 16 and ends at 21, making the data look like this 

so they are and , forming an intron . The calculation in your program, and in my code that produces the same result, gives , which is fine, but , which I don't understand. It is the last character of the intron and the first character of the exon Can this be right? I have put exactly the values above into your code and mine and get the same result 

This is probably a really simple question. An embedded device I'm working with will store the device information in an xml file. In my code, I want to read this xml file and freely reference to it wherever I need to, so I made a simple helper class: 

My instant reaction: Ugh. Being a shameless fanatic of LINQ, I decided to rewrite the code using LINQ. 

I'm also wondering why multiple queries have to be made to initialize dataRetrieveModel, but for now, I only want to focus on this method. But then all those return View(dataRetrieveModel) seems too verbose, so I thought about defining a return label and using a goto. I'm not sure how others feel about it. I'd like to hear any suggestions on this matter. 

To use the function, you can write your own or build it from building blocks available in the scope or not project. The building blocks are sorted in levels. The level 1 provides the bootstrap, it must be loaded first. One building block may be picked from each level. Building blocks from lower levels are expected to be loaded first, but they are all optional. Building blocks in higher levels use the function of the bootstrap to define a replacement function "scope", declared as a module. For example: 

To clarify the use of your global variable "collection" as a namespace for your library, you should assign it directly to a value returned by your Immediately Invoked Function Expression: 

This is the original version of code written by my coworker that replaces every null cells with an empty string. 

However, I'm wondering if this code is less readable than the above version, even though it is definitely compact. In my eyes, it's definitely readable as I'm comfortable with LINQ but my coworkers have not even heard of LINQ. Which is a better change? Should I keep my LINQ version or unroll LINQ to two foreach loops? 

And then I'd just get my device id by DeviceInformation.DEVICE_ID. Same goes for type and home_id. But this approach just doesn't seem elegant. Turn the initializer into a static one? Still, I feel like there's something wrong with this whole approach and I just cannot articulate it. How can I improve this class?