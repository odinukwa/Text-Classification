to check if the proposition is logically valid (true for all possible inputs) to check if the proposition is false for all possible inputs. to check if two propositions of the same number of arguments have an identical truth value given the same inputs. 

These correspond to three questions which we could ask of any proposition which is a function of any number of propositional atoms. In case you're unfamiliar with this terminology, an 'atom' is one of the inputs to a proposition which is a function taking some number of atoms and itself evaluating to either or . Typeclass Declaration The name for the type class bears no meaning for me, so I changed it to short for "Proposition". 

Here, says that in the expression above, the type whose behaviour/implementation we're defining is the type. How do we check if a is valid? Well, it takes no arguments, so a proposition that is just or is valid if it's true, and otherwise a contradiction. 

The first thing you should realize is that in Haskell, typeclasses are basically the same thing as Java's interfaces. They define a contract of behaviour which instances of the class must obey. In this case, the typeclass I'm calling promises the user three methods: 

I'm late to the party here, but I thought it'd be interesting to consider some more optimisation you could do. First let's consider the number of 'modulo operations' your code does per 15 integers: 

Boolean Instance Definition All we've told the compiler so far are our promises: there will be methods for checking whether an instance of is valid or a contradiction, and a method for comparing two propositions of the same type for equality. To start, we implement these procedures for the most basic type of proposition: one that is just or . 

What stands out to me is that you initially perform a check against every grade range and insert into the map in the right one. By that point, you've already found which grade is right. But then you initiate another loop to start searching for the grade corresponding to . I think instead, you ought to alter your method to output a enum, and delegate the string handling to another function. I feel that it's better practice to return a Enum from the first method because of the strong typing-- you may want to use this information for other methods besides finding the grade name. In fact, s are particularly nice because you can use a on them. 

What we're doing here is creating a new typeclass called Prop. We need the syntax because we need to define the behaviour of an instance of the class. If we don't introduce a symbol for it, then how will the compiler know what we're talking about the in the typeclass definition? For example, the line says that for every instance of typeclass , there must be a method called which maps to a boolean value. Likewise, there must be a similar method for . Now the line may cause some confusion because appears twice. It's important to understand that , being an instance of a typeclass, is a type. There are no "objects" as in object-oriented languages. Remember: is a type which satisfies the typeclass contract given by . The Java equivalent would be a class implementing an interface . What we're saying here is that for type which implements/is a part of this typeclass , there is a method called of comparing them. And its type is meaning that it takes in two expressions of type and returns a boolean indicating whether or not they're equivalent. 

Regarding Initialization Initialize methods is a pit of failure as it requires the caller to keep track of if it has been called or not. If possible you should always aim for that an instance is good to go after the constructor. If initialization is needed any way you can perhaps use this pattern: 

Regarding Singleton Try to use the IoC-container for singletons. It makes it easier to test and makes references explicit. Avoid doing all over the place. Note that a class can still be implemented as a singleton but consumed via the container. 

Putting the as single child of the grid is wasteful. Add to the grid. As a rule of thumb is almost never right. After writing WPF for a couple of years you will probably find yourself using ~95% of the time. Grid is a bit verbose but it is the panel you will not have to refactor away from. Also Grid makes reasoning about layout simpler. You can try this to bring down the verbosity a bit. You can add BindsTwoWayByDefault to EightPieceBoard.Selection but I don't mind being expliclit about it. The viewmodel should not know about the view: it makes testing harder and is smelly in general. Not a clean separation of responsibilites between view & viewmodel. 

Nice and declarative, you see what the code does at a glance. And you can compose with , , , etc. as you need. 

Ending here, really nice code, not much of a review. As with all things related to performance, profile first and profile after if you decide to optimize. 

LINQ does not add much imo, if the logic was more complicated the for loops are nicer to debug. One downside with LINQ for this is that it requires formatting to be readable. If you rename things the formatting needs to be maintained. With the foreach loops you get formatting for free. Edit: As per @RobH's suggestion: 

returns an instance that only has one method The method returns the same instance but as that exposes the 

As is a singleton it should be thread safe. ConcurrentDictionary is a nice fit for this. Using the code would look like this: 

In my experience there is rarely a need for delayed invokes on the dispatcher, what problem are you solving? If you do something in a constructor that you want deferred until loaded there is already an overload for that: 

Nothing wrong with your code. If you want you can use linq if performance is not critical. PseudoCode: 

Starting a task and the immediately block () is a huge antipattern. All the downsides and no benefit, the calling thread is freezing your UI now. Also there is overhead in creating running a task so it will block even longer. By doing this you open up the door for deadlocks and race conditions, all kinds of pain. When you start a task prefer it is shorter and you can't forget to call Start(). Normally you don't want to start a task to block for IO. If you use a task you should do all the way. 

I would probably not have this as an extension method as it doesn't mean any real reuse of code. For cancellation you can use this: 

EBCDIC is a myth made up to scare children during holidays, so here is the ASCII-dependent version, as suggested in a comment by JPhi1618. The main imrovement is to efficiency, by avoiding std::string::find, which is probably implemented as a linear search. Unicode is not a myth, unfortunately, so don't ever try encrypting the string "Zurück". 

Your code includes the optimization of evaluating only odd-valued candidates (by iterating with a step size of 2) because the even-valued candidates are known to contain a factor of 2, and are therefore always composite. This candidate-skipping optimization can be generalized to include prime factors greater than 2, by varying the step size in a certain way. I made a version of your code which skips candidates (values of ) containing factors of 2 and/or 3. This is done fairly cheaply by alternating step size between 2 and 4. Extending this optimization to even greater primes gives diminishing returns for two reasons: The step size adjustment calculation becomes more complex (and slower), eventually costing more time than what is saved by skipping candidates; and higher prime factors exist more sparsely than low ones in the candidate population. Skipping 2 alone catches 1/2 of the composite candidates, and skipping 3 alone would catch 1/3. But if used together, half of the composites 3 would skip were already skipped by the 2 skip, so skipping 3 just catches an additional 1/6 of the composite candidates. Including a 5 skip would only eliminate an additional 1/30 of the composite candidates, and a 7 skip 1/210. I experimented with replacing the floating-point call with an integer approximation, but it turns out that is very fast (at least on my machine). And then I gave up entirely after seeing Vedran Šego's optimization, which is brilliant, especially because as gets bigger, the gaps between calls to become larger, to the point where it doesn't really matter much how slow your calculation is. So, I had to add this to my example, thank you Vedran Šego. One other thing, the loop must terminate. If is signed (like ), it will overflow and wrap around to a negative value. This is a completely pathological situation -- calling with a negative number, plus other things, depedning on optimizations employed. Even for unsigned , duplicate primes will be added to the vector until the process crashes when it runs out of memory. So my example terminates before overflows. I also defined a type, to make it easy to switch the integer type used for calculating and storing primes. I use in my example, because it gives results a larger maximum value at no extra cost compared to . Try if you really want to see the program continue for much longer than you will be willing to wait. 

Unsigned subtraction (and automatic mod 2^32) will always give , even when , and as long as the actual elapsed time doesn't overflow the tick count (it isn't greater than 49 days). So you could replace the original with the following code: 

Here's a version of your code which works with C-Strings by using to turn any array arguments into pointers. This also uses perfect forwarding in the recursion, to preserve argument types, just in case unconditional conversion to a const reference is inappropriate. I'm making this Community Wiki, because it's more of an answer to your question about C-Strings, rather than a code review (ok, little review: is usually so poorly implemented, you should use something from , like , otherwise, thumbs up!).