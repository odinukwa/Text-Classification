OK, thought I might get a quick win if you were using a version of Access old enough to be using the Jet engine (in that case DAO is inherently much faster). First thing: Don't go down the road of your "Logic 2". The fact that you realized you have to escape any quotes in the input file should be a great reminder as to why using parameters is good practice - it sanitizes input and avoids SQL injection. Second, and this is the main one. You are looping over code that should always execute with the same results. Pull these out of you loop so you only do them once: 

OK, I'll make a couple of assumptions here. First is that you are mainly looking for changes to individual cells or only changes in a specific row. The reason I am making that assumption is that if it isn't true, you aren't handling the cases where changes occur in multiple months at the same time. Remember, the Target object that you get as a parameter to Worksheet_Change is a Range - not a Row or a Cell. When you call Target.Row, it returns the top row in the passed Range making no guarantees that only 1 Row was altered. A good way to check to see if your final code handles this robustly is to select a 5x5 or 10x10 array of cells and clear them. Does this give you the desire behavior? If not, you may have to re-think your approach to the problem. Now, going on the assumption that you only care about single cell or single row edits, you need to test for that in your code. My general rule is to always try to resolve a Range into something more useful. The .Offset method is typically asking for trouble, as it gives a value that is relative to the Range as opposed to having a hard location on the Worksheet. You can always get your location on the Worksheet from a Range by getting the Row and Column of the upper-left most Cell: 

Header: The and enumerations are used as flags. values can't be combined, so they are a straight up . There's probably some room for criticism here... 

Brass tacks time - let's see how much overhead this wrapper really adds. This is the called routine: 

That is just all kinds of wrong (and it would look even more wrong if you explicitly declared the return type as the that it is). First, your backing field type doesn't match the publicly declared type. Second, you're using a as if it was a . And third, there is no reason for the backing field to be a . The only place where it is used is in the property, so that means you're continually coercing it back and forth, but never use it as a . It also leads to code like this... 

...you can get rid of the Else clause. In fact since you set bln to True immediately before checking to see if it's True, you can get rid of the If also. On this one... 

There are a couple places in your code where you've "de-optimized". I'm not sure which of these adds up to a hour of run-time, but these are the most egregious: 

is not free. In fact it's the complete opposite. It yields the processor to every other thread that needs to clear it's event queue. It also makes absolutely no sense to call when you've explicitly disabled 95% of the functionality that would make the call useful. 

Unless you are adding values to column (j), why are you comparing in both directions? If a value is duplicated between the two columns, it obviously is going to be in A after you add it in (j)... I'd try something like this (pseudo-code): 

First, I'd like to echo @Mat'sMug's distaste for your multi-lined statements. There's absolutely no reason to do this at all having them prefixed with makes it completely obvious that I'm looking at a declaration block. It took me a good minute to realize that it wasn't a continuation of declaration, because the literally disappears into a huge wall of code. You aren't saving any time typing it either - last time I checked, and were both 3 characters, and the former is a lot easier to type on a qwerty keyboard. 

...before passing it (as a ) to , where it gets used as a of subtype again: . (Whew!). Put the... wait for it... strong typing back in. 

A class can be thought of as a structure with additional functionality, but I wouldn't take that literally. I find it much more simple and more readable to just create independent backing variables to use: 

Now that we have code to review - the first issue that I see is that you are not comparing identical source code, and that makes it impossible to get an accurate benchmark. The problem is likely this line in the VB source that isn't in the C# source: 

If you don't (for example if you're only testing it once), you can simply omit the variable declaration and test the return value directly: 

Blocks - Use them. They aren't just a convenient way to avoid typing the variable name repeatedly - they hold a reference. This means that the VBA runtime doesn't have to resolve them repeatedly. That makes a big difference. Wrap the largest section that you can (I'd probably do the whole loop) and wrap it with the object you use the most: 

Fourth - Get into the habit of declaring the scope of your Subs and Functions to make sure that you are only exposing the ones that you intend to. If you leave these off, they will default to public and start showing up in your function list in the Workbook and be available for auto-complete. If it isn't something you would want to show up in a cell, i.e. , declare it as . Finally - Declare your function return types. It isn't clear what the code below returns, and the comment makes it worse - it doesn't return a at all, it returns a . 

The version took 17 seconds over 10,000 calls. The version clocked in at 28 minutes. Moral of the story is that Excel allows you to open XML files merely as a convenience - it is not intended to be an efficient way of retrieving values from them. Always best to use the right tools for the job. 

The other answers hint around the performance, but I'll just come right out and say it. Your should really be named the . First, every single call that makes is late bound - even for Excel objects. It has to be, because like , it is forced to call on itself. This is always slower than an early bound call - period, end of discussion. 

Third (on a related note), you should use the explicitly when you're checking for it's members. This... 

This is the first of (hopefully) several posts as I reimplement an ancient (and unfortunately long lost) Excel VBA Tetris clone. The main workhorse class in the game engine is the display driver, which uses a rectangular area of a Worksheet to emulate a monitor. The display is sprite based, so the class holds a Dictionary loaded with IDrawables, which are basically bitmaps. The interface is as follows: 

@Mat'sMug covers the procedure as written very well, although I'd add that using the function to determine whether a cell has something in it is problematic. The function is actually not testing whether a cell is "empty" - it is testing whether the passed is equal to : 

The identifier is a bit confusing at first glance, as is . I realize that they're just loop counters\temp value holders, but the comments that explain that are a long trip with the mouse wheel up to the top of the procedure. If you want to use a short throw-away loop counter, I'd suggest using instead - it's pretty generally recognized as shorthand for "index". There's also nothing wrong with something explicit as to what it is like or . 

Properties: I'm not sure if I like the "flag" properties as and . , , and might be better. Opinions are obviously welcome. is read only because it is intended to only be set by the passed parameter to (and is probably misnamed - again, suggestions are welcome). 

You need to remember to dispose of your FileStream and StreamReader if you are accessing them this way. The easier and safer way to do this is with the using syntax, which will close and dispose of them at the ending braces. I'd get into the habit of using this with any object with a .Dispose() method. 

Your code calls it 4 times every time you add a sheet. You actually don't even need it in the loop at all, because if you don't end up with worksheets after you call , then there is something very seriously wrong (this is a problem in the original code too). Cache values that you need to reuse. 

That leads to another readability issue. In a procedure this long, declaring everything in a block at the top of the procedure makes it more difficult to keep track of what everything is, especially when you're using identifiers like . It's usually more readable to declare a variable immediately before you use it the first time. 

Finally, there's a helper function that formats the output. This could be pretty much anything - in this case it's a comma delimited string of 1 based character indexes (that was the convenient output for the original calling code): 

...has implicitly (again, the Hungarian notation lulls you into missing the fact that just because the identifier starts with , it's not a ). 

They're also a potential bug source because they are resolved at runtime for late bound objects (which is the same reason you take a performance hit). That means that if you have a typo in the name (i.e. ), it won't be caught by the compiler. It is also dependant on how the typelib is defined for the class. For example it's possible for some late bound objects to introduce errors by specifying the same variable name multiple times. Excel seems to be prone to this type of error: 

I would personally change the name to something like (Pascal case for namespace identifiers) and the two options to and . This will be much less likely to create collisions. Note that and are also really common local loop counter variables. If they're public enumeration member, they pollute the global namespace and can create bizarre\misleading compile errors: 

Since the previous posts covered most of the structural issues (VB6 data structures v .NET, enumerating the payment modes, etc.), I'll address the remaining elephant in the room here. Looping through dates like this is similar to counting on your fingers to find out how many fingers you have on your hands. Nobody would even consider (or maybe "should" is the better word) doing this with a numeric type: 

Not only is the much clearer as to the intent of the code, it also prevents it from breaking if you decide to or need to change the values of the members. It also makes the code document itself, so you don't have to sprinkle comments like this around: 

Note that you can also re-use the objects immediately after you grab a reference instead of calling 3 times. 

What does is hold an object reference to avoid having to dereference it multiple times. If you only use it once, it's reduced to 2 extra lines of code and 1 extra indentation level. That said, the place where it is appropriate is with your , and it isn't used there. This is much better: 

While this admittedly suffers in readability, it slays in performance. Don't take this as an indictment of your code (which is well thought out and written) as much as a warning against trying to beat Excel at its own game with VBA. 

I think the answer to you question mainly lies in the level of faith you have in your statement that "this particular application will likely not change or add functionality at any time." In my experience, its only a matter of time before somebody asks "wouldn't it be nice if..." or the business requirements that drive the application change. That said, it doesn't look like there is a lot of immediate gain in decoupling this much further at this point. There may be in the future, but if it does the job right now the addition effort in refactoring might be a little bit premature. I would ask yourself how many use cases there conceivably are at this point - if this is basically just a one-off office automation type project I'm guessing there aren't that many right now. That said, what has bitten me on projects like this in the past are "simple" changes that are easy to implement but require the source to be recompiled and redeployed. This makes the following code section leap out: 

Since your offsets are all fixed (and you have a reference to the worksheet), you can skip some overhead by using direct cell addresses. For example, can be replaced with . The only that you use for anything other than its value is . So... you should probably be pulling the 's into variables instead of the 's. For example, in this section of code it's possible to request 3 times. 

Default Instancing Don't do this unless you have a really good reason to, and I don't mean "not typing a separate assignment" by "good reason": 

Taken in conjunction with the item above, the function declaration should really be something like this: 

The first call to returns the sheet that was added. You can ditch the call to to pick it up, and avoid the need to find it the second time in the collection by simply doing this: 

Third - Using Range addressing or is not only harder to read, it is less efficient as well. Not only do you have to concatenate strings in order to build the addresses, Excel just has to convert them back into numeric indexes. Unless you have a really good reason not to do so, using is almost always better and is much easier to use in loops. 

That's 5000 * 5000 iterations for the outer 2 loops and 5000 * 5000 for the inner 2 loops. Lets be really conservative and say that the optional inner loops run for only 10% of all cases due to your condition. That's (25m) * (2.5m), or 62,500,000,000,000 iterations. Now let's be really optimistic and say that Excel can do a million of those per second (it can't). Using those assumptions, your first nested loop structure should finish sometime in early 2019. If each of the 3 sheets has 30k records, we're looking at somewhere in the neighborhood of 2500 years for it to complete. The next 3 nested looping structures are similar, but hardly relevant as by the time you reach that code the chances of an equipment failure, forced restart, etc. will be trending toward 100%.