I like this interface, but the only variation, except from the text, are the buttons. Why not abstract the usage instead of copying the actual interface? Like: 

The interface I don't mind the IDisposable. If one implementation is designed that way and you retrieve it from the same factory as the other implementations, you really don't have a choice: 

-property is ugly. A return value from is better, an exception is best. The code should not be allowed to continue running when something fails. The dependency on is not good, but allowing a custom type isn't any better for the same reasons. I think a should be defined in the same package and namespace as the interface. Then the return type. Looks like someone declared a defeat right there. Why bother with the interface at all when you decide to go typeless? The implementation The destructor calls , which means is , which then causes the method to return immediately. You can delete the destructor, it's a nop. Or a bug. Someone obviously tried to follow best practice and failed. The reflection code used to create the repository looks like a poor man's DI container. Nothing wrong in that, if this is the only place you need this kind of functionality. But if there is a 'real' DI container in there somewhere, I suggest a refactoring. The caching is probably introduced because reflection is 'slow'. But slow according to what? My guess is it's negligible compared to the actual repository usage. I would remove the cache unless someone actually profiled the code and can prove a significant improvement. If all repositories have the same shape, then may be replaced by a generic interface. But if they don't, I can't see any way to unify them. If that's the case, I suggest replacing the generic with typed versions, like: 

You can then delete and (but make sure you set your initial state in the watch constructor). Finally, and this is just advice for C code in general, I would consolidate all the functions that really form one module into one .c file, define the private types inside that, and only expose the public facing types, perhaps as abstract structs, in a corresponding header. In this case I would expect you to have , and that exports only the constructor, , the methods , , and (each of which I would rename according to the theme), and the destructor . You would also need to expose the abstract type , but not the internal definition. My header would look like: 

SQL Injection Multiple parameters can be used for SQL injections: , (the first entry), and . You could use a whitelist to filter the input, filter out all non-alphanum characters, or properly document that there is no security in place for these parameters. You might argue that those parameters aren't supposed to be user supplied anyways. But such a generic method as this needs to be secure because it can be used in so many different ways, and especially the or possibly values may be user supplied in the future (I wouldn't worry too much about , as there are likely other problems than SQL injection if it is user supplied, but it is still a good idea to secure it as well). Usage 

Looking at the State Pattern on Wikipedia I'd say it's more normal to replace the entire function table at once, rather than write individual function pointers. To this end, I would do this: 

If I understand correctly, you wish to maintain a list of places, and record only the shortest route to each place. This means that each time you need to find any duplicate entry, and choose which to keep. For this task, an unordered list is pretty much the worst choice you could use. Your algorithm is O(n2) (that is, O(n) for adding each of elements), and while that isn't important for 10 destinations, it's pretty critical for 3 million! Given that ordering is not critical here, a hash table is really the correct implementation to use. This will get you O(1) insert and lookup, and the added programming complexity and memory use is appropriate for that number of elements. If that's not possible somehow, then second best would be some kind of self-balancing tree. Finally, it makes no sense to count the length of a large list by iterating the elements. Just increment a counter every time you add an element. A reduction from O(n) to O(1). (In theory, if you add and destroy a lot of elements very frequently, but only query the size once in a blue moon, then my statement is untrue, but I doubt that's the case here.) As far as your existing implementation goes, it's a bad plan to create the new node and then not use it. Maybe in your implementation a garbage collector will sort it out, but otherwise it'll be a huge memory leak, not to mention wasted effort. 

Last Loop You have two conditions that only apply in the last loop. I would pull those out to after the loop: 

This is vulnerable to reflected XSS, with which an attacker could execute arbitrary Javascript on a victims computer (and thus steal cookies, deface the website, display a phishing form, etc). Use to prevent this (same with ). Functions Your code isn't all that long, but for 150 lines, I would extract some code to functions to structure it. For example, and , and . I would also add a function to avoid duplicate code: 

Then there's no longer need for the reflection stuff, as each method knows which one to create. A suggestion: Change abstraction level It looks like the entity type used by DbContext is the domain class. That gives the following dependency: 

Do not reuse variables or change their meaning. The variable is used in at least three different contexts, which will probably mess up the do-loop. Use different variables for different things and name them accordingly. The variable could be replaced with , and . The price is built up of six components: 

Generally with ifs, you should try to handle the shortest case (the one with the fewest lines) first. When doing validation, it's also always good to handle the negative case first. Depending on the exact context and framework, different solutions may be even more sensible. 

So each field is separated by 3 from it's vertical neighbor, by 4 from it's diagonal neighbor, and by one from its horizontal neighbor. So your code might look something like this: 

However, if you have a big program, with a lot of states, each requiring a non-trivial amount of code, it would make sense to have one .c file for each state. Even then though, I would endeavour to present only one abstract header to the external callers. 

If is a unchanging list that really is as short as you show then you should just hard-code the strings into the code (or use a macro, or declare them (make sure they're const pointers as well as pointers to const)). That way the compiler can optimise the calls away to almost nothing; short strings like you show might even be done via a numeric comparison (a four byte string is the same length as a number), but don't do it manually - let the compiler sort that out. The key point is that the compiler cannot optimize this to the maximum if it can't prove that is constant. If is unchanging, but much larger than shown, then you should use "perfect hashing". There is a tool called that, given a list of names, will generate C code to do the lookup in an optimal way. If can change at run-time and is small then you're probably just about optimal already. If can change at run-time, but can be very large then a hash table is the best option. Failing that a sorted, balanced tree would be better than a list. 

Security I'm assuming this is for educational purposes. Otherwise, don't roll your own, use bcrypt. From a quick look at it, it seems that the core of your algorithm basically boils down to this: 

Yes, you are wrong about that. and are 100% user controlled and not limited by your frontend (be it JavaScript, HTML, or something else). 

is a more fitting function, as you want to see if the string matches certain characters, and this also gets rid of the nested if structure. Personally, I would prefer a whitelist check on here. Misc 

EF does that for you, and I guess NH does that as well. In the end you are abstracting away the call to . But if you need something on top of these, I would suggest a few changes. Simpler usage 

I would not complain if you choose to keep the code as it is. It's readable and focused, except for the helper methods which you have already identified. But we know that code is never finished, and there are always opportunities for improvements. So here are my nitpicks: In You have a parameter selection, yet you pass that to . Do you have a selection or not? If you have one, why do you need to find it? If you need to find it, then it isn't really a selection, is it? I don't want all these questions when I read code. My mind gets overloaded pretty quickly. And it shouldn't be necessary to look into all the members just to verify if they do what they say. returns a . I think would be a better name. In is called before , yet I have to scroll pretty far down to find while is the very first I see. I would like to see listed first. 

is deprecated, and has been for quite some time. however is not, and it does offer mysqli_real_escape_string. Still, prepared statements are the way to go. The good news is that you use prepared statements, and use them correctly, so you are defending against SQL injection exactly as you should be. Your additional Filters That being said, your additional filters are not helping, and are in fact adding a false sense of additional security: