You don't need to convert an object pointer to , a is sufficient for that. Don't use stronger casts than necessary. You can simplify the assignment to and make it more obvious by assigning the result of the placement-new into it: 

When you do this, you must then not mix C++ I/O (IO streams) with C I/O ( and friends) in your program, but mixing these is bad practice anyway. Here are some other comments to your code: 

This type of information must go into comments. The next maintainer (which can be you in 6 moths' time) will need knowledge like this to understand the code. You should add specifications to your functions. They affect efficiency of some operations (like storing in a ), and since this is a very generic class, you should not limit its use in any way. An example for the assignment operator would be: 

When printing this message, you should consider returning 1 (or ) from , instead of allowing fallback to the default success. The outer could be removed. If the file is not open, will fail, and you would at least print an error message instead of failing silently. is a very non-portable and extremely cumbersome solution looking for a problem. You're calling an external program just to wait for a key press. You should get rid of it altogether: your program is not interactive at all, it could run just fine as part of a script. Requesting input like this ruins that. Just drop that line altogether. 

How could these be improved? Because they are both Standard Devation calculators, should I combine them into one method with a header of ? Are they an optimal solution for the problem? 

Any and all comments welcome. If you see something that I can improve, or that I am not doing something the idiomatic F# way, please let me know. 

If you enter an invalid number for your values, your program breaks. To prevent this, you could check your input like this: 

This lets browsers know which version of HTML you are using. This is the current version, which you should be using. Second, you should enclose your entire HTML in a element. Third, you need to have a element with a element. The element is the page title that appears on tabs. You can also link external files, like CSS and JS files, here, as well as specify which character set you are using, typically UTF-8: 

Use more vertical whitespace (newlines); your code is hard to read because I can't see which parts are logical blocks. Optimized code doesn't need to be (and shouldn't be) hard to read--leave that for obfuscated code. 

Please tell me the good, bad, and awful so I do, don't, and don't do the same in my next venture into VB land. 

You have one letter variable names scattered around your code: . Please change this to be more descriptive. 

The same holds for all other uses of C I/O (, ), of course. and would be better declared with type , as they represent the number of some objects. If you have access to C++11, all the above could be simplified even further using range-based loops, lambdas in standard algorithms, or at the very least iterator-based loops. I didn't bother with iterators here (even though they could be used), because their type has to be spelled out explicitly. In such case, it would also make more sense not to allocate the threads dynamically, but create them directly in the vector. No need for manual deallocation, no dynamic allocation overhead. 

You're overdoing it with comments. A lot. And trivial ones at that. Every programmer knows that creates a vector of pointers to , or that you have to use with pointers. Such comments are really just clutter and actually make the code harder to read. Save them for the non-obvious bits. It's unclear what protects. Does it protect ? Or ? Or both? This is one of the places where you should comment, but you didn't ( is absolutely pointless). If possible, rename the mutex to match its purpose. It would also be a good idea to wrap the mutex and the data it protects in a class, to ensure that unsafe access is impossible. requires the reader to parse it (and what's with the double parentheses?) The meaning of , on the other hand, is immediately obvious. And how does it create 4 threads? You could just as well rewrite the entire loop to make it more concise (and perhaps more efficient too): 

Your indentation, spacing, and naming are excellent, although I prefer a 4-space indent over a 2-space indent. I do not know CoffeeScript or JavaScript, so I cannot make any more comments. 

I have this set up with a very basic algorithm for the computer to play (random-selection, hence the title--you'd have pretty bad luck to be fully sunk). Next, my plan is to create a interface with two classes implementing it ( and ). This will help clean some of the muddle of the module up, and will make it easier to implement a better algorithm for the computer, and may make it easier to let the user choose to play the computer or another person. Some of my specific concerns about this is that I may have implemented this in either a too-C# or too-OOP manner. I'm not really familiar with functional programming or F#, so feel free to comment on anything that should be done differently. 

You have no extra spacing between functions except before the function, which has several returns. I would put a single return between each function to make it clear where they begin and end without even looking. 

Also, you should use proper indentation to help you read and understand your code better, which will help prevent bugs. This doesn't do anything: 

Why not create a method for this and pass the necessary values? You would have to pass several values, so this might be a pain, but it would have less repetition than this way. 

The class is missing a copy constructor and a move constructor. These can never be created by instantiating a template. Right now, the compiler will generate a defaulted copy constructor for you (and no move constructor, because you have a user-defined destructor). Since you obviously don't want that, you have to define the copy (and probably move as well) constructor yourself. You're also missing a move assignment operator which you should probably add. Otherwise, your class wouldn't be fully usable with move-only types. Your code is missing comments (there aren't any). You even had to explain an invariant in the question: 

The names and don't say anything about the variables' use. I had to read through most of your code to figure out what means. Always use descriptive names for your variables, at least for those whose value is supposed to persist for extended periods of time. I would be willing to accept the , as it is basically one-shot, but should be renamed at least to or or something more descriptive. Your looping and termination logic seems odd. You are using the correct construct , looping while there's valid input left. But then you have this block: 

Also note that I added a call to into the waiting loop. Your previous code was leaking the threads. You're writing C++. Don't use (type unsafe!) C I/O. Do this instead: 

As it is, the first line is utterly useless. Additionally, this only works because your methods are all static. Keeping track of your instances is important because what happens when you have two restaurants? You need to know which restaurant is controlled by which class instance so you can manage them appropriately. 

We were discussing Standard Deviations in chat, so I decided to write a standard deviation calculator: 

This review is primarily to make sure I am using Unity right. Please tell me everything that can be improved. 

First, split your methods up into smaller units. For example, should have this general structure (and PascalCase naming): 

Don't use regions, just organize your files nicely, and you'll know where to find things. I like fields at the top, then ctors, properties, and methods. 

and are tuples (similar to immutable arrays) like . Is this a good implementation? Would this be a slow implementation, or is it reasonable? The rest of the code (with Checkmate and the AI incomplete) can be found at Github. 

Your naming is bad here too. What are and ? Also, please be consistent in your use of , , and more. Use in cases like , where the type is easily determinable. Use the explicit type name when it is not easily determinable (or only when the compiler cannot determine the type). 

Those names don't tell me what the variable does or is used for. Using a longer, more descriptive name won't affect performance, and will make debugging and maintaining the code easier. 

Here's the first functional version of my Python 2 script for processing comments in C++ source files. It's a personal project, I expect to expand it later with more advanced options (mainly about replacing comments with whitespace or marking their original positions in the comment-only output). It's also intended as a learning excercise. I am self-learned in Python, my primary language is C++. So the core of my question is whether the code is "Pythonic" and if not, how to improve on that. I don't want to "write C++ with a different syntax," I want to (learn to) write proper Python. I will of course also welcome any other comments (general style, efficiency, safety). 

One thing I am aware of is that the code does not handle trigraphs; they are somewhere near the end of the to-do list. 

This will cause the loop to terminate when a 0 is entered in the input. This behaviour does no match the assignment, and hence it represents a bug. Based on the assignment, you should only terminate when input ends, which will be correctly caught by the loop. The line should therefore be removed. Related, your after-loop test for is incorrect. If the loop is (correctly) terminated by being unable to read more numbers because the file has ended, both and will be set on . The condition will therefore fail. You might want to augment the condition to check for EOF: 

This will make your user enter a value until a valid entry is entered. However, this will only work when the value entered is in the form , where is an integer and is a non-integer value. If the user enters , , or it will only input the part and leave the other part in the stream. To validate against these values, you can test the input more rigorously: 

The constructor takes the character set to be used and a beginning and ending range of passwords. For now, it assumes both passwords are the same length, which is useful for when you know the number of characters in the password. iterates over the range of passwords, and returns the password when found. If the password is not found, it returns . will calculate the next password in a manner similar to addition in base-N math. will return the current password, stored as an array of s, as a string. I generate my tasks like this, leaving Windows to manage the threads. Based on watching it in debug mode, it does create several threads, but not 95: 

There are a few things you can improve here. Unless all your classes are in separate files, you do not need to do around each class. This is most unnecessary: 

Don't store information in strings. What happens if you want to check this value and type ? Or what about ? Those checks will both fail. Create an enum with these values. 

As far as performance is concerned, there are no problems in this code. It's using C++ streams in the idiomatic way, which is good. If you're experiencing performance issues, you could try detaching from C streams at the start of your program: 

Indentation in the post-loop conditional is inconsistent with the rest of the program, and should be fixed. The same holds for the block (unless that was just screw-up of the code formatter here on Stack Exchange). The return value of is interpreted by the operating system as the return code of the program. On all OSes I know, 0 indicates success, non-zero indicates failure. You should therefore return 0 on successful program termination. Or just omit the altogether, is implied in the function in C++. Or, if you want to be really beyond reproach, and comaptible even with OSes where 0 does not necessarily mean success, you can change it to ; this requires . Error output (such as your message) should be sent to (standard error stream, usually file descriptor 2), not to (standard output stream, usually file descriptor 1). A more helpful error message would be in order as well. Something like 

looks like a rather arbitrary number for the default template argument for (it's actually a magic number). There is even no guarantee that 16 is a valid alignment value. I would probably choose something less arbitrary such as . There is no reason to use for the type of . You don't actually care about alignment of at all (which is emphasised by you passing to its parameter). All you need is a buffer of suitable size, and for this (or a ) would work just as well. As a side note, be aware that was only introduced in C++14. Visual Studio 2013 supports some C++14 bits, but using it makes your code non-C++11-compliant. You might want to swap the order of the data members, it might prevent need for padding between an oddly-sized and aligned . You might consider overloading the pointer operators and for your class as syntactic sugar for , it simplifies usage. Other generic classes which store a single object sometimes do so as well; an example is .