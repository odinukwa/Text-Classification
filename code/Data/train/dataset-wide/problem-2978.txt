... HLSL has an intrinsic function called "lit" that you can read more about here... $URL$ Basically you hand it a sun luminence dot (NDotL ... dot ( normal, light)), a specular reflection dot (NDotH ... dot ( normal, halfway)) and a specular pow value (your materialPower) it does all the pow, saturate, etc.. basically creates your float specular luminence to * by your float3 specularLightIntensity. While you still have to calculate the dots in the shader, you'd use the lit function, b/c it replaces the pow,saturate,etc you have with a built-in function doing it more efficiently then you coding it in the shader yourself. I would also change this stuff around... 

I think that's how you tie two different registers to one global. Might want to double check MSDN HLSL reference to be sure, though. With your xy multiplier now a float 2, you can change this... 

You save yourself having to cast another float2 (for the x & y math operations), and you leverage .xy per-component math which is faster then doing it each separately. In your pixel shader... 

... that way you declare 1 float4 return value, and do the math for .rgb and .a separately. B/c as you're doing it in your initial way, you're wasting calculations a) generating a float alphaChannel var that never gets used, b) calculating color.rgba when you just replace color.a in the return anyways (by re-calculating alphaChannel), c) you're casting another float4 in your return, and inefficiently comma-delim'ing your color.r, color.g, color.b values when you can just color.rgb them together. The idea is to reduce the number of variables casts you make... so while you can "float4 ( somevalue.r, somevalue.g, somevalue.b, somevalue.a )"... if you're already creating a return value, then just use it as the return value instead of recasting it. Sometimes your return value you're dealing with may just be a float3, eg: if you're only pulling the rgb of a texture, working with it, and the alpha .a will always be 1. Even then.. just cast a float4 from the start, do all your work with the .rgb float3 parts of it, and then set the .a part of it to 1 and return it... eg: 

Late response to this, but all I can suggest is leveraging the per-component math of HLSL better in your shaders... Vertex Shader 

You create a single float4, and then just work with it's .rgb through the shader, but return the float4 whole at the end. You can do this in other places, too... often people will pack HLSL vars full.. eg: they'll take 2 float4's and use the .rgb parts for colors and then pack a float2 in the .a alphas of them... eg: 

You use semicolons inconsistently. I would prefer to always use semicolons at the end of a statement. vs. : You should use , whenever you don't intend to reassign the given variable, which is almost always the case - except concatenations and declaration before assignment. implicit return types (e.g. in ) are not very helpful. If you make the return type explicit, i.e. , the compiler will enforce all code paths to return a value, which helps to reduce programming errors. implicit parameter types: the method does not specify the parameter type explicitly, but rather implicitly by naming the parameter . Use instead and two things are resolved at the same time: First your parameter type is specified, and second, your parameter name is way more relevant in the context of the usage of this method. This is a problem that occurs more often in your code, also with variables. could be defined as and could be . You could also make the member variable types explicit. should be using methods for methods that don't need to be accessible from the outside. In your code all of 's methods, except could be private. unused code: You call without ever using the returned element. The member variable is reset to an empty array, but never used. 

and make , or other implementations that interface. It would be okay to inject that interface into the , like instead of directly providing the word list, if you prefer. Your class is coupled to a specific document structure, i.e. the existence of an input element with the class is required. I would recommend to inject this element into the instance either when calling or when constructing the instance. One should also think about, whether logging to the browser's console is the best way of outputting information to the user of your program. 

This is quite a nice idea for a learning project. I created a jsfiddle to test your code. Initially I was not able to run your program, as there were a few minor bugs, most relevant: When you use , the context of your instance is not captured, even though you are using an arrow function. This leads to being when the event handler is executed. I fixed this, by introducing a local variable before the handler: 

This way you don't depend on the way the word list is generated to provide it to the anymore. If you want to allow the user to provide multiple sources of word lists, you could have an for this: 

I wasn't able to transpile the arrow function with direct return of the double-negated and changed it to 

If you must have an instance method to do this check then you could write this to keep your semantics: 

The problem of not all paths returning something is still here, so change the last line to . If you inline then the pattern logic can be replaced with : 

I like the second option, it is easy to read if you just reformat it a little bit (also corrected your selector and fixed the shadow in IE9): 

This is intended as a comment to the answer from @AmiramKorach; here is a reasonable way to get from the list you have to the dictionary you want (without concerning yourself about managing the dictionary details): 

Garbage collection in JavaScript (very simplified basic design ignoring tricks/special cases) Every variable in javascript can be thought of as a reference to an underlying system object. That is, in JS you have: 

Lock based concurrency in .NET is a fairly simple paradigm (compared to the other ways of ensuring thread safety in .NET). When you lock, you declare a block of code as a critical section, protected by that lock object. .NET ensures that a second piece of code in the same app domain will never be running in a critical section protected by the same lock object while one instance is. Here is a good resource for more threading information: $URL$ Pedantry When most people discuss thread safety they mean it in the same sense as saying strings are immutable. That is to say, as long as you don't do anything I shouldn't reasonably expect you might do it is safe. Unfortunately, locks aren't good enough to actually provide true thread safety (bulletproof against reflection and C# pointer code), they are good enough for most usages where you control the software stack out to the actual application. If you need to ensure thread safety in these instances you must ensure thread safety at the field level in your classes (stuff like the keyword will help you here, but watch out). Some example threads that would break your safety here: 

I felt that this code would be good as a jQuery plugin, so I went ahead and altered your code until I was satisfied. I left in some comments that are applicable to your code, but I would encourage someone else (and may do it myself still, I don't know yet) to give an actual review. 

Finally, I dislike the fact you are initializing these variables as function expressions (statements) and don't end them with semicolons (either add the semis or make them function declarations). I would also rename things to be more consistent and in line with my preferred naming conventions for javascript: