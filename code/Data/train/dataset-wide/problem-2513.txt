I don't like your intro screen. It feels like it consists of two separate screens (1 - where you try to recall your name, 2 where you clean up). As it is - it is somewhat difficult to follow the execution path. I think instead of being a protected method should be an actual screen class which accepts options as constructor parameter. That would simplify reading. I dont like the use of an observable collection, i think it is an overkill. And it exposes the methods it should not. A simple wrapper around List which only exposes and methods would be much batter. At very least - collection should not be public. should probably be a protected property of your base screen. I think is confusing. Imho you should not manipulate properties which you use as an ID. Its better to make sure that all the green bags are called "GREEN BAG" instead (by saving it to constant field, for example) In general, i do not like implementation which uses hardcoded strings. I think that proper implementation should use scripts or (if the implementation should be C#-only) XML parsing. But i guess its a bit too much work for a two-hour challenge, right? :) 

"SomeCommand" ? What is "some command"? You should use meaningful names. And you should not use domain-specific methods in otherwise domain-agnostic API. I would refactor those into extension methods. That being said, here is the API that looks alright to me: 

Why do I have to pass as parameter in order to get it? How does method returning makes any sense? What is the relation between parameter and returned , are those the same instance? You should use clearer method names and signatures to answer those questions. 

It depends on your design entirely. If classes (2) and (3) can not operate on their own, should not be instanciated and are there to serve as base classes only, then you are justified to make them abstract, and i think you should. Also, you should probably reflect your intent in class names by adding suffix to (2) and (3) (or prefix, but i think it is less common). Edit Objects with protected constructor can still be instanciated. For example, you can create them from some method in derived class. It is not a realistic use-case in most cases, but you should not leave such holes nonetheless. If you want to forbid instanciation completely, the only way to do it is to mark the class abstract. 

You are ignoring the whole point of decimals. Which is to avoid rounding errors from floating point caclulations. You must cast , , , etc. to and only then do your calculations using values. Casting at some point is unavoidable, if you have no control over signatures. You can, however, implement a wrapper, which would do the casting and expose properties. That will make your code more pretty. 

Also, constructors in class look weird. You should make those protected. Another minor thing: you have public and private members mixed together in a way, that does not make much sense. Personally, I find code easier to follow, if it has members of the same access level grouped together. But you can use any other scheme (some people like to group property with related delegate, for example), as long as it does not look random and chaotic. P.S. If I were to use this class, I would also want to have an overloaded constructor, which takes . I don't want to manually create tasks, I want you to do it for me. I'm lazy like that. :) I would also want the command to either implement or have a public method, so I can stop async operation programmatically. I mean I could call but it looks ugly. 

Yes, you can write everything in one line, but you will not be happy with the result. And no, .Net creators did not think of implementing a single call which would return exactly 23 characters of dropped file name. :) Silly them. :) Meanwhile, your code makes sense. I see only two possible issues: 

Add braces and a couple of local variables to store the new and new . The constant is still as "magic" as , imho. To avoid magic numbers, you should give the constant a name, which whould explain it's purpose or meaning (why is it and not, say, ). You should probably use when you call . There is a static method , which might be of use to you. I don't like . You should use to wait for completeion of your tasks instead of constantly polling in a loop every 1ms. Or even better, you can use loops instead and leave the details of multithreading to Microsoft experts :) 

- prefix should be redundant, as you specify target type in . a) i think in such simple cases where you have like two possible states a is superior to spawning yet another converter. b) wasnt nullable? Wont it throw an exception if ? 

The usage is fairly straightforward. You inject the service into your form's constructor (or instantiate it there if you do not care much about IoC) and store it as a field, say . Then you just wire your UI to appropriate methods. For example, if we take the API above, you can refresh the list as follows: 

As for your question - I agree with others. The cases where you might want to subscribe object to its own event are rare. If you can avoid it, then you should not do it. 

Just stick to one or the other, so reader does not have to look for deeper meaning to all this. :) is unusual in C#. You should use for constants instead: . I think you should extract constants to separate class, so you can easily serialize it later on and tweak those values without re-compilation. You can call it or something. You can move filePath and timer interval there as well. You shouldn't use nested classes to build class hierarchy. I'd say, that if nested class is larger than 50 lines - it probably deserves to be moved to dedicated file. Default encoding may vary depending on your users' environments. Since you are using a shared file, you have to specify encoding explicitly when writing and reading, to make sure that all the users are using the same encoding. does too much: it opens the stream AND it parses the entries. Split it into two methods and replace with proper return value. Nobody likes using . :) I think method is the wrong method to override. I mean writing logic does not change, its fixed: you take a bunch of entries, and you write them one by one. What changes is which entries you have to write. So instead of abstract you should have . Your class is tightly coupled with class which is a sign of bad design. should have a single responsibility: writing entries to file. It should not manage timer or update cache of parent component. IMHO, you should remove reference from constructor. 

Reduce nesting in your loop to avoid arrow code. This can be done by using // statements or by extracting logic to separate method or entity. Depending on how often you receive messages and on how much time takes, you might want to release before calling . You might want to wait for process to exit before returning form your method. This will ensure, that everything went smoothly, and there is no process left hanging somewhere due to some error in your code. If signature is not set in stone, you should probably replace strings with complex object: 

You should really do some reading on how things are done in wpf, this HTML-ish layout you are trying to create won't work. 

2) It will make more sense to use collections (such as List) to store warehouse items. I suggest you try implementing it yourself, once you are familiar with lists and arrays. 

You shouldn't name classes/methods after patterns (except when pattern name makes sense semantically, like ). does not tell me anything, about what this class does. But, say, does. Its hard to tell what method does at first glance. I mean it is called (add a verb?) but it returns ? Weird. contains what looks like two separate tests. One tests your parser, another tests . Separate them? 

I would say no. If you want to create grid-like layout, you should declare columns and rows, and specify how wpf should stretch those. For example like this: 

just to be safe. You don't need to manually the stream before disposing it. You should throw an exception, IMHO. If passing empty array does not make any sense, chances are - it's a mistake made by developer. You should not hide it. I am not a fan of passing flags all over the place. Consider using directive instead. 

I am looking for general review, but memory leaks are my main concern. I think I was careful enough with dependency properties and weak events to not leave a running timer hanging in memory for no reason, but I am not sure. If you see any issues with my code, let me know! 

It is error-prone and it allows you to store completely unrelated entities in single cache (bad idea in general). I would probably move timeout and to constructor, making class generic and, therefore, strongly typed. 

Good idea. Why don't you actually implement it? It makes sense. The same can be done to method. Right now it does at least three distinct things: 

and that's it. Why would you want to complicate things further? Do you want to avoid this extra line of code by adding an overly engineered class hierarchy of sequences? Not worth it, if you ask me. I mean, I saw people implementing method, because apparently writing: 

Say first line returns due to timeout. Which I assume means that some "jobs" are still running. How can you guarantee that disposed handle will not be accessed on background thread? check looks like a racing condition. Imagine the following scenario: 

you can get rid of , if you add property to your elements, and you can further improve it by adding meaningful exceptions when input has incorrect fromat. 

Edit. Here is implementation, just to give you some idea on what I am testing. Feel free to review it as well, however it is not complete (some trivial extension methods and helper classes are missing) and I am more interested in feedback on unit tests. 

You can use (or ) to get the missing items. I'm not very comfortable with Query syntax, but you can use w/e you like. 

You use to create a button, instead of using an actual class with custom template. Because of this you'll have to manually manage all the interactions, which are already implemented in regular (, , , their interaction with property and keyboard, etc.). So i suggest you use an actual button. Well, your storyboards are clearly copy-pasted. :) Why don't you move them to resources? 

and are all over the place in your . This looks very error-prone. You need a class that will move cursor automatically when you read a substring. Something similar to , but designed to better fit your task. Maybe: 

I agree with Dylan. Even if you are going to swap multiple sorting implementations in and out (as in strategy pattern) or reuse class in multiple places, interface still looks like an unnecessary abstraction layer, at least in its current form, where it simply wraps LINQ query. As for your code: 1) You should try to flatten dependency tree. Right now your service depends on paging, which depends on sorting, which would probably depend on filtering, etc. It results in tightly coupled, hard-to-follow code with deep call stack. 2) Your interface should do one thing, which is sorting. It probably should not have a direct access to database. Also it might be a good idea to invert dependencies, but it depends on how the rest of your code base is organized: