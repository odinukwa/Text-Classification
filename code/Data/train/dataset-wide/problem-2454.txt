Also work on your indentation. Fixing the indentation, the if-logic and the string concatenation, and I suggest that you write your HTML tags with lowercase, this can be: 

Even though doesn't provide any methods to check for divisibility directly, it does provide a method to make the into a , and as we all know, doubles do support the operator. Other slight modifications: 

Speed Improvement Currently you're saving the result of one calculation into your array, and while that's a good start you are missing out on some values you can use. Let's take the example of . The sequence is: The only result you are storing from this operation is . But you have also found out that has the value , has the value , has the value and so on... Your algorithm would increase significantly in speed if you were also storing these intermediate values. 

Even though the code for assigning strength and health to a card is not complete, it seems like you are assigning functions/abilities on one place, assigning strength/health at another place... And I'm not so sure about the methods to assign a card some abilities that you add when you create the card. It seems to me like it would be better to not call the addTaunt method but instead to assign the card taunt through the constructor. You seem to be grouping properties together instead of cards. You're defining all functions for all cards at one place, will you then define all strengths and healths for all cards at another place? It would be better to "group by card". 

The system itself I'm going to list a couple of good things and a couple of bad things with this approach: Good things: 

I had to look much further down in your code to see where/how these variables were used. The current names of these variables is not optimal. You might think that "the cool programmers" use short hard-to-understand variable names, but I'll tell you the truth: We do not. In this case and would be much better names. Additionally, to better see the usage of these variables, it is recommended to declare them as close to their usage as possible. Don't declare them at the top of your method. In fact, they are not needed at all. You can change the code that currently uses them. 

It's unclear how the is being used. It looks like a whole bunch of magic numbers to me. Consider adding a comment where you're initializing it to explain it better. 

Consider the code: That said, I think your enum is good enough to be . This is not the first time I see you use this enum. You're not copying it each time I hope? If you need to use it in several projects, create a project where you keep the common classes and then add that project as a required project to your build path. 

In this case, since these values are so tightly tied together, you could have one method to set both values: 

Some of your variable names are a bit too short and does not properly describe what they are used for: 

Static variables You have way too many variables for my taste, this will cause big problems when you have two separate instances of an object and they share the same static variables. It is good practice to avoid using static variables whenever you can (and trust me, it is more often than you think). private final All class variables ('fields') possible should be marked with , such as: 

This code does exactly the same as your previous code, it's just a different way of writing it. In my opinion, it would be foolish to try and reduce it more than this. Be happy with this one. Good job. 

Currently you keep track of a 'pageNumber' and for each item you add, you get the list with that page number. It would be better to declare the activeList on the function-scope instead of inside the scope of the for-loop. Then you can change the variable when needed, i.e. inside your statement. 

Your last block of , including the if-else that comes afterwards should be indented one step further. 

For the future, if you ever would want to support more things in your maze, you might need more than just true/false values. As such, I would add methods such as or , and use them whereever possible instead of using the directly. Then you could also handle out-of-range values inside the / methods to always count such areas as wall for example, or throw an . 

An important thing here is that once is true, it will never be set to false again thanks to the short-circuiting operator. 

Use English names for variables, especially when characters outside the range of A-Z, a-z, 0-9, _ are included (such as "ä"). The Swedish word "avgränsare" translates to "delimiter" in English. 

Android Strings Android provides a nice way of externalizing Strings in a strings.xml resource file. Using it right from the start of your project or as soon as possible is a very good idea, you might regret it later if you don't. Using XML-resources in Android is how to provide internationalization of your application. It is also good to keep all strings in one place, so you can get a nice overview of the strings shown in your application. Speaking of Strings that are showing in your application, the content of your message String for your AlertDialogs is very questionable. If I as an user would encounter the message "f*ck ya" in an application, I would never ever give it a 5 star rating on Google Play. And it honestly does not give me a good impression of you as a person either. The "ok" message is already defined as a string message in Android, and if your dialog button should only close the dialog then you can pass as the listener. So therefore you can use which greatly improves code readability. Readability Speaking of code readability... I feel that you have an excessive amount of empty lines in your code, including but not restricted to: 

Are you sure you really should use here? I think that you just need to use . Because another rect can collide with both bottom, bottom-left, and bottom-right at the same time. 

Once the constructor is finished, you're not using your String variables again, pass them on to the connect method and remove them as class fields. Only pass them on as parameters. 

Yes, that's still a tree. It just doesn't have any left nodes (it does have seven nodes left though, I didn't remove any). A child node that is bigger than its parent should be on the right, which makes this tree right. (I love the English language) As if that was not enough, your says: 

Checking if a list is not null is a bit dirty. Avoid using null when you're dealing with lists, use an empty list instead. I don't like that you are passing on a list of Strings to this method. You aren't loading from XML currently, you are doing things programmatically. So I would pass a to the method. Then, later when you are loading from XML you can check the strings in the XML and map those to actions this way. 

There we go, much better. Or an array to make it configurable As an alternative to the math operation, if you want to configure the details: 

Allowing users to create their own materials is a good idea. I like your Material interface (although I think it needs to be modified to allow for more flexibility for material types, and you should return as I mentioned...). Visitor pattern? I wouldn't call what you have here a visitor pattern. I think the most intuitive would be to specify which MaterialTypes a material should have when constructing it. In fact, you might want to have as a class instead, and the char and MaterialType array/enumset as parameters to the constructor. 

However, if you add that optional constructor; the users will have to send your code a List of size one. That's not optimal. Perhaps a class to create pagination without some previously already existing pagination would be useful? (This is actually what I expected from your code when I first saw the class name of it) A possible bug Your variable confused me a bit at first, even though it sounds like it should be equal to there is absolutely nothing that forces it to be so. What if returns a list that does not correspond to the that the class got? I can tell you what happens: Adding one extra string to the second page of your example causes it to be completely ignored for some s, and for other values of callerPageSize the first absolute index directly after is ignored. Also, if accidentally returns a list of size less that before it actually is over, then that effectively cuts the list so that the last items does not get seen. By removing the item in your example, the list always stopped at 19 for values of . Possible Solution: Throw an exception if the method returns a list of a bigger size than what was expected. Solving the problem of an incorrect smaller list is more difficult because of your optimization of smaller lists == no more items. Even though this might be by design, it is very important to document this behavior. Another possible problems might encounter when using your class is that if returns null; this causes (caused by Guava). This should either be fixed or documented. Returning null might be a way for a programmer to try and tell your code: "This page does not exist". Remember that when writing code for other people to use, they might not use it in the way that is intended.