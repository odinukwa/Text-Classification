This seems like a desperate attempt to find a use for closures, and I believe your problem would be solved much more simply by making an object, perhaps even a object that lets you overload indexing Some observations: 

Assuming this makes the arithmetic much easier, because there is no off-by-one error to account for, and the start and end of the intron are 12 and 16â€”the end of the first exon and the beginning of the next. Furthermore, numbers can be fed directly into without any offset, except that the last two characters of the intron are clearly at (6-2) I've modified my code below to take this into account, and it makes it much clearer to read 

There is absolutely no point in asking for a code review of a translation of a non-functional program 

I have altered your program, following the guidelines above. I hope you agree that it's preferable this way 

Update As usual, the solution was staring me in the face. I am confident that the values you extract to and are not character positions but offsets, that may be passed directly to . It was your comment "subtract 1 from end of exon because its 1-based index" that threw me So it is the gaps between the letters that are numbers from zero at the start of the string. Like this 

Here's my Perl solution to this problem, for comparison. It simply iterates through every non-empty substring of the original and sorts the characters of each one. The hash keeps track of the count of equivalent substrings Once the counts have been established, the problem requires that the number of possible unordered pairs be calculated for each set of equivalent substrings Because all of N items may be paired with N-1 others we have N (N-1) possible pairs. But a pair like N0 N1 is the same as N1 N0, so we must divide that expression by two, so the number of possible unordered pairs of N items is N (N-1) / 2. That expression appears literally in the code below 

This is really very open ended and is open to many forms of interpretation. The code format below is strictly the way I like to make my code legible. 

The main advantage to this is that the class can be extended easily using other design patterns such as a Facade that further simplifies the class API. It can also be added to easily with further methods within the class body itself rather than by a pure static call. The class can also be instantiated with the keyword providing the ability to create separate cache instances that utilise the same static properties and methods. I need to add this class is very much a prototype that I thought of when I saw your class above. I love cacheing stuff in general and providing standardised interfaces for it is always a great thing to do across all applications you write. 

Only functions parenthesis start on the same vertical. Objects and arrays are always indented 4 spaces beyond the function. 

I agree with Gerard a little, you have made (in my eyes) a common error with interfaces where you've tried to make them specific to a certain type rather than what they actually do, I see this a lot in the wild (excuse the pun). This isn't to say that interfaces based on type are bad, they have their place but in general an abstract would be better suited for types as types will have unique properties that you could not declare in an interface (nor would you want to). As an example I'll elaborate on the "Dog is also capable of chasing" example. Declaring a as makes no sense when trying to describe what a Dog is, instead, make it capable of doing something. 

You're jQuery can be written in one simple function as a catch all for the entire navigation. As you stated you think it could be condensed, you'd be right. As a rule of thumb if you see yourself writing the same thing over and over you should be able to cut it all down into one function. Starting with one of your methods I'll step through it to show how you can condense this and make it more efficient. 

The simplest \$O(n^2)\$ code I can think of off the top of my head stems from your code. I tried to modify it as little as possible for your reference. 

This is by not necessarily optimal, but it is easy. As for why this works, that takes a bit of math. It's late so I'll come back and edit later, but the argument boils down to being able to know all lower values will not work with any lower values or that iteration's value, when the sum is negative as that would make the sum even lower, and a similar argument for the higher values in conjunction with higher values and that iteration's value. This algorithm runs \$O(n)\$ loops of \$O(n)\$ complexity computations after a \$O(n \log n)\$ sort, making it \$O(n^2)+O(n \log n)\$ or \$O(n^2)\$. Why is the second loop linear in complexity when it has the third and fourth loops inside it? The second loop iterates \$l-m-p\$ times, where \$m\$ and \$p\$ are the number of times the third and fourth loop executes during all iterations of the second loop respectively and \$l\$ is the number of entries higher than the \$i\$th index. Thus, for each iteration of the first loop, there is a complexity of \$O(l-m-p+m+p)=O(l)\$ where \$l\$ is linearly related to the number of entries, or \$n\$, making this \$O(n)\$. Otherwise, for each second loop iteration, the number of computations will be less than some constant multiplied by the number of entries passed in. The fifth loop is linear at worst, so it would add to the linear complexity of the second loop, resulting in a linear complexity. To better show the complexity, this all can be reordered so that the exact same computation to take place by unrolling the third, fourth, and fifth loops into the loops that contain them respectively. They still are called as many times as the loops above would have, but instead of incrementing the indexes as a part of their own loop, they increment the index and skip the rest of the iteration of the containing loop. The branching in the code here is a little more digestible and orderly in software, but ultimately the same computation wise. 

Example of the chaser and chasable interfaces in action: First lets make our interfaces a little more rounded 

The logic is really confusing me, I understand how call() and apply() work in the simple example above but I have no idea how or why the prototypes of the object are extended when I call . Could anyone help me shed some light on this? 

within a class scope, the Extension object seems to extend the calling objects prototypes allowing me to bind a callback within the class scope. And then attach a handler after I have instantiated the class. 

There is nothing wrong with this approach at all. Rather than say you should or shouldn't do it any other way I'm going to give you an alternative approach that allows you to write less code in your file. I've noticed that your deals with a lot of different types of requests. This can get very hard to manage when your application grows. It's a good idea to separate out your controllers into manageable classes that deal with one area or feature of your application. The example below would ideally be in a class for example. Taking this chunk: 

It's fairly obvious what .call() is doing in context. I recently came across some articles that went into depth on abstracting the .call() function. The premise is along these lines (this code is verging on pseudo code as I have stripped it down for ease of reading) : 

Don't use jQuery to... Modify CSS unless it is absolutely required (ie CSS alone can't achieve what you want). In this case CSS can handle you're requirements easily. If you find you need to change a lot of CSS and would like this CSS to change due to a jQuery or javascript event. use and . Applying the styles in CSS rather than in jQuery. This is far more efficient in terms of code and your eyes. :) Cache your jQuery objects 

I would personally choose to set up a hash that converted suffix strings to a multiplying factor instead of using a chain of statements. Like this 

so they are and , forming an intron . The calculation in your program, and in my code that produces the same result, gives , which is fine, but , which I don't understand. It is the last character of the intron and the first character of the exon Can this be right? I have put exactly the values above into your code and mine and get the same result 

Here's my solution The main reason yours is so slow is that it's reading the HG38 file line by line, which means it has to upper case each line and append it to the sequence up to 4 million times per sequence That's very slow because the repeated appending will mean that the string will frequently become too big for the space allocated to it, and it has to be copied to a larger space before it can be expanded. Copying such a huge string thousands of times takes a lot of processor work I have written it so that a whole chromosome is read at a cctime. Then all that has to be done is to remove the newlines and set it to upper case, just once I've also printed the each chromosome's name when it is encountered, to give some confirmation that the process is progressing. (You can stop this by removing the statement.) The time taken to test the introns at the end is minimal As I said, this code produces the results 492784 /499504 that you expect, but I'm still concerned about the end pair of bases. Please let me know if you have an explanation 

Now the "exon" starts at 4 and ends at 12, and starts at 16 and ends at 21, making the data look like this 

First things first, you're creating no less than 5 jQuery objects for each time someone hovers and moves out of a menu item. Two things on this : 

There is some form of JS voodoo going on here that I can't programatically work out, can anyone help me shed light on how JS is interpreting this and why when I call: 

Going into the nuances of having a single Cat that can bark out of a set of possibly hundreds of Cat instances is beyond what you're trying to learn but I'm hoping you get the gist of where I'm going with this, behaviour as interfaces generally work better than types and give you a lot more flexibility when actually determining what your classes do. I'm making general statements a lot here, but you will see that your interfaces become very specific to actions. As such they are smaller and make more sense. I have found it much easier to have a class that implements 5 smaller interfaces than 1 or 2 monolithic interfaces due to the increased flexibility available and it keeps things DRY. 

I'm unhappy with the one jQuery call with $.extend() but this proved the easiest way to accomplish an object merge and I use jQuery quite predominantly in the majority of my projects. Despite that can anyone suggest a different way to do this? While this works fine I know it's far from perfect as it's limited to one search term. My thought was to add in another loop within but I'd prefer to avoid doing that, my second thought was to map the object and perform the lookup once I'd found an object with the first property match. Again any suggestions on how I might accomplish this whilst keeping the script clean and fast I'd really appreciate it. Any other suggestions welcome, thank you for taking a look. :) 

I would say that there isn't a correct or incorrect way of achieving this. Everyones requirements differ. You probably want to expand this out, there's a lot going on in the one static method you have in that class. Whilst I don't have anything against mediator patterns, I would probably combine a number of patterns to build a powerful caching class, as well as utilising magic methods (I know some people are averse to this). I need to note the below is a lot more complicated and would benefit from some refactoring to be stored against the actual method rather than a key.