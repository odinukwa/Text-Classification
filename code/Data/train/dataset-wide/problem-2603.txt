also doesn't seem like a good way of handling it. Why is user null? Currently, we don't know, it could be a number of reasons (user not found, problems with the database conncetion, incorrect query, etc). This is why returning null for functionality is generally not a great idea, because the caller will have to guess quite a bit. One solution would be to add a , but that would add additional db queries. You could also throw a UserNotFound exception, but it doesn't seem like an exceptional situation, so that is also not ideal (at least in this situation; generally, not finding a user would be exceptional for a method). Another option would be to add an method to your user class, but again, that doesn't seem all that clean either. The question is what the difference between registering and getting really is (and what data is set in user; for registering, this seems to only be the token, which means that you get an incomplete user object returned, which also doesn't seem ideal), and why you don't handle it in completely different methods (ie why does something - registering a user - if the user doesn't exist already (instead of having another method for that)). 

Personally, I prefer the first approach, as it's a lot more readable. I'm not familiar with google access, but it seems odd that you have to manually check all the access denied reasons. I would expect that you call their API, and it either logs a user in, or returns the reason why that was not possible. Did you check if something like this exists? It would severely simplify your code. 

Even better, you could pass on a list and iterate over that, meaning that your function now wouldn't care how many content types there may be. You could also convert your if into a switch, which makes sense here: 

The PDO exceptions would be handled by your calling code. Depending on what is updated, you may want to log the error, inform the user, ignore the error, perform a different action, and so on. Of course now the question is if this method is actually needed. Is this: 

Comments It's good that you added comments (although using a bit less tricky code would probably reduce the need for some comments in the first place). But this comment is a bit misleading: : The next line also changes the array, something the comment doesn't mention at all. I would rewrite it as (you don't need the range, as its from the complete array, which makes sense). 

Or you could just save the variable by putting the expression inside the if directly. Return early Generally, your code will get a lot more readable if you handle simple checking at the top of your function, and return early. This will also reduce the level of nesting. eg: 

As @ChoiZ already said in a comment, I would not pass the object in the constructor. It doesn't really have any benefits (it's not like you can - or would want to - just pass a different mail class), and it's additional work for the caller. It also means that it will be hard to change the library you are using. With your class, you created a nice interface for sending emails, but by passing the class that actually sends mails via constructor, you are binding yourself to that library. Misc 

Now you have a game field, which contains the current state of the game, as well as the logic of the game. There is room for improvement here, but it should be good enough to show you the general idea. Your View As I said above, your view does too much. It should only show the current state of your model, nothing else. Generally, it might implement an interface such as this: 

Structure Right now, you can only create a skyline for this one type of input format. To fix this, shouldn't be part of . Instead, should accept a list of objects (which you created somewhere else, eg ). Output In your problem description it says: printing a list of points , but you are not formatting it like this (which makes it a bit hard to read the output). Scanner Class I think it's good to have a class to parse input, but it is quite obvious that you didn't really want to have such a class. Your variable naming is generally good, but in , you have names such as , , and , which make the code hard to read. itself is also not a good name, would be a better fit. could also be better named: move what next? To the next word/number/pair of numbers? Your method also moves to next, which seems a little odd to me. I would try to rewrite the code so that it does not do this. You might also want to include some kind of check/error handling for malformed input (although that's not too important for a throw-away class like this). Comments A comment or two wouldn't hurt your code. They are not strictly necessary, but it would help a reader to faster understand your code. For example: 

I think that this would be a pretty good solution. It looks nice and uniform, but not too verbose. Here are some other format ideas, reducing the amount of lines for the comment to two or one. They are not necessarily better, but they are shorter: 

The definitions of and are still a little vague as I understand them, so your document could also look like this: 

You can, but it's not necessary. The rule of only having one return doesn't have to be enforced, and often leads to less readable code. 

Which actually seems more complicated to me. It's longer, and you have to know of what type location is. Additionally, any decent IDE can generate fields plus getters and setters for you. But the actual point of using getters and setters is that it encapsulates your code. For example, if you want to switch from using to using some other class. With getters/setters, you only have to change your class, instead of that class plus your main plus maybe others. Misc 

You need to sanitize your inputs ( for filenames, filter for directories, although you could filter stricter), and you need to check if the normalized filename + path is inside the directory you want it to be in. Note also that even if you fix this, as ids are passed from the user, users will still be able to upload files to other users directory, read files of other users, and delete files of other users. Note also that is nice as defense in depth, but can easily be bypassed. I would remove the comment as to not leave a false sense of security (it's mainly a usability check). Misc 

It's essentially the same code, making your functions unnecessary. If you do want to wrap mysqli - which may not actually be necessary in your case -, make sure that you: 

The cleaning functions you use I think it would be a good idea to look at the functions you do use in-depth, to get a real understanding what each of them does. Ideally, you take a look at the PHP documentation for this, but here is a short overview: 

There is really no need to use like you are doing. You can just access elements of an array like this: , which is a lot easier to read. With this, your code would look like this: 

Classes Right now, your class is responsible for the bot related functionality (connecting, sending/receiving messages), as well as managing commands. I would create a class that manages all the command related functionality, you could call it . Reflection [if you have a good reason to use reflection, like allowing users to add new commands without recompiling, ignore the following] I wouldn't use reflection like this. The only advantage you gain is that you do not have to add a new line of code when you add a new class. The disadvantage is that it is not very flexible (for example, you cannot easily ignore one subclass of ), it is more complex and thus more error prone, users can add custom commands (only a downside if you don't want them to), it might be a security risk (this is speculation, but as the bot is exposed in the constructor, a user created command class probably could insert custom commands into the database or send messages), and it is slow (maybe not too much of a concern in this case, but still). Naming Most of the time, your naming is good and your code is very readable. But then all of a sudden, the reader is presented with variables like , , , or . I would change them to , , , and respectively. Also, sometimes you use camelCase, and sometimes underscore. I'm sure that there is a reason, but I wasn't able to figure it out. For example, why is using underscore while is using camelCase? Repeading Code Your and methods look pretty much exactly the same. You could rewrite it like this: 

For now, just a couple of points: Long class and method Your main method is ~500 lines long. That is definitely too much. Extract Duplicate Code The first thing you should do is extract duplicate code to functions. For example, you have this pattern multiple times: 

Variable Names Good variable names are important, because they make the code readable. Many of your names are good, but and could be a lot better. Formatting 

Blanked Exception or specific Exceptions It depends on what you want to do with the exceptions. If you just want to stop and return "not working", then your approach is good. But if you want to try and rescue the attempt, then a different approach would be better, and then you have to differentiate by exception type: 

But what if the scores are equal? You should add an block reporting a draw. getCardfromDeck The method doesn't do anything, except call a different method. Such wrapper methods are quite useless, I would just delete it. Random Instead of 

Although I would assume that a module, controller, and method must be given, so I would probably write it like this: 

: unnecessary cast & another bug Why store as an , and then cast it to ? Just store it as directly. Either way, if it is not a , but a different kind of employee, this will cause an error. Then, there wouldn't really be the need to store it, so your code could look like this: 

Now, index 1 and 2 mean p1Loss, and index 3 and 4 mean p1Win. This can easily cause bugs in the future. Maybe a better idea You could instead maintain arrays that say what items beat. For example: 

Wrapping mysqli like this may still give you some flexibility later on, but personally, I'm not sure that it is worth it. I would either use mysqli directly, or wrap it in such a way that no element of mysqli is actually required outside of the class. 

This would be a lot easier to test with non-obfuscated code. If you change your example, I'm sure someone would try to cheat it. 

That's just too much for one method. Extracting code to methods will also reduce your in-code comments if you choose good method names. OOP One of the reason that your methods are so long is that you only have two classes (with unclear responsibilities); I would add a lot more classes. It is often easiest to first sketch them out on a piece of paper, here are some general ideas to get you started: 

What you should do is check the file extension as well as the actual file type. The functions that are generally recommended for this are and respectively. Ideally, you should use whitelists, not blacklists. It is a good idea to additionally forbid execution inside the upload directory, ideally by using server configuration as well as OS configuration, but this should not be your only line of defense. 

Yes. (assuming it is used correctly, which means no variable input in the ever; and also assuming that this isn't an issue) 

Note that the extension limitation does not apply to old PHP versions that are vulnerable to null byte poisoning or path truncation. Also, your echo is vulnerable to XSS. 

You can easily prevent this by passing to before echoing it. If also contains (HTML) content by non-root users, sanitizing this will be a lot more difficult, but I am assuming it's only ever created by you. Config Your file seems to be located inside the web directory, you should move it outside of the web root. Having a password in a PHP file inside the web root could leak your password in some instances. Handling Exceptions Right now, you are echoing the exception (not a good idea for production code as @ratchet freak mentioned), but are not handling it, you call anyways (and it will fail, uncontrolled). You should either try to recover, or redirect to a custom error page. General Code Comments Style 

Personally, I would handle the value counting in on the fly, to avoid the trouble with the aces and the duplication in and (you could also avoid this by just calling twice in your constructor). You do the same conversion from list to array in a couple of other places as well. Eg this: 

I wrote a router class which accepts a URL and calls the appropriate controller method based on it. I'm a little worried about the amount of dependencies it has (eg , , etc), because it might make reusing it in other projects difficult. It feels especially bad because a lot of the dependencies are static (and there might be even more in the future; eg if I add support for multiple languages). On the other hand, I also did not want to pass too many arguments to the router, and I'm not sure if it makes sense to create new objects every time for each of the other classes, and I also did not want them cluttering up my private fields (although that might be best?). I don't write all that much in PHP, so I'm happy about any other comments regarding code quality as well. 

Empty Else and Error Reporting In your upload code, you collect all error messages in an array, and then check if this array contains errors. If not, you do nothing. Instead, you should print the error messages to the user, so they know what went wrong. Eval Eval is evil, so I would avoid it if I can. In your case it's safe because the input is not user controlled, but there is no reason to use it like you do. Transforming an array into X variables doesn't seem to server a purpose, just access the array directly. Or, if I am overlooking some reason why this is needed, you could also just hardcode the variables, as only the first five are actually used (you did not post your HTML code, but I'm assuming the user is aware of this). Splitting up your Code 150 lines of code is too much to leave it in one big block, it would be a lot easier to read if it was split up into functions. For example , , , etc. Misc 

Security is user controlled, and thus not trustworthy. An attacker can easily bypass your type check and upload files of dangerous type, such as PHP files. What you should do is check the file extension as well as the actual file type. The functions that are generally recommended for this are and respectively. Style Generally, I like your style. Your code is quite readable, so just a couple of minor points: 

populateAddressVars Right now, is set twice: once if exists, and then you override it when exists. I'm assuming that this means that you want to set it to if it exists, but if it does not, would be fine as well. For this to work, you are relying on the structure of the json file (that always appears before ), which you shouldn't do, as it is out of your control. For the other cases, I would use instead of to gain a slight performance increase and reduced complexity, as it doesn't seem that they can happen at the same time (for elements such as this would not be the case). Return early You are already using early returns a number of times, you should use it in as well: 

As KIKO Software and the documentation for crypt said, . It's safer (it applies multiple rounds of hashing, thus increasing the time it takes to decrypt the hash), and it will manage salts for you, which means that your code will be simpler. If for some reason you do not want to use , note the warning from the crypt documentation: 

I don't really see a reason to place hyphens in-between the characters. It doesn't really add anything. It just makes the token longer, without adding randomness. I also don't see a reason for , it even reduces randomness. Also note that is not supposed to be used for any security purposes. If we assume that it is completely broken (which it is probably not, but I haven't looked at the code, and it does have a big warning in the documentation), that would only leave you with 10 random numerical characters (from a not-so-great rng), which doesn't seem that great. I don't think that there is really a security issue with what you have, but it is definitely not the correct approach. Just use instead. It's definitely more secure, and the code is considerably shorter, and can easily be adapted (just change to if you want more security; with your code, you would have to change a lot more).