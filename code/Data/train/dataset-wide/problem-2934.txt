In case the right element has a bigger second coordinate than the left one, the result is always . I'm not sure if this is by design, but if not, then I'd suggest to make sure, that vertical gap is calculated correctly also in such cases, by taking the absolute value of the difference, instead of the difference itself: 

N.B.: is borrowed from a task of codewars.com, all the rest is my code. While any remark, and suggestion is welcome, I would be interested most particularly in the following questions: 

You can write e.g.: "The implementation of {@link #save() save()} function is optional." Same holds for the JavaDoc of the method itself. 

Why is this last point advantageous? Because you can easily add more situations, without the need to copy-paste the gui elements (wrapping divs). Besides that, it is also possible to quickly change the gui implementation. (E.g., if you decide to have divs instead of buttons, you do not have to change every one of them.) I created a fiddle, where you can try the concept. (Unluckily, the built-in fiddle of SO is not available from tablets...) 

For more details, see e.g. Wikipedia. Some remarks on design Besides having a correct implementation of the algorithm, I mostly had these goals in mind: 

Background Bloom-filter is a data structure to which we can insert elements, and check if it already contains a given element. The peculiarity is, that if a query returns , then it might still be possible, that in fact, this element was not inserted to the filter. (If, on the other hand, it returns , then the element was definitely not inserted previously.) The implementation consists of a bit-vector of length (originally all bits are ), and of hash functions, which map any input value into the range of (, i.e. inclusive, exclusive). When adding an element, we compute its mapped value for all of the hash functions, and set the corresponding bits to one, in the bit vector. Similarly, when querying if an element was added, we compute the value for all the hash functions and return , if all the corresponding bits are , and otherwise (i.e., if the corresponding bit for at least one function is zero). Objectives of the review While any remark/suggestion is always welcome, I'm mostly interested in the following aspects: 

I implemented a Trie data structure in Java, to test my understanding of the concept. I tried (pun intended :) ) to follow TDD steps along the way (i.e., add first a failing test case, and implement functionality after ensuring that it really fails). I'm posting here the end result. Besides the implementation itself, I'm also interested in the quality of the tests. I'm mostly interested in the following aspects: 

Note that by having the constructor throwing an exception if the file name is invalid, we prevent the object from being used in an invalid state. The reason is, that (in our example above), we cannot use the object after this line: 

Introduction to the Algorithm A system can be in N different, unobservable states, (i.e, we never know in which state the system actually is). The system also has a finite number of possible observable "outputs" which depend on the actual (unobservable) state of the system. The input of Viterbi algorithm is a list of observations in a time sequence, and the algorithm calculates the state that was most probable for each time frame, corresponding to the observation. What is also given, besides the list of observations, is the following: 

In this way, the result of the above example will be: . Of course, it might be worth considering to rename the parameter, e.g. to or something similar. P.S.: I setup a github repo for the above mentioned changes, and their corresponding test cases (along other tests): 

OOP changes Since you are exercising OOP (and don't mind some over-engineering ;)) , you could consider adding another , for dealing with the case that no prime factor matches (e.g. ). This would require the following modifications 

Code organization improvement: I suggest not polluting with 's, but have it return error codes, and then in the function. This makes it easier to unit test that function. Invalid characters: the case for is now silently ignored, both in the reading function, as well as in the running function (where, e.g., you could add a "default" branch in the switch statement to cover that). Instead, I recommend returning some error codes for such cases, in both functions, and then bail out the program in . New feature: maximum size of memory and instruction could be parameters of the program, with possible fall-back to the now hard-coded values. Unit tests: in the repo, there is currently only one example/test. I recommend adding more tests for valid and invalid usages as well. In particular, I suggest testing with such invalid cases, that would be caught by the parser, i.e. they would never get to the interpreter. The purpose is to make sure that this function is also robust, independently of the parser. 

Handle the case for invalid operators (now it defaults to taking modulo) Explicitly handle the case of division by zero (now, the modulo will be taken, instead of dividing by zero) Handle invalid numbers: 

Reason is to avoid accidentally breaking the if-else construct, by introducing new solutions.Consider this: 

Is this a correct implementation of the data-structure, or do you see any flaws? Is there a way to make the implementation more optimal? (E.g. is there an elegant way in to jump out of the if we encounter a bit not equal to ?) Related to the above: is there a way to make this code more idiomatic? (I.e., conforming to Clojure best practices.) Can you think of any missing tests? Or some other edge-cases which are not covered? 

For the second part, I suggest factoring out the mapping logic from inputting the date (or at least, the date should also be read in the function itself -- but receiving it as a parameter, and then reading it again is very messy IMHO). So this would look something like the following: