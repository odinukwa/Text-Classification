I guess you thought about avoiding of method, not you mentioned in title. I can't test your code because I don't have either COM port nor motor. I would like to give you some general tips how to improve your code. Let's implement some SOLID and DRY principles. I would start with class Motor which will represent your device. You can implement for example singleton class for this purpose. This helps you to separate your motor logic from other logic such is user interface. I can also imagine your port settings as a part of application configuration. Motor.cs 

I am not providing review from programming good practice or architecture perspective. I just want to provide you some recommendations to improve performance of your code you have asked. 1) Find first empty cell on worksheet Your while loop way to find first empty row is inefficient. Getting value from cell via Interop is slow. Instead of this block: 

Method names is void. says that method should return some initial values. The other case is which returns array. That is strange. IsFreed() returns int. Usually if I see method named like , I usually expect boolean return type. Consider use of Array.IndexOf(). Then the function can look like: 

Loop structure's OK, logic's reasonably good. There is obviously a Java library alternative of , but I assume you knew that. Some efficiency issues with excessive toString() and string-ification of what could be character operations. Here are some tips: 

Best practice in exception-handling is to "throw early, catch late". Exceptions should mostly be handled at the business/ or request level -- it makes absolute sense to reconnect to an external system/ or resend a failed request. It generally does not make sense to retry a single byte, or a single SQL query. Given that, the concept of checked exceptions -- forcing you to "handle immediately" or declare -- is of limited use. Originally they were intended for contingencies, as opposed to failures. For example, an InsufficientFundsException when making a payment. Their spread to instead be used for all kinds of unrecoverable low-level systemic failures was largely a mistake. You should design API insteads to use runtime exceptions, and (if you need to catch) should rethrow checked as runtime exceptions. In my projects, I declare AppSqlException, AppInternalException, AppConfigException etc which work very well. See: 

I know, it's a challenge convert your big doubles to string, but if you can use decimal instead of double, the conversion could be smooth. 

I am not experienced in serial port programming, but I am pretty sure that event SerialPort.DataReceived should be used to invoke subscribed method as you do with your serialPort3. I don't know exactly why you are using Thread.Sleep(), because I cannot see method. 

The question is, what is the goal of this task. If it is just return the position of the last man who will survive and your teacher doesn't care about the killing sequence, we can write recursive function like this (source): 

Instead of using global fields (M, buf), encapsulate them into object and set the proper access modifier or better create properties. Use meaningful names your fields and properties. Use Capitalization Convention. You can isolate your repeating strings into separate static class to make your string constant repository which would be more easily maintainable against direct using of particular string. StringConstants.cs 

Constant is constant and you can find it in Excel documentation or in object browser in VBE. 2) Use temporary string[] array Writing to worksheet cells one by one is inefficient. Work with string array and fill final array at once into worksheet. You can initialize array: 

Use where nulls are not possible, not . is only used locally -- keep it local. Referencing it outside the method can only be erroneous, so it shouldn't be visibly exposed to make that possible.. Carry calculation from is OK here, but could in related algorithms be brittle -- it can't handle a digit-sum > 19 as the maximum carry it can produce is 1. If addition completes with a carry of 0, it will output an unnecessary 0 digit. If Strings are your inputs, you should probably build a String as the result via a StringBuilder -- not an ArrayList. should be called or , if you're building the result in it. Build using StringBuilder in reverse order, and do it by character calculation rather than toString() if you want to maximize efficiency. Return the result from your function, and do the printing in main() instead. there. That way you have a general-purpose function and a fixed-purpose main() method for testing. 

Use where nulls are not possible, not . is only used locally -- keep it local. Referencing it outside the method can only be erroneous, so it shouldn't be visibly exposed to make that possible.. Carry calculation from is OK here, but could in related algorithms be brittle -- it can't handle a digit-sum > 19 as the maximum carry it can produce is 1. If addition completes with a carry of 0, it will output an unnecessary 0 digit. If Strings are your inputs, you should probably build a String as the result via a StringBuilder -- not an ArrayList. should be called or , if you're building the result in it. Build using StringBuilder in reverse order, and do it by character calculation rather than toString() if you want to maximize efficiency. Return the result from your function, and do the printing in main() instead. there. That way you have a general-purpose function and a fixed-purpose main() method for testing. 

Few comments regarding your solution: Exception Test your code with initial values 10, 9. Exception occurs - IndexOutOfRange. I would avoid of method recursive calling in block in . It could cause unexpected behavior of your application. Improvements You can generate array with initial value of each element using Enumerable. 

Variable names variable is in reality array int[]. I would call it prisoners. And the in fact represents prisoners count, so why don't call it . Parsing, Casting Paparazzi already asked the question about converting of string to . Your variables are structures, so you don't need to convert to and then explicitly cast to . Simply use . Alternatives are methods or . 

If you pass prisoners array to method, then you don't need to know prisoners count. You can simply work with property. You display the array in Console in two methods InitiateGame() and ShowInConsole(). Make just one method for this purpose. Simplify expression from to Use cycle if you don't need change array members. Simplify condition with ternary operator. You can use string interpolation when you format strings.