Summarizing this long intro: Filtering is FP-concept, FP-friendly languages or strict FP languages are therefore better. If you choose examples like that and want to work with Java, work with Java Collections, libraries geared towards filtering/collections/data pipelines and Java 8 that introduces Lambdas. Java 8 and streams First proposition for you, uses streams, introduced in Java 8. There's a library that tries to make lambdas (and perhaps streams?) available in Java 7, so you may be able to show same code with it. 

Test name has an "and", seems like two tests? Test throws Exception, do you have tests for that? You don't need to start test name with tests, unless you use JUnit 3. When runs, it calls and . What these do? , why not ? You only implement then? Further reinforcement to point 1) - you have more than one assertion. If buckles, other assertions aren't tested. Is that fine? Why do you need a over just a ? I found no other reference than to that one element, via ? Is this test alone it it's class? If so, I'd extract mocking out of it. Readability / clarity / easier to spot things. Have you tried structuring the test into classic given - when - then or assess - act - assert? 

I used ArrayList without any type-safety. I then iterated over input array and added elements meeting criteria to ArrayList. Then, I printed out ("returned") ArrayList. Why? 

I build a with . Then I the stream and using I on the fly create an that just prints the value. performs an action that you define on every stream element. I could've used and then function would - instead of having side effect - return an array, which I'd then have to print in main, iterating over it. It might look simpler and be 1-2 lines terser, but it's less memory efficient. Answer within all your limits With all that said, Java 7, no "extra" libs: 

Good, this way when the user sees 0x001 in the screen he/she e-mails you asking what the error is and then you either tell them how to edit the file or read it for them. Short Python programs usually are "doable" without even a single global variable. Try it. Someone above suggested classes. Don't go that way. Python classes are slow and fat and you just want to roll a dice, it is not really necessary to have classes here. Last but not least, try to name functions with verbs or verbal phrases. It makes more sense to than . 

Before asking that ask if there is any need to improve the efficiency and shorten it. Readability nowadays adds much more value than performance tweaks. Writing code that your peers don't understand is a much bigger problem than doing inefficient loops. 

to improve code readability and make your intentions clearer. Lastly, makes your intention slightly less clear than . In Python striving for English-like semantics whenever performance isn't critical is considered a common practice. 

I will try to add to the already existing answers. I think that if you are up to coming to CR you won't badmouth PEP-8. If you do not know what it is, read it. Imports should be on separated lines. Two empty lines before a function declaration (one if it is inside a class). 

is repeated for each closing option. This violates the Don't Repeat Yourself principle strongly. Encapsulating it into a function would be a great idea. The same goes to the opening values, they are always handled the same way, why not check if the input is one of them and give that the same treatment. You would only simplify code and ease future maintenance this way. Be aware that I am not really a fan of switches anywhere, except for enumerated types. But my advice is unbiased, as far as I feel it. You'd be better without a switch here, in my opinion. Minor You have a comment. It is quite pointless but it is too small to be an issue. Lastly, it seems that the inline comment before the loop is misaligned. It would be nice to fix that. Algorithm-wise Your algorithm only fails on the end. So if I start with and follow it by repeated a million times it will take a reasonable amount of time to terminate even though the string cannot possibly be valid. 

First... choose the right problem or choose what you want them to learn Let me first question your assumptions (pure Java 7, no "extra" libraries and array filtering). I do so under the premise that you want your students not just learn "pure Java 7" (ain't best idea neither commercially nor academically, nor will it make them greater programmers). Also, why I keep typing "extra libraries" in "": 

This is not "for fun", but because there was need for it. Among mainstream languages none treat "backward compatibility" so seriously as Java does. Despite deprecating APIs since version 1.1, they have yet to cut a thing. This means, there's lots of OLD stuff there. Also, the problem you have (filtering data) is VERY FP friendly. FP languages among first operations have and . Java at it's inception targeted C++ people, who wrote programs iteratively (for loops, step-by-step instructions to solve problems). FP works on streams and pipelines (data flows, and while it does, we do things). So, yes, Scheme (FP language) is awesome for your problem. So is anything that has decent FP features (JS can be argued so). Pure Java, without Apache Commons, Javaslang, Lambdas etc. will be hard-pressed for it: 

Disclaimer: I don't know Android. I've wrote two or three programs for it. Also, I don't have your full code so can't be sure about some of the classes this code relies on. 

I think similar thing can be done with a StringBuffer and were you to process something more text-oriented, that would be better choice.