You can also try looping through the values to , inclusive, but this is messy; it works a lot better in C than Java, since you don't need explicit boolean coercion. 

Here's a fiddle demonstrating it. I took the liberty of adding another row with on every cell to demonstrate that will still override the selection. 

Revision. Better yet, we can use . This has the advantage of being entirely unreliant on magic numbers; we can instead just change our object as needed. Furthermore, this deals with @megawac's concern about the undefined enumeration of . 

I believe @EmanuelePaolini is correct in that you're likely getting TLE because of I/O. You're using Scanner, which is way too slow. Try a different input method. 

This gave me a final speed of , making for savings of 47%! I also tried filtering out duplicates beforehand, but for this case, it actually slowed it down to . (Edit: As @megawac asked, here's a jsperf. I also included one with smaller test cases; you'll notice that the relative difference in speed is much less.) Here's the final function. You may notice that I explicitly specified the base in the ; this is just in case the data file contains something like , where the would parse to . 

Send a request only once that returns all booking data for the specified date. Send only a validation request upon clicking Book; don't bother checking if a date has bookings. 

Option 1 is the ideal approach, since it minimises requests. However, if for some reason you don't want a user to know when you're booked, you'll need to go with option 2. Whichever option you go with, you should provide feedback on its success (or failure) after submission, in case somebody else booked it sometime between validation and submission. 

You'll also have to think about whether you need to distinguish between being undefined, i.e. defaulting to true, and being falsey, like or or . 

Another way: If there's some common selector between the tabs (for example, if they all have the class ) and you're fine with instead of , you can simplify to the following: 

† I say "probably" because although it's a CSS3 Candidate Recommendation, it's considered at-risk due to poor browser support. ‡ Strictly, your code will be assigning the handler to , but they'll do the same thing. 

You're looping through every possible permutation of three boolean values. This could be achieved by looping on booleans: 

You're missing a semicolon—this is a function expression and not a function statement. More importantly, however, this function doesn't make much sense as written. It returns a single element or undefined if it can't find one. That is almost exactly the behaviour of , which will return instead if it doesn't match an element. I would just straight up replace this with . I'd also like to point out an efficiency issue, even though I'm asking you to get rid of it altogether. The loop condition gets executed every iteration. This means that you're actually performing two calls to return a single element. This is bad, and it'll get even worse if you try to do something as you iterate through them. Instead, assign the result of to a variable, to avoid calling it multiple times. 

Functions should be named according to what they do. This means they should often start with a verb, so rather than , it should be . (There are exceptions. For example, when checking a condition, you can use .) Furthermore, they should be named in ; the first letter should be lowercase, while the first letter in each word should be uppercase. Consider aggregating your dog mood functions into a single method. You'll probably soon learn about s; an enum would be a natural way to store and represent the dog's current mood (à la ). If you're looking for a 40% chance of something, then or will do what you want. will get you a random number from to inclusive, so will actually be a 36% chance. Your chain is needlessly complex. Remember that an will only be considered if all preceding s and s failed. Thus, you can instead use an - ladder similar to the following. (Note that the percentages are accurate only if you change your line to use rather than . 

I ran the script ten times on this (3580 lines, 29.6 KiB) and this (500k lines, 8.3 MiB). contains about 300 duplicated names, and about 2000 unused last names. About 70% of the last names in do not have a corresponding entry in . Your code ran in on average over ten trials. I made the following changes in arrCSVtoObj: 

That's not how the keyword works. creates an object using a constructor function, but your function does not behave like a constructor. This works only because will perform the function call, but you're really just doing . Also, rather than using for attributes, use . This holds for the rest of your code as well. 

This is the classical implementation of the sieve. The resulting array will hold a value of for prime values. Now, observe that the first time you ever see a prime, you remove all of its multiples from contention. We can therefore store a separate list containing just these primes. (We also have to loop over the back half of the array to get any primes .) 

You seem to overuse in your CSS. This is very bad, but I didn't change anything about this. Your script is extremely repetitive, too. I tried my hand at DRYing it and I got: 

Indent exclusively with tabs. This is nice when using text editors with a configurable width for tabs. It also can marginally speed up a site, but that's only if you aren't already stripping out whitespace before sending to client. It's also negligible in the era of . Indent exclusively with spaces. This guarantees that the code will look the same for everyone. Since it isn't configurable, though, if you like eight spaces and someone else likes two spaces, they can't just make it happen with a setting; they'll need to do a replace on the file. Mixed: indentation levels use tabs, but alignment is done with spaces. This is the style I personally use. 

Notice in particular that returns a coded string that includes the algorithm used and the salt. This means that you can store it straight into your database and not have to worry about salting and whatnot. 

Another way to do this would be to change to a slice and then use . I'm not super familiar with Go, but this works for me: 

should be one line of code, but you treat it as two, since your regex absorbs the . In fact, I'd argue that the way that you choose to count lines of code is odd; it took me a few reads to see what you were doing and find that error. The more natural way perhaps would be to strip spacing and comments, then count non-empty lines. That also has the advantage of being way faster: you're calling a lot, which is pretty expensive. Aside from that, I only have a few comments: 

Prime time to use the conditional operator. Consider rewriting as . (Although, I would still question why you need to return both. 

Of course, you won't want to repeat this code in so it would probably belong better as a function in some shared library. 

You'll note that I got rid of (didn't seem to add much value to me) and that I declared as a local variable. 

If you're adamant about continuing with your approach, then instead of using and , consider using a salted hash involving the date. For illustrative purposes, I'm only using one round (since this type of thing doesn't need to be cryptographically secure). 

Here's my rendition. It's a little bit less elegant with the return... oh well. I'm using a utility function to avoid potentially ugly ternary nesting. The double bugs me but I can't think of a better way right now. 

The following point becomes less relevant as you address the above points, mostly because I believe you should refactor the referenced code out anyway. 

In PHP 5.5+, the best practice is to use and . You can use it in your code like so. Notice that this obsoletes the column in your table. 

and You're right; these two functions share a lot of code. I propose a single function, which I'll call . I'll add that to the end of this section, but first, the line-by-line analysis: 

Ideally, you would separate these to be in the event handler, since they deal with UI logic instead, while the rest deal with model logic. This also causes you an issue later on. 

The following would implement the last two points. Note that save detection is naive, since as far as I'm aware, there's no way to conclusively determine if a user has saved the file to disk. (You'd also have to set in and .) 

This is a little bit messy; this is the issue I was referring to earlier. It's good that you added a comment, but even with the comment it seems a little bit bleh. This is mostly an issue because your and methods both call , even though in this instance you'd prefer to just use the logic. If you can, it'd be better to separate the model logic (the stuff dealing with the adding and deleting on ) from the presentation logic (rendering, clearing input boxes, etc.). That way this method becomes a lot cleaner. There's also a bug here: if you edit to an already existing todo item, the add will fail, but the delete will still run, so you lose your existing item. This will even happen when you edit to the same thing. 

However, I'm curious as to why that logic is in there at all; it won't ever evaluate to anything but since it won't be called from e.g. ... 

Sorry, don't really have the time to do a comprehensive review (maybe later I'll edit!) but for now: Your code actually fails on some cases. The way that you're finding whether a line counts as a LOC or not is too greedy. (Alternatively, your comment regexes are too strict.) You're reading in basically the whole line as a line of code. This fails for relatively simple cases: 

It looks like you're looking for the index of the first child of with the class. (Incidentally, your code will also trigger on stuff like , which might be a false positive. Be careful about your classes!) Native selectors work fine here. Furthermore, your initial assignment doesn't do things the jQuery way -- there's no reason to initialise two separate jQuery objects. Try replacing your block with something like: 

Performance It looks like you're ing an element and immediately performing a for it. This is incredibly wasteful. You can just use instead. I can think of two ways; one creates two objects and uses two s, while one performs a query. I wrote a quick-and-dirty jsPerf. The query runs the fastest; your original is 91% slower. 

Finally, I don't imagine performance is as crucial as you make it out to be; once per second is pretty lenient. 

Formatting I found this exceedingly difficult to read. The indentation in particular is inconsistent. I highly suspect that this is because your code contains mixed tabs and spaces. (StackExchange silently converts tabs into four spaces. If this is not the case, please ignore this section.) I don't want to start a holy war or anything, but there are three main camps here. 

First, read @MatsMug's answer. Personally, I think that your final exported function is okay as (it's cute, almost), but your internal stuff should still be named , , etc. 

In addition, in your code, you're running a lot of s here. Rather than calling it each time, you can store the result into a variable and only have to call it once. I didn't do it here because by making the other change, you'll only have to call it once anyway. 

The trick is a cool way to truncate floats to integers, but it's much less readable and relies on a side-effect for the heavy lifting. Although is appreciably faster, using is preferable since the intent is immediately obvious. Feel free to disregard this if you've identified this as being a performance bottleneck. If your application is not performing slowly, however, then this may be a case of premature optimisation. 

columns should almost always be s, not s. That's just silly design. Similarly, should be an . should be foreign keyed to some table. is not necessarily a good name. If you only need to differentiate between active and inactive, use a and name it something like . If you need more states, then assign a value like or or , instead of and . There's no reason to have a separate table for and . Rename to something else (?) and get rid of . Whenever you have a top-tier item, set its to or .