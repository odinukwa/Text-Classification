Thread safety To avoid inconsistency in multithreading environments I considered the start()-method to be synchronized. Again, this is optional for this simple exercise. Code 

Beside you have mixed two concerns in one method (load/unload) that you treat differently (overload will not be allowed, unload will be corrected) you also try to publish success information via return value. I suggest to not publish true or false. I suggest to have either no return value or the new value of the loadWeight. Exceptional cases I would handle with the concepts of exceptions. I would expect a signature like this: 

You will have a hard day to "combat" this design. My view on this subject: People either want to get around semantics, do not care about it or even don't know that such thing exists. As the "Anemic Domain Model" does not care about encapsulation it is easy to get around semantics. You do not need to think about where attributes and algorithms are located "best". You can easily pass the structures around that you need at a certain location to do whatever you want with it. I have to explain "best" because this is the main point I always struggling with other developers. I suggest to read the next paragraph too if you get a bad impression on my view here. First of all I want to mention that for me there is for one special requirement only ONE (the "best") solution. The point is: If you talk about code quality and what kind of code is better everybody implicitly say "There is one best solution". If you do not do this: ANY sugestions about "improving" code would be totally subjective. On the other side WE ALL have cognitive trouble at some point of complexity and/or the programming languge hinders us to express the semantic properly. That is why I am convinced that we nearly NEVER reach the point of the "best" implementation. BUT I am also convinced that we can evaluate the path through trial and error and falsification. Nothing else is done in in science. They try to produce good models of reality. And they want to be as close as possible because they want to make forecasts with these models that will be beneficial for the society. But to do that they have to be clear in semantics. One thing a want to mention on which assumption my statements are made if I talk about "reality": 

... to have a technology free core. Finally I only see the method "getNewsMessagesFromUrl(..)" to have potential to be taken apart. Everything else seems to me pretty straight forward. 

The listener pattern adresses the dependency inversion principle as the Calculator can communicate with subclasses of the Listener-contract "CalculatorListener" without knowing the concrete implementation. Also we adress the single responsibility principle when we unburden the UI class "Display" of "writing" something. 

According to Wiki "a god object is an object that knows too much or does too much". The general problem I have with this is: What means "too much"? Your question is about searching an absolute statement as we already know we can only find absolute statements within very restricted areas (and that's what they all have in common) that are not related to reality. As soon as we deal with real world applications we have to deal with uncertainty. That is because we derive OO models from reality as we perceive it. And this can be error prone. To escape this dilemma in computer science some principles are discovered that lead to a step by step improvement of source code. They are called S.O.L.I.D. principles. If you violate a principle your source code becomes worse. So the target is to violate the principles as less as possible. So easy as I say it: The violation of these principles is an identification problem that sometimes becomes very very difficult. In the case of the so called "God class" the "S" of these principles is addressed: The single responsibility principle (SRP). It says that one code fragment (module, class, method) should only have one responsibility. BTW this is applicable to other programming paradigms as well. A "God class" seems to have at least more than one responsibility. That can be said for sure. Anything else is popular speech if someone says "God class". So working with SRP your code will improved step by step by identifying violations of this principle and eliminate them. That is by consolidating redundant responsibility and vice versa by separating different responsibilities. But the whole thing only works if you identify the violation. And that's the core. To identify a violation you look for indicators: 

I do not use a ConcurrentHashMap as it is not necessary anymore. And it is wrong considering the usecase. Those datastructures are not that beneficial as they seem in the first place as you have to know the usecase to chose the proper datastructure to be synchronized. Synchronizing is done via the synchronized method modifier. Both, the read access method and the modification access method allow only ONE thread to be in the monitor. Some may argue to avoid the synchronized modifier because it will introduce a lock on a visible object. Other developers may use the object as a lock as well and a deadlock may happen. My point of view is: If you put a lock on an object that you do not "own" you should know what you are doing. And I think it is a wrong message to allow other developers to not know what they are doing. Thread The next to adapt is your thread. First you should define a Runnable instead of deriving from Thread directly. Furthermore the thread should know the usecase specific thread-safe datastructure: 

This process applies the Open-Closed-Principle. It helps you do distinguish the different concerns and separating them into separate compilation units. So you will also satisfy the single responsibility principle. Your first implementation is straight forward. I would go with that and derive a new class that will implement caching concerns you introduced in your second implementation. The point is: Caches always come with scope and lifetime. These concerns should not flood you straight forward implementation. Caches should be transparent to clients. The interface contract should be the same or enhanced, but never changed or restricted (Liskov substitution principle). 

Learn the theory of sequence, selection and iteration Train your algorithmic thinking by solving problems with the elements of 1. in a programming language of your choice by increasing difficulty Get familiar with the language mechanisms Apply programming paradigms like functional or object-oriented programming Formalize you code fragments by learning the currently identified 26 design patterns and learn to to apply them in the correct situations Organize your code by following the correct semantic of each code fragment and learn and apply the SOLID principles as they guide you through the jungle of design decisions Learn the restrictions of the language you use for a problem. Maybe in another language you are able to express the solution in another way that is more elegant. 

Your solution looks good. It's a really challenging task. This is because you have to "flatten" an algorithm with recursive nature. Furthermore you have to break it apart into single steps and to be able to resume at the last step made. So there are little things that I would change: 

Security semantic User is too strongly tied to the Bathroom. Maybe your User will be using a kitchen next time so in your concept the next interface User is implementing is "KitchenUser". This is infexible (you have to recompile your code) and doesn't really reflect the semantic. It breaks down to that the User is appearing in a room in a Role, and he should only be able to use the room if he has the proper Role. This seems to me a security concept that should be a separated concern. Broken abstractions "Fitting" as an abstraction knows about concrete FittingTypes. So the abstraction got notice of concretions. This breaks the abstraction as you always have to modify the Fitting class if a new concrete Fitting occurs that has a FittingType which is not known. You should at least extract the enum "FittingType" out of "Fitting". You are managing the bathroom fitting in a bathroon object knowing them as abstract "Fittings". Your Fittings currently can only be turned on or turned off. The "controlSpeed()"-method of the concrete class "Tap" is not accessable. The problem here is: there a some solutions to gain access to this method but they will ALL break the abstraction through a class cast that will lead to unmaintainable code. And it does not reflect reality either. The real problem is: You mixed meta-modelling with concrete modelling and I think you did not even noticed that. This mismatch causes class casts at that point you change your view. On one hand you want to manage Fittings in an abstract way (Bathroom), on the other hand a User wants to turn on a specific Fitting and maybe control the flow speed (Tap). To solve this cleanly you have to keep your abstraction level!!! Concrete modelling With that you have to distinguish between the Fittings that differ in there interface. So you have to put Tap and ChromeTap into different buckets as Tap has the controlSpeed()-method to be accessable. Maybe you find an interface that "Tap" can implement that provides the three methods "turnOn", "turnOff" and "controlSpeed". Maybe something like "InfinitelyAdjustable". ChromeTap maybe will implement "Flop". But you have to think about that carefully. With concrete modelling I do not mean that you should not use abstractions (interfaces or abstract classes). What I mean is all about avoiding class casts and providing clients the interfaces they need and expect. Meta-Modelling With Meta-Modelling you are modelling your own classes with objects and you become very flexible. In consistent cases you will have never to recompile the code of your problem domain again. I do not suggest to go deeper into this right now. You should do your own reasearch on this if you are familiar with keeping your abstraction level. At this point I only will refer to Wikipedia: Meta-Modelling 

Sets as significant states You should think about the problem solving process in the whole. Currently the algorithm is ruling the structure. Some examples... Here you explicitly encode the final state as an expression: 

The problems we had when writing a parser were solved by breaking down the parsing to a state machine. We parsed every single character and tried to represent every state as a separate class. We got rid of deep nested if-statements and got expressive little classes that either remain the state machine in the current state or go to the next state. We remember once read characters in a buffer and put them on a stack to support recursive structures. Finally we called our expression parser recursively when we determined a separate expression. It's a lot of additional structure code (classes) to introduce. But the effort will be benifical to future requirements. I really suggest to have a look at following resources: 

I do not recommend this because any pending or working thread will be aborted. If this is your intention then you have no well-defined shutdown as the threads may be in an arbitrary state (writing to harddisk, communicating with remote services etc.). Also you will hide programming errors if some threads have corrupt shutdown mechanisms. So inform all threads to shutdown if you want to exit the program. After all you should define following shutdown strategy for Swing: 

I'd like to have as less parsing concepts as possible. Harmonize your parsing through ONE general parrsing concept. Favor composition over inheritance You currently derive two levels from A_RayCode: A_RayCode<-LoopCode<-IteratorCode. I suggest to have a strategy pattern here. Longer functions names Your concept does not consider functions with names that have more than one characters. Introducing such functions you will have to think over everything. Even if this artifical language seems to suppose to have very short function names (at least one I guess) this can be a serious problem in real world parsing. You are closed for extension. Responsibilities Parsing responsibilities are divided and as I mentioned you have different parsing concepts. Furthermore you mixed parsing and execution. 

Although the solution inflates to three methods nobody can avoid the responsibilites involved to produce the result: 

Where is the synchronizsation??? The work of synchronisation is done by the "LinkedBlockingDeque". As we only delegate to ONE synchronized method of the "LinkedBlockingDeque" in "getElement" and "registerElement" we do not need our own synchronisation. 

Any number that remains unnamed remains a magic number. It's not related common usage as common usage is relative. The problem with it is "when" or "where" to draw a line... when does a number changes its state to non-magic... 2,71828... may not be magic for mathematicians (Euler) 1760 may not be a magic number for anglo saxons (Yards per mile) 10000000 may not be magic for south inhabitant of south asia (crore) 1 may not be magic in the context of multiplication (neutral element) The relative approach will lead to a discussion that will evolve a local aggreement. And the result to consider a number to be non-magic, will depend on when and where you start the discussion. Unfortunally this discussion has to be lead for each number separately. The absolute approach is simple an clear: Every number that is not named is a magic number. Discussion over... for all numbers... Of course this is only a (one) definition. But this definition has inherent properties that will make it possible to evaluate it exactly. So if you want to discuss, go for the relative approach. You will find the discussions never ending. And if you think it is over another number comes along. Or you go and find a definition that can be used in boolean expressions that will evaluate to true or false. I go the second way with following definition: Every unnamed number is magic. Even if you practically ignore it the statement stays the same. 

Your implementation is minimalistic but it does what it does and it does it good. Your code consists basically of three elements: 

It is true. The difference lies in semantics. Interface owned by its own class The core is: EVERY class has an interface aside the language construct "interface". The problem is: Sometimes it is not beneficial. If you have a class in JAVA sometimes it is hard to ensure encapsulation. Therefore you hide the class behind an "interface" language construct. The separate interface of a class is only an extraction of the interface the class already implicitly has. You can compare it to the header file in the programming language "C" where it provides perfect encapsulation. In JAVA it is a helper construct which is not enforced. So nothing hinders you to use the concrete class implementation instead of the interface. In "C" you only make the header files known to other compilation units (I hope so, as I am not a C-developer). Interface owned by the framework The other way around: A framework provides functionality. To let your object cooperate with the framework they have to meet some requirements that are formulated as "interface" language constructs. Here comes the complicatet thing: You may have a class with an extracted alternative interface AND you want to have a contract to work together with a framework. Then you have two interfaces with different semantics to handle. The clean architecture If you consequently follow the SOLID principle it will guide you to exact this architecture. You have no chance to miss it. Your code In general I do not think that pressing a button is a usecase but I think you have a correct reference implementation of clean architecture.