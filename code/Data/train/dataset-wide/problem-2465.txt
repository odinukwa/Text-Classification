Feedback The class looks like it is organized well for the most part- the methods generally handle a single task. However, some of those methods are a bit lengthy so could be broken up into smaller sub-methods. The updated code posted in the answer has methods with shorter lengths, except for the principle method . In the original code there is a variable outside the class. Was that just left over from debugging or other code? Suggestions Below are some options for cleaning up the code and possibly making it more sustainable as the number of fields supported grows. Instance variables instead of passing parameters around Because you are defining a class, why not take advantage of instance variables? and can both be declared as arrays. Unless they need to be access outside the code within the class, set the scope to (or if a sub-class needed to utilize them). 

My solution was to "create an array with the start time being the key and the value being an array with the end time and the start time, though if we find that the start time exists in the array as the end time for another element, we update that existing element." 

This could be simplified by simply returning whether count is equal to 9. And to be sure that the count is an integer (which it should always be since it starts at and only gets incremented by 1) use the strict equality operator (i.e. ): 

I wrestled a bear once has mentioned many great points and it is difficult to find other areas that could be changed. There isn't much I would change about the text in the heredoc string. The biggest thing that I really see that could be done differently is that not all variables need to be wrapped in a complex expression - so the curly braces could be removed for all variables except for and . The others can be simplified like . And as I wrestled a bear once stated, it might be simpler to use an array to create the list of theme files. Going a couple steps further with that notion, a functional approach could be taken with array_map(), which yields an array and then that array could be passed to implode(). Notice the removal of the dot items is simplified using this trick from dwieeb at gmail dot com (via the PHP documentation). 

Unfortunately the MDN page for HTMLSelectElement.value yields a Page Not Found message and none of the archive results appear to be any different. Perhaps the only browsers that don't support on the selectList element also don't support ecmascript-6 so it is a moot point. EDIT Now that I think about it, it feels like the current implementation of has multiple responsibilities: 

You could utilize to copy the array, then use to call instead of using the loop. Originally I was thinking that the could be eliminated but there is a need to get a regular array instead of the typed array (i.e. Int32Array). If the array being copied (i.e. ) was a regular array, then you likely could just use - see this jsPerf to see how much quicker that mapping could be. 

Then when looping through the results, you would have to check (in PHP) whether each field (, , , etc.) was greater than (perhaps utilizing strtotime()) 

Setting the titles on mouseover? Why call when the use mouses over each row? This can lead to calling the function hundreds of times when it really only needs to be called once. So instead of the following: 

Why not use arrow function syntax for , and ? Was the goal to keep the scope of the variables inside contained? 

Those variables don't get assigned until the callback for a new event listener for the DOMContentLoaded event is triggered. 

In general it isn't a good habit to be referencing variables globally. Obviously this is in the context of a callback function but there are ways to avoid that. I would suggest creating a wrapper class and storing the connection, table and other info in member/instance variables while calling the method using the array syntax. The Singleton Pattern could be used to create a wrapper class on the database code and call a static method to get a connection to the database, instead of referencing globally. Also, and don't appear to be used after that line anyway... 

Validating data in There are various options for shortening the code in . Two such options are outlined below, though other options are possible as well. The first approach aims for the fewest number of lines of code (while possibly sacrificing speed), while the second breaks the existing validation out into separate methods and calls them dynamically. Validation with Regular expressions for all fields One option is to define regular expressions for each field that needs to be validated. Bear in mind that performing a regular expression match on a string just to check the length will typically be slower than using strlen() but this way you can look for validation rules and ensure the values match the format. In the code below, the ReflectionClass is used to look up the constants in the class definition and if found, will use preg_match() to ensure the values conform to the field's validation rules. You could also look into using filter_var() with FILTER_VALIDATE_REGEXP 

The original code already uses functional techniques - i.e. array.forEach()- for one loop. Perhaps you are already familiar with functional techniques like that and others but if not, I recommend going through these exercises. That inner for loop can be re-written using array.forEach(): 

Yes- as others have pointed out in comments, it seems to be somewhat poorly written. Not only is it difficult to read (as evidenced by your question here), but it isn't as efficient as it could be- each variable (e.g. , ) is an array -and each sequential array grows in size! This is quite wasteful - see this playground example for an illustration. If there are 26 fields per row, that means 376 elements* across 26 arrays. Storing each value as a string (or cast numbers to integer/float values) would dramatically decrease the amount of memory used. While the memory would likely be reclaimed between iterations, it would still make quite a difference. 

I agree with many of the points in Conor Mancone's answer. Sanitation of data is important - one could utilize PHP's Sanitize filters with . However, you did mention you are using prepared statements for the queries, so that should be sufficient if you really want to sacrifice security. And like Conor suggested, try to split the code in that large controller method into separate methods - not only for re-use, but also for unit testing. There are some duplicate lines of code in your sample - e.g. in both cases (ie. when a cart does/doesn't exist for the current session). While it isn't exactly the best example, it partly violates the Don't Repeat Yourself principle. If you aren't familiar with the S.O.L.I.D. principles then I suggest you look into it- especially D. - Dependency Inversion. That article mentions cases where a model constructor expects a database connection (just like your code). 

Generally it is acceptable, though each library requires extra resources (e.g. download size, time, etc.). There are whole websites about removing the need for jQuery, like $URL$ if you were working on a team, some teammates might prefer to have as few libraries as possible 

Without knowing where the element(s) with class name inklogin exist, it can only be presumed that it exists as a child of the element with (or however the controller is named). If that is incorrect, please update your post to include that HTML output (from the ASPX code). Given the presumption above, jQuery can be eliminated by adding (bound to user.ExtraData.userPermissions.notary.allowed) to the input with class inklogin. Bearing in mind that you stated you attempted this, perhaps there was something wrong with the setup. Below is a working example of this: 

jQuery DOM-loaded callback This is nothing to worry about, but the format of the jQuery DOM-loaded callback (i.e. ) works but is deprecated1. The recommended format is simply: 

Initially, I considered suggesting using Array.filter() but then that wouldn't allow breaking out of the loop once a selected item was found. One approach is to use Array.some() or Array.find() (and disregard the return value) with a ternary operator. A variable can be initialized as the first line, then the .some() callback returns the result of setting that variable to either the current item if it is selected, otherwise the return value of the recursive call. 

The performance difference will likely be negligible... This SO answer has a link to this relevant jsPerf test. One might be able to also simplify the function by converting it to an arrow function (like was used on the callback to ). 

This can be demonstrated on ideone.com. When I ran it there, it took 0.04 seconds, even if it has to run through the entire 2-d array. The original code took 0.05 seconds. 

Then you don't need to add an additional function for the triangle. See a demonstration below. Note that I updated the method to utilize instead of a hard-coded value (like Matt Fletcher mentioned in a comment on your SO question, and also did in the jsbin example he made and linked in another comment). 

This makes me worry about the cases where one of the lines contains a hyphen (i.e. ), which would yield an incomplete string - see this playground example for an illustration. Mike's answer is good. I agree the name could be made specific for parsing the error message, and that regular expressions could be utilized, though explode() should suffice. 

Then take the result of calling and check if that result corresponds to a key in - if so, set the message to that message; otherwise set it to the error message. 

Remove closure just to call function The resize callback can simply be the name of the function - i.e. 

However it apepars to never be re-assigned. It is wise to default to making this a constant with until a valid reason to reassign that value arises. Using jQuery and then If jQuery is loaded on the page, then why use , as in: 

And similarly for the other three routes, which reduces 12 lines to 4. looping over the routes The redundancy could also be simplified using Array.forEach() 

Then that method can be used in the method to get the pirateID. It can iterate through the array, looking for the value in each sub-array. If it is found, then it will return the index of the sub-array. 

Using a functional approach, an array method like find() could be used to look for any value that is outside that 0-255 range. If any such value is returned, then return , otherwise if is returned, return : 

The query as it is above might likely take a while, given the high number of records in each table. But as mentioned above, paging would likely improve the situation greatly. 

Edit insertusernamehere pointed out: Perhaps it would be wise to guard against the case where the is . The current code would add that to the array, which is likely not preferable. There are multiple ways to do this, including calling obj.hasOwnProperty(), checking the array returned by Object.keys(obj) does include , etc. 

One could also create a hidden element in the DOM, have update the text/HTML of that element and show it (using - or toggle a class name that shows it), then hide it (using ) when destroying the dialog. That way, the abstracted close function can just utilize that element. 

DOM element references should be cached The code calls each time the form is submitted to access the form fields. Instead of those lookups occurring each time the form is submitted, a more efficient approach would be to store those references in a variable outside the form submission handler. Since those don't change, const can be used. 

Also note that the class for the table row is simplified to simply , and consequently the CSS selector (i.e. ) should be updated accordingly. See a demonstration of this in this playground example. 

And I don't see any radix passed to those calls. Note the documentation from MDN about that parameter: 

But then again, as has already been mentioned by others, performance can be improved by simply returning the number as soon as it is found, which eliminates the need to create/reuse a variable: 

It is fine to do that, but because the form data doesn't get sent to the server-side, you could also use the id attribute on the input instead of the name attribute, and then fetch that element by id. 

While many browsers should still display the table as expected, there may be some browsers that would displayed it in a strange fashion. The unordered list usage (i.e. , ) seems fine, as there is a list of classes to display. There are some handy browser tools for inspecting HTML. For instance, for Firefox there is the Web developer toolbar, which is also available for Chrome. In the screenshot below, I used the Outline table cells to show where the table cells are. Using that, it might be simple to find which rows have fewer cells than the maximum.