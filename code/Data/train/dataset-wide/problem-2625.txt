You split strings in the same way three times - I find it cleaner to extract this into a common method to perform that action. I would extract the scoring of a single title against a specific file name into it's own method - this encapsulates the core scoring logic and then lets you deal with the scoring of all file names in a more condensed way. After you've done 1 and 2 you can apply some LINQ magic again to make it more succinct. I don't have the code of the class but since the seems to be linked to the title name it seems weird that you'd have to pass this in for every file you add. The code would become a bit cleaner if this is tidied up - I haven't that in the below code yet though. 

which reads a tiny bit nicer. You can hide the generic class as internal in your assembly and expose an interface if you don't want users of your system exposed to the generic and non-generic versions. 

As strings are immutable you can't really avoid intermediate store of the data as it's being encoded. As you already know the length of the final string you can avoid the shuffling: 

I would not make this class a static class. If you have a few places where you want to use this then make it non-static and give it an interface like which you pass around. This will ease unit testing and remove an implicit dependency on the static helper class. 

So there is pretty much no performance difference between the two however I think the approach has a few advantages: 

This class name is a bit unusual - sounds like a namespace so you should use a proper namespace rather then prefixing you class name with it. Bad parameter naming - single letter parameter names are not very descriptive. Lack of documentation - shared general utility classes should have xml doc comments for the class and the public methods. Magic hard coded constant here: 

If I haven't missed anything then should be thread safe. Once you have build the object, the is only ever read and never modified. However it relies on the fact that no malicious or buggy client isn't trying to modify in the meantime. Therefor I would consider changing the object to protect against changes. Several options come to mind 

You access after calling . Generally you should cleanup resources in the reverse order and since the mutex been created last it should be destroyed first. You don't check the return value of . It would be cleaner to release the allocated memory and simply return and leave the caller to deal with it. The header file is basically the public interface to your implementation. Internal details like have no business of being there. In the end most variables or field are or or whatever other primitive type is available - what distinguishes them is the semantics the programmer gives them. In languages like C the only real way to convey that semantics to the reader is the name you give fields and variables. This makes the code easier to read and maintain and understandable by others. Short-cut names like or are fairly useless since they simply fail to convey the purpose properly. Using descriptive names is more important than saving a few keystrokes. This code: 

Your inner loop will only ever pull data out of the first entries in depending what the longest in any of the data rows is because you are doing this: . If we assume that each data row has an of length 10 then you will pull the first 10 entries out of the over and over again. This seems broken. So instead of worrying about "should I use LINQ instead of a for loop" you should worry about getting your code to work first properly. First make it work - then make it better. 

First: Don't create a base class with a virtual method which simply throws. This moves problem detection from compile time (abstract member not implemented won't compile) to run time (forgotten to override or accidentally called base throws) - usually undesirable. Virtual method says "You can override me if you want but you don't have to". Now your actual problem. Let me see if I understand correctly what you are saying: 

Update: Actually I just noticed that your implementation is leaking memory: nodes get -ed but never deleted. Which comes back to my first point :) Also you're copying the and elements around a few times when you probably could just move them but I don't do enough day-to-day modern C++ to provide a correct answer on the spot right now. I'll leave that to someone else. 

Update To clarify on point 3 above. I would consider creating an interface which provides the required information about the available menus. Something along these lines: 

Since C++11 I generally prefer to stick to the standard types and etc. as defined in . With custom typedefs like or you can never be sure that the correct type has been used unless you go and check the typedef. Similar seems to be a custom macros - I'd prefer to stick with the standard . I'd say is somewhat non-idiomatic C++. I would expect a constructor instead taking a buffer of type . 

Your current code finds "holes" in the numbering. If that is not required (or desired) then you could parse the numbers of the end and find the max and return max + 1. Something along these lines: 

Classic off-by-one error. You reserve space for 3 additional entries with but you add 4. and will be out of bounds on the last iteration (last valid index is and respectively) expects a NULL terminated array of NULL terminated strings. So the last entry in needs to be NULL (otherwise how would know how many arguments to pass when starting the process?). 

The bit sizes at the top should be rather than . Why are these classes static in the first place? I may have missed something but they should really be normal classes you can instantiate. Which leads to the next point. Both classes offer the same interface so you should define a common interface which both classes implement (which you can't do if they are static). This would allow a user to define a dependency on a for example which allows him to de/encrypt data without really having to care which implementation is used. It would also make unit tests easier at the same time. You repeat a lot of code when dividing the constant bit size definitions by 8. Consider adding a byte size definition as well like , , which is calculated of the bit size. This would makes reading the code a bit easier on the eyes. 

You access the which is the backing data structure directly within () The only public read access to your queue is a method labelled "Do not use" You have a method in your queue as part of your public interface which is commented as "Do not use". Either remove it, or simply state the draw backs so the user can make it's own decision. 

Standard C# naming convention for methods is . Following standard naming conventions makes the code look more familiar to other C# developers (which might be important as you plan to open source it) You are potentially wasting some cycles here by calling again even though you just did it and have the result stored in : 

For it is not entirely clear if for example the end index is included or not for the removal. C# usually follows the convention of specify the start index and the count of how many elements should be removed (i.e. ). I found that approach more robust in the long run. I don't think dumping the entire list content in is all that useful, especially if the list can grow larger it could be problematic.