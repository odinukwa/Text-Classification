Also, newer versions of Java do not require you to specify the type in the on the right side. The compiler is smart enough to figure it out. I would also have made a class variable. In fact, it might make sense to have a class that is separate from the Euler project altogether. That would allow you to create a more general implementation that you can reuse for other problems. This would also simplify which has more of the programming logic than necessary. 

Note that some of the Builder accesses would not be static. These are the ones where different parts of the program may modify what they output. 

This also allows you to be more consistent with the location of your comments, always starting them on a new line. A final reason is that there is a class of bug that comes from modifying a single statement else clause thinking that you are adding to the else when you are really doing something in the general case. I.e. forgetting to switch from the single statement version to the block version when the block version is needed. When it happens, this can be hard enough to debug to justify always using the block form. It's also worth noting that you can get rid of the entirely if you switch from to . Then you can simply always do an . This would also simplify the logic if you modify the with another clause later. Thus it is more robust in the face of modification. 

If we don't mind having empty products arrays in a category, we can speed up the second loop by moving the check into the first loop. 

No function If performance is so important that you don't want to make any function calls in the loop, then 

This avoids the possibility of SQL injection by someone who spoofs your AJAX call. Or use (preferred). 

Note that if you ever add a column to the table, this call will fail until you adjust it to include the new column. If you include the column names, then this call can still succeed so long as the column has a default value (possibly null). 

Of course, if you do that, you need to mark as throwing an exception as well. I tried storing the dictionary in a trie, but it was slower and took more memory than your solution. 

Note that the two size macros return while the function returns a . I don't know that there will ever be a bug as a result, but you should be aware of the implicit cast. If nothing else, note that you are casting a signed value to unsigned. I'm not crazy about the use of pointers here. It's not wrong. It's just that it leads to odd things like being outside the buffer. It also limits you in some places: 

This may not be doing what you want. After doing that, I would expect to equal , as you just overwrote the previous value of with the value of a previously undeclared variable. 

This saves you an entire sort and a lot of swapping. Constant memory You can do it without the extra , but it requires more calculations to get the indexes right. 

You shouldn't have this kind of debugging code if you are sending your code out for review. By the time that you get a review, you should have removed this. Consider writing unit tests to handle this kind of debugging. Then it isn't cluttering your code when you run it for real. I'd consider moving some of your logic to your class. For example, you could replace the variable with a method call: . You could replace your manual decrement of with or . Later you could have a method. Doing this not only simplifies , it reduces repeated code. Assuming you pass the armies as a named , you could say: 

As a general rule, you don't want to do your database connection in your constructor. You should be able to create an instance without having it connected to a database. What you might consider doing is creating a that runs the constructor and initializes it, returning the result. You should pass $_CONFIG into this function and . That way you can connect to more than one database at once. Your version is almost a Singleton but not quite. I don't see the point in things like 

The minutes table is even worse. There's only two columns but you have six indexes (the is an index on ). Three would be serious overkill. 

In general, you should break up your existing code into multiple functions. For example, maybe you put each input gathering into its own function. Or come up with a way to standardize them and put all into the same function. 

See if that allows you to get rid of the breaks after the div. If you have too much or too little space, adjust the to whatever makes it fit. You don't need a four-column indent in HTML. It makes more sense to use a two-column indent. HTML isn't code. You don't need to use a broad indent to force yourself to avoid nesting. In general, your HTML would be easier to read if you made the indent consistent and removed many of the empty lines. 

Class names should reflect what the class does. In this case, I would expect a name like or even . It's not clear to me what even means. Perhaps a reference to the lack of a temporary buffer? Then it should have been . Or just . 

There is a book called Perl Best Practices by Damian Conway that suggests some things to change: Always use parentheses with functions (except builtins), even when they take no parameters: 

I might call this . It doesn't balance anything. It's a stack of all the currently open braces, so call it that. 

Note that I use the block form even for single statements. This helps avoid a class of bug where someone modifies the code thinking that it will only occur in the or but it actually occurs all the time. This can be hard to spot in diff views. It's especially problematic if no one notices immediately. It's easy to skim over the problem. Debugging this once can take longer than a lifetime of adding curly brackets. It's also worth noting that both your original function and this function will if is greater than half the maximum value. 

Note that I also changed the quotation marks. Double quotes allow variable interpolation, which you weren't using. Single quotes are actually slightly faster, so they are preferred for most strings. You may want to add some sort of output protection too though. For example, if is based on user input, you might do 

You'd normally have the left side defined by the interface rather than the implementation. That way, you can pass it to anything that expects the interface and can easily change your implementation at just a single place. It also helps remind you of what is part of the interface and what is specific to the implementation. You can't accidentally access something specific to the implementation through an interface object. 

Your indentation is a little inconsistent. I don't know if that's how it looks in your IDE or is an artifact of the copy and paste. In general code is easier to read when formatted consistently. For example, your declaration of the class is indented more than its fields. Usually the opposite would be true. 

So if the array is full, we can no longer set any elements? That seems like a bug. We should not be able to add elements in that case, but we should still be able to change existing elements. Write instead 

What's an odNumber? Unless odNumber means something, you might as well call it n. If odNumber does mean something, you should tell me so that I know it too. If odNumber isn't a standard name, then I'd much prefer it was written out. Why write out number which should be obvious from the type and leave od obscured? Similarly, do k, h, k_inv, h_inv, and f have meaning? I'd have trouble editing that code, as I have no idea what each of those means. I sort of think that k and k_inv have something to do with each other, but no idea what. Also, why are most of them arrays? This should be understandable from the code, and it isn't here. Your constants are named K0, H1, etc. Why not give these more meaningful names rather than just 0, 1, 2, 3? Of course, this could also argue in favor of moving these out of code entirely. If position is all that separates them, why give them names at all? You're repeating the exact same calibratedValues and overwriting previous values. 

You get two things from . First, it issues a line feed in the appropriate fashion for that system. Second, it causes the output buffer to flush. I.e. it takes everything that is currently in the buffer and makes it output. Sometimes people will tell you to use a rather than an to avoid that flush. If you were going to do that in your code, you'd say 

The basic idea is that we assign an anonymous function to a variable and then pass that to the various handlers. In order to make this work, we make use of the fact that when the function is called, it knows what object called it: . 

Note: I'm not sure about the map key initializations. They get kind of weird since you are mixing less than ranges with single value equalities. You could pull the exceptions out of the NavigableMap and put them in a regular Map instead. That would make the code look something like 

I'd call , . In fact, I try to always name collections with a plural. Also, I write names out rather than abbreviate them. It will make things much easier if you ever have to read the code in the future. 

But you don't need to swap However, we can do it without any swaps nor the final sort. First, create a new : 

I'd write out and . Also, you don't need the . You immediately use string concatenation on it, which will throw it back into strings. So the only thing that the intval can do is hide bad input from you. 

You shouldn't call this variable . Elsewhere, you use to mean the number that you use to generate the other numbers. You shouldn't also use it for the result. I'd name it either (standard for an unknown value) or (each value that you check is a candidate for being the one that you want). 

There is a type explicitly for handling size data. You may think that you are being more inclusive by using , but you are actually moving errors from where the problem occurs to where clipping occurs. In programming, it is generally better to be consistent than right. Because even if you are more right, you will be wrong in your interactions. 

The standard is to capitalize names of user defined types, so should be . I may have misled you in my other review, so I edited it for clarity. 

Notice how the is unique to this page. I'm not as sure of the and tag. That's not the way that I learned how to write them, but perhaps I'm not up on the latest. I'd also tend to break the class and function definitions out of core.php. The usual rule of thumb is one class per file. More than one function can go into a file. You can include the files from core.php. 

I don't quite understand why you are marking it as unvisited. You did visit it. You just found that it wasn't on a valid path. OK. So is not visit status. The earlier comment was wrong.