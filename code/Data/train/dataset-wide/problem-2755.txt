And now you can merge this function with into one if you want. I guess you have read this, but I just want to remind you that all described optimizations are still applicable to your code. 

But I did not expect that the difference was going to be so huge. Just as an example, I implemented the Inverse function through finding matrix E and matrix L, and compare performance by BenchmarkDotNet with square random matrices (N = {5, 10, 20, 30, 40, 50}). 

Another point, that you are loading whole matrix to the memory. It can be too expensive in certain circumstances. I can suggest one stream-based solution which will calculate a number of islands in dynamic manner. This method was discussed here. 

For sure this task can be solved in \$\mathcal{O}(n)\$ time and \$\mathcal{O}(1)\$ additional memory, but extensive testing should be priority number one. 

I would like also highlight an extremely small memory footprint, which was achieved thanks to usage. 

Better to avoid static not-readonly field I don't see any actual reason for you to keep variables Item1, Item2 and OperationString as private static fields - make them as local variables. In general, based on my experience, many nasty bugs (especially in multi-thread applications) happen because of an inappropriate usage of static fields. I know, this problem is far away from this simple calculator application, but anyway. 

Let user know that calculation was successful or not Let's check which error can happen in your code: 

Always check return codes when reading data from files. I suspect this may be the issue with your code "crashing" as even with loading 150k words your code only takes 1.5 seconds with the fix. Another issue is the mixing of with depending on if your word file contains or line terminations. Using mode with will probably result in incorrect parsing when seeking...at least it did with me using VS2010 on Windows7 causing considerable head scratching. Changing the mode to fixed the seek issue but eliminating the seek altogether is a better fix and then the file mode doesn't matter. 

I was curious about the performance of a trie so did a few tests to satisfy myself. First two problems with your original code: 

Your original code (with the two fixes mentioned above) takes 1500ms to load/parse 150k english words. Not necessarily bad. It results in 388k allocations of new nodes. Removing the call reduces this to 1060ms. Loading the file all at once (only 1.5MB) and parsing the string using has a very small performance increase to 1000 ms. Replacing the with manual parsing logic has no visible effect. At this point the only obvious thing left is to optimize the individual allocations with one block allocation (see code at the end). This has a huge effect on performance reducing the loading time to only 15 ms. Hopefully that is fast enough for you.... At this point there isn't anything obvious left to optimize. You could try saving and loading the completely parsed trie but the I'm not sure if you'd gain much with the larger read size involved. Profiling would be your best bet to see what, if anything, could be optimized. 

Yes, we are doing additional LowerGaussEliminationBackward, but it does not influence a lot on performance. Even EPA=U decomposition is better to be done through L matrix. This is the current state of the implementation. 

The main improvement which can be done here - not to use Recursion at all. Solution without recursion 

You tried to implement a linear (\$\mathcal{O}(n)\$ time) solution, and this is the correct final aim, but, I think, you agree that the current solution is hard to understand especially without any comments. So let's start from something easy-to-understand and not very efficient. But this will allow us to check a correctness of your solution in a first place. Brute-force solution (\$\mathcal{O}(n^2)\$ time) It is clear that this task is related to the maximum subarray problem except the condition of replacing by . So let's make a loop through all positions of the original array; on every iteration let's replace the current element of the array by and find the largest sum by Kadane's algorithm. 

Split complex task on simpler ones - one logic per function Your function ParseInput is doing not just parsing, but also reading from standard input. So split this task - ParseInput will just do parsing. 

I would suggest to create enumerated list of those errors, return one enum element as output of your function. 

Another proposed solution is checking number of on-bits in \$2^{n}\$ numbers. By this, you are limiting your solution on \$n<=32\$ and doing \$2^{n}-\binom{n}{k}\$ checks for nothing. 

I think numerically-indexed arrays might also be used to hold the contacts and phone number data nested underneath the contact group. 

Note how I have moved the HTML into templates defined within nowdoc blocks. This approach can allow you to easily pull this content out of the function itself into separate template files that are easier to manage. For example, the function could be rewritten with template-to-variable assignments like this: 

Don't hard code database credentials into your classes as is suggested in your comment. This should be derived from configuration, not in your code. Ideally, these shouldn't be a part of your code base at all, but rather derived from environmental configuration. 

Assuming that you have a unique index on the field, I would just go directly to performing an insert, but looking for insert failure on duplicate index value. I would then apply increment and try to re-insert. Why have two queries in your happy (no duplicate) path when you only need one? My guess is that the number of cases where you need to make 3+ queries to successfully insert a record into the database will be extremely low vs. having to perform 2 queries every time you want to do an insert. 

You have an odd pattern of using these methods which seem like a paradigm from other languages you may have used in the past. has no special meaning in PHP. If there is code you want to be run upon object instantiation in PHP, that code needs to be in the constructor. Why make the caller set up objects in proper state? In other words, consider this using this sort of instantiation: