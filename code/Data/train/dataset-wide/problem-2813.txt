By consistent style I meant something like this. If you use braces when a statement like , etc. contains single statement then use braces for , etc. containing single statements everywhere. 

Firstly there are 2 classes so don't show them as a single code when showing your code. Place a heading with the class name then your code then second class name then your second class's code. That makes it easier to copy paste it into Eclipse when seeing the code. Why have you named the parameters as and and still using the keyword? Why are you making the variable names different in the first place? It just adds confusion. Name them as and and then use the keyword. Period. You are throwing a when is and the message is . That will become confusing... Also you don't need to throw that explicitly. The assignment to will throw the exception and give you a proper stacktrace already without any extra code. The loop can be made a loop very easily and will limit the scope and extra variable ( in this case). Note that you are doing in both as well as . That shows you didn't take the time to look at your own code. You passed to the function and forgot that it is a variable also. If you have any intention of not changing it then make it explicit and declare the parameter as in the method's signature. Also If I am correct then you have used only to make it one less than the so that your algorithm works. That means your function will break the moment you decide the startRange to be anything other than 1. Also using such magic numbers and such variable names as x is a bad idea. Really bad idea. Take some time to refactor the code yourself. It pays if your code is easy to understand by other programmers. Your code can be changed to this and I think now it is much easier to understand the flow of execution of the current program. 

The first parameter is the array itself, the second parameter is the key that you want to group by, and the 3rd (optional) parameter is a boolean that tells the function if you want to preserve the group key in the sub arrays. Examples Let's use this dataset for examples: 

This will encrypt the string, whereas every character will become 6 characters. The 1st 2 of each character are keys that are required to decrypt the letter, and the 4th character is the actual character being encrypted except masked by a random digit (Basically the letter is converted to its ASCII number and a random number between 0-9 is added/subtracted from the letter). The 1st key (labeled prefix) lets the decrypt function know if the random number needs to be added or subtracted, the random number is passed as the 2nd character in the encryption, and characters 3, 5 and 6 are random noise characters. Note: The prefix is generated depending on the ASCII number of the character that is being encrypted. If this ASCII number is below 44, the random number is always added to the character being encrypted, else it is always subtracted. The prefix itself is a character in a certain range, if the ASCII number is below 44, a random character between ASCII and is generated, any of these characters tell the decrypt function to subtract the random number from the encrypted character, else ASCII between and will always add the number. For example, the string "Never roll your own encryption functions." may encrypt to: 

What's wrong? Where? If you catch an exception then you at least add the stacktrace to the printed messages. How? Google search. About catching only I say only catch what needs to be caught. If you are catching exceptions then if you can add some thing in the catch block to recover. If not possible then at least log a error message which does not require you to manually check what went wrong. Now what else can be done better? You can use Java's generics to make your Stack reusable. You should have created a class and then a which used the generic stack class to do its stuff. In your example the thing that you are calling is actually the as per the logic and the class that you have named is a stack. The main class should have just given the string and gotten the result out. 

I am going on with refactoring my code base while migrating from Python 2 to Python 3. I am using generators to make reusable components this time as I am more comfortable with them this time then last time. But there are times when I am stuck at their use. Like below example. These two are essentially same with one infinitely generating and other with a limit. Is there a way to make these as one function? Normally an extra optional parameter as limit will do the trick but with generators I am not sure how to use them. Is there some way to do that? 

So you can pass any array as the first parameter that you want randomized, then the 2nd parameter determines how the data is returned, then the 3rd parameter tells the function how many times to shuffle the array. I've written this because I think it will be useful for people on StackOverflow, I see a lot of questions trying to figure out how to get a random value from an array. The parameter tells the function to either only return a single array element if false, or return the whole array (with keys in-tact) if true. As you can see in my code, I have to check for the 2nd parameter twice to do actions before and after the actual array shuffle. I wanted to see if anyone had any advice or knows of any ways I can improve my code. I've been posting a lot of my code here lately, and I really enjoy how much I'm able to learn from answers. Thanks in advance! 

Similarly move and inside . Remember encapsulation. Ball's location remains inside Ball. You have this in the method of 

I am ignoring the implementation details like it should be . Similarly the second term is with summation running from 3 to n with step of 2. Third term is `6(n - 2). I'll leave calculating the second term to you. Simply adding these 3 terms gives you an program. 

I have started learning Clojure so please share whether there is some easier way to read lines or anything else that can be improved. 

Your style is good. I had a little improvement for efficiency. Instead of using the condition for checking i as an even number you can instead use as a condition for checking i as an odd number. It reduces the number of comparisons and doesn't effect the functionality at all. It might not have the best readability but it improves time-efficiency. A simple comment can offset the readability lost. Also this seems like Python 2 so instead of using which returns a list you should use which returns a generator when you are looping. It costs a little time-performance but is usually compensated by the huge improvement in memory-performance. Also in the function you can probably eliminate the and variable by using something like 

I've recently written a function that allows me to take a flat array and convert it into a multidimensional array by a specific key in the array. 

I've written a simple helper function for my helper class that allows me to check if a substring is in a string. With my function, you can supply either a single needle to check for, or an array of needles to check for. There is also a parameter that allows you to select if you want to check word boundries or not, and a parameter to allow you to choose if the search should be case sensitive or not. 

My question(s): What shortcomings will I have with these functions? Another question I have is; how can these functions be improved? 

I know what you are thinking, it's never a good idea to roll your own encryption functions, but I'm doing this for fun and self-learning. I created a function that allows you to send a string as a parameter and it will return an encrypted version of the string. Here is my encryption function: 

I have not made all changes necessary because many things are not clear. In the typecasting I have left the Model class as it is. You can simply get the class name at runtime to do the casting. A simple example for casting to String class at runtime is . But how will you get the name of the class as String in the sub-classes? I will leave that to you to find out. 

This code is not completely working. is missing. But still there is a lot of effort. In case you are not aware Code review is only for code that works. You didn't add what you were expecting so I guess you were expecting a fix. Sorry. I won't solve the problem but I will add some general things that can be improved in the code. Use for-each loop if you don't need the index Instead of 

I'll start by breaking the code down into different files. There are a many and here. If I am correct that will definitely grow with your project. Having all the constants in a different file is always a good idea if you are considering making it even moderately big. So to your question