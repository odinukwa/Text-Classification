Your MVC usage is a bit skewed. We have the GUI class (clearly the View), MusicInfo (Unnecessary model that the View uses, but is also passed to Midi?), Midi (Controller, but is also directly accessing MusicInfo which should be internal to the View), Instrument (A model) and BeatBoxConstants (More on this later...). In the MVC pattern what is supposed to happen is this: 

Private initializers. I try to not use them if possible, but I do understand that they have a place. When code is short and simple (like this project), then I find it much easier to read if all of the UI components are setup directly in the constructor. I've found that it's easier to understand what is all happening and build a proper UI hierarchy when they're setup sequentially. A little documentation of what is being setup can go a long way as well. Plus, any variables that need to be accessed elsewhere in the class can still be final since they're initialized in the constructor. That said, in a very complex and large class it can be more readable to break apart the constructor work into some private methods. But even then I might argue that your constructor is doing too much, or that your class is responsible for too many things. 

There are already some good answers here, but I want to provide another method for reducing some of the duplication in your code, specifically the fact that you have 1 method per player turn. and . As Austin pointed out, these can be turned into just one method and you pass in the player who's turn it is. But you can also remove some of your statements to make it even simpler. your current board is 3 separate rows, , and . If we make this a dict, we can cut out some duplication. 

At the moment this code will mutate the existing array, so you may want to create a copy instead. Hopefully you found some of this useful! 

Who cares if it's not selected already? Doesn't hurt anything to set it to false again, plus now it's even more clear that each method is an unnecessary wrapper. Midi Class 

Again, maybe just personal preference, but I find this approach a bit easier to see how the hierarchy is being built up. 

Back to the class, and the GUI class. Do away with . I view your UI as having rows. Each row is for an instrument, and each row has some checkboxes which represent beats. To model this, we can make : 

Use static variables that are already part of the Javax MIDI library. For example, your and magic numbers can be replaced with and respectively. This applies for the message as well. I'm not sure what that's for or why it's necessary, but I'll take your word for it :) Similarly, that magic can be made a private static final variable on the class. And the . I'm not sure what that does either. Velocity? Let's go with Velocity. 

In the next section you compare them to each other, you could simply then unpack these into variables like 

so all I know here, is that it's a list of Strings that represents the ships that player A has. But to find out how it does that, I need to go look at where and how it's used. So I search through the code and find this line 

} Now I'm sure someone who know a lot more about or could give some basic examples of how to implement those, but lets look at how it could be instantiated. 

Keep in mind these are only my suggestions. Take them as you will, and hopefully at least they will teach a bit about good design patterns! 

BeatBoxConstants Constant Class (of Interface) are a bad anti-pattern. Instead, we can easily just pass in the number of beats to the constructors! 

In an example workflow, let's say we're playing a track and click the reset button. The view added a listener to the reset button, so that listener will fire. The implementation is simple and only notifies the views listeners the the button was clicked (the view is supposed to be dumb, remember?). The controller now is notified, and it is smart so it will know what to do! The controller takes charge and stops the sequencer (updating the state), and then tells the view to reset itself. And that completes the cycle! (Interact with view -> view notifies controller -> controller modifies state -> controller updates view) 

Now, this class has the single responsibility of representing and maintaining this list of items. and your class can just have an Inventory 

I've used a larger number of smaller classes here. We now have the benefit of easily being able to add a new to our game, we just make a new class, implement Location, and say what should happen when the method is called! Of course if you needed to do more things than just you , you could add new methods. But I'm a big fan of having as few public methods as possible in any given class. Your logic for checking number of tiles to towns etc. could all be done in the class. In your example, you have some logic around maintaining knowledge about whether or not you can drink from a location, I'll just add one more quick example about how you can do this, let's rework the class just a little bit. 

Now, you might be wondering how that helps at all. For one, it abstracts out (to a reasonable extent) all of the work needed to create a row, add the label, handle changes to a checkbox, etc. This also helps with extensibility. Say you wanted to add a button to your app that adds a new instrument (or even one to delete). Previously you would've had to do a bunch of work to update and maintain that 2D array of objects. Now, all you would need to do is add a method to your UI to addInstrument(), which would create a new InstrumentRow instance and you're all set! I won't go into much detail on this, but one thing that is also a good practice is to separate your view into an interface and an implementation. The implementation would be specific to the UI framework that you have chosen. For example: 

this is a violation of the Tell don't ask principle. Here, you are asking the object to tell you what its health points are, so that you can perform some calculation with that result. Instead, you should tell the object what you want to know. For example 

is an example of a particularly bad offender. If I have a class, and it has an member variable. We know that a will have an , you don't need to write a comment saying what the code is already telling us. Let's take a look at your class. If we look in the constructor, we can see that the constructor is causing some side effects. In this case, it's printing to the console. In general, when I construct an object, I assume there will be no side effects or other unexpected behaviour. It's perfectly reasonable to provide a method to do this (in your case ) but I would not include this in the constructor. Consider making your classes immutable where possible Unless you need to provide getter and setter methods for an instance variable, you should just leave them out entirely and make the variable final. I think here is a good candidate, a getter seems reasonable, but I don't think you'd ever really need a setter. In a standard RPG or game, the player or enemy names don't change. They can be marked final. 

Added bonus: You can select new check boxes and the player will now start playing the new track without having to pause and restart the player InstrumentRow.java 

MusicInfo Class Long story short, you don't need this (I also think there's a better approach than using a 2D array, but for now, let's assume the array stays). The 2D array that's being wrapped here is a UI component, so it can easily become part of the GUI class. The methods in this class are just syntactic sugar, and really don't provide any additional benefits. Plus: 

can be removed Instead of using a for loop and iterating with a counter, you can use the built-in iterator and iterate over .