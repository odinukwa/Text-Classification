I don't think you are using a correct approach here unfortunately. Due to time constraints I'll focus only on your main question, while the rest of the code may be worthwhile to review aswell. You have a method called , it is expected to either return a or to signal that it failed to do so. It is not expected that it will abruptly kill the program. I'll say upfront that I am not much of a fan for throwing checked exceptions, but I think it is appropiate in this case as you are handling user input. It is appropiate to wrap most of the exceptions into a general (checked) wrapper exception that propagates the message, I am talking about and here. It is however not ok to catch , as this will catch all exceptions, also runtime exceptions, hence hiding programmer errors. While this is not a big issue in your current setup due to several (lucky) factors, you should not be doing it ever. One last piece of quick advice is that I would expect the method to have a input parameter, instead of hardcoding it. Even better, you should go for the class which supersedes the class. 

I decided to take on the FizzBuzz challenge with as twist that I would use Java 8 concepts to make it a bit modular, yet still let it be a short, readable and understandable program. This in contrary to some gem I found on the net: FizzBuzzEnterpriseEdition The problem description: 

Also normally I would create all random numbers with one instance such that you could set a single seed in your program if you want to observe the same behavior. In this case this would be less easy but could still be achieved with a variable like . You should deal with as less static variables as possible, meaning that your static class really should be a instance and that the variable should be local to that instance, ideally you should be able to pass along a scanner by for example doing . In the method you could use as loop condition. In the method you could out of the loop, with the following code: 

Furthermore, you should also be aware that your solution only deals with integers, whereas clients possibly may want to use or , you could consider implementing that. You may even offer to make it generic over and require a that can be used to increment , and a that can be used to test if is divisible by another . 

In reality there can be many pages, areas, paragraphs, lines and words. I have only showed one of each here for simplicity and because I cannot disclose full files, also note that the content of the word shown here is " ", a string of one space. A minor defect is that there are still some TODO comments which I need to transform to actual loggers. First the structure: 

Please keep in mind that I am very new to Haskell, having only played around with it maybe once earlier in my life, though I do have some functional programming experience. The list of dependencies is the following: 

As you can see I'm also injecting a instance as bean in order to facilitate running the server on a different timezone if needed and to facilitate unit testing dates. The repository can be found here. It also includes lots of unit tests, but I'm not posting those up for review right now, I might do it at a later point in time or if someone makes a special request for it. 

In addition to the existing reviews, I have some remarks about the used style in combination with Java 8 that would lead to less lines of code and hopefully more maintainable code. Using 

Use diamond inference where possible, this means that for example can be written as . Code against interfaces instead of against classes. Take your again. Nowhere I see a requirement to use a here, you just want to use a list, so only constrain yourself to writing: . This allows you to change the exact type of at a later point. I see that you only loop over the , you have no special requirement to use a linked list, consider using the more or less default , which provides constant lookup times and generally performs better. In your case the performance seems to be equal as all you do is, underlying to the enhanced for-loop, use an . Consider changing from using the API to the API at some point, it offers more future-ready changes and will co√∂perate better with Java 8. Prefer a class that receives print statements over directly printing to during processing. In bigger projects this usually is a logger framework, to which you then attach writers and also file writers for logfiles. In your case you may use a simplified version of this. A is old, very old, use the nowadays standard called , with as default implementation a . Some method names/semantics may have changed, but they both serve the same purpose. Do not catch all exceptions with , you may have confused yourself here, but this catches all exceptions of type (so all), and gives the caught exception the name . But even then, catching s is not good and you should just let them fall through such that they terminate your program (or thread), so you can actually fix the issue, rather than a Cannot make prediction. message. 

The usage: Note that the is not complete (but working) yet, I will put convienience methods in there once I need them. 

For our Cardshifter Project we wanted to be able to load card definitions from file. A card is defined as: 

The code in general looks quite good, although it may be slightly over-complicated for the problem it is trying to solve! You can improve though by using a rather than directly adding two strings together: 

I have written a few simple-to-be-used methods in Java 8, and am wondering what could be improved upon those: 

In general it looks good, now going through the code to also see if it actually is good. 1. Exception messages Your exception messages should be made clearer, an example of them is at the constructor of . If or , we get echoed the value of the variable back, but no indication whatsoever to what is actually wrong with it. It would be good to see it included. Also is most likely not wanted, is it? Lastly on this point, I would prefer if you only use once, as the case is here. If it would be used multiple times, then there should be a simple check at the top of the method, to ensure the check only runs once. 2. Initialize objects as early as possible. You are initializing both and in the constructor, and not at declaration time, which looks suspicious. They do not depend on either or passed into the constructor. Hence I see no reason to initialize them late. This prevents duplicate code when adding more constructors. This also holds for in . 3. Try to use more meaningful variable names. As a reader of the code, it is very hard to get the meaning of in , after some thinking (which is a precious resource) I realised it was meant to be temporary queue, just name it then. 4. Consider factory methods. The lines: 

When an item succeeds to 7, it can be converted to a "32DR crystal", which can be sold. When an item fails, it will produce 1~15 Dazzling Ores and a Level 100 Chip. If the upgrade that failed was from 6 to 7, it will produce 2 Level 100 Chips. Upon failure the item is lost. To increase upgrade success, you can add 500 Shiny Crystals from upgrade from 4 to 5 onwards, which will double your success chance. My goal is to calculate the most profitable method (possibly negative profit, also called loss) given the price of the 29 DR item. Implementation-wise, I have decided for now to let it run on the console for ease of use and with a few variable parameters hard-coded. they resemble the price/value of an item in the game and that, because it is dependent upon players, may vary from day to day. It's just for personal use, so I do not think it is bad to recompile it every day. In the future I want to support multiple types of items and goals (upgrade levels) though, where the following details are variable: 

I am aware that the with a as argument is obviously much nicer, however for convienience the single-argument version with only a function is much better. 

Omit and keyword from interfaces, it is implicit. Be consistent with spacing out your syntax. You for example have , whereas it should be , some strings in your program also could have spacing fixed. Don't start instance variables with , perhaps this is common practice from another background, but not in Java. You seem to adhere camelCasing elsewhere though. Make parameters where possible. It gives compiler errors if you accidentally change the primitive or the reference to an object. Use generics, in you specify as , you want to use generics. If all types of objects can be stored, then use . I see that you have forgotten to declare the type of the variable, using Java 7's Diamond Operator, it would be , also notice that I define only as type, as you always want to use interfaces to declare types if possible. Give variables descrptive names, and are not descriptive. Lastly, I would consider using a for the in , the name implies that you want a queue implementation, yet you are using a list implemention. 

Some relevant information about jinput can be found in this topic rather than in non-existing documentation. With that said, I have implemented the following: 

where is the input. Then you can save both one line per method definition you currently have, and more importantly you abstract away the logic into your helper method, so you cannot make a mistake in the logic of one of your implementations. 

My goal with the following code is to provide an extensible class that can be extended in order to read log files and transforms them into meaningful output. I'd like to have comments about the code itself, the test code, the javadoc and the overall structure. 

In the implementation every card gets mapped to an in our Entity-Component Framework, however that is to be considered an implementation detail and is not the intended focus of this review. This code is also accompanied with tests, but as there are lots of tests, they require Entity-Component Framework knowledge and are all accompanied with their own XML file, they are also not included. You can review all code at our Github project page on the develop branch and the tests can be found here. Then now follows the implementation code: CardLoadingException class