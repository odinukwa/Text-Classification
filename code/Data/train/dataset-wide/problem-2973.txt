Personally, I think the flag is not the best idea, or at least not, in the scenario you have added it, as it looks like a global variable. The scenario you have set up now, poses a few problems as you present it, nl: 

This doesn't interact with the request at all, at most, the user will see something on his screen, however the response will still be running, and your code may eventually react on it, so you are pretty much unsure if it really worked. But don't forget that any callback you create should be canceled in the end (through (see PatrickRoberts comment below) or ), so that there is no need for you to check if a response returned ;). I personally still prefer the and methods to do that. Suggested rewrite ES5 

for both if blocks. But that should not be the end, you might as well extract the code that checks if the keyword exists in the array, and the extraction of the keyword. In the end, the statement that you wrote can be reduced to this (now I think I understood your code while refactoring it) 

This is really one of the best examples that should be refactored to a method, and that could even be split into several methods. You have to ask yourself, what is variable, and what is fixed in my piece of code. Well, if you look at it closely, both parts of the condition seem to check if a keyword exist in a certain array, and in case it does, it will take the found element of the array, and split the words, and then it will check if these words are specific words, and if they are inside another array already, if not they will be added. As a side note, this part of the code I have the most questions about, simply because I didn't actually step through the program yet, and I cannot seem to match the code with your specifications, yet, so I won't change the functionality here, I will just show how it could be extracted to one or more functions Lets take a single statement to begin with, like this one: 

async/await implementation Since you expressed interest in loading through Promise, I thought I would offer 1 version that loads the promises through the / pattern. It's important to note, that this pattern is not fully implemented in all browsers (eg: Internet Explorer). As you didn't specify if ES6 would be viable for you, I don't know if it fits your use case, though you could use babeljs to transpile it to browser compatible JavaScript. 

From the demo page, I have to say, it looks very nice. I am very curious why you do not use the constructor to call that seems a bit verbose for any user, neither does it look very good to use as it is not a constructor in the strict sense, you don't even need it. For a detailed description, please find it on MDN, where this explanation is of importance to you. If you return anything else but undefined, you will not receive a new Slider object, but just the returned object. 

I have a while-do loop nested inside a while-do loop in my program, due to it needing to iterate in two dimensions through an array of arrays, and originally my loop looked like this: 

I'm not a php expert, but from reading up on the documentation it appears that it may be possible to insert additional from/to addresses using the "Additional Headers" field on the function. Since you're using a regular string concatenation to insert your POST variable into your additional headers field, that is very well possibly the vector for attack. The example in the php documentation demonstrates this. 

I have a situation where I'm stitching three different unions into a triplet tuple for building a map/dictionary of strongly typed values keyed on a string. One of the union cases is very large, the second has three options, and the third has only two. Right now I loop through the large with reflection, and have six yield statements to handle the combinations of the second and third unions. My code works fine as far as I can tell so far, but I don't quite like having in my code six times. How can I better represent this situation? *If needed I can post the code for the unions too. **Note that is just a string. 

You use a lot of nesting with complex if statements, which complicates the flow of data in your code, which was mentioned in other answers that people have given you. I'm going to update my answer as I see more places to optimize, but for readability you might consider doing following one of my favorite patterns for dealing with lists of objects. I use lists. In your code you have these columns that you know you want to remove. You can construct a list early on in your code to hold these columns: 

I really feel bad about recommending this, but based on what you're doing you should investigate the use of Webforms in ASP.NET. Webforms are the most straightforward way to provide easy CRUD operations on a database in C# while exposing the operations safely to the user. You also will work entirely with C# and the ASP.NET elements in html, so there's no need to manually use javascript with most basic tasks. If you want to get more advanced then you can go with MVC5 in ASP.NET but that doesn't have the same level of builtin controls, data table displays, and similar that webforms has baked into itself. MVC5 does give you more power and flexibility in return, but if you need to get something done in a hurry or in a very basic form then you'll probably be fine with Webforms. The problem with webforms, and why I feel bad recommending it, is that it tends to not encourage good N-Tier design because it both allows you to do things like embed SQL queries in your views (which is blasphemy) and a lot of the examples display exactly that behavior. It is possible to setup a good distribution of responsibilities into multiple tiers with webforms, which is what I'm doing at my current job, but it doesn't do a great job of encouraging good design. That being said, it does encourage getting things done in a hurry, so that can sometimes outweigh the drawbacks. 

The above is extremely abbreviated (for example, ClientManagement actually has about 20 Objects, 20 Managers, and 20 DBs), and there are other base folders like EmployeeManagement, InventoryManagement, etc. Each "Management" base folder corresponds to a schema in the database, so that for example, in my SQL Server database, I have [myDatabase].[ClientManagement].[Clients]. Each class in the Objects folder looks something like: 

The TextBox1 in Processing.aspx is where the progress update goes. Now let me just point out the dirty trick and the part I don't like right now. In Processing.aspx, there is a meta tag to refresh the page once per second. How it works (summary): When the process starts, a Session variable called ["Running"] is set to true. When the process ends, Session["Running"] is set to false. And since Processing.aspx refreshes once per second, what happens is it saves the current contents of TextBox1.Text to another Session variable called ["TextBoxContent"]. And then the Page_Load method for Processing.aspx fills the TextBox back up with the previous content, and adds a period. So the output will begin simply looking like "Process Starting", but after 10 seconds it will look like "Process Starting.........." (one period per second). How it works (details): The process begins in DatabaseChecker.aspx's Execute button: 

As you can see, my web application is broken up into different layers which makes organization a breeze. But, I feel that currently I'm not utilizing the power of layers --- the logic layer does nothing at all but just forward the calls to the DB layer. I think part of my problem is that I simply don't know what I CAN do that is useful. Currently my system works and my goals are achieved. Some people might say, "then what's the problem?" And while that makes me happy (it means I've done my job with some degree of success, horray), I want to know more advanced techniques. In the article I originally linked to above, it uses the example of checking roles in the logic layer. In my case, I don't need to do that. We're checking roles pretty much on every action the user takes at the page level. If I can't figure out something else useful to do at the logic layer, I am thinking about cutting out the logic layer all together, since all it does is forward calls anyway. This would eliminate some .cs files and make it even easier to navigate/maintain. Ideas, thoughts? What can I do better? What has worked for you? Are there any things related to layered web applications that you know now that you wish you knew when you first started? 

First off, let me say that this article pretty much changed how I program, for the better. Until I read this article, I was a spaghetti programming master --- if there were awards for crappiest, least organized, and impossible to read programming, I would have been world champion. But that article taught me to utilize classes (mind-blowing, I know), rather than just copy/paste the same logic around to the necessary pages. With that in mind, I modeled my application (described below) on the examples found in that article. I highly recommend that article for anyone else who's looking to make the jump from newb coding via facerolling on the keyboard to newb coding with some thought behind it. I've been simultaneously building upon and maintaining this web application for a year now, and I feel that while the layered approach has helped me to stay more organized, I'm not utilizing very much (if any) extra power from having layers. In my web application Project, I have a folder I created called Classes. The structure looks like this: