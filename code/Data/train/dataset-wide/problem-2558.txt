doesn't appear to be used after it is assigned to the empty array. I would hope there is not a method called after that which references that variable globally...Presuming that is the case, that variable can be removed. I would question whether really needs to be defined, since it really is just a shortcut to calling . If there were more lines to that method, it was called more than once or the interface required it be implemented (and a different implementing class did something different) then it would obviously be good to keep. 

For a single page application, there may not be a need to have more than one function called during the event, but as applications grow larger, there may be a need to have multiple. That approach (with supports multiple callback functions to be run. Also note that the documentation for beforeunload states: 

After reading over the code snippets you included, it looks pretty simple. The only concern I have is that if the switch statement reaches the default case, then is called , and then just after the switch statement, is called... If a status is sent, then it doesn't seem appropriate to send the response data (even though wouldn't be assigned in the default case. One other improvement I see is that the response could be made consistent by moving that into a function and calling it in the two places where a response is sent. So in the example below, that is defined as the function inside the callback to , or that could be moved outside the callback and would then likely need to accept the response object as a parameter. 

Feedback The code seems to work okay, though it appears that the counting is off because of the comparison operators used (i.e. ) and the initial value of the indexes (e.g. ). Use Greater than Or equal to (i.e. ) in order to accurately count with the correct number of seconds per minute, minutes per hour, etc. Your code doesn't display the value of but I added it (see code snippet below) and noticed it was going between values of , and . Suggestions Pre-increment instead of post-increment and use immediately after Instead of incrementing each value using the post-increment operator and then using it, use the pre-increment operator. So lines like this: 

Output from keys Because of the changes above, the keys are the pairs so use list() and explode() to unpack the pairs. 

Since the code already contains arrow functions, continue with es6 features and use let and const instead of var unless browser support is an issue. For reasons why, see this answer on SE and its siblings. For example, the first line of the method could be changed from 

Scope of Variables Unless is used outside of the code in your post (which would be grounds for making it off-topic), then you should declare it as local to the function using (or if you want it to have block scope. The same is true for and . That way those variables won't be global, which could cause confusion if you did use to declare a variable inside a function but not before that. For more information on that topic, see the section Keep your scopes close and your scope even closer on this page. Accessing DOM elements multiple times via DOM lookups are slow. It is wise to cache them once in a variable and then refer to the variable when needed. This is also mentioned in the aforementioned article under the section Cache DOM Lookups Those lookups could be added above the function (possibly assigned in a DOM ready function like jQuery's , though it is argued that isn't necessary with modern browsers): 

And then it can be referenced with-in the constructor to add the image and counter elements. If the value was assigned at the time of declaration, then const could be used instead of var. 

Gerardo pointed out the mix of and usage. If you wanted to keep the strict usage of then that container could be declared using . Then after that, a function can be defined that sets the opacity 

Return value from is a boolean The code in method calls when the parameter is an array (). When that happens, should be assigned a boolean. After that, the return statement calls but that should error because it would be calling the method fails() on a boolean... thus leading to that error you saw: 

Feedback The code looks decent - I don't see many repetitive DOM lookups and style updates (refer to Stop Writing Slow Javascript for more context). I also like the use of the spread operator and functional programming techniques (e.g. ). Though actually I do see that function does a DOM query each time to set the active class on the clicked item and clear it on the other buttons. I would advise using event delegation to look for clicks on the buttons. Instead of adding an attribute to each button, use data attributes like in the HTML below. That way the logic to filter items is taken out of the markup. 

Specify context I support Blindman67's answer. If arrow functions were not supported by all browsers used (e.g. IE - but then again there is little support for Angular in IE anyway) then you could also utilize Function.bind(): 

For the most part I would say Yes. However I do notice that the convert functions create a local variable (e.g. ) and then if the input value isn't valid, an empty string is returned. One could argue that the valid input check should come before declaring the local variable, lest memory be wasted (though in a small SPA like this it will likely be negligible). 

You default construct all nodes upon construction of the stack and destruct them when stack is destructed, in which case is unnecessary. One can just use an array of nodes and pass it to the unique_ptr. In this case you also don't need a destructor for . Obviously that only works with default constructable 's and makes only sense, if T doesn't hold any resources after it has been moved from. You actually create and delete objects upon calls to push and pop, in which case you have to use placement new () and manually call the destructor (not ) 

There are a few simplifications you can make: Unused variables The value of isn't used anywhere, so you can just get rid of it it. Simplifying outer loop: 

The only thing you share among the codes is just define it as an atomic (). Even Better: Don't share anything: Let each task use it's own hit counter and sum them up at the end (easiest way to do this would be to use std::async). Create and seed a separate random number engine for each thread 

There is no need for , just put the (inverted) check into the loop condition (this will then also enable you to process empty lists). You can write your outer loop as a simpler (semantically equivalent) for loop: 

Your code doesn't run in parallel at all! Locking the mutex at the beginning of means you are always only run one instance of at the same time. You are passing a copy of the same random number engine to each thread. As this is only a pseudo rando number generator, all threads will operate on the same sequence of numbers (you are doing the same work multiple times). 

Whether that is easier to understand than your version is up for discussion, but it should be a little more efficient. can be simplified by using an STL algorithm: 

I don't think there is anything wrong with your general approach (or at least I don't have a better suggestion). On an implementation level I've a few suggestions 

As mentioned before, I'd replace the class member with a local in and pass the array as a const ref parameter to . This gets rid of the mutable problem and might even increase performance. I'd write the function a little different: 

Aside from general advice of how to improve my class (I bet, there is a lot), I'd especially like to know if 

Upon construction, no actual nodes are created, but only properly aligned memory is reserved, on which you later call the assignment operator. I believe (although I'm not sure) this is OK if T is a POD, but if not, then (move) assigning values to them is definitively not allowed, because custom move assignment operators usually assume that points to a valid, initialized object. So in general, I see two possibilities: 

In response to the comment about multithreading: You can (more or less) trivially parallelize by letting each thread generate the new cells for a slice of the world (e.g. a quarter of the rows on a 4-Core machine). There are many parallel loop implementations out there that can make that Task even easier. Obviously this is only sensible for very large grids. 

On my 4 Core machine with VS2015U3, this reduced the execution time from 120 to 20 Seconds and reduced the error roughly by a factor of two. Small style tips: 

The general push/pop logic of the stack looks fine. The memory management however is somewhat flawed: Missing Destructor From the perspective of the unique ptr, the stack doesn't contain Nodes, but uninitialized memory (effectively a char array). So at destruction of the stack object, it won't call the destructor of the individual nodes, which in turn won't call the destructor of . In order to correct that, one could write a destructor for that traverses the nodes and manually calls the destructor on them. Assignment into uninitialized variables 

I know, there are a few implementations of immutable strings out there, but my focus seems to be a little different. My goal was to have a type that provided value semantics, but didn't incur the cost of dynamic memory allocation when constructed from a string literal which is already guaranteed to exist during the whole program runtime. After refactoring, I ended up with two classes: 

For some time it has been bothering me that there is apparently no way to directly initialize variables from input streams (something like ) My solution is this: 

Padding I just want to point out that aside from the false sharing between and , which is avoided via padding, any thread calling push or pop will access both variables anyway and afterwards you still have false sharing between the actual nodes. Performance This code contains a lot of micro optimizations, which might or might not be worth the effort if the code gets reused in different contexts (its definitively not worth for handling a worker pool). However, I'd suggest, to write at least few small benchmarks to ensure that those optimizations are in fact improving and not hurting performance. Also I want to repeat my warning from the comments that for some reason, VS2013 (and also 2015RT) seems to be unable to implement in a lock-free manner, in which case the whole structure is probably much slower than a normal stack with a mutex. 

Using STL algorithms If you want to advance an iterator by a certain number, you can use std::advance instead of a loop: 

Const correctness: A lot of variables are only initialized and never changed afterwards - make them const range based for: You could use more range based for loops (e.g. when joining the threads, creating the seed, or some loops that go over the array of the random number engine.