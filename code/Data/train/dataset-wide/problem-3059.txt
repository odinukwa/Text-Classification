And, no, there's no easy way to have something more dynamic that , unless you have a specific use case in mind (and then, you would use an interface, but this is out of scope for this question). See this for a detailed discussion on why Go doesn't have generics for now. 

Replace all by . When you're not using the second argument, you don't need to discard it explicitly. 

It's very simple; what you're saying here is "give me a , I can give you n random values from it". Option 2: 

why not: log.Println("fetching from hacker news", fmt.Sprintf(newsUrl, i)) Using everywhere makes your code not very resilient. Maybe it's worth looking at "what can fail for transient reasons" (typically, database transactions…), and re-try the thing that failed a few times with exponential backoff. There's lots of whitespace in the "what stores the data" part, which isn't very idiomatic. Empty lines in functions aren't really frequent. 

(That said, I'm not convinced it matters — the compiler should probably optimize this anyway.) I tried it and was very surprised to see that the benchmarks were still very poor. Turns out, you called the wrong function in your benchmark :-) calls insead of . Retrying it with this fixed leads to the expected result: 

It doesn't seem that the library has a query builder or a specific type. So building a query in an idiomatic and readable way should be done as you would do for a normal string, and that is using the package. This will allow you to get rid of many code smells: 

the line containing your query is long and not easily readable, maybe skip more lines you can write the skeleton to your query once, instead of using successive appends — this is also more efficient if you have many services the call to can be avoided using a simple condition in your template you can replace directly by its value, that you previously computed in your Go code and you can get rid of the variable that you pass to & , just do all the substitution logic in the go code. 

Other than that, if you are using Java 7 or 8, you should be using try with resources instead of try-catch as that is less error prone. And instead of returning null, you should be returning an empty collection . As far as I know, returning null is not a very good approach. 

Naming Convention: , doesn't make sense to me. If I were you, I will be making them more readable e.g. etc.. But this is just my opinion. Your default constructor , you don't need to do as , and are object members so these will be auto initialized as , so I don't see any good reason to do . 

As far as I see, your code is well written but just my two cents. Appending @Malachi answers as you don't need the nesting. May be he forgot to tell about: 

As far as catching the exception, an advice, always catch the specific exception, not the generic, so you should be catching or instead of . Also, it's always a good idea to log exception somehow. 

As far as OOP paradigm is to be considered, I do not see any problem with the implementation and as per my knowledge and experience of OOP, I can not find any mistake or make any suggestion for any improvement. Well, here are few pointers that I will consider if I will implement the same thing: 

Web Client implementation doesn't need the actual implementation, if the service is hit able, it's client can surely be written. 

I want to know the problems that I might not see at the moment but can occur in future? Also, is there much better way to improve this piece of code with respect to multi-threading? If someone here can help me cloning or downloading the whole project and suggest about the overall architecture of application and multi-threading, I will be very very thankful. But since codereview is only to review some particular piece of code, so here it is, I want to review. 

From the algorithmic perspective, I'd like to suggest another solution (regardless to Python as a language). Here goes: let's assume that all items in the given array are different. the other case has a similar solution, so let's focus on the algorithm itself. 

The math behind this function is not that simple, but it's not that complex, too: You should calculate the shell's index, according to , , and . Then you should calculate on which side of the shell are and ("North", "South", "East" or "West"), and calculate the "distance" (in steps) of the current item from the shell's start position. All this is pretty much mod calculations. Once this method is done, you could simply write a nested loop (N by N) with and , and print the function's value, without having to populate a matrix before that. The calculations in the should not take more than O(1) (in space and time), so eventually you could have a solution of Θ(N) in time, and O(1) in space. Just an idea, though. 

Having so many operations -- seems like you'd want to use some kind of a factory, injected in the constructor, or the instances themselves injected in the constructor, instead of constructing the classes inside the constructor. 

Find the nearest number, in terms of distance, from the array to the given external number (20). sort the given array. find the value in (1) in the array. it can be done using a binary search. now, to the main point: the next value would be either to the left of the current value or to the right of the current value, since the distance is now between the next value to the current one, and the array is sorted (!). so all you have to do is to hold two additional indexes: inner-left and inner-right. these indexes represent the inner boundaries of the "hole" that is being created while constructing the new list. 

I believe should return something. The returned value of might have a special value of in case that one of the s calls failed (this scenario should be covered by the code). In the implementation of extend - consider using instead of and manual copy. If you insist on perhaps using might be more elegant than a manual copy. I'd move magic numbers to s: Initial Capacity (hard-coded to 10) and Growth Factor (2). Alternatively, they could be parameters to the function How would you free this struct? Perhaps you should add a "destructor" to be called before calling with the struct pointer as a parameter. In terms of functionality, other than printing this "array", how would the consuming programmer could get (or set) a specific item in this "array"?