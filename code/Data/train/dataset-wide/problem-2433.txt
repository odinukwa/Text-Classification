This way you can test the parser independantly and exchange it later without modifying the class that can remain as simple as: 

As it's already been said, using as a parameter does not have any advantages here but... it can be used as the new C# 7 feature with return values and local variables which I find allows us to greatly improve the readability of the algorithm. By using it this way we can now return a reference to an array item and also use local variables that we can overwrite. We no longer have to work with indexes everywhere. Setting the variables will set array items. 

This is another scary part because it does so many things that ASP.NET actully should be doing. For example the should probably be handled by an authorization system like Implementing authorization in ASP.NET MVC. It should also not be doing any logging. All this should be handled by the . Then there is also this: 

Additionaly I had to create a new small service to be able to fake the file-system and simulate missing or invalid file. 

I wonder that the linked SO question does not mention the method. With it you can randomize the list in place by creating a custom . You should also return the new result so you can chain other extensions if necessary. 

This method doesn't require the variable. You don't store the result anywhere so you could simply call inside the just after you create an event: 

Currently searching for a persons would be faster because it is a key in the dictionary. You could add another dictionary that maps numbers to persons and make the number search as fast as person search by looking at the key instead of searching all values: 

There is also a secondary problem: there is no constructor accepting any s so every time you create a dictionary from something non-dictionary you often end up looping twice twice over a collection (expecially with types derived from a dictionary) - and you cannot easily work with tuples. I tried to fix it with my own implementation that is built on top of the normal dictionary. It adds two es to add the key to the message and it adds constructors. 

I've been experimenting with other designs and after a couple refactorings I completely rewrote the API (and of course incorporated the suggestions too). This is how it looks now: 

Collision detection You can calculate the collision much easier with the structure. Use the method if you are interested in single points that 

and hit if it worked you'll see around each formula in each cell and the results in the second table. 

The is a very helpful feature. But creating those strings is an extremely tedious task. I wanted to make it a no-brainer so that I can create them quickly and at the same time make sure that all of them are formatted the same way so I created the following tools. 

this one should not. needs to be used with a return type. If it's then you should use just . You may/should use only for event handlers. 

The class should be abstract because it's rather unlikely that you'll have an instance of it. Consequently the constructor needs to be . The two properties this class it provides should be as you set them in the constructor and the derived classes call there's no need for their setters to be . Actually you can remove the setters if you are on C# 6. The same rules apply to other classes derived from the or other items. 

You should stay consistant with the variable names. The xml element is named but the property is . Pick one and use it everywhere. Otherwise you'll need to explain and think all the time what was it for. 

You should really split this or give them proper names like . How do you know which one is it actually? I think you should create a new class and derive the etc. from it so that you can use a dictionary or an array of elements. 

In order to make it work and make its usage easier you should get entire s from the first query instead of just the ids and you'll need a custom comparer for the that you can even reuse for the extension so you can replace the 

Consider splitting the method into smaller pieces. Each piece should configure only one entity at a time. You could write them as extensions so that you an chain them: 

This means I'd like to create the downloader first and then tell it what to download and where to save it. I don't want to create a new downloader for each url or each download directory so the actual interface should be simply: 

We add the suffix to methods that are marked with the keyword. This is a naming convention that as you'll see in a moment Entity Framework follows too. 

Your assert extension is not a real extension yet. But with the new MSTest-2 we got the new property on the class that we can use to write real extensions for. You just need to add to your method to make it work that way. This is not the only improvement you should make. Assert methods parameters usually follow the pattern exptected + actual - in that order. You should name your parameters accordingly so there is no doubt about what they are for. The last thing you should change is the condition inside . Instead of comparing just milliseconds it's easier to use the property. 

ImageFileType property You set the file name via and then the extension... this is a little be weird. The class should be able to recognize the extension which means that the property should be read-only and return the type of the image: 

so I don't think it's necessary to get the connection you've just created with because it gives you exacly the same connection back. I removed it from the constructor: I have also made an adjustment so that you can use either the defautl for unity or you can pass it any other connection (if you have any): 

You can indeed improve the query by changing the strategy. If you first file extension and them inside the element selector you can remove and the query will be executed on the server and it won't be necessary to download all the data to group it later on your machine. You will then only get a few groups and their number of elements. Now for the few file extensions it's very easy and quick to get the category names: 

Excepiton handling Almost all of your blocks are meaningless (at least those with only ). If all you do is to rethrow the exeption then it's better to do without them. But in your case however they are even harmful. Instead of just doing you do which distroys the original stack-trace and creates a new one so debugging your code wouldn't reveal the real cause of the error. 

It depends on how you define the right way. Is your goal short and small code or is your goal testability and maintainability? These two goals are mutualy exclusive. 

It would be much easier to optimize and use it if you refactored it into specialized structures/methods. 

The has been extended to support formatting and max length for collections. A new check prevents it from crashing when is . 

All public members should be named with PascalCase unlike where the convention is usually that is to be called . 

The has two very similar methods: and . I find this duplication is not necessary. could call synchronously. In fact, they are identical. Additionaly I expect to return a so that I can it (if I wanted to) - this is the usual convention for methods. 

Next you create a new type for the content of the file. Each property that is mapped to a column in your excel sheet you decorate with the above attribute: 

As you can see I either can specify the member name or evaluate it dynamicaly. I do it only in case of an exception. The prevents the expression to be build prematurely. It's call probably wouldn't win a beauty competition but what else we can do: 

The last method has the arguments in the wrong order. For the sake of consistency the excluded ids should come last because this kind of extends what does and adds a new parameter. They are very similar and should stay that way. 

that may use JSON internally where you can setup the de/serialization process as required by each file. Generic solutions almost never work in such cases. 

You've written another extension for something that already exists namely the and extensions. One can do exactly the same with: 

I'm not entirely sure because even though you use a generic return type you use the same table for all of them: 

The shortest I can think of is to generate the numbers first and then make the conditions shorter by checking if the is in the particular collection: 

In order to be able to build validation-rules more easily I created this that provides two extension methods so I can pick one that seems to be easier to read for a specific condition. There is no anymore. 

This is really just a very simple example demonstrating the two methods that need to be implemented. You might want to make the name comparison case insensitive or trim the names or calculate a different hash-code. There are many ways to do it but now you know how to start. 

Or if you want to have only one method then try this (but make the other two and add the suffix - otherwise there'll be a conflict) 

Don't do so much work in a setter. This is not the right place for that. You should implement it as a command like and fire it when the text changes. 

In a perfect solution you should not have to cast anything. Getting rid of the and replacing it with real types would allow you to remove all the quoted code above and just check the actual values, not their types or even existence. You could assure that they are defined during object construction already and later assume they are correct. 

This requries another helper class for storing the items, so let's create one. It needs to implement the interface: 

It concatenates the results of and and returns them as . In order to get the relative path, we neither use the nor the methods but instead the : 

This examples lacks a lot of error checks. For example what if a currency code does not exist or is too short or too long? It'll crash. To prevent it you can use the method of the dictionary. You'll still need to add one more class for reading from the console. Yes, you should encapsulate this too. By building it this way you can now easily write tests for each unit. Additionaly you can add another constructor to the class so that you don't need a XML in tests. 

Before you do other things you should separate and encapsulate, this means you should put certain logic into their own methods that specialize in doing only one thing. If you put e.g. the loops in such method methods, you won't need any comments. Here's an example of how it could be done with C# 7. Also notice the changed names. There's no need for the prefixes. This is just a start and there is much more to improve. I left it out intentionally. 

I don't see any reason for not using the for the index. If it was the it would at least stand for but what does the mean? 

Unless I didn't find the difference this exact same block of code seems to occur twice in your code, both in the and the . 

When I see this interface I expect to find a method like that takes some parameters and processes them to yield a result. In this case however the interface should rather be called either or because you name every parameter of that type so why not call it ?