This should work, but I don't recommend it unless you have a lot more identical examples. You could move both the hash and the into helpers, but I think that amount of indirection doesn't make things any clearer. 

I generally like to be Rubocop-clean, but it seems like breaking up the first case statement will only make things harder to read. Any suggestions? 

First, kudos on including specs to show what you're trying to achieve. Titleize already does most of what you want (and I presume you are running within Rails or otherwise using ActiveSupport since it's not in core Ruby). You just want to add downcasing of little_words that are not at the beginning of a sentence. A few notes: Variables should use an underscore to separate words and you want to use two space indents and single quotes. You should call your method something different than the built-in . I recommend running Rubocop to help learn Ruby style idioms. 

2) using dual inheritance to get the functions of SlideShowBase into SlideShowPics seems more complex than needed. I'd think about just including a SlideShowBase into your SlideShowPics and letting it manage all of the image paths by delegation, while SlideShowPics handles the display. The old saying here is 'prefer composition over inheritance' 

Python has a neat built in called 'zip' which creates a pairwise list from multiple iterables. So you could do: 

This would let you compose and reuse a collection of funcs into a DefaultFuncs and then reuse it -- default funcs is really just an elaborate Tuple tricked out so you can call into the functions from the owning NeuralNet instance All of these are functionally identical approaches (it sounds like you've already got the thing working and just want to clean it up). The main reasons for choosing among them amount to where you want to put the work #1 is good if the functions correlate and you want to easily tell when a given net instance is using a set; #2 is just syntax sugar on what you've already got; #3 is really just #2 except that you compose a function set as class (perhaps with error checking or more sophisticated reasoning) instead of a a dictionary 

Finally, you should consider whether you want to be when no conditions match, and you might consider explicitly adding an to make that decision obvious. 

[Rewritten] You want to avoid inject, as is O(n) and clearer. Monkey patching array makes the code clearer and is idiomatic Ruby. Methods that return a boolean should end in . Method names should be snake_case. Here you go: 

This doesn't directly answer your question, but I also recommend switching from integer actions to enums: $URL$ Interestingly, this should not require any changes to your database at all, but will provide a lot of convenience methods and make your intent more clear. I do recommend hard coding a hash of the integer to the symbol in your enum definition to avoid any ambiguity: $URL$ 

There's nothing magic about Rubocop, but it does encourage you think about what makes readable (as opposed to just correct) code. In this case, I think it is clearer to make the conditions explicit in the rating method as you've done rather than break them up into separate methods to pass Rubocop. Specifically, I would suggest this: 

Another piece of python wisdom to consider is 'if you can do it with the standard library, do!' Field and record based storage is really easy to do with the csv module, which reads and writes comma-separated spreadsheet style files. A file formatted like this: 

DictReader is especially nice since it automatically parses the first line as the headers and returns a dictionary so you don't need to create a custom class to organize your data (as an aside: you could also do this using the sqllite module, which would let you read and write the entire database directly and query it with SQL. I'm not going to go into that since SQL is it's own thing - but for bigger applications it would be the right thing to research). Writing out the data is the inverse of the above: 

All of these filters automatically return lists, so you don't have to loop or create temporary variables to collect matches. I think it's easy to extrapolate from this how to write the program very compactly; using standard library functions means you can concentrate on logic and user-facting stuff (do you want to include partial name matches, or regular expressions, for example? Do you silently ignore bad input or scold the user? etc). 

I found a solution I like better, which replaces the loop with a . Sequences work but look funny as fake data. 

Ruby uses SCREAMING_SNAKE_CASE for constants, which is what you are setting up, so I would call the variable . If you have a super long constant, and it's not created programmatically, then listing it a line at a time is clearest. Ruby will coerce into unless you treat it as a string. You can use the shorthand for arrays. So, the first couple lines should be: 

I would just factor out the flash error into a constant. Also, I believe the trailing period in your regex should be escaped, as you don't want to match any character. 

In Ruby, it is almost never necessary to set a temporary variable to empty and iterate over an object, given the power of methods like map, reduce, find, all?, etc. I don't see the need to use since it doesn't change whether index will be present or not. It's unclear why you're checking for nil on the first sheet_activities (since you can't guarantee what will be first without sorting), but if you just want to return false when sheet_activities are nil, the above will already do so. Also note that Rubocop likes single quotes when you're not interpolating. 

The class would store Earth's G in a constant, because it does not change in any planet's calculation. The constructor should require the planet's own G value and it's name (for the Print statements, discussed further below). You can also add a method to calculate the resultant weight based on a given value, to follow along with the Object Oriented approach. 

Now if you'll be very strict and won't accept the use of a array. You can replace it by extracting the first and second values using function on the first two 

The rest is just a search function to find the based on the and . I recommend creating a name class with and attributes and use a to search for the meaning. The class can be as simple as 

I would start from the declaration of . You are an from it but no other class will handle it. You should put your inside a and handle the exception properly. I would also recommend reading everything from the files at once and use that of data in your code logic. A locks the file until it's finished with it. Furthermore, you don't have to call just for the sake printing a new line. Use the escape sequence for doing the same 

I moved the test into its own method to separate the logic. This still shows a Rubocop error of which you could fix by moving the nested iteration into its own method, but that struck me as more confusing than helpful. Note that creating the method allows us to use both and to break out of the loop at different levels. Also note the use of a guard clause. 

My other suggestion is that you might want to monkey patch String as follows, to follow the pattern of other Rails Inflectors (note that including is unnecessary): 

Your second method is closer to idiomatic Ruby. In general, you should never need to initialize an array. is a nice alternative to . And, you can open String and add a new method. I would do: 

Sorry I don't have time to review the full program, but here's a much simpler replacement for the method. Note is a redundant if you're then going to be splitting on white space: 

There are many different design-oriented ways to produce a good solution, as demonstrated in the other answers. So I'd like to suggest something different. One should make use of framework classes whenever possible. It avoids potential bugs, reduces the lines of code and standardizes the code. There is an in the called . It has an ordered list of the days of the week. All you need to do is parse the as a as detailed below 

Using the array has a massive advantage here for the output statement. Since the corresponds to the planet's position in the array, you can simply call the appropriate planet's method as . Following two lines will suffice the purpose of the previous . 

You can also use the array to populate the menu itself using loop. This is especially helpful if you have a large number of planets/items in the array. 

The main idea here is to use the dictionary CircleSet as a sparse grid: it will only have keys where a point falls into a circle. I'm using a separate set() object to track intersections so that the 'overlaps' function does not have to look at every value and see if there are multiple entries, but you could ditch that and do 

Map is handy for shortening ths common pattern, but I think Guido has officially disowned it for the future 

From a style perspective I like the first option; if you're treating this as a property its clear what you intend For implementation, I'd try a class level default with an instance override to provide the right words to allow for specialization or extension (for other languages than English, say, or use at Oberlin College). Whatever your gender politics this implementation is extensible to new cases and one offs.