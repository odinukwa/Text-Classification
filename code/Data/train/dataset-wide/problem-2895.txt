As you can see, that's as subjective a review as you will get. If I try to comment further, I will talk more and more about style (and there is nothing wrong with your style, so that would be pointless) or about C++14 but your code seems to explicitly target C++11 so that would be pointless too. 

This should look like this, assuming that you have a member named and that your class has a method named which takes a and returns a : 

Before reviewing the algorithm and its complexity, there is a number of things to be said about the code itself: 

Avoid raw pointers. Instead, use a which will manage the memory alone. It's by far safer. Since the modified portion of the code is quite huge for this modification, I won't include it in this section. However, you can find the modified code at the end of my post :) Constructor inheritance Do not bother creating specialized constructors to forward your results to from its derived classes. You can use constructor inheritance: 

Here, is only used if is . Since the variable is not used later, you should move it inside the to avoid creating a useless when is : 

If you want a fun solution: associate every letter of the first word to the \$n\$th prime number ( to \$1\$, to \$2\$, etc...) and multiply together every prime number correspond to the letters of the first word, let's call this result the . Now, for every letter of the second word, associate it to its corresponding prime number and compute . If the remainder is \$0\$, it means that the letter was in the first word, assign the result of the division to ; otherwise, it means that the letter wasn't in the first word and you can increment the difference counter. Of course it only works well with a small alphabet (you can cache the prime numbers if the size of the alphabet is small) and becomes impractical for big words unless you use infinite integers, but at least it's funny :p 

Of course, none of this is meant to be used with a C++ compiler and all this code is merely done for fun; I would never use that as production code. Also, I already know that all those macros pollute everything, but I don't care - all of this is just a proof of concept. So, would there be any way to improve the interface even further? Moreover, are there ovious errors in the implementation? 

You should take some time to give meaningful names to your functions and to your variables (and structures, etc...) as much as you take time thinking about the programming logic itself. Meaningful names improve readability and maintainability of a code base. 

Therefore, I decided to build some truth tables. In the following table, \$ lhs_{old} \$ and \$ rhs_{old} \$ are possible values of and before the update while \$ lhs_{new} \$ and \$ rhs_{new} \$ are the values of the same variables after the update. I did not take any interest in and since none of them is used to compute both \$ lhs_{new} \$ and \$ rhs_{new} \$; therefore, I simply ignore them in the rest of this reflection. \begin{array} {|cc|cc|} \hline lhs_{old} & rhs_{old} & lhs_{new} & rhs_{new} \\ \hline 0 & 0 & 0 & 0\\ 0 & 1 & 0 & 1\\ 1 & 0 & 1 & 0\\ 1 & 1 & 0 & 0\\ \hline \end{array} We can easily replace by \$ lhs_{old} \$ in the computation of \$ lhs_{new} \$ but we can't use it to compute \$ rhs_{new} \$ since the update already occured. My first thought to get rid of was "can we compute \$ rhs_{new} \$ with only \$ rhs_{old} \$ and \$ lhs_{new} \$?". Looking at the truth table above, it appears that it is not possible. Trying to compute \$ rhs_{new} \$ before \$ lhs_{new} \$ doesn't solve the problem either. However, we already have computed another value in the loop: . Therefore, I injected \$ res_i \$ in the table and looked at what could be done with it: \begin{array} {|cc|c|cc|} \hline lhs_{old} & rhs_{old} & res_i = lhs_{old} \land rhs_{old} & lhs_{new} & rhs_{new} \\ \hline 0 & 0 & 0 & 0 & 0\\ 0 & 1 & 0 & 0 & 1\\ 1 & 0 & 0 & 1 & 0\\ 1 & 1 & 1 & 0 & 0\\ \hline \end{array} We can infer from this "truth table" that \$ rhs_{old} \land \lnot lhs_{old} = rhs_{old} \land \lnot res_i \$. If we inject this new discovery back in the code, we can use it to totally get rid of : 

So far, so good. However, one very common operation is to compare the distances. Generally speaking, when comparing the distances, the is optimized away and the sum of the squares is compared instead of the distance itself. Therefore, I tried to create some kind of expression template to represent the distance between two points, so that users will benefit from both the ease of use and the "get rid of optimization" when comparing distances. Basically, the call of is not done until the exact value of the distance is needed. Here is the class: 

In Python, try to use indices-based loops (with ) only if you have to, only if you do need the index. Otherwise, try to always use element-based loops. 

Moreover, if you also make your , you won't have to update it every time you call , but only once in each thread. That said, you can't initialize it with its "range" anymore, you have to pass it when you call it: 

Rethink All in all, your goal is to test boolean conditions on types. Since the query traits have a member, you may want to create a that checks for and (like or ) instead of checking for and . That would make your intent clearer, but it would be more like a template. 

You may want to use calls and internally. If needed, it also calls if is an array type and calls if is a function type. In short: 

I did manage to improve some things since the question was posted. So here is what I discovered, that could somehow improve the implementation and the usability of the : 

Frankly, there isn't much to say about this class since it is simple enough and relies on another simple clock. The type alias, static members and static methods seem to all rely just like they should on the template parameter so there is no problem. I believe that is nothing really from os this shouldn't be a problem either. The only remarks I have is about the template parameters: I am not sure whether defaulting to makes sense. Is it really the default clock amongst the three standard clocks? If you think so, why. But frankly, defaulting has no sense: doesn't tell anything about the epoch to the user and you already provide the meaningful type alias (note that using the defaults is always equivalent to using , which makes them useless). You can't default without defaulting though because you can't change the order of the template parameters. I think that the best solution would be to leave undefaulted template parameters in but make an alias template with a possibly default template parameter: 

Generally speaking, there isn't much to say and I can't find any obvious flow at first sight. I'll have to comment on small things instead: 

You have "data" embedded in code in the function . You could use an to help separate the data and the actual algorithm: 

seems to always be executed, even if we just killed the last monster. In such a case, it appears to be calling on an empty , which is undefined behaviour. I don't think I am mistaken, so you should put a condition before executing that last instruction. 

Two-dimesional array Your first function can be aggressively reduced by replacing and friends by a 2D array: 

I have not much to say. Your code reads quite good, which is rather pleasant. Here are a few tidbits though: 

Specialized algorithms Calling a generic algorithm with a constant value in a formula can sometimes be considered to be a special algorithm. In your case, \$2^n\$ and \$-1^n\$ may be considered special. Their respective implementations can easily be made \$O(1)\$, which is always something you might want at some point: 

EDIT: Answering your comment. If is an abstract class and you only add instances of derived classes, then I think that still works fine since polymorphism will be achieved via reference semantics. On the other hand, could take another argument if you want to emplace instances of classes derived from : 

If you do this, then you should be able to almost always keep the best algorithms between generations, but you will also keep some other ones whose mutations and/or combinations may unexpectedly produce agorithms that are better than your current best ones. This process of "you may have an unexpected talent" is useful to avoid local extrema. 

Concerning the map, I don't think that there is any way to make it since it allocates memory dynamically and there is no such thing as predynamic storage ( and ) in the C++ standard (yet?). You could create a mapping with a simple array (or ), using characters as indices and as values. But you would probably have to fill every ASCII values with some values, even those you don't use. That's not the cleanest thing to do. Concerning the choice of the mapping, if I remember correctly, has not the best insertion time in the world, but has a really efficient \$O(1)\$ lookup. Since you initialize it once and then you only perform lookups, such a construct could be more efficient in your case. On the other hand, you could try to use a which is a map based on a vector and which is consequently cache-friendly. For almost anything, the good old is the slowest alternative. 

You could probably write a nested function that does the and then you can handle the number of the iteration in the main function: 

Since all the values in this line are known at compile time and is apparently not meant to be changed, you should consider making it both and : 

As an additional note, your function does not actually implement an insertion sort, but a gnome sort: to insert an element in the sorted part, your function repeatedly compares an element to the previous one and swaps them if they are not in the correct order, which means it's a gnome sort. An insertion sort would compare every element to the current element to insert to find the position where is should be inserted, then it would move every element after the point of insertion one step to the right and put the current element in the correct place. Here is an actual insertion sort; the actual code comes from Rosetta Code: 

For example, you could always store Kelvin degrees and let the functions do the conversions ( and wouldn't do more than assigning and returning the value). The user does not have to know how it is stored and what they have stored, only how to set and get the temperature the way they want. Miscellaneous C++ things 

CRTP helpers When using CRTP, it is common to write methods in the base class to avoid having to deal with the pointer and to use reference semantics instead: 

Many things have already been said about your code (I like how it looks from afar by the way :p). But I still want to add my two cents: 

Towards a solution? One way to prevent all this allocator stuff would be to take containers as template parameters, like and let it handle all the allocator-related problems: 

At some point I needed to compute the average of a big collection of integers. I knew the size of the collection prior computation, but a naive average computation was prone to integer overflow while repeatedly adding every elements divided by the size was prone to loss of precision. To mitigate overflow and loss of precision (speed wasn't an issue), I came up with the following algorithm: 

What strikes me most is your variables names: they are cryptic. Having short name for loop indices is ok, but you should at least name your function parameters so that anybody using your function knows what they are supposed to pass to it. When I read , I know that I will have to pass a collection; here we have which without a doubt the array parameter. However, an array parameter decays to a pointer, so I also know that I will probably have to pass a size, but then we have two parameters and and I have no idea what they mean (from your main, we can infer their meaning, but a potential user doesn't always have a friendly main to explain how it works). There is a famous quote concerning computer programming: