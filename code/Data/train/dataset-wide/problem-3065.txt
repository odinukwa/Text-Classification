As brought up in the comments, this will crash if there are 0 elements in the list. To prevent this, you should probably check this before you try to get the range, like this: 

I'm not sure what is going to, or should, happen if neither the nor the statements execute. Should there be an statement in there? 

Here is a Battlehips game in F#. Now, before you start jumping up and down on my code, please understand that, for all its awesomeness, F# has a serious limitation: Its compilation is linear, and the solution structure cannot have folders. Any code that uses other code must be below the other code, whether in the same file, or in another file lower than the first file in the compilation sequence. Here is my file. It contains basic data and methods not specifically relevant to other groups. 

Also, use the correct indentation, fix your braces, and you should add braces to your / block like this: 

Your comments are redundant because it is clear you are adding it to the list if it does not exist. You did use braces here, which is good. Please be consistent whatever you choose, though, and either always use them or never used them when they are not needed. 

There are others as well. I would recommend using a space for readability. I would put spaces around variables in function definitions as well: 

Now, you have a method with one responsibility, and it will probably be a little easier to make sure you update everything if you add any new types. I would use these same principles to load the input/output types. I would create a method like so: 

I hope this makes sense; I know it can appear somewhat convoluted, but it really will make your code cleaner and easier to maintain. Basically, all your logic and display data goes in the VM, and the view is for pure presentation. Because the code-behind is part of the view, it should also only be involved in presentation details that cannot be expressed in the XAML, like fancy drag/drop details. Feel free to ping me if you have any questions. 

Also, you should use proper indentation to help you read and understand your code better, which will help prevent bugs. This doesn't do anything: 

This review is primarily to make sure I am using Unity right. Please tell me everything that can be improved. 

You are wasting your time here. Once you know the value is not a prime, you do not need to continue looping. This will reduce your time greatly: 

Sure there is. Check the input and notify the user, and let them try again. And do it in a dedicated method. Maybe you can modify the stub method I gave you into and make sure it is within the ranges provided. This is a perfect example of extracting similar logic into a more generic function. 

Seventh, you do not need to identify each block on the page with an or . If you wish to style all HTML elements of a certain type, you can do so like I show above. The in the example can be replaced with , or any element you wish. 

After , it restarts again with . So let's put these into an associative array, with the associated element: 

Basically, we're doing the check inline, as well as concatenating the php extension after check. Though this relies on the file not existing - you can replace with any other name. Additionally, we're not echoing on fail - rather we simply inform the user that the requested page does not exist. 

The better way would be your first, as you're just comparing the element A with element B and not creating a copy of the element as you are in the second version. Additionally, to be a bit of a pedant - you don't want to name a function where its only returning a boolean, over where its assumed it would return a boolean. 

This function makes use of array_walk_recursive() to push into a placeholder array whatever value is pointed to by whichever key matches our needle key. Proof code: 

Use PDO, not mysql_* as they are deprecated and dangerous. Break up your code into functions, this makes it easier to call and test. Throw and catch exceptions. You can omit the ending ?> 

I think it looks ok - though someone might want to add on if they notice any issues I may have missed. However, a bit of cleanup goes a long way: 

Memoizing a generator is a good idea to save having to rerun it. There are a few ways to do it - one is to handle it the way you're handling it, by returning the cached result if it exists, otherwise returning and caching the new result. The first way, is to the the method from . Such as follows: 

Well, the function kind-of sort-of violates SRP...but according to Uncle Bob, I think your class violates the SRP moreso than the function. Your class above, has three functions within it: . One of them scans the directory, one of theme creates an array of theme names, and another loads the theme files. One of those methods should not be in there: should be in its own class called or something. Which means, by extension, that is in violation of SRP. To quote Atwood - SRP is about "choosing a single, clearly defined goal for any particular bit of code: Do One Thing ... But in choosing one thing, you are ruling out an infinite universe of other possible things you could have done. It also means consciously choosing what your code won't do.". So in the end, its up to you whether this violates SRP and whether you would choose to follow SRP so deeply that you violate OOP or DRY. Perhaps someone with more experience can chime in or prove me wrong (heck, always good to learn something from someone else) EDIT: See ($URL$ article as well for clarification. REVISIT 01/26/2015: Revisiting this answer, I would rewrite the code as follows: 

To expand a bit, we are renaming the function and variables in order to align with PEP8 naming conventions. Here's the code: 

Notice that your original answer does not catch nor raise an error when encountering a string val. I've reworked your code to this: 

First of all, you can figure everything out if you know the distance between the values of , , and . 

You don't need the statement because you return from the . @Malachi says you can merge the s in the into one statement, and that is true, although I don't recommend it for readability purposes. However, if you do that, you don't even need the statement to return true - just combine it all into a return statement: 

So, sᴉɔuɐɹɥԀ suggested I write a SEDE query to find first questions with answers posted within 24 hours, and here it is: 

First, your loops are evil to read. It took me several minutes to figure out what the condition did. Essentially, you loop N times, where N is the Nth instance of the character in the string you wish to find the index for. Each time you loop, you find the index of the next occurrence of the character in the string, update the position to search from, and continue the process until the index is either -1 (no Nth instance), or until or , based on which side you are searching from. A simpler way to write this algorithm is as follows: 

This follows standard Java brace formatting, although some programmers place the on a separate line. I am sure your code can be improved in its execution as well, but these are more pressing issues for now - make your code easy to read, and you will catch more bugs and be able to improve it on your own, as well as getting reviews on content instead of style. 

Also, you have spare returns scattered around your code, especially before ending braces. C# does not consider whitespace when compiling, so those are most unnecessary, and make it hard to read your code. You may want to consider putting a single space after the brace instead of before the brace if your code is separated into logically similar groups or if you want to split it up some. 

Put a single class/enum/interface in each file. This will make it easy to find the various classes because each file has the same name as the type it contains, and each file has a single responsibility. 

In question five, you have multiple inputs. Why don't you handle it like this instead of having multiple // statements? 

It will only fire on fields to make things simpler (fields in other scopes should be properties, anyway). If the field is only assigned inline or in the ctor, it should be Fields cannot be if they are: A. Assigned in any scope other than a ctor or inline. B. Passed as a or argument. C. Incremented or decremented with the prefix or postfix or operators. 

This next action isn't used by the game, but rather publishes the data so another system can hook into mine and receive updates about games. 

This looks very clean and simple, which is always* a good thing when programming. First, you don't save state, nor do you have long functions--each function does what says in a couple lines. One nitpick is your naming: 

Another way to do it, if the generator consistently returns small sets of data, is to just use . This is especially true if, like aforementioned, the generator returns small sets of data and that data is not dependent on an action (ie, data is static) and that data is not kept in memory for a long time (such as in a child that is killed (and its memory freed) once its served its purpose). The way to do so, is: 

In the end, we're left with three functions. One which creates the key, iv_size and iv. One and one to encrypt and decrypt, as follows: 

The code below is good. I only changed the comments a bit to make them a bit clearer and more concise. However, one glaring issue is that it seems you have your setters and getters mixed up. Note the and functions you have in your class. Usually, setter and getter functions do exactly that: they set a value and get a value. What you seem to be doing is using the set* functions to get the value returned by another function. This is +wrong+. 

Why not go with a template like Twig or Blade which would make the syntax a lot cleaner, while retaining most of all the controls. Also, remember that the view is for showing data, try to maintain as much logic OUT of the view as possible. Here's an untested version of your code with Blade: 

You should think more about how you arrange and style your code. Additionally, you should be aware of DRY methodology and keep from repeating code wherever possible. I made a couple of modifications to your code. Primarily, I cleaned up the arrangement and styling. After that, I added an Ohm class - which places all of your Ohm related functions as methods (again for code cleanliness): 

If you are creating a database wrapper, why not make a lib out of the wrapper and stick it into a directory that other modules/classes can import? So, your class would be in a directory structure like this: 

Rather than tie yourself to only one type (string), you could use the package as well as interfaces to make it somewhat type indifferent. The following is my reworking of your code: 

My little attempt basically takes items that are repeated and puts them into their own separate conf files and just include them into the main conf files. On my servers, I structure them as such: 

Not quite a lot that can be done performance-wise...you have a lot of data to pour over ( and with the new data . You could possibly think of moving over to a faster database (Redis? Cassandra?). Anyways, I made a few minor changes to your code - added empty() checks rather than empty string checks, shortened a few if statements, etc. 

After that, we continue with an if/else block which calls the function according to the user input. Our i/v/r/w should already be defined in the block above. One major change here is that we are no longer printing directly from here. Rather we are setting the output in an variable, which we later use to print.