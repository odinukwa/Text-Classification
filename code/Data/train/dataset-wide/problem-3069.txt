Almost readable, right? But something is still off. Better types Your result type of doesn't really capture what you want to do. You want to run an instruction and get a new , maybe with some output on your console, or some user input taken. But even without that information, we'll notice that you never user the part of your result, except for . That line could also get written as 

We can now use on any null-terminated string. We're able to reuse functionality. Note that both functions are very easy to check by hand. 

So we lost no functionality at all. Prefer range-based -loops See above for an example. They are much more convenient to work with if you don't need the index or the iterator of a specific element. You need a compiler that understands C++11 or higher, though. Documentation and comments Comments and documentation often feel like a nuisance, but they will help to to remember what you had in mind when you wrote the program. Also, whitespace is your friend. Compare 

However, since all your error messages are also on , one will not see them. Use instead of for errors. Your algorithm There are some small things of with your algorithm. First of all, you display a string in every iteration. That's slow: 

We can now check the functor law easily for many combinations. The more rigorous approach The more rigorous approach with functor laws is to proof them by hand. So let us assume that functor laws hold for the functor in . Then we have to show that 

And we're done. By the way, you can use to get rid of . But that, again, is left as an exercise. Further remarks The type annotations in your bindings are not necessary. I would get rid of them, since they may get out of sync with your top-level function (but you will at least get a type-error). can be written as , if you're up for a challenge. Your overall complexity stemmed from . It's a great function, but only if it's used for the right job. Not everything is a nail, just because you have a hammer at hand. Instead of trying to get everything else in place to use a specific function, ask yourself what you want to do, and whether there's an easy way. Unfortunately, there is no -like function in the standard library (unless you count stateful accumulators such as ). 

But as soon as a second parameter gets involved, it gets a lot more trickier. And as always, the best code is not worth it, if you cannot understand it later on. Haskell's referential transparency makes that a lot easier, but if you need to sit down and check how works, it's a good call to use . In the end, it boils down to your personal choice. I would have used a list comprehension, because it's still easy to read, but it's only a syntactic sugar variant of your : 

A space goes in, a space goes out. We do not change the key. So now there is only one case missing: the one where we have a character that's not a space: 

If we enable , GHC will even tell us when we forgot to handle a DB environment that we might add later: 

* Please note that you would usually change into a class and use methods. I'm not sure whether you're ready for object oriented programming yet. This is basically the C-way of object orientation, which may or may not be easier for you as a first introduction. Read the documentation should be used only once in your program, and before the first call. Just use it as first thing in your . This was a small intermission to get you ready for the next section, which is rather important. Don't use There's usually no need for if you've followed my second-to-last advice and split your game into several functions. You should always avoid . makes it hard to reason about the program flow. Think in scenes Your player has essentially one action. They have a choice, which either determines the next scene, or their action in the fight. A scene here can be thought just like a scene in a play. You do already think in scenes. It's those bits and parts where you use and and the dreaded labels, for example the , so you're already on a good way. However, if you want to change those scenes without recompiling your program all the time, you probably want to move most of the text out of it. You could even specify the choices and the enemies in text files, but that's a little bit out of scope for this review. Further remarks You really need to structure your code into separate sections. Functions would provide a first way. However, when you start to do that, your code will probably get larger than it already is. Vertically that is. You have around 650 lines in a single file at the moment, and if you structure your code, you will probably have over 1000. At that point, you want to split your file into several ones. Maybe you want to put the fighting logic into another file. Or the character generation. The scene-handling? It's up to you. By the way, your lines are currently too long. But that will probably fix itself as soon as you use functions. 

function can help you. Namespaces Unless you know what you're doing don't use . Abstractions Now let's have a look at one item exchange 

Review Please don't use on the gobal scope. It's considered bad practice. Next, try to keep the scope of your variables smaller. Also indent your code properly to make it easier for you (and others) to see the program flow. Don't include . It's not a standard header. It's somewhat OK in programming challenges, but you should use the proper includes in your real/production code. If you use a smaller scope for your variables, you will also be able to use better names for them, for example instead of and instead of . If we apply these changes (and translate your names into English), we end up with 

Ownership could take a slice instead of a vector. That way it's more general. The actual implementation is left as an exercise, but it's more or less the same: 

The size of the list Your is also fine. However, I would not return a . That depends on your use case, though. A function should be fine, too. Also, I would add an additional detail: 

What's the big difference? Well, we're not using repeatedly, which is a big plus. needs to traverse the whole list to get its result. Also, we're not switching between lists and maps all the time, which gets rid of all intermediate lists. Running the benchmark again, we gain the following result: 

Next, you usually don't want to use the whole . It's considered bad practice. And last but not least, you want to use variables as local as possible, to get rid of errors that are hard to debug (e.g. should be declared/initialized in your ). If we follow all of these points, we end up with 

yourself. I have no idea why you use together with at that point by the way. calls the constructor with the given arguments. However, our constructor will copy since it is not an rvalue. I'd just call at that point. We're dealing with primitive types here after all. 

In , you can simply copy your s. Don't use an underscore on global scope names An underscore at the start of an identifier at global scope is reserved and yields undefined behaviour. Also, is considered bad practice. Prefer range-based -loops over Your loop is not really easy too the eye: 

You destructor is fine too, although you don't need the . Also, you don't want to print text in a destructor usually, except for debugging. Note that I'm using the new described above here: 

Short answer: don't use recursion. Slightly longer answer: don't use recursion if you have more than a single recursive call of your function in the non-trivial paths without memoization. 

This will return if returned , and the number of read characters otherwise. Putting all back together I omit the functions I've already covered above, but if we use them, we end up with the following program: 

But that's more or less a personal preference. A major nitpick though is that you take the of the list in every iteration. You can get rid of that if you write another function: 

Your code doesn't have that error as far as I can see, but you can keep it safe by using more often: 

So when you use , other Haskellers will try to figure out what monad is currently getting used. However, you don't use a monad at all: 

To remove possible data races in have take two arguments. Then you don't have to store the in your class at all. 

It's missing , which is essential for the line afterwards, since we're at position or after this line. If you really want to manage this style, I'd suggest to 

Allright, that seems to work. However, do we actually need the check? No. does that for us. So let's get rid of that: 

Note that the first variant still has the somewhat awkward there. A partition that starts from the right wouldn't have that problem, but we're stuck with that. Now is just 

Your instance doesn't need to be a . We can remove that constraint to make on more general. Your instance could be made a little bit more readable if you provide a function: 

Never use in a header. While is already considered bad practice in general, it's especially evil in a header file. It affects every file that includes your header. Next, hide your . It's an implementation detail. You can put it in a namespace, inside your class, or in another header. But it shouldn't be readily available to an end-user. Furthermore, you have an inconsistent naming convention. Your variables are written in camelCase, your methods are written in camelCase, but your class is just . The sample size is too small to see how you want to name your methods. However, is harder to read than , or . It's great that you implemented in terms of and in terms of . Great way to reduce duplicate code! But why stop there? You have duplicated your code in several other places. For example clearing the list is done in both and . Provide a function, e.g. 

Note that all this annotations are only necessary if your functions will be in a header. Don't repeat yourself You pad your string, but it's a) hard to get and b) repetitive. Write a function to get rid of the duplicate logic: 

Output You use quite often. In some instances multiple calls can get replaced by or . For example, instead of 

Both should return , but on the first list returns and on the latter . Make sure to your list, or state in the (currently missing) documentation that your list has to be sorted. Also, using twice is rather slow. Instead, the first elements up to and then take the : 

The qualified import here is good, but your module header is missing. Since there is no documentation you don't want to export some functions, for example the partial . 

In this case everything is in a single module and everything gets exported. This enables a user to use the constructor immediately. If you want to prevent that you need to make sure that only the type, but neither the records nor the data constructor get exported. Otherwise can get circumvented. 

This is an exaggeration, but you can be as verbose as you like. This kind of commenting has a big draw back, though: it's easy to accidentally enter a comma or period by mistake and end up with broken code. Conclusion All in all, well done. The if-else-logic is a nice brain teaser, to be honest, which makes an proper comments a lot more important. 

That function does not exist, though. A perfect building block for would have the type signature , but that's missing from the standard library. Others packages provide functions with that signature, but none does provide our needed functionality. But we can write that function ourself: 

I guess that shows more what is possible with C++14 lambda initialization than actually reviewing your code, so let's get back to your code. Well, there's nothing else to say, to be honest. Your code was cleanly written, and if you really want to couple the container and the discrete selection strongly there's nothing to improve (aside from using ). As Frank said, I think the is an overkill, but if we ignore that it's a solid piece of code. 

Here we see a great use of to prevent a magic number. We don't have to guess what means at another point in your code. We only see the identifier . However, you don't follow that approach with your error codes: 

That's a lot of imports, and several seem strange. For example , since you only use , , or other functions. The problem is that you've use , but left the . This should be: 

You need a C++11 compiler for this. Alternatively, move into the private part of your class declaration. The move, assignment and copy operations can be defaulted: 

We will now take a look at your source of duplication, and . Both suffer from somewhat the same problem: you need to define the map from Brainfuck instructions to oOo instructions and vice-versa. So let's define them: 

This is a valid place for an exception. A function has only a single return value, so it can only tell you that something is wrong with an exception*. Exercise: Try to use that function in your code and handle the exception. Also show the exception to the user, they're probably interested in what went wrong. You should use the code similar to 

The first one is a lot more readable, whereas the second one uses a "hack". I would go with the first one, except that I would use , which is a little bit faster. And one could introduce some DRY: 

But again, that's a matter of choice and up to you. So what's the point of being so small? Well, at the moment, there's no choice for the user to make the game harder or easier. Adding that to your "large" above would make things messy. Adding this to the small makes things not-messy: 

We begin with the "loop". is . This has not necessarily the same effect, since is not the same as when using floating point arithmetic, but it's fine for our cause. It also works like the Python code, which was your original intention. We now have 

The code does not account for negative numbers, yet the number type () allows them. The program will print for the input , although is the correct answer. The GCD is usually positive, but your program will print on the input . A function will make it easier to test and re-use. Since you provided a complete program you probably want to check whether the user actually inputs two numbers and not or something else that's not an .