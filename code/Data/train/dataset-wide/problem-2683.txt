Well this was a very satisfying problem, thanks for sharing! First of all, calling external resources is expensive, there for not optimized, which you ask for. Else wise, calling external resources can be preferable if the external resource is something like shell on a platform you have control over. That's the reasons I removed them and substituted them with python built-ins. It's pretty much the only reason this code is slightly faster then yours. I found one small error in your code. What if a file you try to hash has spaces? The problem occurs when you split the return from md5_checksum, it splits to as many values as there are white spaces. The most time consuming function of both our code is walk. It's easy to check these where cpu-time went with profilers. And python has a builtin I like, but there are many. It's the cProfiler, check my code for usage. The biggest change was refactoring the function are_identical for 

Seems like you have background in some other language, your use of global is very weird. It's a unnecessary bad hack. 

They do the same thing, but the any() builtin, is.. as well faster, then iterating over lists. I did remove your function comments, as they can be substituted for good function names and annotations. Do you agree? 

give you the ability to import the timer class into another file. If you try to import your code into another file, you'll start your program and not complete the import. 

what happens here is that the two files are open at the same time, and since wrong is a generator, it will read one line, in this case word, at the time. If the currently written word is in english it yield it and write it to the file. Pythons enumerate builtins purpose is for these kinda situations, where you want to iterate over something while still keeping track of the rounds. 

Lurking today. I just post this for your pleasure. It might give you some ideas about condensing your code. 

Your calculation function s for one loop in 100 iterations. The my solution s for one loop in 100 iterations. 

You could call max on to variables directly and put the if statements in line and avoid the try catch by checking if the user input is digits. 

Comments In python there is something called annotations, they are very use full. The let you define for yourself and other readers of the code what in parameters and return parameters function has. Example 

which is prettier. There is a better way to find the current seconds, minutes and hours of current time, 

The code has two generators, one to truncate the number from the left, or moving the X coordinate of the cruel pair. Another generator to move the Y coordinate. The generator that moves the Y coordinate starts at the same length as the query string is. If the query string is longer it yields 0. 

There is always a better way, then to use a global list, your t list is a global list. You are on the right track when defining a very clear is_palindrome function, but instead: 

Terminating and joining is not the same thing. Check out your task-manager, you should see the processes staying as "zombies". The call terminate() force the exit of the process and join() does something I don't pretend to understand, but I know that if you don't call join on terminated processes, you will get zombies. 

It might not be a complete solution, i can't test it, but it reduces the numbers of cases that are checked. But i should give some pointers. 

You should refrain from using many variable names, but I like that you used the correct convention.. If you have a lot of data, you should make use of a data structure. If your not going to use the naming conventions, stick with what whatever convention you choose, it's a lesser evil. You should use the conventions, imagine this was maths, and you substituted + for - changing the convention. Seems like a bad idea if this is homework. 

The and of python evaluates to and respectively. In python if you multiply a str with a number, you'll get that many str, so would be, "fizzfizz". would yield . 

It's confusing that you use a manager, I get the impression that you are going to use the result to handle interchange of data between processes, this is not the case. You are just retrieving a result from from a child process. It is dangerous because you are always overwriting the same key "result" in the manager dict. Think of it. Every time you return from the manager.dict, there can be leakage, i.e. if it is over written before you return the wrong result is return. You should use a Queue that is unique to every 

Now that you have a set that you could use for membership testing, I think it's remove the function spell check, since it adds a line of code and somewhat obscures the program. If it did something more then checked for membership, sure, bur right now, no. In that case, you could remove the third for loop and create a generator to let the program deal with only one word at the time and further reduce memory usage. 

I notice something small, well you know the corner cases. You know that a DNA string will yield a score of that is the same as length. Obviously ^^. So don't check those cases. You make 4 iterations in your code. While only one is interesting. A big improvement in runtime could be to change: 

I like your code! But some styling notes and then a suggestion. I think the usual way to check if a number is a perfect square is: 

The main function relies on the fact that if the condition are meet, all following conditions in the current substring are meet and we and we can simply add those. This means that the only check done is the check where the is of equal length + 1. 

I thought I might as well summit a answer. It will first contain some styling points, and then a async approach to the question. 

Well, you have your code in a function, but it is still top down. It makes it harder to read, and much harder to improve. If you instead break the code down into separate functions you'll have an easier time improving code. You'll also not repeat your self. 

It will scale better since we are never checking what we don't have to check, the only thing we have to check is if there is a corresponding index in the other list (now dict).