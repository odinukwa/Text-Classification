What's 0.0005? What's false? PolyPortrayal Is there any reason to use inner classes? draw() Switch statement also works on String (since JDk 1.7 I think) MainAgent Dude, I have to scroll to see all the variables. That type is too long. glances of and checks the scrollbar. It's WAY too long. 

There's some other fishy stuff, but I'll conclude now, because in my opinion there are some problems even without the reflection stuff: It seems like an over engineered approach for an easy problem. Or: It looks like the solution of a problem, which probably isn't even a problem. It certainly is, from my point of view, the wrong tool for "the problem". The usage of reflection makes maintaining the code harder and more error prone, at least in my experience. The usage of annotations, too, by the way. I'd suggest to take a step back to the solution before you implemented reflection and analyze what object oriented principles are violated (e.g. SOLID, coupling, cohesion,...) and what patterns can help you get rid of those problems. Now, that's the major point: Ask what design patterns help you get rid of your design problems, do not ask would reflection get rid of the design problems?. I recommend fowler's web page about gui architectures: $URL$ (presentation patterns). It's not exactly a "good read", but it certainly is educational. It helps you to understand, which presentation patterns suits your application best and gives you some guidelines about how to implement you presentation layer. 

Now what? What can I do with that? Do I need that? Is this ... important? I would have chosen 'getMessageKeyPrefix' or something like that. Why must this be exposed anyway? 

Double-clicking on a ListCell would call .edit() on the domain object. Same thing. The presentation code calls the domain object, then, the domain objects calls someone and says "someone wants to edit me". If I understood it correctly. 

It's much easier to use and understand. toString() For instance in the type, you append to the return value. Is there any reason for that? @Override You're overwriting the toString method. Always use the @Override annotation for overwritten methods. It helps the reader to see, that it actually is overwritten, and, the compiler actually checks, if the method is actually from a super class (if you mess things up) Liskov / inheritance Now, I'm pretty sure, this isn't within the scope of your assignment either. In your main method, you got an array of Vehicles, at the end you iterate over it. Now if you were to know, how many passenger seats there are, you will be only able to do that, if do something like ). If you add another interface, for instance and want to get information out of that, you add another if clause. That's a violation of the Liskov Substitution Principle, or, in other words: bad inheritance. (You should look that up, it's a object oriented core principle). Now, I really dislike inheritance, in general, it's often a pain in the long run. I would have hidden the sub classes behind a static factory or something and provide an API like 

Your test case should not only test your implementation, but also document the behaviour of your implementation - without having written the implementation. And if you're at the first point, your test case describes the expected behaviour of your implementation. And it guides the design of your implementation. And what's very important, too: Know when to stop. If you have code which is not covered by your test cases - and should be covered by a test case - at the end of an iteration, you did it wrong. And in my opinion: A code review does help, but not too much. Because with tdd, an application grows iteration by iteration. And the thoughts which have to be thought during those steps have to be learned and practiced. 

What I'm missing the most is that class which performs the actual requests? For instance, the pinValidation is performed in the type - this is imo mixing of responsibilities ("holding state" / "beeing a DTO" and "validating pins"). I'm also pretty sure, the actual pinCode of a card will never be transported to an ATM. I'd suggest write something like a ? Not sure about the Atm class. It's more like a controller class, as in the MVC pattern. It takes user input and tells the ui what it has to show and does start transactions. The actual logic is within the Card type. Why are you doing a mapping for AtmOperation and not working with the enum itself? Why not pass the enum in the method? In the is actual business logic in the requestPin method. The "n trials before account is locked"-thing shouldn't be in the ui. The ATM is actually a very good exercise for a traditional 2 or 3-tier application, but I can't see it here; I think your main problem is, you don't know where to put what code. Maybe a good exercise would be, to completely ignore the UI for a moment, and just focus on the business logic. And maybe get used to a few mantras: "When I want to exchange the UI, what do I have to change in my code?". And "Does that class do only one thing?". When you get that, put the UI on top of it. (It's not the usual thing to do, but I think it will help you). (And maybe write some unit tests, I'm just saying) Smaller stuffs: 

We actually do know what the type is, not 'compiler-time-ish', but runtime-ish... for a heads up: I'm really bad at generics and I'm not sure if that's either a bit of a misuse of generics or if it's way too complicated (or could be done much easier)... (edit: and someone should review my posted piece of code, too ...) I just introduced a TypeParser interface to support the different types (Integer, Double, String) and made the static methods instance methods (so they do bind to the type, which was the main problem, I think) and I'm sure there's room for improvement either way,... 

Yeaaah, that's why people tend to use existing ormappers ;) - you might want to introduce some static methods in your base dao, e.g. all() and join(String table, String condition), so the writing is more fluent and it's better to read... you might want to check the Criterion API/impl of hibernate, it's quite nice to write and read, but that's quite the work, if you really want to implement your own ormapper with a certain amount of sql features. And: Most important: It's your job to make a class or a method readable. In test cases, I even write a static tomorrow() method, which creates a new Date and adds a day. Of course, you have to write a lot in java, but that must not be the excuse, to make your code not readable. 

Object Oriented So, from a object oriented perspective, stuff is a bit chaotic. Servlet What bothers me the most is that there's "too much code" in the servlet. Just think about that: What if, let's say, you want to introduce a presentation framework (because servlet programming is a bit year ~2003)? Which parts would you have to move 'to somewhere else', or which parts aren't reusable? Account First, I thought it's a type which represents an actual account, but it's actually ... well a mixture of business-object/domain model and data access object. It does do some sort of logic, like validating an existing login, and it does execute queries on the backend. "Usually", or "a common used pattern is", you have a layer which is dedicated to read and write data. A dedicated layer which does the 'business logic', and the dedicated layer which displays the data and takes data from the user. That's called a 'three tier architecture', which helps you to 'separate the concerns'. Readability Servlet.doGet The servlet has a bit of a readability problem. It starts with the problem, that you have code in your 'doPost' and code in your 'doGet' and it's a bit hard to understand what happens where, or rather what should happen where. Let's look at that 'set-empty-string-to-that-attribute-in-request-method': 

... I think a view with a dao responsible for that case is the way to go ;-) To be honest, in ormappers, I do not like the represent the complete erd in java objects approach. Maybe I just didn't get it, but sometimes it gets quite horrible. I mean, you have a Customer, the Customer has a List of Addresses, a List of Orders, a List of PhoneNumbers, a List of Items in the Shopping Card, a List of open bills and and and. And everything is present in the type of hell. And it gets worse, because all those dependencies have other dependencies, too. I found, that an app, at least above a certain size and complexity, is much more maintainable, if "those" problems are taken care of with a certain degree of isolation, even though that means, there is some redundancy, maybe a ClientAddress type and a ClientOrders type, instead of a "one size fits all" approach. Hope that helps,...