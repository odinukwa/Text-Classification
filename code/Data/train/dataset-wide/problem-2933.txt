You can use 2 custom attributes instead of one. In this case you should not swap value, just replace it. 

But, memory get free only after 3 minutes in my Google Chrome 43.0.2357.125 (64-bit). I was looking in htop, so chrome could free objects instantly, but return to system only after 3 minutes. Profiling If everything looks impossible, you can always try experimental way, using profiling. There is awesome article about profiling in Google Chrome also Firefox Developer Tools. I have applied chrome heap profiles for my example, and it says that data object doesn't exist in window scope any more after pressing "delete" button. Hopes it will help. 

Nodejs and preallocation Lets start with this test where we conditionally switches allocation from static to dynamic. 

and instead of a sequence of vectors, we'd get back a sequence of maps with keys , , and . This usage is totally unrelated to your original intention for this code, but it shows how generally useful the function is—so why make it private and hide it where no one can access it? Let it out and see what uses people can find for it. Finally, for such a small program it probably doesn't matter, but one of my favorite features of Clojure is docstrings. I would write one for any function I was publicly exposing: 

to check whether optional arguments were passed. But really shows its value if you want to have options and switches, which are a pain with and near impossible with interactive input. (You have to either have a config file somewhere, or annoy the user every time with "Do you want gold-plating? (y/n)".) To end on a positive note, I have nothing but good things to say about your use of docstrings, especially the ones on your functions. This is exactly the kind of excellent docstring that Clojure has and that Python mostly lacks, at least in the standard library. 

UPD: With single attribute you should create singleton, which will handle synchronization. I had try to draft singleton, but it is not so easy for me. It should be responsible for removing duplicates from task queue and watching on data consistency. 

field has standard $URL$ for it's numeric value. class property can make some troubles if future, when you'll need to make some manipulations with this list. But in this case it is acceptable solution. there is library called cities_light, it has states and some additional properties. Cons of using it - it require to download it's database (about 400MB) during migration. overuse of property. You should use boolean field and then adopt data presentation on form. Also, you probably wish to separate this huge model into few for performance improvements, but this require some profiling workaround. 

Then you can call instead of and instead of You could also put a inside to make things even shorter. These changes give you a kind of API to shorten and simplify interaction with your game state. Here's what those helpers would look like as macros. (Hopefully; I'm far from a macro expert.) In this case, since we're not doing anything special with the order of evaluation, the macro version of looks exactly the same as the function version. 

Think of it this way: is there any way to count the number of distinct elements without actually looking at every element? (More accurately, without looking at some substantial portion of the elements?) If not, then \$O(N)\$ is the best you can do, asymptotically. There might be other optimizations you can make to speed things up in wall clock time, but the algorithm is as fast as it can be. I suspect, though, that your code isn't actually running in \$O(N)\$ worst-case time, because I suspect that adding an item to a Java TreeSet is an \$O(\log N)\$ operation, since I think they're implemented with Red-Black Trees. If you process \$n\$ items, and each time you process an item you do something with it that takes \$\log n\$ time, then your algorithm has worst-case complexity \$O(n \log n)\$. A Java hash set, which uses a hash table, should insert in \$O(1)\$ time, so your code would run in \$O(N)\$ worst-case time if you used a (as Simon André Forsberg suggests too) instead of a TreeSet. In general, I think that's the best you can do if you're just looking at an arbitrary array of items. 

Then continue refactoring method be method, you'll probably spend a lot of time, but you code became much easier for reading and making changes of any difficulty. As you have constructor, all methods should in it 

Note: it is not final or most optimized version ever, I have tried to show you set of approached you might want to know to optimize your code even further. Benchmark using browser Just open console in your browser and paste following code 

Improvement You don't need to make loop at all. You need random generator that will provide 2 values at each iteration: 

Garbage timeout Look at dummy example of garbage timeout at fiddle. I'm creating array of 30M elements of , that are binded to root object - window. 

Or, if you're uncomfortable with the shortcut syntax for anonymous functions (it can get pretty hairy), like this: 

I'd like to echo the comments: it would be really helpful if you told us what this code is supposed to do, exactly, and maybe explained some of the pieces that touch on what you have here, like what type is and why you chose to represent it that way. In your second code snippet, you have this section: 

which takes advantage of the fact that gets initialized before the loop condition is checked. The class has built-in constants for zero and one, since they're so common. So you can initialize your array list like this: 

At least this code is called more than once, so it is reasonable to make a helper function for this purpose and make more reusable code. But I'm sure that you need few strategy classes and multiform manager to hold options and build flow using strategy instances. 

Second quote sad that it is enough to be unreachable from so called roots objects to be collected with garbage collection. So if you follow all recommendation and memory still leaks, than there is one of problems: 

Here, you will receive which is not very informative, probably you would like to make your exceptions for such situations. Performance of string concatenations As you can see from this post, most efficient methods are using , and list comprehension with . I recommend you to rewrite your method to use list comprehension and make all required checks in the beginning of the method. Sanity defaults 

would call with as the value of and as the value of . The more complex way to do this is to use the module from the standard library. If you're sticking with all positional arguments, then reading directly is probably fine. You can do something like 

Not to be excessively negative, but the solution in the C# code is much cleaner than the one you implemented. No shame in that; it happens to all of us. But I assume you wanted some advice on making the code you have run faster, because if you just wanted to copy that C#, you easily could have. So that's the direction I'll go with the rest of the answer. It honestly puzzles me that this code is so much faster than yours. I would have expected the BigInteger math to be the really slow part, but this code does the same amount of BigInteger math as your original code. Your code does take quite a bit more memory, since it stores all the Fibonacci numbers it calculates, whereas this code only stores what it needs to calculate the next one, and uses an integer to count how many Fibonacci numbers it's seen so far. An array list is backed by an array, so actually accessing the items shouldn't be much slower than with a plain array, but there might be some kind of cache or memory allocation effect. With this code, the compiler can block out a single, static chunk of memory. In the original code, the that stores Fibonacci numbers keeps on expanding, so the backing array might have to be reallocated several times. Every time the array is reallocated, everything stored in it has to be moved over to the new storage space, which is pretty slow if you have a big list. If that turns out to be the problem, you can try passing the constructor a guess for big you think the list might get (the default size is ten). If I were you, I would profile the code and look for some issue like that. Dig into the implementation and see if it's spending a lot of time reallocating. Just see where the code is spending its time, and try to figure out why that's where it's spending its time. If you don't already have a profiler you like, Netbeans has a pretty good one built in, and I'm sure Eclipse and other Java IDEs also have them. If you profile and post some of your numbers, we can probably give you better help with diagnosing performance issues. EDIT: @ChrisHayes discovered why the code is so much slower: it's the call. I took the original code and just replaced the call with a check against a limit of \$10^999\$ as the C# code does. Still used the array list, still stored all the Fibonacci numbers. As Chris Hayes observed, this reduced the runtime from about 900ms to about 13ms. The author of this blog post also found that was quite slow. An answer on this page implies that BigIntegers are stored in a way that makes it easier to implement the method that lets you convert a BigInteger into other bases, like hexadecimal or ternary. One could apparently implement in a more specific way that makes it quick to convert into a base-10 string, but difficult or impossible to convert into strings in other bases, but the standard library implementers chose a representation which was more general, but slower to convert into a string. See the end of the answer for my final version of the code, including modifications I made to get rid of . [/EDIT] Aside from the performance issues, I had some readability issues—not that your code was unreadable, just that it was harder to read than it had to be, and that contributed a little to the confusion that we had over where the number 4872 was coming from. The biggest one is the variable . Unless you're working with coordinate axes, please don't call variables . The C# code gives the analogous variable the name , which is better, since you can tell it's probably some kind of counter. In general, that C# code is quite clean, so it's a good model to learn from, though I'd probably just go all the way and call it . could also work, since it's traditional to index the Fibonacci numbers with . (This is another reason why is confusing; if I'm reading a program about Fibonacci numbers, I can process or the like pretty easily, but is just strange.) I also found your use of the do-while loop with a boolean flag confusing. A or loop with a statement would have been better, but I think the best would be to let the do-while work for you, and write something like this: 

Fixed size value in binary file It is not a problem if you have binary file with fixed size data. In this case all you need is to copy your input file into output (or any other way of allocation equal amount of data) and then make to next value you need to write. Maybe it will be faster to change reading curstor instead of writing cursor, it this case you have no need to preallocate large sized file, just add to the end off file. Varies size value in text file Have no idea how to implement than in memory and perfomance efficient way. So if you can make some restrictions on input data, let it be binary file, in other case try to find out some other restrictions that, perheps, give you some advatages. BTW: if it wont be critical you can try converting file from text to binary for transposing and back to text after that. Explaining Lets look at the followig matrix $$ A = \left[ \begin{array}{ll} a_{11} & a_{12} \\ a_{21} & a_{22} \end{array}\right] $$ $$ A^T = \left[ \begin{array}{ll} a_{11} & a_{21} \\ a_{12} & a_{22} \end{array}\right] $$ Your source file contain matrix \$A\$, while your destination file should contain \$A^T\$. To write data into destination file in direct order you should jump over source file to read each element from current column.