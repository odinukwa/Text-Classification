In , the return type is , but you return and . Just return a and return or . You also never use the variable. Also, comes before , and you probably meant to surround the response checks with parentheses: 

Of course, then you have to fix the other parts of your program that use them. In addition, I'd stop doing assignments inside of parameter lists and and headers. It's dangerous to do so, especially as a beginner. Here I've changed the first : 

shouldn't be a property on the program. Nothing is going to be accessing the file, so if it's going to be in there, it may as well just be an instance variable: 

Using namespace std pollutes the global namespace. It's better to use everything with its full name (, , etc...) 

I'm going to be brutally honest, because I think it will do the most good for you as you look for a job. You say you "have the right frame of mind" and "just need someone to 'nudge' [you] in the right direction." You're way ahead of most of the pack, as you are capable of something much harder than FizzBuzz. However, this code needs a lot of work and a lot of reorganization. It's going to take time to learn the culture of C#, and it's going to take time to learn OO principles in an effective way. If I were you, I'd start writing a lot of OO code in C# in my free time and posting it to codereview. This is C#. You don't need to call on strings. Instead, do: 

This works on the bases that we do not care for order, so an ordered list of each will be a good check. I have not broken out of the inner loop, as it is unclear weather multiple words could match and all of those words should be returned or not. This is untested, as stated, I'm not a Python programmer. 

I'm not a Python programmer but I would take this approach, as if I understand the problem correctly, it seems like an easy solution. Along side that I believe it makes us of the language features also. 

These two individual points should allow you to achieve the maximum score. Now I would just like to quickly go over some theory behind why this solution works. Time complexities It seems people keep asking you to address the "consecutive elements". You have already done this through the use of . This Java sort algorithm is referred to as a "tuned Quicksort" ( See $URL$ ). 

I removed because I don't think it's necessary. I would also check for malformed input, as can fail with an error, and can be something other than , , and . Before I got into the industry, I had flaky UIs that worked if you used it how I, the programmer, intended. There were quite a few ways to misuse it and break the program. One of the first things I learned on the job was that that was not going to fly. Ewan's answer is great for the OO principles, so I'll neglect to cover that. 

Use when you can. It lets the programmer know (reasonably well) at a glance that a variable will never be modified again. The variable can be declared as such since it's never changed. Also, returns a , so I'd probably declare it as such and cast later: 

I'm almost alright with not declaring local variables though. The function names are descriptive enough, especially knowing we're traversing a tree: 

since the rename is redundant. As already mentioned, it's more common to be a bit more explicit with error handling in Go and let utility functions (such as your ) return any errors for handling "higher up". In addition to Effective Go, I suggest looking at the Go project's Code Review Comments page. Although the later is only what the Go Authors use and isn't necessarily more widely applicable, I find it a good starting point. Among other things, with respect to naming it suggests (again as previously mentioned) using , , , etc instead of what you use. Also, while on the subject of naming, I personally subscribe to Russ Cox's naming philosophy which suggests vs , versus , and vs for identifiers used within a short span (as opposed to file or project wide identifiers). When it comes to marshalling to/from JSON, use of struct tags allows you to not only map Go style names to JSON style names but also apply other attributes (notable things like "omitempty": ). In particular, without this if you tried to marshal your stucture back into JSON I believe you'd end up with your JSON fields capitalized (as Go's package can only deal with exported fields). The code review comments page also recommends applying caution/restraint to the use of named result parameters. They can be useful for documentation via but I try and avoid them just to save a variable initialization line in the body. Your tastes may vary, but if you use them be careful of shadowing the named returns (e.g. with a named and inside an if/for having something like ). Instead of using something like to pre-read all the data I find it useful to look for "streaming" based alternatives. For programs that process large data inputs (e.g. reading from a large file) piece by piece this can make a big difference. Here, provides a type for this purpose. In this specific case I don't know if it makes any memory/performance difference but I find the result of using it (and combining your send and parse functions) seems to simplify the code. Back to marshalling, it can sometimes be helpful/useful to create your own thin wrapper types with custom (un)marshalling rather than limiting yourself to basic types. For example, in the code below I've added a type that unmarshals from the way StackExchange API is documented to do all time/dates. You could easily add a method if marshalling was also required. The difference isn't that important here, but for example, it allows easier use of all the methods/functions (e.g. , changing the output timezone, etc. In several places you do things like: 

Another shameless linq answer that doesn't require reversing or creating a new enumeration and only goes as far as it needs to: 

Since there are only three valid key sizes for AES, it makes sense to not even let the AES class be instantiated with any value. I would introduce an enum similar to this: 

Instead of putting the logic in the method, we can change the header of the method and let it populate a list of items visited by that cluster: 

Consistency is important. The rest of your variables start with a lowercase letter, so name the variable in the same way: 

That second is a bit long, but we can rewrite this to something I think is more readable by creating ranges and using as a cross join: 

Just pick one. Here I just return void, keeping with the semantics of the rest of the parameters (pass by non-const reference): 

I would get rid of the continues on the for loop. They can get rather confusing, especially with three of them in there. You can use and to do so: