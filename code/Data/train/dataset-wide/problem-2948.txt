The advantage here is can be anything as long as it shares the same API. OK, so now let's talk about ensuring only one DB connection exists at any given time. Since the DI dependencies are just anonymous functions, you can just use the static keyword inside of the dependency definition; however, Pimple makes this even easier by providing a method that does this for you. As per the documentation: 

Not bad. Regarding your concerns that toPretty.json is visible from outside object-scope, people typically get around this by using the Module Pattern. 

In general, using the "new" keyword in any class is bad practice, because you're creating an implicit dependency. Instead, you should follow the "ask, don't look" design philosophy and require that the database object be passed to the class, rather than letting the class fetch it. Dependency injection is a common solve to this problem, and I'd recommend looking at how PIMPLE is used. Here's a good article: "Dependency Injection with Pimple". Many people, like deceze, will deride you (rightfully so) for doing things like this, because it's one of the easiest (and probably most common) things you can do to kill the possibility of testing your code. If you were to write a unit test for this model, you'd have a database object being constructed with each test. Since the whole point of unit tests is to run code in isolation (to verify the tested code's accuracy), it would be impossible to test this model without a database. On that note, the JavaScript guru, Misko Hevery, published a really superb article on writing testable code: "Top 10 things which make your code hard to test". While this is specifically in the context of code testing, it's also very good general programming information. 

@Tim gave a great solution of his own, so I won't talk about your algorithm, but about your code: Naming Conventions Class and namespace names in C# should be in PascalCase: 

I'm not familiar with Umbraco, and I could not find any documentation on LinFu, I do, however, have some remarks on your code: Comments - your code is more than 40% comments, and un-useful comments at that - a comment that tells me that is is a waste of space and reduces readability of your code - I actually needed to copy your code locally and remove all the comments to read it. Static vs. instance scopes - you chose to put some of the state in the instance, and some in the class, but you manage both from the class. This means that if you create two instances of your class, their state will be unexpected, as they will change each-other's state. If you this class is meant to be a Singleton, make it a Singleton. Use locks properly - you chose to use as your lock object. That's OK, though I don't see why you would need a reader-writer lock. The problem is that you misuse it - the way you use it is as if it was just a regular object. Again, a simple lock object is fine, but declaring it as a fancy lock type, you confuse the code reader to look for (and assume) its use. 

Move the PDO object to a constructor argument (see below) so you're not violating the Law of Demeter (see #1 and 2 here) Remove altogether and simply return the result from the method in which it's built. Break this into smaller, more meaningful methods based on responsibility (see #4 below) Create and methods with optional parameters 

Ah, the age old pragmatism vs. purism. While it sounds like you have a healthy amount of skepticism, I think this is actually one of the few instances where it's OK to use a global variable. The core of your problem is you need to share data (state) between two routes. A global variable is the simplest way of doing this if all you're doing is appending the number 4 each time. Here's some things to consider: 

I ended up using the decorator pattern. The report view and each graph object now implement a method. When the report view's is called, it iterates over each graph, calling the graph's . The latter method receives the report view as a parameter, and this provides access to convenience methods for creating/retrieving DOM elements for the graph to attach itself to. New report view: 

In this solution all calls should be relevant, as they should be around the actual length of each line. 

Make your structs immutable is a helper structure, with public members, which is fine, but you better make them , so you know they won't be changed after the object is created. Choose your validations Don't throw on your own. It may confuse a future debugger. Either throw an or let the runtime throw the for you. Choose your comments Most of your comments do not add much to the methods, and are therefore redundant. Let the names of the method and variables do the work for you. If you feel the name is not clear enough on its own, it is better to rename it (maybe to ) and then you can safely remove your comments. Being nice is better than being strict Unless there is some requirement restriction, I don't think you need to throw an exception if is - why not simply call instead of telling the developer he should? Since there is no meaning for calling twice ( is ...), you might as well hide it altogether, and call it when needed. Use the power of String Use to make more succinct: 

While this may seem "decently normalized", it's not. As you said yourself, there will be a lot of (redundant) NULL values, but also, relationships will not be enforced correctly, as this schema allows for duplicate records for any combination of Post/Group/Link and Tag. For instance, you could have two tagmap records with the same and . Now, while you could add a compound key consisting of PostID, GroupID, LinkID, and TagID, then you have another problem: a single record can contain more than one (non-tag) Post/Group/Link relation. e.g. a tagmap record with = 1, = 1, AND = 1. This can lead to update anomalies. See Second normal form. A normalized solution would be to have three separate tag-relation tables as abuzittin gillifirca suggested: , , and . Doing so will eliminate all the redundant NULL values and allow you to enforce relations correctly. Having said that, I'm guessing you came up with this design, because you want to use a single query to fetch all entities assigned to one or more tags. You can still do this with multiple tag-relation tables like so: 

The above comments should be placed after setting , since they describe ... They are more confusing, since the code does not do what the comment say - it sets the at either or , then totally ignores the given information, and tries to get even if the last statement returned false. BTW - don't use - does exactly the same, and is more readable. 

Naming You should give variables and methods proper names: Consistency Your class contains a method and an method, but also a variable and a method. Either rename to or the other way around (not including the class name of course). Typos It is a very awkward "oopsy" moment when you find a typo in your code, even more so if it is a method name which is already in use or overridden - so re-read your code and try to find them before they become harder to replace... ( should be ) Convey meaning Your variable/parameter names should convey the meaning of what do they hold, and how they should be used. is maybe technically accurate, but does not help the reader know what it is for. Perhaps would do a better job. is also a little too generic, and might be more appropriate. is also very technical, and I think that is more readable, and gives a better flow to the calling code. Don't be lazy In most cases it is a bad idea to shorten words in variable names, as they make the name less readable - don't use - say . Don't repeat type in the name There is no need in repeating the type of a variable in its name - does not reduce anything by omitting the word from it. Comments When you have good naming to your classes, methods and parameters, you will find that most method comments are simply re-iterations of the method signatures. Likewise, when you find that a method/parameter needs extra explanation in a comment, it might be because it has a bad name. So, is very self-descriptive, and doesn't actually need any documentation. Comments have a nasty habit of rotting - when you change the code, you tend not the maintain the comments, which after awhile will stop describing the code, and sometimes even totally mislead the reader. (see , for example) Encapsulation Keep internal data of a method inside it - don't expose it in your signature. and have no business in the method signatures. One is totally internal, and the other should be instantiated within the method and returned rather than passed by reference. Declare variables only when they are needed There is no need to declare variables at the beginning of a method if they are only used at its end. 

After a cursory glance at the character codes for these, it looks like the lowercase is 32 (decimal) higher than uppercase. e.g. 'é'.ord - 32 == 'É'.ord You could try something like this: 

I think this is fine for something as simple as a volume control; however, there are some limitations to at least be aware of: 

You could simplify this even further by using a single CSS class for all elements that need animating. e.g. Also, if there are any animations that are triggered by mousehover, you could do all the animation in CSS with the pseudo-selector. Finally, make sure the CSS transitions you use are compatible with all the browsers you're supporting. 

This looks pretty good, not much room for improvement I think. LinkedIn's JavaScript is calling linkedInApplySuccess, correct? All you have to do is specify data-success-callback, or something similar, in your HTML? The only minor thing I would do is instead of sending just the job ID, send the entire JSON object. As long as resources aren't an issue, it's always best to capture all data and disregard the stuff you don't use rather than only collect the stuff you're currently using; this is because requirements change, and in the future you may want to do something with the data you've been ignoring. For instance, you may want to calculate how many people are applying for jobs with the position "Chief Weasel Wrangler". You can alter your code to something like this: 

I don't see what you will gain with your hypothetical syntax, let's say there is one... your code will look like this: 

My code still runs ~2 times slower than the original (ends in 18 seconds), but it is more reasonable than with ... 

Redundant code is exactly the same as . Be consistent In different places in your code you check equality either as or as - choose one way - and stick to it. *Adding @Marc-Andre's observation: You should also be consistent with your indentations and braces locations. Although Oracle's suggestion is to put the opening brace at the end of the line, 

Your method looks very nice, and I don't have much to say about it except Good Work. I've read the code a few times, and even then I almost missed this: 

As I read the code, it seems that what the method does is control the business flow as defined in the specifications. Since all it does (at least as it is written here) is delegate the actual actions to other methods, I don't think 'it does too much' - its single responsibility is to control the flow of the registration process. To answer your concerns about future maintenance, I see two possible kinds of new features - features that should affect all the service consumers, and features that affect only a single (or part) of the consumers, but not all. In the first case - there is no problem - do your change in the code, and it will affect all consumers (if you move the code to the controllers that won't be true, since you'd need to change all the controllers...) In the second case, it should be easy enough to create a new register method for that use case. Since all it does is delegate, the new method itself will be just as simple as the old one, with maybe a delegation to a new method, something like this: 

Since RequireJS invokes the module, it would be problematic to construct dynamically. There's no good way of creating more than one instance of your view – probably not a problem. The View is tightly bound to a specific DOM structure. This means it will require extra code to make your View responsive. e.g. a small volume control for mouses (desktop) and a big one for fingers (mobile). 

I'm not following. Which file/object? You appear to pass the JSON object from to your constructor, and this is just a plain JavaScript object. 

Doing so would change how you bind your events and render your HTML, so I'm leaving it at this just to give you the general idea. 

Looks pretty good to me. Regarding , definitely don't put this in its own statement, because if there's a problem with the earlier code, the connection might not get closed. I know you're not using Python 3, but ss an alternative, you might consider using the statement and let Python handle the closing for you. See $URL$ (end of section) and $URL$ Your code might look like this: 

Let your code breathe Your code is very hard to read - lines are long and crowded together, containing multiple method nesting (). Reading code is like reading a book. If you don't give the reader some breathing room (a period, coma, paragraph) - your reader will get lost, and might abandon the book altogether. You should consider adding a few blank lines to make the structure of your methods more apparent, for example: 

Update It seems that adds considerable overhead to the performance of the code. So it is not advisable to use it. Fortunately this works: 

Calculates interest or the new balance? Also, don't be lazy say - - there are no fines for long names. 

I believe the easiest way to avoid duplication each time you read from the database is to create a which receives a as a parameter, and does the heavy lifting: 

Regarding and , @BroiStatse suggested caching , and I'll say - you don't need to cache ! Once you have used it, you don't need it, so if you load the XML on initialization - you don't need to save at all: