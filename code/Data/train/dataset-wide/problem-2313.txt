PS. additionally you have to learn the difference between SuperServer (targeted at small installations) and Classic/SuperClassic servers. For running 24/7 the second options would be preferable, since frequently the server instances would be shut down after user disconnects. So while "server" as a concept keeps running 24/7, the actual executable programs of it get closed and restarted, easening at potential problems like memory leaks in server or UDFs. OTOH Classic server is more vulnerable to cache synchronization issues like in case of crash during Garbage Collection or attempts at metadata (scheme) changes while users are working. In FB 3.x they promise to integrate those two approaches to make it a kind of sliding scale options in firebird.conf 

Reads data as a usual SNAPSHOT transaction, thus db errors would effect it. Some db erors would manifest it in read errors (like if DBA changed column type in a way incompatible with data), but other might result in some data being "invisible" and skipped. Backup file is stripped of fast-access metadata and geta a lot smaller, which is good for archives (example: 1.1GB of raw database -> 380 MB FBK -> ~700 MB after restore). In FB 2.x GBak is known to work considerably slower via TCP/IP than via Firebird Service Manager connection. It is told to be amended in forecoming FB 3. Restore is basically recreating database, so it is slow. But it optimizes the database internal layout and saves some space (no more half-empty pages in the middle of the file). Due to Firebird being very liberal in online (during active operations of users) scheme change (the safe approach was enforced in 2.0 but undone in 2.1 after uproar), the traditional backup might be "unrestorable", so the attempt at restoring a FBK file into a spare free disk is a must. Until you proven you can restore that backup, you may consider you don't have it. 

Just a few words describing the data: In my application, there are acceleration measurements (for example at 25kHz) for the exemplary duration of one second. These measurements get repeated in not necessery Ã¤quidistant time steps for that measurement point. (Maybe each five or ten minutes). This is a kind of interrupted permanent monitoring, somehow two-periodic: 

I hope that my question shows the Situation. I'm looking forward for ideas (thanks in advance) as for today I think arrayial/vectorial are not enough regarded by timeseries-DB-creators. 

When using JDBC I like the new to establish the connection. Further I like the isolated set-Methods for the properties like , , , , , , and so on. The question is (esp. for the use with Oracle), if there is a way to set up LoadBalancing with two or more servers without specifying the URL directly with 

Hoping to address my question within the right Forum. If not, please assist me, where to ask. Having an use case in which I get one-dimensional acceleration measurents delivered with a given sampling frequency (for example f_s=10 kHz) for a given range (for example T=1 s). That measurement would be repeated periodic (say for example every P=60 s). In that example, it will give me a vector of acceleration measurements of length 10'000 float values each minute. For evaluation purposes I would like to store the attentand Fourier Transformation of that vector also. Now my question: In which database (timeseries-db or simple relational) and how to store that data? In my understanding TS-DB are highly optimized for storing timestamped scalar values. But what, if I have (not so short/small) timestamped vectors? I'll present my thaughts on that question for deeper insight: 

Back-up is very fast (just dumping of changing pages), can use cascading (database -> monthly large snapshots -> daily deltas from last monthly -> hourls delta form last daily). However it does not optimize (by recreating) the database. And it does not detect database errors other than top-level, errors of pages allocation (like "orphane page") OTOH the pages snapshotted are mostly intact, so in case of partially corrupt database they might still have a manually salvageable data. If the corruption would be noticed quickly. In a sense, that amounts to safe and incremental copying of he database file(s), wit hall the cons and pros. 

OTOH is the main and shadow servers were in different networks (offices, cities, countries) and the link disappears between them, then one of the networks would see it as crash of the main server and another would see it as a crash of shadow server. When the link would be repaired, the databases would have new different conflicting data entered by users. 

Yes, it is possible and it is covered in documentation and in lot of FAQs like the one at iBase.ru For the example at my development box I have co-installed FB 2.1.5 Win32 SuperServer (at default port 3050/tcp) and FB 2.5.2 Win64 Super-Classic (at a custom 3064/tcp) There might be troubles with FB 1.x as it was using registry, but FB 2.x was made isolated and self-dependent. One option is to download ZIPs and unpack them to different folders. Then you have to run text window of Windows Command Prompt "As Administrator", go into "bin" subfolder and there are all those executables like server itself. There also is "inst_svc" tool. Running it with an option like "-?" would show you brief help. Focus on installing main service, not installing Guardian (only needed on Win98, only shipped for legacy uniformity) and giving non-default "instance name". Then go outside "bin" and open "firebird.Conf" with any text editor like notepad. The documentation is within that file how to set non-default TCP port. That's all. Do the same for your another FB folder and you've done it. Another option is to run two installers. The 1st one would do all the described above things automatically. The second one would unpack files - and ask you to do those configuring operations for the second copy manually. Just do it like described above. 

Each array/vector (time domain data and spectral data) as a blob? Compresses? Each array/vector as a linked CSV-file? Compressed? other ideas 

I can understand each scalar value of acceleration as a single value with a given timestamp (could be calculated from start of measurement, index of value and sampling frequency). I think that could easily be done with a TS-DB. The timestamps would have two different sampling properties - one is f_s and one derived from P. I'm not sure, if it would be efficient extracting the measurement arrays/vectors, as always it would neccesary to find the beginning of those arrays/vectors. Furter I'm not sure, how to store the Fourier spectral information, as they belong not to a single measurement or timestamp and it is a complete array/vector and not only a scalar value. Storing the whole acceleration measurement vector with the timestamp together with the Fourier vector (understanding each array/vector as a related to the timestamp) might be a clearer view. But how to store best? 

There are 20 or more of those points. As dealing with time series, the first idea might be the usage of a time series db. On the other hand, for me it seems as if the main purpose of time series db is storage of scalar values. Of course, my measurements are scalar values. But I'm not sure if it would be a good idea to store every scalar value as a (time/value/measpos_id)-triple - leading to an enormous number of entries. I think single of those entries would never be evaluated. Another idea could be the storage of the measurement vector (all values from that second) together with the starting time and the measpos_id. But howto do that? Taking all values as a blob? Not every system is capable of dealing with vectors - and maybe they differ in length. Are there concepts in timeseries-db for such problems, which I'm not aware of? Further for evaluation (extraction) I think maybe the exctraction of the complete vector would be the most used case. Please feel free to ask, if my description is incomplete or some more details could help in finding a good solution. What are your recommendations? NoSQL or relational SQL? Further ideas? Every hint is welcome. Thanks in advance. additions: