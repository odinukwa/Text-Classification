Then we declare the main method for getting the highest combination. I decided to make a line in four different directions for each point and check to make sure the line's points are in bounds before creating it. 

If maxReactionTime is not , then it has to be , so you can turn the into an . You can then refactor it to one line: 

You can get rid of a lot of repetition in by storing things in arrays and accessing them by the . You can set up your arrays like so: 

In , you can move the statement outside of the loop and get rid of the part, keeping the statements. You can also combine the predicates of the successive statements using . If you want, you can calculate the "constants" using a specified board width a edge width. 

I'd advise that if you're looking for 100% compatibility with here, you'll probably want some extensive unit tests. Here's what I came up with that handles the edge-cases I threw at it, but I don't expect it's bullet proof either. Main changes are using the format specifier, and using to get the number of digits before the decimal place instead of . 

Well, the calculator one at least could be simplified since you're always adding/subtracting the same: 

That's not going to do a whole lot for performance (basically get rid of a rows iteration), but everything else I see is really context specific that may end up with worse performance assuming your data looks like I expect it does (< 10 , < 50 and thousands of rows). A couple of additional thoughts you can try, though, depending on your data: 

In , you can get the product names before the loop and loop through those instead of looping through dictionaries, filtering, and then getting a product name each iteration: 

A method would be useful and more efficient here. You can implement your own or find it in a library. I believe all the Project Euler problems have a solution that is a lot faster and more memory efficient than brute force. So you can try to figure that out for this problem next. For the later Project Euler problems, brute force is not an option. 

Why does have three parameters but only use one of them? should be declared inside the loop because it's not used outside of it. You can assign it on the same line that it's declared. 

Now that we can see that we're looping over all the rows for each , we can change to traversing once and pick up any along the way. This effectively flips the order of iteration (I'm assuming there's more rows than query strings). To get rid of the nested loops altogether, we'll switch to using to find any matches. We'll also drop the check on each iteration for a single call at the end. That should keep us from iterating multiple times. 

Once you have the of the integer portion, you can use the format specifier to get the correct number of decimals, which would clean up the string building part. 

The braces should all be indented by four more spaces, and should not be indented more than the above brace. isn't a very descriptive name. I'd go with something like . Most of your loops can be replaced with LINQ, which is more concise, safer, and easier to read, in my opinion. For example: 

An alternative solution is to create a function to get take an item and get that item's sorting order and then use that in an . This method takes a collection of the tests for the front and a collection of the tests for the back and returns such a function. 

Lastly, your organization is very confused. You make one class responsible for too many things. There is no need for one class to both handle finding the max value in a range and to compute the cycle lengths. But, while these issues are important, I can't see that fixing them is going to shave more than about 20% off your time. :-/ 

This is only slightly faster because some processors have a combined 'find the remainder and quotient' instruction that this leverages. It also avoids testing even numbers. If your number is not divisible by 2, it won't be divisible by any other even number other, since all even numbers can also be divided by 2. Also, make sure you have compiler optimizations turned on. 

I agree with your teacher that you should have the print method do as little else as possible. You should try to have methods that do only one thing because they are easier to read and test. Another thing is to keep your code DRY (Don't Repeat Yourself). If you have code that is repeated, you should refactor it into a separate method. So you have two reasons to print the results in a separate method. Also, you can replace the loops with LINQ, which is more concise, safer, and easier to read in my opinion. I prefer to explicitly declare whether each method is public or private. 

will exit at any key; you want to change your message or change that to to require an . AppCoordinator Your class is a major code smell; it's a (no offense) terrible name that really doesn't describe what it's doing, and is likely to become a "god object". I would rename that to or or something. Since this is your largest class, the meat of my comments are here: 

Ok - that pretty much gives us our product management functionality. Now, on to UI. You've got the right idea here - console input/output should be handled generically, so let's expand on that idea and write a few generic helper classes. A good way to think through this is figuring out what portions of what you need to do are specific to your app, and what is a generic concern. You should try to split those as much as possible. These won't have anything to do with , so they'll be reusable in a different console app. 

This is overly confusing, and things are obscurely named. This is a one-off for a programming contest thingy, so it doesn't seem like it's that important. But I find that organizing my code well helps me think. You might find that's true of you. Also, you have several fixed sized tables that are very huge. Quite likely unnecessarily so as the short cycle lengths for large numbers indicate that most sequences converge rather rapidly on a common chain. Lastly, you keep a stack of values when no such stack is necessary because the problem description doesn't require you to print out what the chains are. And even if it did, a very slight tweak to the table contents would allow you to easily print out the chains by just following pointers with no stack necessary. There are other details that seem minor but are actually a big deal. For example, you create an empty vector, then assign it a very large table. This will create two copies of the very large table, and throw away the (rather minimal admittedly) work done to create the empty vector. Since this last is a very specific coding flaw, here's how it would be fixed: 

Now, each filter simply takes an input and transforms to an output. We need a pipe to tie to it all together: 

You can over the directly, getting a . Or you can over and just get the . Either would be preferable to going over the just to get to the (and you don't check the return of ). I'd also change the name of your variable since the trailing implies that it's multiple dictionaries (FWIW, I'd probably go with just just so I didn't have to ever read a potentially offensive word over the phone; but that's just me!)