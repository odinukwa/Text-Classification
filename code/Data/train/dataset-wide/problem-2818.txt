What you're saying here is that it is all about the colors that make it to the screen. Then why don't you put the ASCII's 0xCE for double line cross and 0xCD for double horizontal bars directly in the errortext? This will avoid using as an argument ( remains of course) and will save a lot of bytes on many occasions throughout the rest of the program. 

I've also avoided the duplication of the instruction that you already had in the top part of the program. Shaves off some bytes! 

What this BIOS function returns in , , and are the highest allowed values for Cylinder, Head, and Sector. Cylinder of course also partly in ! I don't think there's any reason to believe that the total number of heads could never be 256. If BIOS returned (indicating 256 heads) your code would simply fail. I suggest you define the hdPerCyl variable word-sized and set it up using: 

The main loop performs a redundant first/only iteration as mentioned in the answer by @DavidWohlferd. You solve this by a one-time jump towards the end of the loop: 

This is a misleading comment! Since the premise states that the results are to be below the inputted number, the line conflicts in the usage example given. 

In this code there's a lot to optimize. Step 1, remove a redundant and the now unnecessary label lxisetup1: 

And here you only want to increment the qhigh variable when there's a carry from the previous operation 

Now mask1 can be found at address [masks+8 -0] Now mask2 can be found at address [masks+8 -4] Now mask3 can be found at address [masks+8 -8]. Using the masks. Comparing EDX to 0 can also be done through decrementing EDX and watching for the sign flag. A simple negation of EDX gives the negative offset needed to fetch the correct mask. 

Currently your program depends on the zero stored in number. In future you might want to re-use number several times and then the zero-terminator might not be there anymore. I think it will be more robust if you wrote 

You'll agree that much that was said about the 16 bit version also applies to the 32 bit version. To be honest, I found it lacks so much on comments that I hesitate to actually review it thoroughly. I will however point out the next optimizations: 

The first improvement you should do is making use of the possibility to fall-through in the code. Don't use but rather fall through as equality is the only state that remains after and . Also ifEqual would be a more correct name for this state. 

Because you used to test the exit condition, you denied yourself the chance to use ASCII's in the range [128,254] when constructing this prompting string. Just use the instruction, it's equally small. 

A better strategy will be to simply subtract without looking at which number is the largest and then later take the absolute value of the difference. 

You've placed the zero before the carriage return/linefeed. Those won't be outputted as a consequence! 

At first glance this felt wrong. Rest assured it's correct, but the mention of something relative to always only makes sense when it's absolutely clear where is pointing to. I would have preferred it like: 

If you used the register for the BF data pointer and the register for the BF source pointer, not only would this be a more natural choice, you could also dismiss the and around . By further using for the loop depth you can also eliminate the need for and around the same . Do note that clearing a register is better done trough an instruction: 

Nice, but wouldn't it be possible to combine a few things (the first and the second )? Yes. Using and a conditional complementary the code has yet again shrunk, this time by another 2 bytes. 

I've moved the higher up in the code so SetFinalBytesLoop can benefit from using the register vs the immediate 0. 

You've used a WHILE-loop here. A REPEAT-loop would have been more optimal. Also a better way to zero a register is by -ing it with itself. Furthermore by using the register you eliminate the need for the and : 

Elimination process. The order in which the eliminations take place is crucial. Not only for obtaining correct results but also because choosing an optimal ordering reduces the number of divisions by 5 to 6 percent, as next table shows. 

It's perfectly possible to move the numbers in the variables without putting them in a register first. But in the case where the same number goes into more than 1 variable using especially the register is advantageous as it reduces code size. 

This is where your program has its first error. You trust the user at the keyboard to actually input a digit, but your program should make sure it indeed got a digit! 

All of these assignments require a 32-bit immediate value. That's a lot of bytes! Because later we need , we can start with clearing and incrementing twice towards 2, storing the intermediate results in memory: 

You don't need the instruction because the 4 instructions in a row already leave the high nibble empty. This shaves off 2 bytes from the program and reduces the number of cycles by 2. These benefits double because you used this construct twice throughout the program. 

One final point about this code is about the use of . The negation of zero is also zero. That's why this kind of testing often uses which guarantees the value gets modified. This doesn't impact your code however since you've chosen an address that certainly does not contain zero. But choosing a fixed address like eg. 21h*4 (DOS isn't loaded for sure) would make setting up much shorter and even allow you to not use at all. 

By popping exactly 80000000h, you guarantee that the will produce the desired 80000001h. I've used because it's 1 byte shorter than . 

Yours is as good a solution as anyone else's. That said, a solution that pushes the elements would not need to address these elements relative to at all. 

Since your intent is to put the value on the stack in , do so in one go with . And moving the register to the register before the instruction is wasteful since the division can simply operate on directly. Next some improvements you can apply 

Defining the masks. If you are willing to address the masks through the instruction then a 50% gain in storage for these masks can be achieved. The reduced alignment condition will further add to this gain. 

Seeing "This is determined by..." makes this paragraph somewhat mis-leading because it would seem that Long Mode capability is determined merely by looking at EFLAGS[21]. Your code correctly does it in a 3-step process, but that's not something that the reader sees right away. People with less time on their hands might have given up reading already! 

Still room for improvements. In an effort to get rid of the separate instruction I came up with a 1 byte smaller solution. This also no longer contains the complementary that you commented about. 

The output can easily be customized by changing the 3 compile-time variables (number of )COLS, (number of )ROWS, and WIDTH( of one column). The only restrictions are that the product ROWSxCOLS must fall in [1,255] and that WIDTH must allow displaying the 3 digit number, a separator, and any combination of tags.