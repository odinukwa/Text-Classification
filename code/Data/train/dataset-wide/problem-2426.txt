But i am not sure about my design of this singleton. Would the instance be visble to getLogger when I export it as a module to another compoent? 

so I could find where any problem would occur (try/catch) and to be safe against injections and invalid characters (prepare) (I had some personal checks but I am pretty sure that a function specifically made for would be better). When I had one or two queries it was fine but after the code grew it became a little too much code for little action/substance (like 16 lines for one query...) So I would like some advise. How do I make my code more manageable? Is there some fundamental error in my logic on structure (the way I wrote it)? Is there some rule for using try/catch? Is it more for developing and debugging and afterwards you can remove some blocks of it? Is prepare enough for rudimentary security on queries? I was thinking of making a function of just this block of code and calling it with the statement as a parameter. So I would just 'type' the query in the main body and then call the function where it would be prepared, executed and then return the result. Of course then I would always use fetchAll and would return an associative array but I think as long the datasets are small the memory usage would be fine (in any case in nowadays systems it should take A LOT to notice a difference, I think)... EDIT: I was told about abstraction layer, which I admit I am a little fuzzy about. Basically it is a class which is instantiated every time the script/function runs and wrap the functions used repeatedly (along with the checking I do) inside it? 

Disclaimer : this is not quite an answer but more than a comment. You've written tests and I'd like to start by thanking your for this. This definitly makes reviewing easier. Good think to know if that you can make easily double the amount of test you have without thinking too much. Indeed, it seems like by inversing the parameters of your function, the return value should be the opposite value. You can write this : 

In for instance, we can see that a situation leads to a result being computed and returned without being store in the memoized list. Also, that case could be handled with less duplicated logic: 

More optimisations You could compute the limits outside the nested loop. Your loops are actually loop in disguise and you could make things more efficient by using or you could use the argument of range to use the values you'll actually need : (in both cases, there might be an off-by-one issue but I'll let you check and fix). Final (untested) version of the code 

Single source of information / magic numbers In your , the magic number 3 appears twice. Because the function is so short, it is obvious that if you change the first, you have to change the other one but it is a good practice to use a local variable/argument/global constant to store this value so that one does not need to change it in multiple places (and potentially forget a few of them). Conclusion I have to go, I might continue this review but at the moment, the code looks like: 

As you can see initialiseLogger gets some app config and creates a logger which then gets assigned inside a const object that then becomes immutable. I also expose a getLogger method that is going to be used in the other components to get the logger and then log what they want. Example: 

I am not feeling 100% sure about this code. Should I go for a singleton pattern and just expose the getLogger function. Something like 

This it he top level of my React app. I initialise my logger here. And below is the logger. I am using our ui logger by my project. It exposes one function called configure that creates a logger based on some params. Each time it gets called it will create a new logger. 

I have a web application where I connect with a MySQL database using PDO and in some scripts there are a lot of queries one after the other which don't necessarily concern the same tables. i.e I will execute a SELECT statement in one, and then depending on some values I will UPDATE another and finally go and DELETE from another one. The thing is I only recently learned PHP and MySQL and because I wasn't sure and wanted to be careful and to find easily any problems (and a little because I am a little ocd and anal about silly things like uniformity and coding style) in every query I used the following format