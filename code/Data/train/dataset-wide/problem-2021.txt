To some extent it depends on how you intend to use that data. If this is an audit table used strictly to be able to occasionally research who changed what and when and occasionally restore bad changes, then option 2 is fine. If you intend to display user history to the application or through reporting, use option 3. I can think of no circumstance where I would use option one as it beciomes a places where blocking happens. 

I'm going to add one more scenario to @ooutwire's answer. You may also want to create an audit trail if you need to be able to selectively fix bad data changes. For instance, suppose I have imports of the sales roster for the client. One time they accidentally remove a name and our process assumes she doesn't work there anymore and removes her access. But she does still work there and in order to immediately correct the problem (I can't just run the previous roster as that would remove the new employees), I can find the data that was changed through the audit log and restore her. Or if someone maliciously changes data or runs a bad table update query (I saw someone update the entire table once because he forgot a where condition, the audit tables saved his job), it is easy to get it back. I have never worked on an Enterprise system that didn't use and need auditing. This data is critical to the success of the business and the ability to fix it quickly when things go wrong is priceless. 

The answer depends on what you intend to do with the data. Are you going to be doing frequent queries against it or do you only need it for the occasional lookup of what happened when, to rollback bad changes, or for regulatory reasons? In the first case above, use the second process you descibed although I would add a column to denote the active record. I would also add a record created date. I wouild also create a view of just the active records and use that for allof my code that needs to see the current data. In the second case above, I would have audit tables that are populated through triggers (the offective way to create audit records for any change to the db) and that also include the data of the change and the user or application that made the change as well as the old and new values. 

It of course would depend on what type of temps you are recording and what temperature type you are using and what level of detail you need, but Decimal (4, 1) would be what you would want for most outside temperatures if you are using a Farenheit scale. Celsius outside temps are probaly OK with Decimal (3, 1). If you are doing scientific work, you might want more places possibly both in front of and behind the decimal. 

First your problem is that you are using Access which is not going to perform well with the struture you need. Your problem is most commonly solved using what is called an EAV table. This is because you will probaly be adding more and more exam typoes weach of which will have differnt parameters. I would structure it so that I had all the common details about the patient in a patient table (and some related tables for things that change over time or that have mulitple values such as address). I would then Have an exam table with dates and a study table with the current studies. Exams patient and studies would all relate through join tables (patientid and studyid inthe patient study table and examid and studyid in examStudy table and patientid and examid in the patient Exam table). This is becasue you ahvea many to many relationshsip between these things. Now as to the exam details this is where the EAV table comes in. It would include Examid, parameterName, parameter value) You would then inseter a record for each value you want to store. That way you can add and change them as the exams change. They are harder to query this way but this is exactly the use case that EAV tables were designed to meet, frequently changing values that can't be knwon in the original design. Access may not handle this well, so you might want to consider a nosql database for this part. And of course you need to protect patient information according to HIPAA rules. Be very sure you are aware of them and how to prtect the data. Again Access may not be the best choice for that unless you don't intend to store client names and addresses etc at all. 

Something else that can cause ridiculous growth is failing to backup the transaction log frequently. It will grow until it uses up all your space if you don't back it up. This is separate from the database backup. Check out the size of your transaction logs too. 

It is a very poor practice to expect to maintain the PK/FK relationships from the application. In any db that is nontrivial, data has close to a 100% chance of being changed from other sources including ad hoc queries, data imports, etc. It is irresponsible to think the data in the database is protected because the application has protections. Sure you think that you will force all changes through a webservice or some such, but the reality is that no one is going to add a million new customer records, from that company you just bought, one record at a time through a service. Your database has to be designed to account for the fact that people will change it directly at the source or through other applications (some of which may not be able to use your web service). Further, the application interface is usually more likely to be thrown away or redesigned than the data and when that happens, you may lose all or some of the data integrity rules. In designing databases, you have to think about how the data needs to be protected over time not about what is easiest and most convenient for the programmer or the intial application. A data professional sets up PK/FK relationships in the database because that is where the data lives and it is the best place to set it up to protect the data quality. I see data from a lot of different companies in my current position and I see all too many that didn't set up their PK/FK relationships in the database because they have data integrity problems that a correctly designed database would not have. 

Bill gave an excellent answer. I would add that I would login to the user interface as a test user and try to understand exactly what the users do with the data. It will help you understand the why behind some of the stored procs or design. Understanding what the data means and is used for is critical to understanding a a database. If the database is on a business function or subject you are in general unfamiliar with (say it does flight planning and you have previously only worked on financial applications), then ask the users for some reading material on the subject matter or go to the library yourself or search the Internet about the subject matter. Ask the users if there are legal or regulatory issues you need to be aware of. Again some of this subject matter background may explain what seem to be odd design choices. 

I would prefer the first version because you probably only rarely need to see the history but you will frequently need to see the current value. A history table should be populated from a trigger, so you don't need to worry about the data getting out of synch generally. So suppose you have a million records in MyObject and then you have 10,000,000 record in MyObjectHistory. Do you really want to join to a table with that many records to get the current value? Now if you are going to need to query the history as freqently or more frequenlty than the current value, then the second struture would work. (And if you are going to be displaying the value as of a particular date, I would have a begindate and enddate field in it to make querying simpler.) BTW I would add a date field to the history table to be able to tell what order the changes happened. You can't rely on identities for temporal order. PLus if there is a question about a previosu value and when it changed, you will need to knwo. I might also put in values for the application the change came from (if you have multiple applications) and/or the person who made the change.