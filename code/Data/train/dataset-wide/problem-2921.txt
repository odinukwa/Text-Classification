It's still a valid implementation of , but we can add more stateful behaviour to it. (And the class will never know!) Let's have a look at what looks like now 

To me this is someone screaming that they want you to use inheritance in some form or another. In your current code, you have a single class, and you maintain the different levels of in 3 different lists, and then you keep track of them by index, 0, 1 and 2. I think here we can make Employee an abstract base class, and create 3 concrete implementations. These will be , and . These could look like 

(we no longer need a getSongName() method now!) if you had a Map, your selectPlayList would almost be identical. 

In your current main method, you do lots of List manipulation, all of this can be done elsewhere, you shouldn't need to know how it works. As a side note, there are a lot of redundant comments in your code. Comments should say WHY you're doing something, not WHAT you're doing. I know that when I see object.method() that you're calling a method, but I might not know why you're saying instead of just , for example. I hope this was helpful for you, keep it up! 

I wanna start of by saying that I think this code is to a very high standard for someone just completing their first project, the game is overall well put together. So for this review I'm going to primarily focus on your question regarding the MVC separation. At the moment, your class has too many responsibilities. From looking at the code a little bit I can pick out a few. 

it's looking very good! I had a few things to talk about. Don't use for string comparison, use . If the test is for checking equality, using will give inconsistent results. See this question $URL$ Exception Handling, I think overall the exception handling is very good, but I think you may have gone a little overboard with regards to your Exception class. I like Exception, though. An exception is supposed to be raised when an Exceptional thing happens in your program, I would say that someone trying to fill an already filled slot is that. But the end of the game is very much a core part of the flow of your game! To me, something like this makes more sense. 

these could maybe just print the elements in the given order, or maybe return a list of the elements (not the nodes) in that order. Overall I think it's looking very nice! Keep it up 

But then , and are not great variable names. They do have a small scope and are used immediately after, but there's no reason to not give them a better name. Why not just call them then in the next loop you can just use 

So there's not a whole lot of code here, our just makes runes a player through all the levels. It we then just do a short class to tie it all together. 

Now, these variables have names that indicate what they are, rather than just a single letter. Also notice I got rid of completely, you were calling for the effect of prompting for them to press enter, we're not actually using it so we don't need to save it into a variable! Something that's sorely lacking from your program is the use of functions. Functions have many benefits, in this particular case, they are a way of re-using code, but also a way of making the code more readable. A prime candidate here is the constant use of . Why not put this in a function instead. 

At the moment this method simply prints that the is searching a chest, why not provide the option to search any object. 

now we just put all our there. At the moment we have 3 different methods for adding employees, again we only need 1. 

Thanks for sharing your code, it's looking good but I think we can make some improvements. Currently, the method doesn't actually make use of ! We can just remove that, so we end up with . And then when we call it later, we don't need to pass in a object. you say that returning null is a bad idea. I agree with you, and would suggestion you use an instead. This was introduced in Java 8. It's intended purpose is to act as a value to return when the actual return value might not be there. To me, your example looks like a good use case! Let's see what your method looks like if we use an Optional. 

and let the garbage collector worry about the rest. You would of course still need to check that all of these values are okay to use like this before hand. LinkedLists are supposed to be good at adding and deleting elements from the start. And if it's a doubly linked list, also the end. As side note, I would prefer to see your Node class as a private class inside your linked list class. As this Node class probably shouldn't be used anywhere else. Your public interface is a bit unusual, for a list, I would expect to have public methods like , etc. is an implementation detail, this should be a private method that's called when the list is empty. if I wanted to insert an element at the head of the list, I would prefer Another thing that stands out is your deleteNode method. This is definitely an implementation detail leaking out. A user of the list shouldn't know at all about Nodes. The method doesn't even take a node, it takes an int, I would prefer . Also, your list won't properly support duplicate values, if I have 3 nodes with the value if 5, and I try to delete 5, it will delete the first node with a value of 5 it finds. As another side, you should make as many variables private as possible. 

From your question, it looked like the was some sort of requirement, if that's the case, I would ask whoever set the requirement why! Misc you can re-write as . Similarly for -> Hopefully this review was useful for you, and that you can see the benefits of naming things well and using functions to increase code re usability as well readability on top of reducing code duplication. 

thanks for sharing your code! There are a few pretty big issues with your current code. Variable Names Your current variable names tell us absolutely nothing about what the variable is, or what it's doing. and tell us nothing. If someone needs to read through your code following a poorly named variable just to find out it's purpose, that's not a good thing! Remember, other people reading your code didn't write it, they won't know what each variable is unless it has a clear, meaningful name. Let's just look at this short snippet 

Okay so now it looks like if the list is empty, the other player wins. And one more example, this code 

Same goes for the Artist class in terms of immutability. Naming In your Song class you have playSong and getSongName methods. These are methods on a Song. there's no real need to specify song in the method name too! We can simply have 

Now, we don't need the comment anymore, and as a reader, we don't even need to know what the number ALWAYS_WINS is. We can do a similar thing with 0. Naming This maybe also belongs in the readability section, but thought it deserves its own because naming is such an important aspect of writing readable and understandable code. 

in 6 lines we have 4 mystery variables. Now, of course I can make a stab at what these are based on context, but I should be able to know what they are from their names! How about this instead: 

I'd just like to add a few more points on top of what @RobAu has already suggested in his answer. It's considered an anti-pattern / bad practice to use exceptions as control flow. In your program, you throw / catch an to re-start the user input process on an invalid input. I would recommend that you simply continually prompt for a valid value instead. You should keep the main method in a separate class. At the moment your class has multiple responsibilities. It's in charge of being the game, but also as the runner/driver of the program. I would expect the main method to look like this. 

What if you want to have Enemies fight each other, different factions etc. There's no need to limit the potential targets, how about 

So no the class is your "Runner" and is used in your main method, it contains an instance of a and a . Hopefully you found this review helpful, keep up the good work! 

I think a method that prints an element from a collection is a bit unusual. What I would expect is a method called that returns the top element but doesn't remove it. By just printing it you're limiting its use to console only applications, and the only way to retrieve the element is to remove it! You should consider adding an error message to go with your , and maybe reconsider the exception type, an sounds like you're accessing an index, but you're not maybe a custom exception would be more suitable. I think should be (plural) as it will be representing zero or more items. Bonus Stuff you could implement the method. This would allow the caller to do something like 

Thanks for sharing your code, You should write code to adhere to the PEP8 standard, for the most part you've done that correctly, you have variable and function names, but you've put all your imports on one line. 

Some final points to consider. When you another entity, you could get the currently equipped and the other entity's currently equipped and do some simple math based on their instead of a method, you could just override and then print the directly in the calling code. Before you start coding anything, think about what Objects could be involved in your System/Game in real world terms, then start thinking about how these could be implemented as Objects in your code. Instead of , why not just make a of Weapon objects. Hopefully this review was useful for you. Keep it up! 

this print statement is unreachable code. If this is the actual indentation of your code and not a mistake in formatting when writing your question. A return statement exits the function, code after a return statement will never be executed. If you want to print it, simply change the order of the statements 

Using exceptions as control flow is considered an anit-pattern. On top of this, I would also say that a could be used in place of an 

Okay, so now we have more smaller classes that each are specialized, but how is this good? My main goal here, is to not need to alter code when I create a new implementation of You don't have an example of the class or the main Runner class, so for now a just has a method. You can of course do whatever you want in your class. Instead of an class, let's make a class. That's what this is after all, an RPG. 

Where possible avoid using classes as a way of storing global / static variables. The benefit of creating classes is to provide a method of abstraction. On top of this Player class your Game class is essentially just some static methods that you call from the main method. What if your code could look like this 

We constantly append to the same list. Being able to compare cards for equality would be useful, consider overriding the __eq__ and __hash__ methods. And if you want to be able to do card1 < card2, you can also override __lt__ and __gt__ Final Comments My final suggestion would be, try and make a card game using what you've written. See what problems you run into, what works, what doesn't work. Something straight forward like War. Hopefully you found this review helpful! 

see this question $URL$ have a look at the arguments for and against using getters and setters. I won't also recommend reading up on the benefits (and drawbacks) of writing immutable classes. Avoid using Strings to represent more complex Objects You're currently representing your inventory as an array of Strings. I would argue that an is far more than just a String. I would rather see an class. This could be a super class or interface that all items in your game could derive from / implement. Some class that come to mind could be, , , etc. If all of these things are represented as a single String, you're restricting what you can do. Additionally, I would not use an array for this situation. How about an class. 

Give one line per import. Your code lacks a main guard. If I was to import any functions or classes from your current code, your slot machine game would start! Generally you just want to wrap your code in a conditional check that looks like 

Hi there thanks for sharing your code, I have a few comments/suggestions. Implement the __str__ method In your code, you have a method specifically designed to print out what your card looks like. Using the method is a special method designed to return a string representation of our object. In your case it would look something like this. 

First off, I really like this Juke Box idea as an OO design project, and it's looking quite good. Write immutable classes when you can 

it isn't immediately clear what the significance is of adding 100 to the total. (you're saying why, not what) As a side note, instead of writing total = total + 100, you can simply write total += 100 As for docstrings (comments which describe a method/function) they are generally triple quoted strings 

If you're using to call methods like this, just call the methods instead. if you look at the documentation for the function, it already returns a list, you can just use There seem to be some unnecessary offsets throughout your code, why use and not just you can just take the user input value and subtract 1 from it in one place, in Python counting starts from 0 :) n is a very poor name for a variable, use something like or instead, anything to improve readability goes a long way. in your function, you call again inside, I don't think there's any real benefit to using recursion here, I think it would be simpler to understand a simple loop instead, and it would also be simpler to reason about and leave less room for error. 

Unusual Behaviour right now, if I pop() an empty stack, it will return 0. This would be extremely unusual behaviour for an empty data structure. It wouldn't really be empty anymore would it? 

instead of printing "Stack is Underflow", why not throw a new EmptyStackException(msg). That's what it's for after all. In your push method, you print a message if the stack is full. Again I would suggest throwing an appropriate exception here, or even better, you could resize the array to accommodate the new element. (This would be great practice for making an ArrayList implementation.) What's Missing? Your stack is missing an isEmpty() or empty() method, this should just return true/false for if the stack is empty or not. This is extremely simple to implement so you shouldn't have any problems with this! Your stack is missing a peek() method, this should show the next element, without removing it. Why Stop There? Some other methods you might like to add for practice could be, 

If you return the member variable songsInPlaylist directly, the caller can do whatever they want with that same instance of the list. (An alternative is to provide an unmodifiable version of the list. Note that if the objects inside the list are mutable, then you still have things to worry about.) Similarly, in your PlayList constructor 

now it's all well and good that we have 3 subclasses, but we're going to need to be able to compare them, we need to add a way for an Employee to give it's priority, so let's just use a getter. (we don't need a setter) 

Lots of good answers already but I just wanted to add to Josh Dawson's point about not exposing private data members. The only getter that you need to have is One thing to watch out for here, when I think "size" such as list.size(), I think current number of elements, not maximum capacity. Maybe a name such as getCapacity or getMaxSize might be more descriptive. Anybody using the stack shouldn't need to know or care about the variable, it is just an implementation detail. However also acts as a value which represents the number of elements that are in the stack. So I would maybe create a getter not called but maybe or something along those lines. (or if you decided to rename your current one) One pitfall here is that you start top at -1. If you started it at 0 and used top++ instead of ++top it would reliably give back the number of elements without the user needing to know that a value of -1 means "no elements", they would just be left with a 0 instead! Your current method can also break your stack. All it's doing is mutating the variable. It's not actually adjusting the size of the internal array and copying over existing elements (say like an ArrayList does) If you do want to provide a way of expanding the stack, you could implement something similar. The method is also extremely dangerous. Consider the following code