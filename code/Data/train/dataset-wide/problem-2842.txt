Your use of in the first implementation is just wrong. In fact, it won't even work if you run your code in strict mode. When not in strict mode, in the browser. So, you're just using which is not a particularly good way to do things. gets a meaningful value if you call a constructor with the operator or you use or or you call . Otherwise, it will just be the global object (in regular mode) or in strict mode. I'd suggest this simplification which uses a function closure to store the state of the sum and returns an internal function to allow the chaining. This is OO-like solution where creates a function object that stores the current sum in a private closure and on the returned function is a means of extracting the sum and is means of adding to it and chaining is supported: 

Remove all undeclared and thus implicitly global variables. Remove caching of jQuery selector object (don't see any need for it). Remove several intermediate variables that are only used once Add to event handler so it can use directly Change from to to code more closely to the promise standard. 

This creates the same underlying methods as your original code, but is obviously a bit cleaner syntax. Usage of the constructor and methods is identical. 

And, here's a version that makes the change to wait on any promises that are returned in the array of values per our discussion in comments. I also changed it so that if you don't pass a function to .spread(), it will reject: 

In , why don't you use to see if a handler is already in the array rather than do your own from scratch iteration? 

Or, if all your ajax items keep their useful ID like you have above, but have a common class name, you can do this: 

Is repeated each time. Since there can't be a case where is an object that has a property and where , then you can figure out once before all the comparisons whether there is a property or not and just use that knowledge. This also simplifies the comparisons. I'm also assuming that the variable in your code is just something you are temporarily using and not something you're really trying to set (it appears to be an accidental global and is not being used elsewhere so I've removed it). You can extract out some of the repeated code like this: 

Your particular example gets 10 times faster by just removing the jQuery and using a loop and instead of the jQuery versions. It's also worth stopping the iteration when you find an excluded value since you don't need to look any more once the flag is already set: 

There are times when you work on going for performance, but even then you don't lose sight of the priorities that come before it. 

There's a big problem here. can either return a promise or throw synchronously which is a bad design and very unfriendly for the caller. Instead, you want any synchronous errors to be returned as a rejected promise. The beginning of your code should be changed from this: 

Now, it seems as an additional improvement for this particular usage, you can move the clause to a place where you don't have to save the variable to the higher scope because all paths with a successfully open go through one promise chain (assuming no exception in the handler is thrown before is called: 

Use to set hours, mins, secs,ms to 0 Calculate the A-F hex value rather than a bunch of statements Returns a string from since that is always what is needed Put the multiplication multiples in an array that you can loop over rather than copying code Calculate the final string directly rather than using the intermediate object with first through sixth properties 

Here's the original answer before the actual HTML and actual rendering intent was disclosed It would be useful to both see the HTML and understand what you're really trying to do here. It may be much easier to add some appropriate classes and do things a simpler way, but we can't really tell without seeing the whole problem including the HTML and a description of what you're really trying to accomplish. From purely studying your code, it can be deduced to a pattern and that pattern can be generated with javascript rather than repeatedly typed out. Here's my first analysis of deducing the pattern to a couple loops of code. There's one loop to create each event handler and another loop inside each event handler to loop through each item and apply the desired change to each one: 

There's simply no reason to wrap your existing promise with another promise and no reason to use or here either: 

Update the appropriate variable with an appropriate increment. Set the appropriate value. Call . return the newly modified value. 

In most places you are retrieving , I think you really want . You don't want to be using over and over again because you keep making a new jQuery object over and over again. Evaluate it once into a local variable are refer to that from then on: . Then refer to whenever you want it. But don't get confused because not all values of are the same in your code so some places will need their own . Declare all local variables like so they are not implicit global variables. I think you need to convert quantity to a number in because you use it in numeric comparisons later which won't work properly unless you make it into a real number: Your ajax has me baffled. You're loading into the clicked button? Is that really what you want to do with this line ? That doesn't make a whole lot of sense to me. What are you trying to accomplish with your ajax call? You don't seem to ever be using . 

You can rearrange the if/else to be a little more efficient. You can retrieve the length a little more efficiently. And, use (pre jQuery 1.7) or (jQuery 1.7+) with a selector of a parent object close to the elements. That will perform much better than for large numbers of elements. It could look something like this: 

And here's a version that just calculates the desired letter-spacing with no iteration. This is 27x faster than your original version: 

EDIT: This is a new answer now that we see the HTML and understand what the OP is actually trying to do. There is a much, much simpler way to do this. Conceptually, instead of maintaining manually controlled relative positions of every div, we just make them all absolutely positioned on top of one another with only one div visible at a time. To show a new one, we the current one (which we maintain a reference to with an class and the new one. Since they are all on top of one another, it makes a smooth opacity transition from one to the other. Here's a working demo: $URL$ You can change ALL of your Javascript to this: 

would be more efficient because it wouldn't continue to evaluate comparisons that you already know won't match. It would also be more efficient to cache some values here so you aren't revaluating the same expression over and over. A switch statement could work fine. I would tend to use a switch or an object table lookup if you had lots of different tag names you were looking for. At just qty 3, I'd probably stick to the . Here's an implementation with and some expression caching: 

My general rule of thumb is to cache a selector lookup within a given function so you only look it up once for each function invocation, but to not cache it globally. If something was being called hundreds or thousands of times in a loop, you would want to cache it outside the loop just for common sense efficiency. Caching things globally is pretty much never needed for user event types of things because the performance of looking up a few objects in the DOM is super fast when compared to any sort of user action time. In other words, you wouldn't be able to tell the difference so you might as well go with the most maintainable and reliable code which avoids unnecessary globals. 

Note, there is no need to check because calling on something that is already visible just does nothing and is a slightly expensive operation because it has to check the visibility of every single parent object. 

There is no native way to do this so your general logic seems sound. Here's some improvements, you might consider: 

The idea here is that you make the items that you want to process self describing by giving them a common class and either an id or a data attribute that describes the query to use. When you add items to the HTML, you don't even have to modify the jQuery as long as the items you add to the HTML follow your recipe. 

If you move and into an object called rather than just top level variables, you could also use a map-driven approach like this: 

For speed reasons, this one assumes the letter-spacing is initially 0. If it won't reliably be zero, then you have to obtain the initial value and use that in the calculation or set it to zero initially. And here is a jsFiddle of this one to show that it works: $URL$