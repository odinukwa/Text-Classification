WAIT, we lost some precision. What happened ??? How did this happen ??? You need to accommodate more decmial digits (> 2) UPDATE 2011-07-25 17:37 EDT I substituted (7,2) with (10,7) in the stored procedure and got back the proper precision 

In all honesty, I cannot tell what the is. You should try comparing that graph above to the text-based output from one of these: 

You would eliminate (saving 8 bytes per row) and remove a needless index. Then, your INSERTs would look like this: 

This way, you double the storage for indexes but not for the table data. As a result, this should be a 25% savings on diskspace. The MySQL Query Optimizer will choose perform index range scans only, which is why the concept of covering indexes works well here. Here are some nice links on Covering Indexes: 

MyISAM will do all the heavy lifting of assigning the next for each I discussed this a few times before 

UPDATE 2011-05-20 11:17 It is possible all the DB Connections have timed out from PHP's vantage point. See if restarting MySQL and apache will do it. Also, make sure that the timeout values for MySQL, PHP, and Apache all match up Also, do this 

A quick way to determine how much memory MySQL thinks it could allocate is as follows: wget mysqltuner.pl perl mysqltuner.pl When you run this script, it will tell you what percentage of the installed RAM MySQL thinks it can safely allocate. If the answer given is over 100%, you definitely need to lower your buffer sizes. The main one to focus on are: sort_buffer_size read_buffer_size read_rnd_buffer_size join_buffer_size max_connections key_buffer_size (not really effective past 4G) @DTest already set the direction for you in his answer, so +1 for his anwser. The perl script will tell you what happens if you don't set it or if you change any value. Here is an example: A client of mine has read_buffer_size=128K read_rnd_buffer_size=256K sort_buffer_size=2M join_buffer_size=128K max_connections=1050 Here is the output from mysqltuner.pl: 

That will do what you want, but remote root is not recommended. SUGGESTION #3 Since already exists, then remove the root@localhost. 

It works as is. UPDATE 2015-01-16 14:46 EST Here are Queries to Report Sizes and Computes the Memory Units On-The-Fly Total MySQL Data and Index Usage By Storage Engine 

STEP 03) Failover Your Application In simple English, use the IP address of ServerDB2 in your application instead of ServerDB1 You should wait and make sure you have a low peak time to do this failover STEP 04) Setup DRBD on Separate ServerDB1 

The idea here is to make sure all binary logs and relay logs are time synchronized. The NOW() function could then be correctly interpreted from these logs. CAVEAT Be very careful about changing clock times when it may not be necessary when it comes to Daylight Saving Time. Since the clock time is written in binary logs in seconds since Jan 1, 1970, it may not be necessary. Since the clock is 75 minutes off, do this ASAP. Don't wait until DST kicks in. 

AFAICT you would only need to consider the size of the and files. Since SMALLINT is 2 bytes, and MEDIUMINT is 3 bytes, look for the files to increase byte 1 byte for each record. Thus, 1,000,000 rows in a 10MB MYD will now be about 11MB. MyISAM tables with a wider row may need some adjustments (increases) in things like 

I see you see your innodb_thread_concurrency is 20. That's not good. Why ??? Over the years, I have learned that infinite concurrency is best (See my old post MySQL using too much CPU). Usually, I would recommend setting this to 0. With recent improvements to InnoDB, I learned that 0 may not be the best value in some cases. A comparison of two values ( and ) was done the article Percona Server 5.7 performance improvements. The article states: 

I am sure you wanted the range to show up, so the query is designd to catch all ranges. Any missing range is essentially defaulted to zero. GIVE IT A TRY !!! CAVEAT: Unfortunately, the first subquery requires you to hardcode it. It will be the only hardcoding required to make it work. 

Use existing db1 as Master install mysql on db2 (Same version aon db1 and db2) make sure mysql is not running on db2 

What was wrong before? In your original trigger, you had . That was looking for the actually being equal to the string 'req_id'. That's why I made the other corrections, especially correction #2. Give it a Try !!! 

The output for diffcount of 1 shows how many are not represented To see the unused records, run this 

I recommend downloading MySQL Administrator (I know, it's old but I still you it for quick and dirty "I WANNA SEE STATS NOW" moments of day) and set it up. I customized my own graphs to watch the size of the InnoDB Buffer Pool and its dirty pages. You could also just use the Connection Health tab. 

Did you ever wonder why mysqld did not crash when doing ? Doing simply passes through the data folder looking for files. Running this query 

STEP 01) On the Old Server, STEP 02) On the Old Server, STEP 03) On the New Server, STEP 04) On the New Server, Make sure on the New Server is on a much bigger disk mount 

You should convert them to MyISAM. That way, you can index the tables by the timestamp and perform SELECT queries from them. By default, these files use the CSV storage engine. 

Although you may not get good results, if you still want to experiment with reading triggers and stored procedures immediately after startup: STEP 01) Create a script to read those tables 

If you want something that's quick-and-dirty, may you should consider doing this: STEP 01) Use mysqldump 

Based on your output, you are using XtraDB now. In case you need to revert back to the original InnoDB, see Using InnoDB Instead of XtraDB. It discusses flipping the plugins and restart MariaDB. As for XtraDB, you can read the Documentation. I can tell you one thing that I wish MySQL's InnoDB had: MORE INFORMATION_SCHEMA Check out the 5.5 and 5.6 INFORMATION_SCHEMA extensions for Percona and see how they compare to those in MariaDB. To see which parts of XtraDB can be tuned and monitored (which InnoDB cannot do), look at this Pictorial Representation of InnoDB (originated by Vadim Tkachenko). 

So, that the size of does not slow things down, try creating a temp table for the purpose of gathering these two columns 

Once you have the general log entries stored as a table rows, you can run SELECTS against the MyISAM at will, with queries like: 

This WHERE clause never mentions Column a. Result? automatic full table scan. As far as order of columns in a table goes, defragging tables and making table formats with fixed row lengths could reduce any possible issues with table column order is that is a suspected concern. If anyone knows of issues with Oracle, PostgreSQL, SQL Server, or other RDBMS's concerning table column order, please chime in. 

Please read the MySQL Documentation in full for , then ... GIVE IT A TRY !!! If it does not work on the first try, do this 

SCENARIO #1 You may want to monitor . It represents the some total of relay logs the Slave has to process. When should you worry about it? Give this scenario 

The source of the problem was removing the log files before flushing everything out of the logs You should run this to shut it down (using innodb_fast_shutdown) 

MySQL 5.0 Certification Study Guide Chapter 30 Section 30.5 Pages 444,445 Here are the options for myisam-recover 

Please do not get fooled by the error message. Note that the error is . It does not say . What would create a condition ? It has to do with the changes that are pouring into the rollback segments for a transaction. I have addressed this many times 

If your database is all-MyISAM (you start hearing Twilight Zone music) : Don't mysqldump. Shutdown mysql and maker a copy of /var/lib/mysql (LVM Snapshot, scp, rsync, etc). That way, there is no SQL controversy. You should probably dump data and table structure together, just to be sure.