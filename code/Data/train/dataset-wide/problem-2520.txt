I am implementing a multi-player game in C# and having seen all sorts of projects, from indie developers all the way to large studios struggle to patch networking into existing products in the past, have made the decision to get the networking aspect done first, and build the game on top of that. I've so far gotten to the stage where my server can accept clients asynchronously, but I have a strong feeling that I've implemented the threading very badly. I think it is possible that I am misunderstanding and/or misusing async/await and Tasks, but having read documentation and similar questions I think I will need practical experience to get my head wrapped around the correct usage of these. As a result, I am hoping that someone would be generous enough to look over my code and help push me onto the right track. I have excluded 'using' statements and the client code for the purposes of this question, however I can confirm the code does function correctly. I am not too concerned about issues such as naming, and the fact that I have a bit too much code logic in the Main function right now -- these will be modified and extracted to more appropriate locations respectively as the project progresses. I have denoted lines I am particularly concerned about with 

Overall approach Hiding and showing menus has been done a lot, and to be honest, you are applying a lot of javascript for something that can be done mostly with css. I'm not aware of your DOM, however you can move the toggle menu behavior (and even the animation) to your CSS and just have a simple click event handler that fires a toggleClass event. Example: 

Caching Variables and selectors Whenever selecting an element on the page, if you are going to select it multiple times, try to set the jQuery element as a variable first, and reuse the same variable. 

(Note I strongly recommend using over , you'll run into less problems in the future this way. Event Binding You should try to get into the habit of using instead of `$({selector}).click(function(){}). applies an event handler for every instance of , whereas the will apply a delegate event handler to , and listen for any within . The difference is making 1 event handler compared to making many. Right here, there shouldn't be too much of a difference. We are assuming that there is only 1 . But, as you can imagine, using can give huge performance benefits over directly. But, most importantly, by using , you are binding the click event to . Should you remove and re-add a new in its place, the click event will be lost. This is not the case with applying the to a parent element. 

However, as mentioned at the beginning of my question, I am concerned about using run-time dynamic typing in this fashion (See my dispatch code in Entity - the second snippet in this post). This system will probably be handling a lot of messages, and I have some concerns about the overhead incurred (it also feels like a code smell in general) I would really appreciate feedback on this approach; particularly whether it seems like an abuse of dynamic to more experienced C# developers than I, but would also appreciate alternative suggestions. Alternative approaches I've considered, and why I did not go with them initially: 

Exhaustive set of event properties which components can subscribe to manually - adds extra code overhead to each message type, which I'd like to avoid Dictionary from event Type to handler in each component - have to subscribe at run-time, which feels undesirable. Switching dynamically inside a non-overloaded handler - more viable than it sounds since most components will not listen to more than a few message types, but still has unpleasant code overhead 

Originally, I began writing code to loop through my list and my list and then realised I was going to be writing duplicate code for every list of data and switched to having a and looping that and ended up having to use reflection. I was wondering if anyone can think of a way of achieving my goals without using reflection or having duplicate code for every type of model stored. I'll attach my current completed class below. I don't mind doing so much but it's the code: 

Caching variables is more performant and can be much easier to read. You shouldn't have to find by id IDs are meant to only exist once on the page. By calling , you are effectively saying "Starting from my current element, lets search down the DOM tree until I find something that matches my {selector}" 

If it isn't, then your DOM should be corrected. == and Type Coercion As a general rule of thumb, you should always opt for over (and conversely opt for over ). basically means does a sort of equal b. It doesn't take into account the variable's type. passes as true (even though one is clearly a string, and the other clearly a number). means does a and b match the same type, and does the value equal each other. In this case, will return false (because of the difference in type.) I know this might sound small and nit-picky, but in reality it really isn't. Using will lead up to unexpected behavior that can be hard to spot. Additionally, is faster than . will stop trying to compare two variables if they do not have a matching type. Simplify Conditional I want to highlight the following conditional: 

There are multiple ways to make Dates in javascript. The format above will create a new Date based on "today"'s year, month, and date (think day of the month). Technically you could also do this with a DateString, however "new Date(dateString)" is implementation dependent, and may have inconsistent behavior across different browsers. And if making 2 Date objects makes you uncomfortable, you could always do the following: 

I'm not sure whether my distaste for reflection is justified or not, but it feels ucky that I'm using reflection here. I'm trying to make a very simple class which has a number of where with a load and save method. The load method should: 

I wanted to remove this very strong coupling which my components have (as a result of specifying exactly which component should receive the message), and transition towards an event / message system. As a result, I've written an implementation which seems ideal, however it uses run-time dynamic typing which has me concerned that there may be a better way to achieve my goals. 

Additionally, my usage of any features in more recent C# iterations (C# 6 most notably) may not be up to scratch, so I'd appreciate any suggestions for making my code more condensed or 'modern' I apologise if this question doesn't fit perfectly here -- I was concerned it was a bit too specific and if it is, please comment and I'll try to open it up a bit. 

That's really bothering me. It just feels wrong and suboptimal and I'm sure I'm not thinking this through properly. Full code below: 

I'm working on a game which utilises a variant of the entity component system pattern. In my current code, I have been communicating between components using code of the form: