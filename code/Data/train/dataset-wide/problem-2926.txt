Reading here is quite misleading as it sounds like you will loop when the processing inside the code block is correct. One suggestion is to invert the meaning so that it better reflects what is being done here: 

You can also consider using the direct boolean comparison and ternary operators to simplify the expressions here: 

Since you are already on Java 7, you can use on your for safe and efficient handling of the underlying I/O resource. Also, if all you are interested in is to read a file contents as a single , you can consider reading them into a , and then there appears to be three simple ways using either Guava, Apache Commons IO or Spark (web framework) libraries: 

Or you need to change your 's ordering, or the unit tests' expected values. Or perhaps I am just over-thinking this and should just treat the definition of 'high-to-low' as 'a higher rating is greater compared to a lower rating'. Second, @rolfl suggested just calling the 's method, but since you are asserting specifically for the values , and , you need a light implementation to make it suitable for your unit tests. 

vs returns a , but that array is only used in a simple -loop, which I think a will work equally well too. The reason for suggesting the latter is that you can rely on to do it in a single step for you, which eliminates the need to have your own little method. 

These nine variables can be replaced by a 'compact' 3x3 array. The main benefit of an array is that it makes looping much easier: 

You can compare by , e.g. . Casting of in your method is potentially unsafe and may/will throw s if you accidentally pass in the wrong object type. 

You have very large code blocks that I can't help but wonder if it will be better to extract them as methods. For , maybe you can consider setting the to when there is no more to be read from it: 

It's easier to literally express this as "length of sequence is myself and what follows behind", instead of relying on a helper method... Unit tests Please create more unit tests to test the expected behavior for unexpected s, e.g. , negative values, far greater than , etc. Performance 

Conclusion It's always good to conceptualize what are the steps in your chunk(s) of code, and then wrap them into their own methods. This helps to facilitate an appreciation of your own code, which could uncover inefficiencies (e.g. doing something twice) or potential bugs (checking for a property in one place but not the other). More importantly, it lets you easily perform unit testing on smaller slices of your code, so that you can safely modify these smaller chunks in the future to be more efficient with the assurance that you wouldn't be introducing bugs. 

While you're at it, why not simply replace the classes with a 'modern' logging framework like SLF4J? The methods it offers handles the concatenation elegantly when logging is not required, so you don't even need the guard clause in the first place. Finally, your method can be simplified as such: 

Since Java 7, you should use on your for safe and efficient handling of the underlying I/O resource: 

In this case, your type is no longer used as a 'flag', instead given an arguably better usage for performing the calculation. 

Computation logic aside, this seems like a long-winded way of solving, saving and returning the created . For starters, calling multiple times will override the class variable every time, is this the desired approach? If one instance can generate multiple s, then perhaps it will be better for to made as a in-method variable, and have it passed around. However, if there should only be one per instance, then you need to check that you are not re-creating a every time is called. The following two steps, and seem to depend on the assumption that must be referenced already. Again, you may want to consider whether you want to make a method argument for them. It might be clearer from the method signatures, but if you more comfortable with ensuring is properly instantiated as a class variable, then that works too. It is also not clear-cut to grasp what exactly is going on in these few lines. If I were to read them literally (bearing in mind this is skipping the randomizing + generating blank cells, which sounds odd too): 

This is not a very optimal way of checking if a user from the file is in your object. For starters, will generate the representation every time, and you may run into false positives. For example, if the representation of a contains a comma, which is the delimiter used by : 

Instead of -ing, you should be using the constructor to create new instances backed by the same elements as the original. This is safe for adding or removing elements on the newly created instances. Interfaces over implementations Interface types such as is recommended over the implementing types, i.e. , because the users of the variable should only need to use the methods provided by the API without having to understand the underlying implementation. This is also known as loose coupling. Additionally, since Java 7, you can use generic type inference to save you some keystrokes: 

I'm guess there's an implied range of inputs such as all must be positive right? Because your calculation will yield the same hash codes when equals to , and having a bunch of negative and positive integers (or just ) will 'break' this easily. You may want to update your question with any assumptions on the range of inputs. How to reverse a I think that you can move your method into the class itself as such: 

Some simple suggestions here... For Java 7, you can already use type inference aka diamond operator to simplify the following such assignments: 

Since you also suggest giving ideas about Java 8, you can use as a slightly better replacement - there is no need to handle the appending of manually: 

SQL statement construction Your third-party library do support bindings, so instead of , you should consider: 

Getting a full board involves setting the board to the solver, and then solving the cells (as another method call). Then, save the solution by setting the solution per board cell. Finally, save the board by saving each cell. 

Code formatting styles Your class's code formatting is the conventional kind, which a seasoned Java developer should be able to understand easily, and that is weirdly different from your and classes. You should either make the class 'look' more like the rest for consistency, or make the code formatting of the other two more conventional. 

The rest have offered a good number of improvements already, so I'll just focus on the use of an array of s in . is recommended over if you do not need synchronization, as it is the case here. Usually, one creates a from a using its method, instead of . Also, if you really need to use , then you should either append single characters (such as ) or your individual s, instead of concatenating them first, to properly 'optimize' their usage: