That's just one way to group the code. Another way might work better for you. You could also group your functions with similar functions, to make them easier to find. As one example, and could be next to each other, and could be toward the bottom. While grouping your functions, you can check to make sure no functions are called before they are declared -- it won't make the code run better, but it will increase readability. 

Also, if you ever modify your code to where you need to access the cloned elements by ID, keep in mind that your cloned elements will start with . You're using the length to generate the number, so when you add the first element the length will be 2. 

Your code looks good, and very clean. Best practices are usually subjective; there's no absolute best way to clone and insert an element. That being said, I would make two suggestions: 1. Be consistent with your HTML Your div doesn't have quotes around its ID, whereas your div does. I'd recommend always surrounding IDs in quotes as a standard practice. 2. Swap the and order This suggestion is purely subjective, but semantically, I think it makes more sense to add the cloned element to the DOM first, then change its display property, rather than change its display property first (which won't have any affect yet anyway) and then add it to the DOM. Again, that's just my opinion. Other notes If you're interested in adding autofocus to your elements (so that as a new element is added, it automatically gets focus) you could do that fairly easily by inserting this line just before you close your function: 

The use of global objects is generally discouraged, but migh be okay given your current experience. Another (slightly) better option is to instantiate the database once and pass it to the method that needs the database. The imho best option is to use dependency injection. However, this is pretty advanced stuff and something you want to look into in the future. Advice #7: Use dependency injection if possible. Globals might be okay for now, but lead to trouble in the future. You say, that you have posts and comments. However, in your code you only deal with assoc arrays. Why don't you create classes for Post and Comment? This is the perfect place to use a class. Advice #8: Use classes for entites (Post/Comment) and not assoc arrays. If you use classes for Post/Comment, you might wonder how to write them to json. PHPs jsonSerialize will help you there. However, you probably have to convert json -> Post/Comment yourself. Advice #9: Use jsonSerialize or something similar to serialize objects to json. 

Source Code Structure As already mentioned, only define one class per file. I like it, that you encapsulate the fields of your classes. However, you have many static functions, which basically degrades your classes to some kind of namespaces. There is nothing wrong with static functions, but be careful not to overuse them. Advice #6: Don't overuse static functions (and statics in general) As you mentioned, and is suboptimal. You have pretty much three options: 

On my machine, this overhead is ~1.20s. The original solution for input with 9000 entries and 3 lookups takes ~6.25s, while the solution I've posted here runs in ~1.23s, which means it imposes hardly any overhead over that of the VM startup and shutdown. 

The code below first reads all the input in chunks of 4096 characters, accumulating a list of chunks. It then reverses the list, flattens the list into a large string, and splits the entire string on newlines. After that, it converts the first element of the resulting list to an integer , and then processes names and numbers from the remainder of the list by storing them in a map. The value stored isn't just the phone number, but the required output string . Once all the entries have been processed, the rest of the input is queries, which are then processed one-by-one against the map. Query processing uses with the string used as the default for lookups that fail. This allows the return value from to be unconditionally output directly to stdout. 

The final clause is where all the interesting work occurs. It first calls with a default value of to check if the value tuple is present. If it's not, the default value of is returned, and the case clause for creates a new list of value tuples based on the incoming values of , , , and and passes it to a new call, setting the initial sum value to 0 and passing the current cache. This call returns a 2-tuple comprising the sum for that value tuple and a new cache. The final line in this case clause inserts the sum for the value tuple into the cache. The case clause for when finds the value tuple just returns the cached sum and the current cache. The result of the case expression is stored into , and then is called recursively with , which is the tail of the value tuple list, a new sum which is , and the new cache . We can run the code in a list comprehension to calculate the running times for values from 1 to 12 using like this: 

Update Added 8. - 11. If you are feeling confident or want to try static code analysis, you might want to look into something like $URL$ or $URL$ . They can warn you about global variables, unused variables and more. ad 4) As Schism mentioned, this advices may lead to unwanted global variables if you mix up and . So for example: 

The four if statements inside and seem to be the same, so you could move them to a seperate function. However, you currently have set to a fixed value and you don't change it. So as it is, the if statements are unnecessary. Some variable names are rather cryptic: , , etc. There are unused variables: e.g. The browser identification and the "calculation" of seem to be good candidates for a seperate function. 

First of all, it's good that you try to implement something like a blog/forum on your own. It will teach you a lot of good/bad practices. In one comment you said, that you are trying to understand how these frameworks could be impemented, so it would be very good, if you take a look at them. Check out their APIs and see what they did. Im used to Symfony ($URL$ so my advice will mostly use their architecture as an example. However, be sure to remember that there are many ways to success and the things I describe are my current point of view. Your major problems (maybe not now, but in a few days/weeks/months) are the structure of your project, the structure of your source code and the mixing of php/html. 

We execute the function twice for each value and time only the second call â€” this is a non-rigorous attempt to prime caches and such to get a more accurate measurement. Some results for your original code are: 

First, we can see that the third numbers, the function results, are identical to those for the original code. This means that either the new code is also correct, or both versions are incorrect. As you can see the execution times are greatly reduced from the original code for all values of greater than 4. For the smaller values, the original code is faster because it doesn't have any caching overhead. But for the larger values, each increment in results in only a small increase in execution time. For of 12, the run time is only 2.68ms, which is roughly 28000 times faster than the original code. With the revised code, calculating takes only 2.8 seconds: 

I created an input file containing 9000 entries to be stored and used it to measure this solution to be about 150 times faster than solutions that read the input line by line, as measured by running the solution on the command line in a bash shell like this: 

Caching is definitely appropriate here as well. You can carry a cache through the calculations using an Erlang map. I took your original code and made the following modifications: