Can't help but think that a trick with integer division and clever Card enum setup would help a lot: 

Incorporating exceptions to handle expected situations is never a good idea. Creating an exception instance in Java is significantly slower than the condition that would prevent the exception. Exceptions should be exceptions. Additionally, as maaartinus says, you should not ned to declare the outside the try block. Even if you accept the exception as valid, your code would be simpler as: 

This removes much of the code duplication. Note also that convention puts the at the end of the line in JavaScript, not at the start of the next line. Also, you should add space between your operators and expressions to make them more readable. Finally, you don't need to add the as it is not useful in the condition since the function returns a boolean already. A concern I have is that you have two arrays, and . You index them both with the same index, and there is no apparent control that ensures they are 'in sync'. Are they a 1-to-1 matching pair of arrays? 

So, the point of my answer is to say you chose the less-appropriate code structure. Nodes should be containers (and private, and light-weight). The Trie itself contains the state data, and is what does the heavy lifting. This is the opposite of what you have. I have left the data structures similar to what you have. If I were doing this myself, I would probably be using a large data set, and I would find a way to get rid of the Map, and replace it with a more space-saving primitive array structure of some sort. 

and then feed those states on to a Concurrent*Queue on the notify side. Then, have a seperate thread that reads from that queue (guaranteeing the order) and feeds the events to the listeners. This also removes potentially long-running method calls from the service that provides you the notification events.... (i.e. this may make the OS more responsive to other applications) 

There is only one example of it in your code, but I really dislike multiple conditions on a single line: 

In your first elements you have space surrounding the text. In your later there is no space. Is the space important? If it is, you should either use attributes, or set on your XML. Update FYI, I ran your XML through xmllint and it output your XML as: 

There are a number of concerns I have here, some of them style related, but mostly about the actual functionality.... mounts and may not necessarily be actual mount points. You should first check to see whether it is a mount point before testing it. This is because it may inaccurately reflect the space if it is not actually a mount. Additionally, it is (remotely) possible that, even if it is normally a mount point, that the partition may be unmounted too, but that's a remote problem. The program is a useful one for identifying whether a folder is in fact a mountpoint. It returns a useful exit code (0 if it is). 

You use the array slice , which had me confused for a long time. TO me this was just counting the times and on, and not counting the time at all. I never saw tha tyou were splitting on instead of just whitespace, so. Making your code depend on the amount of whitespace is a problem, and will become a bug at some future time, and, it appears, is a problem right now. You should split on whitespace, and count fields, instead of counting spaces.... Now, the last two columns are 'guest' time, and these values are double-counted in the user times. Your current code double-counts that time, and will lead to errors in your computations. Your array slice should be splitting on whitespace, and should only be summing: /proc/{pid}/stat Your calculation here is right, but I would do the split just once, and read the two fields in one slice. 

set up your selector and the thread that manages it. set up a limited thread pool (about as many threads as you have CPU's/Cores) plan your protocol for communication set up a state machine for each client 

This should simplify the code a whole lot. If you need the two methods and to be public, I would make them simply: 

This indicates a larger problem though, that a fair amount of code is repeated (calculating neighbours, etc.). My suggestion is that you should have an initial pass of the field after creating each cell. This inialization pass should get each cell to compute, and store their neighbour list, as well as compute whether the cell is a sink. Putting it in the constructor of the Rainfall class seems like the right idea, but, since the initalization can also record the sinks, it seems quite a lot for a constructor. I am on the fence. The up-side is that it will make the execution faster.... Consider the RainFall constructor: 

Additionally, there is no reason, if you are in a method that builds these things, that you can't return immediately with the right answer. Often if you are doing things like the above, it indicates that what you are doing should be in a sub-method, with an early-return when you have a successful setup, and a default return value when things fail. 

Recursion is something that is often "unwrapped" to become loops, but the same is true, in the other direction. Almost all loops can be implemented as recursion. Using your "trick" of throwing an exception to act as a conditional, it would be simple to turn all your code... this code: 

You do not report the actual Error - is not actually reported somewhere. What if the error was "UUID is invalid: Illegal character 'G' at position 25". That's a useful error message, but instead, the user just gets the error "Invalid Token". In your other error-handling block, you do a better job og logging the actual value, but those values are still not reported to the "client", they are just logged on the server. You don't alter the behaviour of the program.... you "report" the problem, but you don't return, or abort the file processing. This is a big deal. For example, when you have you report a broken , but you keep processing things, which means your may be , and your following code will panic. Duplication! That same error logic is repeated many times. You should refactor the code and reduce the duplication: 

Discussing performance of methods which are almost entirely in the main method, is sort of pointless. Java performance requires hot-spot compiling, and that does not really happen until methods are run many, many times. The main method is run just once, so is seldom compiled efficiently. Perhaps it's only ever interpreted. In terms of efficiency, the algorithm you are using is documented as being the best for this puzzle. Essentially there is no better way. Your subsequent question about how to incorporate additional multiples is complicated.... the way the algorithm works right now, is to calculate the sum of multiple sequences. One sequence is: 

There are a few things I would point out as being poor go style. The two different nesting loops is where I would start: 

So, what does that do? It takes a reading from the stat files, then it runs top, which taks a second, then it re-reads the stat files, and prints the results for that second to match against TOP. Finally it waits a second, then loops. On the next loop, it has already waited a second, then another second for the top, so the subsequent loops report the top times for only the second second of a 2-second wait time. Your comparison numbers will never match accurately. Additionally, when you remove the top comparison, your loop will be: 

You seem to be using Apache's log4j API. What you should consider is how other API's have solved this problem. For example, java.util.Logging has the following two methods: 

This makes the computation for any 1 node an \$O(\log{h})\$ operation... and, if there are nodes to locate, the overall result would be an \$O(q \log{h})\$ one. The "final" solution would be: 

is essentially remove the item at position 0, which, for an array list, means every other item needs to be shuffled forward one spot. To remove the first item, you have also moved every other item. Again, when you find the next multiples of the prime, you are shifting each larger value by 1 position as well. This could result in a lot of shuffling..... a huge amount, in fact. What's worse, though, is as you go through the multiples of the prime (for example, 7), you say: 

This is a nice project to learn concurrency on, and you've already identified a few issues that concern you, and you're right in some ways. Go documentation recommends using channels when possible, over mutexes. The documentation in the package says: "Other than the Once and WaitGroup types, most are intended for use by low-level library routines. Higher-level synchronization is better done via channels and communication." Channels are your friend in Go, and you should use them liberally (well, more liberally than mutexes). There are some special cases with channels, though, and your code has a good example of how they can be used in a broken way. Your concurrency is not nearly as significant as you think it is. I will focus on this code for the moment, and we'll simplify it down, and then get back to the concurrency problem in a bit... Client handler This code.... 

First up, yes, you're right that the second null check is redundant. If is null then the method will return on the first check: 

On the whole, your code is neat, the style is good, generics look OK. I have a concern with two major 'design' points though. The first is the class. This encapsulates the basic functionality of a node in the binary tree, and it makes it seem that there would be a way to customize the implementation. Unfortunately, you can't. Your BinaryTree class creates a concrete implementation as a static-internal: 

Those are your constants, and should be declared as . The things which are variables, are the cadence, and the 'gear size'. A general purpose program would have a method that takes those two variables, and returns a speed....: 

Your question is not very clear... but, the way I understand it is: Collect all the unique values in , and count how many of those unique values appear in . Interesting problem.... instead of a straight join with all the conditions, which may lead to an internal cross-product (thousands of joins and results to run comparisons on), I would state the logic as a couple of subselects ... which represent the two sets of data... the unique values in t1, and the unique values in t2. Note, the 'union' operator does a distinct as part of the union.... 

Apart from that, I like the recursion, and so on. You have avoided one common bug with precedence by specifying as being higher than . I am not sure if that's fair though... most languages treat them the same. 

This needs to be said multiple times, so I am saying it again. TODO All those TODO items.... do they still need to be done? When I see TODO's in the code I 'worry'. Either it means the code is not done yet, or it means you do not pay attention to details. The fact that you have TODO in your code probably means you use eclipse (or Netbeans, IntelliJ, whatever...), and those TODO's will all create flags in the margins of your program. Don't those flags irritate you? Multithreaded programming is 90% discipline. You have to follow the rules, and you have to be concerned about the details. All those TODOs are details you should not be missing. Visibility Your and your are not private, and they are not final. They should be. Right now, some other class in your package can access them, lock on them, trigger conditions, even replace them, and it will royally f*** up your program. should be private too. The whole class should also probably be final. Volatile Your is volatile. I think you think this is needed to keep the value consistent on all threads. In this case, volatile is redundant. The lock is what keeps the memory model consistent, and it is why you are using locks. The volatile just makes additional overhead for Java to work around. Remove the volatile. Locking, unlocking, synchronization, and accessing a volatile member all create what is called a 'happens before' event in the Java memory model. Everything in the JVM that 'happened before' the event is guaranteed to be visible to your code. So, if you also lock your access to the then any thread that ran before your lock 'happened before', and any thread that tries to run during your lock has to wait for you to complete, and when that thread acquires the lock, your thread 'happened before' that thread, so your memory model is copied to that thread's model. In general, if you are using volatile, and you don't understand what I said above, then you are likely doing something wrong. Signals ratchetfreak has already pointed out the unnecessary signalAll's in the acquire methods. I am going to extend his comments in three ways: