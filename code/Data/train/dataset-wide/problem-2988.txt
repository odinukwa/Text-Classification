This figures out the letter-index (0..25), adjusts it for shift, wraps it around, and then puts it back in the ASCII lowercase range. Note: this is probably what you want, because "Caesar". But if you want wrapping from upper to lower case, that's a different expression. 

First, have a look at "line 10" - the block of code that starts with a "10" in the left-most column. That code corresponds to this python: 

I don't know what is. I'm guessing it's 26, but that's a guess. Also, what if is, say, 100? You haven't imposed any range on it, other than the conversion to . Let's replace the conditional stuff with an expression: 

Note that I am treating the table as a collection, specifically, like a , and presuming you write method names that are inspired by existing Python collection names. Now, with that out of the way, let me propose that you should be lazy in how you handle creating and deleting database connections. Specifically, make the caller do it! Making the caller pass you in a connection is the best way to write code that you want to test, as well as the best way to write code that is maximally portable. If the caller mocks a database, you don't know and don't care. If the caller connects you to Oracle instead of , you don't know and don't care (provided your SQL syntax is valid). 

You are maintaining as a queue rather than as an unordered collection. All new animals go on the end of the list, and food is assigned from beginning to end. This means that you are disproportionately killing babies. While this might be correct, in a simulation sense, it does not appear to be explicit - that is, I don't see anything that indicates you intended to kill babies first. So I'd suggest that you either (1) make your intentions explicit, or (2) randomize the allocation of food. 

See the difference? N is N. There are operations that can be 0 or 1. Guess which is the operation? And there are parameters A and B, clearly marked. I haven't changed how it functions, but someone reading the code can now refer to the instructions and see what's what. Adding Faster Next, let's look at your two operations. Here's your first one, counting the 1 values: 

Note: may be the wrong name, since there is that implicit rule about not modifying the outer edges. Maybe "CanBeRoom()"? Position If you define an indexer for your Dungeon, you can use the directly instead of reaching in for the and values. This will cost some performance, but that likely doesn't matter during generation. Alternatively, you might just write a method. Dungeon Rules I saw one "implicit" rule in your code: the dungeon's outside walls are inviolable. I'd suggest that you make those rules explicit, and encode the operations you are currently implementing with just a paragraph or two of code: 

There's a lot to change in this code. So much so, that I'll just start with a few items. First, you read in something from "deck.txt" but it's not clear what. I'd suggest that you eliminate this entirely. Just hard-code the values in your program - a deck of cards isn't likely to change very much in the next year or two. Also, you don't validate the deck you read in. You just assume it has the right size and contents. That's super bogus, since users love to mess with configuration files. If you're going to read in the deck, you'll need to add some validation code. Next, the card valuation (): this is nuts. Look up the method and build a parallel list of values. Or do the math: , then . Finally, I'll suggest that you break up the huge block of code at the bottom of the file into some sensible functions. A main game function, some "turn" functions, etc. See if you can chop off a bunch of lines, update your question, and we'll try again. 

You don't show your import of . But I'd prefer that you not import by name, and rather spell it out inside your function. You're only calling it once, so it's more efficient to the reader for you to simply say: 

Just be careful about what size characters you use (16 bit only). If you have to use a full-out string, consider the solution in this answer. I suggest this because your output code would benefit from having "concrete" values. (The rest of your code is happy with the CellType being an abstract enum.) 

Now you have tuples where you can ignore the [0] element, and the [1] element is the index value. You can either make a pass to replace the indexes with values, and then merge the static and dynamic lists, or you could do it all in one pass. I suspect that the sizes of the inputs will determine which is the right solution: for very large inputs, especially with smallish s, using bulk operators (array slices) is worth getting right - that is, figuring out how to do . On the other hand, for short lists, the single while loop that merges like you have now may be faster, or at least fast enough. 

The second part of this code looks like it should be another function in your module. Get Top Albums from that returned artists In this section, you are making the same error you made in the artists section. You don't need a dictionary keyed by an arbitrary ID. Just create and append to a list. Get Tracks from albums Likewise here. There's a some added code for your audioscrobbler module, and a list where you're using a dictionary. 

You know it's a generator because you see . Twice! Generators don't return a value when you "call" them. Instead, they return a object. It's like an iterator - it's an object that you can call on and it might return multiple values: 

... but then you tried to use . Use or instead. (Like you did on the first line!) Use Python's expression to connect a nested generator to your caller. This code: 

You perform a computation to determine if the current player is 'X' or 'O'. But you then divide your code into two sections, basically identical except for using literal 'x' or 'o' characters. Why not do the computation, store the 'x' or 'o' into a variable, and shrink your code by 50%? There are a LOT of statements that are really just laziness on your part. (Or a strange desire to use statements.) You can eliminate the whole and things by simply moving that code up to the one place where it gets used: 

J_H provides some good feedback. In addition, I would suggest that you combine your SQL statements into a single statement, to reduce traffic back-and-forth to the database. Your code is really asking "do these entries exist in the tables?" So ask that! Use a nested select to ask your two different questions, and just do a on them. If they're 1 and 1-or-more, you're good to proceed: 

Similarly, you have a "blocking" list, where some substrings must not be in the website field. This is a similar function to the last, except you want to yield the row when the condition fails: 

In this case, the NPC was a and one of the messages displayed would indicate that training was an option. If the player elected to be trained, the option might have the result that nothing happened and a message was sent to the player indicating she didn't have enough gold. Or the result might be that the player's gold balance was decreased and the player's Skill was increased. It's worth noting that in many cases, training is only an option once. If the trainer has already trained the player, the option is no longer available. Or, possibly the cost changes based on the skill level, or based on the number of trainings already given. I think if you approach the problem less from the view of "let me model exactly this set of methods" and more from the view of "let me model the actual mechanics of the system" you will discover a different, possibly larger, set of classes and methods/events/messages. 

This comment should not be a comment. If you're going to explain the purpose of the function, use a docstring. And another one: Consider this: 

You are not taking into consideration what would happen if the end of the string occurs. C strings are NUL-terminated, meaning they end when a "zero" byte is encountered. You want to do something like this: 

Notice that the purpose of an function is that it be an initializer. That is, you use it to set starting values. Either those values are valid, in which case things just work, or you have made a mistake. I "outsourced" the parsing of position data to the class. That way, a board can implement whatever mechanics it likes for positioning. Similarly, I apply the axiom "tell, don't ask" to get the piece placed on the board. This avoids coupling the and the class via knowledge of internal representation or data storage. Finally, since is the base class in this system, I set to unilaterally. I'm not actually sure what you mean by this - did you mean "this kind of piece is able to castle under certain circumstances" or did you mean "this particular piece can castle right now if requested?" Regardless, the answer is no at the base level. With the base class defined, you should use subclasses to define custom behaviors that are different. For example, the possible moves of different pieces, or the boolean. 

Bonus: If you make your TreeNode class iterable, as mentioned in #1, and you use as mentioned in #3, you can make your code even smaller! Since the nodes are iterable, and since will accept an iterable, you can yield from the nodes directly, like this: 

Note that if your collisions are symmetric, you might want to delegate one more time to a single class. That is, square-with-circle might just return so as to only have to maintain the cross-shape collision code in a single class. Note also that you can use overload forms and casts to get the same result, defining and , then calling instead of . But it's actually easier just to type out the name than to type out the cast (which I'm fairly certain was a factor in the names chosen for casting operations)... 

This shows me there is some confusion on your part. You are allowed to assume that a logical or () fails because it's false - there's no need to repeat the test in a false mode: 

Use parameter names that make sense According to wikipedia, the Greek letter mu (μ) is frequently used for viscosity. So perhaps it makes sense to use either or as your parameter name. (Perhaps not: it's not self-explanatory unless your source-code readers will understand it.) Explicit is better than implicit You are doing a bad job of testing your inputs. In fact, there's two bugs: 

Finally, why does your object have an ? It seems unused. I'd suggest just using as your object type. 

First, let me say, "Good job." This code is okay for someone in the middle of learning. With that out of the way, now I'll rip it to shreds. ;-> Let's ignore your main program, which has its own set of problems, in favor of focusing on the class hierarchy as you requested. Use the basic features of OOP The first thing I notice, is that you're not really "doing" the classes right. For example, consider the : 

Of course, isn't a constant lookup - you have to iterate over the neighbors internally to check which ones are empty. But you can make sure to do it in the most efficient order. Now check this out: When you have your code mostly written, and you want to squeeze out some more performance, start at the innermost loop and start caching any value that has a dot () in it, by storing that value into a variable with the dot replaced by an underscore outside the loop if possible. Like this: