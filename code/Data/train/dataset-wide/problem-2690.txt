Throughout your code you deal with plenty of ArrayLists, however you should Program to an Interface. When you declare a variable as an ArrayList, all of the calling code will be locked into using this Implementation. I would declare your variables like this; 

I would save this as a local variable and use it in both conditions instead I would maybe consider moving the ASCII art to a file, and read in your list of art from there. It takes up a lot of space in your program. And do you even need to use the Counter class in your program? The Counter class is intended for when you want to know the number of occurrences. If all you are doing is comparing a list of 3 values, your roll_dice could return a sorted list and you could compare them directly. 

One area you could improve performance is by making it a doubly linked list. At the moment your deleteLast() method is an O(n) operation, meaning it needs to traverse the entire list to delete the last element. And since this is the case, there's no real reason for keeping a reference to it at all. If each Node had a next and a prev Node, your delete last could look something like, 

If I had the functionality to take any card object and place it to the deck, suddenly we don't need to worry about what the last card was to be taken or the last card that was put back (if we want these values we can of course still hold onto them) General tips and things to watch out for Consider this line and now look at this documentation about the random.shuffle method here $URL$ your code isn't doing what you think it's doing here. (hint, in-place) In your list of values, you have a mix of data types, integers and strings. I would stick to just one data type per collection. Since you want to use strings to represent "Jack", "Queen" etc. I would stick with Strings for everything "1", "2", "3" etc. And parse the integer value from it where needed. Using PEP8 standards, any method without a leading underscore can be considered "public" and I should be able to use freely and not need to worry about unexpected results. What happens if I do the following. 

This class has the sole responsibility of starting your game. I would avoid using Strings to represent something more complex than a String. The "A", is not a , it's a . A can and should use internally where needed to achieve the desired functionality. Your BattleShip is kind of a God object it currently stands. It knows about and is in charge of too many things. It keeps track of Ships/Players/Missles/Grids etc. I would say that the object should tie all of these things together, but each of these responsibilities should belong in its own class. @RobAu showed some good examples in his answer. One of the main benefits of using custom Objects instead of just Strings/Lists/Arrays for everything, is that it makes the code highly readable if done well. At the top, we have 

It's quite a mouth full, is a good method name, it explains exactly what it does, I don't need to go read the code to understand it. is not a great name, I have no idea what that is. Same goes for , these tell me nothing about what they are, at first glance they're just numbers being plugged into a method to convert them to letters. So some investigation needs to be done to understand what's going on here. I look through to see some more uses to get an idea what's going on 

If we wanted to make a new Location, which I think is a very reasonable thing to do. We would need to go and change the code in the class itself. Ideally, if we wanted to make a brand new location, say a . All we should need to do is make a class, and slot it in. Let's have a look at how we could do that. Firstly, we could make the class, an instead 

thanks for sharing your code I know that this isn't a huge amount of code, but I'm going to look at it assuming that we will want to be able to add additional features and expand upon the code that's already here. Redundant Comments comments should say why you're doing something, not what you're doing. This line 

I think single letter variable names (excluding and loop counters) should be avoided at all costs. You currently have all the fruits values hard coded in, it might be worth while to extract that data into a file to make it easier to add/remove new ones. That's probably not a huge deal though and may have no real benefit. I'm not sure if there's any cleaner way to achieve the s without scattering the calls throughout the code. You could maybe use named constants for the duration, but there may not be much value in that either. You have no docstrings in your code. The statements act as a form of documentation however, and your variable names are (mostly) very good. But there may be some room for some useful comments. Hopefully this review was useful for you! 

You almost never want to make your instance variables public. You should use a getter if you actually need to see that variable outside the class (which would happen less often than you would think) Your location class contains information that specifies what type of location it is! 

Code like this could end up corrupting the state of your object. In general I would try to avoid passing references to any objects that are implementation details, and if you have to, clone or copy them as said in the other answers. If you're looking for ways to add new features, you could consider implementing the Iterable interface, so you could iterate through with a for each loop. You could also override the equals and toString methods. 

It doesn't look like a big a difference, after all it's still a single line of code, but let's image you introduce a new mechanic in the game. A that prevents death for 3 turns even if you're below 0hp. That seems like something that might be in an RPG. If you want to do this now, you'll need to go through every occurrence of checking for this > 0 and add an additional condition, this would be very inconvenient and also again, very error prone. with an method, we could do it like this 

thanks for sharing your code! I wanted to talk about one pattern that repeats itself quite a bit in your code and how you could improve it. The long if/elif cases where you check for a name, and then based on the name, you call a method on the relevant object. 

Thanks for sharing your code, Full disclaimer: I know nothing about NBA, so I'll just be talking about the code itself :) Avoid returning references to mutable objects, here you return the underlying ArrayList objects, this means that the caller can edit these lists and it will (most likely unintentionally) mutate your NbaDraft object. Consider this example 

Hi thanks for sharing your code! My answer isn't going to touch on the algorithm itself, but I wanted to talk about a way that you could make your insertion sorter more flexible. At the moment, your sorting only handles integers, if you were to use generics that implement Comparable your insertion sort anything that implements that interface. Consider the following classes ( your algorithm remains unchanged) Sorter interface