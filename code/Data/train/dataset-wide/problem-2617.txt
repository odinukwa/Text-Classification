Globals; I would prefer using ids on the input fields (or even better, a jQuery selector) to retrieve them rather than going through . Like: 

Each inside of is sortable, and each inside of is also sortable (independently of the other sections). Each element within these sections is numbered according to its position in its own list. So to continue with the example above, the correct numbering is: 

Note that this allows you to easily pass the field itself to , instead of just an arbitrary key. Functions; I'd recommend the following style when writing functions: 

I have a list of elements (well, nested lists of elements, really) that the user can reorder (using jQuery ). A simplified view of the structure is something like: 

I don't see anything in your code that should cause any performance issues. You're not doing anything iterative, or performing any complex operations; your code just executes linearly and changes some CSS properties. That shouldn't kill performance. Have you seen anything to indicate that this code does kill performance? If so then the only thing I could suggest is changing the events that you listen for (or maybe, adding some logic to ensure that you don't start a new transition while the current one is still running), as perhaps the page is triggering more and events than you expect. Premature optimization is the root of all evil, and all that. Also, you should be able to do: 

A more potent approach is to return not the length at which to split, but the results of the split. In fact, makes this work out of the box: 

Shouldn't the current world automatically be satisfiable if the created one is? Or is this one of the things nonstandard s might change? and look like they ought to be removed and inlined respectively, but I'm not sure how to keep lines where you use from duplicating. 

There's also and , but if you simplified your question and above doesn't unsimplify, post the whole code and there might be an unreasonably short answer again. I also have the feeling wherever you use could be simplified further since only really returns a boolean. 

If you used , would be Using , is , except that the list is the right way round. Replacing with allows you to remove the last line, and thus the recursion, in loop's definition. Prepending to allows you to remove the . skips getting system time. 's allows you to require ability to generate random numbers in exactly the upwards call hierarchy of if you use mtl-style type signatures. You won't even need to specify that it is actually provided by (except in ), giving type level gurantees that you aren't using IO except for random numbers. Then you can wholly reduce to . 

You need to realise that is \$O(n)\$ in the length of the list. And in worst case you do this removal \$n\$ times which gives you an \$O(n^2)\$ algorithm which is too slow for this task. You can be 100% certain that they have a test case that is the maximal number of characters, all the same in both strings as to trigger this worst case behaviour. For example the following: 

As you said yourself, this is syntactic sugar. But your sugar may be my vinegar as I'm not a python developer. In any case, these are largely my personal opinions. Take with a grain of salt. Without macros First of, I'm aware of the fact that this is not a typical review response so feel free to mod me into the ground. However based on a comment by op, I felt compelled to give this a shot without macros. 

And then, if you don't mind making it more defined, make this and the above similar snippet use the same first argument to foldr. 

and both call their argument , leading to mixups. maps the integers to , not . You are looking for . 

Ignoring what kind of error messages you get, you don't need to handle error cases yourself: (!!) already does that. 

When you need to reverse afterwards, that's a hint you should have folded the other way. But this can even be written in terms of : 

Your use of for memoization can be extracted into . If one can stop instead of having negative balloons decrease score, can be condensed into one case. 

Have some rewrite rules applied, combinators used and helpers inlined while I think about your algorithmic question. And make a . 

Another thing that comes to mind is that k*k might be faster than k^2 for obvious reasons. looks it up Oh hey maybe you want to look at $URL$ 

Consider expressing your if zodiac in day of year You are currently testing each of the zodiac signs for month and then day, giving you a total of 12*2 = 24 if statements. If you instead convert (month + day) into (day of year) you only need 12 statements. You can do something like: 

Your principal algorithm is a correctly implemented BSP, so yes. You are creating a Binary Space Partitioning tree. Also, FWIW: You only need two points on opposing corners to define an axis aligned rectangle which you seem to be using here. So you could simplify. Edit: Just noticed your question about connectivity: Just checking the immediate parent will give you a subset of the possible connection information. Since your BSP is axis aligned and 2 dimensional each node can have 1 to 4 neighboring nodes (depending on if it's positioned along the edges or not) or 0 for the root but lets ignore the root because it's not interesting. If you're interested in the full connectivity you can either traverse the tree top down and keep track of all edges and in that way find which rooms are neighboring. Or you can keep track of north,west,east,south neighbor of a node during tree generation and use this information to determine connectivity. If you only look at the immediate parent, you only get one connecting node (out of possibly 4). I do not know how you intend to use this connectivity information so this may be enough for you. 

Note that is the version of r that does not have its set to yet. This could have been averted if merely contained the room's name. The recommendation to use abstractions theoretically also goes for , but what's needed here isn't available in the common libraries. Using my package prototype pointed-alternative and missing StateT combinator getsT: 

This can probably be reduced further because either of us introduced some unneeded numerical operation somewhere. 

This is the backpack problem and NP-hard. We won't be scaling well in the worst-case whatever we do, but we can do a little better by, for example, only keeping track of suffixes of vendor selections that can't be undercut in time and price at the same time: 

In real code, I would consider this to be too much naming for this little code. Most of this would probably be used only once and could thus be inlined. Since the exercise required implementations for all these, it's okay. is . is . Did you try compiling this? means that shouldn't work, and elemIndex takes the Char before the String. 

The code works as is and I have achieved my sought for syntax for iterating over specific types of items on the loadout. However there are a few things nagging me, most prominently the unchecked cast in . I would like help with: 

should really just be the destructor , and in simply call . Calling on a pointer is perfectly fine so you don't even need to check for here. So you only really need this: 

Use of white space You have a lot of randomly added line breaks, this makes your code difficult to read because I have to scroll a lot. Please keep your code tidy. Don't do unnecessary work For example in your destructor you do this: 

I have removed the cast to double, which isn't necessary. The double return type is deduced by the argument. I also changed to use instead of which I think is a bit cleaner. The biggest source of error you have is in the summation of . Adding a small floating point (FP) number (the dereferenced value) to a large floating point number (the current sum) will cause a truncation error. For example will return true due to the limited precision of FP-numbers. What you want to do is to add the numbers from the smallest to the biggest. But simply sorting isn't good enough, consider 10^20 entries (yeah I know fat chance but it's just for illustration) each with value you expect the norm to be 10^2, but in fact it will be close to 1.0 or less. Because after about iterations the running sum will be so big that any remaining elements will truncate. So you need to have a heap, take the two smallest numbers, add them and put the result back into the heap. Then repeat until only one number is left, which will be the sum. This guarantees that you will always minimize the truncation error. However I have no idea if this level of accuracy is necessary for you, but you stated precision as a question so I went for it. :) 

Changing the where to a let allows you to skip passing the secret. Passing guesses in and messages out purifies the control flow part of the program. zip [1..] makes clear: The number of tries during each step does not depend on the control flow. interact, lines and foldr replace the recursion. (Recursion is too powerful for brains to handle in general, so we should avoid it when we have a simpler tool.) Your mileage may vary on any of these suggestions. 

To bring 's last lines closer in method with the rest of your code, you could do and put another to the right of . (Or , because the repeats everything anyway, but that's kinda incidental.) When you implement a transformation of a simple partial algorithm into a safe one, chances are 's already got something, here . in its prefix form allows me to not close each option with a multi-line closing bracket, and shuddup indentation blocks split code into units just as well as names do, and then you don't need to choose names for everything. Each option even already lists a description of what it does! 

So from these results we can draw the conclusion that any differences between the two methods is minimal and I would say it is within measurement error because these measurements are done on an otherwise active system. Benchmark code below for reference 

If executed as is this would require two execution stages. The two multiplications would have to wait until the division is completed before they can start. The total delay is 1 div + 1 mul (the two mul can execute in parallel on the cpu). Compare this to: 

Another thing that you can do (even though I don't believe it will affect your result significantly) is to use instead of to avoid the possibility of a copy. Like this: 

(sorry for the brevity and typos, writing on a phone) Assuming that you are only using ASCII characters you can simply keep a boolean array and keep track of characters seen like so: 

We're passing around a lot of setters and getters and indices, if only there was a library that specialized in that... Enter . 

Here's a little to start with: implements . implements as , and as . These don't error on being out of range, instead doing nothing. is a bad name because list is also a verb and set is also a noun. is . should be called or , because you aren't generating the neutral element or inverses, and are using either commutativity or associativity to only append the original generators to any new elements, and only to the right. 

The general idea is to use library code, particularly to eliminate explicit recursion, and inline things used only once. abstracts computations that can fail and abort at some point, and allows you to bind into pattern matches that fail the computation if they don't match. abstracts retrying them until they work, using s instance. abstracts computations that carry around a piece of state to read and write to. defeats the need for to manually loop. Contrary to that comment, abstraction is kinda Haskell's thing. 

In addition to the other answers: Be more direct towards the user The template parameter is not very explanatory, pieces of what? In your case I can deduce it to be number of that should back the array. As a user I don't care how many s are backing the array, in fact it's also a portability issue as an int can be anything from 16 bits and up. So to be sure I can get the number of bits I need, I need to figure out how big an is on my platform. All I really care about is: 

Disclaimer: This is live, production code for my hobby project: LSML (GitHub). Due to the size of the code I'm unable to include everything in this review. The application is a tool for configuring loadouts for an online mech game. Brief summary of the problem domain A mech has 8 components: Head, Lt/Rt/C Torso, Lt/Rt Leg and Lt/Rt Arm that each can be individually configured with equipment and armor. A mech's effectiveness (discounting tactics and strategy of the player) is defined by what equipment it has and how it is distributed. This software allows creation of different loadouts with equipment and armor and performing statistical analysis on them. Constraints There are three main constraint types on loadouts.