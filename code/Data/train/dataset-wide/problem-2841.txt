The next thing to notice is that a number being even is actually a fairly common check to make. Such things should be turned into functions. Mostly copy-pasting again: 

As others have said, use . As others have not said: definitely use . You cannot sanely mix raw C strings and exceptions without smart pointers. In fact, mixing any dynamic allocation with exceptions without smart pointers is a great way to drive yourself insane, but in this case it's not even remotely justified as there's a class that does exactly what you want. Now, let's see how can be rewritten: 

Suppose we're implementing an interpreter for the bytecode of some stack machine. Let every element of the stack be a , and let the stack be represented by a list: 

These are nowhere near as elegant as the recursive one, in my opinion, but they very well may be faster. I've profiled all five six with the inputs 53435 and 57435 (takes too long on ideone, but is fine locally) and got the following results: 

performs addition of s, performs addition of s, etc. We'll use some monad to store the state of our computation. It doesn't really matter what we use, so we'll just represent it with here. Our function to execute one instruction might be 

I'll cover the C++-specific issues first, and then move on to the design decisions you make. First of all, note that C++ has the Rule of Three. It states that if you have a custom destructor, copy-constructor or copy-assignment operator, you almost certainly need custom implementations for all three. In your code, the destructor does nothing, and you have no reason to define a custom one at all; the same goes for the constructor. If your destructors and constructors aren't doing any custom work, and there's no technical reason they have to be defined past the class definition, leave them implicit. However, you should be doing some work in the destructor: destroying the list! Your user should not have to call just for it to be cleaned up correctly; make it be called by default in the destructor. If it was already deleted, it won't do any harm, and if it wasn't it'll save you from a memory leak. (Alternatively: assert that it has been deleted in the destructor. I don't think it'll make you many friends, though.) Moving on; the way you define and means that and are effectively just members of . Why not get rid of the extra struct and make them members directly? It won't impact performance, the things probably compile to the same code, but it will make accessing them easier. Your function hopefully doesn't modify the list, so you should make it . Otherwise, people will be unable to work with references to const to your list, which will upset anyone who's used to using the standard library. I understand this is the first version, but only allowing people to print the list is a little limiting. Ideally, you should be providing (forward) iterators for your list; they aren't hard to implement, being just pointers with custom increment and dereference semantics. Failing that, at least allow one to apply a function over the list, or to fold it; that would cover most uses. At the moment, you seem to be treating the in the first list as not being a real value. This is rather strange; why are you creating a value that nobody can ever access? This last point brings us to the design questions. All in all, it looks like you end up half-way between representing the linked list and the nodes as a single type, and representing them separately. Here's a suggested rewrite: 

One thing Loki Astari hasn't covered is const correctness, which your code is sorely lacking. You should make anything that isn't going to change , and mark all non-static member functions that don't modify the object they operate on as , too. For example, the declaration should actually be , and the definition should be . Further, I'm not sure making private is all that good an idea. Are these nodes going to be used by one class, or many? If only one class needs to be aware of them, you could choose to make them a nested class and expose more of them. It probably won't matter for performance after inlining, though. On the other hand, I see no reason at all to keep around, as it is only ever set to 0 when an instance is created, and then never touched again (until the destructor, but that's mostly redundant). You should also watch out for variables that start with an underscore: if the underscore is followed by a copital letter, the name is reserved, and you should not use it. If you insist on marking your member variables somehow, consider a prefix or an underscore suffix. 

Now you've got to build your abstract syntax tree. I would advise a class that contains a list of children, the associated tag, and the text in it. Thus, something like 

That'll do the same thing, and describes the intent more clearly. As an aside: you say that didn't work. That is indeed something that won't work, partly because C++ doesn't provide an all-that-easy way of joining a string together with something else. Your best bet would be , unless you wanted to go through the trouble of explicitly creating a . There are also functions like and , but those are generally less safe or harder to use. 

The way you use ranges is not particularly pythonic, as far as I can judge. I think something like this would be preferred: 

Most binary operators are best defined outside the class in order to make them more symmetric. I would recommend using the following pattern: 

I wrote a function () that takes a C string and a destination buffer, and then copies the last word into the buffer. The code was originally C++, and was changed into C later. 

As fogbit said, first check for digits, then if necessary. By the way, unless you wrote your own , it should probably be . Don't print anything on error. Either that the value is correct, return an impossible value (-1 is commonly used), or throw an exception. Printing that there was an error does not tell the rest of your program what happened. Finally, do you really need to write this? Are you sure your numbers won't be in the form , which can be converted just fine with or an wrapper? 

This is C++, not C. Therefore, your linked list class should contain the methods for operating on the list, and it shouldn't expose implementation details like nodes. For traversing the list, provide iterators. You should also make it a template so that it can be used with any type That's the general picture. More specifically: 

As for optimisations -- you could convert it into a list of numbers yourself, thereby skipping some error check that str() may be doing (however, as Winston Ewert has pointed out, this is unlikely to be faster). You could also try not creating a string at all like this: 

As for design: the implicit sharing of state between dice bothers me. It isn't detectable as-is, but it means that there is no way of specifying that a particular die will return particular results (for debugging). If this is used in a multithread application, the results of may be surprising; I'm fairly sure should not be called from multiple threads at once. I think I'd go for the more explicit approach of having an and pair, or ensure thread-safety of . You could also make this more generic: 

Therefore, apparently, it is possible to write something a little faster to what you have, but not by a lot; profiling with a larger set of inputs is needed to really be sure, too. If false inputs are indeed significantly faster to compute with the recursive variant, you may be better off using it as most of the results are not going to be palindromes. EDIT: I've added the function provided by Winston to the results. EDIT2: More functions and their running times can be found here. 

First of all, stylistic matters: Why are you making a singleton? There is no need to require that only one exists: it doesn't use of any global state except itself, and the logging path could easily be passed in using the constructor (along with any of the other "constants" that seem rather arbitrary). If you want to treat problems as more than just , tuples you can write a class for them, but as things are I don't see you using it as such. Neither do I see why you'd want to hide the . A stream which functions as a bundle of other streams sounds like something you may want to use in multiple projects; write it up properly and use it. I'm not sure why you've made the / distinction. They sound like they have weaker restrictions: let that be decided by the constructor parameters or parameters or template parameters, but don't duplicate code just for that. Especially seeing as how you ignore real problems entirely if there are any available. What you're doing with the debug stream looks like too much trouble for me. If you want to ignore all output from the problems, why not just set the to ? You don't handle the case where a solution takes infinite time to execute. Perhaps it should only wait and after that kill the thing? Why are you first writing everything to , and only then to ? As for your performance problems: quite frankly, I'm not sure. Does only adding one problem to the and running it as a normal problem work? Is the difference only in what is printed, or is it actually present? 

I would use the last as the simplest, yes. I'd probably write a helper function to not have to write out the explicitly. The first and second both require you to write out the tuple type. This will change soon, but not everyone will immediately have C++14. Also, they're easier to get wrong; I think you mean to specify capture-by-reference in example 2, for example. With , I suppose 

Where is some (possibly empty) sequence of characters that don't contain and is some sequence of (probably alphanumeric + underscore) characters. Now you could use something like PLY to build a syntax tree. You'll have to define your terminals: 

You'd want to parse to a that has the , the , and a single child. Once you have that, you can go ahead and define the grammar rules. PLY lets you do that with def p_tag_in_text(p): """text : text open_tag text close_tag text""" # You now have an object for each of text, text, open_tag, text, close_tag, text # and can put them together here. Once you've defined all parser rules, you get an abstract syntax tree, which you can then traverse finding all relevant nodes and calling replace on the text you want. As you can see, this method is a lot longer and a good deal more complicated. The token examples I showed don't match the grammar -- you'd probably want to split the , and out of the tokens, and make sure that and just contain the identifiers. I've also not entirely specified how the grammar rules should be implemented: the current setup leads to it being unclear where the text is in relation to the tags. You'd have to refine the system somewhat to make that work (probably making the text a kind of child, and appending it at a suitable time. Because of this, you should first try to restrict your input. If you can ensure a number of things about tag nesting (especially tags containing themselves) it would allow you to do all of this with a regex, and in that case Winston Ewert's solution is what you should go with. 

Everyone knows you can't put a in an . I decided to implement a collection which does allow you to do this: 

Why not just ? It's simpler, it means you can't forget to check whether things succeeded, and given 's implementation it is likely to be just as efficient. Speaking of checking whether things succeeded, why not throw an exception if the input is invalid? There are valid reasons, but it's certainly a solution you should consider. (By the way, if my previous solution sounded bad due to the need for exceptions, have no fear: fits the use-case very well.) And, in a similar vein: it sounds like you're trying to prevent the creation of invalid s. However, your default constructor does exactly that. Are you sure default-construction is more valuable than guaranteed validity? Again, depending on what you do with the class, the answer varies. All in all, I'd suggest dropping and writing: 

You also seem to have an awful lot of duplicate code. Try to factor common operations (such as setting up all those members) into separate functions. Speaking of which, your functions aren't particularly clear. Why does a method called not return anything? What is it supposed to get? You've got plenty of hard-coded values in there. I hope that is a placeholder value; the other ones should be passed in as parameters. Could you make it determine the agent ID based on the email? As things are, it seems like this is prone to incorrect combinations of input if anything is changed. 

This code is perfectly fine to use -- I applied some cosmetic changes, but they don't particularly matter. Gabriel is suggesting you use iterators, but I don't think those make things any better: 

where pops two objects of the given size, applies to them, then pushes the result on the stack. The question, now, is how close we can come to implementing . Intuitively, the type is something like 

Here's code that does exactly what you were doing, but with 's new constructor and with no temporary. I think this is just as clear, but some may disagree. An even clearer way to do this is 

I don't know if this is actually faster or not. You should probably get rid of the single-use variables, seeing as I am not sure they will be inlined. Alternative non-recursive solutions: 

By the way, you're not checking that the array is of sufficient length in . in does not depend on the parameters of the second-outermost loop, so it should be in the outermost loop. You should also use instead of in the call to . About testing: , , , and all seem to be pure functions, so you can test them simply by checking the return value. You might want to get a framework like GTest or Boost.Test to make them easier to write. 

First of all: names starting with an underscore followed by a capital letter are reserved for the implementation. You may not use them. Ever. You might also want to specify whether you're interested in all advice, or only that relevant to C++03; I don't see much C++11 could do here, but it's generally an important distinction. Now, comments: 

Using on doubles isn't usually a good idea, although it may be okay in the case as you know you've assigned exactly 1.0 to it previously. I would write as follows: 

We'll need opcodes for addition, subtraction, and unary negation. However, apart from acting on s, we might want to treat the top two elements together as a , and then the next two as another , and then do something to those. To keep things simple: 

Note that the spacing may be off (you use 100, 110, and 120 in the different functions -- either pass it as a parameter, or choose one). Secondly, instead of the long if..else chain, you could use a dictionary. For example: 

What your code says is "given two arbitrary types and , the functions form a monoid". This is not very meaningful, as the resulting definitions for and are not very meaningful. In particular, something to the effect of is required. What I think you were looking for is . A category can be seen as a generalisation of a monoid where not all elements can be combined. Haskell types and functions naturally form a category, with being the identity for each type and being composition of functions.