I find it's good to get into the habit of using to open resources so don't have to worry about forgetting to close the connection. 

People do this sort of thing all the time in the JavaScript (this.arguments) and Python world (*args); however, by removing type constraints from the parameter list, you have to be wary that you're always providing the types of parameters your function is expecting. If one of your parameters is supposed to be a string, and someone passes in an object, bad things may happen. Conversely, some very respectable projects use multi-line parameter lists. It's fine to have a lot of parameters, as long as they're all necessary, but it's always good to be skeptical. Long parameter lists is a good code smell – if you see them, the code may need refactoring, but not always. As far as the attributes of Box's, forget about programming for a second. Conceptually, what are the properties of a box? Can a box still be a box without a color, tileW, tileH, walkable, speedY, and speedX? Can a box still be a box if it doesn't know how to draw itself? If your answer is no to all of these, then your code is fine, and requiring parameters as a single collection/object vs. individual parameters is (arguably) a matter of preference. That being said, I would move the three lines to a separate method . It's best to only do construction in the constructor, and leave the rest – like rendering – to other methods. 

$this->get('feed_parser') is just a fancy way of getting a SimplePie object from the PIMPLE container - you could just instantiate a SimplePie object yourself (if you want code you can't test). After running this code, $item would be a PHP array (or some collection class) containing the details of one image. In my case, I then exposed this as JSON and a REST API endpoint for use by JavaScript, but you could just as easily have PHP output the appropriate HTML. 

The keyword in a class definition A method and attribute for data created by single method A very long, ambiguous method: Two mostly-different SQL statements separated by an 

This started as a small set of objects that transformed data, rendered the graphs with D3.js, and managed the layout all in the same object. The graphs can be removed by the user, and they resize based on screen width and the layout adapts to smaller screen sizes. I've decided to convert each type of graph to a subview and use a parent view to manage the layout of these subviews. This allows me to centralize the code that inserts the graphs into the DOM based on width, platform, etc. The subviews are all built from a single, large set of homogenous data. I have a single object that constructs these views based on available data then stores the subviews in a collection object (to be persisted when the report is saved). This collection of subviews is then passed to the layout manager for rendering. Subviews are only constructed if the data is available. The thought here is separating object graph construction from the rest of the business logic will make it easier to write unit tests – a requirement moving forward. I'm having trouble finding a good way to place the subviews on the page. Currently, they're all in a single collection, but they need to be placed in different places based on what kind of graph it is and which set of data the graph is for. e.g. for each of 1-3 "properties", a graph of growth for the month needs to go at the top of the first page and middle of third, while a single graph of top referrers needs to be drawn only on the last page. The most obvious solution would be to simply iterate over all of the subviews and using a giant switch statement, but I think "giant switch statement" and then immediately think "refactor" and "use polymorphism". One of the ideas I had were to index the subview collection and create a map to lookup the DOM insertion code based on the index, but this is only a stone throw from a giant switch statement, and I'm essentially coupling my layout manager to the subview builder. Another idea was to check the subview instance name in the layout manager, then insert the graph into the appropriate place in the DOM based on this value; however, this would still require a big switch statement. Is there a good solution to this problem, or is my design flawed? Here's how the page is initialized (in a Twig template): 

More on resources: For instance, if you store 1KB every time the / route is loaded and get 1M visitors a month, you'd be up to 1GB of memory just for global_list in around 1 month. 1KB is a lot of data, and you probably don't need all of this information to do your calculation in /test. Instead, you could aggregate the data by using global_list as a running total for the full set of data stored elsewhere (a database or filesystem). If you're doing more than simply presenting a count of records in /test, and you need whole (or partial) records, then you can do pagination. Let's say you're presenting a list of the records in global_list. In this case, /test could simply return the first 10 records by default, but allow the user to see more pages by providing a page parameter. So if the user wants to see records 31-40, they could request /test?page=4 

Continuing on Peter Kiss's answer, the keyword is indeed hard to test, but you don't have to worry about it when it's in a dependency container. If you use Inversion of Control and have your objects ask for a DB connection, rather than getting one, you don't have to worry about using singletons or static class properties – you just let the dependency layer manage connections, and this can be done with a simple static variable inside a closure (see below). This answer is verbose, because I'm going to assume ignorance and try to explain Dependency Injection in as simple terms as possible (I still haven't found a concise explanation of DI). Afterwards, I'll explain how you can use DI to ensure no more than one DB connection is created. You need to create a very generic container object to contain dependencies. At runtime, you insert these dependencies into this container (typically before you do anything else). Then, you pass this container to the constructor of any object with a dependency. The object then retrieves the dependency it needs from the container. This allows the dependent object to be completely ignorant of how the dependency was constructed: e.g. a database object could have been constructed from PDO rather than MySQLi (though you'd want them to share the same API). This aids in making your code much easier to test by keeping object graph construction and application logic separate. If you're using PHP 5.3+, I'd recommend looking into PIMPLE. Here's how you'd set things up. 

Definitely separate your PHP from HTML as Alex suggested. You probably don't need to go the full MVC route for something so simple, but simply generating your PHP variables then outputing your HTML would make your code a lot more readable/manageable. I like your idea of generating a random string and checking it, but Flambino's right, it will never be reliable (by design) - also, imgur probably hates you ;) A simpler approach would be to consume imgur's RSS feed: $URL$ I was bored one morning, so I added something similar to the login page of one of my projects. It pulls one random image from lolcats' RSS feed and inserts it into the page. Here's the code that pulls the image: 

This depends on a few things (keep reading). Not necessarily. This is a question of optimization. You could fetch a vote's book by using Chapter as an intermediary (), but this would obviously require sequential trips to the database - one to get the vote, followed by one to get the chapter, and finally one to get the book. Do you plan on fetching a book for a vote frequently? If so, save some resources and stick with what you've got. From a dependency standpoint, this seems counterintuitive, but since a chapter cannot exist without a book (can it?), I would say this is fine and simply a matter of preference. This always seems awkward to me as well, so maybe someone else can provide more info. You can, again, this is a question of optimization and convenience. When you have questions like this, ask yourself, "will I really need this?". If the answer is no, or you're unsure, leave it out; you can always add it later if your needs change (the relations are setup correctly to do the joins, right?). See above. I would provide a Chapter.getVotesSum() and/or Book.getVotesSum(). These methods would include GQL queries to aggregate the appropriate rows from the votes table into a sum. 

It look like the first link on every page of the site is the same (e.g. the link on a logo) and the children processes are simply printing this (correctly) so it looks like incorrect behavior, but isn't.