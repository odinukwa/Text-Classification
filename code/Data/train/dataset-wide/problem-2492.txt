you see that it goes through some preliminary steps relating to the fact that it needs to handle a list of potentially several paths. You only ever have two strings to compare, so you can skip that - and in fact, if you look back at the profiling data, you'll see that these calls to and do take up a significant amount of time. Therefore, it makes sense to implement your own version of without the and calls. 

Instead of chopping off the whole end of the list, as in the previous method, this one pops off the last elements one at a time. 

Mostly, this is a matter of convention, but also, it's handy to have a function that can be run from another Python script that will just do everything. Organizing the driver code The process of evaluating an RPN expression is something that makes a lot of sense to put as its own function. That's a self-contained task you could easily want to reuse elsewhere. So I would suggest making a function which does exactly that. You can then use this function in your main loop as follows: 

and it will automatically strip trailing zeros as needed. Of course, this does display large numbers in scientific notation (); if that's a problem, then you might have to do your own formatting. Use descriptive variable names Your list doesn't actually contain tokens; it contains operators, and could be generalized to contain functions. So I'd suggest naming it or some such thing. Allowing arbitrary numbers of arguments This is really more about adding a feature than reviewing your existing code, but I might as well point you in the right direction. All you have to do is store the number of arguments a function or operator requires, in addition to the code that actually evaluates the operator. For example, 

Most of the time is spent in (my renamed version of your function), and after that in , so you'll want to focus your optimization efforts on those parts of the code. There are basically two approaches you can take: 

can time arbitrary expressions, so I don't see a good use case for what you're doing here. In fact, it could be considered bad practice in the sense that timing information, which is normally in the same category as debugging code, shouldn't be built into your program or function or whatever. You should be able to add that on "outside", only if needed. That's what allows you to do. Of course, sometimes it is actually useful to include timing information as part of your program. Even in that case, it seems like overkill to use a lambda function. A simpler way would be 

If different parts of this expression could raise the same type of error, then that would be a good reason to break it down, so that you could tell exactly where a given error comes from. But that's not an issue here. You'll only ever get s for one reason. Same goes for the float-parsing part: 

OK then: since your concern is speed, let's track our progress with actual timing data. The first step is to run the code through the Python profiler. With the addition of a bit of driver code that just calls 10000 times, I get the following results: 

I'll start with , since you wrote that code and it'll be easier to work through. The algorithm you use is to go through each pair of consecutive strings in the sorted suffix array, find the common prefix, and save that prefix only if it's longer than any common prefix already found. I can suggest a few improvements: 

Don't overuse variables You don't really have to save and and separately; you only use them once each. 

The only real purpose of is to make it so that you get a instead of an when a function or operator doesn't have enough arguments. But I don't think it makes sense to do that. See, is just a stack. (Well, a list that is serving as a stack.) It knows nothing of numbers or arguments or calculators and really has no business raising a . The code in is the thing that knows it is a calculator. That's where you should be raising s. So instead of using , just watch for s during the evaluation, catch them, and raise a in the handling code. As a side effect you won't need anymore; you can just dispense with it entirely. 

So at a minimum, I'd suggest wrapping all your code (except for the function) in a function. It's good to separate the input/output from the calculation. So the loop in the middle should probably be broken out into its own function. You should give it a name that clearly identifies what it does, like . Don't declare and all the way at the beginning of the code. Wait until you need them. In fact, if you're breaking out the loop into its own function, you should put those variables in the function itself. Have the function return the number of solutions and number of duplicates, because that's all you need. is not a great name. That function actually checks whether two numbers and their difference contain all the digits from 1 to 9 a specified number of times. So give it a name that reflects that. You can expand on the name by using a doc comment. Similarly, and aren't very conventional names, although in this case because you're just running a mathematical algorithm, there aren't much better choices. It's common to use and in this case, since the numbers are integers, or and if they were floats. And it probably makes more sense to pass the number of times each digit should appear as the argument, not the number of digits in each of the original numbers, because that way it's a lot easier to understand what the code does. is another name that doesn't make any sense. That variable actually holds entries representing the solutions you've found, so why not name it accordingly? Get rid of variables you don't use anywhere, specifically . It's conventional to use as the return value to indicate that a function doesn't have any meaningful result to return, so I'd suggest using that instead of . Nothing wrong with , but it's a bit strange to have a function returning either a boolean or a string depending on the result of a calculation. Don't pass around more variables than you need to, unless it helps performance. In this case you don't need to return both the number of successes and the list of successes. You can find the number of successes by taking the length of the list. The calculation of maxes and mins probably belongs as part of the solution-finding function. That helps you avoid passing around more variables than you need to; with this change you only need to pass one argument, the number of digits.