Write testable code The above point is a pseudo-contrived example, unit tests are possibly a better example of when you'd want to not keep creating new objects. the login credentials are not something that are required at the time the Login class is created: 

In the above example, an array, a scalar or even a nested array can all be handled by the same function. Use PHP's built in filters Rather than write your own filters, you're better off using PHP's sanitization filters. For common cases, your code becomes therefore (assuming this is implemented): 

Conclusion There's no CakePHP code here. If you're interested in writing/using something similar to the code in the question, it may be useful to look for a lightweight framework such as, for example, slim - either use it as is or pick through the source to make your own framework. 

Not testable The biggest failing with the code as written is that you can't unit test it - I.e. you can't use PHPUnit, mock things and verify that it handles all circumstances you think it can. The main roadblock to this is putting directly in the same method that does things. A better idea is to do: 

As well as making using the mail class easier, this has the advantage of the backend mailer class only being constructed on first use, it also makes testing easier: 

There are other minor details which could change - but adopting this pattern will generally lead to more maintainable code. 

since it tries to talk to the database, which isn't connected. You can use set_exception_handler so that you don't need to scatter try catch blocks around your code where the intended result is to do nothing except logging and show the user (or developer) a 500 error message. With that said, some more detail in the order points are encountered reading the code: Don't mix presentation logic into classes Unless the class is dedicated to presentation logic - don't put presentation logic in it. This simply means don't return or assume html, instead just return appropriate data (booleans, arrays - as appropriate). The function is an example whereby it would be better to just return the array stack and let something else loop over it and dump to html,json, the log etc. Don't create needless classes The error class doesn't seem to offer any benefits. I.e. this: 

By making use of the block option, the same layout file can be used even though the css/js/whatever in each template is different. If the layout structure differs - That's a good reason to use a different layout file via: 

A consistent constructor makes it easy to know how to use a class without having to continually refer to the docs or class definition. If that's something you do with none-constructor functions (not applicable here) your code would not be compliant. Having different constructors isn't particularly intuitive, and means you can't have simple override logic like so: 

Use a pattern The general principle is fine, though it won't handle plugin routes (which I assume isn't a problem) However instead of a loop (and therefore defining 6 routes per controller) a parameter for the controller name can be used which will be more concise and likely overall more performant. The code could be rewritten like this: 

Also note that using negative checks can be harder to read - so it would infact be preferable to write as: 

Don't classes you aren't using - is not used Load models using - Using the table registry of course works, but loading models in controllers is normally done with loadModel - it is more efficient. The template makes no reference to the variables being set in the method - , and are unused - if they aren't used don't set them. Provide a complete example - The controller code and template don't relate to each other - it's hard to put either into an appropriate context as the code in the question, whilst complete enough to comment on, isn't complete enough to see how it's used. 

Neither of these permutations should be possible and indicate that you need to know the internals of the class to use it. If you don't know how the class is storing the parts of a url, you can't use the class and/or will get no errors with mistakes, just nothing useful. This would be easier to use, and a lot less error prone: 

Don't point at php This script looks like the intention is to point at a php file, that returns the compressed content. Assuming that's the case... PHP doesn't belong in-between a user and a static, public file. Webservers are much better for serving static content. Rather than pointing at a php script that processes the request, looks for and/or manipulates files and then serves it - take advantage of the webserver and point at the cache file directly - or where the cache file should be if it doesn't exist. I.e. change this logic: 

There should basically be no super-global references in app-land code - all of the same data is available via , , . None of that will work with the code in the question though, because it's not based on CakePHP's controller class which populates those variables. 

I think for sql injection you're ok. Some tips that are general points though: Don't catch exceptions just to throw a new exception 

Especially where it appears inline somewhere - use whitespace for readability. Sprintf If you find that your code gets to be like this: 

Use a validation function There are many possible solutions, one thing you can do is use a separate function to validate your data: 

But, especially with the above example, it's more work to use the filtru function than it is to just write: 

Format for readability If you're jumping in and out of php - having lines like this: make things hard to read, especially if there is some nesting in the code. Whether you choose to use curly braces or the alternate (colon) syntax is up to you, but in html code using a style which aides readability (putting the curly brace/colon on the same line as the statement it relates to) helps. No PHP Short tags Shorttags are often considered a bad practice, and as such should be avoided unless the code is your own, and you control where it's going to be used. Note that you can use with PHP 5.4 irrespective of the shorttags setting. Consistent whitespace The following: 

In this way the embedded logic in the build method is separated and more obvious - and the repetative logic is avoided. It also becomes possible to run the function whenever the data changes rather than each time a call is made to return output. Concusion Some of the other answers have focussed on the use of public properties, on that: what does it matter. There are more fundamental concerns to address with the code presented in the question. Whenever writing code, try to apply the DRY principle not only to the code you write but also to the code as executed. In this way you get code that's easier and faster to read and run. The way the class works is only 'easy' to use if you want an absolute url. The build method should be refactored to permit only real possibilities. If you're already using the class with more permutations than just absolute and relative urls - you'll need to decide whether to change the calls or the code so that it still works. Assuming your code already works you're in a perfect position to write a few unit tests for your class (if you don't already have some) - and then start tweaking it. Writing unit tests will give you the confidence to rip the guts out of any code and know that if/when the tests pass - you've safe to commit your changes and benefit from your shiny(er) code and/or new-found knowledge.