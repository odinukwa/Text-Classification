There is an easier way to get the port names - . I don't really like using the attribute of the for the format string. This seems like a misuse of the attribute and I'd prefer to use a for the mapping but that's just my opinion. You are catching all s in various places and write them to the console. This is usually abad idea because you don't give the caller any idea that something went and pollute stdout with the messages. It's better to use either a dedicated logger to inject or to log the messages and rethrow the exception so the caller can deal with it. You dump various messages to the console without giving the caller the option to change that behaviour. Again using an injected logger or the class is a better option. In your method you catch the and format a custom return error. I think letting the caller catch the exception would be more flexible. is because it derives from so whatever object owns the should implement as well. 

should probably be an interface so you can inject it through the repository constructor. For unit testing you can mock out the interface. If the repository is a transient entity (i.e. constructed per web-request for example) then injecting the context through the constructor is probably the most straight forward way. If the repository is longer lived (like a singleton lifestyle) then you might want to consider the unit of work pattern in order to limit the lifetime of your context. 

In the methods and do not modify the object state so you should consider making them (i.e. ). I'm not 100% convinced of the property. It basically just reflects the current position of the object in the depth-list and you are writing a fair amount of boiler plate code to keep it that way. This increases the complexity of the class somewhat. I'd revisit the concept and check if I can't get by without it. 

Since we're interested in the smallest (so the resulting number has the maximum number of 5's and is therefor the largest matching one) this leaves you with roughly this pseudo-code algorithm 

Regarding vs : I tend to prefer if it's for simple pointer checks and when the expression is more complex. However some companies enforce the style because a typo like typing instead of will yield in a compile error this way (you can't assign something to a constant) instead of an accidental assignment. I never managed to consistently do it that way (old habits die hard) and to be honest I've never run into a bug due to this (compilers these days spit out warnings for these kind of constructs). 

will create 2 strings: one from and then the new string created by appending it to the existing string. A will just keep a list of all the strings to append and create one result string at the end when you call . So instead of strings you only create strings. The has the same problem. There are some optimizations in the C# compiler which can transform sequences into calls on a but you should not really rely on this. In the end it doesn't matter too much if your strings a short. However when you hit the 85kb limit then the strings will be placed on the large object heap which can cause problems because it doesn't get compacted and you can get holes. This can lead to weird out of memory situations (you can find more with google). 

Now you have a generator which creates a sequence yielding for each number if it's a multiple of 3 or 5 and the translated version of it. You can create algorithms to implement question 1 and 2 based on it. 

Service locator is an anti-pattern because it tends to create implicit dependencies which are not easy to see and usually cause grieve when trying to write unit tests. Especially your implementation which references what seems like a singleton instance which can cause additional problems (i.e. you need to take care to reset it between tests). Avoid it. I can't say much about the MEF injection but it seems roundabout having to write all that code. It also creates an implicit dependency which will probably cause grieve when unit testing your class and makes it directly dependent on MEF while there is no need for it. Avoid it. Clean and simple. Explicit dependency, easy to unit test and injection can be easily manged by any IoC container of your choice (Unity, Ninject, Windsor, etc.). The way to go. 

Those comments add no value. Furthermore reiterating what the code does in the comments will usually lead to comments conflicting with code once a few rounds of refactoring have taken place. Why is this called ? Graph means usually one of two things to me: Either a data structure with nodes and edges connecting the nodes or the visualization of some data. I can see neither of those here really. You repeat a lot of string literals in your response creation. This should be refactored into a method. Makes refactoring later easier and avoids typos. Maybe even create a class encapsulating the response so you can do or something along those lines. 

The use of two different variables which only differ in the capitalization of a single letter is ugly and error prone and you should use a different name. One convention I tend to follow if I select objects which are to be destroyed is to call them . So maybe something like this: 

It's been a while since my assembler days but your routine should really use a loop to check the array. Basically it should accept the start address of the array, the number of entries and the number to search for. Right now if the requirement changes to lets say have an array of 10 numbers you are in to do a lot of copy and paste and bound to make mistakes. You have already used a loop for the input so why not for the search as well? Also some of the names like could be a tiny bit more descriptive. 

Similar for and your various event handlers. (I'd also remove the suffix.) should be a . Then you can remove the unit as part of the name and gives the caller more flexibility. If you call in just the right moment again after it has been called before, you can have multiple calls going on. The right moment is that the timer just elapsed from the previous call and started to execute but hasn't set the flag yet. I don't know if you want to protect against it. You will call twice on the timer. This should be harmless but you might add to . This: 

As it stands now I probably would not bother adding an additional method however I would introduce local variables to hold the arguments for the call instead. Can make debugging a tad easier. 

return a reference to the element however you effectively store a local copy to pass to the callback function. It would possibly be more efficient to change the callback to take the input element as a reference instead to avoid the local copy. 

As you don't actually need the index of your , the more idiomatic way would be to use a loop. From your earlier review requests I do remember that the properties are static properties on the class in which case you do not need to create an instance in order to obtain the value for the property. When using a regular expression you should make use of the grouping which will remove the need to split it up afterwards. Alternatively use and which would probably be faster than regex matching. 

Programmer error (the passed in heap pointer is ) Failed to allocate memory The element already exists in the heap (this may be perfectly fine) 

I'd prefer 2 or 3 because it enforces the readonly-ness in a much stronger way. Update Number 3 could be simply implemented as 

Easier to debug. You can simply set a break point and peek the queue. This is quite difficult to do with the wrapped task approach. No use use of lower level synchronization primitives. The first time I read your code I instinctively thought "Hang he's got a why the calls" until I realized that the decrement happen in the async task outside of the lock. With the you program against a slightly higher level of abstraction which is often a good thing. Fewer class members which reduce the state complexity of the object (the queue is the only member). 

There is no need for the - your structures are small enough so they can live on the stack of main. So you could just do: 

Can't say much about the javascript in general as I don't use it but: Please do not comment every line of code. This means you write your program twice: once in the comments and once in code. They are bound to drift apart and get out of sync and all of a sudden you have code which does the opposite of what the comment says and then you are in trouble. Bad comments are worse than no comments. As Jeff Atwood pointed out quite nicely: Code tells you how and comments tell you why. 

I wouldn't have bothered implementing my own queue. Just use a or a plain with an index pointing to the current head element. Saves a bunch of code which you don't have to test and maintain. You shouldn't use the mutex directly, you should use a instead to make sure the mutex gets released automatically when the scope is left. You should reduce the scope of the mutex to a minimum to avoid unnecessary lock contention (in this case probably more of an academic point but still a good habit to get into). So the method could look like this: 

The implementation is obviously not thread-safe. Just something to be aware of. One way to improve it, is to just use a variable to store the current maximum id and return the next one higher if you need a new one. If an id gets freed up then you could just not worry about it. If you really want to re-use returned id's then store them in a set. The basic logic then becomes: 

Your code duplication in (2x in there) and is around the differences of how the keyword is handled and how the prev/next links are enabled/disabled. Lets look at the link enabling first. To me the logic of disabling the links should be very simple: 

Hard to read code is more difficult to maintain and you're more likely to miss a bug. Use braces consistently. Things like these just lead to trouble in the long run and don't make the code any easier to read. 

Overall Your header doesn't include any function declarations so I'm not sure what your "public interface" will be but only few of your functions are so I have to assume you intend to make all others available in which case I have to say I don't like the interface into your structure. From the looks of it your should only be manipulated through the appropriate functions yet your return the pointer to the internal storage from various functions which has the potential for the programmer screwing it up easily. So consider carefully defining the interface into your structure and how you intend it to be used. Most of you functions should either return or an result indicating whether or not the operation was successfully executed. When dealing with memory allocation you should always check the result. I'd probably even go as far as making opaque. Suggested interface in your header file: 

If you want to make it faster instead you could try reading the entire file into memory in one go and then calculate the . Something along these lines: 

where is the number of 5's and is the number of 3's and is the known length. One simple way to solve this is to transform it into: 

I think the xml doc comments are ok although in general mostly I'm dubious about documenting the backing fields as well as the properties. I typically like to keep them together like this: 

Also is actually constant for a given image so it should be computed once before the loop. Not sure why you are obtaining the properties of the image as pointers rather than copying the values directly into local variable. This should save you a bunch of loads in the loop below. So instead of 

Basically return if any of the memory allocations fail or . Provide a if you want to give the programmer an option to just allocate an object with default size (I personally don't like these implicit "pass 0 or negative to obtain a default size allocation" implementations but YMMV). Technically the result of a pointer subtraction is and not . The former is signed while the latter is unsigned. You should probably store the result of the subtraction in a local variable of type and check that it's not negative before returning it as . If it's negative you apparently have hit a bug in the implementation. can be greatly simplified by using rather than copying each byte individually. It will also be much faster. 

Your list holds values of type yet you named the node type very specific in relation to file descriptors which will be a bit weird if you make a list of lets say prime numbers you want to operate on. Consider renaming your node type to something more generic rather than (especially sincere there is a type in ) Your method actually doesn't insert an element, it appends it to the end so it should be named . doesn't work when the node you want to delete is . I know you handle that case separately in but it's still bad that the caller has to know that fact. It also clutters the code with lots of special handling. is a bit weird: It skips the first one, then prints all following nodes in order and then prints the first one. So while it prints out all nodes I'd say it's still unexpected from a usage point of view. None of your methods can deal with the fact if is being passed in. If you your structs then you can save some typing work.