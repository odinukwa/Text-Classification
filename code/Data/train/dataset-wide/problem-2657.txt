A few other things to notice here: Stop using . Throwing generates a large amount of code, and is on the “cold” code path in a function you want to be inlined most of the time. So always break that out into its own separate function. 

No, this is not a visitor pattern. You are trying to do double dispatch. You are actually calling every time. There is nothing I see that will then do the second dispatch to the right derived class for the actual type of the parameter. What did your test program print?? 

Continuing, I see the same issues. loops, writing by hand instead of knowing the library, etc. You don’t need a bare return at the end of a function. Various print-out functions that don’t change the object should be . 

I saw the vectors and wondered what the values were for. It is hard to evaluate the code without knowing the data model via an explaination. I wonder if using index numbers are a good solution for keeping track of cards. Why not pointers to the card instance, for example? There is a Boost library for multi-index collection that can be handy if you are keeping multiple ways to look up the same data. 

Good that you use an initialization list! You are, however, using ye olde syntax. Use curlys, not parens, for initialization. Since you only have the one constructor, “all” of them use the same values for most of the members. Put them in the class definition as direct initializers on the members, instead. 

My explorations on GCD and performance Aside: you might find My blog post interesting, where I found bottlenecks in GCD including branch prediction, lack of instruction parallelism, and the DIV instruction. Even things like Modulo is significantly slower for signed types compared to unsigned types of the same size! Since the values being used are all positive, that is another speedup. For some operations, the opcode is faster for 32-bit than 64-bit; so switching to a smaller version once the numbers get small enough will speed it up. I found that an algorithm written for computers in 1961 that does no division runs slower than the modern expression when coded naively, but once the bottlenecks in that are found and eliminated, it runs much faster. The CPU can burn through lots of primitive instructions so the increased length is not significant; it’s the traffic jams inside the CPU that kill the performance. 

Look at Boost.Range. Your first point drives most of the rest of the concerns. Write your template function to take a Range. You can pass it a C string literal, a std::string, an array, vector, or anything —— even a pair of iterators if that’s what you need after all. Not limited to char? No problem: make it a Range of T, with a default of char. This takes the place of your initial idiomatic approach. Use ranges rather than iterators, and you don’t need to wrap it for convenience. Boost.Range does all that for you. The output can remain an output iterator, but I like to make it a range adaptor. With that, you can do things like: 

Well, I wonder how it’s different from and related stuff. I assume there is something different about it so that’s a mental burden right there. 

Use (almost everywhere). since there is no code-movement barrier, your benchmark might not be accurate. 

You are assuming that the container holds elements which have the form of constructor you are expecting. Anyway, now your first example in becomes: 

Conceptual thoughts Your are setting things up to handle a member function call on a receiver object. Generally, a callback may be a free function, and may involve one or more objects with lifetimes to be managed. It may well be a function of yet another class, or a free function written just for the use of this callback. Given (as discussed above) that you must use actual shared_ptr’s to the objects in question, there is no reason to intrusively adapt the objects that may be called back (e.g. your required base class). I see such a callback can be handled idiomatically※ like this: 

this->Key = key; this->changed = changed; No… Write your constructor initializers, not assignment on top of default-initialized members. Learn the difference between initialization and assignment. 

This is called double dispatch because you are using virtual calls twice to resolve two different polymorphic aspects of the call. The first call to is a virtual call so it recovers the correct type of the message object naturally. Then the body of that function uses overloading to call the proper function of the set. But, to allow for different commands, that requires a virtual dispatch too. You also see that my sketch did not provide additional arguments to the call. If you had commands with different signatures, this gets repetitive. 

Do you understand that is already of type ? It is pointless and strange to compare against or . Converting a value to an integer produces 0 or 1. So you don’t even need that test in the first place! 

Many years ago, long before Boost existed, I implemented reference counted pointers (as did a lot of people, I’m sure). Since the compiler did not have partial specializations it was basically impossible to make and automatically produce different classes (the version lacking the read-write forms of access and having different implementations for some of the functions). So I did the obvious and made two different named types — and . Nobody was bothered by this, even years later when it would have been possible to write a partial specialization instead of two classes. (It was also natural to have more than one flavor of non-constness by having separate names — shared reference vs copy-on-write). Also, compilers did not allow for template member functions, so it was not possible to write a templated constructor that implicitly converts. I used two work arounds which you can find on the linked page. 

speed of Look at branch prediction. If an statement will go one way or the other at random (as when traversing a tree) the predictor will never get it right and you have a huge latency. 

So, isolate the two groups of letters and do the same thing to each range, where I pushed how to do that down into another function I’ll write later. That function needs the value to work on, needs to know how the two ranges (upper and lower) differ so it work on both, and I also parameterized just how for to rotate — this allows 3 to encode and −3 to decode, all in the same function. So, this function can encode/decode too, and should take a similar parameter which is passes through. Following the earlier note to break it up from the file I/O, and here I also separate it from slurping in the whole file. The one thing this function does it work on a single string. It does not care where it came from or what will happen to it. It does one thing only: rotate the letters in a string. 

Thou hast scribed an olde dialect. You’re using the ranged loop so your textbook must be written after 2011; perhaps it is just a slightly updated lesson plan from 1998? 

Put your variables where they are first used, and ready to be initialized. Don’t put them all clustered at the top of the function. 

See ⧺ES.9: Avoid names. I see you are using a new language feature of , so your code might not be as out-of-date as you feared. You might consider reserving a value of 0 for ERROR or empty or something like that. 

You can use default initializers on the data members, and not have to list them in the constructors. 

Your should be called . And you can get it from so do you really need a separate entry for that, and if so, shouldn’t you generate it automatically too? Or, define the functions in terms of the nested rather than peppering the specialization with and etc. in all the identical places. Again, if you factor out , the rest of that just goes away and you don’t need any explicit specializations for . 

Don’t use the macro. Forget it ever existed! In this case, your initializer is . The style in C++ is to put the or with the type, not the identifier. This is called out specifically near the beginning of Stroustrup’s first book, and is an intentional difference from C style. 

What if no character was read? The stream could be you know. Maybe you hit the end of the file, or the network glitched. 

It also lets you use a range- loop for the kind of access used in the function. However, your code to access each position in a systematic mannner (rows, cols, diag, box) is inefficient. As I pointed out in the tic-tac-toe answer recently, you can declare a linear array and multiply the rows and columns out yourself for single position access, but use single additions of a stride to navigate your pattern. (actually, the stride probably works even if you declare the array as 2D as you have it. I’m not sure that’s completely proper though) Then you can have a single predicate which takes a starting point and a stride and does the loop of nine comparisons; this one function will cover rows, columns, and diagonals, efficiently.