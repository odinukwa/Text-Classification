Macros can be quite good at alleviating these sorts of pains; there is , for example, which works well at handling Results; if you refactored your code so that all of the important stuff was inside a function which could then return , for example, you could use on all of the fallible I/O operations. As it is, you can do things like writing a new macro to assist, and also give a more helpful message explaining where the error occurred. Here’s something more like what I would write; of course, there are various points that are subjective, and I have made some stylistic changes to be in line with what I believe to be more common standard style: 

Secondly, you shouldn’t be using strings for this; you should be using paths, because that’s semantically what you’re dealing with. The easiest way to get a path tends to be to take a or a generic parameter implementing and calling on it; , , , and more implement it. You can get the base name from a with ; this admittedly produces a , so if you want to display the path you’d need to convert it back towards a string with e.g. . Anyway, the point of this latter part is just that for something that is semantically a path, you should be handling it specially, as a rule; a path need not be Unicode. Think on it more. 

One must realise that in these common tasks that people tend to assume must succeed there are actually possibilities of failure. 

If you wanted to minimise allocations, you could shift the definition out of the loop and replace its assignation inside the loop with . That way it can keep using the same heap allocation time and time again. But that’s an optimisation that is not necessary for something like this. I might or might not do it, depending on what I had eaten, if anything, for morning tea. Personally I think I’d go with instead of in this particular case, but that’s completely subjective. 

Making private fields public only for the sake of tests is undesirable; you should instead add new methods which are only available in tests, e.g. 

Expressed simply: testing your own code shouldn’t have any impact on the API exposed to library users. is already ; no need to wrap it in . should be rather than in most places. Basically, you should never need to clone the after the first time when you insert it into (to “remedy” that, you could use instead if you wished; not sure if I would or not). You’re doing a lot more memory allocation than is necessary. Unwrapping is undesirable. See if you can avoid it. can be rewritten thus (note how this also makes it only one lookup rather than two, so it’s faster as well): 

HashMap has some really nice things for efficiency. Just as returned an in the previous point (which rendered the part superfluous), can use the Entry API to do less work: 

The name should, under Rust conventions, be . The macros could be written as private methods, and I tend to think that they’d be clearer thus. I would expect them to be inlined automatically, but you could mark them also; because of inlining, there will be no performance difference to the macros. wrapping is only needed to provide indirection so that recursive data types work. thus needs it, but doesn’t. Your implementation could (and thus should) be replaced with . You check if , but then report as the error that universe size must be > 2; the clause, however, would correspond to > 1. Now, concerning the equation; for starters, should be written as —superfluous parentheses hamper reading. But there is a more significant issue at stake: the actual equation being calculated. The comment gives this equation: $$2^{floor\left(\frac{log_2 x}2\right)}$$ But the code calculates this equation: $$floor\left(2^\frac{log_2 x}2\right)$$ These give quite different results; the comment would yield only powers of two, but the latter will yield all integers, and might as well be . I feel that would be clearer as , seeing as has already been asserted. In : would normally be nicer written as . One less indentation level, and a more natural way of expressing it. In : is being called quite a few times; it feels like it should be possible to remove some of them, but I haven’t thought about it much at all. 

Everything looks good enough. Code style is OK. You are using , so it will be quite fast and there is nothing you can do in the code to speed it up. You may or may not need to check this: 

I don't believe the code works as expected. One of us for sure made mistake with . If is me, comment so I can fix the answer. Code style You will have better readability, if you indent everything inside the class. You need to work on statement in . I can not read it at all. I personally would do it on single row, but then many people will not like it at all. Constructor - I do not see where you need this? You initializing the static fields every time. 

What is the doing? Is this because of incomplete . comment - remove , use or . helps the optimizer a lot to speed up the code, when class is known. - I think you need to check somehow for it. Probably in . Fraction.cpp prefer initialize list: 

Also move this into the .h file. It is so short. destructor Your destructor is empty - remove it completely. default constructor in ListNode default constructor in ListNode is empty. You can not remove it, because you have one more constructor. However if you have C++11, you can do: 

Please note, many people (me excluded) will not like in the middle of . Anyway if you do it this way, readability will be much better than with . 

depends from where this comes, you probably need to sanitize it somehow. see (1) In same place you overwrite the . see (2) You probably want this: 

Finally, if you have C++11, you can clean up things some more, including you might remove constructor and use default generated constructor. 

return 0 from main() In latest C++, from is optional. Since is there, do not remove it. const method 

Use private where needed I believe must be private. insertAtEnd() I might suggest you use instead of . What will happen if list have more than 255 elements 

I would even move it to the file. skipping for now Integer.h same considerations for the and . Initialize the value to zero. If you do so, you can ommit initialization of . once again doing nothing. this time you can remove it. Display.h remove and . on all your code, you use . now suddenly you switch to . Why? Answer is - to make more ugly :) main() Do you think there will be exception thrown? is deprecated. If you are using , change it to . Make to be . You really not need to write it several times. 

constructor class member "initializers" I may be using incorrect term, but constructor better be like this: 

I agree with Loki, but hare are some more things: Destructor I do not see the destructor. What happen when you destroy / the class? Answer is huge memory leak. You definitely need to have to release the memory and prevent memory leak. If I read the code correctly you need following or something very similar to: