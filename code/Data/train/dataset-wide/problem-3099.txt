ahhh, I see skiwi just answered a bunch... I'll cover some other stuff from here on.... Reiterating his comments: 

The says "Look in the string for a sequence of digits". The method loops through all digit sequences, converts them to integers, and totals them. 

With any Java Writer or Stream... YOU MUST PROPERLY FLUSH AND CLOSE it. The documentation is not fantastically clear... but: when you exit the method, you must ensure that the file is flushed and closed. you are exiting your program before the data is written to disk. Always use the following pattern when doing IO (if you are using Java7) : 

I think this pattern of creating an instance, running it through the loop, and at the end of the loop re-initializing it, is a bad one. This case is a good example of what can go wrong... because you have introduced a bug as a result The first time through the loop your is configured as: 

Your is a List. The Linq query to get the chunk with the right coordinates is going to scan the entire list, and check each chunk. This is a linear process, and the performance depends on the number of chunks in the list. As the list grows, the performance decreases. The solution is to index the chunks in a way that makes the lookup performance a constant-time operation (not dependant on the number of chunks). The logical data structure for this is to use a Dictionary, and key the Dictionary on a value that is the coordinate. Thus, given a coordinate, you can easily find the Chunk. Your chunks are indexed using int values for the X and Y coordinate. I would recommend using a long-value as the key, and to simply shift the X and Y coordinates in to the Dictionary... for example: 

... and then follow that same generic method in to your inner methods It is complicated. There is some reference material here: 

why throw an exception for an empty array? Why not return null? you have not followed the instructions correctly... it is impossible for a 0, 1, or 2 element array to actually have a peak, since there is no or to compare against. Additionally, there is no peak in cases like , since the 2's are not peaks, and the three's are at the edges. your first if conditions are and , and those are just messy.... your should have a recursion-terminating condition and not spread it around in the method. I am a pragmatist about OOP in Java... Objects are great, I agree, but there is no reason to have an instance for this code. A static method passing the input array in would be fine....: 

I think that you have confused yourself with your code, and the way that data structures are intended to be implemented. What you have done that is unconventional, and causing the confusion, is that you have exposed the Node class as a public class, and you have a constructor that takes Nodes as input. Node is normally an implementation detail of a data astructure (your KDTree) that is transparent to others. Consider Java's LinkedList, that has Node instances, but you never see those Node instances, just like ArrayList has an internal array, etc. Your KDTree should contain the Node class as an inner (nested) private class, and the users of your KDTree should never be able to see/access those nodes. Your KDTree class should abstact that interaction away. The constructor for your KDTree should be able to construct off the base values of the node, or be an empty constructor, and have an add method that takes the base values. Consider something that looks like: 

it is synchronized (so you have to do a whole bunch of memory management) it does IO (accessing buffers and other OS resources). it flushes the streams it does string manipulation 

Index the column with Maintaining this static data in a function would be a poor use of computational power, and make indexing harder. Your function would thus become: 

and two variables to contain the previous char and the previous char count, you could just go through each character in the string, if it's the same as the previous char, you increment the count. If it's different, you add the previous char and it's count to the StringBuilder, and reset the previous and count to 1. Then, when your loop is done, if the StringBuilder is smaller than the input, return the StringBuilder version. This type of compression is called 'run length encoding' by the way. 

The basic algorithm you use is logical, and well presented. The general style is standard, and I see no issues there. I believe the algorithm can be changed slightly to make the comparison code simpler, but the performance will still be comparable. I looked for edge cases I would have expected, specifically relating to large differences, but you appear to have covered that well. Unfortunately, your pair-counts for are all off. For example, your third test case: 

the (renamed to partition) should construct an int[] array as a stack. It should then call the recursive method. the recursive method should only construct the String value for actual results, not intermediate results. rename the variables (and methods) to be more descriptive. used 'final' where I can to show what variables cannot change, and it can help with the JIT Optimization. 

This is a bit of a pre-Java7 cheat I use. It is safe to close the inner stream, and let the outer Readers (BufferedReader,InputStreamReader) not be explicitly closed. In Java7 I would put them all in a try-with-resources, but, Android, alas!. With the above code you don't need to worry about closing the stream at all inside the try block. OK, so now the try-block is simple, I would put two conditions (the readLine first!) in to the read-loop: 

When you test the root, you will determine that both sides have the same height, yet, the tree is far from balanced. 

and suddenly your employee has aged... a lot. What the oracle documentation is saying, is that, if you have mutable content, you should return a copy of that data. This is often called a 'defensive copy': 

With the above variable changes (and the change to the indexing of or , your code is much more readable: 

Finally, I did not like the method you chose as the core await container... Instead of the I prefer the . I cannot defend that preference right now though. Not sure why I prefer it. Still, having thrown all that criticism at you, here's how I would probably do it. Note, the logic change for the await.... You have a single static lock. What I suggest is to create a 'completion listener'. In the case of awaitAll, each Event has it's own listener. In the case of awaitAny, they all share a single listener, so there's just one notification. The system below makes each an independent operation. The only signals are what's happening that's relevant to the completion service. This is untested, so go through and understand it well ;-) 

You can add methods for other features you need, as needed. Note, that having abstracted/encapsulated the underlying data store mechanism, you can easily replace the array/deque with a Map now, and not notice. Edit: to add in the combined constructor/index problem, a solution like this may help, adding the method: 

in the normal course of events, every get, remove, and put requires a 'readlock' to be held for that operation. This significantly reduces the amount of concurrency available for the store. Actually, now that I look at it, the implementation uses a ReadWriteLock, but there is a bug, and even the 'write-lock' is a , so there is no effective exclusion from the process. If the lock was implemented right though, it would still require a full lock when the 'replay' was performed. even when the system is not having a snapshot taken, the overhead is required to conditionally manage the data load. Using a Strategy Pattern we can improve that, by having one simple strategy that is used most of the time, and then a more complicated strategy that is only used when performing snapshots. Using the mechanism of ConcurrentHashMap is overly complicated, and has resulted in the degradation of generic typing to raw types, and is a problem. 

Double.parseDouble throws the unchecked exception . The exception thrown does not give great deals of information about why the number is not valid. I always recommend wrapping Double.parseDouble (and , etc.) in a try-catch that reports what value was parsed, as well as the exception that was thrown. Otherwise debugging is a pain. I often have a helper function like: 

Your code here is hard to follow because your code style and format are inconvenient. Structures like this: 

Now your GenQueue is a Queue (java.util.Queue) and it is also a List, and it supports all the features that are already embedded in those implementations.