In other words, must return something that was pushed onto the stack (or an error, but that's an architectural issue not a principle of computer science). Architecture Strictly speaking could return a void and write a message to the console, but it is conventional for it to return something of the same type as the top element of the stack - in the case of reference types, the question of whether it should be a copy [and what type of copy] or a reference to the object itself muddies the waters. The current implementation of points to a larger architectural issue, a low degree of modularity. Currently, user interface is spread across the code and the stack data structure even writes messages to the console. The effect: 

Having as a property of a node feels a bit like a leaky abstraction because it embeds the needs of a particular tree operation into the more general abstraction of graphs and nodes. To me, a node is a data structure that has some pointers to zero or more children and perhaps stores a value - depending on the semantics of a particular graph. Consider an acyclic graph with all values at stored at leaves versus various cyclic graphs with values stored at each node. In the cyclic graph case depth first search is not directly applicable until an appropriate starting node has been selected and though the concept of may make sense for some cyclic graph algorithms, it wouldn't in the case of other algorithms such as Dijkstraâ€™s shortest path. To separate concerns, a depth first search algorithm might create it's own object consisting of a generalized node object and a field...or use any of many other data structure approaches. Without isolation algorithms operating on the graph must walk it a second time to clear the field. If there is concurrency, then graph algorithms must lock the entire data structure and the depth first search should have transaction semantics. 

Specification It is helpful to specify the solution before writing code. The mathematics of sorting three values means there are six permutations: 

It contains three functions {, , } which take a number and either return that value or an appropriate string: 

Because less code is often easier to understand and might contain fewer bugs...at least those tend to be reasons given for using high level languages since the days when assembly was considered high level and compared to raw machine code it was. Trust and Verify(maybe) Idiomatic Scala will rely on library routines such as rather than reinventing them. Mainly because the odds of a random Scala programmer writing a better implementation are approximately zero. Even those who possibly could will not unless there is a verified performance issue and the bottleneck is in the sort. And then it's probably time to look at JVM Bytecode instead of trying to get more efficiency through the Scala compiler. Advice 

Semi-Idiomatic Scala The first thing to accept is that regardless of how idiomatic the code, the underlying computer science must be expressed. Due to its design as a transition path from Java's traditional imperative style, Scala allows for programming that falls in between purely functional and entirely imperative. A simplifying abstraction (used in the question's code) is to reduce the stack data structure to a single integer, then and become: 

A little less worse, but still a potential source of cognitive overhead for the programmer using the function: 

Efficiency Because the graph is undirected, the adjacency matrix can be represented in space if there are no redundant edges, i.e. matrix is triangular. A one dimensional array with accessors could serve as simple data structure. As you probably know, if the typical graph is sparse, then an adjacency matrix may be space inefficient and an Representation 

At an arbitrary iteration some may lead to states already visited and Odersky's approach trims those. What it doesn't do is capture the semantics of bags to trim the search space. Consider: 

Hard coding a magic number for stack size has code smell. Stack semantics derive from automata theory. As an abstraction, stacks do not have a fixed size [of 16 or anything else] and cannot be filled only emptied. An object oriented implementation should perhaps reflect this at the top of the inheritance hierarchy to avoid conflating implementation details with stack semantics. When it is necessary to implement a stack of limited size, consider taking size as a parameter to the constructor not hard coded as a magic number. This will allow greater code reuse and more clearly separate implementation dependencies from the higher level of abstraction. Finally, why not implement stack as a list? Example code: 

Other Strategies An empty board has zero probability of being a solution. This is lower than a board with a queen randomly placed in each column. Though the probability of random placement producing a solution is slight, it is better than an empty board. Gradient Descent Starting with a randomly populated board, an estimate of the distance from a solution is made. [1] Next each alternative position for each queen is examined and an estimate of the distance from a solution is made for each resulting configuration. The one move that results in minimizing the distance from the solution is made and the process repeats. When no improvement is possible the solution may be abandoned [2] and a new random board generated. Generating and examining random boards is parallizable and typically done because the number of boards examined is often large. [1]: Choosing how to measure the distance is art informed by science, not pure science except in so far as recognizing that the problem of measuring is still in NP. [2]: More complex approaches may not always chose the configuration closest to a solution and/or backtrack when no improvement is possible. Again, optimization is based on understanding the particulars of the problem. 

The other diagonals in the other quadrants can be generated from the worst case diagonal for Quadrant I (northeast). Technically, the transformation can be seen as either a four-fold rotation or two mirror planes. I thought that rotation seemed easier. 

Make the code more modular by removing tests from the production logic. Delete dead code. Consider using version control to maintain historical investigations instead. Consider writing an overall description of the program, so that anyone reading it, including yourself a week from now, can more quickly understand what the code does and how it hangs together to do it. Consider better names. 

From the README.md Introduction: The purpose of is to read all the lines from a text file and return the file's contents as a Clojure value in a standardized manner. Specification: Takes: 

The last piece is to undo my arbitrary choice of origin. It boils down to a simple 2d translation. If the bishop is on square then the equations become and . 

Double Loop Looping over the array lists one at a time creates a compositional type dependency that could be abstracted as . As way of illustration: 

The test is true when the inductive base case is false. The action on the base case comes at the end. 

and there is no functional requirement to store or pre-compute all the permutations. Any non-functional requirement such as performance may be addressed with a non-functional solution such as memoization or caching. Iteration Mapping to is an operation from one constant to another constant. This mapping can be represented as a function . We can get any member of as by where is the corresponding member of . This means that we can iterate over the entirety of simply by constructing . The good news is that this means we are no worse off spatially when we construct than we were with . The bad news is that we are no better off. The Bad News Permutations are in NP and the only way to get back into P is to know something about: 

Code Clarity The code is hard to read. The more that the names of items in the code reflect the way we would label the pieces of the problem domain [mathematics here], the easier it becomes to reason about the way the code implements the problem. better expresses the mathematics than . And though I know does something, but it's not obvious what. is better. is better. Final thoughts Giving things meaningful names helps a lot. seems like more work because it is more typing [by 8 more keystrokes]. But it's a false economy because debugging and refactoring code for speed is orders of magnitude more difficult than banging on the keyboard. 

is always because something is either or . An can't be because is always an . More importantly, none of this makes it any easier to reason about how the code represents or solves mazes at the high level of abstraction or about how the code works at the level of and tuples of s at the lower level. Readability Structural decisions and the choice of abstractions make the code difficult to read. Writing zero comments should not be considered a feature. Modularity The absence of any modularity makes the code difficult to follow. Simply breaking out the tests would significantly improve readability. Scala has a common idiom for modularizing code: . There are practical alternatives available from other JVM language communities. Leaking Abstractions A maze declartion should be purely declarative. It should define the geometry of the maze in terms of walls, levels, chutes, ladders, dragons, etc. A maze object should have an API that answers two questions: 1. Where am I? 2. What do I see? It should initialize with a maze definition and a goal location. A maze solver should intialize with a start location and a maze object. It should reach a solution state based upon querying the API of the maze object. It should not have knowledge of the maze geometry, the goal location, or the solvability of the maze given the start location. It's supposed to figure all that out. This means a maze solver should build an internal representation of a maze based on what it finds. It has to do so anyway to maintain its search space, so even though it sounds like more work, it isn't. Decoupling the solver from the maze declaration and an instantiation via a maze object makes it more general - e.g. it could operate over the wire to a RESTful endpoint. Specification There needs to be a specification for maze declarations. The important issues are: 1. How many degrees of freedom exist for movement? A 2d rectangular grid might allow four or 8 depending on whether moving diagonally constitues one move or two. A 2d hexagonal grid would allow 6 directions of movement. 3d grids allow additional options. 2. What is the language used for maze declarations? Names Variables and constants should be named to reflect the business logic of mazes. The model should be tied to the language of mazes: