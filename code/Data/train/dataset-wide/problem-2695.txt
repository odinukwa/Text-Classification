Now we can build a Traverse class that implements a generic method which is generalized and can be applied to any part of the tree and with any thinkable predicate on activity object (passed as a parameter). 

Update As @Gerrit0 suggested, is a better option than (more concise and achieves exactly the same result). 

Minimize component state It's better to use a single field rather than having a field per each list. You don't have to change anything in your template if you wrap the around using accessor syntax. 

Caching Pattern I commonly see the following pattern for "caching" observables in various code bases: 

the is now responsible for holding the data related to the specific Question (both, question and the list of answer with corresponding behavior). This is not really the "Strategy Pattern" yet, but it is a first big step towards it. In Strategy pattern you normally do not mix the data and behavior in the same class, but rather separate them. We declare a property that will hold the important dependencies (aka Services) that are required for a given Card to do it's work in answers' actions. This allows the card classes to stay regular TypeScript classes instead of being declared as services. This also means that the with the services should be provided from the outside. In TypeScript we can use the to enforce client pass in the context. 

Instead of that I decided to use a more dynamic, queue-based allocation technique. The 0th element of the array is reserved for a virtual index-pointer to the next available memory slot. Next to any stack will result in data insertion to the pointed virtual index. The next elements of the array are reserved for a virtual index-pointer per stack. These are basically saying where the certain stack's head is. The rest () array indices are used as a virtual space. The very first index of this section will have a "physical" value of , and a "virtual" value of . The next virtual index () has a physical value of , and so forth. This is because a single virtual index consists of two physical indices. The first value is dedicated to a value hold by the stack entry; and the second value is a virtual index-pointer to the next element in the stack. The illustration below should help understand what I am trying to say (in case the description is too vague): 

I'm not really into Neural Networks, but I do read code and I do have some suggesting for what to do next related to this code. Code and Style Comments – Since you keep increasing the whenever this method is called, you'll run out of array elements to update, and will finally trigger an index error. In the same code, you'll only once when the exactly equals the preset number of inputs. So if the input of a changes afterwards, the network is never updated. Neither of these seems to be correct. Always generate even when not over the activation value? – In light of preceding point, it seems kind of strange to do the sequence, as that might for some networks trigger the index error before it should. Wouldn't it be better to leave out the no input part? That is, unless that is a requirement due to the value swapping from over and under the during the lifetime of the network, in which case you really need to address the case of connecting inputs to the Neuron receiving the input. Why delay the summation of inputs, and the value – In my mind it would be better to update a and the value whenever receiving an input, instead of when doing the . Imaging having a network of thousands of nodes, and you having to calculate this for each fire event you trigger, even though the input possibly didn't change? To me it makes more sense to do this within the having a variable, and to have a class variable (or method) holding (or returning) the . Do however know that this would require proper knowledge of which input is being updated, so that if you receive a secondary input on that you'll correctly adjust the sum, and not blatantly keep adding the new value. Order of calculation and output – Most likely your should be replaced with a call to some logger, but I would also put this one in front of the loops. As it is in a bigger network you would get the output of the latter nodes, before the first nodes. For the output to make sense, it would be wiser to have the output directly after the calculation of . 

Specify types explicitly whenever it's possible (including for methods and for instead of ). Use instead of -- it will help detecting unintended assignments. Try not to move things around when it's not necessary. E.g. the following section is pushing one array's items into another. 

Why Deal With Indices In Loops? The last map function can be rewritten the way that does not require manual counters/indices manipulation. This is very typical for functional programming. This approach helps making sure that there's no chance for the infamous OBOE. 

I am going one-by-one through problems in the "Cracking the Coding Interview". This question is about problem 1.5. One Away. Since I was never good in "algorithming", any suggestions are highly appreciated. The very best thing you can do for me is suggest a better approach instead of the "straightforward" fragile code I wrote. Oh, and since it's pretty much an interview question, performance is important too. The solution I got is -- bound by the length of the longest string so far (which can be easily fixed by early exit when exceeds ). Code 

@demrks please take a look at the code below. It's a result of multiple refactoring iterations. While the original code does the job, I find it very hard to read. Hopefully, you agree that the improved version reads better, even though there's very little new in it. Many developers including myself believe that readability is a super important aspect of coding because it directly affects complexity, and thus correctness of the code. Here's the list of techniques I applied (in order of importance as I understand things): 

Example of class The following example is a simplistic implementation of part of the class. class MakeKing(Creation): """Wrapper class for the makeking command, starlab v 4.4.1. 

Not sure if I understood your concept, but you get the gist of it. Simplify to a point where it is easy to understand what any given method does. Move stuff which is not essential to a method into a submethod, i.e. the coinflip stuff. 

The idea is to have enough specific typical words in either list, so that it eases detection of the language. So how could this look in an alternate version? Well, here is some code for you to work with: 

Note that contrary to this function returns the average of the 3 fastest times (i.e ) and the slowest time. And if you want the other times, you can uncomment corresponding lines from bottom of the function. For me these two times are the most interesting, as the max time indicates if there are cache effects in play, and the bottom 3 averages out load on my computer a little. Also note that the code needs to have in order for the magic join in the last print statement to work properly if you use it in Python 2. Conclusion With these three variations I'm now able to have the following code at the end of a review script: 

Edit: As suggested by Joe Wallis, I've changed the into a set to speed lookups. Do note, that this (as the rest) is still untested, but Joe Wallis should be correct that this specific lookup should then go a lot faster. And Joe Wallis is also correct in his answer that printing does take time, so you need to consider whether it is worthwhile to actually print inbetween each operation. I think I would keep it for a little while as it clearly indicates where you spend your time, and compared to read/writing files the time to print should be neglible. 

This is a really good question -- starred it! I am not very experienced with RxJs, but I believe your code around and is as concise as possible. itself is "subscribable" (just like an ) but it's a really bad practice to expose it directly to the consumer, i.e. your separation of and is a right thing to do. Exposing is okay because it's designed to be read-only. is inevitable in your code, unless you decide to keep the usersSource state as a local field, but IMO it does not do any good in this scenario. Having state to be stored as a part of the is handy. 

First we declare fields to iterate on. Clear validation error indicators set on previous runs. the fields which fail validation. I am not sure what is the '?' that original code relies on, but I think you know better ;) If there list of filtered fields is empty, we know there are no validation errors and can return from here. Otherwise animate to the top of the screen, display UI errors for failed fields, and return false. 

Manual field copying in 's constructor (from the definition provided) seems silly, especially knowing that IS a : 

DISCLAIMER: I'm not very familiar with Redux. In my book triggering requests based on request completion is business logic. (Or even more generally: triggering "something" based on "something else" is business logic.) If something is business logic, I'd rather make sure it is implemented somewhere in my reducer, rather than a service. So, either the or its would emit a proper action ( in this case). 

I haven't installed Pythonista, yet, so I'm not able to test this code, but hopefully it should work nicely. 

which needs a little change to the function as I've added some groups, and changed into non-capturing groups for some of the others: 

Sorry for terrible naming, it's just something I threw together, and when I ran it using $URL$ it gave me the following output: 

I'm almost sorry to say, that it feels like you are naming things just because you can name them according to some coding principle. Calling a named tuple OOP, is stretching it very thin. Yes, it encapsulates something but it doesn't have any options to do actions on the object, and it's not a very good use of it. Could possibly use OOP if you used inheritance for the human player and the computer player incorporating the choice logic. But then again, that would ruin your so-called FP approach with lambdas and storing of functions. Which again is stretching it rather thin, as you don't use a functional approach avoiding state handling and mathemical functions on lists. So in the end it is mostly imperative programming, which most paradigms ends up with at some level deep within. And it's imperative programming with a very slight touch of OOP, and a very slight touch of FP. As this however is Code Review, lets add some review issues as well: 

I tried compiling a new version using the online compilator at $URL$ but there was loads of errors and it seemed a little unstable. In addition, when trying to get information from OP regarding how you actually are running your code, and expected output, I didn't get much response. As such, I've failed getting you alternate refactored code better implementing a type dependent state machine in Idris. 

Readability first. If it's not readable, it's broken. Performance. Yes, it's compiled into JavaScript. Yes, JavaScript is "slow". Point is, this code is just an exercise and will never get into production. Said that, I don't want it to be unnecessary inefficient. 

You may not be ready or want to jump into @jasoninvegas' state machine proposal, but you should consider it among the alternatives you have. As the very first step, I'd recommend looking at plain old extract method refactoring... 

does not seem quite right to me, because it will work funny with falsy values. It's better to rely on , or depending on the way you want it to work. Example: 

P.S. I apologize in advance for using strong words and for my way of thinking potentially misaligning with the coding standards of your organization. I'm not questioning your internal agreements of course, but rather trying to analyse and evaluate the code as a "spherical cow in a vacuum" from a perspective of the developer on the Clapham omnibus (who obviously can not jump as high as you can). P.P.S. This is the great question and the code to read/think about! 

It took me a while to understand the way works in its current implementation. I even thought that there's a bug (after rereading the code, I see I was wrong about it). 

There are minor style things that could be improved in the code, but that's unrelated to RxJs, so I'll not comment on that. 

Feedback I am looking for Here's the list of things I am interested to hear back (in order of significance):