I use a different approach: I have created a class similar to std::ostream_iterator (see the utility functions at the end of the code for example use): 

Size of a string cannot be measured accurately by an unsigned int (at least not portably or in all cases). Safe alternatives: 

Yes. You can remove the difference between association and relationship, and define a single concept ("connectable object"). 

The visitor pattern allows for the implementation of external polymorphism and double dispatching. Depending on where you are getting the design pattern documentation from, it may make for a bad implementation for C++. The Visitor page on wikipedia for example, states you need a base class for the visitor, defining virtual entry points for the operations. This is true for Java for example, but not for C++. For a more flexible visitor in C++, consider the use of functors instead of base visitor classes, not defining all visited classes in the same hierarchy, and using type erasure (through std::function) to hide away the differences in the functor types. This provides you with a degree of flexibility that other languages usually do not allow for: 

You make your code more self-descriptive. your Socket class Your class suggests an other meaning, than it provides. It should handle the sending and receiving without the need, to specify the explicit. The user shouldn't be forced to pass the themselves. That's up to the class, to provide the correct socket (at least you are holding a socket as private member). Think about that, perhaps your class has simply the wrong name for its purpose. use instead of heap array You are using a heap array as a read buffer. This yields exception errors, and it isn't totally clear (at least for the user of the Socket class) who is responsible for the cleanup () of this buffer. It is never a good idea, to hand back a pointer, and let the user cleanup the stuff by themselves. Instead, you should simply return a . That's clean, smart and has no hidden traps. If the user decides, he doesn't need the buffer anymore, he can simply let it go out of scope and it will be deleted automatically. The problems are even bigger, when an is thrown by any part of your framework, the users code or any other part of the program. If you want to pass ownership, use the provided classes. For strings it's , for every other point it is or . When you think, "returning a char* has better performance than returning a ", that's not totally true. Most of modern compilers can optimize that. You should google for "" (). In it is guaranteed, but in or it might fail. But even in that cases, a simple move of the happens, which is not as bad as it sounds. 

The gain in readability comes from the result type being explicitly specified. If you have APIs that only work for non-const pointers when they should work for const (this is the most legitimate use for const_cast) you should wrap them and centralize/localize/hide the call to const_cast. If you find yourself writing const_cast calls again and again, the problem is not poor readability of the code, but bad API design. 

There are probably other factors making the code easy to crack, but as I said, I am not a crptographer. 

Yes: First, the if-else if-...- is big, difficult to maintain an monolithic. Consider replacing it with a hierarchy of classes and allowing your function to do simple dispatching. (also look for my comments in the code below): 

Use C++ not C First of all, you are making a lot usage of C, not C++. In C++ you either use the keyword class or struct to declare a class/struct, not together with the keyword typedef. You are using uint32_t a lot. This is also C style, the proper C++ style is the std::unit32_t type. But most of the times you don't really need to specify the width of your integer directly. This only makes sense if you want to serialize/deserialize them. Use new and delete instead of malloc and free. Better: use smartpointers like std::unique_ptr and std::shared_ptr. declare properties private (encapsulate them) The problem here is, you are using public available objects inside of the IMAGE_STRUCT struct, which can be modified from the outside. split-up your functions Your atImageEvent function is huge! Split it up into smaller parts. name conventions There are no explicit name conventions at all, but you should not declare your classes/structs with only capital characters (like IMAGE_STRUCT). Most of the times words with only capital characters are macros. It's not a mistake rather than a bit of taste. if I am not totally wrong names beginning with _ are reserved by the standard and should not be used for custom code. To be honest, I am using them by myself, but I think its worth to mention this. undefined behaviour 

(bno is probably the only one that should be commented; the other two are obvious) use dependency injection for and . Example old code: 

Since the function takes a unique_ptr now, you now know you need to pass a pointer and you also know you are passing ownership as well. 

Note regarding class API design: You are implementing both a node (for an element of the list) and a list of nodes. You should have two classes instead of one, and the pointer should be a member of the list, not a node: 

Normally, you should use the most specialized type for a job. In , and should be declared as . uses a big, monolythic switch. Consider replacing it with a dispatch map (extract cases into separate functions, then create a to map these functions to separate inputs). You should not have the entire code in a single file. Instead, you should have each class in a pair of files (.h for the declaration and .cpp for the definition). This would allow you to remove the huge separation blocks. Old code: 

I prefer over , because it enables the possibility to create the objects inside the vector in place instead of copying. use the parallel std algorithms In the end you could simply use the std::transform overloading for ExecutionPolicies rather than writing the stuff yourself on the base of threads. Have a look here. 

You are running into undefined behavior here, because you are reading from a union property without writing to it first. Unions should not be used to convert types to each other. It is not safe! I am sure, the code doesn't do what you expect. Your code says, you are converting a uint8_t pointer to uint16_t integer. You are not accessing the data, just the address! 

Actually, it is very efficient, because it uses move construction and/or ellision (returning by value shouldn't cost much - if anything, since c++11). 

I wouldn't use it; It is basically copying/generalizing the functionality of a scoped lock (alter another object's state, while in scope) - and I would prefer a simple RAII wrapper for that (because it's expected, straightforward and doesn't write code using macros). 

Other stuff: Use instead of zero. Either make the class final and the destructor non-virtual, or leave the destructor virtual and remove the assignment operators. Having an assignment operator in a base class leads to getting your objects sliced. 

For learning RAII/resource management, it's a good idea to write your own smart pointer class. For production code, use std::shared_ptr, std::unique_ptr, or boost smart pointers (if you have to). Here are some notes on the code itself: 

Most of the points are already mentioned by others, thus I will only tell you my opinion about the missing ones. I don't really like your function. You obviously know how to use , why don't you simply use them for your purpose? It all boils down to something like that: 

In the end I did not review the correctness of your code, I just stepped over the obviously mistakes you made in your code. 

don't use You should not use because it eliminates some important information, which may lead to some conflicts with your classes or classes of other libraries. It is not uncommon to have a class, which has a totally other meaning than the . And to be honest, it isn't that much more work, to type in front of the classes/functions, is it? use You do everything with for loops, which is bloated and error prone. Use the algorithms of the namespace instead. I provide you with a short an clean example, how you could do the above task (and more) with less lines. your algorithm itself You should think about logical improvements. Is it necessary to store every score in a vector, when equal scores produce the same rankings, and the following scores just increments by one? Therefore I took the algorithm, which returns a . doesn't erase anything itself. It just moves duplicates to the end of the range (our ); you have to them manually. But, before you can use you have to order your elements. I don't know if it's guaranteed to get the score input in a descending order; thus I simply use to ensure this. After that, it's a simple (which is a binary search instead a linear search) to get the first iterator to an element, which is not less than the provided score (ok, I had to pass an other function object, because we want to check for greater and not for less). starts with a zero index. This means, we have to add 1 to our index, to get the official ranking. Easy, huh?