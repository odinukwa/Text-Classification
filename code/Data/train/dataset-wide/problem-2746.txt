I assume is some kind of way to print debug/info/tracing messages. If so then this is not a good name for the function. Better would or similar (depending on the exact purpose). There is this magic method called everywhere but it doesn't seem to follow any particular pattern. Seems suspicious to me. 

The way you handle exceptions is less than ideal. The caller of your methods has no easy way to find out if the call actually succeeded or not - except for parsing the return value of the method. A better way to deal with it is to let exceptions bubble up to the caller and let the caller decide what to do (e.g. terminate the process, retry later, etc.). In addition you could log the exception (requires passing in some kind of logger) Alternatively you could make the return value an parameter and return a indicating if the call was successful instead if you really want to hide the exceptions from the caller. In this case I'd rename the methods to something like and 

C# uses PascalCase naming convention for method names. It is accepted practice to reduce indent with multiple blocks like this (in cases where no additional statements have to be executed in the outer using block): 

returns a . You probably want to wait until the tasks you have started are finished before you quit from main which you can do with . Something along these lines: 

You should make this a method on which you can call when needed (which gives some purpose back to ) I would consider a design along these lines: 

Your method will break the stopwatch because you create a new timer but you do not re-attach the timer tick event handler. You have a method which sets up the timer but you also do this in the constructor which is some code duplication and in fact has introduced a bug (see previous point). DRY - Don't Repeat Yourself. Make use of a common method which can get called in both places. Instead of "polling" your stopwatch in a continuous loop your should expose an event like to which any interested party can hook up to. In general this can pose problems when interacting with UI because if the callback happens on a different thread then you need to marshal UI access across to the UI thread. However you have used a which is evaluated at the top of every dispatcher loop - which means the callbacks are happening on the UI thread and it is safe to access UI elements from within the callback (see the MSDN example). So basically you can expose an event which gets fired on the timer callback and whatever code hooks up to it can update the UI. In general MVVM has established itself as a very useful pattern. Which means that rather than updating UI elements directly you would update an observable view model to which the UI is bound. This decouples the UI better from the data and decoupling is always good. The timer is guaranteed to not fire before the interval has elapsed - but there is no guarantee about how long after the interval has elapsed it will fire. This means your stopwatch will start falling behind the real time as you assume each tick is 1 second while in fact it might be 1.01 sec or so. This means after 100 seconds you could be easily 1 sec off or more. A thread time slice in windows is typically around 10ms so I'd suspect the timer to be around that accuracy. Although on Windows Phone you might get better performance (couldn't find any documentation in that regards). The way to overcome this is to take a timestamp at and compute the difference to the current time on each tick. While this will probably also give you an approx. 10ms accuracy it will be constant while your solution will accumulate an error on each tick. This will also alleviate the need to compute the seconds, minutes and hours since passing as you can get that from the . 

: Printing the list in reverse order recursively is an academically interesting solution but if your list is sufficiently long then your stack will explode. Use a to temporarily store the elements and then print that. : Currently this is O(n) because you iterate the entire list to find the last element. If you store a pointer which points to the last element in the list in addition to then you can avoid that and this operation becomes O(1). : Keep a length property in the class which you increment/decrement when a node got added/removed. Again reduces an O(n) operation to O(1). : 

Right now the programmer has to remember whether a node was added via or in order to call the proper delete function. However this could be solved by having a flag in which indicates whether the node owns the content or not. Delete could then automatically do the right thing. 

Note: I have taken the liberty to remove the static from all fields and just return the of the list rather than keeping track of the length separately. When serialization requirements get more complex it can get problematic but for simple stuff it's hard to beat. Sample XML file: 

The and methods are identical (unless I missed something). Not sure if this is a bug or intended behaviour but if it is intended then this should be extracted into a separate method so it can be called from both actions. From my experience it is very rarely required to use the enumerator interface directly, like you do in your methods. Those can be rewritten to: 

In your implementation as it stands you do not need the variable. You can simply return when you have found the line: 

You should get rid of the suffix. There is no value in attaching the type as a suffix to the name. You don't need to write everywhere to access members. You have an property which is not used. 

So train yourself to write well structured encapsulated code even for seemingly simple things because it will form a habit. Even if you don't want to develop software professionally in the long run you will find it more rewarding when you do it right. 

Not sure if that is just the case in your example but it's rather uncommon in C# to prefix classes with or . In fact the only commonly used type identifier as part of the type name is usually the prefix for interfaces. Method names in C# are usually naming convention. is used for local variables. Not entirely sure about the whole structure of your code but to me it looks like you should be able to easily move the code into a separate helper class like this: 

If is what it sounds like then the name for should be . What does return if there is no prime within the given bounds? 

should be equivalent to Your loop is one based for some reason but inside the loop you have to subtract 1 from everywhere. You should just make your loop 0 based which would de-clutter the loop a bit. I would find just as descriptive a name as . You could get rid of the by calculating the position: 

Changing the input file seems dodgy to me. The Unix way would be to write the "encrypted" output to . This way the user can choose what to do with it (redirect to another file or to another program for example). 

As the standard naming convention for local variables and parameters is an established practice is to prefix private class members with although using instead works as well. Matter of personal preference I guess. You can remove some in-code comments by creating helper methods which state what they are doing. For example instead of this: 

is just a hint to the compiler which is free to ignore it anyway. Typically you should only use it in specific circumstances when you know if and why it is required. Otherwise it's just adding noise. 

Your view models should be implementing . This will make it more obvious that your models will raise property change events. Also the WPF binding framework checks if a class implements this interface and makes use of it if it does so. Standard naming convention for C# is for method names (private or not usually makes no difference) 

And in the future if you want to filter entities by you create a with a method which you then can use as 

I'd use (LINQ) to obtain the maximum. Less code to write and does the same. While it is ok to use single letter variables for loop counter is not really a loop counter. It's the index of the current element so I would rename into . Consider changing your last while loop into a for loop. This avoids mutating the state of the array (saves you a read and write on every iteration): 

You are doing a lot of parsing and re-parsing by passing everything around as strings. This is not really a good way of doing it and also very inefficient as you are constantly throwing away information and having to reconstruct it via parsing it out of the string. Here is how I would split it up: 

This reduced the function from 365 lines down to 100 lines, not bad. Now we can see that the block asking to re-roll die X are basically also all the same except for the die number. Now let's store the value of the rolls in an array which holds one entry per die. And because this is C++ we are going to use a 

You should only use single letter variable names for loop variables. Parameters and other local variables should have more descriptive names. For example when I first quickly glanced over the code I saw this and thought "Strange, why is he passing in two nodes?" associating that has a similar meaning to . I had to look again before I realized that is actually a map. Using names like or would result in easier readability. does not print the tree and should therefor not be named such. It collects all nodes on the same level. Better name might have been apparently expects that the elements to be inserted are in order. You swallow the error case by simply returning a . You should throw an exception instead to make it clear to the caller that this is invalid input. You represent a binary tree by a reference to a node which happens to be the root. However if the caller accidentally replaces it with a reference to a different node memory leaks because some part of the tree is now lost. You should encapsulate the tree in a class like which handles the construction of the tree in the constructor or through a factory method and handles the deletion of the nodes in it's destructor. This way the user can pass around an instance of the tree and not even care about how you store the data internally which facilitates encapsulation (although in a templated class this becomes somewhat a moot point). It would also result in more idiomatic C++ by creating an object through a constructor and destroying an object via a destructor rather than calling a delete function. 

The method in the course is responsible to check if the student exists in the course and return once it has executed the strategy. It is totally encapsulated in the course and the caller doesn't have to know about any internals. 

Design Reading the code it looks to me as if there are two separate things mixed. Effectively you have two different code paths through your class - one for static method calls and one for instance method calls which do not have much in common. I'd consider to refactor this into separate classes to simplify some of the logic and separate the concerns. Something along these lines: 

When throwing an exception because the argument violated a constraint then you should consider mentioning that in the message. Simply "Invalid foobar" is quite useless to anyone using it. A message like "Buffer size must be 128 or larger" would be infinitely more helpful to the programmer using this class. should be able to be called more than once without any side effects. In your case it would throw a because you set to null. A check should suffice. Adding a flag is another option. In the times of Linq as a user of your class I'd appreciate it if it would implement to iterate over the rows. I'm not 100% of the full purpose of . It looks like it could simply be expressed as boolean flag to indicate whether or not there a row is currently available. I think the design of the private methods needs to be cleaned up. They have some inter-dependencies for the various state variable (like buffer and row positions) which are not easy to follow. 

The initial predicate evaluates to and is as well. Entering the first block this means is always and can be omitted and is always hence the path is never taken. Given all of that the code boils down to: 

For the second part asyncio is used since Consul provides a long-polling API which blocks key queries until there is an update to the value (or a timeout has elapsed). python-consul provides an asyncio adapter which makes use of aiohttp. Since this is my first time in working with Python and asyncio I'm looking for feedback on best practices around the use of it. But any other feedback is welcome as well. Implementation (): 

I would check that the lock was actually locked in (and throw if it wasn't) - unlocking an already unlocked lock indicates a potentially serious bug (lock/unlock should always be in matching pairs). I'd consider implementing and check that the lock is not locked when being disposed. Any object owning a lock instance should then dispose of it - this adds another check that the locking/unlocking is done correctly. 

If you want to add another item to the game then you add another entry into the and some additional rules and you are done. One thing to improve with my version is that rules just effectively define winning rules and all other cases are implicitly ties which in the context of this game makes sense but could be made more explicit.