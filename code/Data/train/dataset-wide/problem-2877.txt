I have setup agenda tasks to periodically retrieve and possibly insert new SE sites and tags in my MongoDB database. Some things that bother me in particular: 

I prefer to define (almost) all of my variables as and when it's a string, I use the lowercase instead of . It just feels nicer and in the case of : keeps the focus on what's important. 

Your code is not extensible to more (or less) than 3 parameters even though this shouldn't be so hard. Below is an example how I would do it with 3 hardcoded parameters: 

I'm not familiar with the library but isn't there an event you can subscribe to instead? I notice something like but there could be others too. Either way I would decrease the delay to, say, 100ms for better responsiveness and no difference in performance. 

This is aside from any remarks on whether or not your code fits your problem description, as @rolfl states. I don't see where you split it in sublists of 3 elements. 

I prefer since that also takes care of.. well.. whitespace. You never know if the pesky QA departement tries something like that. 

You can remove the intermediate variable entirely since the try-catch is now gone and there is no additional logic. 

Update In response to your questions about retrieving the ID I made a little sample project to confirm my suspicions and it's like I thought: the original object's ID is being updated when inserting it into the database. Take a look at the following code: 

is a helper method. If it is only used in then it should be declared there and made . If it is used elsewhere as well, then it should be either moved up into the hierarchy (if that makes sense in your structure) or to a separate helper class. 

No abbreviations[1]. Change that to and . [1]: almost none. Some very specific ones like I can live with. 

In you use two variables and which you convert to integers. This implies that these Ids are stored as a type they shouldn't be outside of your method. This poses 2 issues: 

It might be functionally the same, but once more popular convention dictates this instead (refer to the standard method notation): 

Dabbling around with Roslyn and made a small analyzer just now. This one will show a warning in Visual Studio when you have a try-catch statement that only has a . I realize the working code () is rather small, but I'm looking for feedback on best-practices (insofar there are already best practices established) and general remarks on scenarios that I might have overlooked. I have also been looking for a way to unit test this, but haven't come up with a good solution yet. Is there an elegant way to test these analyzers instead of looking over them by hand? Or perhaps an API that exposes some crude methods which I could provide a wrapper for? Analyzer 

Finally, see that you can now add more complex validations to scores and weights, if needed. You can easily extend this code now to support additional use cases also. Hope this helps! 

With all that said, this is how one of my scripts look after all these conventions are applied (I used a simpler script than the one shown above to focus on the conventions and not the script itself): 

Finally, functions are documented in a similar way than blocks of code, but I decided to include parameter and return value definitions (inspired to some degree in Javadoc comments). Here is an example (take notice of the tag at the top of the comment): 

FILE ORGANIZATION The basic organization of my files was thought in order to put everything that makes sense together, in the most 'findable' way, trying also to follow the basic flow of my scripts. In this regard, the main sections that my scripts have now are: 

Well, in case anyone is interested, here is what I've come up with: BASICS I like using the type of comments over comments, because I think they are easier to read (less clutter). Also, I use lower case text for everything inside the file (except for section headers, as you will see below). I understand that many people prefer to use upper case text for function names, labels, etc., but I think lower case text is easier to read, so that is what I am adopting for my files. COMMENTS Taking this into consideration, I use a header on each file like this: 

I use these two methods when running macros that do intensive work of reading/writing information to several sheets: 

A more compact and extensible solution would be to use pattern matching to try and take common parts of your field names and use them to map the uneven field headers you get in your csv files. But I don't think this will work in your case, because you don't seem to have common patterns for all your field names. For instance, and are field headers that should match to the field, but as you can see, there's no common usable pattern there. And in cases where there is a common pattern like , it won't work either because it could be for the fields or . So in this particular case I think you will definitively need to provide the full list of possible field names for each field. Now, you can do this in a more compact way using a VBScript dictionary that allows you to check in one line if certain field name (key) exists using , or see the field address matching a particular field name using . You still need to add all possible combinations of field names and addresses to the dictionary, but after doing that (just one time), you can use your dictionary very efficiently to get the address for all your headers. 

Some sections are optional - more details regarding the sections I use below in the organization part. Blocks of code inside each section can be commented with something like this, in order to create a clear separation of the different parts of code, and also to provide useful comments for business logic, batch file techniques used to "make something work", etc: 

You're not using any form of globalization. Intended? Adding a resourcebundle isn't much work and you'll finally be able to support Swahili. 

Indentation is done with 4 spaces (or 1 tab, consisting of 4 spaces). It's best to stick to these conventions. Order of attributes I see your methods are declared as 

Why are you using to get the value and then placing a useless call to to discard of the value? That's not how a stream is intended to be used: simply call from the start then. 

Now I will immediately know what your intentions were and the general idea behind your approach is clearer. I'm certain your teachers will appreciate such informative commenting when they have to look through a multitude of assignments, many which will not have gone through a review. Member order Regarding your edit on method order (which I changed to member order to get some other things as well): usually I would point you to the Java Code Conventions but appearantly they all give a 404 right now. However from the top of my head, this is the order of which a class' members should appear: 

I see this pattern from time to time but I don't like it: or . That's what overloads and perhaps named arguments are for: all you care about is the part, everything else is just one specific way of retrieving the data but does not have to actually be a separate method rather than an overload. I would change it to and call it like this (and considering your variables are aptly named it can stay like this): . If for some reason you don't like this, you can always do but that doesn't add anything so use it when the variable actually isn't clear (like ). 

I don't believe a Semaphore is needed in the first place. Remove it, register an event handler and continue your "act" and "assert" phase inside it. Something like this: 

With a limited set as this, you might as well skip the entirely and just keep the statements. Exceptions are expensive, statements not so much and there are only 4 options anyway. Furthermore you could reduce the semi-repeating a little by providing a unified version of the input to compare against (all characters in lower/uppercase). In fact, I would change it to use a simple lookup table. This results in something like this: 

As far as I can tell from first sight: if you have a situation where is initially and has items but the first item in that list (aka: index ) is then , and will not be set. This might not have been a problem but is never reassigned so it will remain . This will crash your program if a flow is followed where eventually will be called: there the field is used. This will result in a . 

You're constantly locking the result set. It's probably faster to just omit the parallellism altogether since we're not doing that much work anyway but if you really want to have it, I would suggest looking into splitting the to-generate dataset beforehand, computing the data and storing it in separate collections and at the end combining those collections. Though that might be slightly overdoing things.