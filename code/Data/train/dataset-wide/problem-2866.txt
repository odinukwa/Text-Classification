Also, I use inline comments to help the reader and my future self to understand complex statements such as 

Overall complexity: Instead of introducing a new class for something as simple as a random number array, write simple reusable helper functions which return arrays: 

4. Invert the negative condition: You can get rid of the explicit comparison to zero by switching your and statements: 

Optimizations Blindman67 has already pointed out that regular expressions speed up parsing by a huge margin. But we would still copy the input which results in a linear additional space requirement. By stepping through the raw input via and and using the fact that two of the three queries are of fixed length, we can reduce the additionally needed memory to a minimum and thereby speed up parsing even more. We also reduce the overall number of and operations on the stack by a simple run length encoding - i.e. by keeping track of the last maximum in one stack and its repetitions in another stack: 

Remarks on the provided implementation: The code is already well structured and easy to follow along, even though it is not immediately clear what you are actually trying to accomplish. 

Give those functions clear, self-documenting names to help the reader along. In your case, those could be e.g. or similar. Your algorithm's runtime complexity is probably linear in the number of available cells. If you find that your application is running slow because of that, you can employ techniques such as spatial partitioning to improve runtime performance. 

Since the worst-case runtime complexity improved from quadratic to linear, we see major performance improvements. The runtime is dominated by read query maximum retrieval speed. 

3. Simplify the condition: Your condition can be expressed in terms of both loop iterators and thereby simplified to : 

Runtime Complexity As pointed out by others, your implementation performs a summation over elements in range per lookup in linear time. You can improve the runtime complexity as follows: 

I would like to hear your recommendations on when to use JavaScript's over , especially when applied to mutable objects as demonstrated in the following comparative code samples: Strict preference of : 

Each row represents the schedule for a single team. We note that for each round teams are partitioned into pairs playing against each other - i.e. . However, there is a flaw: According to above schedule, there is a round for each team where it has to play against itself (the red squares) - i.e. . That's because a correct schedule for 10 teams can only have 9 rounds, not 10. To fix this, we first slice the main diagonal of - all matches against team - and end up with: 

To improve code readability and reduce the perceived complexity, you need to reduce nesting, remove conditional branches, simplify if-conditions and switch to a more descriptive style. The following 'techniques' help to simplify your code sample: 1. Exploit the nested loop structure: The first condition checking for line-breaks becomes whenever the inner loop terminates. Get rid of the condition and move the statement below the inner loop body: 

Encapsulation When your projects get bigger, a clear separation between individual parts of your code becomes more important. Reduce interdependency, limit the scope of your variables, keep things local and well contained. All this facilitates reasoning about and understanding of your code as well as debugging, testing individual parts, reuse and more. The properties and methods needed to store and update a custom date are a good fit for a custom object type, a . You would start with modeling a simple date. A concise representation of a date is given by the seconds passed since 1888, similar to a Unix timestamp which counts the seconds passed since 1970. All other variables such as minute, hour, day, month or year can be computed from that timestamp, given we know how many seconds there are in a minute, hour, day and so on. To incrementing such a date by one second, you would simply increment the timestamp. It is a good idea to hide the logic which derives these dependent variables from the timestamp behind getter and setter methods. This would allow you to e.g. introduce leap seconds later on without having to substantially change the interface of your date class and thereby the code which interacts with these dates. It is equally helpful to separate your model from the way it will later be represented on the screen. Formatting a date depends on the user's language and locale. Integrating a formatted date string into the user interface should be part of the view layer of your application. Here is one possible way of encapsulating a custom date within a class and some formatting functions: 

This has the added benefit of removing the dependency on jQuery. Now, looking at the returned array, it becomes evident that you are actually building a mapping from year to values: 

Now, we re-introduce the matches against team wherever a team would have to play against itself (the red squares). We also have to fix the opponents of team to reflect these changes. This practically means that for each round we swap with where denotes the self-matched team (the red square): 

If your input strings are of length n, your current implementation has a cubic runtime complexity O(n³). This could become an issue for longer strings. I recommend to split counting character frequencies and comparing those counts into two separate steps with nearly linear complexity O(n): 

This is the resulting correct schedule with all swapped matches highlighted in red. This schedule is identical to the one you compute and pretty simple to generate: 

Implementation Your implementation is clean, robust and easy to understand. I suggest only small changes: 

Better yet, take those complex statements as a hint to better refactor your code. I advise to use available language constructs where appropriate. If you replace a simple for-loop with a while-loop for no apparent reason, a fellow developer will have a harder time to read and understand your code. Also, I really recommend to use curly brackets with if-statements. The lack of those might be more pleasing to the eye by hiding the deep nesting, but makes reading and understanding as well as modifying your code much harder. I suggest to combine if-clauses with identical statements. Instead of writing e.g. 

I recommend building the filter in steps, starting with an empty object . You then add attributes according to the selected city, category and date. And finally, you convert it to a JSON string via : 

It is not obvious to me why the arguments and are given as instance properties and defined within the constructor function. By doing so, you create a stateful object which is more difficult to understand and test than e.g. a simple 'pure' function. Also, by setting the flag, the semantics of your method are no longer compatible to the meaning of . How about two methods and ? The suffix indicates that the return value is a complex object containing index and value, comparable to e.g. or . Those established methods iterate or return arrays instead of objects, so you might want to consider following this established pattern, too. Instead of passing an flag and relying on instance properties and I suggest a method signature such as and passing (or not passing) a delta argument. I would replace the many for-loops with a single . You would then have to lookup and and return either one depending on the given flags. Don't forget to test for the corner case when and consider handling it appropriately. If you had to handle more than 20 values, I'd implement a binary search and - if the number of queries for a given array of values is large, built a binary search tree first. This would improve runtime complexity from linear to logarithmic. But for just up to 20 values, the built-in or even an explicit for-loop is surely faster. 

If you modify your function to increment frequencies for string and decrement frequencies for string , you can simply sum the absolute frequencies to get the number of required deletions. If you combine that with a more descriptive approach by replacing for-loops with and , you get a simpler implementation: 

Algorithm Your algorithm is simple and easy to understand, but comes with a linear runtime complexity of . An algorithm with constant runtime complexity exists. Here are some pointers in case you are stuck: 

The native is fast, but comes with a certain constant setup cost that makes it slower than your implementation for very small strings. As soon as the input strings get longer however the built-in outperforms any other solution: Small strings: 

don't belong on the same namespace or module as the random number generator as they are not related at all. Namespace: You use the object for unrelated things: 

I recommend removing the inline event handlers from your HTML document for a cleaner separation of markup and logic / JavaScript similarly to how you separate markup and style / CSS. You can then add all event handlers with a few lines of code as follows: 

A better design would probably have the attributes on the colored buttons and not on hidden elements, introduce a mapping between pad and audio source and leverage the web audio API instead. Using shapes instead of heavily styled s for the UI might further simplify your markup. 

Replacing above regular expression with e.g. a much more refined allows you to capture floating point numbers, negative numbers and whitespace. To support more operations, simply append them to the object literal, e.g. and add to the operator capture group within the regular expression. 

Your solution is a bit wasteful by generating and testing all integers in the desired range while you actually only need a handful of them. A big improvement in terms of performance is to avoid modulo arithmetic and increase the step-size tenfold whenever you finished iterating a sub-range 1-9, 10-99, 100-999 and so on: 

While the original implementation performs better for very small inputs, the improved implementation performs much better for longer arrays. This confirms our above runtime complexity analysis. Plotting the times against the input length clearly shows the quadratic nature of the original runtime complexity vs. the linear runtime complexity of the improved implementation: 

Edit: You could move the declaration of both event listeners out of the loop body. However, the dropdown toggle's 'click' event listener needs access to the dropdown element it belongs to. So you would still need a closure or alternatively bind the event listener's to the dropdown: 

So how about just returning the paging range as an array of numbers? Later on, within your HTML template, you can then print or - in case you print HTML - simply select a different CSS class for the current page. Handling corner cases: In case you choose a range of 5, but the total number of pages is set to just 4, a call to will return including an undesired at the beginning. A robust implementation should probably reduce the range according to the available total number of pages. Fixing issues: Since we now allow user defined values, we need to fix issues arising from values that are not caused by the hard coded "force start at 1" within your code. Putting it all together: Choosing simpler and more consistent variable names as well as renaming the nondescript to , we get an easier to read and understand implementation. Replacing the loop with yields more descriptive code. Adding a single comment describing the function's behavior instead of many individual inline comments helps the reader to better understand the purpose and usage of the function. 

5. Use the conditional ternary operator for terse conditional assignments: You can replace the somewhat verbose statements with a single conditional assignment using the conditional ternary operator: 

In this case however, as you are striving for optimal performance, even generator functions are slow compared to directly processing the raw input. Robustness Your code is not very robust. Your handling of invalid queries is inconsistent. For invalid queries you return . For invalid queries you throw a . I recommend to simply ignore the request of deleting the top element of an empty stack. This would be consistent with . I also recommend to define the maximum of an empty stack as . This would be consistent with . Correctness Your code is not correct. For example, for queries you throw a . This is because you process the first line as any other line and ignore the fact that it contains the number of operations. Runtime Complexity The worst-case runtime complexity of your code is quadratic. Let's assume you are only given push and print queries in alternating order. You loop over all N queries. For each of the N/2 print queries, you inspect all stack elements to find the maximum. Since the number of stack elements corresponds to the number of push queries N/2, the average number of elements in the stack is N/4. Unfortunately, the resulting N/2 × N/4 = N²/8 is quadratic. A linear worst-case runtime complexity is possible. Instead of pushing the incoming element onto the stack, you simply push the current maximum on the stack. So you can reply to a print query by simply inspecting the top of the stack. Applying the aforementioned changes to your code, we get the following implementation with linear runtime complexity: