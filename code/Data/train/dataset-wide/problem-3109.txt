Naming can be renamed as to follow the naming convention. can probably be renamed to better reflect what it actually refer to... is it just ? Types are usually given in the singular form, so looks a bit out-of-place too. What does it contain to represent multiple messages anyways? Interfaces over implementations If possible, it's suggested to change the return type of to the interface, instead of the implementation. This is because callers on this method should not need to know they are using the implementation, just that they have an object adhering to the interface. Java 8 Since your methods are , the 'mapping' between and them can be expressed nicely in Java 8 as method references. Assuming 's type is a simple /: 

@rolfl beat me to it, but I'll still offer my answer in case it is marginally more useful... First, in your method, you are expecting that the sorted list is in a low (not rated, yucks) to high (so many As!) order. This either means that your should really be calling 

Ok, here's a quick shot. Consider starting from the number 3 and increment your loops by 2? Example: 

Just mentioning this for the sake of mentioning (see final point below), but you can probably get away with just this: 

I'll leave the actual generic DAO discussions out of this answer for now, and just offer my two cents on coding styles... 

Enhancing use of loop Multiple local variables can be declared in the loop, so you can include your variable as such: 

Since your three conditions are mutually exclusive, you can also consider putting them together in one ladder, e.g. 

Do you need to consider resiliency for handling messages that failed to be persisted via Hibernate? In fact, would you need to consider the need for Java Transaction API so that you can synchronize (layman-speak) the persistence of your domain object with the acknowledgement of your JMS message? Oh yeah, one last thing... 

The suggestion above opens the possibility of treating cases differently from the usual . You may want to just swap the indices, or optionally return when both are equal. Alternative You can consider iterating through a of the input as such: 

Language It's better to stick to English for all your class/method/variable names too, instead of a mix. This is to promote better understanding of your code by others who may not understand your native written language. 

My take on this is that there's really no issues with using Lombok's builder pattern, but at the same time don't be too limited by what you can do through a framework. :) I think can be made redundant if you were to work with an / directly, instead of a . Even if you will like to stick to this current approach, this method can be rewritten as such to leverage on the return value from , which is only if the addition modifies the : 

If I were you, my answer will be that it is entirely plausible we want to preserve the case of aliases while performing case-insensitive searches. That's not to say your approach can't be improved: in fact, that's what is for, as demonstrated in the above section. APIs 

An additional benefit of this is that you eliminate to risk of calling accidentally, when the argument is really a URL. Auto-boxing You rely on auto-boxing for your and classes. The problem with this is that you get a nasty if there is no mapped/array value, and the JVM is trying to unbox the to one of the primitive types. Also, if the value is not the desired primitive type wrapper object, you will get a too. You should consider checking for that, for example: 

Potential bug #1 The problem of using a class variable that is modifiable in every new instance created is simply, multiple such instances cannot iterate through the contents reliably. Potential bug #2 This is also related to in the method: calling it twice without a effectively skips one element. Usually, the iteration state should not be modified when doing a , but you have a inside it. Potential bug #3 The other problem with having inside the is that callers cannot reliably retrieve the element without calling first. Illustrating all bugs 

Using the method reference to group objects by, with a dash of to combine two streams together, we can combine the processing on both the repository and service results with relative ease: 

The first character (what case to use) This can be implemented as a , i.e. converting a (boxed from a , which is safe) to another . The conversion when encountering the next character past a separator There are two possible approaches here: 

edit: As you have rightly pointed out/discovered, is not a generified (?) class, so the closest approximation (in terms of reading code) is to use checks and then call the appropriate constructor. Some people frown on it, but the option exists... 

You usually should not need to declare the return result right at the start, perform the optional assignment, and then return from the method. You should just return below, without needing the variable: 

Strip out the 'key'. Split values by into tokens. Optionally converting resulting tokens to objects for , and leaving them as they are for (this is where comes into play). Put resulting objects into a . 

(BTW, is a Java 7 method and it is a simple null-safe implementation of calling the first argument's with the second argument. This is important as can return for non-matches.) Pro-tip: Actually, you may want to go a step further by grouping the day and year values, and make sure that the length of both parts (i.e. or ) are different: 

If both conditions satisfy, then a sample wrapper implementation can be as such (using poorly named class names and variables, please excuse that): 

Minor comments here since scott_fakename has provided a pretty good start... Extract the user input part from into its own method, so that each method is only dealing with one thing. You have some idea of showing 'tracing' messages for debugging/troubleshooting, ever considered using a logging framework? Not sure if this is beyond what you need to hand in this assignment, just a thought... I also think using one static class-wide instance is good enough for all the random number generation. As for consolidating and methods into a single one that takes an extra parameter to control the calculation, you can consider using enumerations to indicate the different modes. E.g.: 

These can otherwise be represented as properties or fields of a Java class, if you choose to model each strain as an object. If you ever decide to add new effects/medicinal properties/negatives in the future, you'll have to keep updating these s. If you choose to model them as classes and s, it makes it easier to add or remove these properties for each strain. 

This is one of the few places where you may want to use a temporary variable, and employ the help of line formatting: 

Exception handling Avoid catching on a generic as it can cause confusion in the long run. For starters, it adversely affects logic control the moment you encounter any kind of exception - checked or runtime, minor or major. It also potentially hides newer errors when you change your code: maybe you need to be concerned about a new checked exception that you can safely resume processing the remaining results, but because of this broad condition, you'll be left wondering why you sometimes/always end up with an empty . Also, the declaration is for checked exceptions, so you are still able throw runtime exceptions, if it's severe enough. early If you invert your condition check on and to early, you can reduce one level of nesting. Style