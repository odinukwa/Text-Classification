If you're on Python 3.6, you can use to get cryptographically secure random bytes or to get hex-encoded cryptographically secure random bytes. If you aren't on Python 3.6, you can achieve what does with the following: 

There's a lot to unpack here! First, take a look at . It just parses an expression and returns the result of evaluating it (remember how the first production in the EBNF is the "main" one?). To parse an we parse a term , collect any number of that follow it, and evaluate out that math. We do something similar for . For we either try to parse a number (just a ) or a (subexpression) and if we can't find that we raise an error. Notice how the actual work of doing the math in done in and . But, critically, note that the former should only be given lists of floats (must already be evaluated, the parser handles this via recursion) separated by operators of the same precedence. This means intentionally cannot handle . The parser handles this. It would first parse a and call . This would be returned and then it could finish parsing the and call . For a simple calculator example, this code is decent. But you can see how things quickly get out of hand for more complicated EBNFs. This is what I was alluding to earlier. This code needs the following helper: 

Note that this is a free function, not a member function of . Prefer free functions, because they work in more cases (like multiplying an to a ) and are thus more consistent. This allows you to do this: 

Don't put into a header, because everyone using your tree now also has the whole standard library in their namespace. Put the public parts above the private parts. People are only interested in what they can actually use, not the implementation details. should be since it cannot be used in a meaningful way anyways. Don't use , use instead. is just a macro for (in theory it could be something else, but in practice it never is). Nonsensical things like and compile even though they are clearly errors. doesn't have that issue. Prefer initializing in the class directly instead of writing a constructor. 

I dislike that your class mixes functionality (a mathematical vector) with memory management. A class should only do one of those. If I prefer I have to rewrite your whole class. There is actually a thing in C++ that is better than smart pointers, which is value semantics. People rarely screw up the lifetime management of an , it just works naturally. When you do tricky lifetime management try to mimic the way does it. The should be (as well as , and ). It should also work on s and not only on pointers. The standard way to add s is this: 

Your syntax: As an outsider to your syntax process (and perhaps a useful perspective of a "potential user" that wasn't part of that process): 

Note that this code is only loosely tested. You should write tests for each component. As I've needed to loosely test, I've fully implemented everything and will put it in a gist in case you get stuck connecting the dots (but really the only thing I left out was exceptions): $URL$ 

Ignore whitespace (although this has it's limits, we probably don't want to become --instead we probably want to error that we can't have two sequential numbers, we'll leave this to the parser so for now let's say the scanner will just emit two tokens for that and ) Turn symbols into single tokens (ex ) Parse numbers (may be multiple characters, can be ill formatted as in ) 

I think you shouldn't do regex matching on the arguments. I'm assuming the plugin API doesn't give an error to the user if the arguments don't match the regex. I think you want to be more informative to users when the issue an invalid command. Also with my suggestions above, all commands now have space separated arguments so you can just use the last param from . I've only included one doc comment as an example to make the example shorter. The rest are your job! is just a helper that turns an array into a comma separated list with "and" (ex. it handles two elements just being "x and y", but also 3 being "x, y, and z") I'm still undecided on whether this use of a decorator is worth it. On one had, it removes a lot of duplicate code (used in all but one command). But on the other, it's only two lines of trivial code per method, so maybe the indirection isn't worth it. 

Wow, my machine is noisy. I don't really know why it's that bad, but moving on.. The version that explicitly shares tails performs better in the small test, by a notable margin. At those sizes, the memory use doesn't have a significant performance impact. But in the larger test, it's notably slower. At that size, the cost of the additional memory use is visible. A side note from the larger test is that the performance difference between the naive version and my hand-fused version has become significant, and the hand-fused version is slower. I'm not as good of an optimizer as GHC! (I suspect that the issue is that I'm counting up and comparing against a non-zero value in my loops. I could test, but that's getting pretty far-afield.) In summary, I'd use the naive version. It might be a little slower in small cases, but when things get big, it starts to get ahead. And it definitely has better properties about memory use at any size. Sometimes duplicating work is faster than caching it. 

And in fact, that's exactly what leaning on the monad instance for iteration looks like. A couple of binds and a return. 

That last line should not compile, but it does. Blame the that should not be there. Unfortunately you need to write 2 classes to get this right in C++, typically and . Looking at the list of things required to make a bidirectional iterator it seems like you are missing some, for example everything around std::iterator_traits which also explains 

This implementation uses a second array for the merged list. It is probably possible to do it in-place, but that requires some more effort. My solution reduced the complexity from O(n*log(n)) to O(n), but changed the space complexity from O(1) to O(n), which is not strictly necessary. I would probably favor your solution because it is easy unless it is proven by profiling that the small efficiency deficit is a significant problem. 

To print a matrix we would simply do this: . What you did is combine a container (holding multiple objects) together with input/output and the actual functionality of matrix operations. You should try to make each class only have a single purpose. The only purpose that should have is to do matrix operations. Instead of writing an example by hand I'll refer you to eigen where they did all of this plus some other neat tricks. Now imagine I did and my output said "The sum of 1 and 2 is 3". That would suck. Your shouldn't do that either. 

Interpreting commands from IRC, delegating to the appropriate business logic, and returning a text response to the users in the channel Vote bookkeeping - adding/changing votes, tallying votes Serializing/saving/reading/deserializing the bookkeeping information from redis 

You'll noticed I've omitted the docstrings, because this answer has gotten really long. You should include them. Notice how this class only concerns itself with tracking support and opposition for options and abstaining votes? No mention of any commands or serialization! You should be able to test this in isolation to make sure you voting mechanics work (and you should, because I haven't!). The class method may look a little strange. I'm a big believer in logicless constructors for testability. Users of should never create a new one on their own. They should invoke . But for tests, you can create one at will with some state already setup to see how it behaves. This also acts as a nice entry point for our serialization methods that we'll add later. Some wins for this separation are that the logic for finding the option a user meant is centralized, as is the logic for ensuring a user hasn't voted for anything else. All of the vote logic is now close to each other, so making changes to voting mechanisms should be easier (because a change's impact can only affect the surrounding code). One thing to note is that in designing the API, we've exposed an exception that we need to handle and tweaked how the param to the and methods work. Namely, can be none (in the case of a binary poll) or a string (the possibly partial name of the option). Updating our is easy: 

turns out to just pass off the heavy lifting to and . is pretty simple, so the interesting part happens in sequence: 

So is this better? Well - it depends. It should be better when the cost of allocating the suffixes is higher than the cost of keeping them around. The memory use of keeping them in memory isn't insignificant. Eventually it starts to really make a difference. Here's a new set of benchmarks: 

I was suspicious that your initial code was basically as good as possible. It's already algorithmically better than your second example. is immutable linked list. There's no way sorting values is better than just generating the correct values in the first place. So, I decided to benchmark your initial version vs a hand-fused version that is guaranteed to allocate only exactly what it needs. 

I changed the definitions to be functions that take the max size instead of infinite lists in order to prevent memoization from breaking the benchmarks. Here are the results I got: 

And the results say... They run in basically exactly the same time. The differences are well within the standard deviations in the measurements, and my computer is apparently a very noisy system to benchmark on. The conclusion I draw from this is that the naive code is basically as good as possible. The optimizations present in GHC and its libraries make it exactly as good as the far-more-complicated fully hand-fused implementation. 

I don't like that you use to set the function. suggests that I can append a bunch of functions and they all get called when the event happens, which is not the case. would be better. It would make sense to take advantage of move semantics. The lambda that gets passed into is moved into and then copied into , when 2 moves would have been enough: 

That way you can also leave out the constructor. I dislike the name . The return value tells me if it searched or not? I would prefer so that the return value fits to the name. Your leaks memory. It creates s with but doesn't them unless you manually call for every single item. You have 2 options here: Insert a destructor that deletes all the nodes or just make , and s, which will delete the nodes automatically. If you go the route you will have to change the implementation code a bit, because you cannot copy a (then it wouldn't be unique anymore) and instead or them. Your can be copied but the copy does the wrong thing. Instead of a copy I get 2 trees using the same nodes (because it just makes a copy of the pointer). If I change one tree the other also changes. Instead you should write your own copy constructor that deep-copies the nodes. Same goes for the assignment operator. Also your would benefit from moving, so you should add a move-constructor and move-assignment, too. prints stuff. As a user of your class I don't want that. Or at least let me specify an where you should print it to. should be a function. Right now I cannot search for a value in a , but I should be able to. In you keep the , but it is not used for anything. You could simplify that function to something like this: 

The big thing I can see is that you don't seem to know why to use a mutable structure in Haskell. They're not automatically faster. In fact, they have some GC-related overhead that exceeds that of immutable structures in GHC. Mutable structures in GHC are only a win if they can actually reduce the amount of allocation, and this implementation looks like it allocates a lot. When you consider using a mutable structure, you need to examine how mutability will reduce total allocation. If it doesn't reduce allocation (and usually by an asymptotic factor) it's unlikely that mutability alone is going to help performance. 

Note that I do a round of benchmarks forcing smaller values fully into memory, and then do a second round of benchmarks with a much larger value that I only care about the last entry of. Here are the results: 

If you want the laziness of , you'll need to write this using . Doing that requires a trick - the same trick as is involved in writing as . I wrote in some detail of my derivation of how that trick works here. For what it's worth, using that trick to write using looks like this: