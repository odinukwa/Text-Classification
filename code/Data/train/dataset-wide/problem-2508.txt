suggests me that you already spent a good amount of time digging into the topic. While your first point indicates you are on the right way, your second point gives me the impression that you have been hijacked by articles written by people that do not really use the ECS pattern or do not understand the pattern at all (Unity, Unreal and Lumberyard are NOT Using the ECS pattern, neither in its old conception). To directly address your question, I think the best suggestion comes from @Laurent La RIZZA's answer: 

This is deeply different. Basically you can select which engines process which entities without having to resort to specialized components or without resorting to usage of Tags or groups. Basically when you spawn an entity, you have to select in advance which engines will see that entity. You can change that at any time by updating EntityViews in its descriptor, if there are missing components a nice error message will tell you that (I think you can implement that at compile time with C++, I done something similiar in past). Basically you may have X entities in your game that have a Position component, but you don't want to process your position the same, so in example static objects should not even have Systems updating them, so they could just have a method that returns the position without allowing to change it (that method does not implement any logic it just returns data). 

This gives an overview simplified of the design process. You continuosly refine things, because you can't predict everything. I Assumed objects have a position ok, but then after I defined the first piece of logic It was obvious that the bush was missing the radius for collision avoidance. It was not so hard to add it later. This kind of continuos changes are a real pain without an ECS system. And I added a Radius, without warrying if that could interefer with other engines, just because the engines are selected by the entity view, so there is not risk that adding the Radius to bushes automatically makes the bush processed by Radius-realted systems. Bushes are only processed by Systems interested in their EntityViews. If later I want bushes to be only slowing down player, I could altogheter remove the EntityView from the descriptor, and automatically I change bushes behaviour, without having to change engines, or without having to change the Bush. Honestly I think the final syntax in C++ will be quite different from C#, but I believe it is actually possible implement the same of Svelto in C++. 

When you instantiate a bush you also specify which entity views it will implement, so basically this allows it to be processed by right engines. In example if you want bushes to be avoidable by avoidance algorithm 

but let me explain why his suggestions arepure gold. ECS pattern is about decoupling all the game logic (yet seems most articles put focus on components, the point is deocupling the logic). 

Once you have pieces of logic, working on Components, then you finally just need one further step to link that logic togheter, and what you need is actually a ECS framework. 

Even if you address my concerns, I'm no cryptologist, so I would be very surprised if we can come up with a robust crypto system on this forum. I would strongly encourage you to look into one of the many libraries that provide the AES or a modern stream cypher like Spritz or HC-128 if performance is a constraint. 

I don't know how much advantage there is to a unified 2-method interface, at least as anything other than an implementation detail. You might consider dropping that interface in favor of and (and possibly ). You might also use a sealed class to implement your point observer, rather than an interface. 

You will also have to write some 10-20 lines of boilerplate to get ANTLR to lex and parse the text, then run your listener over it. The two big wins in this approach are that you get to specify your language in EBNF (or an ASCII version of it), and you don't have to write the branching logic yourself. This makes the listener and grammar vastly easier to read and reason about (and have interns/newbies modify) than hand-written parsers. Another cool win is that ANTLR does a reasonable job at best-effort recovery. You can configure it to act differently, but by default it will coalesce the tree to a close legal approximation, and give you warnings (rather annoyingly pushed to std-err by default) when it does. then the nasty bit: you'd have to modify your build system to tolerate the generated code that comes out of your parser generator. The tools for doing this are reasonable on the java side (ant, gradle, and maven tasks all ready to go), but I don't know how they are in .net land. Further, for your situation, this is a pretty heavy-handed measure. If you can get away with writing your parser by hand and never touching it again, doing that is the best option. If you find yourself going back to that parser time and time again I would urge you to consider a solution involving a parser generator. 

as an ANTLR fan, and assuming you dont have a raging hatred for auto-generated code, I'd be remiss if parser generators didn't get mentioned here. With a parser generator, you'd specify your desired syntax in a grammar file and the interpreter in a listener (or 'walker' or 'visitor') C# file. 

I'm going to post a slightly different opinion; the previous answer is perfectly sensible but they aren't the changes I'd make. 

I'd encourage you to use the operator instead of . The reason being it gives you a kind of duck-typing with collections: your code (at a source compatibility layer) stops caring about the specific implementation of the add like thing, and instead asks if the type implements a fairly common operator. The single most obvious advantage here is that it allows you to switch from to completely without (source-compatability) issue. 

Note however that this should really only be used for instructional purposes, there are plenty of libraries out there that have built-in observer pattern implementations, not the least of which is guava. You're likely much better off using one of those libraries than suffering from the inner-platform effect.