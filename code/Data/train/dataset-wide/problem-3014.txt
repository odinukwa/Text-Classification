You're right - there is a lot of duplication. Also, some organization is needed. Organize! Before you do anything else, get everything into a function of some kind. All those statements at module scope, move them into a setup function, write yourself a , and do the standard Python thing: 

The one obvious thing I see is that you are consuming the input. I'd suggest you try using slices instead, so that you don't consume the inputs and you don't have to spend time and memory splitting the vector. 

First, you misspelled "variable." But second: how could you possibly think this comment adds value to your source code? There are some occasions when you need to answer the question "What?" But those occasions are few and far between. You're actually better off never answering that question unless somebody calls you on it. Until and unless someone asks you "what is this code doing?" I would suggest you simply never use a comment to explain what you are doing - because at the "learning" stage, it is almost always obvious. You might explain "why" you're computing some value, or "how" you're doing a computation. But, again, for the most part these things are obvious. Now consider your variable, 

Finally, I'll point you at the module, which is the standard Python way of measuring speed. If you are trying to beat a time limit in any challenge, make sure you use so you can keep track of what effect every change you make has on performance. 

Command your minions. This is purely a "social convention." But the standard convention for commit comments and function documentation is to use the Imperative Mood rather than passive voice. It's almost as if your program is telling the computer what to do. (Wait, what?) Change this: 

than to have them search backwards for where occurs. Also, of course, in this context actually reads better than just . You have an input parameter . You use in your loop. But is the singular of , so when you say it seems like you are returning a member of the iterable. I'd choose a different name, like , making it clear that your returning a component of the inner tuple. You compare but you don't have to. Since your random number is pinned to 0., you could just use a comparison against the high value and get the same result. Structurally, the shouldn't be in the branch. Yes, it only executes when the is not executed, but the should not be part of the flow for that statement. I'd rather see: 

And this is wrong. Tail should point to , not to NULL. How can you fix this? By adding another condition: when updating the pointer, check to see if the pointer is still pointing to . If so, then go ahead and null it out because you know you have a 1-element list being shortened to an empty list. But if points to some other location, and you're deleting the tail element, then you can set to point to the address of the struct containing the pointer that is pointed to by (Say that five times fast!) Fortunately, the pointer is the first element in the struct, so in C you can assume that the two addresses are the same, and just cast one type to the other. (In C++, with a vtable, the addresses wouldn't be the same. In C with any other field at the top of the struct, the addresses wouldn't be the same. That's what the macro is for! You could subtract the offset, but ... c'mon! This is C! Just hard-code the 0 and move on...) Something like this: 

But wait! Because you go on to implement a function in-line, perhaps to show your disdain for the paltry performance advantages offered by the standard library? 

But then how would you test? You'd have to use global variables or something, and where's the fun in that? But if you built a generator, you could ignore the options and just pre-program a path through the data: 

First, let me say that I support the idea that the dungeon generator and the dungeon object should be different. The code to randomly create rooms has nothing to do with the code that decides whether a user has stepped on a trap, etc. So I like the idea of a separate class/object/function. That said, this is a very awkward set of calls. It doesn't "scan" well (to use a term from literature). I suspect that all these fine details need to be wrapped up into a single factory function that a user can call: 

instead, so that starts at zero. But then you won't run the loop on , if that matters. Alternatively, you might want to try: 

It seems like you are doing a little too much work. The maximum sum of a node that is None will be 0. The maximum sum of a node that is not None will be the value of the node, plus the of the sums of the two children. That recursion alone should be enough to avoid using intermediate data structures. Something like: 

It's worth pointing out that right now your code is very fragile. You have a lot of array indexing, and any little mistake (like a plus sign instead of a minus sign, or an x instead of a y) is going to give you a potentially valid-seeming result that won't be quite right. You will need a strong set of test cases to catch this sort of thing. But I'd also recommend that you use variables or preprocessor macros to spell out things instead of expressing them symbolically. For example: 

Memory Ownership in C++ One of the most important concepts in C++ when dealing with pointers is the idea of ownership. Some terms: 

That should enable you to eliminate and everything that uses it - just encode the as a method that returns the right answer directly. Write methods that actually do what you're doing I notice that you've fallen into the trap of writing methods that don't do what your code is trying to do: 

First, let me second @mkrieger1's suggestion. Go read Eric Lippert's blog posts about how (not) to solve this problem using the type system. In particular, the very last post in the series which encourages you to take a step back. You have said, "[the player] can improve the level of his skills with paying money. He can't do it alone. He needs a trainer for that." This does not sound quite right to me. In my experience, the can interact with various some of which provide information, some of which provide inane chatter, and some of which are special and perform services. You are leaving out the interaction part of the equation. It's not a simple case of writing code that directly invokes a dedicated method on an object: 

But really, you should not be writing this function at all. The point of your UDF, if I understood correctly, is to evaluate its arguments and return one of them unchanged. So, just do that: 

(Also worth noting: is the name of a Greek letter. is something you do in a boat.) You might even consider the fact that Python supports unicode identifiers, like so: 

The collectively exhaustive events are not going to change or be updated. So use a tuple instead of a list: 

As you can see, this lets you send data into the generator, then pull data back out. You just have to start off by sending a to "prime the generator". This is relevant to you because you need to have a 2-way conversation. You want to send out some options, and get back a selection. You could do it like this: