In the constructor, is allocated: . However, it is never deleted. You can do it in a destructor. The same is true for the array(you should delete it at the end of the and member-functions). 

A little bit about code style: it is conventional to surround binary operators with whitespaces(for instance, should be ) and there should be a whitespace after a closing bracket and before the opening one(that is, is better than and so on). Yes, you should check that and are not before calling the method on them. The constructor can throw an exception. In this case they will be . However, you can use try-with-resources(if you have Java 7 or later) to make your code more simple and concise: 

loops can never terminate if the table is full. If all the slots're used and you're trying to insert a new element or look for a key that isn't there, it'll keep wrapping around as there're no elements in the array. You can fix it by terminating the loop after iterations, but it's only part of the problem. The real question is: what is the desired behavior in this case? Being unable to keep more than elements (which should be known at compile time) is a serious limitation. In fact, a hash table that can hold only 20 elements is likely to be quite useless in practice (if the amount of data is so small, a simple array is unlikely to cause any performance issues). Ideally, the table should grow when there's too little room left. Roughly speaking, you should allocate a larger array, rehash the elements, but them into it, and delete old array. Even if you decide to keep it fixed-size for simplicity, you need to indicate that the table is full somehow. It shouldn't silently fail to insert a new element. Using error codes is a typical way to do it in C. You can run your program under valgrind (or some other memory-checking tool) to see if it leaks memory. If it does, your function's wrong (or is called improperly). Assuming that always returns a valid pointer is dangerous. It may not. You need to check if its return value is not before working with it. is not a good name. It doesn't delete a hash. It deletes a key. It should be called correspondingly. It's not clear how you code behaves if the user tries to insert a key that's already in the table. Does it allow duplicates? What value does it return upon lookup in this case? Whatever the policy is, document it. 

will fail with if is not a valid representation of a number. You can do it by catching this exception: 

for parsing and validating command line arguments. for reading the words from a file and emitting random words. for processing user's input. A class that handles the game logic (and just it: no logging, reading input and stuff like that). A class for logging (like displaying errors and showing the output to the user. These two could be two separate classes, too). 

One method should be responsible for one thing. There're at least 4 different (very different) things here. In fact, I believe that the first thing (and probably the second and the last thing, too) doesn't belong in the class. Why? It makes sense for the counter to count occurrences and do just it. It'll make it more reusable. Think what happens if you want to change the output format, the way the user choose the file or just use it as part of your different project. I would redesign the it so that it has one method that takes a string and returns a map with different words and the number of their occurrences. The reading/writing stuff and the user dialog belong to a different class. These are different concerns. So I'd create another class to handle file I/O and one more class to interact with a user as these things have nothing to do together. They can change independently and they don't need each other to work. They're separate entities. You don't handle the case when the is (that is, when the user doesn't choose a file). A isn't very user-friendly. This piece of code: 

I have no idea what that means. What is ? What is ? Why do you sum them up? I suggest creating a method and add a comment that explains what's actually going on. 

The implementation of the and algorithms themselves seems correct(but it is a good practice to write unit-tests to make sure that it works as intended, so you should do it). However, your code in general is not correct. It definitely leaks memory: 

About the algorithm itself. I do not fully understand the algorithm you are using now, but it looks pretty strange(a bfs with a stack of queues?) and, as you have said, it is inefficient. So let's redesign it: 

You can improve the performance by using a more efficient algorithm. Instead of generating all possible combinations, one can count them using dynamic programming. The state is , where indicates which numbers were already used. A transition is adding a number such that it is not in the and is a prime. The answer is sum of such that is prime. Here is a pseudo code of this solution: 

There no need for a custom destructor anymore( handles it). Note that I have added this line: . Why is it necessary? We need it when the is and so is . In this line: , you should be comparing to the vector's size, not capacity(because it is an undefined behavior to access elements of the vector beyond size). More general notes: 

The number of dimensions is a compile-time constant. There's no point in allocating an array to store them dynamically. You can use instead. Member-functions like , and (which act as constructors/destructors) are a smell. You can write cleaner and simpler code using the copy-and-swap idiom (The idea is to implement a custom swap function and a copy constructor and then pass the right-hand side object by value in assignment. A move assignment and move constructor become essentially one swap). This idiom will also solve the self-assignment problem. Your code is broken now. If one assigns an array to itself, it'll get destroyed and will be in an invalid state. Memory allocation using and is not a good idea. Your code is not exception-safe. Let's go through this piece of code: 

It should actually be in the first line. You can reduce the chances of making such bugs by storing a shift vector for each direction in a dict and using a shift function: 

When there're comments in the code that tell what it does, it usually indicates that the following piece of code should be a separate function with a meaningful name. I'd create a separate function that the positions of the words to be modified (and it something like ) and a separate function that checks if a word already has a label. You can make your code more readable the tuples from the list: looks better than 

Your code is not working fine. Firstly, it prints the maximum number, not the maximum even number (you can check it by running it on the input ). Secondly, it's not that it's slow. It never terminates for some input. If the is 342, your code goes into an infinite loop as the number transformation go as follows: 342 -> 102 -> 120 -> 102 -> ... How to fix? The first bug is easy to fix (just update the maximum when the number is even). You can fix the second bug by building a graph for all numbers (with an edge a -> b if a goes to b in one step) explicitly and traversing using, for instance, depth-first search and carefully checking for the cycles.