Are there any edge cases I'm missing? Also, this doesn't seem efficient: First, there's an added dictionary. Second, there is a linear search on each iteration to check either the keys or the values of the dictionary. There's an \$O(n)\$ on the array resulting from the string, as well, but I'm not sure if we can avoid this. 

The following converts Arabic numbers to Roman numerals. I decided to factor each digit into its place value, then use a mapping to convert it to its Roman equivalent. For example, 1997 is factored to: \$(1 \times 10^3) + (9 \times 10^2) + (9 \times 10^1) + (7 \times 10^0) = 1000 + 900 + 90 + 7\$ The Roman numerals for those numbers are then retrieved from the mapping. 

For the sake of brevity I have not included the enter class, but you can see it here (65 lines). And here is a gist of my proposed changes. Only the and methods change. 

Your method has two hard coded dependencies. The first is the name of the class . Should Resolver's name ever change, or be replaced, you must make changes to resolve_url. This is more subtle, but it's a dependency nevertheless. The order of arguments that Resolve accepts is hard coded into resolve_url. Should those change, those changes will cascade down. 

Next up it's Board. Board was doing too much. It was keeping track of the players, moving them, keeping track of turns, etc... So I split it into two classes: Board and Game. First up it's the new Board. 

This example illustrates my point but it is not complete. You must wire the policy to the controllers, maybe include it in a concern. But it's not that hard. There's a great gem called Pundit that gives you similar interface. Asides 

You only need to sum the first 11 numbers to get the correct sum Take advantage of Swift's functional aspect 

The rest is self explanatory. checks to see if is not nil. I've isolated dependencies on and in their own methods. The only thing that may not make sense, which I omitted from player class is , this is just a convince method for to check if the last rolls gets it over the winning line since the player can't move off the board. 

But since Rails is pretty well tested, I feel like I can trust its JSON return. I'm not sure if this approach makes my tests brittle, since any change in the response body will cause the tests to fail. But maybe that's a good thing? Here's another example: 

If I find an opening bracket, I add it to an array. If I find a closing bracket, I remove the last element from the array and check if the brackets are a pair. If I find neither an opening or a closing bracket, the string must be invalid. 

The method returns an Enumerator object, which responds to the method. The enumerator's size is the number of jumps (or loop iterations) that the frog needs to reach its destination. can take up to two arguments; the first is the goal, or the value needed for the enumerator to terminate, and the second is the value by which to increment the goal. 

Outside of the jQuery DSL I've hardly ever written any JavaScript. I never bothered learning JavaScript until a couple of months ago. After a slow start I got stuck in and created this game today. I usually program in Ruby, and this is proving to be an obstacle because I'm thinking in ruby while writing JS. The code may come as a shocker to experienced JS programmers. My greatest challenge is to separate presentation from logic. I haven't figured that out yet. This is a case of knowing the syntax without knowing the language well. I'm interested in comments about structure. I know this is hardly maintainable code. It's obvious. What is not obvious (to me) is how to make it maintainable. I'm only adding the JS code here, but the entire game is included in the snippet below the code. 

You could refactor your block into something like this. But I don't think this is a good idea. I'll explain why below. 

Then you don't need to pass the credential to the initialize method. But you can should you need to. 

Some would argue that a service object adds a needless complication. They may have a point. I think it depends on each use case. 

This refactoring addresses concerns one and two regarding the mechanic. To some extent. More on that later. 

I honestly think your first version is the best one. It's readable, and makes more sense at a glance than the refactorings. That said, I would consider a couple of things. 

I'm looking for feedback on this live-filter I wrote in JavaScript. You can test it using the included snippet. 

When integration testing Rails applications HTTP request helpers can take a string or a named route as the first argument. I find myself writing: 

A snake's head can't be on the last square otherwise you can't win the game. A ladder's base can't be on the last square since there's no where to go. A square can not contain the base of a ladder and the head of a snake. You either slide, or climb. Players start off the board. 

I would suggest using a service object. I would like to see what others think about this. It looks like there's too much going on for the controller. The controller should be responsible for execution and value return. The model for processing the object. The service for wiring up the object and giving it prepared params to do its job. This is not tested, but just to give you an idea. I would go further and condense the and methods in the model so that the service just receives an error or an OK to give back to the controller. 

I watched a presentation by Dave Thomas on Elixir where he gave an example problem that he solved using functional programming. He mentioned using Ruby to solve the same problem, but did not show an example. I decided to give it a try. The problem goes something like this: For a list (Ruby doesn't have lists, but for our purposes an Array is close enough) of n numbers, create a new list where unique numbers are represented once, and repeated numbers are represented by a tuple (again, Ruby doesn't have tuples, but for our purposes a Hash or an Array would do) where the first element is the number itself, and the second is its count. For Example, the following list: 

I improved with my second iteration, but it still relies on iteration. I narrowed the range down reasoning that the largest palindrome is likely to be the product of two numbers within 901 and 999. This time I multiplied all the numbers, but only saved the palindromes in the array, then selected max, which saved a step. It's noticeably faster, but still not optimal. 

How can I improve this? If there a better way to get the unique teams from the match info? That parts looks convoluted. I also feel that the method is too large. 

Flambino's answer is great. I will add another way to solve this; although, as Flambino points out, it is a math problem and loops aren't needed. That said, you can use an Enumerator. 

As pointed out in the comments, I would use a name other than and . Your example code is lacking context, so what I'm about to say may or may not be applicable, but... 

It accepts a grid. A grid is just a has to cells and portals. It doesn't care what, and how. As long as it gets a hash, it works. The old method had a bug. If a player rolled in excess of the board size, it would exit its cell, even though it had no where to go. The new fixes that. The player only exits if it enters another cell. If no movement happens the method returns nil.