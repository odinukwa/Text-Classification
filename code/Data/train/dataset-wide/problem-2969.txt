Using is better than using the properties of , because of Single Responsibility Principle If that was too fast for you: Step 1: 

Imagine if I put some code in the same package and did Now I broke your program! This one needs to be 

That is a really bad name for that class. Here you have to write the fully qualified class name because of Android's class, which is not something you'd want often. Moreover, I don't really see the purpose of that class at all. It is just a wrapper for a , and an unnecessary one. This part can be changed: 

Then you can replace these lines in the rest of your code with or . I suggest naming the parameter to something that makes more sense for you. 

However, as this would make it hard to remember the ordering of the parameters, I suggest that you look at the Builder pattern 

This way it is always up to the caller to pass a valid age instead of the method defaulting to zero which will bring other problems. It is better to have your program break early because of a bug than to have a warning message be printed out which may indicate a bug. 

Your actual code While reducing the code duplication for the individual buttons is important, let's take a look at the code that is actually performed for each button! Step 1. Adjust spacing to adhere to the Java coding standards and remove unnecessary parenthesis. Step 2. is used in both and , so put it outside. Step 3. In the part, you're doing the same thing no matter if and is the same or not, so reduce code duplication by simplifying that logic. Step 4. Remove empty statement After these steps, the code is: 

Player Everything fine except for the method which I don't think is even needed, as any code wanting to print the hand can call 

This is a bubblesort algorithm. However, on some places you use the significantly more effective method. I recommend writing s for the different ways you want to sort by and then use . 

Where the implementation of those methods could either be or , if you add such private fields that you initialize after you've read the config file. Testability, Dependency Injection Why is this even a singleton? It's good that you have a method that takes a so that you can use different configs, but your code leaves some things to be desired. 

That all really depends on one thing and one thing only: How costly is the operation? Secondly... OK then, maybe two things: How often do you plan on calling this method? If the operation is cheap, I would use the return directly version. If the operation is costly, use the approach with the variable. Additionally, if this is a multi-threaded environment - or rather, when this possibly becomes a multi-threaded environment - the first approach goes out the window unless you synchronize on some lock (which will add some additional overhead). The first approach as it looks today is not thread safe at all. 

Using is not a good practice!! Instead of using , use a do-while or a loop. You want to do something as long as the answer to "Do you want to continue" is "Yes". This is perfect for a do-while loop. You should also avoid using and instead use a for-loop to iterate through the array. It could also be solved with recursion. Use anything you want except the statement! 

Adding to the things Max wrote, to make sure that you don't make the same mistakes again I wanted to point out several things regarding your current code: 

Why are you creating all these classes if you end up hardcoding all the values anyway? There are two parts especially that I would make more flexible: 

The first thing that comes to my mind when I read your code is "this would be a good job for a template engine". File constructors 

You don't need to use , use instead. The difference is that is a primitive type, which means that among other things it cannot be set to . 

I see absolutely no need to have these as . As it is right now, your code would get problematic if you instantiated one , waited for a while, and then created another game. Each should have it's own and values. 

First of all, there are only three specific keys that you are interested in, so there is no need to loop over the map. Just grab the keys that are interesting and see if they are null or not. Secondly, it's possible to extract a method for increasing the actual card counts in each map. 

Honestly I believe you have answered this question yourself: The app works just fine. From what I can see, you are using the intent exactly as you are supposed to. You are also using properly. But, because you have come all the way here I guess you want to hear some suggestions/criticism as well so I have tried really hard to come up with something: 

You seem to always end with the check: Is there another parent? Or as it can be formulated, while there is another parent, grab that parent. Luckily for you, there are while loops. 

Now let's say that I have a , simply by Then I would be able to do: and viol√†, I have changed your 'constants'. An array is mutable, so it is possible to change the values of it. And as your variable is , it is possible to access it from other classes. This is why those variables should absolutely be private. And as they are meant to be used as constants, they should also be static. 

My version: This code is still quite similar to your code. The hand still , but the number of lines has been reduced by about 25-30 % (I might also have changed a few things to get it to compile, as I don't have some of your other classes, so read and see what I have done, and apply the things you want to your own code). 

You're also inconsistent with arrays: or ? Prefer the second one. Using spacing like is better. And your method calls: 

You have several different options for this: Guava Google's Guava Library introduces the idea of a Multiset which is capable of counting the occurrences, and also provides a couple of other features. Java 8 If you are using Java 8 (which I highly recommend if you have the ability to do so), your method can simply be this: