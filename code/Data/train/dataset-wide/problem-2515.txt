which is duplicated in the second arm of your statement, but with player 1 and player 2 reversed. I would change your function to return a list or tuple of the new player states, instead of modifying them by side effect and then reassigning them into the list. Something like: 

Regarding the code inside the block in , rather than trying to minimize that code, I would think about what other exceptions you might be able to catch and handle at that point. Try doing some of the other calls from that block of code in the interactive prompt, with invalid data, and see what they toss at you. I don't think it's too much code anyway. I wouldn't put it in a separate function; while it may be several lines of code, it feels "mainy". As you say, it's the meat, or maybe more like the backbone: it provides the structure that binds together all the other code. I think it's fine where it is. I see some issues with your use of exceptions. Regarding the code inside : 

Caridorc gave you a lot of good suggestions for rewriting your code. I would just add one thing: if you're just getting started with Python, I recommend using Python 3. From your use of and without parentheses, it seems you're using Python 2. It's good to be aware of Python 2 since there's still a lot of it out there, but Python 3 is the future. Although Python 3 isn't backwards compatible with Python 2, it's not like the case with C++03 and C++11 or Perl 5 and Perl 6 where you essentially have a new language. Python 2 and Python 3 are about 90% similar in the core language. And the last version of Python 2, Python 2.7, has several Python 3 features backported to it, including the function. So if you learn Python 3 and then end up having to work on Python 2 code, you won't have much trouble learning the differences. Aside from that, I would just recommend carefully studying the code that Caridorc gave you. It's a very clever and concise way to write this program. 

Your code is written in a very Java-like style: your methods don't return values, but operate by mutating class instance variables. There's nothing wrong with this per se, but it does have some negative effects: 

A program like this, that seems to be a command line utility, is probably better served by taking command line arguments than by interactively reading filenames. That's the next direction I'd go in. The simple way to do this is to read . If you've ever done bash, is the script name, just like , and are the positional arguments passed on the command line, just like , , etc.: 

Even if this function is only used once, the code inside is ugly enough that the call site will look nicer without it. The same is true for a lot of the calculations in the main of . You asked where macros might have been helpful, and I see one obvious place. You have the code and all over the place. You could write a helper function or macro to shorten that up, maybe something like this (as a function): 

Here's a gist with the rest of the code, including the private helper methods. Although the current code is Java 7, I plan to switch to Java 8 in the near future, so suggestions for where I could make good use of Java 8 features is also welcome. 

This makes testing easier; I can pass in whatever I want without having to build any context, and I can check the return value. Using return values also lets you use doctests, which are one of the cool features of Python that no other language I know of has. 

Rather than print a message from inside this function, I would probably re-raise with a new message: 

Then you could do destructive updates to the game state much more succinctly. On the other hand, having a giant, monolithic variable being passed through every function is sort of not functional to begin with. In the following code, I'm going to treat as a global, because if you have a mutable variable that you always, without fail, pass into every function, wherein you make destructive updates to it, you basically have a global. Let's cut the clutter and just treat it as such. James Hague discusses this issue in Purely Functional Retrogames Part 3 and Part 4, and I'll go over what he says below, but for now, we'll have a global game state, because I do prefer that having a global game state that takes up space in the argument list of every function. To get out of doing destructive updates, Hague suggests unpacking only the pieces of the game state which are relevant to a given function, passing them in, and returning a value which represents the effects on the game state to the main loop. The main loop can then update state based on what value it gets back. This would get rid of a lot of the calls to in your functions; you could bundle up all the necessary changes inside the functions, return those changes, and then have a single at a higher level that makes those changes. With this kind of system, you might move between quadrants something like this: 

But consider cutting down on the amount of context your class stores, passing more things in as arguments, and returning results, e.g. make take a directory and a list of allowed formats as arguments, and return a tuple containing the list of found movies and the list of skipped movies. Then you could write something like: 

Overall your code looks pretty good. It would be nice if you broke your lines, though; they're very long right now, so I have to scroll horizontally to read them. You also mix naming conventions in a somewhat weird way with . It would be better to stick with one convention; you've chosen camel case, so or . is quite long, and the nesting gets pretty deep, so it might be good to try and break that out into separate functions. I'm not sure why , , , or have to be instance variables (which they are, if you write ). It looks like you're defining and using them within just one method, so they can be local variables. 

Now is longer and a bit uglier. But this way, all the logic for is in . You expected to return a vector of vectors, but as it was before, relied on processing each line into a vector, so the logic of one function was spread across multiple functions. Notice how the whole thing is now separated into a general portion, the function, which could be useful again later on when you need to read some lines from a file, process them in some way, and return them in a sequence; and a specific portion, , that contains all that bits which are only relevant to the problem you have right now. Pursuant to that, I don't really like that is private. It seems like a perfectly good, general, widely useful function. For example, suppose we have a CSV file with columns , , and , separated by spaces. Then we could write: 

I would prefer not to catch the here. Letting an exception go uncaught will just stop the whole program, which seems to be what you wanted. Some other languages force you to catch or declare every exception, but Python will just bring down the whole program around you. That's not what you want for production code, but that is absolutely what you want for development: anything anomalous will make the program crash and die right away, with a reference to the line number where the crashing and dying occurred. As a bonus, it's quicker and easier to write the code that way, because you don't have to add blocks around everything. If you can do something about the invalid input, then definitely catch the exception and do something. But if all you can do is say "You screwed up, fix it", then why not just let the exception be thrown? This piece of code from could be a lot shorter and cleaner: