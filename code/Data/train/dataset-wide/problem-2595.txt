Once a child receives his share of Chocolate, he leaves the queue. The remaining portion of the Chocolate bar is dealt in same fashion and the whole or a portion of it is given to the next child in the queue. School has got a carton of Chocolate bars to be distributed among the children all over the School. The Chocolate bars in the carton are of different sizes. A bar of length i and breadth j is considered to be different from a bar of length j and breadth i. For every i such that M<=i<=N and every j such that P<=j<=Q (where M, N, P and Q are integers). Each Chocolate bar in carton is unique in length (i) and breath(j). Given the values of M, N, P and Q (where M, N values are the ranges for length of Chocolate and P, Q values are the ranges for breadth of the chocolate). Find the number of children who will receive Chocolate from the carton. Input Specification: M, N, P, Q are of integer type (M, N values are the ranges for length of chocolate bar. P, Q values are the ranges for breadth of chocolate bar). Output Specification: Number of children who will receive Cadbury bar from the carton. M = 5, N = 6, P = 3, Q=4 Here, i can be from 5 to 6 and j can be from 3 to 4. So the four bars will be in carton of sizes 5x3, 5x4, 6x3, 6x4. First we choose a cadbury bar of size 5x3 → first child would receive 3x3 portion ( remaining 2x3 portion ) → next child would receive 2x2 portion ( remaining 2x1 portion ) → now the remaining portion are 2 square pieces of (1x1), which can be given to 2 more children So the Cadbury bar with the size of 5x3 can be distributed to 4 children. Similarly we can find out number of children for rest of the combinations (i.e. 5x4, 6x3, 6x4) in the given range as follows 

Please let me know the corrections that I can make to improve the code. Please tell me your opinions so that I can improve myself. 

Output Specification : Minimum number of stones required to make K pots overflow in worst case or -1 if input is invalid. 

With an enum, it should automatically use the individual enum values as the selected value and display the enum values' .ToString result in the control. If you use localization strings, it's a little (but not much) more complicated. Instead of binding enum values directly, you will want to bind a list of objects with the enum value and your localized string representation for the value, and then set the DisplayMember and ValueMember properties to the appropriate fields on your bound objects. Once again, that can be done through the designer (under Data again) or through code, as follows: 

Dispose all the things While you have a using statement for your connection object, there are a few other objects which implement you missed. Both the command and reader objects need using statements. Naming The method doesn't set anything. It would be more appropriate to call it , since you are retrieving information. Your variable names could use some work as well - they are somewhat inconsistent. Some have prefixes, while others do not. Some are camelCase, while others are PascalCase (the convention is camelCase). I left these changes as an exercise for the reader :) Use well-defined data objects I also noticed that returns a which contains various user detail properties. It would be better to create a data structure to hold this and return it instead: 

Honestly, it looks like you want to use a domain object to model your providers and perform the pay calculations. Rather than using a bunch of text fields and drop-down controls, you can then data bind your domain object to a . Domain Object You want an object which has properties for all your display values. Since data binding is involved, you need to ensure the object implements the interface, like so: 

Initially, I shared your concern over resource disposal. My assumption was that there was the possibility the command could be left hanging around in cases where you did not enumerate over the entire collection (as with something like FirstOrDefault). However, a few quick tests with a test project reveals that the using statement performs its clean-up as soon as you are done with the enumerator. A LINQ statement or a foreach loop may only partially traverse the results, but they both still clean up the enumerator when exiting scope. Keep in mind, though, that there is still potential confusion that might arise from the deferred execution of GetSomeData. The command doesn't execute until you start enumerating the result. If anything were to modify the data before between the time you call GetSomeData and when you enumerate the result, you could get different results than you expect. 

Well, yes and no. If you absolutely must instantiate classes by name as a string, and you absolutely must have exactly one namespace for classes, and you absolutely must not use the object or a module scope as that one namespace (i.e. just declare a function in your source), the way you're doing it is probably the simplest method. I would add a to make it more user-proof. However, for all the same reasons as above, I would again have a good hard think about how badly you need to instantiate objects by the name of their class. If you want to actually do reflection, you'll need to re-implement by name, etc. etc.; if you want to segregate your classes into namespaces or give them any other kind of scope, you have to re-implement scope. 

Again, that will change a few things logically throughout your code and header, but it will end up far cleaner and clearer than it started. You've got pointers to pointers in C, an often underestimated advantage over other languages, and so far you're doing great with them. If you can handle using them for pointers to arrays of pointers, you can handle using pointers to members as objects. Other than that, the nature of the task demands a bunch of hairy pointer-chasing and a little bit of pointer math, which is tough to read. Stuff like takes a second for me to digest fully. If your comments were at all lacking, I would want some of the longer statements to be broken up and have some intermediates made into local variables with names. However, your comments spell out what's going on very clearly, so I don't think that counts against you. 

I apologize for my lack of GCC fluency in advance - I have only used MASM and RosAsm for x86, but I will try to translate. This review will be in top-to-bottom order, not in order of importance. The first thing I would do is evaluate whether you really need to use cdecl calling convention. If you're only calling your function from asm, it makes sense to pass the source and destination in and , respectively, rather than putting them on the stack and then loading them. Next, instead of , I would do: 

That will only require 4 fetches per dword, and is perfectly readable (as far as asm goes...). The bit twiddling hack does it with just one. With regard to your instinct that family instructions would be better, I believe you're sadly incorrect. If you learn any other assembly language and try to use strings, you'll certainly appreciate the effort Intel originally put into providing special string instructions, but they haven't really optimized or extended those instructions with the same zeal as one might like. Further, you can't , because doesn't set any flags. If you ever do end up , remember to =D. This might seem like a long list of complaints, but for having first seen assembly 4 days before writing this, it's remarkable that you can do anything useful. Cheers.