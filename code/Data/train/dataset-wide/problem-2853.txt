We are only interesting in the count of matching elements. To improve the performance, determine the count without creating an intermediate array: 

Another suggestion is to make the method generic, so that it can be used to find a parent view controller of any given class: 

Each element is the result of applying one query to the given numbers, this can be simpler done as a operation: 

is not needed, the remaining code already handles the case of an empty string. Determining the unique characters from can simpler be done with a filter operation instead of a for-loop: 

For it is 501 iterations vs 2. It is obvious that the required number of iterations in the original (subtraction) method can be arbitrarily large. For the second (remainder) method, it has been proven that (again from the Wikipedia page) 

Your code works correctly (as far as I can tell), but it took me a while to understand how it works. 

But there is still a chance that the error remains undetected during development and the deployed application crashes later. 

since all primes less than have already been found. This reduced the execution time of my test (code below) from 2.26 sec to 1.17 sec. A possible further improvement is to treat the only even prime separately and then handle only odd numbers: 

Yes, but the j-loop still traverses over the entire array. Instead of replacing the found minimal element by , you could replace it by the last array element, and then reduce the upper bound for the j-loop accordingly: 

Finally: Your enum has a case for "no state". But the Swift way of representing "no value" is to use an optional: 

That increases the clarity of the program, and allows you to add unit tests easily. Iteration over all array elements can be done with a "for-each loop", that saves the repeated array indexing and makes the code better readable: 

Note how a "enhanced for statement" can be used to iterate over the array elements, instead of a for-loop or a while-statement for the array indices, as in your code. There is also no need to use a or floating point literals when doing an integer remainder calculation. 

which becomes apparent only with large input: A negative sum must also be reduced modulo \$ 10^9+7\$, before adding the modulus to make it non-negative. Putting it together, your code would look like this: 

Strictly speaking, your output is not correct, as the problem asks only for the first 10 digits of the sum. This would be done with 

to get the last path component of a file path. Apart from special cases (such as escaping closures), properties can be accessed without using : 

What if the difference is exactly one month and 0 days? The first two if-conditions should therefore be 

While this could all be fixed, it probably isn't worth the effort because there is a Foundation class which already does exactly this: 

Note that is not necessary to access instance members. Or use image literals, a feature introduced in Xcode 8. You can simply type the name of an image resource in the asset catalog. This will be autocompleted to , but displayed as the image itself 

Then and should be computed only once before the loop starts, and not for each loop iteration. There are also problems in the analysis of the computed date components: 

method searches only one level deep for the first responder. You could implement it using the recursive search as 

So it is good practice, and you need not worry about the performance. Note also that all Objective-C APIs from the Foundation and other frameworks which return an , are imported into Swift as ing functions. By throwing an error (not an exception!) you can inform the caller that the method failed and provide additional information about the problem. The caller has the options to 

That makes the code shorter and safer: If you add another enumeration value later, the compiler will check that it is covered in the switch statement. There are several places where an array is created incrementally using , e.g. in JPSNeuralNetworkNeuron.swift: 

Instead of you could log if any of the socket functions fails. The error message string would be more instructive than a error number. For example: 

Finally: You can replace the loop by recursion, using the method of and the nil-coalescing operator : 

The task is about dynamic arrays, and using an array (instead of a dictionary, as you did) simplifies things considerably. If you start with an array of empty arrays: 

Adding more sorting criteria is straightforward with this approach. A possible disadvantage is that can be called multiple times for the same phone number during the sorting process. That can be avoided at the expense of additional storage: 

Coding style There is a well-established coding style for Python, the PEP8 coding style, and conformance to that style can be checked online at PEP8 online. In your case it reports “missing space around operator” in almost every code line. Variable names , , are meaningless variable names, and isn't self-explaining either. Magic numbers The number in 

Your method works correctly, as far as I can see. But it creates an for every node in the tree, i.e. it uses more memory than necessary. Each call to the method of the generator then traverses down the methods along the left or right subtrees, which makes it slow. An iterative approach using a stack instead of "nested generators" seems to be faster. Here is a possible implementation of the iterativeInorder algorithm described in Wikipedia: Tree traversal: 

(also making the obsolete.) Mutating the temporary string can be avoided by working with a (which is a kind of view into the original string) and only updating the current search position: 

will not be available in Swift 3 anymore, so it could be a good idea to start replacing that by in your code. 

This method needs about 0.0002 seconds to find the solution (or it's non-existence) in all three test cases (sum = 1000, 928, 1001). One note regarding your function name: It might be unclear what is "special" in . Also the "Coding Guidelines for Cocoa" recommend the "get" prefix only for functions that return some value indirectly. A better name for your function would be something like 

Note also that no block is needed if the block has a return statement. This saves indenting levels. Then you can use list comprehension 

so that can be used for a variable without causing confusion. (This is of course opinion-based.) Hashing You don't need to implement 

The input lines can contain up to 1,000,010 integers, which means that many temporary string are created. An alternative is to use from the Foundation framework to read integers directly from the string. And since the number of integers is known, we can call to avoid reallocations while the array grows: 

If you don't need the reference semantics then it is preferable to define a (and mark methods as where necessary). Access modifiers You added public/private access modifiers, which is good. But I don't see why the properties of are declared if the type itself is . It should be changed to 

would be one possible solution, but the better way is to use an enumeration which can take exactly two values: 

which returns the unqualified class name of the given class (in contrast to which returns the fully qualified class name including the module name). 

On my computer (with the program compiled in Release mode), this reduced the time to compute from 0.065 seconds to 0.002 seconds. (The rest of this review is about the code organisation and might be opinion based.) I would pass the given digits as an argument to the function. One advantage is that it is easier to add test cases. 

(Unfortunately, there are many integer types and I don't know if the repetition can be avoided.) Now you can restrict the type to . Alternatively, take a different approach and make the pack/unpack methods operate on the type itself by defining a protocol extension: 

In you use list comprehension to split a row into numbers – why not use list comprehension as well to split the input into rows? 

the can be eliminated by calling either or with instead of . Also your code produces three output lines for a single-digit input because and is called even if . Together: 

fails, or does not return a , then you did not configure the table view correctly in the Storyboard. Such cases should be detected during development. Therefore it is better to abort with a runtime error instead of "hiding" the problem and returning a plain . This is a valid use-case for a forced cast: 

( flushes the output file in addition to writing a newline character, which is not necessary here. On the other hand, it does no harm because this part is not performance critical.) In the inner loop, an RGB triplet is appended with 

You restrict the scope of the variables to the nearest enclosing scope with , which is good. The use of whitespace is not consistent: vs . The variable names seem a be arbitrary: Why and , and not and as in the LeetCode problem description? The first you can do to speed things up is to "early return": 

instead of converting the to and searching that as a substring. (But using instead of your own splitting function as suggested in @milos' answer is probably the better way to go.) 

Note that I also declared them as constants because the properties are never modified after initialization. Simplify the decoder, utilize optional chaining This 

I am not familiar with the Firebase or DKImagePickerController framework, so I cannot say anything about that. But there are some things that I noticed: There is no need in Swift to reference properties via (unless there is an ambiguity with a local variable, e.g. in an init method). And you are not consistent here, e.g. both and is used. 

and this reduces the time to 0.016 s. In you are using a tuple with named components internally, but return an unnamed tuple . In the calling function the return value is assigned to a named tuple again. I would recommend to stick to one variant, e.g. the named tuple: 

First the class: You have defined as a variable and optional, but actually node elements are cannot be and are never mutated once a node has been been pushed on the stack. You probably did that because you create "empty" nodes first and then call the method to set the element and next pointer. Another reason is that you use nodes "without an element", but I'll come back to that later. I would suggest to make a constant and non-optional and replace the method by an method: