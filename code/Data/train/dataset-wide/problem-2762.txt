I'm not a fan of classes that are called a plural but aren't actually a collection of items: , , etc. This gets especially bad when they're properties: 

Your comment style is inconsistent. I'd put the on the line above the method, not next to it on the same line or below in the method's body. Also, is it even necessary? 

: is this supposed to be a field or a property? If it is a field it should be , if it's a property it should be PascalCase and should have a getter/setter. 

Part of the 50+ lines of shenanigans with (bad name since this is a ) should be moved to a separate method; perhaps even a separate class. 

Is there a reason why you use WinForms? Quite frankly I feel the technology is outdated; WPF offers you far better ways to do the same thing. For instance, you can use MVVM. 

There is also the presence of several magic strings, which reappear elsewhere in your code (the ). This indicates to me that these values should be s in a separate class, so that should there ever be a need to change them you only need to do this in one place. I would even consider something like this: 

There is no good reason for you to make 4 separate calls. Most likely a single call for would be enough, but even if you have a pressing need for them to be on separate pages, you should still 4 pages in a single call. You don't need to open to get anonymous memory, just pass as the FD and add the flag. 

Note that it does not return indirect subclasses, only immediate ones. You might also consider what happens if some subclass of is itself abstract. Speaking of which, you should be using and . 

Likewise, it is exceptionally rare that allowing mutation of a string after construction/assignment is actually useful. This makes the constructor nearly completely useless. 

You're matching the regexes in a loop, giving it \$O(n m)\$ performance instead of \$O(m)\$ where \$n\$ is the number of regexes and \$m\$ is the length of the text being matched. Any halfway decent regex engine can match an arbitrary number of regexes simultaneously and then tell you which one matched (a trivial extension to the way is matched; I've done this in C); I am not familiar enough with JavaScript to know if it has one. Possibly since these regexes are fairly simple, you could capture a fixed piece of text and then use that in a dict lookup? 

Then you could use that class, i.e; fill it with the necessary data, call and pass that class as the param, and use the method when you call . 

Now all I needed to do was assign the proper values to the properties, and pass this class to the method where I needed to use the parameters. Is this the ideal way? Not if I had to create a dozen of these classes, no: then I'd made sure to use reflection to figure out the type of a property so I could return the proper OracleDbType, I'd have used an attribute on a property to store the parameter name, etc. 

Your method is 140+ lines long. Even when you apply the above, it still is doing multiple things. Split it up into smaller methods, e.g 

What if you need to add another, e.g. ? As Heslacher's answer shows: move this to a separate method, and consider moving etc. to a collection of "valid" WorkCenterNumbers, thus reducing the code to: 

If you want to keep it a method, you'll need to change its name since a method name should contain a verb. More worrying to me is that you repeatedly call this, so it is repeatedly calculated, but this is pointless since won't ever change. Right now if is 10, gets called over thirty times! If you don't need to expose this it could simply be a private field which you set in the constructor . Even if you need to expose it, I'd still advice you to set a private field in the constructor and have a -only property to expose it. 

If you don't like nasty bugs, always use for allocation sizes, not . Yes, somebody will do it, this is a fatal flaw in the Qt libraries. You're missing move constructors/assignment. Most likely they should be implemented by moving the ownership logic out to a separate class (if you don't take all of my advice, would work) and then using the Rule of Zero. There's no point in providing a method (this is a flaw of ), you can just use on the iterators (that you need to implement). Most implementations use instead of , or even just a single member which points directly to the string data. and stores size/cap information at offset . Newer implementations often use SSO (Short String Optimization) as well. You're missing slicing operations. Slicing operations should return a class though, instead of allocating a . You're missing , which most people want from a string. Though I'm not convinced it's useful; I treat strings as opaque blobs rather than containers. If you choose to have mutable strings (see below), you're missing , , and . In either case, you're missing . You're missing , , etc. These should allow mixing with . 

In my experience providing or on strings is a mistake. Instead, strings should be constructed via one of: 

Why do you use ) when you don't do anything with ? Why not use ? Oh wait, I see, you've called your collection -- a bad name, since this doesn't tell me it is a collection of lines. 

But when I then stepped through the logic, I found that this still does a number of things that don't seem necessary. And I distilled it down to this: 

What is ? An ? I don't think that class should have a plural name, and it doesn't look like it is an "email name". 

, , etc. all implement and thus they should be encapsulated in blocks. Instead you tie to a singleton class, which is the opposite of that. Here's how they should be used: 

has eight parameters. That's waaay too many. Instead, construct a class where each of those params is a property, and pass that class. 

So what's left are the shenanigans with the . Which seem over-complicated and make it hard to determine the logic. Here's my solution: 

Though I have to say there's still too much repetition there and thus room for error, but I fear that's inevitable when you want to stick to s. I would also consider moving repeated logic like this: and . There's a lot of repetition there, which suggests it could be moved to a method, something like this: 

That said, your short-circuit if the lengths mismatch is a good idea no matter which implementation you use. There are some style issues that jump out with your implementation: 

Any memory that you read/write from multiple processes (or threads) must be protected either by some sort of mutex or by atomic operations with an appropriate memory order. It would not be enough to . So the following line may be optimized to be an infinite loop: 

All of the above, except for the last two which are special, provide exactly the same public API (except ) and can be implicitly constructed from each other if it makes sense. 

Most python users would just use . That's \$O(n log n)\$, which is not that much worse than your \$O(n)\$ solution. But the code you've actually written is just a reimplementation of: 

That way it can be run directly with (and possibly other harnesses, I know the standard requires wrapping them in a dummy class, but I haven't used any others). 

There are a lot of functions that aren't safe to call in a signal handler. For the few that are allowed, look at the Async-signal-safe functions section of the signal(7) man page. Your current signal handler is almost okay, but any variable that might be changed from a signal handler needs to be declared . Officially it must also be instead of , though I'm not sure how important that is on real-world platforms. You should be checking the return value of and . They will return (which is usually but could theoretically be any negative number) with set to if the signal has been delivered during the underlying system call. That said, there is nothing to prevent the signal from being delivered before or after the syscall itself (before is the nasty case, and doing the syscall yourself won't help unless the signal is blocked around the call). If you want to handle signals in any sort of sane way, you need to them, at least some of the time. Either then unblock them during "safe" runs of code and check the flag periodically or else leave them blocked call (which will not invoke the handler). 

That way it would be easy to add additional parameters. Or perhaps you could simply store instead of etc. after all validation is complete, to comply with DRY. 

and are virtually the same method and could easily be reduced to a single method with two parameters (, ). And does there really need to be a block around this? Does this functionality even need to be in a separate method? Why not just call ? 

I would even urge you to move that outside of this class and parse the arguments you're sending to this method before you call it, so it can become: 

Is there a reason why your code is littered with class name prefixes like "Interfaces." or "DataAccessLayer.DataTransferObject."? Those make your code harder to read, IMHO. 

Could you also indicate what kind of project this is? I'm guessing Windows Forms, but it would be useful to get a little more context. 

I'm a bit worried about how this one method seems to be dealing with distinct requests. The value of for instance is only relevant for a small part that involves neither nor , so why then clutter this method by inserting that logic here? Why not instead have: 

Also, be consistent in naming : . I would expect the database field to map to the property , instead it's called . 

Instead of , use to avoid precalculating and storing the entire sequence in memory (and also spawning an unnecessary subprocess). Instead of , use to name the argument then use . Note that is an alias for , but it's idiomatic to use for assignments and for expressions. Beware of the possibility of failing! Using an chain as @glennjackman suggested will avoid this pitfall. It would also be possible to replace with but that's ugly IMO. 

By the way, \$O(2n)\$ is equivalent \$O(n)\$. However, the bound is actually tighter: \$O(n + m)\$, where is the number of distinct elements. This is, however, an average bound, because it relies on a . If the worst case hash collisions happen, you get \$O(m(n+m))\$ 

My preference is to then use so that I can stuff it in a or or set along with any other read- or write- file descriptors. 

If you're using , you shouldn't have the shebang in the second script. If you're using the shebang, you shouldn't use . But rather than use directly, I would the script once at startup, and in it define a function that was called at the later times. You should use instead of to avoid forcing a separate subshell to spawn. I would provide a default instead of exiting if no argument is passed. Something like . Also, I always use named variables as early as possible. Note that if you were using a function (with or without ), you should use to avoid leakage.