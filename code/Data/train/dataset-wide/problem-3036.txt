If you are driven to get the absolute best performance, there are a number of things I would change. These changes will not necessarily improve the readability, but the performance will be best. First up, creating a each time is going to slow you down. This may well be about half of your time, in fact. I recommend a static version if you can be sure you won't have threading issues, or alternatively I would recommend a ThreadLocal. In general a ThreadLocal is the better option because even though Random is thread-safe, you don't want contention when it locks one thread against another. The second thing is "Why use a List?". Seriously, it's overkill. Use a primitive array, and preferably use char..... String concatenation is slow, so the is essentially the same as: 

All your EntryParsers should then be updated to have this new generic type. Abstractions You have far too many layers of abstraction in your code. Whenever you see 'marker interfaces', I get suspicious, and you don't only have marker interfaces, you have inherited markers? 

You have immediately 'un-nested' a large portion of your code, which makes readability better. When you write code to match a specification, like you have here, it is valuable to include the specification you used inside your code, which, you have also done... but, do that before the code, not after it. If you have an if-else block, and the if-side (the true side) always does a , then there is no need for the . This can simplify the code further.... Performing these changes, we get to: 

The point is that it is very bad practice to have returns in the finally block. Don't..... EDIT: Update to include a better solution.... Use Java try-with-resources (since Java7). 

set up a separate thread that loops for each , and the Constructor takes the port number, etc. The code would look something like: 

See how, as you go, you can "shift" the value from the one side to the other? This makes the solution a simple \$O(n)\$ complexity. 

What am I saying there? I am saying that the Matrix can consist of any combination of values that may have an Iterator. The mnemonics I use there are that: 

Well, when you decide to something as a learning exercise it's normal to tackle just one problem at a time. In your program you have databases, object-relational mapping, JSON encoding, OAuth protocols, closures, REST, and more. It almost makes me a bit sad not to see slices, channels, and go-routines in there. What happened to the good-old FizzBuzz? Your ambition here is admirable, and I understand the motivation to accomplish something meaningful (a cool slack-bot is awesome), but I worry that you'll maybe miss some details in your haste. General In general, your code looks like it has been through the wringer a few times, and it has wrinkles, and a few worn spots. While it looks like you are already in the habit of running your code through the routines, you should also add and to your tools. You have a few issues I can see off-hand: 

The above code takes each value, and, if it's even, it 'inserts' it before the odd values. The above algorithm draws a number of similarities to the insertion sort, which is, surprisingly, very fast for smaller data sets. 

Right, options gone... Filtering Let's look at the filtering now.... and, remember, in Go, functions are "first class" which means they can be a type, or variable. 

we declare S to be self-referential, and then we use to declare the type of which is a . Using these classes is surprisingly easy: 

I literally fell asleep with an answer mostly built.... and now that 200_success and palacsint have covered pretty much my complete answer. I have to reiterate though that the use of will be your worst performance culprit. Also, (as I learned recently), your code will not handle surrogate Unicode characters well (it will reverse and thus break them). So, I had put together some code which I believe will be much faster than yours, it will handle space and punctuation in a very different way to yours, and it will correctly not reverse surrogate pairs in the text. The reason this code will be faster is because it converts the input String to a single char array, and it does not create any other objects until the end, when it converts the array back to the output String. 

efficient Mostly, yes. The inefficiencies in here are all related to the IO, and the Scanner, not your code. A more low-level API may net you some performance benefits, but not likely. You are also (re)using the Random class well, and there should not be a problem there. actually reservoir sampling (with equal odds of any line being drawn)? Yes. This is a good implementation of the reservoir algorithm. The random arguments are good, and the substitutions should be fine. 

One important note here, is that I would not actually print the output of the result in the loop, but just record the details. The is probably slow, and that would make the timing results biased. I would accumulate the completion data in a different way, and print it all after all tasks are done, or, alternatively, in a different thread. 

Concurrency Strategy In general, using is complicated, partially because the meaning of changed in Java 1.4, and also because it is hard to spot. I recommend against using it at all. Instead, you should use a more visible concurrency mechanism like synchronization, classes, , or So, while I recommend against , what's a real problem is using multiple different locking schemes in the same code, and you use both and . The use of synchronization as your concurrency strategy should be fine all on its own in this case. General 

Your code is a great example of when to stick with primitives ;-) Seriously, though, what you have there is a problem related to primitive arithmetic on undefined types. Operators like and are primitive-based (except for string concatenation) and as a result they are strongly linked to specific primitives. The code is repeated because each implementation has a different combination of primitives. In other languages with primitive types, like C, or C++ you would have the same sorts of problems, except you would have unsigned and signed variants as well, or otherwise suffer with large amounts of casting. In fairness, templates in C++ will help reduce the boiler-plate, but the language itself will generate different instances of the code for you. So, what's the solution? Well, the best solution is to not encapsulate primitive operations. If you need to do , then do that, don't do . Alternatively, to reduce boilerplate, select a single datatype that is a superset of the other types, and use that. In this case, probably ..... hmmm, is a , but will cause your code to fail.... With , you can implement all your major methods using arithmetic, and then have a single protected method to translate it back to the underlying class.... (and throw an exception if the back-cast is not possible?) 

It is useful to be able to expect a super-type of an exception. For example, you want to trap an when you run a query, or you want to trap an when you do something on a Stream..... you have the code: 

At this point, we have looped back to index 1, so we stop this loop. Note that we have not yet visited index 3, it is also a discrete loop. Index 3 in our function returns itself to index 3. If you consider that index 0 always forms a discrete loop, then you can skip it. Still, larger vectors have more complicated multiple loops. Here is a function that will rotate a single discrete loop inside a vector, starting a specific index: 

The code for this one baffles me. I believe you are doing much, much more work than necessary. The nature of the problem is such that an \$O(n)\$ solution is the best time-complexity one. Your solution is in fact \$O(n)\$, but it is much, much more complicated than necessary.... two loops over the data? Lots of state conditions, and class objects, and conditionals. Have you considered the simple function (returns the index of the first of the triples, or -1 if there is not one: 

For this, the does not need to be static either. If you code the process like I suggest then the methods become much more generic, and you have other advantages like: 

The above code has the advantage that it can (using the method) simultaneously declare one host to be 'dead', while also requesting a replacement. The code is designed to take null-value for the dead host, or 'just get the next available host'. Here's the way I would implement the ClientData class. Note that I use 'plain' synchronization here. There is no immediate need to use more complicated systems: 

measuring performance with a single call is never going to do anything in Java - you need to call the code enough times to allow the JIT compiler to compile it. It is unlikely that the JIT compiler will ever compile the method So I extract the 'hard' logic in to a seperate method that the JIT system can compile and isolate. I handle the special cases seperately.... put the user-dialog outside the calculation.... 

The official way to support a system where you control multiple Future instances from an ExecutorService is similar to what @ferada has suggested, you use a 'decorator pattern' to wrap the task, and track the results. But, the Java library has this system built in to the ExecutorCompletionService. Using that service you are able to feed tasks to the service, and wait for tasks to complete. Your code as it is looks functional, and you successfully wait for all tasks to complete. The problem is that you are not waiting for them in the right order (you are waiting in submit-order, not completion-order). Since the CompletionService returns a Future on submit, and the exact same one on completion, you can use that as a key to a timing Map... using an on the would be appropriate because it removes any dependency on the actual implementation of . Note that you can use an 'enhanced-for' loop to get the instances from the list. Consider the following code: 

EDIT: Request to get help on how to debug the code: To debug the code, you need to set a break-point in the method. Select the line and use the key-board short-cut Ctrl-Shift-B which will toggle a break-point, and you will get the 'dot' marker like the picture below: 

A huge amount of you work is just plain work that has to be done.... (the joys of brute-forcing). MessageDigest On the other hand, this work is unnecessary: 

Sure, it's long winded, but, look what happens when you want to use it in your code. Here is some code that transforms an array of Digits in to an output String: 

Since this has been migrated to CodeReview, it makes sense to inspect it from a review perspective. Others have correctly pointed out that the limit of your iteration is the root of the the number. That will impact the performance.... but what about your actual question: can the code be shorter (rather than faster)? First, some comments.... 

There is not much to criticize in your code.... and there is a lot of code to go though. Mostly really neat, and, it takes a while to 'grok' it, but it comes together OK. Here's a laundry-list of small items (there are no big Items I can see): 

I have put together a simple SQLFiddle that shows this select in action. It assumes two sets of users, (some male names, some female names), and it puts the different users in to different MAIL_ID's. Once you have swapped out these nested statements, it will significantly shorten your query.... Your handling code though will have to change. Getting a CLOB back from the view is a big change.... and it is best to handle that in a different way.... Edit: About this operation as a general problem At an academic level, the problem you are experiencing is because you are doing a non-relational operation in a relational database. Data in a relational database is treated using set arithmetic. You have sets of data that you can intersect, union, filter, and otherwise manipulate. The problem you are tying to solve in this question is the conversion of a set of values in to a single merged value (with internal consistency requirements). This type of operation is not well defined in set theory. The standard/recommended mechanism for solving this problem is to export the data set in to an external application, and process the data from there. Any system you use in an SQL query to remove the set-like nature of the data is a 'hack', and that is why you are unsatisfied with the result you are seeing. The right solution is to not use SQL. 

OK, that's some relatively simple stuff. Messing your code around using the above suggestions I get: 

I have been through this loop (quite recently, actually), for a rather large project in a very commercial environment. Frankly, it's not sustainable. Let me run through some of the issues: 

Note that, by convention, using hungarian notation in go is not good code-style. You should not suffix pointer variables with . A pointer to an int containing the number of T-Shirts is still and not OK, so the above code changes the flag handling to be Var-based, and it reads easier, and removes all pointer references later. I would also add flags for the starting date, and number of days to simulate. Washing Day Your washingday function is a good idea, but you are doing string processing in places where the library has better options to offer. Note that has constantes for the days-of-week, and those constants are declared as a type, and that type has a function available: $URL$ - what this means is that you can avoid the string-conversions in the function. I personally would probably use the option too to print the days. Actually, I would remove the println from the function because it is making the function do too much - (computation and presentation). I would have your function as: 

That neatens up your code, and does what is called "Functional Extraction". Additionally, if you look at that function it does a lot of work... it does 2 string concatenations, creating three Strings, a StringBuilder, and a bunch more. It would be more efficient to keep everything as numbers, and have a function like: 

This will operate in O(m log m) where m is the square-root of the input.... which will be really fast. Here's some code: 

For a beginner to go your program is good. You have obviously read up on handling, and you've got a grasp on the pointers. I have come to like the processing in go (though having previously learned/understood getopt and written my own library in Java, I feel like go should allow more powerful commandline handling). Flags So, having said you have a good grasp on those concepts, I am going to recommend that you change the flag handling (and as a consequence, you remove the pointers). In addition, you should be putting in the number of days to simulate, and perhaps the starting date, as flags too. So, functions include both and variants. I recommend using the variants where you can. Your code: 

There is no need to do the deep abstraction for the . You can simply reference the columns you want and include them in the result...