It's MVC so the Actions are the first port of call - it may not be possible to have a refactored method that is called before the Action. The GetSignature() method is called using all of the Action's parameters, so it may be difficult to refactor. 

TL;DR; Don't calculate the possible moves every single time. You've overlooked a key concept: the potential moves for a knight on f1 are the same regardless of what move number it is. It doesn't matter if it is move one (the N is on f1 because it hasn't moved yet) or if it is move 199 (the other N has wandered all over the board and ended up at f1). If you calculate the potential moves every single time you consider a move, then you are wasting a significant amount of time - it will always return the same value. And then your chess engine will be very very slow. The solution is to precalculate the potential moves before the games starts, and then for every move you take the precalculated potential moves and subtract the moves that are not possible based on the actual position. You still need the function, and to make the improvements others have suggested, but you need to pass in the piece as well. Source: I have written a chess program. 

I want to keep things DRY, so I'm trying to figure out: Is it possible to remove repetitive parameters and code from ASP.NET MVC Controller actions? eg given these Actions: 

Is there any way to refactor out the repetitive and parameters, and the call to ? There are two obstacles to refactoring I can think of: 

Until recently, I was very much only devoted to imperative languages (mainly C++ and C, to be precise), when I decided to venture into unknown waters by picking up a new, completely different language, which happened to be Haskell, a decision which happened to be influenced by the fact that I owned a copy of "Learn You a Haskell for Great Good!", a book which I very much enjoyed learning from. Some days ago, I finished said book, and, wanting to apply my newly acquired knowledge, ventured our to find some programming exercises. I quickly remembered Advent of Code, which offers a whole pre-Christmas period's worth of easy to mildly difficult programming problems, a few of which I had already solved during the holidays. I skimmed through the exercises, looking for one simple enough to be conquerable with my still very inadequate and shaky Haskell skills, and finally chose the task of Day 22. Problem Description 

is a horrible piece of code. Try to reduce the things you do on a single line. These should be five separate assignments on five separate lines. Also, don't use the comma operator like that; the comma operator should only be used when it is required, which it absolutely is not here. Kind of hitting the same spot as point 4, but does not do what you think it does. To be precise, it calls for , and does nothing else with the other values. Usually, you should compile with warnings enabled so your compiler can tell you about such things. Again, don't (ab)use the comma operator! is extremely uncommon in C++ and, as far as I know, supposed to be a replacement for on compilers which don't treat special characters very well. Although your usage is not wrong, you should prefer to use instead or people might look at you weirdly. could be implemented nicer with a statement. Instead of 

this I don't think you need to use the keyword in front of everything. Namespace - Utilities is not a good name space, nor is or or anything else vague. These are namespaces that scream "hey, put any old class in here, I don't care!" would be much better. Dependency Injection Instead of creating a you can have it automatically created for you by dependency injection. But that's a subject for another day :) 

Modifiers You don't have any modifier in front of any of your class declarations, which by default makes them internal. If you meant to make them internal, that's fine, but at least write , so its clear that you didn't do it by accident. If it is an accident then decide on a modifier and add it. is usually a good choice. If you are implementing an interface, make the interface public and the implementation internal or protected. Then it is only accessible by using the interface. Naming does not actually check if value is a valid price format. Format implies that it is a string used to format the display of something. Your function actually checks if the value is a valid decimal >= 0. A name of would be more correct. If you were actually intending to check that the price is in a valid format ( string does say to the user that it has to have a comma eg "10,00"), then your method is not implemented correctly, since a value of "10" or "10.00" would also pass the is valid test. only validates the price, so it should really be named Handling validation The way you handle validation is a bit unusual with the repeated check for and the repeated handling of the validation. Try refactoring the duplicate code out. 

Do not use since it not only lowers readability of your code (things that belong to the standard library are no longer easily discernible) but also opens the door for subtle name resolution bugs. is of type , but is only of type . Since grows until , you are running into the risk of overflow here, so should also be of type . However, since should never be negative, it would be even better to have it be a / Keep your spacing consistent. For example, why do you sometimes leave space around and other times don't? There is no right coding style that everyone agrees on, so you are free do choose any option that fits you, but you should at the very least stick to the style you choose throughout your code (also, keep in mind that most programmers consider more space better than less space, so leaving a space around operators is generally better received than not doing so). Consider wrapping your recursive function in a helper function. Anyone who doesn't know about your code would assume that all three parameters your function takes can and should be passed by the caller when the last two arguments aren't actually supposed to take anything but their default value. Don't treat single characters as strings when treating them as s would work fine. In particular, prefer over since this is (likely to be) faster and more efficient. Having a function output do directly severely harms its uses. For example, what if I want to send the formatted number to a file? Currently, your function doesn't help much with that. There are several possible improvements here, for example building and returning a or taking an as a parameter and output to that instead. You don't actually need in , the compiler is nice enough to add that automatically (Beware, however, as this only happens in !). 

Board looks like hash with some restrictions (size) and has default value of empty cell (Cell). Stores in memory only non-default values. A bit smarter than array in my opinion. Relying on hash means that the keys can't really be removed and memory won't be freed but it won't be issue if you decide to replace hash with something else as long as it implements contract (methods [] and []=). It can be replaced with some persistent storage (file/db), give it a try! Once you have in-memory and persistent storage you can use hash in tests (it works fast) and file/db board in your web/console application. This is great pattern but very difficult for many people who rely heavily on ActiveRecord. Don't let storage drive your design! 

Ladder is a bit different, on enter it teleports player. It shares contract with Cell. If you use rspec you should write shared example group for any kind of cell to ensure that it supports method. 

I strongly recommend you to look for presentations of Sandi Metz and get her book (Practical Object-Oriented Design in Ruby (POODR)) - you won't regret it. Hope you find this useful! 

Player knows how to move, to get make it work he needs to be aware of the board so we have to inject it. This knowledge could be extracted to some middle object but whatever it's worth it is up to you. Do not try to add too many classes if you don't need it, every class/file you add makes the application more difficult to follow/understand. I've made it this way because it's simple and demonstrates dependency inversion principle. Board (high level abstration) is being used by Player (lower level abstraction). There is little risk (or reason) of Board changing it's behaviour, on the other hand can be adjusted to incorporate some rules or restrictions (i.e. roll 6 three times in a row should invalidate the move), so risk of breaking the application is lower this way. 

This ensures that each header file includes all necessary headers by itself. Keep your spacing consistent. Notice the differences between 

is not a good practice, because it can make your code harder to read if you are using a lot of standard functionality and introduce hard-to-spot name resolution problems. While that is less likely to be an issue in short programs, I still advise you to not use it (creating good habits is worth a lot in the long run!). Don't do too much on a single line! In particular, don't , because, on the one hand, you are likely to forget an initializer or a part of a type here and, in the worst case, end up with undefined behavior, and, on the other hand, it is just hard to read for everybody not familiar with your code (such as I). Please split that line up into multiple definitions and declarations. Also, ... Initialize and use variables as locally as possible. This not only prevents scope pollution, but also increases the readability of your code. As a reviewer, I don't want to (and even cannot) keep a mental map on more than a handful of variables, especially if I have to remember them through large blocks of code where they don't even appear once. To my understanding at least, the term decimal implies floating point numbers, not just integers. Please think about clarifying, e.g. by writing "decimal integers" or something alike. Your code does (probably) unexpected thing for numbers smaller than 0. Since you take input as an and also do virtually no error checking, you could end up with the user inputting a negative number, for which your code will output 0 for the binary and 0 for the decimal representation. If you don't want to accept negative numbers at all, should be unsigned. If you do, change your implementation to work correctly for those. Either way, you should do input verification on the numbers (or non-numbers) you get. Don't use . If you want a newline, simply write . The reason is that does more than the name suggests. In particular it writes a and flushes the underlying buffer which is very rarely what you want or need to do because it seldom yields any benefits and can decrease performance. Order your includes. In general, alphabetic ordering is expected to enable fast header verification for people reading your code. Write meaningful comments. In particular, follow the DRY principle in comments as well as code, which means that , for example, should go without the comment because it only repeats what the code does. Instead, try to us comments to give reasons as to why you're doing something, and don't overuse them because you've read somewhere that "the more comments, the better". Usefulness and clarity are key. is not exactly what I would call a good variable name. Most of your other names are good, but this one identifier is definitely not. How about something along the lines of instead? If you have access to anything , use in place of because is fragile and convertible to a lot of things that are not actually pointers.