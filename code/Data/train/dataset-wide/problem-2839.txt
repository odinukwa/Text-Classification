Style Your code is pretty readable already. But you mix and . I prefer consistent style. Also, you use a function expression instead of a function declaration - there are subtle differences, but it's mostly a matter of personal preference. To me, the function declaration seems simpler. Runtime complexity Your main issue is performing full array searches via (in linear time) within the inner loop. By using an alternative data structure such as a simple object , a or a which complete such lookups much faster (in constant time), your performance will improve drastically for large inputs. You can also get rid of the final by mapping numbers to their indices. This doesn't improve theoretical runtime complexity, but still improves performance. The same holds for breaking out of the loop early as soon as a solution is found. Implementation 

See also Is JavaScript a pass-by-reference or pass-by-value language? Now, if we look again at your implementation, we note that you already perform a regex test. We could perform a regex matching instead and get rid of all those redundant calls. I wrapped this new implementation in a documented function and ended up with: 

Of course, you might want to encapsulate above code in a function or even more versatile, a generator function and replace with . However, since you only have four different step-sizes of 1, 10, 100, and 1000 you can encode them manually and come up with an even simpler generator function as follows: 

Separating logic and view: Your current implementation returns an array of strings destined for immediate output. This comes with a few drawbacks: 

This allows you to replace with the more readable . Default properties: There is a pretty common technique used to handle default values of object properties. Replace 

I think that by closely following the above recipe, you can avoid the more obscure arithmetic and come up with a simpler and more intuitive 'generative' algorithm. The scheduling is encapsulated in the function: 

Notes Declaring some of your variables as can protect you against erroneous reassignment or rebinding, as any assignment to variables will throw a at runtime instead of silently continuing execution. Instead of I recommend using the unary plus operator which is "the fastest and preferred way of converting something into a number" according to MDN. Parsing I like your separation of input parsing and the actual program logic. However, you create a lot of temporary copies by first splitting and then mapping the array. If you like, you can use iterators or generator functions to parse input with only constant additional required space: 

returns an array. So don't bind the result to a variable called . Or better, since you can't have multiple array entries with the same name, replace with : 

As already pointed out, you need a more sophisticated approach to testing runtime performance of runtime-optimized code produced by modern JavaScript engines. I compared the performance of your datastructure against the built-in as well as plain objects on the well-known performance testing playground jsperf.com based on the benchmark.js library and got the following results on Firefox 53 / Ubuntu: 

It works. But you would then need to return instead of . Also, it is less readable as you re-assign the function's return value to the input parameter, which is confusing. Further suggested improvements: Naming: 

First of all, your given sample features zero-padded 2-digit months and milliseconds which you currently don't reproduce. The mentioned 'smell' is probably caused by 

2. Remove the redundant condition: The final condition is redundant as it is always when the first if-condition is . Remove it: 

If is not an array but an object, replace with . Performance If performance is really an issue, look into the runtime complexity of your operations. By introducing an explicit from parent names to children files, the runtime complexity could be reduced to depend linearly on the total number of children only. 

While there are exactly 945 different ways to partition 10 teams into pairs and thus many more ways to generate a correct schedule, I could not come up with a simpler or more intuitive schedule. 

Consider what happens if returns value A, but before the expression is evaluated, is changed to some other value B. This could cause to say that the queue is empty when it isn't or that it isn't when it actually is. Conclusion These are two of many issues that are currently in your code. I've decided to stop here since that's a pretty bad problem. This current implementation if not safe at all. I recommend you do some more reading and learning about thread interaction. Good luck. 

Imagine a first call to in thread A makes it inside the statement and gets stalled just before executing . Now another thread B calls and successfully gets past ; the writer now has a value different than reader because of the compare/exchange operation. However, the store of an element has not happened yet since thread A is still stalled. What is thread B going to pop? It's going to access whatever garbage memory is at that location. Issue #2: Malfunctioning empty function The load from and the load from followed by a comparison is not thread safe. 

Notes A faster way to check if a file has been processed would be to add a character indicating that it has been processed, for example: 

Welcome to Code Review. This queue implementation is not truly concurrent-ready. Arbitrary initial capacity 

Why have you decided that the default size should be 100? Different people have different needs; having default values like this isn't a good idea because there is no true advantage to having a default size of 100. While this is subjective, I suggest you remove that default size and just have users be required to specify the size that they want. Compare/exchange confusion There seems to be a misunderstanding in regards to the use of compare/exchange. The compare/exchange operations work as follows: 

Basic algorithm Since you have very large files, you should consider streaming the file one line at a time instead of loading them all once; your program would use a lot less memory. You would also not have to copy your , which is very large! In order to know which files you've already processed, you could create a new file that holds a list of all the files you've processed and write to it as you stream from the original file. This is of course, assuming you want to keep the original file intact. I will continue under this assumption as the other case (simply delete from the list as items are processed) is simpler. Check the Notes section for a better idea that you can implement with inspiration from the following section. Implementation The following is a sample implementation for the algorithm I described in the previous section. For brevity's sake, I did not include the items mentioned under the Form section, nor did I include exception checking; I will leave those things for you to figure out. It is also most likely not as optimal as it should be, but it's merely meant to show you streaming. Sample 

1. Description 1.1. Functionality The objective of these types is to provide type erasure for any function while maintaining the ability to provide a return value through a combination of and its associated . 1.2. Motivation This is useful for any sort of dispatch manager, a thread pool that you can submit tasks to being the actual target; where a task is any function with any parameters and return type. 2. Implementation 2.1. deferred_invoker.h This is the main functionality. Type erasure is provided through the base class, which simply has a virtual member function that is called when the function has to be invoked. The specializations will then know how to deal with the invocation and whether they have to save a result. They also take care of ensuring the correct initialization arguments required for the call are initialized and saved in a tuple. This applies for template parameter which is any function. A simple tag dispatch system takes care of return types. I've omitted a third implementation of for lambda and functor types to focus the review. It's basically the same style as the other two (possible design issue?), but it takes a copy of the lambda/functor and the arguments, instead of a pointer to the function. 

I wonder if I use the correct syntax in bash? Further I think my scanning function is not all that good, I bet there are more pretty ways to check. Lastly maybe checking wifi's near me with instead of iwlist scanning would be a better way of handling this? 

@Austin Hastings has the right idea, using to do all the attribute setttings. I recommend to look up , and Python . Code changes 

Cut a big number into evenly sized chunks of adjacent digits Sum the product of the chunks A main function that returns the largest adjecent product 

I need cheap GPU's and decided to make a little ebay-scraper to make sure I can buy it at cheap prices. It works and I can search for (any) product to scrape the Title, Price and Shipping cost of that product. But I feel like I haven't done it in a generic way, hence the need to post it here. Thus my question is, could this have been done more generic? 

You could make use of something like opencv to find the individual pieces. Afterwards you can crop and save those pieces. This will be a big improvement as you could give it a different image, and it would create individual pieces from it... no more measurement from the user! 

Intro I have started a new course (Analyzing Big Data with Microsoft R) and have an exam soon. So I wanted to test my skills, and a nice way to do this was by doing a Kaggle competition Titanic: Predicting Disaster. I managed to get a decent score (80%). You can run this script by first downloading the , and set your working directory. I am using the latest Microsoft R Client. Any review is welcome, but I am most interested in: 

I think your program is ok, but could use some improvement, be sure to check out the Paramiko demo's these contain many usefull pointers for working with parmiko 

Review There are a few things that could be improved upon. 1 .Your could use some love I might understand using a dictionary so you can see which value corresponds to which direction, but this may be simplified to just using a tuple of directions. and are variables badly named I believe, maybe or something would be better. and implies that these variables are private/protected, and in your case they are not. Secondly I think with this: 

Well done There are some obvious beginner mistakes, but you have created a working game. Avoid working in the global namespace 

Why the string to tuple conversion? I am not sure why you are converting the input into tuples and then convert them back into strings corresponding the input again. Because you could have iterated over the without the conversion Use libraries when possible I know you specifically said not to use lib, but this seems the perfect spot to use it. If there is no specific reason for it (like an assignment) I recommend using it. 

Use either or because this feels just wierd, and kind of surprised it worked at all. I'd recommend sticking with Secondly, be sure to check out the itertools module from python, because what you are looking for are basicly permutations of a word. 

Any review is welcome! Plus I would be happy if anyone has additional information on how to prevent MiTM attacks. 

When I do a the IP of the Attacker is in the route. When I trace the route, and there is not a router device in my route it means an attacker(laptop) is listening on my connection When I the attacker does an , the ARP-table has duplicate values. 

DONT! String format your sql queries, but let the cursor do it for you. As @Gareth Rees said, this is not secure! 

Inspired by this question on CodeReview, and because I'm never able to beat the queue. I'm just too slow I guess.. :( I made a little python utility that reads the queue's information every 30 seconds and opens the link in your browser if we can review something.