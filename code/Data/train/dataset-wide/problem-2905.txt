I am writing this smart pointer as a learning exercise. Any feedback would be most appreciated. Any flaws? Have I missed any test cases? smart_pointer.hpp: 

Question 1: functionxxx_as_string() is used below. How else could it be more elegantly named? Question 2: Is the static char* array method adopted below the only solution? Best solution? Any suggestions? Generally, I have this issue where my list of enums will be from 3 - say 50 items, mostly less than 20 items and they are fairly static. 

Is that the standard way to do function pointers to member functions in C++? Any comment on that would be interesting. I guess it could look a bit daunting to someone not familiar to std::function. I won't change the code in the review at this late stage. 

I am preferring to remove all the printing stuff from the class interface and use the operator<< overloading idea in 200_success answer like this: 

Late additional comment After reading this article: $URL$ I found that I can change the tcpclient constructor to look like this: 

I need to create a protocol for sending data of various types over a socket connection. so I need to serialise the data to a byte stream. I only need signed and unsigned 32 bit integers, 64 bit integers, string and binary. It is only a start but if anyone can code review this I would really appreciate it. 

What does CNRG mean ? ^^' Please search for the good practices in naming classes ;) is only written once so it should be ... actually it should be a constant. Same goes for the field. The extension is also part of the filename IMO. So in the end that'd be : 

Performance tuning To reduce the impact on performance, you should try to reduce the number of call to to only one, at the end of the run.... You may end with a very big however, so you should use a instead. Combining both those things should reduce the time taken by your application by a very noticeable amount and you should end up with something looking like this : 

You are mixing the inner workings of your application with its view (how it's presented), you should avoid this most of the time (unless you are going for a simple script). By splitting the view from the logic, you can change the way data are shown to the user without touching any line of codes that take care of the behaviour. The separation of your classes feels a bit random... for instance, why do you have an and an ? what was the rationale behind splitting those two ? what does the class bring you ? You are always using the default visibility for your methods, make your methods public Your code always talk about but then, the model is stored as While you abstract some things, you are not using any abstraction for your tasks... they are simply stored as , adding behaviour to your task (for example, a due date) would have been easier with s objects. You should use dependency injection to make your code OO. By using dependency injection, you'll reduce the coupling between your objects making them easier to test and extend. You can take a look at the following SO answer for a brief explanation : $URL$ Never store password as a clear text, you should hash it... if you don't know how to do it, there are plenty of library that can do it, in the standard lib you can take a look at the following class : $URL$ Methods' name should make their intent clear, for example, methods that start with a , , , should return a value... as such, the method shouldn't be but rather return a list of options :) isn't a meaningless exception, so you shouldn't let it being thrown around and then use printStackTrace on it at a completely random place. Those exceptions means your program have receive a message from a thread telling it to stop while it was waiting. ...well, actually, why are you even calling there ? ^^' Why are you creating a Tasker in ?? Aren't tasks supposed to be linked to the user ? Avoid the default package, it's considered bad practice (and actually gives a warning in most IDE) : $URL$ Don't declare two variables on the same line, it's harder to read ;) 

This simple program uses a socket class I wrote, class socket, to retrieve a users pop3 emails and print to stdout. I would like feedback on the socket class and the code to download the pop3 emails. My main focus is on the simple state machine to go through the steps required to download the messages. It looks a bit ugly. There are probably better ways to do it. main.cpp: 

One way to write a client which uses a specific protocol, eg http like in this case, is to create a base class with the basic socket handling functionality with virtual functions which can be overridden with an inheriting derived class. But it is more flexible I think to be able to get the socket handling class to call a function specified by the client. Hence, the tcpclient constructor takes three arguments which are calling client callback functions to handle the asynchronous connect, data received and exception events. But the callback functions are straight functions. It would probably be more flexible to allow member functions to be called somehow. I wasn't sure how to do that. Anyway, I would appreciate any comments on the code. tcpclient.hpp : 

Please review my ini file parser (and potentially some general config file formats). The data structure used is a section, see below. Does that seem a good approach? I was wondering about the name. It will parse ini files ok, but unix config files are so variable that calling the class config might be over selling it a bit. I don't support mid-line comments. Only comments on a line on their own are well just ignored. All values are stored as strings. I thought that only the user of the config file will know if a value should be used in his or her application as a string or integer or whatever and onus is on user to convert. Any comments would be much appreciated. Its intended initial use is for Windows ini files. Parsing the configuration into sections. config.hpp 

Well, let's move to other parts of your code : You shouldn't set startX and startY to be static. You only use this to be able to call ... to avoid this problem, you could give a method that takes no parameters and delegates to your "true" solve like this : 

Once you have tested the basic properties of the matrix's operators do 1 or 2 tests for each operators with constants matrixes ; for example testing the result of matrix [[1, 2] [3, 4]] + matrix [[17, 42] [42, 0]] (with no random value) Here are some tests examples : 

The code is pretty clean, if you started coding very recently, you can be quite happy with it. But please note that some of your variables names start with an uppercase letter, as a reminder java use SCREAMING_SNAKE_CASE for variables, CamelCase for class name (or object type if you prefer), and camelCase (aka lowerCamelCase) for local variables, fields and method name. Also if the user input only one word then your code fails (which is not necessarily bad nor wrong)... silently (which is bad). You should print a warning message in such case. 

Controlling the input If the user input neither 1 nor 2, then what happens ? Never trust user input ;) Magic number (& cie) You use quite a lot of magic numbers though the code which is usually a bad idea. : this method is pure black magic to me ; you should comment or try to split it in easier to get methods. Example of code with DI Here is a sample of what it could look like (code is not complete) :