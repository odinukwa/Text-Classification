I'd appreciate any feedback on improving perceived responsiveness for the feature this UserScript adds to the webpage. I realize changing the URL after a slow image load within might make the URL change seem slow, but I also noticed that when calling or within a listener to or events, it appeared to cause the fusion image to load significantly slower. Though this UserScript still functioned properly either way, I'm curious if anyone can come up with an approach that improves responsiveness overall. 

I did a little preliminary research and was unable to find a class to create re-usable instances of template string literals, so I wrote my own. Below is the main file (slightly modified to remove exports) written in ES2016, along with a few examples of usage that show the convenience of the class. 

And as promised, here is the link to the repository, which also contains formatted documentation on the respective github pages, and a full demo on Heroku. Please be responsible and only make HTTP requests to the Heroku link sparingly, as I have it hosted on a hobbyist plan, which only allows so many hours of uptime a month. I have plans to implement a service worker for it in the future to mitigate this issue. 

I would say it works. At least essentially. Nevertheless: There might be flaws even bugs in my program. And I guess one could improve it a lot. So therefore: Any hints, comments and recommendation by more experienced Assembly programmer very much appreciated. 

As far as I can say: It is doing alright. But I would like to know: Is there a better pattern for solving the task of getting a duplicate-free array? If someone knows a better solution then I would appreciate his/her answer. Moreover: - Is my documentation understandable and done in a good way? Or do I have to improve? - Is my parameter validation done correctly? Looking forward to read your answers. :) 

Any hints and tipps concerning possible improvements highly welcomed. Especially the design and usability. 

I've got to made a function which returns the checksum of an given integer. Source code of my implementation so far: 

I have to implement a double linked list as an exercise for a further education. There are three interfaces which have to be implemented: IValueElement 

Hyperlink to my GitHub-Repository. What would you have done different and why? Looking forward to reading for comments and answers. 

One of the things in this rewrite to flatten your pyramid code, I changed the order in which is called, because the way your code accessed the property relied on the usage of a proxy get trap in order to work properly, which is both unnecessary and inefficient. Lastly, I cleaned up your generated text to break it up into a few lines, otherwise it's quite unreadable. You might consider storing that text to an external template file using a minimal template engine (possibly written yourself just for this specific case) in order to avoid hard-coding it in here. 

On Pokemon Fusion, I found it annoying that the webpage didn't automatically update the tab URL to the permalink when the fusion is changed, so I decided to write a UserScript to do that. After finishing that, I thought it would also be convenient to update the fusion whenever navigating through the site history as well. 

Here, we are mimicking the signature of the native API, which has one required argument and one optional argument. We simply expect a property to optionally exist on within this wrapper function. 

It seem to work alright. But frankly: With all the parameter-checking and taking different possibilities into account it has become a lot of code. If someone knows a possibility to write it more elegant then I would appreciate his or her answer. Any other hints welcomed too. Should mention: I can't use ES 6-syntax because we got only Internet Explorer 11 here and there won't be change in any nearer future. 

I've have make this animation on the weekend as a "just for fun" thing. And for to play with various techniques I've seen in others code. I think it works quite alright. Nevertheless I would appreciate comments about: 

The code has passed the automated tests. But I would appreciate some real feedback. What do you think about my string-processing and the way I've done the type conversion? What would you have done different and why? All comments, hints and answers appreciated. 

I've started to learn node.js a few weeks ago. This weekend I've made a tiny app for to recap what I've learned so far. It uses OpenWeatherMap as a data-source. The user calls the main file (controller.js) via terminal and assigns a string (a location, usually town) as the one and only parameter. The app then prints some current weather-data for the named location to the screen. 

This part is pretty straightforward; we're creating a timeout given the amount of milliseconds supplied from or the default , and invoking the callback function in that amount of time. 

While this is a relatively simplistic and deceivingly elegant implementation, insertusernamehere's solution is admittedly an order of magnitude faster, when using an array as a perfect hash table for non-negative integers instead. 

In order to satisfy the O(N) time-complexity, construct a in O(N) time and space complexity, then use a loop which is considered constant time relative to N O(N) as well (thank you, wchargin), since the maximum possible number of iterations is equal to N and average performance of a operation is O(1). Because O(N + N) = O(N), regarding time complexity, this solution is overall O(N) performance in both time and space: 

You can write concise code without using cryptic variable names. Change to something more meaningful like or even just . One way to resolve pyramid code is to look for places where your logic can be decoupled or flattened. While it's possible to continue to use the dependency in order to achieve this, it's probably much easier to just use since you're already using promises anyway. This will also give you an opportunity to get rid of your global variable : 

I have written this function for creating complete HTML-elements including arbitrary attributes and inner HTML. I want to keep and reuse it. Therefore I have tried to document the usage well. I would be interested in hints concerning: 

This week I've had an idea for an Ajax loader animation: An air bubble ascending in a glass tube. Something like shown here: $URL$ I've used CSS-keyframes and -filters for to implement my idea. Finally I made a little demo for simulating the loading of data via Ajax-request. Compiled and minified code as an Live-Demo: 

Further requirements concerning the implementation of the methods I have written into my code as comments. Here's my Plane-class 

I had to do this exercise for a further education in which I'm currently enrolled in: Write a Java class "Air Plane". Object-property names and types are given and compulsory. Write the according constructor and getter-, setter-method. Check within the constructor the given values for being valid. Moreover are the following methods to implement: 

Is everything done in a good way and manner? Where could my implementation been improved? Any ideas how to solve point 8? There I get finally stucked. Looking forward to read your comments and answers. 

I would like a review of a library I've recently published. I realize this is a rather large request, but having looked on meta, it seems this is perfectly on-topic. I'll include a few choice samples from the library to demonstrate my approach, as well as a link to the full codebase for anyone interested in giving a full-breadth review. So to summarize, this library, called , is, as the title and tags suggest, an object-oriented approach at designing an educational tool for teaching sorting algorithms, which is why the sorting algorithms use generator functions to introduce interruptions in the control-flow in order to be visualized step-by-step. Here's a few of the classes needed to implement an iterative (bottom-up) merge sort algorithm: 

If you are at all familiar with using promises, then you'll recognize this pattern. While it is typically considered an anti-pattern, this particular implementation is written properly, and is also necessary in this case to take advantage of a convenient implicit race-condition behavior of promises that I'll explain in a moment. 

This first checks that is "truthy", and then checks that is a valid, non-zero number. If these are satisfied, then is assigned the value of the supplied property, otherwise it defaults to milliseconds, like in your example. 

How to structure / shorten the JavaScript- and Sass-code better? How could the animation be improved? So that it runs smoother and more "natural"? How to improve the responsiveness? 

Task description: Search the highest ID within a given JSON-structure: An array with objects as elements. Every object has a property "ID". Then increment the highest ID and return it as a result. For to become the next ID used. There can be gaps within the given data-structure (because of prior delete operations). This gaps aren't allowed to use. It shall always be: Highest ID plus 1. I have currently two different implementations for a solution. The first solution is a more functional approach: 

Task description: A set of product-thumbnails is shown. The user can filter the shown products by vendor(s). Done by clicking one or multiple buttons. I used jQuery together with the Isotope-plugin: $URL$ First I had the idea of using iteration for assembling the filter-criterium string: 

I've made this animation using Sass and CSS-keyframes. I'm bit worried about my usage of position relative / absolute. Can one expect that it works in all browser reliable? Or to I have to expect things like a offsets? Moreover: Is there a way to improve it somehow? It doesn't run smoothly. Perhaps I've chosen the wrong tool with CSS-keyframes? Any hints and tipps to the points mentioned as well as everything else welcomed. 

Overall, it gets the job done, but your code (especially the area I'd refer to as "pyramid code"), could use a little more organization and clarity. Your statement could be a little more concise, and, at the same time, more canonical about what it's actually there for: 

This line invokes the native method with the wrapper's arguments and resolves the explicitly constructed promise with the fulfilled object, if, and only if, it is successful and it completes before the callback is invoked. The reason this occurs is because of the specification: a promise can only be fulfilled, rejected, or remain pending forever, and if it is fulfilled or rejected, it is "settled" and cannot be fulfilled or rejected again. If it is unsuccessful, and it fails before the timeout occurs, then it will invoke with an error. 

Inside the callback, we're rejecting the constructed promise with a , but keep in mind, if the function has already invoked or in its , this call is essentially a noop because the constructed promise has already locked into its state and cannot be "settled" again. Because of this, it is unnecessary to assign a reference to the timeout and call if those occur first. Conclusion If you've read this far, you've probably realized by now that the suggested code is compact because it takes advantage of a thorough understanding of the promise specification, and is able to safely make assumptions that keeps the code DRY. 

Is everything done in a good way? Or has the code flaws which should be improved? Okay. My ASCII-art skills have to be improved. I admit ... But seriously and important: Is my implementation of the MVC-pattern correct? An according answer would help me to feel more confident about the topic MVC. But other hints and recommendations are also welcomed. :) 

I had a college semester and an internship in a firm doing Java but I'm not a real Java programmer. So I don't know the idioms and patterns of the language. Therefore my question: What improvements should I made? Especially: I catch the most exceptions within the class itself instead of passing it upwards towards the calling method. Is my exception-handling done in a correct way? Is it good practice to catch exceptions as early as possible? Any comments, hints and recommendations appreciated. 

I would be very interested in hints and tipps concerning the animation-design and the Sass-code. Because I'm a beginner there. Nevertheless: Any other feedback welcomed too. ;) 

Task is to have a function which takes an array. Then removes elements from the array which are contained more then one time. Finally returns an array with only unique elements. Here's my solution: