You are beginning to mix up the business logic with the user interface. You should (be able to) design a "game driver" class without regard to user interface. You want to keep your GUI code separate from your game logic code. And another OO paradigm is to create new objects separately and pass them into where they are used. I see a class ( "Dealer" might be a better name) that handles the cards, deals them to players, etc. Then your class wires-up it's buttons to the methods. For example a "Deal" button's click event handler might be . pseudo code for the idea: 

The problem with the OP's code is that is trying be-and-do-everything-at-once. THERE ARE 2 THINGS HERE. Groups of items, and then the "Pricing Rule". OO programming is about identifying the parts in our puzzle and then putting them in the appropriate places. 

Multiple Add methods Makes no sense. Why would a method arguement be validated sometimes and other times not? How would a maintenance programmer be expected to know when or why to call one or the other? If indeed multiple "add" methods are needed then overloading is what you want. Overloading is a fabulous way of saying "hey, you can do the same thing, but differently" Not overloading obscures the fact that the methods all do the same thing. Then, overloading highlights what's important - that with different object types we get the same result. 

P.S. Some readers may point out that I do not mention . I'm not feeling the need here. I think the proposed re-write will be far more helpful lesson in the long run. 

I see lack of experience. Poor to bad variable names, lack of code structure, magic numbers, non-idiomatic constructs ( instead of ). The code in general is confusing. I really wonder why there is so much digit/number manipulation involving an array. I think it is because the code tries to do everything all at once, but it ends up obscuring everything it does. I'm not saying the algorithm must be changed. Rather, things discussed below can go a long way toward mitigating difficult code. 

Hey Rocky! Watch Me Pull A Rabbit Out of my Hat If you're a Rocky & Bullwinkle fan you know how that always turned out! Well, here goes ... It looks like every generates a parent, child, and grandchild node. So, how about we generate all the nodes first, holding them in parent, child, grandchildren s. Then adding to collections is simple. Extension Methods Great for putting "core" things in understandable terms. Even without all the craziness I think you should implement some Extension methods first, then refactoring will be less confusing. 

Refactor DB calls out of classes i.e. Separation of concerns; Single Responsibility Principle; Maximize cohesion and minimize coupling. To facilitate this, you may want to design "data transfer objects (DTO)" classes (collections) to pass to your new database code layer. The idea is an object of data w/o little or no behavior; simply for the purpose of cleanly and conveniently passing data. And certainly your classes can integrate these easily. You may want to think about making these DTOs inner classes so or , as appropriate, has total control over them. 

Note: This answer was written after best answer was selected. Going through a few things then putting them together. 

"... instead of inheritance.." I expected the class to encapsulate the object by wrapping the contained object's methods in its own. Thus the client code is not aware of a distinct inner object - the Law of Demeter a.k.a. the least knowledge principle. That encapsulation implies there is no public getter; and I would prefer a constructor parameter over the public setter. If we inherit from there is no contained object, so good encapsulation makes composition "feel" the same for the client code. Class types are different of course, but we're still calling the same methods and getting the same behavior. 

P.S. I know you're gonna say, "Hay Bob. You shouldn't use now. Well, it made refactoring easier and quicker. 

If there is no existing employe create an Employee object with zero in the ID fields. So when you call 

It's my understanding that .NET handles connection pooling automatically and I've never worried about it in my experience. My spidey sense tells me that with proper refactoring, all your exception handling will be right here. Follow-on Refactoring - getting business logic out of DataBaseHelper With the above in place, I can see the query string in , and similar methods you must have in pulled out. Now is free of all "business context". If the SqlCommand setup is very customized for each query, then perhaps becomes a whole new class; very possibly derived from an abstract class with standard/common setup. Oh, you can use the same object with different parameter settings; Remember that parameters is a collection on and so you can have have custom methods to set up s and pass that into a object used over and over, living in that abstract class I mentioned. 

More refactoring. I made each case a method call; perhaps overkill (except for choice 2) but code in this method - "at this level of abstraction" - will not change if, for example, you change how works. 

Logic nesting is too much. When I read that final Im saying "else what? Where am I?" Too many s is bad enough, with code clarity is out the window and bug potential explodes. 

I take CodeWars as an opportunity to research the language. So any given exercise should take as long as it takes to meet your learning goals. DO NOT rush and short-change yourself. I suggest you incrementally refactor this exercise. It's more about learning to code than learning JavaScript. The point is to see the before and after. You may have several iterations. Do it in stages to see the effects of each thing you do. After all that you may want to rewrite from scratch to see how you've learned to integrate all you've learned. If you think your goal is to make it perfect, you're missing the point. 

Depends on what optimal means to you. CodeWars culture favors concise, clever usages of the language. Conciseness can clarify code. For example using Array and String iteration & manipulation methods you might avoid the index futzing in loops. What makes it sub-optimal is the relative difficulty of reading and understanding the program overall. 

That is not inheritance, just for the record. But if you do inherit from a then there's no point in having the interface. This is especially true if you want to have some default or common behavior. Off hand I'm thinking about handling errors from the web service call. 

The await looks like a leaky abstraction. Could your generator naturally behave synchronously? A quote from Exploring ES6 

Wait! Now I want to be able to ask the if it is in it's proper state, and single responsibility principle guides us in making changes. 

Catching specific exceptions is good. But this code is not catching any of the exceptions that opening/reading a stream may cause. Catching a specific exception is good because there is context to capture specific information relevant to that exception type; which can really help troubleshooting. 

An interesting SO answer on that unary operator Here is that AirBnB reference. I strongly disagree with the "semicolon auto-insertion" premise. If you are allowing the JS interpreter to auto-insert semicolons you are screwing yourself big time. ALWAYS USE SEMICOLONS TO END YOUR STATEMENTS, period; Don't pretend you can devine what the interpreter will do in every case; and sleep soundly. As for avoiding the wrong variation, pre-increment when you meant post-increment: Y'all be careful out there, Ya-hear? Seriously, the unary operator is ubiquitous and the gotcha is documented, intended behavior. Try this: 

This answer is post preferred pick This pattern is fine if exiting on the first invalid condition is what you fundamentally want. OF COURSE what if scenarios bring other considerations into the validation code design. As the code evolves refactor the validation structure as needed. I agree with @slugster - change the name to (or , whatever) because ... "IsValid" vice "IsValidForDB" method name is a paradigm shift A valid business object is one thing. Putting the data into a database is another, separate, thing. Do not put database features/limitations in your object's business rules. The generic means we are validating the object for problem domain business rules. Valid or not the database puts demands on us that are not problem domain validation issues per se. For example how do we store ? As , the blank character, or some other arbitrary character(s)? So changing the method name acknowledges these separate concepts and therefore we codify these separate concepts literally. Code that must transliterate values to/from the database should be in some data layer of code independent of your business object. 

communicates overall function much better. is understood in 1/10th the time as the original. Each method, including , is focused on one thing. 

Improved application of Single Responsibility Principle, encapsulation, and domain modeling. Start With Good Data Structures 

Product Class With Appropriate Responsibilities I don't want to get wrapped around the axle about , , naming conventions, etc. That is irrelevant for the larger point of Object Oriented. 

Obviously the clients will want all the s (OMG, I just used a name in a proper sentence. The power of Self Documentation!). Sticking with the OO way, we make a strongly typed collection. Think Single Responsibility, encapsulation, domain centric (my words) design. 

Base classes need some implementation Put implementation in base classes. That's what classes are for. 

Edit This edit is about moving functionality out of and into class where it belongs. The themes are rigorous encapsulation, using game terminology, and Single Responsibility Principle. 

The game driving the tournament The Tournament driving the pairing of combatants The Combatants doing the fighting. Better separation of concerns We coded at appropriate levels of abstraction w/in each class. A.K.A. we pushed details down. [edit] One more thing.... the may now seen superfluous, but it got me to thinking that can now be passed as a parameter and now we can have game variations. Holy Inversion of Control, Batman. 

Now, what class would this go into? Person. What about Student? The above already does most of what we need for Student too. Do we duplicate it in Student class? NO! Object Oriented Design to the rescue! 

The mass of arrays is essentially capturing the information, or context if you will, that will instead be defined as appropriate properties in the appropriate classes. 

Request triggered only in the constructor Both answers require that every request must be a new object creation. If that is intentional make sure it's documented. Otherwise I'd say it is a single responsibility violation in the constructor method. 

Make an array of range-strings, not a comma-separated-values string. Otherwise there is no point in returning a . 

// STOP. Don't spew out price calc code here. We need to deal with "we have 3-fer Coupon and we bought 5 of them". But that too will be encapsulated... somewhere; in Openy-Closey think we might consider extending . // I can imagine it's use thus: 

Too Many Trees in the answers There are lots of valid points throughout the various answers but it mostly misses the big OO forest. 

Classes are not cohesive. The number of Constructors and the nature of the parameters is a big clue. 

Just because it's simple does not mean its OK to ignore proper encapsulation. Parameterized Constructors == Happy objects The constructor is the place where there is a chance for creating a valid object. Validate the parameters. Test for nulls, valid ranges, valid data combinations, etc. I control my state, not the client. 

The client gets zero and does not have to guard for null. Other methods and properties return default values, null, etc. whatever is appropriate for benign, "do nothing" behavior. You might also have a . The client should only have to ask if the object is "null" and should not have to know how it's "null", just that is is. Client code should not be forced to know intimate details to determine state. The object itself knows. If a class is not controlling, encapsulating, determining it's own state that class is not reusable. Hiding Details Along the same lines above, a client should ask if there is a manager, not determine it for itself. 

should not be checking the validity of the returned data. This method should be concerned with only "getting a member number by the user id". This is an example of violating the Single Responsibility Principle. Exceptions - "covering" database calls with is idiomatic. To put a fine point on, and perhaps contradict, a couple of previous answers: 

Refactor I can't see the forest for the trees; it is not structured. What does do? This is high level code and should read as such. 

When I saw another answer that extracts this to a factory class, the above immediately struck me as a SRP violation. However if a request is the exclusive domain of the class (it is after all), then perhaps not an SRP violation. Even so I think about a client using the request functionality, not being the request functionality. 

I think you're over-thinking the solution My first thought is that I'd like to iterate a collection, and give each rule the dice roll results. 

Make Cohesive Classes OO programming is an exercise in self-reliance, for the classes. A class should know how to do things that is should be doing itself. The client should only have to tell to do it. 

Rewrite properties as shown above. Don't allow client code to set properties, as a general rule. - I'd rename this to because it is a property. If it were a method then leave the name as is. - This is ambiguous because I am unfamiliar with your business domain. Put parentheses to clarify. 

Extract the busy-work code of transforming the to into another method. From what I'm seeing I would think about the concepts you want to express in your code vis-a-vis some technical adherence to "encapsulation". If you want users to have no concept of an imbedded in a fine, but as it stands I'm not thinking message is inadequately encapsulated. Alternatively if there are some public getters that you simply do not want users to access, then that's OK rational too. In this case then the alternative is, in the class, a public - and likewise for all properties you want public. If, as far as Page users are concerned, the message's subject is the message, then rename the methods: ; but it still returns a . You can take that one step further by having implement iterator methods so the calling code looks like , , etc. and whatever. But again, the caller has to iterate. This doesn't feel like much bang for get buck to me, although it seems to fanatically adhere to the law of demeter. 

Single Responsibility - Custom collections For me has become a no-brainer for good SRP application and enhanced functionality. The .NET framework collections take advantage of "equals", "IComparable", and "IEquateable" (more?). All of a sudden "Find", "Sort", "Contains" collection methods work like magic (from the client code perspective).