have inconsistent bound checking, which may cause confusion when quickly screening the code, i.e., you need to mentally switch between and , which consumes your "brain cycles". :) [added 23.04.2018, 16:36] IMHO, the preferred way would be: 

You won't need to change your docs, when parameter name will change. Also, I don't know why people use this comment style: 

Eclipse can add this automatically. And this is also something that is useful, e.g., when your GPL-licensed code will be copy-and-pasted in some other project. If so, you'll be famous, which is what programming is about anyway. :) Headers Someone else pointed it out in the first part. But... Do you need all of: 

Don't use -- in most cases it only clutters the code. I prefer to have some distinction between the c-tor parameter and the class' field, so I use "naming convention": becomes in a c-tor. Using prevents compiler from copying every column. 

to remove seventh row. But what does it syntactically mean to subtract from a table? Why is it removing the row? Why not column? Ideally, mathematical operations (, , etc.) should be used only with mathematical objects, e.g.: numbers, matrices, vectors -- but not , I mean mathematical vector, note that the does not have overloaded to add more elements. I think that this is because library designer knew that it makes no sense syntactically to allow such an overload, etc. Such a syntactic sugar could be useful in small implementation, but I would definitely avoid it in larger designs. Consider, e.g., in a 100 kLOC code base that someone encounters: 

Forgive any syntax errors - my VB is rusty. If you can't change the calling convention and have to work with VB6 types, there are similar date handling functions for the VB6 Date type to extract the year, month, and day. The logic would be the same though. The code above can be stream-lined a bit, TargetMonth and ModeFrequency are declared mainly for the sake of clarity. One final note (and this is more something to be aware of as opposed to something I would change) is that the code is relying on how the language handles dates to enforce a business rule. In this case it is when the payment is due if the effective date has more days of the month than the due date. The original code (and the sample above) both assume that the due date reverts to the last day of the month (behavior of .AddMonths() and DateAdd()). Some companies assume the first of the next month. Some companies like the one I currently work for won't assign an issue date after the 28th. 

should be private! File naming I was taught that is a C header, and for C++ it should be used or . I know it is not entirely true, but using: & for C only and & (or & , or & , or even & if you want to be particularly unique) for C++ only provides a nice distinction between C and C++ files without even opening them. It could also be used by some shell script if needed. Further reading: Try: $URL$ 

This shows intent more clearly. (Some may say that too clearly. ;)) There's also another problem with: 

This way you "re-use" the fact that returns / -- so it minimises the burden of analysis. You intuitively expect when some operation returned that something went wrong. This is only if you really need the operator implementation. Personally, I think that it creates more problems than helps with anything. I seems quite concise to write: 

Having braces around the "one-liners" eases adding new code and reduces the frustration related to adding the braces after. No more "I should've added them at the first place". ;) Field visibility These: 

The second thing that I'd mention is a usability issue (and a pet-peeve of a lot of validations I run across). If there is more than 1 thing that is being validated, and the user has to pass all of the checks, let them know everything that was wrong the first time. It's possible to have no capital, no number, and be too short -- don't make the user attempt a password 3 times to figure that out (and don't assume they'll read the instructions first). 

VBA doesn't short circuit the calls, so first you get the value of (implicitly) twice, compare it to two different things, and (then this is the huge one) get the exact same value for every time through the loop. Again, cache values that you need to reuse. This is much easier if you use a loop (there isn't an statement): 

Note, it isn't clear from your question if the numbers in the have meaning outside of the code that you posted. If they are, just make them a property of Advisor. Throw in a couple factory functions to easily generate objects (curse you VBA for not having constructors)... 

It's fairly obvious what .call() is doing in context. I recently came across some articles that went into depth on abstracting the .call() function. The premise is along these lines (this code is verging on pseudo code as I have stripped it down for ease of reading) : 

You're jQuery can be written in one simple function as a catch all for the entire navigation. As you stated you think it could be condensed, you'd be right. As a rule of thumb if you see yourself writing the same thing over and over you should be able to cut it all down into one function. Starting with one of your methods I'll step through it to show how you can condense this and make it more efficient. 

Going into the nuances of having a single Cat that can bark out of a set of possibly hundreds of Cat instances is beyond what you're trying to learn but I'm hoping you get the gist of where I'm going with this, behaviour as interfaces generally work better than types and give you a lot more flexibility when actually determining what your classes do. I'm making general statements a lot here, but you will see that your interfaces become very specific to actions. As such they are smaller and make more sense. I have found it much easier to have a class that implements 5 smaller interfaces than 1 or 2 monolithic interfaces due to the increased flexibility available and it keeps things DRY. 

While the intent may have been to group aliased members, you can make this explicit by just assigning aliases within the declaration itself: 

I pulled this out of my code bucket and dusted it off earlier today in response to a post over on SO that made me cringe. This was originally written to highlight changes in Excel cells in real time via , so it is designed with an eye toward raw speed to avoid blocking the UI. Benchmarks on current hardware are running around 3 seconds to compare 2 1kb strings. I cleaned it up a bit to modernize the coding style, but I'm mainly looking for input on the algorithm used and suggestions for making the code a bit more understandable for somebody who isn't familiar with it. It basically works on byte arrays and tracks the current working position in each array with a set of index pointers for the "start" and "end" of each substring that it's working with. The algorithm is similar to a binary search. The entry point function finds the longest matching substring in the two byte arrays, excludes it, logs all the differences to the output, and then recursively calls itself on the slices of the arrays to the right and left of the match: 

This is really very open ended and is open to many forms of interpretation. The code format below is strictly the way I like to make my code legible. 

I've written this relatively simple class to help with managing arrays of anonymous objects in my scripts. 

Only functions parenthesis start on the same vertical. Objects and arrays are always indented 4 spaces beyond the function. 

The main advantage to this is that the class can be extended easily using other design patterns such as a Facade that further simplifies the class API. It can also be added to easily with further methods within the class body itself rather than by a pure static call. The class can also be instantiated with the keyword providing the ability to create separate cache instances that utilise the same static properties and methods. I need to add this class is very much a prototype that I thought of when I saw your class above. I love cacheing stuff in general and providing standardised interfaces for it is always a great thing to do across all applications you write. 

This implementation actually looks really solid. A couple stylistic and micro-performance issues I would personally address: Array base: I'd remove and explicitly declare your array dimensions. The problem with using is that it is a module level option, and it "taints" all of the code in the module with a non-default setting. I consider it similar to using in C - it alters the semantics of your code. There's not even really a reason to use it in this case because you are always using the to initialize your loop counters anyway. Changing this line... 

Third, turning off screen updating is your friend if you are going to be writing values to a lot of cells. Again, I don't know the use case here, but it is a good habit to get into especially because of... Finally, performance. There are some things that VBA does well, but in general the built in Excel functions are going to be much, much better regardless of your algorithm. I have yet to find a function that I can outperform Excel with if a native alternative exists. First among those functions are look-ups and sorting, which Excel does extremely well. I took the liberty of testing your code with the numbers 1 through 10,000 in D3:D10003, 5000 random numbers between 1 and 10000 in column A, and 3000 of the same in column B. Your code took about a minute and a half to execute (in my resource starved VM). The code below took 10 seconds: 

I disagree with that -- this is why these tokens are keywords -- and I don't use spaces. But this is only my opinion. const-correctness The space character could be . Instead of: 

You won't need to think when/if the first line is only short description. Besides, it also look more consistent when adding file header, e.g.: 

Does it really need to be ? How many rows do you need? Is it stable? Is it robust? is guaranteed to be at least 16 bits long. I would use: 

(Side note: I prefer to have modifier after the type, this frees your brain from remembering how to read such things: .) Also try to have variable in capitals, and maybe name is more descriptive. If something does not change, it does not change. Instead of: 

I also prefer to copy all includes from the header file to the implementation file. The rationale behind this is that it ensures that when interface change is made, it will not impact the implementation file. And you get the implicit-include problem solved at no cost. But I can't guarantee it is how the C++ code is written nowadays. Interface Does it really belong to the interface? 

9 - You have another (less) subtle bug. If you use to have the user select the range to work with, you can't use the global or collections - they have to be qualified. The reason is that you yield control to the user, who is free to select a cell in a different Workbook than the one that was active when the macro started. 

Binding There is absolutely no reason to late bind to the Microsoft Scripting Runtime - it hasn't changed its interfaces in some developers' lifetimes. You're taking a pretty decent performance hit by late binding because all of the calls have to be dispatched at run-time instead of resolved at compile time. There roughly exactly a 0% chance that an early bound is going to create any problems with deployment. 

...makes it immediately obvious that the array is 1 based without having to scroll to the top of the module or remember that the base is non-default. Variable naming: and are about as meaningful as and . Something like and would make it a little more obvious what your code is dealing with. Worksheet references: You are currently using magic numbers to locate the worksheets that you're operating on, and the indexes are based on the ordinal of where the sheet is in the collection. If this is intended to operate on two fixed worksheets, use their class names instead. This has two benefits: first, you aren't using 2 procedure calls ( and the implicit ) to get a reference that you already know and have access to . Second, your won't break the first time you add a new worksheet. For example, use (or whatever it is) instead of . Binding: There is no reason to late bind to the scripting runtime. The interface hasn't changed in this century, and is unlikely to. This is a pretty good performance hit in exchange for absolutely zero upside. Add a reference to Microsoft Scripting Runtime and declare it explicitly: 

The difference is that your routes are mapped to the controller methods. Your GET route would map to the method in the controller. While the POST route would map to in the controller. Also, the GET route would be handled by in the controller. Changing the routes is a case of changing the controller methods. This means one place to change your routes rather than two. 

within a class scope, the Extension object seems to extend the calling objects prototypes allowing me to bind a callback within the class scope. And then attach a handler after I have instantiated the class. 

Example of the chaser and chasable interfaces in action: First lets make our interfaces a little more rounded 

So you now have interfaces that describe what they do. It now makes sense that both a Dog and a Lion can implement . Not only this, any animal class you create are capable of using it without semantic issues. Your interface suffers from the same problem (to a lesser degree). Having a canine interface is probably not a bad thing, declaring that canines only bark or howl is true. Is it true to say that no other animal species can bark or howl? what happens when this cat turns up on your doorstep? (stupid example but I found it amusing) Cat videos aside, we now have a strange edge case where a cat is displaying canine behaviour, but it is not a canine. Enter the interface (that I find both funny and embarrassing).