is and is the loop variable constrained to be less then length. While we are here you should not use as a variable name. It conveys no meaning (this is not fortran). Name your variables. Also think about the maintainer searching for all uses of i is a real pain as the letter i is used everywhere. Name your variables so it can be easily found. Prefer to use pre-increment. 

This can be pasted into e-mail or a slack channel. And if you have a terminal cut and pasted to decode. One more test: 

Comment on Question Can tell if your code matches the problem statement. Because I can't understand the problem statement. Input 

Personally I would just work with the stream. You can get iterators that work on streams just like they work on a text string so your algorithm would not have to change. 

You provide the timing of the 4 different versions. But that is useless without the code (if you wrote the perl version as badly as the C++ version then its not surprising you get bad results). Before times are usefull for a comparison we need to make sure that the tests are comparable. So we really need the code for all four versions. Then we can get criticism of all four code bases and work to get them aligned to the best implementation of the appropriate languages. Once we have done that then we can do realistic timings. Note 1: Stop using 

Identifiers with two underscores are reserved for the implementation (so don't use them). Also MACROS (things defined by #define) are traditionally all uppercase (because they do not obey scope rules (because they are not part of the C language but part of the pre-processor system) we make them all uppercase to make sure that we don't accidentally clash with other identifiers). 

Both are fine. BUT for neat code you should be consistent in your usage. Notice that the only read a single space separated word. 

I could go on. But I think your first task to better organize your code so that it is readable. After that we can go into how it to make it better but you are a long long way from being able to do anything useful. Yoda conditionals: 

But you still allowed the object to be constructed? Now you have an object in an inconsistent state and no way to detect that the object is in a bad state. You should just throw an exception at this point. Let the caller decide if it is worth continuing by catching any exceptions. 

This line is likely to fail. Using your method you need to validate that the pointer is not NULL wither at the point of setting or at the point were it is used. 

The underscore means that it is implementation defined. If there are no alternatives fine. But always prefer standard functions to non-standard implementations hacks (especially if they were done by MS). In this specific case the standard one is better designed and make usage easier. Also why are you printing to a character array then copying to the destination array? 

But you do need 100 of them so you can store all intermediate values: You don't need to loop over an array to initialize it: 

The one thing I would note is; that even though you may be using the standard library well, you are not writing encapsulated code. I would have written the code so that the test could have been applied to the code in the same way that real data could be applied to the code. This mean you have to define an interface to your algorithm. Think about what the inputs are (how real data and test data can be provided). Here you just have a loop inside main(). As a result you are not really showcasing your ability to write good encapsulated code. 

Printing Idioms in C++ I would change the to take a stream as a parameter (rather than default to . Then I would add so you can rint it using normal C++ idioms. 

If you are using dynamically allocated memory you should be using some form of smart pointer to indicate the ownership of the object. If the object is not dynamically allocated then you can use a reference rather than a pointer. But in this case I would not even expose this interface as it introduces coupling (by exposing the internal implementation of the class). Your internal structure is exposed as a public class and you return a pointer to this type of object via . This means you will need to support both of these indefinitely. This may prevent you from improving the class in the future (as both of these will need to be maintained to keep old code working). The internal structure of a class should be kept private. This will reduce coupling with external code and allow you to change the underlying implementation if you discover a better technique without having to modify any of the code that uses your class. Naming conventions. There is no absolute standard for C++ (so take as you require). But a common convention is that user defined classes begin with an upper case letter. The names of objects (variables/functions) begin with a lower case letter. This makes it easy to quickly identify what is a type and what is an object (which is very useful in a language where type information is paramount). Your comments are bad. Comments need to tell me something that is not obvious from the code. Also the code should be self documenting. Thus usually comments should tell me why (or describe in detail the algorithm that is being used). I can read code so the comments should not repeat the code (otherwise you have to maintain the code and the comments to make sure they say the same thing (and that is extra work)). The worst thing in development is finding code that does one thing and the comments say something else. Which is correct (the comments or the code). Which do I fix? So minimize your comments and only write stuff I can not tell from reading the code. Code Review Why are you publically exposing methods that can break the state of the object. 

Register objects Now you should register objects derived from this class with the factory. This will prevent you accidentally passing NULL as a callback. 

The array does not seem like the logical choice for container. You are going to spend most of the time looking things up. This suggests that you need some form of map. Because of its size I would just use std::map. But you only have the true values stored so we only need to check for existence so we can use std::set instead. 

It basic looks like you use as a container then other classes just pull all the data from it and then manipulate it directly via the API. This leaks your implementation extraction. I would reverse the design. The class knows how life is run. Then it updates the GUI via an interface that you provide. 

Not everybody will see as a divide by 2. Don't do that it just makes the code unclear. Use the divide operator it express intent much better (and does not have any worse performance). 

OK. Good start. Rule of three/Five Definition But you have not considered the rule of three/five. When you define a class (or struct) there are three (potentially 5 in C++11) member functions that the compiler will generate for you. These work well under normal situations but when you start working with RAW pointers and memory management the semantics do not mash well (know as the shallow copy problem). The automatically generated methods are: 

That call to is superfluous as streams are automatically converted to a boolean (using ) if the stream is used in a boolean context. Also simply using is a BUG. If you hit the end of input, then your code will go into an infinite loop. Mainly because does not detect the end of input and will not update correctly either. So not quite as bullet proof as you were hoping. Also the use of here seems a bit brittle. If the user typed in a valid input but stuck a space after it before the new line then your code would reject that users input. That's a pretty hard corner case to explain to a user especially if your error message is not very helpful. In this chunk of code: 

Depending on how you compiler implements it. It may potentially be faster to allcoate a block of zero memory and compare it (This of course will be platform dependent). Some instruction sets allow all the following to be done in one op code (each line). But of course any speed improvements you get have to be weighed against the readability. 

The part is a new part of C++14 so you will need to tell your compiler to use the newer version of the standard (that's not a default yet). But usually this means adding to the command line. Templatization Your code does not allow for easy templatization. In fact you don't define in the code sample above. This is more easily solved using templates around a class. 

The other thing I would note about your code is the use of . The standard now provides and . By using these functions you make your code easier to re-use with different container types (especially if you want to use C-Arrays). Note: In the code above I use as a filtering function. Filters are easy to write as lambdas. 

If your function allocates a new string and returns it then it is returning ownership and thus it is your responsibility to call on the result at some point. If your function returns the original string (or a pointer to some part of the original string). Then you are NOT returning ownership and thus the user should NEVER call on the result. 

You have already said the number of results you expect to print. But if one of your inputs is negative then you print nothing. This could be seen as an error. Prefer '\n' to std::endl You only need to use if you want to force a flush. This is rarely true. The streams will flush themselves when they need to at the most optimum time (so you forcing them to flush is usually sub optimal and can cause performance issues). Write logic can be simplified a lot: 

If the user wants a copy. Then all they have to do is assign it to a local variable and you will get a copy. But if they want to manipulate the object in the garage without a copy then you can also do that (so best of both worlds). 

Sorting (using radex) The radix sort is fun. If the number of buckets is the same as the range of your elements then you don't actually need to do any sorting. In your case the range is if is a reasonable number you can create different buckets. Then you just count the number of each element (rather than tracking each one). This makes the sort O(n). 

This separates the implementation from a specific type and allows you to modify the underlying type in the future without having to worry about users of your code changing there code. I tend to group all the iterator calls together. Not intermix them with other calls. 

Your first attempt did everything in one function. You should have split that up. There is UI code/file reading code/sh256 code all intermixed into the same function. A better technique is to separate these out into different things. 

You don't need a test for a boolean condition to branch the code to return a boolean value. Simply return the expression. 

The problem with allocating pools like this (via char array). Is that the language gives you no guarantees about the alignment of . If on the other hand you used a then the language guarantees that the is aligned for all types of size or smaller (see requirements for dynamically allocated memory). The maximum size of the pool is so this can be represented by 2 bytes. So every block will keep a two byte prefix of its length so that when we de-allocate it we know how many bytes have been added back into the system. Note: We need this prefix size even when the block is allocated. Also this means there is a two byte additional overhead when allocating blocks. Also each free block has to know the next block. Again the next free block has a number of in the range so it can be represented as two bytes. Note: This data is only used when the object has been freed. So it can be used by the application as part of the data space. But it means that that the minimum block size that will be allocated is 2 (so 0/1 sized blocks will not be optimal). 

Now you expose an iterator type. But the user of the iterator can not assume anything about it or the underlying container type. Not sure this is a good idea: 

So what you need to do is imbue the stream with information about how to break a word. In this case we will just turn all punctuation into white space. 

So the next thing. Is constructing the object of this class. Integers have no type. So I would introduce types that represent the different units of measurements. These types know how to convert to a Unit of Length: 

So the first update to the above pattern is to check that the read worked and only perform your other actions if the read worked. This is a perfectly acceptable way to do it. But it is still not the best way. The standard way of reading from a stream is to put the read test in the while condition. 

Get Integer is well done. Most people forget to test if there is anything else remaining on the line. A simple enhancement is: 

But surprisingly I normally I prefer using the when the object is a pointer (or bool). I think in this case it is because it is combined with testing a nested member of a structure it just does not look correct (but as I said it is an arguable case). Edge Case What happens if the list is empty?