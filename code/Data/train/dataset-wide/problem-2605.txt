If the pointers never overlap, let the compiler know that and allow it additional optimizations using . 

Unclear code The approach of a copy with is unclear. Certainly code could use a single pass. Look into using and to find the and delimiters first and then parse that token, perhaps in a helper function. 

Later. Information hiding Code does not detail what might be the part and implementation part. To this end: 

When dealing with user input, avoid being a hacker target. Step 1: check user input function results. 

Choose a consistent integer type down converts to . If the prime test is for s. I'd expect consistency. should be the same type. As this is a prime test and no need for negative numbers, consider or go for widest like . 

Use for array index types and the result of . may not be the right size to use as an index. (Also in ) 

Rather than initialize a pointer with a value the will shortly become invalid and non-testable, set to (or "yuck", a version of ) and adjust the to not de-reference the pointers. 

Not much left to review given the other good answers. Some additional ideas: Lopping off a Certainly OP meant to lop off the usual trailing . The below lops off the last character from a line of input, regardless if it is a or not. 

Rather then bury magic numbers 9, 18, 20 in format specifiers, consider for the width. Then compiled code could pass in the computed width. Similar thought for 

Other notes Notice how the below size works without even knowing the type of the pointer. This is less error prone and easier to maintain. 

is sufficient. The complete definition should exist in to unburden the user of details and prevent direct access. Further, consider doing the same for . This implies the initialization returning a pointer rather than the calling code allocating space. Also some get/set functions needed. Yet data abstraction helps in the long run. Auto formating The below and others imply a manual formating and is unproductive. Adopt a suitable auto-formating style and tool. 

With using a sub-range of , then does not look like a proper test. I'd recommend a review and tolerate mine fields as small as 1x1. Ah, I now see which handle most of this concern. As is no longer the mine field height, use of a different variable name would add clarity. maybe? Either way, is likely incorrect. Perhaps Non-standard code My compile reported: "ISO C forbids omitting the middle term of a ?: expression". 

Code uses the contents of , before knowing they are valid. When returns , the state of the buffer contents are undefined if an I/O error occurred. Best to not inspect the buffer when returned 

Unclear why code is using for flags. linux.die.net implies the type should be . Check your prototype for - also its return type. Is it or Ref? Although code nicely aligns, I'd expect an structure rather than 

is a naked magic number. Give it some self-documentation and explain why 33. Same for . What is the about? 

Good stuff Impressive early use of signal handling. Good formating. Good comment level. Functional error? Something thing is amiss concerning and . I'd expect possible values for , not . 

overflow - which is undefined behavior See below: Assume was text version of . will cause to take on values increasingly closer to and then can overflow. (UB). , which is in this case, is alway true as long as is positive. only becomes negative due to the UB of overflow of . Code may appear to perform correctly for OP as typical UB here is to wrap the sum to a very negative number and the later coverts the negative number to an with the hoped for compare functionality. Yet it is too late, UB has occurred prior. 

Though not yet employed, consider using the return value of non-0 for an error indication should some field or parameter be out of range. 

Calling with simple will not work. The code is only checking if the first of the string matches its end. Original reverses the contents of . This may be an very unhappy side effect for an application calling An efficient re-write of would find the length and then do compares. 

code fails as it does not initialize . The size of a file and the range of are unrelated. Assume file sizes could be much larger. 

Use when able. As the string pointer to by is not modified, add to allow wider application and potential performance improvements. 

Good formatting and layout. Aside from bug, good code. Bug? I'd expect , per Tiny Encryption Algorithm. 

Better to determine size by the referenced variable than the type. Easier to code correctly, review and maintain. 

C1. is OK code and like-wise allowing to free again a link list is good. Just clear the head node to an initial state. Detail: should be able to be followed by a another . 

certainly needs a number like Nice use of in Use of in error handle is a reasonable exception to the never use . Useful when multiple error points. In the end, rather have code do complete error checking with than elegant without error checking and without . 

Do not recommend the shuffle algorithm employed - it has weaknesses, Consider Fisherâ€“Yates When possible, make array pointers point to data. It self-documents code, allowed wider application and some optimizations. 

IMO, should be explicitly specified in the .h file as to the functionality. OP's code return a non- pointer. An alternative it to return . I recommend OP's approach, with documentation. 

Certainly is meant to fail with negative numbers, so direct application of family of functions will not work the same. Another difference between and is that rejects strings that begin with white-space. Based on codes usage of , the seems to be an unimportant difference. The design of is weak. It can "fail" at least 4 different ways. It returns 0 or on 2 of those, unspecified on overflow and has a technical undefined behavior (UB) with when . Suggest instead to return 1 value, like , for all problems. A name like would add clarity over . 

and the other 3 s only need to declare the pointer type with and then declare the functions. The definition of the type can occurs later and not in the public section. How many ? Often code needs to assess the range of an enumerated type. Useful to add a as the last one. 

No provision for numbers. (or ones with a leading ) No provision for trimming leads in answer with input like No provision for non-digits as in Simplification 

"Is there a "better way" to shift items? memmove" is deigned to be very efficient. A good replacement for the loops that shift data. Example: 

Advanced idea: this whole approach can be simplified using mostly integer math. I have not yet coded a solution yet it go like this. Consider each set of 3 points: . Form points D and E which are extensions of segment P0,P1 and then +/- 45 degrees off for a distance of P1,P2. If P0,P2 is less than P0,D and P0,E, then it is a sharp angle. 

is not a static function. Suggest to either 1) make it static so it only receives qualified arguments or 2) make the function more tolerant of values of unexpected values: 

Needs to be applied to both integer and FP test. allows trailing white-space. Both and allow leading white-space. Double is more complex as in the case of underflow like "1e-10000", the may set and that is usually not considered an error in many uses. The returned value will be either +/-0.0 or a small value. 

Pedantic (meaning only the crazy care): When counting elements of an array, recommend type rather than for , . Either that or fail if is to exceed . The main issue here is security. If a user can break your code by pasting in insane long string (when ) it represents a remote possibility. Pedantic: The approach (@Bobby) will not overflow the digit count for insanely high number of digits like the present code. 

Overall: Recommend to not causally mix , and . Too many cases where code would fail by using both pairs. Suggest using instead of with a test. (or fix/test the casual conversions.) 

Weakness: unnecessary loss of accuracy. The above simply throws away the least significant bit of . To improve accuracy, this division would benefit with a "round to nearest even". About 1/2 the time when a bit is shifted out, the quotient is incremented. Example code to demo improvement. 

The whole messing with and math relies on 1) (something not specified by C) and 2) does not detect conversion problems with . Suggest a new approach that only uses math. 

gains little here as the certainly of null character termination relies on the prior code in a not so-obvious-way. 

too small. Code makes a table the size of , which is 1 too small should . This leads to undefined behavior (UB) and code should be amended to handle all letters. 

is strange in that it never uses . Certainly incorrect functionality. Highly suspicious about the correctness of the value of in . Such terse variable loses clarity as to it role. 

Array sizes are best typed as as that is the type return by and work for indexing all arrays. Otherwise, why use ? It may be too narrow (once 32,000 is eliminated). 

Not too easy to re-organize too much without violating coding goal of "demonstrate the proper way to use format specifiers for different data types". Perhaps a helper function to print the common prefix and size to un-clutter the demonstration. 

vs . is well defined in the C spec. Consider negating the macros and using . does not change elements of . Consider Like-wise returns nothing, yet such a function certainly has many chances for I/O, allocation errors. Better to return an error code. is so removed from use and not detailed as to why it is 25 leads to a potential future problem when it gets changed from 25 to TBD. Suggest a more meaningful name and size to meet the needs