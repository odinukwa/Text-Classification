When testing the algorithm against other implementations it seems to work as expected and without a thorough knowledge about calendars it is hard to comment on the details of the algorithm as is. From a computational or mathematical point of view it is possible to simplify or make the formulas a little clearer by removing unnecessary parenthesis and just rely on operator precedence: 

There are a couple of simple errors: 1) In you replace the next line with the second part of the split instead of inserting it after the first part: 

Your handling of state is nice and clean and easily maintained in that you always create a new instance when ever Buffer or Cursor changes. But it requires objects. Cursor is not : 

Zeta gives a thorough answer; I'll just add the following. The operateCaesar function could be written as: 

I would return in the outmost function too to avoid the call to ToArray() in order to let the client decide how to handle the output: 

Note: If you try PrimesBySieveAndLinq.GetPrimes(int.MaxValue) it is very slow at the beginning, but speeds up after some 1000 of primes. 

I think your code is not that bad and for small segments and data sets it is all right. May be a better naming of the class Estacion would have turned you in the right analytical direction. I'm not that familiar with your language, but I think translates to or in English where a more appropriate name would have been or . The class is error prone in the following way: In the constructor you calculate but both and (and ) are public properties and may be changed in the process which will leave the object in an inconsistent state. In stead you should make the a read only Property as or . As for the algorithm it self I think Janos' analysis says it all. 

which is a misunderstanding of the concept in that an method (unless it is a UI-event handler) should return . In the new implementation is removed. This has the positive effect that when is called by and the parameter to has more meaning. In the first version that call returned immediately after starting which in turn in fact was the long running thread. It is in fact possible to await a call to like this: 

One Class Once you see how the eliminates all that code then I hope you will see that this naturally fits in with the . It's a common thing to see, breaking out code into arbitrary classes in order to corral the clutter. Our new structure will do that for us. 

Yes. Yes there is. Think about the logic at any given question/answer and make it work for every question/answer. The result will be a single function. We are at question #2: 

Build data structures to generate more tests instead of writing more test code. It strikes me that the amount of test code explodes with the need to test more involved graph complexity. Test code must be as thoughtfully architected as the target code to avoid all the bad things about poor OO design. Looks like your tests are basically the same except for hard coded method parameters. Make the method parameters variables then you can have a single test method. 

from a previous answer: The Document object shouldn't be responsible for checking for duplicates. But should define what a duplicate is. That is to say... 

Holds a single colour. Change name to . The name implies its used in class. class does not use it; if this is a more general "colour", then perhaps rename it . class has , . Should these attributes be properties? vis-a-vis . Seem redundant to me. Isn't property unique per se? Or do you want two "black" to have different s, for example? No public setters You defeat the purpose of the constructor by allowing explicit property settings. And in the long run its a bad idea in general. Rewrite to: 

in a sense is implementing for another class. should only have to ask "give me this requestType". Something like this: 

Now What? Where/what do you want this to evolve to? Not much else to say w/out that vision. Nonetheless here's my "first thoughts": Hit vs Sunk The should end with the ship sunk. This is a good place to start evolving the code because it addresses the core state management of the game. Getting core fundamentals right profoundly effects the entire app code and structure. And "hit vs sunk" necessarily motivates structural changes of the game's objects. My immediate thought is the ship itself. Firing Encapsulate the random number generation into a method that exposes the idea of firing the gun. I think there is no point of a particular ship firing. That may be obvious from actually playing "battleship" but these sorts of things must be explicit. Ship Class Will have to know how many hits it can take and how many it has taken. The fact that a ship has 1 or 20 "hit points" should not be exposed in the loop or anywhere else. The ship may know where it is in the ocean (every ship has a navigator doesn't it?) - so it can tell if it got hit. 

I need to define an entity () that contains and manages two collections of identifiers ( and ) that are ids of some other entities (). The business rules are the following: 1. The collections must contain only unique identifiers. 2. The same identifier cannot belong to both and . 3. Identifiers can be added or removed (performing the checks above). Note: Adding an identifier to the is not opposite to removing it from the . For instance, there is a list A that contains included lists B and C and excluded list D. That means that . An attempt to add list C to the leads to an error while C is in the . If the list C is removed from the , the list A will be the following: . I introduced two properties to get the collections and four methods to manage them. There are few areas I'd like to hear some feedback about. Which variant is better? Property naming 

The tests should be easy to maintain and understand. That is the tool that drives development. Sometimes it may contradict with the widely known rules you mentioned, but it does not mean we should be fanatic about that (as soon as the tests drive the development and work as the safety net). 

Also, you have to create an instance of the wrapper in the production code, haven't you? So, what is the purpose of the static class then? Static classes are inconvenient for unit testing. Instead of introducing wrappers that mimics the original class, you can simply get rid of statics at all and go with simple 'injectable' abstraction and implementation: 

That's totally fine and even more - introducing 'common' initialization logic increases coupling of your unit tests. Imagine you need to add a new 'common' line to setup things common for a few tests. You never know for sure if there are any other tests impacted; you may make your tests false positive. It's more safe to modify your test 1 by 1 as necessary. Tests like have about 6-7 arrange lines and 2 assertions. IMO, it is easier to read, understand and (!) maintain this single test than splitting it into two (or more) just because of the 'one assertion per test' rule. That looks like Facade tests. That might be fine to have them at some level, but it's important to understand that tests like that may be a bit more hard to maintain since there are more parts that might be broken during refactoring. Don't have any oppinion on that... Looks fine to me. 

EDIT I admit that Husk has a point about especially in where the length reach as much as but tests on my computer shows only a pair of seconds in expense for n = 8. The algorithm exhausts the stack for n = 10 anyway... As an alternative you could use which seems to have the same performance as Husks version. 

If you've showed the environment the function is used in, the review could be more useful, but I think your reasoning is right, except that Lazy is used to defer instantiation and you actually use the lazy-created object () the first time it is called for by returning DataCache[key].Value. Therefore Lazy is of little use in this context as its object is instantiated at the same time as the Lazy. IMO your DataCache would give more meaning if you up front filled it with all possible queries without actually using them and then call them as needed. Alternatively you could just cache the queries directly in the DataCache without Lazy. 

In the way you show that you create each Skill instance, you really have anything than the Description to distinguish them from each other. I read your Skill class as merely an advanced flag that defines a small set of properties. In the below I further anticipate, that each skill type doesn't change throughout the game. If that is correct, then I would make the Skill class as a "singleton" per Skill type (onehanded, twohanded etc.) and let a static Factory method create/return the right Skill according to a Skill Type enum: 

2) When checks the input list it does not find changes to items in the list, if they are of reference types. In your test environment it find changes to the string items, because a string behaves like a value type in this case and the changes made to the string actually make a new string - not a change to the existing string object. So your method actually finds a new string not a changed string. If your list was a list of a class like: 

The definition of "I have no manager" (e.g. a zero) is in the class where it belongs. Every new employee automatically has no manager by definition because it's build into the DNA of the class. Who's your Boss? Warning! Confusing and ambiguous code ahead! 

Proposed Experiment The code structure is lousy. There is testing for and all over the place, and even repeated in a nested loop. I have to read and study a lot to figure out how the query is being built differently based on these conditionals. Re-write the code to examine the conditionals up front and separate code for each path. This will result in some redundancy I guess but the point is to see how the code becomes clean and understandable. Personally I'd go for clarity over some minor duplication in this case. But you should be able to DRY that up. Broader scoped common variables or via method parameters. 

Looks like you'll have every rule iterate the order items. I'd rather see the iterate the items; and only once. 

Once refactored, put around the database code. Catch specific exceptions thrown by your database engine. P.S.DTO mis-application leads to bad code: property-only classes manipulated by massive "manager" classes containing complex/nested control structures in every method; with a sense of redundant repetition everywhere. 

Warning! Arm Chair Quarterbacking in progress. Given that I offer this. Game Class Why is this in the ? You need a "driver" for a chess game and that would be a class. "A game consists of (has) moves" makes more sense. The gives us a conceptual framework for a richer chess game. A has players, may have a timer for speed chess, and can keep track of pieces removed from the board; and of course records the moves. Board Class The chess board is a data structure. Don't make more of it than it is; nor less. In the Visitor Pattern the data structure has-a element that has an method. That element seems to be a . I'm not certain if it's better than the being visited, but certainly the point is that we're evaluating the state at that one square? I don't see a big deal in giving a board reference to each square. OR .. maybe the s are visited. To test if the piece is "inCheck" for example. This perspective makes more sense than a square is in check. Is this why your board is and not ? Whether we are visiting the board and iterating the squares; or iterating the board and visiting the squares; or iterating the squares and visiting the pieces may be more than semantics. I vote for whatever best reflects intent, gives me good code expressions, and sensible building blocks. In any case I agree with @bowmore about refactoring to . Pieces Even given a rich class, I like the idea of using an enumeration for names. This makes for nicer coding and expressability overall (and my pet peeve - it avoids strings). Maybe two enumerations. As in and ; or , And a value to represent an empty square might be nice or . Maybe has a reference so it knows where it is. This may have a nice effect on the code. Visitor Pattern Nice call. I agree with @MarcoForgerg, the visitors do not need to keep state. Just pass in the needed parameters and forget-about-it when done. And, instead of Singletons perhaps just static. Nested visitors? Ok, so the board gets "visited" which in turn "visits" each square, which in turn, finally gets to . Visitors, by definition, understand their visited data structure so I'm thinking board iteration is wrapped in the board visitor, and the square visitor knows to check for an occupying piece and knows what Evaluator(s) to pass to the piece. It feels like nicely layered (code) logic to me. And note how the iteration logic is in the visitors, not the board (data structure). And subsequently all the business logic is in the visitor as well. SO instead of this