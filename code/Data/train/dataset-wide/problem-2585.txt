Behold, a thing of beauty. One should never underestimate the value of self-explanatory code (if only the constants here). The Main Application All that remains to be done is the demo application itself. It sets up some factories, and starts an input event loop to receive keyboard shortcuts. Handling them is pretty straightforward. The stopwatch-specific operations ( and ) are the only mildly complicated ones because they will have to filter for any running tasks that might be stopwatch tasks. Launching a task without selecting one or more views to connect up will result in a and nothing happening. Note how clearing the or automatically destroys the right subscriptions (due to the use of ). 

Okay, after I worked my way through the original code, a few things have become clearer. Since I have never done programming with I was eager to try my hand at a better design. Here it comes. It's a sketch only in the sense that I didn't create separate translation units. That is basically a tedious exercise and left for the reader. However, it does implement stopwatch (including lap times and reset), countdown and a bonus "random timer" task. 

Something I didn't fix, but you definitely should, is the use of a single list as both a black- and white-list. It is much easier to create two different lists, and check each of them seperately. because now you have to keep thinking 'is this list a white-list or a black-list?'. Conclusion Methods should focus on one thing as much as possible. By seperating code into methods we reduce duplication and increase clarity. Lastly, by preferring early returns we prevent deep nested if-statements, again reducing duplication and increasing clarity. 

If the sender doesn't have permission we send a message and return quickly. We don't have to worry about permission for the rest of the method! Let's do the rest too. It looks something like this: 

I don't think it is good practice for this sole reason: You are relating a class with its name, meaning that now you cannot refactor the class names without manually changing the enum values. This can ultimately lead to compile time errors or errors when accessing a web page, it will create maintenance tasks, though I do not think they can cripple a system. Furthermore, you are using raw objects, they should at very least be typed as using generics. And lastly, you should be making variables wherever they can be, which is not happening in the enum approach right now, despite that it could've been done using this approach. As alternative I suggest to start by creating a class that holds the data for every : 

Post Scriptum These are random notes. Specifically, I didn't mention important things (like brace style, const-correctness, use of raw arrays etc.) 

Note this is still basically exactly the same algorithm (modulo the bug you had in the condition), but it is now much clearer what is happening, and why. Note that I moved the logic to check for previously-visited actors inside to avoid duplicating that logic: when reviewing your code I had to think really hard whether this block of code was actually necessary/correct: 

Using Memory Mapped Files And Spirit Taking the approach from my answer over at [SO]: $URL$ I changed the implementation of into the equivalent: 

A bug in your line 97 (the should be ); your code might never complete, for some inputs The birectional search does not in practice improve the speed (note; worst-case behaviour will be improved, but at the cost of complexity) yields significant speed up (on average, there are <=10 relations per vertex) Destructing the maps takes significant time. This is one of those rare occasions where I'd suggest purposefully leaking the memory since you know the program will be terminating anyways. 

These strings are all constants and should be defined at the beginning of your class. They should look like this: 

The implementation seems fine. I would change the return type of the method to be a bit more general. Callers don't care about whether the duplicates are stored in a Set or not. 

The most important thing we've done is create a seperate method that will check whether a block is minable. By using a seperate method, we can focus the onBlockBreak method on 'what to do' instead of deciding 'when to do it'. The rest of the method now looks like this: 

Notice how it doesn't have to care anymore about whether the block is blacklisted, or the current lightlevel, or any of that stuff, we moved all that to the isMinable method. This allows the onBlockBreak method to focus on one thing, and makes it much easier to read! The isMinable method looks like this: 

The remainder is the setup for the DemoApp, which includes rather boring stuff like generating random view positions. 

ยน I am aware of the usual implementation in hardware stopwatch devices where the operation modes form a state machine. I also realize that the implementation in code tried to mimick this. Unfortunately, not only did it fall short, it also conflated things with the UI side of things. Consider this answer a finger exercise on my part. 

The BFS State I've defined this as simply the "grouping" of things you have prefixed in and flavours. 

As you can see, we made the intent of the loop clear: we swap the contents of the queue with an empty one. We then loop over all previously queued nodes (the ). At the end of the step there might be new queued items, but none of the originally queued nodes will be. If there weren't any items to begin with, we return . 

Your line seems to be off, might've been due to putting the code here, you should remove 4 blanks. Take as example this line: 

To illustrate, I have decided to reformat the class to how I would've done it and I think it looks way better now. 

I first played around with , but it turned out to be only of use for formatting, and not for parsing, as it only gives one specific format per locale. So I decided to roll out my own code whilst still intending to use as many Java library features as possible (mainly from and ). The test class: 

To get familiar with the Rust language I've decided to implement the method of Sieve of Eratosthenes to find primes up to a number N. I have created the following code that both prints the prime number and whether it is prime in tabular format and prints a vector consisting of the prime numbers. As additional library I'm using the external library bit-vec. 

Notice how all it is doing is passing the call on the the other methods when it is appropriate. onNfbmCommand Let's look at the onNfbmCommand Method. This part is difficult because it contains a very large nested if statement. This makes it hard to think about, so let's see what we can simplify. It seems both branches are actually almost the same, except for the specific message they are sending. In other words, it doesn't matter whether the sender is a player or not. We can use that to our advantage! First lets create a method that sends a message to the sender with a color if it's a Player and without a color if it's not: 

But honestly, using stream/filter doesn't make it much clearer. Why not stick with the standard approach? 

Where the latter would be called once you successfully have obtained the and that one would do the low level job. Conclusion My conclusion still is that the code overall is fine minus the coding style issues, but these improvements would improve it. I think it is also better than a Singleton class, because this to me simply looks like an utility method, hence warranting a place in a class, but I do not see a reason for a Singleton class for this. 

I'd like to get the code below reviewed on all aspects, specifically I wonder if it's common usage to use like this, as currently more computations are done in the statement than in the rest of the code. 

The code is not intended to work with the and classes just yet, I have only included those classes such that the code is complete. The code is also available in my GitHub project. 

But we're still stuck with quite a big nested if-statement. To get rid of this nesting we can use something called a guard clause. Which basically means we're checking things as early as possible so we can return quickly. So in this case we can do this: 

Here you are giving a warning that the configuration is wrong, but are still continuing with the invalid value. Why not set the value to its default value? 

This comment doesn't add much and can be removed (after all the code says the same thing). Perhaps it is worth mentioning why you are saving the configuration when the plugin gets enabled. loadConfig 

Overriding the incorrect configuration with the default value would save you from having to keep track of the temp_disabled flag. onCommand