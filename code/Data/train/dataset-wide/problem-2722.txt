You can of course use other data structures with better asymptotic complexity, but since there are only \$2^3\$ instructions this might be an overkill and should be benchmarked. But wait a minute: the return type has changed. That's because the text is allowed to have superflous characters. and are the same programs in oOo. This leads to a slight change in : 

It's still the same, although now heavily inlined. Exercise: Check whether works the same as . Now we need to several times. We can generalize something like that: 

Regardless, the string type depends of course on your later use case. Since hints that you will decode JSON, you will likely use aeson later, which uses lazy s as well. Given those functions above, we could now write as 

So this would be a way to improve your runtime tremendously. Further places for improvement is too opaque, it's not clear what you're doing. Try to split it into several sections. For example, all those lists of symbols can be abstracted into 

You can keep the functionality as a "one does all", but for testing and maintenance it's easier to provide a larger interface. Do not reinvent the wheel (unless you want to) There are several libraries that provide argument parsers, for example . Those libraries make it easy to handle command line arguments without a hassle. Also, a for two possible option variants is slightly an overkill: 

While we're at it, add some documentation. and are only some lines away from each other, but that might change later. The after is Doxygen specific, you can ignore it if you don't use Doxygen. Declarations and initializations You use C99 and therefore can declare variables as late as you want. Whenever you declare a variable but set it a lot later, try to rewrite it as initialization at the right point. For example, isn't used until . We should keep it's scope limited. That way we cannot accidentally reuse variables. If we follow this suggestion then , and get limited in their scope. We will have a look at that later, though. And since we already renamed to , we could also rename to . You can of course choose other names, but again: there is no need to abbreviate. Disk space isn't expensive anymore, so choose names that you still understand after several months or years when someone calls you in the middle of the night. Input and usage may not return . That can either happen if you're at the end of the file or if an error happens. You should check the with or if that happens. We stay at . While it's unlikely that you change 's type, it's usually good practice to use or . If you ever change to , you don't have to remember to change to . State machines and repetition Your loop is essentially a state machine. The state machine itself looks fine. However, there is a lot of repetition. We have 

comes in mind. You can still use the same logic as above, but now the (possibly infinite) tape can get tested without running an actual brainfuck program. As an exercise, write 

Otherwise you end up with a deleted, but not nulled . Call-by-reference Use for arguments if you're not going to change them afterwards. 

Irregular names Some of your methods start with a lower case and a verb, others start with an uppercase. You should probably sort that out. Use instead of Unless you really want to have single precision only, use . You can use something like 

still applies the parser (and therefore changes the state), whereas applies the parser and collects a list of . Similarly, we can get rid of in 

Now that you can see all cases, it should be obvious that your missing at least one, namely the one for the empty list . Also note that using and isn't very efficient, since you need to traverse the list twice. You could write a function like 

Unless you're fine with those functions at global namespace, it's usually a better idea to either a) use a complete name, e.g. , , or b) prefix/suffix them with the type's name, e.g. or . The story slightly changes if you want to use lenses and Template Haskell, but that's for another post. What follows afterwards are several top-level functions without type signature, which is considered bad style: 

The here is quite hard to read, especially since there are two operators next to each other ( and ). A simple is easier to the eye: 

Other than that you stuck to a single indentation/braces style, which is great. Reduce complexity You have both as a reference and as a referee. I guess you had two s at first and then removed one. If that's the case, I suggest you to remove one of them next time. The compiler will tell you where the variable has been used and you can do a case-by-case decision whether it still needs to get checked or can get removed. Split functionality This is likely a toy program for you to fiddle with , but for a library split your functionality into several files, e.g. 

That's again a DRY violation. If you change the price, you have to change it at two places. That's error prone. Instead, reuse the information you already have at hand: 

looks exactly how you'd imagine it. It doesn't need to be in , as it does not inspect the state, but let's keep it there for simplicity, again: 

all your s need to allocate, even if they never get used one cannot use with types that don't support default construction 

Note that in both cases marked with , you pattern matched on and used . That's not necessary. So all patterns are: 

Get rid of the list. No, really, it's as simple as that. The sequence of s in will be non-decreasing, so essentially you could switch 

That's important as soon as you change to another type, as the compiler can now issue warnings. Make function-specific read-only data and The in never gets changed, and only needs to get initialized once. We do not need to conjure a new every time. Also, we have to make sure that we don't change the contents of , so we should make it : 

At this point I wouldn't change the code anymore, unless I see via profiling that or is a bottle-neck. If you really notice that is a bottle-neck, you can use , but I guess that the compiler should optimize above code. 

That's easy to read, and more likely to be correct. Either way, I assume you know that, so let's get started with the actual review. Try not to shadow existing names We return to : 

Pattern matching or list element selection? It's possible to reduce the size of , , and so on if we use on a list instead of pattern matching. That's a completely other style though: 

I will show how I did the latter, so it gets easier to understand. First, if we do nothing in an , but everything in an , it makes sense to exchange those, e.g. go from 

But that might be your design, so let us ignore that for now. Instead, let us have a look at your first cipher. Caesar The nice property about Caesar is that you can encrypt the same way you decrypt. If you move a character characters forward, how many characters do you need to move it to get back the original one? . With that in mind, we can heavily reduce the size of : 

Other than that, your code seems fine. You could use better names and documentation, but given that you write code for a code challenge, it's not that necessary. You might want to use a binary search for your limits, though, if you need more speed. In , you can speed things up if you use bitshifts instead of . You can speed up if you calculate the Fibonacci numbers there. That prevents you from calculating the same sequence over and over again. Hint: you can implement as a generator, which makes this a lot easier. 

What would Bob do? You've written an interactive program, but the user does not know what your program does. Therefore, Bob—the generic user—might accidentally write "test" instead of a number, and suddenly your program runs wild. A first step in the right direction would be to tell the user what your program will do—as long as its interactive. Note that this is not C++ specific. We can do so by starting with: 

Now you might say that this is an obvious malicous attempt to break type safety. However, we don't need to do that. We can just write our own variant by accident, for example to use some list functions: 

Allright. Now let's try to get a variant of Haskell that's just as readable. We do that by explicit recursion and then later figure out how we can get rid of that: 

Which seems reasonable. Another approach While one can solve this problem in this way, one can also just generate the prime factors of the number: 

That way you're also more likely to expand the documentation in your implementation file, not only a brief comment: