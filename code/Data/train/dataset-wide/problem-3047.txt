Avoid the looping Even simpler would be to push all items with the spread operator, since Array.push() can accept a variable number of elements: 

Put the filtered users in a computed property. One could argue that the difference is small - it adds a couple lines, and the function is technically still called the same amount of times, but it takes the function call out of the markup. 

Additionally, the first iteration, to count the occurrences of each element, could be simplified using a ternary operator: 

See a demonstration in the sample below. Notice how there is now a clean separation of the event handling logic (JS) and the markup for display (HTML). 

Store DOM references Every DOM-query (e.g. ) is expensive. Instead, store those references in a variable and use that variable instead of re-querying the DOM. 

As far as making the code "secure from exploits", that might be tough to do with JavaScript, unless you take tactics like minification/obfuscation, etc. The suggestions below should allow the code to be more robust. Naming , and aren't very descriptive. Better names might be , , , etc. Additionally, the variable in the loop (i.e. ) is not declared using var so it is put into the global namespace. Allow number of population columns to be dynamic Currently the code only allows two columns of populations, and hard-coded to years 2000 and 2005. The table headers could have a class added: 

So it might be wise to create an element and have that element appear/update when appropriate, instead of using . Rewrite See the code below, which takes into consideration the recommendations above. UPDATE: Apparently using the attribute is forbidden. In that case, a simpler way to ensure that all questions are completed is to use a FormData object and then get the keys with FormData.keys() and because that returns an iterator, convert that to an array with . Finally, return the equality of the length of that array with the array containing the correct answers. 

Then in the callback to .change(), accept an argument for the change event - e.g. - and check the target property 

Then there is no need to wrap in calls to the jQuery Selector function (i.e. ). And after the loop, then add that table element to the DOM: 

Actually, const could be used instead of var (unless Browser compatibilty is an issue (e.g. if you are supporting users with IE 10 or earlier). Using jQuery It appears that your code utilizes jQuery (based on that last block in the Javascript section). Because that is available, the DOM lookups can be written in a shorter form - e.g. 

While that is only one less line, there is no need to worry about adding statements (some might argue it should have been added in the case). It could also be simplified by moving the assignment from the block to the initial declaration: 

Hopefully the response by James is sufficient for your concern about best practices. I did notice some redundancy in that snippet of Javascript. Specifically, the line that handles adding the nonce attribute to the script and style tags could be simplified: 

I don't see very many improvements I would make, though I do see a couple places where native PHP functions could be used instead of manually iterating over arrays. These changes (in the first couple blocks) shaved a few milliseconds off the total time - e.g. from ~194ms to 169ms. filtering friends in The filtering of friends in could be simplified using array_diff(). I.E. this block: 

So in the argument will refer to the current instance. Replace with and then any place was previously used to access the div element, refer to . Also, call and on `this, since we will be converting those to methods as well (see below). 

Note: the variable didn't appear to be used, so if that is necessary, you will need to update that. And those can be used to clean up the code to fetch the lists of items: 

See forked fiddle here. Note: and are not supported by older browsers - e.g. IE 10 or earlier. Refer to the Browser Compatibility sections for let and const. See this edited version of the forked fiddle. Also you mentioned it not working in IE 11 - I tried the original version and noticed errors related to jQuery. I tried porting it to jsbin. I noticed there were still errors with jQuery and updated the jQuery version to 3.1.1. That seems to help. 

See a demonstration in this Playground example. Functional approach to iterating over rows One could also replace the loop on the rows with a call to array_map() in order to get the array of words for each row (and pass that to array_filter() to eliminate empty rows), though the statement would be required in order to access within the callback. 

Are there really separate query string parameters and , that are different than the form field value (i.e. two different variables in and another in ? Also, is the second block (i.e. ) supposed to use the values from POST data instead of the query string? 

That way the IDE will know that the property should at least exist for each instance (though it might not be assigned a value until that statement). Other Feedback Switch statement cases: 

Your code could be considered a representation of polymorphism when considering that the function was changed for a single instance of the customShape type, but that doesn't really apply to all objects of that type. Traditionally in Object-Oriented programming, sub-typing would be used to create sub-classes that inherit the properties and methods of the base class. You created instances of , but didn't really make any objects that inherit that functionality. For instance, you made the triangle instance and added a function (like a method) to that one instance: 

Cache DOM lookups Even with abstracting that code into a function, it would still be performing a query on the DOM. 

So you might want to consider doing that in the method. Functional approaches Functional approaches, like using array_map(), array_reduce(), etc. could be employed, although in some places it would require extra work (e.g. employing the use keyword to reference variables outside closures)) and may be slower because a function is being called. For example, method could be re-written as: 

let vs const In function , there are two variables and declared with the keyword . Those variables don't appear to get re-assigned. If the value never changes, why not use const? Actually, there is this block when is equal to the three gamestate values: 

Bearing in mind I am not an expert VueJS user and have only been working with it on small projects in the past year, I can't really think of anything... If you really wanted you could consider using slots somehow, or an Event bus if the components became more separated but that might not be nessary since everything is contained in the main RoyalGameOfUR component. If I think of anything else, I will surely update this answer. 

Because will spread the arguments out to match the parameters (i.e. ). That way there is no need to iterate over the items. Array.concat() could also be used but then the array would need to be re-assigned. Or Array.unshift() could also be used with the spread operator. Expand the snippet below for a demonstration (AngularJS code removed for simplicity). 

D.R.Y. There is a widely accepted principle amongst developers: Don't Repeat Yourself. The following block appears three times (with varying spacing): 

Feedback The code looks pretty good. The styles are laid out pretty well, and the JS is pretty succinct. I like the use of data attributes and modulus division for the counter values. Suggestions CSS The style appears to be used for a majority of selectors, and none use any other alignment, so move that up to . Javascript Update class instead of style directly Instead of storing the images in Javascript, put them in CSS classes. Then update the class (using jQuery's and methods) based on the counter value. That way, the CSS can be updated without having to update the JavaScript code. N.B. _Initially I was thinking an advantage here would be that it would be less expensive but most browsers will still have a reflow when changing the element's class attribute as often as the original code. Read more about reflow here. Use an event delegate Instead of adding a click handler to each element with class and the button with id , use event delegation to handle all clicks with one function. Then check to see if the event target's id matches the that of the continue button, otherwise if it has the class . For more suggetions about Javascript, see this post - I know it is a few years old and bases jQuery but has some good information. Rewrite See these suggestions implemented in the rewrite below 

More tips in article For more tips about improving Javascript that interacts with the DOM, see this post: Stop Writing Slow Javascript. I know it bashes jQuery initially but it has some very helpful tips (and nice quotes). 

Actually, that function is deprecated as of version 3.0. See the last paragraph below for more details on that topic. 

This could be simplified using array_shift() to pop the first row out of the array of rows, and preg_split() to separate header names by 1 or more white space characters: 

As others have already mentioned, Array.prototype.filter() might be the simplest approach (or Array.prototype.reduce() could also be used but would require more conditional logic). It would typically be slower than the nested loops because it would be adding additional function calls, but for small data sets it typically wouldn't be noticeable. For example, I did a search on Google for "jsperf filter nested loop" and found this jsPerf test. Using Array.prototype.filter() on , pass a callback function that returns when the value at property is included in by checking A1.indexOf() for a value greater than . 

Unreachable line in ? In the statement, there is a line after the statement for the last case (i.e. ). I believe that is un-reachable. 

Nested Ternary operator Bearing in mind that this might just be maintained by you, if somebody else wanted to update the code, that person might find the line below less readable than several normal blocks. My former supervisor had a rule: no more than one ternary operator in one expression - especially if it made the line longer than ~100 characters. 

without a radix The click handler calls with no second parameter (i.e. radix). The MDN documentation states one should "Always specify this parameter to eliminate reader confusion and to guarantee predictable behavior"3. So that call should have added as the second parameter: 

Typo There appears to be a typo for the variable - should it not be ? For the sake of readability, I would correct that: 

And instead of using to select the form element, could be used, could be used if an id attribute is added to that form element, or even simpler, can be used because the event is bubbled up through the DOM. 

So why bother returning anything from that function (besides exiting the function early)? Assignment of before returning a value That function has many cases where a string literal is assigned to (with scope beyond the function) followed by a statement. This seems unorganized. Why not merely return the result (I would suggest adding an additional tie case, for the scenario where player2 has the high card). That way, the message can be set in the click handler (or another function), so that isn't responsible for checking the result and setting the mesage (refer to the Single Responsibility principle). That way, the messages can be set in one place (instead of repeated, as they are in both cases) - adheres to the Don't repeat yourself principle. To change this, the case could be added to the result set: 

Consider the scenario of putting cards in a box. If you later want to know if a card is already in the box before deciding to make another one, do you want to search the whole box? Wouldn’t it be easier if you could check if a card exists by going to an exact spot? The same is true for the storage technique of the sub-arrays in . Instead of just pushing the sub-arrays into the array of overlapping arrays, set the sub-array at a specific index- making it an associative array instead of an indexed array. That way the time required for look-ups is minimal (I.e. \$O(1)\$ complexity) instead of having to search through the array (I.e. \$O(n)\$ complexity). So when setting the key, you could concatenate the outer and inner shift IDs: 

Other Review points Feedback I like the usage of the jQuery ui keycode constant for the enter key (i.e. ). I must admit I hadn't used that before but aim to do so in the future. I really like the application of object destructuring for passing the named parameters - that is quite nifty! Suggestions Cache DOM references I see a couple places where DOM elements are looked up in succession, for example: 

I don't see much in initial searches online for best practices of handling AJAX errors/failures. Many web-applications display an error message to the user that an error occurred. As you mentioned, an fall-back email might be the best solution for your application. 

Single element with class notification Because the code won't add a notification element if there are already elements with that class name notification, the code could instead add a single hidden element when the DOM is ready, show it when the notification class is instantiated, and then hide it when necessary. That way the DOM wouldn't be manipulated as much. For more information, check out Stop writing slow Javascript. I know it bashes jQuery a bit in the beginning but later it has some useful information that I wish I had read years ago. Removing _this One could use Function.prototype.bind() (not to be confused with the jQuery method ) to bind functions to the context of , which would eliminate the need for the extra variable . See an example below, also utilizing the function names instead of calls in simple closures. 

The rewritten code definitely feels less cluttered, and it makes sense to remove a block that never gets executed... Since the code already uses , more functional approaches like .reduce() could be used to clean up the code, unless the performance losses would be too much. 

jQuery DOM-ready syntax: As of jQuery 3.0, only is recommended; the other syntaxes still work but are deprecated.1 So that ready callback registration can be simplified to: 

Initially I was thinking of suggesting the clause, but I don't think that would help in this case, since the query selects the aggregated count and uses that for a comparison. One option is to use a Common Table Expression (CTE) but apparently those aren't introduced until MySQL version 8. One other option is to make a View: 

Does that mean running a query to select data from each table and then subsequent queries to select the affiliated data? If so, repeated (redundant) queries (i.e. on one table where only a condition changes) can lead to poor performance. But, if the associated data can be shared across records (e.g. multiple accounts have the same location) then it might be better to have one query per table and then look up records in various result sets when needed. If paging can be integrated, for example: populate the first \$n\$ results, where \$n\$ can be 20, 40, 60, etc. then the query with the joined tables might be optimal.