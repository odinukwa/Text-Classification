That's why we should first think about the primary concerns of our application, and try to seperate these concerns into classes, which can then also be re-used if designed modularity in mind. Therefore, Assuming what you are trying to achieve is something like this: 

You can wrap your timers in ExecutionPlan class. Using a class for wrapping the timers have many benefits. 

EDIT 1: You also don't have to check and assign moannie if it is passed in as euro because it already has the value euro: 

In that sense, the creatively defined method name and the parameter names and will not do. The General Naming Conventions states: 

Finally, the implementation, with all the naming convention violations and functional confusions fixed, might look like the following: 

You should also check the items of the passed in collection for null references. If any of the items of the would be null, your code would fail with a null refererence exception at 

Then, why restricting the second method parameter to ? Let's get that as an . This way, your method can also operate on or instances 

You can also change the method to be an extension method of . This will clearly state the purpose of the method if declared with a good name: 

Yes, it seems thread safe. I run a test to prove it which I give the details at the bottom, but first are some code review comments. 

You should always check if the parameters are passed in as null. Your code would fail with a null refererence exception at if is passed as null. 

You keep track of class instances and not bare integer values, You can re-use this class in other projects or forms (if designed & implemented correctly), You can extend this class to enrich it's functions etc.. (There are an infinite number of benefits) 

Method name is a common method name used by collection types to add a new element to the collection. An method with source as the first parameter and the items to be added as the second parameter does not make sense. and are bad names for parameters and should be changed at least to and or similar. And in Capitalization Conventions 

Now the page has posted back and this all needs to be save, so the Save method in my control just lets the business object handle this all: 

2 - To support transactions, I use a similar approach, and also include helper methods to Begin, Commit and Rollback: 

The other piece to this is the re-usable UI code for the Phone, Address, etc - which handles all the validation, etc in just one location too. So, let your thoughts flow and thanks for taking the time to read/review this huge post! 

FYI - SaveResult is just a little container class that I used to get detailed information back if a save fails: 

3b - I'm building this in MVC, so I have a "base" Controller class that all my controllers inherit from - this way the Context only lives from when first accessed on a request, and until the page is disposed, that way its not too "long running" 

Data Context needs to be stored in a common memory space, easily accessible Transactions should take the same approach It must be disposed of properly Allows for better separation of business logic for Saving and Deleting in transactions. 

Notice how each Address, Phone, Etc is handled by its own business class, here is the Phone's save method - notice how it doesn't actually do the save here unless you tell it to (save is handled in the Customer's method so save is called just once for the context) 

Here is the code for each item: 1 - First the data context stored in either the current HttpContext.Current.Items collection (so it only lives for the life of the page and only is fired up once at the first requested) or if the HttpContext doesn't exist uses a ThreadSlot (in which case that code most clean it up itself, like a console app using it...): 

I want to get opinions on the code I have put together for a centralized DataContext via a DataHelper class that I have created to be re-used on projects. NOTE - there is a ton of code here, sorry about that, but I really wanted to layout out the complete approach and uses for my ideas. I'm an not saying this is the right approach, but it works for me so far (still playing with the approach, nothing in production yet, but very similar to stuff I have built over the years) and I really want to get constructive feedback from the community on what I have built to see if it is insane, great, can be improved, etc... A few thoughts I put into this: 

Therefore, You can simplify the exact same behaviour at least in terms of the final state as follows: 

The access is synchronized to the method. OK. For the threads that call at the same time passing the same instance, after the call to , is for only the first invoking thread. OK. All other threads get the existing instance after calling and is . OK is called on one of the first threads that call , most of the time the adding thread, but sometimes on another. OK After the call to , all requesting threads get the same instance out of one by one, as returned by . OK The first thread that gets the instance calls and succeeds. OK. After the instance is removed, other threads continue to get the old instance because they have the removed instance. OK 

The code is missing the class which I think is also important for the review. The cache items are added with keys and it is important for this method to return the same value for objects having the same credential values, and distinct values for instances with different credential values. Is it? Naming conventions. Class names should be PascalCase and the class violates this rule. Should be To achieve better encapsulation and seperation of concerns, (The creation of an empty credential object should be a concern for the Credentials class, which has control over the internals of itself) instead of having a field in this class, it is better to have a field (or property getter) in Credentials class. 

To prove that it is properly working, I run a 100 concurrent threads test with random access to the operation with the same credential instance. This test revealed that, 

And here are the results of the test, which shows the method is invoked a total of 5 times for all the 100 threads. The test created 100 threads which access the method randomly within 500 ms. There is another thread for removing the item from the cache in 100 ms continuously (This is because, the cache policy doesn't seem to effectively remove the item at the exact point of time of expiration). The method lasts for a random time between 0 and 500 ms With the following results, it can be seen that the method is invoked a total of 5 times (which is the number of the cache not containing a instance for the given credentials, first one because the cache is empty, and for 4 more times because it is removed from the cache) I can't help myself thinking why the of returns when the item is added to the cache. This would have been implemented differently (as returning the added instance as ConcurrentDictionary does)