I made a simple React + Redux app which allows you to add and remove recipes to a list. Here are the user stories the app fulfills: 

User Story: All new recipes I add are saved in my browser's local storage. If I refresh the page, these recipes will still be there. Code: 

I built a small app that gets data from a remote json file and displays it in a list of users. In each list item, an image of the user, their name, and their points tallies are shown. The list is displayed in two possible ways - 'all time' and 'recent' - depending on the user's choice. I would specifically like feedback for my SCSS and usage of React components but anything else is also welcome. PS: I tried working without semicolons - is this a good or bad idea? Here is a Codepen Javascript: 

I have written a small app that fetches news items from an endpoint and displays them in a grid. I used React to create components and use them throughout the app. This is the first thing I have built using ES6 - mainly for syntactic sugar. I tried to match the BBC News page style, so it should look very similar. It's responsive and should look good on any size screen. Overall, I'd mainly like feedback for my React and ES6, comments on best practices or what I could do better. Here is my React code: 

Now we have an easy way to test. Let's make sure that we can handle all reasonable values. Here are some values that you don't handle. and so on. You should always expect the worst from user input and handle errors gracefully. For example,' 

which use the idiomatic, efficient range form which allows the compiler to bypass some index range checks and calculate len(a)-1 once. Unless there are at least two array elements, no sort is needed. The upper limit for the outer loop is len(a)-1 not len(a). Especially in the inner loop, avoid unnecessary address calculations, index range checks, memory accesses, and exchanges. Also, avoid inefficient comparisons. 

The Go programming language was designed to operate at Google scale. Go programs are usually written to be reasonably efficient. For example, assume that your function is used by Google's search web crawler on billions of HTML pages (with multiple scripts per page) per day. I see opportunities to make your function more efficient by using CPU time and memory only when necessary. To estimate how much your function might be improved, I ran some Go benchmarks. 

Code should be readable, correct, maintainable, robust, and reasonably efficient. Readability is a prerequisite for the other characteristics. Start with Go Code Review Comments. You write: 

The unnecessary conditional path and indentation are a distraction. The most important path is the correct path. It should be easy to read the correct path. 

The code does not depend on the iteration order over maps. The iteration order over maps is not specified and is not guaranteed to be the same from one iteration to the next. A zero value map () or an empty map reasonably returns the zero value int (). In all other cases, for both 32- and 64-bit s, the result is obviously correct. For example, 

Here is a demo of it in action: $URL$ I used to format the code, and based the architecture from the documentation. 

Also, a rule was to use React and SASS (The FCC founder said that SCSS is acceptable). This was my first attempt at using Redux. As a result, some things in the app are experimental. For example, the reducer works well and returns a new state each time - but I'm sure the code here could be better written. Also, in the component, I found myself confused at how I should use the component's state, or draw data from the Redux store. Some thoughts on this are most welcome. As was recommended to me on a different code review, I used the BEM pattern for my SCSS. I used Vex for the modals. This resulted in some pretty ugly code. For example, html tags within a string (which I think looks really confusing in the vicinity of JSX). But the functionality is fine, I believe. Would React-Bootstrap be a better option in this case? Here is a link to a Codepen of the app Javascript: 

I have an and function because there are only these two fields that get added by the form. Would it be better instead to use an and run this when either field changes? I see this as a benefit for when other fields get added, but less efficient because I will be running an onChange function for several fields that aren't changing. The naming of my action creators, reducers, and functions inside are usually the same. For example , action creator and function. Is there a better approach to this? In the function inside , I am validating the and values. Should this go inside this function, or somewhere else? In the function inside , I am dispatching many actions. Is this correct practise? 

Your program is running 100,000 client connections using goroutines. One connection has a problem, so you crash the program. We have 100,000 very upset customers. Handle errors and fail gracefully; return errors; don't or . See Errors. 

I reorganized your code. Don't write code as a heavily indented stream of consciousness. First, write the normal flow. The first step in a code review is to read and verify the normal flow, it should be obvious. Second, add exception handling. Third, add error handling. Sensibly minimize indentation. See Indent Error Flow. For example, a simple first draft, 

The code in Abdallah Hodieb's question is good (LGTM). I prefer the simpler, more readable form of the first loop. 

Go is statically typed. Every variable has a static type, that is, exactly one type known and fixed at compile time. You are not in dynamically typed Python anymore. You could use reflection, BUT DON'T! 

Code review is an iterative process. If there are significant changes, open a new question with the revised code. 

We know that this is safe to do (a nil value for conn is OK) and that it is the expected behaviour because we read the net.Dial source code. 

Your rationale is "I easily forget some things." That's not a problem. What is a problem is that you don't know how to easily find this information in the documentation. No employer wants employees who write idiosyncratic, unreadable, and unmaintainable code. Similarly, you write, 

Likely, just has a single default state, but if you ever want to construct this object yourself, you should consider return-/exporting the definition from your module, rather than returning an instance of it. A simple solution here is to simply return the result of . Use a template. In the future, you can use additional templates to support other platforms. e.g. start with a desktop template, later on create a mobile template, and choose the template dynamically at runtime based on the environment. 

Since RequireJS invokes the module, it would be problematic to construct dynamically. There's no good way of creating more than one instance of your view – probably not a problem. The View is tightly bound to a specific DOM structure. This means it will require extra code to make your View responsive. e.g. a small volume control for mouses (desktop) and a big one for fingers (mobile). 

I ended up using the decorator pattern. The report view and each graph object now implement a method. When the report view's is called, it iterates over each graph, calling the graph's . The latter method receives the report view as a parameter, and this provides access to convenience methods for creating/retrieving DOM elements for the graph to attach itself to. New report view: 

As far as I know, Meteor's reactivity is one-way: changes in data are reflected in the DOM. To go the other way (DOM to data) there's two common methods: 1) grabbing data directly from the DOM when it's needed (i.e. to save it) as you've done above and 2) binding DOM elements to data models, and using the data models for CRUD operations. 1 is simpler to implement, but 2 gives you more control over data-flow, subscriptions, and life-cycles. 2 has plenty of great libraries you can use, so you don't have to reinvent the wheel just to leverage these benefits. Backbone.js is probably the most well known plain-JavaScript library for this sort of thing (also check out Lo-Dash and Exoskeleton if you haven't), but the Meteor ecosystem may have a preferred library for this. 

Your is a massive clutter of messages. That may make sense for debugging, but it doesn't make sense for production. What is the purpose of this and similar statements. 

Even if you write impeccable code, you will still be judged on the quality of the external packages that you use. The packages from are of very low quality. Here's my complete program. It's a first draft. 

Go uses the testing package to write tests and benchmarks. These are the results for benchmarks of the various selection sort functions. Each benchmark sorts an array of 1,024 random integers from descending to ascending order and then sorts it from ascending to descending order. 

The most important property of a program is that it is correct. For the Caesar Cipher, Latin letters are rotated, in either direction, by a fixed shift amount. Decoding is the reverse of encoding. Your algorithm looks suspicious. I tested your algorithm against my algorithm. Encoding "Hello, 世界" for shift +25, your algorithm gives "a~\u0085\u0085\u0088, 世界" and my algorithm gives "Gdkkn, 世界". Your algorithm: 

Go uses camelCase: . Go uses a capital letter for the first character to export identifiers. Use functions to encapsulate complexity: . Bubble errors up so that each level can handle them appropriately. Local variables such as and are not exposed outside the function. The function runs at the end of the function instead of the end of the program. For output files, check for errors on . Don't panic in packages: . is a rewrite of . Note that now truncates the local file only if there is no error reading the remote file. From a design point of view, we may want to download the latest version of the remote file if available. If there is an error, common on remote connections, we can elect to fall back to the last local file. Robust code gracefully handles failure. And so forth. There is more, but I'm out of time. 

In general, using the "new" keyword in any class is bad practice, because you're creating an implicit dependency. Instead, you should follow the "ask, don't look" design philosophy and require that the database object be passed to the class, rather than letting the class fetch it. Dependency injection is a common solve to this problem, and I'd recommend looking at how PIMPLE is used. Here's a good article: "Dependency Injection with Pimple". Many people, like deceze, will deride you (rightfully so) for doing things like this, because it's one of the easiest (and probably most common) things you can do to kill the possibility of testing your code. If you were to write a unit test for this model, you'd have a database object being constructed with each test. Since the whole point of unit tests is to run code in isolation (to verify the tested code's accuracy), it would be impossible to test this model without a database. On that note, the JavaScript guru, Misko Hevery, published a really superb article on writing testable code: "Top 10 things which make your code hard to test". While this is specifically in the context of code testing, it's also very good general programming information. 

Not bad. Regarding your concerns that toPretty.json is visible from outside object-scope, people typically get around this by using the Module Pattern. 

I'm not following. Which file/object? You appear to pass the JSON object from to your constructor, and this is just a plain JavaScript object.