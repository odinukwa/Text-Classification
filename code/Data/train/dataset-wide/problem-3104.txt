In the methods , , and you can assign the variables upon declaration. Also, the return code from the function isn't checked like in the other methods. Frame.h / Frame.cpp The constructor and are unimplemented. The member variables of can be initialized in the constructors, and and appear to be unused. main.cpp You have a statement early on, but seem to always use the scope resolution operator () when using objects from the namespace (I see two instances where and are referred directly). Consider removing the statement. The naming of functions is a little inconsistent. Most of the functions are named with , but there is also a and a . The first part of uses a lot of and where and can be used instead. You should be able to name your directly instead of using a : 

VideoBuffer.h / VideoBuffer.cpp I believe the only symbol you need from the includes is for , which appears to be pulled in with (which includes "libavutil/frame.h"). I haven't tested it, but you should be able to remove the other two includes. The method seems like it could be eliminated and its code moved into the constructor. I don't see the method being called explicitly in the rest of your code. Also, the member variables and can be initialized in the constructor: 

I've noticed in your Matrix.cpp file the class member variables are referred to inconsistently throughout the different methods. For example, in , member is referred to as is, while in , you use . There are similar examples in the other methods. Although you seem to correctly use the pointer to disambiguate the class member variables from the method arguments, many methods are using the pointer where no such ambiguity exists. You might also consider making the and functions static methods of the class, that way they don't have to be declared friend. If not, I would at least rename them so they aren't confused with functions from the cmath header. The and have different argument names. It could be useful to have the name of the file that failed to open when a is thrown. The takes an unsigned integral type as argument, so you might want to used an unsigned type () in your for loops when iterating the underlying vector of class. doesn't check bounds, and if you accidentally pass it a negative number it will likely be converted to a large positive number. As an aside, if you ever use unsigned types to iterate in reverse (starting variable at array/vector size and decreasing counter), be careful not to subtract one from the counter variable once it reaches zero (the counter variable will likely rollover to the largest possible value). As far as your , I would be careful using that depending on what you intend to do with the returned row. The returned is a reference to an object to the method. If you get a row with and then mutate your , the returned row may no longer match up with your object. You will also mutate any prior references you retrieved with a call to . So if you ever need multiple rows from a at the same time, you'll need to change the method to return a new , or copy the returned row before calling the method again. Also, as @janos answer points out, the variables only used in the for loops can be declared in the initializer of the loop so they are scoped. 

For , you'll have to return an , which must remember the size of the array (or else retrieve it from something like or , but those are problematic because they're analogous to instead of . You don't want to destroy more items than the user provided). Fortunately you can partially specialize your template so that has that extra "size" member. (The STL's is also specialized for , but doesn't keep that explicit "size" member because doesn't need it. Instead, it's specialized to provide a different set of accessor operators: instead of and so on.) 

Even better: remove the argument entirely! Just use the predicate for the whole thing, and the condition becomes . 

No particular comment on the correctness of the stack implementation. I didn't find any obvious bugs. :) 

Same deal as above: if you already know the expected type of the object, and just want to check that it's not-empty, you can use its truthiness. Also, you've got the entire function body under this . We can fix that with an early return: 

It's hard to tell without seeing the code for and , but I would not be surprised if you've got a race condition between the main thread's and the worker thread's . The workers take in order to prevent data races among themselves; but the main thread blithely pushes new data onto the list without taking , which seems like it would cause a race in the case that the list had only one element. 

However, your bitflag identifiers , , , etc., are pretty much unreadable, especially given that you already have English names for them right there in the source file! If I were you, I'd replace the entire function with simply 

This strikes me as a recipe for disaster. Do you really need these two functions (one lock-free and one not) to have the same exact name? Also, if the latter is not lock-free, then it should not be taking as a ; it should be taking a plain old . Which sounds a lot like the first function. So basically, kill off this second function. 

This won't change the codegen, but it might be worth doing if it helps with the "localization of concerns": If is useful only to , then it doesn't necessarily make sense for it to be visible to the entire program. 

The try-catch is necessary if there might be more than one "consumer" thread trying to set the value of the promise. Also notice that we're assuming that there is at least one "consumer" thread; if there's only the "killer" left, then it'll wait forever since there's no "consumer" left to finish emptying the queue. 

However, both of those snippets I just pasted have formatting "bugs" besides the indentation: In the second one, you have a trailing that shouldn't be there. In the first one, you mix brace styles: 

This is a common anti-pattern I see in a lot of student code for some reason: you want to compute a value, so you make a class, give it a method, and then add memoization so that the method won't be so darn slow the second time you call it. This is an anti-pattern because it takes a notionally const operation (counting the number of tilings) and makes it a non-const member function. That is, it breaks this reasonable-looking code: 

The salt should be the same size as the hash. As noted by the other answers, always pass in the work units parameter so that you can upgrade the strength of the key stretching over time. When you compare hashes during authentication, use a constant time algorithm. 

No, "HMACs are substantially less affected by collisions than their underlying hashing algorithms alone." Sha1+HMAC is far more secure than Sha1, and it is a currently accepted standard for password hashing. 

The salt should be exactly the same length as the hash. When you verify, always use a constant-time algorithm so that attackers can't play hangman to guess passwords. If it takes longer to get a response for a mostly right password, attackers can use that data to progressively guess the password one letter at a time. For 2014, you need at least 128,000 iterations to be safe with PDKDF2 / HMAC-SHA1. Make sure to pass the work load in as a parameter to PDKDF2, so you can change it as processors get faster. Double the iterations every 2 years. 

No If you can't pass hash length, salt length, and work units (iterations) into the hash function, you have no way of keeping up with faster CPU speeds. The salt should be at least 64 characters, and it should be generated using a cryptographically secure random number generator. It needs to be unique for each hash. It should be the same size as the hash. Any less is too little entropy. Any more is wasted. Always pass work units into key stretching algorithms like bcrypt, PBKDF2, etc... That way you can increase the work required as CPUs get faster. In 2014, a PBKDF2/HMAC+Sha1 algorithm needs 128,000 work units. Double the work every 2 years. You need to store the work units with the hash so that you know how many to use for comparison, and you'll know to ask the users to select a new password when its time to upgrade their hash. Addressing comments (there wasn't enough room in the comments field): The salt should be at least 64 characters because the hash should be at least 64 characters. The salt should be the same size as the hash in order to prevent attackers from creating lookup tables for every possible salt. This is why it's a very bad idea to use a username as a salt -- especially now that we're fighting off attackers with enormous amounts of storage, CPU, and memory space compared to just a few years ago. In other words, having an equal length salt guarantees that generating tables for each salt (combining tables + dictionary attacks of the most common passwords) would take at least as long as a brute force attack. The minimum length of 64 characters is the current recommendation (for the year 2014, 2013 is almost over) in response to changing CPU speeds. The recommendation of 22 was first made years ago -- CPUs double in speed every year, and current botnets exist with over 90,000 nodes, capable of generating billions of salts per second. Super cheap supercomputing clusters can be built today for less than $2k. The old standards just don't cut it anymore. Salts need to be generated by a CSRNG in order to prevent collisions. Pseudo-random generators that are not CSRNGs are notoriously bad at that, often generating a collision within a few thousand hashes. For sites with hundreds of thousands or millions of users, that's not an acceptable rate. It's important to prevent collisions because a collision means that the same tables can be used to attack multiple hashes at the same time. 

It's a little bit "weird" to have an opening curly brace without indenting the following lines; but it's equally "weird" to have a (non-member) function definition that doesn't begin in column 1, and having to indent all your code past column 1 is much more painful to read and write. The benefits of "collapsed" style really start to show themselves with 

The idiomatic C++11 way to write would be to have it make a copy of the passed-in Container, so that you could just pass in an anonymous (rvalue) Container and not have to worry about lifetimes. The itself would own and manage the lifetime of its Container. 

Somewhat off-topic: I'm leery of your use of to declare a pointer. To me, a bare identifier always means "value-semantic object", as in or ; and if the object is supposed to have pointer semantics, you add a star, as in or . Hiding the star inside a typedef strikes me as a bad idea. Although I admit that if you're coming from Java or Objective-C or Python or any other non-C, non-C++ language where 

You wrote where I would write — I use plural names for parameter packs, and recommend everyone else do so too. (And as for over — it's just shorter.) 

Or, if you know that is very small (say, 16 bytes or less), then you might consider getting clever and writing 

Plus wherever comes from; that's an undefined symbol in the code you posted. I'm guessing it does something similar to ? 

Seems pretty straightforward. By the way, "disjoint-set" is a less common name for this data structure than "union-find", at least in my experience. You have several typos in your code; you should always fix those. Sure, the computer doesn't care, but we don't write C++ code for the computer; we write it for the human reader. should be ; you should either implement or remove its declaration; and you should use proper indentation. 

Move semantics are your friend. Use them to eliminate all the expensive reallocations and s that are happening in your code. I count three s: once inside , then again from into , then again from into . 

As for your code: It's definitely more convoluted than mine! :D But in Befunge, this is not necessarily a bad thing. There are some infelicities; for example you use where I would have used — I don't understand why you bother printing that space character with since it comes at the end of a line. Possibly a vestige of an earlier version of the code? On the right-hand side you have a jumping over a . If you were trying to be obfuscated, then you could replace this with a codepath that just runs straight through the and then corrects with a further up. You have plenty of white space where a could fit in. Rather than always using 

Jerry's definitely always runs (much!) faster at the "bleeding edge", but by the time you've altered it to compute the 20-millionth prime correctly, that same program is now running slower to compute the 1-millionth prime. (If you knew, up front, which prime you were going to be stopping at, you could choose a safe bound for the array in advance. But you can't do that if we're just piping the infinite stream of primes to .)