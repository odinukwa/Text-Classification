You may be able reduce the amount of synchronisation, but you cannot eliminate it entirely. CAS or Fetch-And-Add are lower level operations that are abstracted away by Java so you cannot use them directly. Firstly, some observations: due to the mechanisms of how the lock is acquired, your synchronization of handle will cause a random caller to be selected when multiple are waiting. This could cause a situation where trades are handled out of order, which would be evidenced in the timestamps. If this isn't desired, you should use a queue to ensure trades are processed fairly (although what constitutes fair is a matter of debate). You shouldn't use your CheckException as a convenient way to skip past a bunch of code. Have return a boolean and use proper flow control, otherwise your code appears to accept a trade even if the credit check fails. Some of your preconditions to a trade may allow you to reject a trade before entering the synchronisation block. If the CounterParty doesn't match, you will always reject a trade. If a trade is above the daily limit, you will reject the trade outright. If a trade is above the trading limit, you can run the credit check without synchronising and reject it if it fails. It also appears that you only ever increment so if any trade's value would exceed the daily limit (and assuming trade values cannot be negative) you may reject it with an unsynchronised check against the daily limit. Once you've checked all these preconditions, you have to worry about concurrency. You will have to check the daily limit again, but if this is done on a single-threaded consumer thread, you do not have to synchronise at all because there is no concurrent access and you know the value cannot change. With this approach, may also wish to submit the call to a thread pool to execute separately as this may also slow down execution calling the listener inline. A BlockingQueue would be ideal for this kind of design. 

The simplest way to avoid the recursive traversal is to have two lists: nodes you want to visit and nodes you have visited. Your loop then goes like this: 

would be clearer with an explicitly indexed for loop, although this presumes hand have a minimum of two cards: 

There are few aspects to optimising this problem. The first is recognising that there is a lot of redundancy in the problem space. With rotation, every hour of the day can actually be mapped to any other hour with an appropriate rotation. Equally, the first half of an hour is a reflection of the second. This means we can precompute a small segment of non-repetitive calculations and then map any other times on to that. The second is that those pre-computations do not need to factor into your runtime; it makes a lot more sense to load them in and just do a lookup. It's not cheating if it's both fast and correct. As such, I'd wave off trying to optimize how you generate your values as unnecessary and just commit the results to memory. If you look at the problem space carefully, we can go even further than that. polfosol's graph helps a lot here: we can see there are clear, regular local maxima roughly once per minute plus a clear maxima once per hour. If we already know those maxima and if any given time period contains one or more maxima the maximum is guaranteed to the the largest of those values. If we manage to select a time period that does not contain any maxima, the maximum value is guaranteed to be either the first or the last value (which, for 2 calculations, is cheap to calculate on the fly to be worth optimising away). This makes the solution incredibly simple: for segments larger than one minute or so we're guaranteed to find a maxima with a simple search within boundaries; searching <30 maxima for the biggest is not computationally intensive. For segments less than a minute we still have to check the local maxima and, if none are contained, do two calculations for the bookend values: one of them is guaranteed to be the maximum in a no-maxima containing segment as the segment must be either a 'u' shape or a slope. Sometimes optimisation is finding ways to do the minimum number of calculations rather than doing calculations themselves faster. 

joda-time is a very nice library that can overcome some of the shortfalls in the core Java Date/Time classes. For example: 

Embedding long strings like this into your source code is not ideal with Java and you might find putting them into files, loading them, and extracting the Strings from them to be much tidier. It allows your text to be reproduced in the source file verbatim without quotes, escaping, appending, and newline issues and it cleans up your class too. As a side benefit, you may be able to give the external files an .sql extension and they will be executable/testable in their own right. Having the SQL on your interface is a bit of a code-smell as interfaces should be concerned with signatures, not implementation. Sonar isn't necessarily right and will detect false positives. Repetition inside strings shouldn't always be extracted out as there may coincidental or minor, genuine repetition (the repeated usage of 'SELECT' for example) that could change independently going forward. You can instruct Sonar to treat them as false positives and it will stop warning you about them. Building SQL in your code is another code smell and, if done badly, can be subject to injection attacks. If you go down this path, you will want to do it programmatically and rely on proper escaping of parameters. 

"The two hardest things in computing are cache invalidation, naming things, and off-by-one errors." There's a particular art to naming things well, but like any art, appreciation is subjective. In this case, I'd strongly prefer to match the fact that it is a factory for generating objects. The fact that it does so en masse and gives you a list of many at a time is not important enough to be in the name of the class; a factory could have multiple factory methods that vary whether they generate one or many s. There could be an argument for not embedding the list behaviour into the Factory. It may make your current use-case simpler, but in future it makes the Factory hard to use if you wish to only generate one object at a time. Having a simple loop when calling the factory to create multiple objects will still result in fairly clean, concise and easy-to-understand code. It also avoids issues associated with whether you should accept and/or return a List, Set, or just a Collection. 

Also, you suggested there may be more than one remote; perhaps there should be a loop and associated code to add all remotes, not just one of them. As for simplifying your execution, from a high-level perspective, I'd remove the 'on failure' logic to try and chain your tasks. Instead encapsulate the 'talk to a host' as a single subtask. You can then have an orchestrating task that attempts one of those subtasks against a host and creates the next one if they fail. As some very crude pseudo-code: 

Some of your commenting is a bit excessive. JavaDoc comments in particular are aimed at generating automatic API documentation and shouldn't be necessary for private functions unless they're very complex and you need to keep a maintainer educated. Generally JavaDocs should be documenting specific behaviour. Same goes for private fields- try to self-document with good variable names, rather than relying on comments. In particular, the duplication of the R/B definition between the two classes is a code smell and you should be scoping it so that it's accessible from both classes. More fundamentally, the choice of a char to store this data is rather misleading as it suggests that more colours may be arbitrarily introduced! In some cases of a limited set of valid values, an enum is both appropriate and descriptive, but for a case as simple as this, a boolean would work. For readability, using constants like and would allow you to do away with and do stuff like . However, the most OO appropriate way would be to just have the methods and on the node object. and wouldn't go amiss, you could make a case for if there are occasions you're not assigning the colour but switching it. Your exceptions are incredibly strange and I suspect you're using it to subvert the recursive nature of your function. This can become an anti-pattern, such as using exceptions for flow control. Inserting into a tree that already contains an item of data should be treated as an idempotent operation and therefore a success; hardly an illegal argument. is worse as it promises to return a boolean, but it returns true if successful and throws an Exception if not (generally speaking, you should never throw the Exception class- always find a suitable subclass or, if one doesn't exist, make your own), so the docs are lying! A fantastic improvement to this class would be to actually implement the Set interface and use that contract to guide at what sort of behaviour would be 'nice'. As per the Set interface, looking to indicate whether or not the data previously existed (say, we modify to return a boolean to that effect), you're now running against an issue with recursive algorithms: the return pathway of information is very narrow as you only get one return type. None of the options are all that pleasant- you could make a custom object that gets passed around from invocation to invocation and has fields for all the information you wish to pass around, but that could lead to thrashing lots of objects in accordance with how much recursion you've done. In this case, a simple flag field will suffice, but that in turn highlights the thread-safety of an RBTree instance. As it turns out, the operations on your tree could cause some very strange results if invoked in a multi-threaded environment. This is not the end of the world, but definitely something that should be documented in your JavaDocs; the core Java Collection data types typically do not provide thread-safe implementations, but are documented as doing so (synchronization can be achieved using wrapper classes).