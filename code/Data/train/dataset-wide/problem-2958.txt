You create an array with then overwrite it by assigning it the reference to You should just declare and not assign it an array that is not used and immediately dereferenced. Also I am unsure what your intention is here. Do you expect there to be a second copy of that is sorted? 

Some benchmarks I am guessing a function like this is written, apart from an exercise, to search for power numbers. Thus execution time is important. String manipulation and type conversion is not something that javascript likes to do, so running the two given answers in a profiler I measured the time to run the following loop. 

There are very few situations in when you need to use a block. I feel that if you are using them you are being lazy. There are many problems that can be overlooked when using try catch. Here are just 3 for your case. 

Object assign via operator There is a sorter way to do the property order if you use the spread operator to assign properties. 

Naming and Commenting An important part of being a programmer is good naming. Looking at your code at first glance it seemed fine, until I started to rewrite it (I always rewrite when reviewing). For good code I should be able to rewrite the code without the need to go back to the original source for clarification. In this example I was constantly going back to try and understand what you were doing. The main reason was that the name of variables that did not match what the variables contained and conflicted with important global names. Comments To make it worse the comments confused things even further So let's examine the comments 

You have it almost perfect in your question. With a little improvement you can reduce memory and CPU load. 

Axonometric projections With all that said the whole function is a problem as is doing a search when a direct index can be found. * note that the code below is off the top of my head and may contain typos, it is a suggestion and you should do some extra research on axonometric projections to create code more suited to your needs.* All axonometric projections (Isometric is a particular type of axonometric projection) can be defined as 4 2d vectors that define the direction and scale of each of the 3D axis X,Y,Z and the location of the origin. If we ignore the Z as we are after a cell coordinate the problem can be simplified even further. 

Bloat I started reviewing the code, most of it was good with a quick glance, I was going to comment on the long variable names and suggest you consider using common abbreviations to make the code more readable. As I looked deeper I started to find more and more bloat. There is a point where code granularity is a burden on the source quality. One line functions called from only one location is not a good way to use functions. It make the code harder to follow, especial that the names are so long they all look the same and need to be read to find, rather than a quick scan. The example 

Precision testing is flawed... ...because precision function is flawed. JavaScript uses FLOATING point numbers, but you are treating them like fixed point numbers. Consider (Small value is ) JavaScript will happily return the correct value I think you are trying to fix problems like which JavaScript will calculate to be which has an error of 2e-48 Both examples your code will round to zero, and the test will pass even if it is completely stuffing up the operators eg is which is in fact out by 16 orders of magnitude. You are better of providing the test function with the JavaScript calculated value. Don't test with the known result but rather the calculated result and remove the calls to . Euler's constant Looking at the code it it seams to me that values entered as exponents will be incorrectly evaluated (maybe throw) eg will not work. Though I am not sure, I have not run your code? Triming Javascript has a trim function so there is no need for Thus 

Getting a benchmark of 4.4 compared to the original 4.6 which is about a ~4% performance increase. Not much but every bit helps. Smarter logic If you look at the logic you are testing each loop the bit location defined shifted right depending on the loop count. If we consider that the input values are limited to only positive doubles less than you can use bitwise operators to give a major improvement in performance. The following code benchmarks 2.0 compared to the original 4.6 so that is a massive improvement of ~57% and would bring your 88ms down to ~38ms But remember that has a limited input range. Solution B 

To generate a good hash you need to limit the size of the hash number. This can easily be done by just using integer math and bitwise manipulation. An improvement (not perfect) hasher 

Personally I would say, forget the DOM and use a canvas, but that will upset the the believers in semantic page design. I all I can say is maybe rather than use relative positioning do all elements via absolute positioning, that way you don't have to fight the pages layout engine. If you have correctly separated rendering from the apps function then you are free to experiment with rendering methods. 

Why this makes your function bad. Saving state to a stack is great when you have complex or branching data structures that you need to iterate. Saving an irreverent state on the other hand is not so great. In fact I would say using an aysnc function to step over animation frames via recursion is about the worst way to create an animation. If you have 200 characters to animate by the time they have all completed (the last recursive call) you have 200 function states on the heap. I would estimate that the memory usage of a 200 character animation to be about 200K +, though that is nothing, I have seen people chew 1Meg just to add two integers in JavaScript (crazy eh!). Luckily JavaScript makes such wasteful resource usage transparent, by providing ample memory and a gaggle of resource management threads to contain and clean up so from your point of view everything is running slick.. Another way. I am a little long in the tooth and come from a time where 1K was all we had. I can not write code without a device angel whispering thoughts of "conserve, speed and memory" So I would have written your code as follows if the requirement was to use async functions, and assuming that the value is many times greater than 60fps. 

becomes and you use destination to mean a link, we can abbreviate destinationEnd as and makes more sense as with better called 

All but the royal flush has an additional value depending on the highest card. If you multiply each named hand index by 13 (the number of card values ) you get a unique score for each hand thus a full house with high ace would have a score of which would beat a full house king high . This system would produce a gap between the best straight flush ace high and the royal flush that is always ace high. But that would not effect score comparison. There are 21 possible 5 card combinations in a deck of 7. You could build a function that generates that set of 21 combinations, but as this problem is static (it will only ever deal with 7 cards) the combos can be precomputed and stored as a static list 

Example A Javascript example showing usage of above method. Images are loaded one at a time and made to fit the available page width. 

I can not find fault with your code apart from the use of of which i am not a fan. So I will just present an alternative syntax that gives a little extra encapsulated protection. Its usage is slightly different. is instantiated via a factory and closure holds the generator . I also freeze each instance of List to further protect the state. It also does not have to mess about with which from your side-note comment is a bit of an annoyance. 

It will prevent you from doing what what I mentioned above. Strict equality and inequality Javascript has two types of equals and not equals. They are and . The first two are lazy and will return true if the values are somewhat equal (to hard to explain in a paragraph) The latter two and are what you should use always, unless you know why you should use the other. Forget you ever saw ==, and != and never use them again. Blockless blocks. Blocks after statements can be omitted if you have only one line of code to execute. 

(1) Note the code was changed to return results as a string, and not output to the console as console output messes up benchmarking results 

An alternative solution. Looking at the problem and seeing that the board can be any size. the search by iterating square will grow logarithmic with the size of the board and number of obstructions. An alternative solution is tied to the number of obstructions by setting up a small grid of 8 directions ('dist' in example) containing the distance from the queen to the edge. The size of the board would not effect the complexity apart from being able to hold more pieces. As you iterate the obstructions you check if they lay on one of the paths from the queen to the edge, if so you shorten the path, keeping track of the minimum path length. Once all the obstructions have been tested just sum the values in dist array. As the obstructions will always need to be iterated this method is near optimum for the type of input. If the input was an array of squares containing obstruction then the original search would be the best on average as there would be no need to iterate all the other pieces. 

A generic event listener You have a list of objects related to a TV show. You have coded it by hand for each particular episode which is laborious, prone to error, and just a painful time consuming process. Using your naming we can improve the code complexity by having only one event listener that can deduce what the click is for and what to do with it. For this we wrap everything that needs a click event in a containing element ( element id ) For each clickable element we add data we can use to determine what to do with the click. ( and ) We set up the initial visibility of episodes in the HTML. 

So I submitted that as an answer and it bombed big time being only ahead of 52% of submissions. NOTE Your (OP) code runs 33% faster than the above. I used my own benchmarker to test the different functions and the code I first gave (Solution B) running much faster than the updated solutions. Inconsistencies I have zero trust in the leetCode results, they are completely inconsistent with proven benchmarking results and even for their own results. I would guess there is a bug in there timing solution (JS is notoriously hard to benchmark) so be happy for a pass, and give no credence to the performance as that is based on luck. Best JS solution I could come up with. So the updated best performance as tested on a independent benchmarker is the following snippet run in strict mode. Out performing all the above by an order of magnitude. BenchMarked 0.1 compared to the next best at 2.0 for (Solution B) and OP's 4.6 33 times faster than OP's original. 

As the cards are now encoded in a 6bit int we can use a regExp to evaluate sets of cards by converting an encoded card to a hex value. For example the card Ac (Ace = = 12 of clubs = 3) is encoded as is the hex value King of clubs queen of hearts as . A royal flush would have the hex representation of , , , But if we create two string. One that is the suits and the other the ranks we get . That means a straigh is one of 9 squences and a flush is one of suits . We can create very simple reg expressions to test for a particular type of hand. 

The function uses some constants and function that are detailed in the snippet below and explained in the answer. 

Object oriented programming Sorry this is not a good review, your code is a classic example of a quote often cited in the argument against OOP. 

The interface provides a way to control how often (time) to idle the execution context to allow for pending events to execute. The idle time can not be directly controlled (you can create 0 latency timeout using the message event but this has some problems) Using the above is simple and can work over concurrent iterators. See example code below on how it can be used. This is only a suggestion as your specific circumstance are unknown to me. Testing concurrency The following example uses a controllable load that blocks execution context for a fixed . It runs several concurrent iterators that call a fixed number of times. The iterators run concurrently (time share) and illustrate how can manage execution context switching giving you some stats regarding the overhead. There is also a ticker that provides additional events. The purpose is to play with the settings to match your expected environment and workloads. You can then find the optimal settings for your needs.