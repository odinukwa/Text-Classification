The code works as intended but, as said, I would like feedback on what I can improve in this code. That explains why I post this question even though there exist duplicates of this one, I just want feedback on my code, that's all. Thanks in advance for your responses. 

The code works as intended what I am concerned about is optimization, how to improve this code in both, execution time and stability. What I am doing in this code is compare each element from one list with ALL of the elements of the other list (I see a problem here, but don't know how to approach it well, the foreach seems not to be the best option here). 

I don't see anything very wrong with this block, and it actually leaves you open for future expansion (with regard to the variable), but if you wanted to simplify, you could... Change this: 

Here's a different version, though I won't claim that it is significantly better. The code seemed to work just fine and was mostly easy to understand (see my comment on the original question). My only big suggestion would be to add some comments to better describe what you are doing and how this works. For a brief description of my changes, see the comments in the code. I can elaborate more if necessary. 

Again, as I see it, this program does not treat an interruption as such, so I'll give you an explanation of how I've been learned to treat them and how it can improve your code. First of all, an interruption is a source which interrupts the currently executing code to execute another that expects an event. Due to this behavioral, an interruption should be always as short as possible. An interruption needs to be as short as possible because if you can call an interruption before it has ended (like in the case you are experiencing) it will overflow the stack pointer at some point in your execution and cause your device to not perform correctly. This happens because when calling an interruption the embedded saves where it is, performs the interruption/s (if more than one has triggered) and then comes back to where it was and resumes normal program execution. Do you see the main problem in your code with what I've explained here? If your interruption takes longer than the time you call it periodically, you will never exit the interruption, thus regarding your code unusable while also making your embedded to perform badly or not as expected at some point because of an overflow in the stack pointer. Because of this, an interruption should only consist of flag management which will be used in turn to allow the code intended to be executed in said interruption in the main body in your code. You might ask yourself how you can do this, so I'll give an example of how to implement this on your own code. 

Also, it looks like your function is almost identical (just converting to ) to the you use within it, so why not just use ? i.e. 

However, I would consider converting the path string to a variable and place it elsewhere earlier in your code. This allows you to use it in more than one place while requiring you to make only one change in your code later if that path changes. Taking my last suggestion, I would even break that down more to allow for more possible file names (if that would be useful for your case specifically or not is up to you to decide). I did not make this change in the code below. My final result, based on these suggestions would be the following: 

The problem here is the lack of functions or subroutines to avoid repeating code, thus making the code less mantainable. There are here other issues which are also important, for example, multilanguage support, which I'll address in the following To carry out multilanguage, I would declare an n x m array to store the n strings in m languages. To provide an example of what I mean, to store the greeting message, an array like the following needs to be declared 

We are given two list on integer arrays, and the objective is to retrieve another list which contains the duplicates in both lists. The code developed is the following: 

For your specific question, you can do your replace on a string variable and write that value back to the cell, rather than search on the cell each time. Accessing the actual cell is very slow. Change this: 

Do you have anything 'fancy' in your sheet? (i.e. special formatting, pivots, formulas?) If not -- or even if you do, but with more work -- you should be able to copy the values into and rename, rather than move the entire sheet. Modifying your to work with a pure data (no formatting) example: 

To explain this array, the first dimension of the array declares the amount of messages stored, while the second dimension declares the amount of languages one can output the information. So, if we would like to print in any of the languages, the following line would just do that. 

This code would make the greeting valid for both languages, while also making the code more mantainable if you want to change the greeting message for any language/s by having all the messages in the same place. Keep in mind I substract 1 from since arrays are zero-index based. Implementing language this way can save you a lot of code, make it more readable and also more mantainable since you don't have to look in n lines to fix an error that has propagated through all your languages due to copy pasting code. This can be applied too to handle any amount of users, further reducing your code and making it, again, more manageable when maintenance or improvements happen (which you are bound to do). If you need help in developing anything, comment my post with what you need and I'll try to give you an answer as clear as I can. Hope this helped explain how to handle multilanguage. Note: To ease the maintenance of interface messages, you can switch the matrix, n for languages, m for messages, that way you will have in the same first dimension the same message for all the languages, rather than having all the messages for a language in the first dimension. 

For your VB code specifically: In general, though some might disagree, I would much prefer to see type specification when I see . i.e. 

I have the following SQL query I am trying to use (save/make easy future modifications to) that is essentially the same query over and over and over, ed each time, with only minor changes to the clause. I am more familiar with MS Access, which allows me to use an statement in the clause to accomplish the same, but I was not sure how to do this with Oracle, so I came up with this mess instead. Since there may be future changes in the query, such as adding or removing items from the pull, I want to be able to reduce the overall size/repeteiveness of the query so making those changes is easier. Other values like the dates are more flexible, so I've got those plugging in as user-specified variables already. It's the more static criteria that I'm concerned about, since I don't want to have the end-user putting in the same variable for those fields 10,000 times before the next potential change. Is there a way I can simplify this so that either the s are reduced and/or the sub-queries are smaller, more compact, and better able to be manipulated? I had also considered ing my needed fields in the top-level query, but the DB is very large and each individual step takes a few minutes to run as-is. I was worried that doing in the sub-queries would make the process run far too long. (I have not tested this method, but I have assumed it is no good. Please correct me if that's wrong!) Also, I feel like the use of is a bit overboard, but this was produced by a query builder, and I'm presenting the output of that here. 

So to conclude, an interruption should always be as short as possible and only used to manage flags which alter the behaviour of your main code block. Hope this helped, comment any question that you might have with what I've explained. Note: The code only wants to give you an idea of how to manage interruption, so it may not be the one that fits your needs. 

I see a major flaw in this code right off the bat and that is your interruption management. In my opinion, you are not treating an interruption as such, you are treating the timer as a function instead of a source of interruption in the behaviour of your normal code so a question arises.