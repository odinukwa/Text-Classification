never use exception handling as part of the routine/regular code path in you program. Most Java VM's require significant locking and processing to generate the actual exception and its stack trace. I have seen 10% performance improvements in large commercial applications where simple pre-validation of common exceptional conditions saves a huge amount of processing resources. What if the user enters the non-existent class name , they get an back. In the event that the fails, you do exception handling and return null. If the program asks for the same value again, it will do the full search again, and so on. If the class exists, it is not normally very slow, but, if the class does not exist, the has to search the entire classpath. Cache the results (of both the successes and the failures so you only have to call once. 

now you don't need to worry about closing it in a number of other places. Just returning from the function is enough to close it. Secondly, you should use a scanner... not a Reader. See: which has the documentation "Scanner provides a convenient interface for reading data such as a file of newline-delimited lines of text." Scanner defaults to using line-termination (which is what you have) so it's easy to set up. Your code: 

Now you have an immutable state struct that you can then advance through the daily logic. Each advance returns a new state. Conclusion You've made a great start in to Go. I encourage the use of structs to localize logic, the use of smaller, single-purpose functions, and separating the presentation code (printlns) from the calculation code. I have taken your code and re-worked it in a way I would consider an improvement, and I have tweaked the starting state to match your logic (and also kept the statements in the so that it matches the output of your program. Have a look, and see how the logic is separated, how the flags are used, and so on: $URL$ 

These same cautions apply to your code. There is really only one way to manage content that you need to securely erase later, and that is to encrypt the data before you store it, or to store it in an encrypted filesystem. Deleting the file then is as simple as 'forgetting' the key, or corrupting critical/small parts of it. The bottom line is that since almost all Linux implementations now use ext3 or some other Journaled file system, that your secure erase is not likely going to be secure enough. Code Review Assuming the process would actually work in your setup.... As for your actual script, the code is neat enough, and the command-line arguments are handled OK. There are still a number of problems though: you have no error-handling for any of your commands. if all the dd commands fail (perhaps someone is running in a jail and and are not accessible), but the works, it will seem like the process succeeded, but you have not actually changed any bytes on disk... which is bad. A user who runs your command as: 

In cases like this I prefer finding the "major" condition, and then using a ternary for the "minor" condition. Your situation is slightly unusual in that it is so neat.... but, first do a function extraction so that you can take advantage of an early-return (no variable).... and then consider a solution like: 

janos has given you some nice hints about your random, and array indexing. I believe you should take it further, though. Specifically, your system should be parameterized. I would expect there to be three parameters: 

There's a bunch of small items to consider, and then some larger items too. Starting small.... Sweating the small stuff.... 

Regardless, you give no indication where the class comes from. Still, your situation would be much simpler as: 

With the char-sorted words, you can use the sorted version as the key of a dictionary, something like: 

Data Storage The best way to store your data will depend on the system you choose to store it in. Right now you are undecided. That's OK. Your Reminder class is flexible enough for it not to matter right now. You can adapt at the time it happens. 

debug overhead How often do you run your program in debug mode? And, if it is not often, what is the cost of preparing debug messages, and not using them? If you have code like this in your application: 

Note how we call instead of ? Now, what is ? It is a simple class that takes a predicate, and a Consumer, and it calls the consumer with the value, if the value passes, and it returns false if the predicate passes (which means the value will be filtered in a filter call). It is more comments than code, and it's really simple: 

Your code could be simplified significantly if you remove your checking algorithms, and work off only the assumptions and facts given. What can we say about the inputs? 

Here's some suggestions on what you can do differently to get a better result (both performance counters and code style). The class breaks many rules for naming conventions in Java.... well, actually the class name is OK (), but the method (also called ) is very confusing, because only the constructor (which you don't have coded up) is supposed to have that name. Rename the method to something simple like 'sort'. Additionally, the variables 'counterOne' and 'displaylist' are not necessary... if it were me, I would have 'counterOne' returned from the method, and the variable is completely dead anyway. Doing this will allow you to make the method static, of the form: 

Foot Notes Note that your code has horrible performance on List instances that are not random-access... Consider someone who feeds your code a ... it will perform badly because each time you get or set with an index, it has to scan the data for the value. is an interface available on collections that support fast and easy index-based access. The Java implementation solves sorting non-RandomAccess Lists by dumping all the data in to a different RandomAccess list, sorting that, and then copying it back again, something like: 

There really is not a wrong answer to this. Different places in the Java libraries use different strategies. For example, the new Java 8 code uses with a bunch of utility methods, and the same is true for the and utility classes. On the other hand, these require specific imports to make them happen. In your case, since you have to import the class anyway, it makes sense to make the utility constants part of that class, instead of a new utility class. I see nothing wrong with: 

The result was a sort in 0.096 seconds, or 150 times faster than your code. Now, this code is not exactly simple, so, be warned that it is a little obscure. The first thing I did though, was create a class to abstract away the low-level IO: 

This SQL of yours has three issues I want to address before looking at the performance... Formatting: 

then suddenly you have the fully-featured logging. In many cases this sort of checking can improve performance because it can eliminate expensive 'setup' for log messages 

Look for where the is a complete word not followed by an asterisk. Here's a little demonstration .... Edit: Note, there is no reason to add the case-insensitive switch () because your regular expression has no specific case-based characters. 

Your script is doing a number of unnecessary file copies and scans. I tried to streamline the process a chunk, and came up with the following to replace the line-stripping. Your code does: 

Shouldn't the answer there be 1 for both situations (unless mynode.next == mynode)? To my mind, this method should look like: 

Your question above is lacking any description of what the code is supposed to do, and how it does it. All you do say is: 

The concrete implementation of the Abstract is somewhere else (often un-documented). Examples of this type of factory pattern are: 

Now, since you synchronize outside the add method (and outside the loop), there's no other thread that can call the add anyway. Still, that's not a problem, because your main method does: 

With the above stack, you should not need any casts from to Simplifications Now, looking at some other parts of your code, let's simplify... Chained constructors: whenever possible, have just one constructor that "does stuff" for your class, and have your other constructors call the main one. Your constructors look like: 

Implementing Similar to the calling function, this one is accessed concurrently, and again, I like the use of , etc. Where this function has problems is primarily the way you copy and shuffle the data. It's overkill, and inefficient. You also have similar issues with overly long variable names, etc. Oddly, in this method, you use the early-return concept really well. What you should be using instead, in here, is the concept of a "Guard Clause". Instead of checking for a non-empty list (using - whatever that is - is overkill too) you should just check for an empty list and return. Your method is: 

Your code is odd in the sense that it is going to a lot of effort to calculate that 103 is 1000. I understand why you are doing it, but I took the liberty of changing the terminating function and replacing it with: 

Note that this, on my machine, produces at peak (after JIT warmup, etc.), about 30,000 results per millisecond, or 30million per second.... (and suggests days, even months worth of processing): 

This question really sucks, and it's a good example of why Code Reviews are important, and there is a lot to learn in it. I was very close to closing the code as "Does not work". 3 hours ago you were asked to give some clarification and context. You did not. So, let me show you how a programmer should present their code for review, because in there is a lesson too. This is approximately what your question should have looked like: 

Using a case statement, instead of the subselects, allows you to do logic on the results of a join, instead of the conditions of a join. But, first let's look at potential bugs in your code.... Bugs: 

The above changes do not change the logic of your program at all, just the techniques used at the various points. Your implementation would still be 'textbook'. In terms of performance, though, your limit is the number of times you create, copy, and discard arrays of data. There is a variant of the Merge Sort that uses just two arrays, the input array, and a 'temp' array that is the same size. The algorithm repeatedly merges small chunks of data from one array, to the other, then swaps them, and merges the now larger chunks back to the first, and keeps doing that until the data is sorted. Using that algorithm means there is no additional array copying, etc. It is much faster, but the implementation would look very different to yours. Still I would recommend you try it. There are examples on Wikipedia 

The code above notifies even if nothing was locking things. The effect is probably minor, but it is important for classes like this to show symmetry. The code should be: 

should have a count of 6, and not 18. There are only 6 pairs with difference 0. The pair at index 0, and 1, is the same pair as index 1 and 0, so you can't double (or, for some reason triple) count them. This also applies to cases like: .... you have an input array of just a single element... but you have 1 pair with diff 0? Really??? There is one small performance improvement related to how far you need to iterate in the loop - you have: but that can be just since is always less than or equal to . This is particularly confusing if your input is negative. For some reason, and I can't explain it, I prefer and for those variable names too... seems not-quite-right, but I understand it anyway. Just a niggly thing. Additionally, there are a few places where I would do things in a more Java-8 way. Let's deal with the smaller items first... Small things Consider this code: 

I know it is small, but the implicit cast makes things easier to read. You duplicate calculations once for the base value, then again for the rank, and again in the having clause. These complex aggregates can be simplified by using a CTE. Calculate the raw data in one CTE and do the calculations in that, then, use that raw data as part of the outer select. Describing it is harder than just doing it. Consider the following query which produces the same results as yours: