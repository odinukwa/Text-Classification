It seems strange to me for to be a specific way of getting all items, and should always return all items. Introduce a helper for clarity. 

Taken together, you really must combine the maps into a new data structure which is returned to clients and replaced in whole by the background thread. Storing it in its own atomic reference allows this new class to avoid concurrency and locks altogether. 

One thing to consider first is if you want to be limited to INI files. Other configuration file formats allow sections to nest to arbitrary depth. For an implementation that supports this, take a look at Zend Framework's module. For now, let's stick with your current requirements. 

I try not to cover ground already touched upon by @janos's great answer except to emphasize formatting. You mostly do a good job with the indentation which is clearly the most important factor, but has a loop whose body isn't indented. Consistent spaces around operators (looks like you do), structural parentheses (, , etc), and braces is important, too. As I scan your code, each case of and sticks out like a sore thumb and distracts. Naming two traversal methods is misleading. You aren't searching for a specific value. Use traverse or visit instead. Why are the traversal methods static? Tree traversal cries out for recursion! So many of your methods would be simpler using recursion instead of loops, stacks, queues, and visited flags (is that flag even necessary with the looping algorithm?). 

The parser should handle the optional file validation (does it exist? is it a file? is it readable? is it well-formed?), parse the file, and return the full data array wrapped in a object to provide the remaining features. 

The following rewrite tests only the error ( value provided) path to make it easier to follow. The main difference is that each test now checks a single aspect of the overall behavior. You still need to decide how to group the tests for each use case--either with separate top-level blocks or nesting as you did above. 

The first part that updates the selected credit card has a lot of code duplication that could be made generic. 

In PHP 5.0+, variables that hold objects are actually identifiers for looking up the object. Only assign using the reference operator if you truly need to bind those two variables together. Assigning normally will only copy the identifier and not the original object. Do you need a destructor that calls the parent's? I suspect that you only need to override it when you want to augment its behavior just like normal methods. However, I admit I've never needed a destructor in PHP and could be mistaken. This comes down to coding style, but I am not a big fan of leaving off braces for single-line blocks. I used to be, but once I got used to putting them on every time I became a convert. I can't count how many times I've added a second line and forgot to add the braces and wasted time trying to figure out why it was executing the second statement when the block wasn't entered. Finally, I'd add an explicit for those methods. I believe this will eventually be required for all methods (no more default) in PHP. 

Here is the reference: StringUtils.isBlank EDIT #1 just figured how to use to eliminate one if question: 

well, it can be that one thread will ask at the same time that another is pushing an item into the queue. that is why I believe that in the body of the reading methods you need to create a synchronized block that is dependant on a boolean that is set when a writing method is called. Another advice I can give you is to have a look at package. it contains several lock mechanisms that are more powerful and flexible than synchronized blocks. For example, has the following text in its documentation: 

though it is arguable, Coding by exception is considered an anti pattern. Exceptions should be reserved for error conditions, not as indicator that a virus was found. EDIT: with regards to the question how to implement pt 2: First, I would create a custum exception that signifies a failed virus check 

AS you can see, this solves ALL three problems mentioned above. 2) Use Class names that reflect the scope of one instance an instance of holds the info of one contact. Same as an instance of so it should be named in singular form. 3) misleading method names / redundant logic The logic of modify and remove is fine but the method names are misleading: there is and which give the false impression that they are doing the same. In fact, is actually doing a search for the contact to be removed. same with and . and while we are on the subject, why do you require both old contant's name AND number to find it? especially since you have a choice to search for a contact based on name only. Now, if we agree on that, you can use when modifying and removing contacts. 

the File handlers ( and ) are defined outside of the block, are opened at the beginning inside the block are closed in the clause. 

I have two comments of the tweaking kind: 1) any variable that is shared between threads has to be . this is true even for static variables that have one value throughout the JVM (actually it is per class loader but this is irrelevant here). The reason for that is that threads can locally cache the value of variables. volatile variables force the thread to read the global value each time. You might also want to take a look at which is an int that is guaranteed to be incremented synchronously and that has the same value for all running threads. 2) while will work, Java concurrency package has several Lock mechanisms that allow for better control over the synchronization process. of relevancy here are , . 

Here are my comments in order of severity 1) Bugs 1.1) Split into words in you split the line by a single space character. That has two problems: first, it will split two consecutive spaces, adding an "empty" String to the output array (try it), and second, it ignores all other words delimiters (like tab and new line characters). luckily for you, regex has a predefined character classes that defines all white space characters. this regex will split theline by one or more white space characters. It will correctly split into two words (you can try this on single space regex and see the difference). However, it will not split or so you may need to further enhance the regex pattern (depending on specifications) 1.2) resource leak You get a plus for using try-with-resources when reading from files. However, why did you not use the same construct when reading from the console? you should know that opening multiple readers from the console costs OS resources. While we are discussing , you should be aware that Java 7 gives you a method that allows you to read whole files in one line of code: 2) Performance 2.1) Greedy load of files You first read all the files into memory. That may pose a problem in memory consumption if you are given many files and/or big ones. The processing doesn't require loading all files upfront. A better design would be to read the input line-by-line and do the counting on this line. This way there is only one line in memory at any given time. 3) Design 3.1) Modularity You should follow the design rule of "Code to the Interface". Almost all of your methods break this rule. Instead of specifying concrete implementations as arguments and/or return value: 

Names like , , ,... are bad names for classes; if possible change them to more descriptive names (and use PascalCase). My guess is that the entire body of your button click event handlers can be abstracted into a single method, considering that also seems to be pretty generic. Look at that method and check how it handles the various types of forms and filters. 

If you need comments to document the flow of your method, then you're doing it wrong. Obviously this needs to be split into much smaller methods, each dedicated to their own logic. That was you could move the three lines below to a method of their own that would return a BitmapSource, and you could encapsulate in a block (considering it's an ). Same for : another stream you're not properly disposing of. Quite frankly, I'd move everything inside the into a class of its own and start refactoring from there. 

Zer0's improvements can be further reduced: there's no need to create a , then fill it using and then return it. Simply do all that in one go: 

There are 100+ lines of code here, and all you've done is retrieved one field from one table and displayed that. I'm all in favor of separation, but to me this feels like massive overkill and it is likely to become very unwieldy very soon. It looks like code that would have been barely acceptable ten+ years ago, these days it feels outdated and bloated. 

What if the order changes? Also, this makes it hard to figure out which parameter is connected to which field. 

Now all I needed to do was assign the proper values to the properties, and pass this class to the method where I needed to use the parameters. Is this the ideal way? Not if I had to create a dozen of these classes, no: then I'd made sure to use reflection to figure out the type of a property so I could return the proper OracleDbType, I'd have used an attribute on a property to store the parameter name, etc. 

Also, the point of the class is to avoid a constructor with numerous parameters. Just have public properties and assign those, e.g. 

Using a to pass parameters is just throwing away so much functionality, especially when you seem to be passing dates: . Why not use ? 

has eight parameters. That's waaay too many. Instead, construct a class where each of those params is a property, and pass that class. 

This is still a fairly short program with limited functionality, but you could already consider moving both the logic and the logic each in a method of their own, perhaps even to a class of their own. Keep your lean and clean, use it to stitch together the various independent parts. Ditto for the output part: move that to a method of its own, and provide parameters with all the necessary data. 

The method is declared with clause. However, the code is surrounded with that catches all exceptions, including the supposedly thrown one. The catch block contains what looks like a statement fragment that does nothing (but passes compilation). perhaps you meant to throw an Exception? 

since I know Java :) I have the following comments to add to the previous answer: resources handling Resources, in this context, are the input files you are reading. Their lifecycle is not handled properly. In other words, you do not close the files, leaving OS resources open after the file was read and parsed into memory. This is not a big deal in your program since you only open two files, but it is still a glaring omission. Since proper handling of lifecycle of resources can be tricky, starting with version 7, the Java compiler gives you the feature of try-with-resources, offering automatic closure (and better exception handling) 

define the test data define all possible validators and initialize all of them upfront. validate the input by applying validators it knows when a validator should be applied somewhere inside the validation code block, the method decides that it is now time to do the calculation the method is also responsible for producing all the output (from validation as well as from calculation) 

The actual iteration over the collection is left to the stream library which may decide to optimize this instead of sequential loop. The code is more concise and clear. 

You do no validation on the lines that the method produces. What if it did not produce comma delimited values? the method should give you and you write the line in the proper format (perhaps with the custom delimiter?). Instantiation In you create a new instane of the class for every input line and (also a bad name if you ask me) you accept a list of instances. from that I gather that the design was that a instance represents a CSV line. However, the usage contradicts the design. is supposed to produce an . Did you mean it to return an instance of ? in this case, a better approach would be to use a constructor. This is the proper way for a Java bean to populate its state. 

and the mixin classes can be interfaces (they never get initialized) with matching setter method signatures and different annotations 

in addition, interface contains a method that returns a boolean. how do you plan to prevent clients from calling it? 

the class seems (to me) to fit the "utility" pattern of class that has only static methods (like or Apache's ). Therefore, I recommend that the non static method be changed into static. That would eliminate the calling (static) method having to instantiate an instance of . so there is already a method in . For clarity sake, choose a different name for your method (unless it is dictated by the exercise). how about I am not sure what was the exercise but you need to understand that this is not the proper way to parse an XML document into a Java bean. In the 'real world' there are 3rd party parsers that can build a out of XML document. Now, if we stick to string processing, the method does not really parse an XML element. all it does is cut a substring of a given string. I mean it is fed the starting and ending tokens. If it is to be an XML element parser, it should be given just the element name and it should figure out how to find the text part of the element. in psuedo code: