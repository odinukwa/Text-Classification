In the lvalue case, will be some type , so we're referring to the passed in . In the rvalue case, will be some type , so we'll be move-constructed from . Everything checks out. What about non-member begin? This is definitely the Forgot About Dre of C++11 container programming: 

You are mixing up lots of different responsibilities in your classes. For instance, has to handle both the part and all the pin input parts. It is weird that an doesn't actually take references to its input pins. Furthermore, how in this model do we connect gates to each other? By your design, a "pin" is a value comparable to an integer. What if I wanted to model something like (picking a random circuit from google): 

Also, while you have error checking in case the user forgets to add a conversion (good!), I'd suggest making it more direct. Either all during construction: 

The Expander Trick First of all, and is reinventing the wheel. We have . If you don't have a C++14 compiler, just copy an implement of it from the web somewhere. It's super useful in all things metaprogramming, so it's helpful if everybody's using the same terms. Next, you can write all sorts of "iterating-over-a-sequence" functions without having them be recursive. Take for instance : 

I've implemented and used this pattern before. There are cases where shared ownership (via ) is not correct or desirable, where the ownership policy is as you have described (one thing owns it, but may pass along temporary non-owning references). In the past I would adhere to the convention that the appropriate smart pointers should be used when possible, and thus that any return of a bare pointer through some API was implicitly considered a scenario where the API was maintaining full control over the lifetime of the objects in question (not sharing it, not transferring it to you). The problem with this worldview is that it often must be explained; it's not obvious if the function is returning a so-called borrowed pointer, or if it just does . I've lost track of the number of times I've had knee-jerk "you should use there" reactions from people upon seeing any use of a bare pointer whatsoever. So I do think there is probably some value in codifying the way the pointer will be used in its type like you've implemented (or like what N3840 proposes). But it's possible we can do better. Using a pass-through wrapper type lets us encode this extra documentation, but it doesn't help us prevent any of the errors you still have with such an ownership paradigm (namely, somebody holding on to a borrowed pointer beyond the time in which the owner has decreed it can be relied on). This results in the classic "dangling pointer" crash. It would be slightly more useful if we could tell, either when we delete the owning pointer or when we attempt to use the borrowed pointer, that we've made a mistake (of the two, I think the former is better; the latter is not really that much different than the basic crash unless we spend a lot of memory storing information about the call site where the former happened anyway). You can do this by using internally, and passing around objects as the "borrowed" pointers (at least in theory, I've never used them as such extensively enough to be sure there are no unusual edge cases). But that does carry the cost of the overhead of , which is small but non-zero and generally cannot be easily compiled away. But you can implement an which functions more-or-less like except that it also provides a way to hand out objects and thus can keep track (in a fashion similar to how does) of any outstanding borrowers of the pointer, allowing you to assert and perform diagnostics if you delete the original pointer with outstanding borrowers. You can do this in such a way as to trivially allow all this extra record-keeping to be compiled away, so in the end you just have the equivalent of bare pointers again. But is all that extra work and complexity worth it? We can't approach a system as robust as what, for example, Rust has in its borrow-checker. We can only make it slightly easier to catch a specific case of pointer-related bug slightly-earlier (and with a non-trivial amount of upfront implementation effort and ongoing maintenance of the related custom smart pointers). It's definitely arguable that spending that time rethinking the API (and specifically, the ownership semantics thereof) to avoid the need to hand out "borrowed" pointers would solve the problem better and more completely. I'm not completely sold on it, though I definitely like the theory. I have an implementation I've been using for a while, hoping that continued experimentation and use will lead me to a more solid conclusion. 

And then be (see later on why I dropped ), and you can yield . begin() and end() by ref? This works fine if all you want to do is support iteration in a range-based for expression, but can lead to all sorts of broken code if people start using as a normal container somewhere else. I think it'd be better to return by value. Default Operations where possible Your copy constructor does exactly what the default would do, so just make that clear: 

Also, this already sets everything to , so you don't have to manually. Though your original implementation did as well. What does BFS do? This is a function, that does something with local variables and - and then what? What as the outside observer do I get? This function needs to return... something of value to the caller. Otherwise, it's just spending time doing nothing. Also, again, prefer range-based-for for the push: 

namespace is reserved. Don't add stuff to it. Especially since there's no reason to in this case. Just put it in your own namespace. unnecessary string usage There isn't actually any reason to take the prompt as a . You could have kept it as a character literal. Really, anything streamable is good enough, so this could just be: 

Bubble sort is very slow when run on medium or large lists. I recommend using a faster sort algorithm (e.g., Quick Sort), or using C#'s built-in sorting functions (e.g., the extension method). If you prefer to minimize how much you need to change your existing code, the code for Comb Sort is almost identical to that of bubble sort, while still running significantly faster. That said, Comb sort is a bit less popular (and thus less well-understood) than other algorithms of similar efficiency. You may want extract each step in your algorithm (Sort, Chart, etc.) into a separate method. If speed is important to you, a profiler will tell you which step is worth optimizing first. 

You are not salting the passwords. If you are storing passwords for more than one user and multiple users have the same password, you will be able to look at the database and detect at a glance which users share the same password. Ideally, this should be avoided. You are not using key-strengthening. This makes it so that brute-forcing the password will be easier than brute-forcing the key itself, which means that most of your encryption algorithm is de facto weaker than claimed . I recommend bcrypt for this; I believe it is included with php 5.3+. 

That's a lot of code for a simple operation. What are you doing here? You're counting the incidence of . But there's an app for that: : 

Don't use non-member / You're using standard containers. They have member /. It's a natural thing to use and long predates the non-member functions. The non-members only make sense to be used in generic code, or on types that don't have the members. As-is, you're neither adding more functionality (w.r.t. generic code) nor adding to readability (it's longer to type, and the important part - the container - now comes last). So this: 

No further checks against are necessary, once we handle the empty case. The rest of the algorithm involves just keeping track of a current running sequence and the best sequence so far, which you could do with a local but better to just do with a couple s. 

It takes a while to get used to, but once you do, everything is in the same place, and no necessary. 

If you always use braces, you won't run into issues if you ever add a second line to your code blocks. Also, one statement per line! Strongly prefer: