What you want to do is allocate enough memory to store objects to be created but not actually create them until you need them. For this you will need to understand . Rule of three You declare the copy constructor and copy assignment operator but I don't see a definition. So it is hard to tell if they work. Pass by reference. 

But I usually make this a then it can be used with strings and with C-Strings (the string is dynamically constructed in place). If you are worried about the copy you can always add a constructor that takes the parameter by r-value reference so it is moved into the object. I don;t like passing the number of years held. Then just creating a set of unitialized values. The year is not really a valid value. 

That really depends a lot on the features and characteristics of your system. Do you care if you batch up requests? If the answer is no then I would definately look into and try the period logging approach. 

Also you are performing a bunch of uneeded copies. Capture these values by reference rather than value; 

Do I pass dynamically allocated memory (as you will free it for me) as the message or can I pass the address of a local variable (then you better not free or delete it)? The return value has this been dynamically allocated? Am I supposed to free/delete it when I am finished or is this an internal buffer in your class that I should make a copy of before the next call to this function. After reading the function. I think a better interface would be: 

Personally I prefer to put the const on the right. There are one or two corner cases were this makes a difference and when doing complex C++ templates this has saved my butt. 

And is implemented in an optimal way for your platform. Trying to be too clever and shot your self in the foot. 

You can't see it until you read further and note you are joining on threads[t] even if not all the threads worked. So you need some method to track which threads actually failed and pass that information forward to the join section (what I did below) or you need to re-use the slot in the thread array (If you loop over the array using as the limit then you can not leave any blank slots in the array). 

The other thing I would change is to put it into the SP_ESTIMATE_NODE class. The only time you use this is for sorting in a priority queue. So it is easier to define the priority queue if the class already intrinsicly knows how to sort itself. 

These are OK returning pointers. As here you are saying that there may be no result and you need to validate any result (checking for NULL) before it can be used. But you can pass string by const reference. 

This means the type you are passing is more constrained then type being used in the function. Looking at the types we have: 

But you don't test for the empty string. What value is the empty string? Is it zero. If you print out the empty string what will it display? It displays a blank. So that would confuse the user. So a blank/empty string is invalid input. This try catch is redundant. 

Now that I can see the code. I see a lot of common elements (and I am not sure I believe it is correct). Looks like the tmp element is being set as the second last element in the list and rear points to this element. 

You need to add constructors for moving the data object into the node (look up move semantics). Also building the data object in-place is another useful technique (but more advanced). As I mentioned above: 

C may be an old language but it is still heavily used and has its place. It is practically the only glue language that is universal so great for writing effecient modules for other languages or gluing languages together. It is also great for low level coding where you want/need to get close to the hardware. But there are downsides to writing in C (but saying it is dumb to do so is stretching it a bit). But you should be able to justify your choice of choosing C over an alternative. 

The optimization is that you can ignore all values that are multiples of 2 and 3 if you increment by 2 then 4 then 2 then 4 etc... Now that you know that you are already ignoring multiples of 2 and 3 in your second loop; then in your first loop you don't need to even check for anything below 5. Just make sure to add 3 to the final result. 

Also there is a standard function to check if a character is a hex digit . Pass objects by reference to prevent a copy. 

This is not threaded code (as there are no locks). So there seems little point in making a copy of the data here. 

Each of the pointers in this structure are initialied by a function call that obviously allocates so object and returns a pointer. I don't see any code that correctly tides this up. You should wrap each of these pointers in an class that will correctly tidy itself (otherwise at each failure point you need to write code to tidy up the object correctly). These constructors in Map are obviously not doing anything: 

The two languages have a basic similar syntax but they are different languages treat them as such. Know what is available from the standard libraries: 

I think your whole approach is very C like. Personally I would define classes that represent the fundamental things you are representing and define input operators for these things so that they can be read directly from the input stream. This is what I would do: Note: I am assuming extra white space is acceptable. If it is not then modifying the code to use is trivial. AMPM 

This is because pointers do not have an indication of ownership. Ownership is the concept of who is responsible for deleting the object. So from your interface I can not tell if the pointer I am passing you means you are taking ownership or not. I have to open your class and look at the destructor to see that you are expecting to take ownership of the object. 

I might move the into the the trouble with that is you need to change the iterators from being iterator_const (once you have fixed the first point) to non const. The advantage of course is that you don't have to return a from a function. 

This condition may not be met in all graphs (if there is a subset of nodes not connected to other nodes). Also Dijkstra uses two lists. 

That could would look a lot clearer without the cast. I would only keep it if the compiler is generating a warning. (but then I may change the type of to be the correct type (but I am a C++ programmer and correct types is important to me). This seems like a complicated way 

I think you want to separate producer and consumer from the Moniter. These are three different types of object. When you construct the producer/consumer you pass it a monitor object to use when it deposits/withdraws items. 

An alternative to my first version. If you don't want to use streams. Then I would go with a version that does not modify the original string. 

Space is not the only white space character. Rather than explicitly testing for a space you should use the standard function for testing if a character is white space 

You make the assumption of random accesses iterators. It would be nice to be able to do this with any iterator (including input iterator) 

But the std containers (including string) provide iterators (and more importantly reverse iterators)