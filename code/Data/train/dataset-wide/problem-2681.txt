And that last point also kinds of sums up this review. You've written code which looks OK, but I don't know how I'm supposed to use it. It kind of seems like I could just as easily write the commands on the command line, and that this interface to the Starlab package is just hiding or making it worse for me to run the simulation. 

This uses string.ascii_lowercase for the set of lowercase letters and a positional approach for rotating a letter a given approach. The methods could be extended using default parameters to allow for other characters sets, but that is left as an exercise to the reader. Furthermore I've presented two functions here one for rotating the entire string, and one for rotating a single character. These could have been combined, but I like the single responsibility principle of letting one function doing exactly one thing. Lastly I've kept the main logic from the original post, only embedded it into a , and added some extra information related to the output to display the various rotation offsets used for presenting the text. For even more various alternative implementation look at other posts here at Code Review tagged caesar-cipher (in a variety of languages). Both shorter and longer and simpler and more complex variation exists. 

Another similar optimisation is that you change the array, , and then join it at the end, this complicates matters also. If possible, try to use list comprehensions, i.e. . This makes use of a function to encode a given character. The encryption and decryption are quite similar, so I suggest joining these into one. You'll also have a bug in your code, related to how to find the key (or offset) to use when decrypting. Trusting that is the most common character is at best dangerous. It is better either to include it somehow in the file, or let it be a shared secret between encoder and decoder what the offset is supposed to be. One safer option, if you don't want to have a shared secret, could be to use the length of the first word, or to insert the key as first/last character of file. But depending on frequency of a given character is not a good solution. Using better variable names is also good practice. Avoid single character names for anything but loop indexes like (and possibly for a character). Making use of predefined tables are also a benefit you can take advantage off. The final note, as some other have commented, is to make use of the syntax for opening of files to help encapsualte file reads and writes in a nice way. Revamped code Here is my revamped version of your code, complete with an example of encryption, decryption and comparison of the file. Has left a commented statement, if you want to see the line read, and encrypted version of it. Just for the fun it, I also added in the character classes of digits and punctuation, to further scramble the encrypted file, and if a character is not in any of the character classes it is kept as is. Here is the code: 

Extend to translate both ways A natural extension now is to extend it so that it can translate both ways. In addition to the function, I would also make a function so that you can make functions which can choose which way you want to translate. Look into unit testing and/or doctest Another possible extension is to add testing of your methods, to ensure proper translation and handling of different cases. Loads of alternatives exists, but I'm going to point you towards unittest and doctest. Both of these are included in vanilla Python. The former can be useful for slightly more complex cases, but I've opted for doctest in my review, as it has a nice side effect of displaying with the docstrings how to use the different functions. Doctest can be invoked on your module in a variety of ways, but the two versions I've been using the most are either to call it direcly from the command line using or through calling a simple function from the main code. The former doesn't require anything besides the actual docstrings, and if you use you get to see every test it performs (and not only failing tests) and the summary. Try it out with code below, and change some of the stuff related to lines, and response on following line. Make useful I know I was the one proposing the function you're using, but now that it is maturing, I would make it into a loop asking for which language to translate to and text to translate. This way you'll get a meaning full script to run, in addition to a meaningful module to use. Note how I used a little trick to 'alias' if in Python 2, so I wouldn't need to do the all over my script. Consider also looking into an extra module handling Python 2 and Python 3 like the six module. Revamped code Here is my version implementing all of the above suggestions: 

One of element to improve code is to apply the DRY principle, that is Don't Repeat Yourself. In your code as pointed out by Caridorc you do repeat the clearing of the die face, which should be moved outside of the statements. But a die is very repetitive by nature, so there is more to extract. If you look at the die face for 2 and 3, the only difference is the middle dot, and when going to 4 and 5, you add two more dots. And finally for 6 you add yet another two dots in the middle. This can be formalised as shown here: 

The takes a dictionary of new configuration option changes, and it uses a little trick within the inner loop to check write non-matching options to the output file. That trick is the loop. If the loop completes normally, the will execute, but if a matching option is found and it 's out of the loop then the will not be executed. Also note that in the multiple variant, I've changed the matching on the line to be , which limits the option to be at the start of the line, and a complete word followed by a space. This avoids false hits, as are present in your original code and in my for changing the single option. (Left as proof of concept, see tests below) Test run I tested this using the following file: 

If you're using Python 2.x, I would also consider using if is somewhat large, to avoid creating that array in-memory. This is better handled by default in Python3. In the suggested code I read the file twice in order to get the number of words. This would in a lot of cases be better than reading the entire file into memory, and reading is usually cheap. If not an exact number of words is needed, I would estimate this number by taking the file size, and dividing by the average word length. Finally, I've also created the to return a boolean regarding the membership, as this allows for other uses rather than just presenting a text. Hopefully you'll see the benefit of packaging this into a class. This implementation should allow for a much smaller memory footprint, and it would also easier allow for multiple filter to be used in parallel by instantiating multiple filter simultaneously if that should be wanted. 

It could be faster (or slower), as it skips the array handling and the join/map operations, but it uses a string concatenation instead... 

Alternative logic If I've understood your request properly you are getting a whole lot of sentences, and want to return all the English sentences (and loose the French sentences?). You go about this task by removing everything which isn't , splitting into words and checking against a dictionary, and if the English word frequency is above 0.75 you'll return that sentence (without punctuation). Doing it that way eliminates on a good indicator of French sentences. French sentences uses loads of accented characters. English doesn't. That is a very good indicator (if the Facebook guys care to write those characters), which you are missing out on. Your solution also checks against an entire dictionary, which is kind of expensive. A simpler solution would be to keep two smaller list of typical English words and French words, and make sure to remove non-French or non-English words from these lists. I know very little French, but here is an attempt at some trigger word lists: 

First of all I, for one, do not think your code is self-explanatory. I've read it quite a few times, and if I do understand the code you've written, but I still fail to properly understand your logic. In other words, your code would benefit greatly from some test cases, with proper explanations around them. Even a link to which algorithm you are attempting to implement would be better. So here are some other stylistic and code review items: 

The and main call code is untouched, so keep them as they were. Hope this gives some hint on how to avoid or make it cleaner when using inner functions. 

According to the comment made by Mauricio Scheffer, this has been around for quite some time, see $URL$ . That code however seems to handle different versions of F# which yours doesn't. Regarding a pure code review of your code, it does seem clean enough, and if it serves your purposes, then who are we to say otherwise. It does seem like a neat trick given a suitable use case. My guess is however that in most cases people don't need a new function to be generic, unless they have a specific use case regarding generics. And that means that in most cases, you already know the type of your literal. 

As you can see there is a lot more empty space, bigger markers, and even easier to see that in my slightly changed base data the x-ranges are not totally separable. 

So you if aiming for accuracy you might want to reevaluate the mathematics, and what your base reference is supposed to be, aka if you should use the Earths barycenter or the actual position of the Earth, or possibly the Solar System barycenter. In the code I've provided so far, I assumed that your mathematics where correct, so I've not counteracted for these inaccuracies. 

Another algorithm Your algorithm builds up all permutations of substrings in the given text, and checks each and every one of these are palindromes. This gives a lot of extraneous checks as you keep on checking not taking advantage of known information. One option to get better response could be to check if the current word you're checking is already part of the results set, alongside with if you find a palindrome, then split it down into all the sub palindromes. Another option is to switch the algorithm around, and make the loop go through each character in the text, and see if you've got a palindrome when extending with the left and right character of your current character. This way you'll stop checking when it's not a palindrome and don't waste time checking non-palindromes. Here is that algorithm in working code: 

This will result in a reduced memory print, which always is good. And you process the line only when traversing the line and not both there and in the output printing. The latter is a lot easier to do as you only traverse a prefilled array. Disclaimer: I'm not sure how this is done using multiple processes, but you seem to have figured out that part already. If you're having issues with that, you could try this algorithm without the multiprocessing part. PS! Are all of the processes writing to the same file in turns? It could(!) be better to allow each split to write to its own file, and join them afterwards... 

Another element not covered is what is typical values of the size and length of the arrays, and this might affect some of the other parameters. This could allow for temporary storage in an another container like an or a , or possibly given larger size to rather use or similar to swap the elements. Using would also reduce the chances of getting errors related to big or little endian issues, which could arise elsewise. 

Style reviews I would suggest to read up on PEP8, as it quite common to follow this when programming in Python I've understood. Here are some comments to your coding style based on these guidelines: 

And here is a slightly extended example displaying some of the more esoteric options available using this class. It also shows how neat the output can be, and gives a clear separation of presentation versus the logic to print the table. 

Overall your code is nicely formulated, well spaced and easy to read, even though I'm not into genetic algorithms. Your coding style seems pretty consistent, and that is always good. I have the following comments to your code: 

I'm agreeing that it is bad practice, and that you should use exceptions to indicate error situations. Letting exceptions propagate including other levels of detailing sub exceptions, seems like something you'll loose control over quite soon. I would rather extend the different functions to return the needed information either directly through function returning result objects which could hold the detailed information needed at the top level to determine the causes. You would then collate, and keep on returning more information up the chain. Or you could implement a message queue where the delegates publishes messages regarding discrepancies onto the queue, and you have a central subscriber collating all those into some sensible report to present at the end. This would be especially useful if you are talking about higher level parallell algorithms, but might be overkill for a simpler system. It does however have the advantage that code at any level, could post a message and it's kind of separate from the code logic elsewise.