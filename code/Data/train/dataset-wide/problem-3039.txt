I find it weird that the bootstrap class actually changes the configuration. Configuration to me is a read-only value storage. It gets written in the config object only once in the life cycle of the application request: When it's read from it's permanent storage. The AppController for some weird reason has dependencies on a session manager, a configuration object, and TWO database connections. None of them should be the business of a controller. The controllers task is to be the combining layer between the incoming request on the input side, a number of models that act upon the data in the request as the processing step, and passing data back to the response as the output. Analyzing the input data from the request usually is done by helping objects that represent HTML forms to do validation (none of the controllers business). The models usually make use of some database access or session, but this also is not for the controller to know. Preparing a response means to push some values into the answer, which might actually be rendered by a template, but this also is not really the business of the controller. When I look at your AppController class, I see that it offers a whole lot of methods that have nothing to do with controller tasks, but with implementation details of a concrete application. I see methods like , , , that shouldn't be there. I especially wonder why does not use the to terminate the session. It was mentioned before, but I want to underline that if you force all the application classes to be extended from your frameworks classes, you make it hard for others to use your framework. For example the - for some reason they have to be extended from your mother helper class. A much better approach would be to only force the implementation of an interface, and offer an abstract helper class that already has a basic implementation that can be extended if there is no need to build from scratch. 

While Jesse's position that fields should never be public has merit, dreza's use of auto-properties is a much easier way to accomplish almost exactly the same ends: 

I do not know about the culture-specific comparison behavior, but if it's at all possible to compare the strings verbatim (even ToLower()ed), it would likely be preferable performance-wise. Other things that may help include building custom extension methods that make certain assumptions: 

The downside is having to perform count-N swaps to insert a value into index N (which basically means that pushing or popping from stack X is bound in time to the number of elements in stacks higher than X). Another option is to use the array to implement a simple "hashset"-like structure (with 3 "hashes"; one per stack). The general is to create a Node struct, which your primary array will hold copies of. Each Node holds the actual value pushed, and the index of the next lower Node in that stack. To push, create a Node, assign the value and the index of the current "top" node of that Stack, then put that Node in the first available spot in the array (which you must keep track of because elements can be added/removed from pretty much anywhere) and remember its location as the new "top". To pop, do the opposite; go to the remembered "top" index, get that Node, then clear that index (checking to see if it's a lower index than the currently-known "first available"), and set the "top" node to the popped node's "next" index. The advantage is O(1) access in most cases (pushing a node, which requires determining the next null index of the array for the next push, is worst-case linear); the disadvantage is extra space necessary to maintain the links between nodes of a stack. 

It converts currencies. It validates currency identifier. It fetches HTTP resources It caches fetched HTTP resources. 

Your classes do too much different stuff Your classes do not implement proper dependency injection. But if they do, they have very weird dependencies that will fit a certain use case, but not all. 

I must criticize your tests. They are not part of your question here, but available in your github repo. Your SlotTest does not test slots. It does test the page. Why? 

I have some criticism on details you didn't ask, but which should be addressed: Autoloading Make use of it! There is no need to make manual calls to . There even is a standard: PSR-0, which defines how you should structure your class and namespace names together with the directory and file structure. When I look at your code, I see some issues: Because the underscore was used as a separator before PHP got namespaces, it is considered a separation character in class names. Namespaces Make use of it! I cannot see a reason why the exception \DH_MVC2_Application_Exeption is located in the root namespace, and not called \dh_mvc2\application\Exception. It would be so much easier to simply inside the "\dh_mvc2\application" namespace. Whitespace and coding style Endless debates might occur, but I really don't like yours. Especially the inconsistent placement of parentheses. Personally, I'd rather prefer not to use that much spaces, but if you really have to, use them everywhere. For example, if you want to find the function "set_ini_default_paths", and want to make sure not to find "set_ini_default_paths_directory", you'd search for "set_ini_default_paths(" - which will find only function definitions, but not usage. To find these, you'd have to search "set_ini_default_paths (". Dependency injection Doesn't take place. Objects are created inside your class. There is no way I would be able to change for example the Config object if I'd use your class, I must use yours. I even cannot change the config filename! Include path Be careful what you add here. If a PSR-0 autoloader is used, there is no need to add anything to the include path. In fact, you'll get a good amount of performance if you include as few directories as possible, preferably only ".", to be able to include files with a relative path. 

This could probably be optimized in our case to return early if we discover that any node's child depths differ by more than 1. We could hack it by throwing an Exception, but the proper strategy is almost as easy to implement: 

The one thing this doesn't save you from is Joe Programmer implementing some method within this class that mutates Cost or Weight, requiring slightly more discipline in code reviews (and Joe Programmer can do similar damage to pretty much any other implementation; the readonly keyword on a field will just show him he's wrong, and then he's double-wrong if he removes it). If you ever needed to convert this to a property with a backing field, that can be done trivially by any refactoring tool you can plug in (and if you aren't using something like ReSharper or CodeRush, you're not doing it right). BTW, regarding public static readonly fields, I don't have much bad to say about them, and I don't think they should be avoided out of hand. C# In Depth states that using a public static readonly field for the instance member of a singleton (or here, a multiton) is not only fully thread-safe, it's reasonably lazy when used as a true singleton. In a multiton situation, the constructor's invoked, creating all static instances, on the first reference to any one of them; using the structure will get you lazier and still thread-safe operation. I would avoid exposing instance-level fields (readonly or otherwise) if you also use properties. This combination of member types makes reflectively accessing members more difficult because you not only have to scan the type for member fields, but also for member properties. Public fields have additional drawbacks vs property accessors, but if there weren't some merit to being able to expose them, then the C# team simply would have disallowed use of on a field, n'est-ce pas?. 

Reading the tests, I do not really see how a single slot is to be used. I only see how multiple slots inside a page are used. Also, I only see tests for several GET methods. If I want to verify that the results that are coming out are correct, I somehow have to read the config fixture file - a secondary source of information. This situation actually is bad. I want to be able to read the tests, and actually CHANGE some input values in a certain test method to see whether or not it changes the output and breaks the test. If I cannot see the input, I cannot play with the values. One final improvement: If you include files, they can actually return a value. You do not need to define a global variable that will transfer the config values. 

Easy. And completely unrelated to your currency conversion so far, but it solves a problem you might have, unless you are only offering a web service that inputs amount and currencies and translates this to the other value. What about currency conversion? What about adding two different currencies? Decorator pattern to the rescue! You can build a decorator that implements the same interface, which wraps around a currency object and does the calculations for converting the currency. Let's fix the interface stuff first: 

I have seven checkboxes on a data maintenance WinForm, which indicate the days of the week that are "valid" for a particular operation to be performed. These "map" to a list of DayOfWeek enum values on the backing domain object; if the value is present in the list, the box should be checked, otherwise not. Any combination of boxes can be checked. In the "bind" method that sets the UI controls to the proper values of the domain object, here's how those checkboxes are set: 

What I came up with is a variation of a "multiton"; a class that cannot be instantiated in code, but has a finite number of static instances each representing a valid value of the type. They are implicitly convertible to strings and so the static members just drop in wherever a string is needed. 

You can do this with vanilla Linq. The question is whether you want all keys on the left plus new keys from the right (a "full join") or common keys between left and right plus all keys on the right (a "right join"): 

You are doomed! Basically you try to allow an attacker to define which code should be executed, and you try to find out if you are smarter in detecting malicious code than him injecting and hiding it. The "EXEC" mode is completely insecure, we need not discuss this. But I doubt the blacklist mode is of good use either. I feel it to be insecure as well, but I cannot prove it in 5 minutes. For example, I can try to read any file on the webserver by calling . I can try to overwrite any file by using . I could install my multipurpose script this way that is called a second later, and you get owned. In the end, only the whitelist mode seems reasonably secure, but this is just a generalized form of AJAX RPC calling - and a very dumb one, because it is limited to single PHP functions, you cannot do anything more sophisticated. And if you really think about it: There are already plenty of working solutions to allow Ajax calls to do more useful stuff within one single call. Some of them are called "restful webservice". 

Even better, if you know the logging could throw a particular type of exception that the other operations will not, then catch just that exception and handle it as a logging exception, and let all others trickle down to a general catch: 

The code to read the UI controls' state back out to the domain object is similar; if the box is checked, add the corresponding value to a "clean" (initially empty) list and assign it to the object. This smells. I was thinking of adding a Dictionary containing the checkboxes and keyed to their corresponding DayOfWeek. But, that sounds like a bit much as well (it certainly wouldn't save many LoC). Any other suggestions? 

For the absolute best performance speed, I'd recommend a Dictionary of all possible values and whether they are the pattern you're looking for or not. The Dictionary has to be hard-coded or generated as a one-time cost, but once it is you get constant access time making the whole thing not only linear-time and very fast, but rather elegant: