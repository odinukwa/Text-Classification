I would also suggest that you always use brackets for your statements. It's generally accepted common practice and with good reason - the few lines that you save by not doing so lead to some very insidious bugs. On an algorithmic note: why reverse the at all? Use one loop and read the both forwards and backwards simultaneously. For further improvement, walk through a comparison manually: 

Set everything to as you don't know if anything is a composite. This isn't really required as in Java is by default. Starting with to , if , loop over for while in increments of and set . You now have an where anything that is () is a prime. 

As runs in a separate , we need to consider visibility and atomicity of any variables used to communicate. So an seems the natural choice: 

Are horrible! If you need to label a variable declaration with what that variable is, you have picked the wrong name. Further, if you are going to use inline comments, avoid the case where the comment makes the line so long that it's illegible. 

I have some code that calculates the "sentiment" of a Tweet. The task starts with an AFINN file, that is a tab-separated list of around 2500 key-value pairs. I read this into a using the following function: 

So now you can easily add new "transformations" to the list. In order to transform an to the correct in Scala we would simple use as is also a collection. No such luck in Java. I came up with this thing, it's a little ugly but I think it's clear: 

I also had an alternative idea where instead of have a I would just have a . In this case when I found the cycle I would just go back to the start of the cycle and re-run it (but this time with a counter). This would trade speed for memory, but both would still technically be O(n). I ultimately decided against this because if you scale this up to arrays that are not of s, the solution I wrote would do better (since the extra memory is ints, where as the extra computations could be complex). 

The idea is to search the array from left to right, looking for rises in elevation. When we find one, we backtrack looking for how high up we can fill the valley, and then redo the backtrack, this time actually filling it (this prevents "double filling" in future elevation rises). The worst case arises when we get a large elevation on element 1 and elements 2 through are rising from 1 to the value of element 1. IE . In this case we do the maximum number of backtracks. If I have my math right, our time complexity would be $$n + \sum_{i=0}^{n} {i}\ = n+\frac{1}{2}n(n+1) \implies O(n^2)$$ So quadratic time obviously a red flag, but I'm not sure I can avoid it since I'm dealing with 2D arrays. Other than that, the big ugly part is the variable in . The point of it is to check that the left edge we end the loop on is properly checked. The last notable issue is that much of this code would be very risky if run on its own because the assumption is that all inputs are valid. This was due to time constraints though, so I don't consider it an issue. 

read a tweet file, with a JSON tweet on each line parse each tweet to a using extract the field from the tweet - giving the content of the tweet for each word in the content, check it if has a sentiment for each sentiment word in the tweet, calculate it's value (from the AFINN ) and sum across the tweet store that number 

I'm happy with this code - it's pretty clear and I'm not worried about its speed and memory usage as the file is small. Using the created I now need to process many tweets. Lets say I have 1GB of then in JSON format - from the live stream. What I need to do is: 

This way they are outside of the running code and clearly constants. Similarly should (almost) always by an instance or class variable as having more than one is (almost) never useful. Use for outputting formatted messages: 

Firstly because of the scope of and also because loop indicies should be incremented inside a declaration unless you have a good reason not to. I would prefer the following construct as it show that I have two variables used in the loop, that the termination condition is and that I increment every iteration. 

Using Caliper this method has a runtime of around for . I have done a few experiments with speeding up the code. For example, using the Prime number theorem we know that there are approximately prime numbers between and . Using this information we can create the used for storing the primes to almost the right size: 

Bearing in mind that a linter can only look at how the code is written and not at what it's actually doing, statements (or the equivalent as with Ruby) that don't do much are completely fine. A switch that tests many conditions is bound to be long-ish, there's not much you can do there. Every one of the warnings you get is a direct consequence of the fact that you're testing 8 values. I would say this is one prime example of a situation in which you just don't waste your time in an attempt to make the linter happy. Extracting methods is going to clutter things up and look dumb. The only viable option that I can think of right now is sticking those ranges along with their readable description in some kind of hash, and retrieving the value from there. But it's a compromise, really: if this method gets called often, you could be instantiating yet another object at each call. I say you just ignore what the linter says in situations like this, or adjust its default settings to make it less bitchy. Your method is fine, the intent is very clear to me, and it's not doing anything complicated. Don't get all caught up in an attempt to please a tool that doesn't understand your code to begin with. 

Code like this is bound to be a bit hairy. However You aren't using parameters This is a big security vulnerability. What's that method doing? Is it doing everything by the book? Does it handle every possible obscure corner case? Let ADO the MySQL connector manipulate your query, especially if there's a chance you're handling values supplied by the user. MySQL can perform the so-called MERGE (also called UPSERT) You can do it via INSERT ... ON DUPLICATE KEY UPDATE statement. In case you are not aware what that is, it's basically a way to either insert or update in case the fails because of a duplicate key error. It's for sure faster than making a separate query to retrieve the records that are currently present. By the way, code like this leaves your code open to race conditions in case another user inserts a record exactly between when you read the current records and the moment you execute your . This is bad, and you're not currently guarding against it. MySQL can do it for you, take advantage of it. EDIT Also 

So we create a to communicate between the clock and the main . We place a sleep in the clock thread that sleeps for seconds, if the thread is interrupted before waking, it simply exits. This is much more efficient than your busy wait as it doesn't tie up an entire CPU core for absolutely no reason. Never busy wait! We can now modify the game loop to: 

Iterators Kudos for correctly using an to from a while iterating. But, as described above, this is not the correct approach to implementing a Sieve. Programming to the I don't link this method declaration: 

You don't use any of the properties of . You do not need to know that it is a . I would specify the argument as and leave the invoking class to decide on an implementation. Brackets There are two styles of using curly brackets in Java, and either are valid: 

This should reduce the amount of time the spends resizing itself. This reduces the runtime by about for - so has little effect. These sort of micro-optimisations should always be tested using benchmarks to see if the additional code complexity warrants their addition. A few comments on the code: Use of You use sometimes to delimit references that won't change: 

never create a in a loop, and always close resources. never write this is ugly and error prone ( also compiles). you only need to check once; after reading user input.