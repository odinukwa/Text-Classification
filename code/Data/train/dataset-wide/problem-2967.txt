This code would make the greeting valid for both languages, while also making the code more mantainable if you want to change the greeting message for any language/s by having all the messages in the same place. Keep in mind I substract 1 from since arrays are zero-index based. Implementing language this way can save you a lot of code, make it more readable and also more mantainable since you don't have to look in n lines to fix an error that has propagated through all your languages due to copy pasting code. This can be applied too to handle any amount of users, further reducing your code and making it, again, more manageable when maintenance or improvements happen (which you are bound to do). If you need help in developing anything, comment my post with what you need and I'll try to give you an answer as clear as I can. Hope this helped explain how to handle multilanguage. Note: To ease the maintenance of interface messages, you can switch the matrix, n for languages, m for messages, that way you will have in the same first dimension the same message for all the languages, rather than having all the messages for a language in the first dimension. 

Again, as I see it, this program does not treat an interruption as such, so I'll give you an explanation of how I've been learned to treat them and how it can improve your code. First of all, an interruption is a source which interrupts the currently executing code to execute another that expects an event. Due to this behavioral, an interruption should be always as short as possible. An interruption needs to be as short as possible because if you can call an interruption before it has ended (like in the case you are experiencing) it will overflow the stack pointer at some point in your execution and cause your device to not perform correctly. This happens because when calling an interruption the embedded saves where it is, performs the interruption/s (if more than one has triggered) and then comes back to where it was and resumes normal program execution. Do you see the main problem in your code with what I've explained here? If your interruption takes longer than the time you call it periodically, you will never exit the interruption, thus regarding your code unusable while also making your embedded to perform badly or not as expected at some point because of an overflow in the stack pointer. Because of this, an interruption should only consist of flag management which will be used in turn to allow the code intended to be executed in said interruption in the main body in your code. You might ask yourself how you can do this, so I'll give an example of how to implement this on your own code. 

To meet the requirements of input iterators, you are not going to be able to improve on what you already have. If you want to optimize for other cases, you can refer to the notes on : 

isn't needed after using a control flow interrupt (, , , etc). Help reduce indentation and limit the amount of code you ask readers to keep track of. 

Should be publicly exposed? Prefixing is implied. Typically used in objects you maintain, so as long as you avoid shadowing names, you shouldn't need to prefix and can reduce clutter. Don't weigh your members for ordering. Lexicographically compare your data members. That means you should find the first mismatching data member and then apply the comparison operator. C++11 makes this simple by using (requires ) on the data members to create a , then using the comparison operators for objects to lexicographically compare. Using and , you could implement the remaining 4 relational operators through logic. 

What is the value of ? Conversion of arithmetic types using separators is dependent on the locale of the stream. The possible results are 

Follow the Rule of Zero. If you define one of the special member functions (destructor, copy/move constructor, copy/move assignment operator), then explicitly define them all. With in-class initializers, prefer letting the compiler implicitly generate a default constructor. If you require an explicit argument constructor or a conversion constructor, explicitly default the default constructor. Your destructor could save on one pointer copy by using directly instead of . 

First and foremost, You now don't have to worry if it takes longer for the code to execute than the timer to fire, since you have control over whether or not the program has to read from the ADC. Secondly, your program can execute many things while the ADC performs a conversion (essentially we've made the ADC conversion a task which we launch and later ask for its result), this might remind you of asynchronous code. 

The problem here is the lack of functions or subroutines to avoid repeating code, thus making the code less mantainable. There are here other issues which are also important, for example, multilanguage support, which I'll address in the following To carry out multilanguage, I would declare an n x m array to store the n strings in m languages. To provide an example of what I mean, to store the greeting message, an array like the following needs to be declared 

The code works as intended what I am concerned about is optimization, how to improve this code in both, execution time and stability. What I am doing in this code is compare each element from one list with ALL of the elements of the other list (I see a problem here, but don't know how to approach it well, the foreach seems not to be the best option here). 

The code works as intended but, as said, I would like feedback on what I can improve in this code. That explains why I post this question even though there exist duplicates of this one, I just want feedback on my code, that's all. Thanks in advance for your responses. 

Prefer initialization to assignment in constructors. Some class types cannot be assigned; some cannot be default-initialized, some might be expensive to assign instead of initializing. 

Don't pass a smart pointer as a function parameter unless you want to use or manipulate the smart pointer itself (i.e. share/transfer ownership). See GOTW 91 Make empty and single-line statements visible. 

Undefined behavior here. If the is full, you erase no matter what happens. If insert succeeds, an iterator overwrites the current invalid iterator in the LRU. If insertion doesn't succeed, nothing happens to the LRU and the current iterator is just invalid. Check before erasing. Erase when inserting. Determine how you want the LRU to behave on failure to insert. 

Before coding, did you go over the requirements with the interviewer? Are strings limited to just words? What about sentences/phrases? Any adjustments for capital letters, punctuation, word dividers? Consider that the phrases *A man, a plan, a canal, Panama!", "Was it a car or a cat I saw?", or "No 'x' in Nixon" are considered palindromic phrases. Also, why do you ignore strings of length 1 and 2? Document the reasoning. 

Be aware of the possible states a type may represent. What happens if someone runs the program and inputs no data? Boom. The mean cannot be calculated because division-by-zero is undefined behavior. The median cannot be calculated as an empty set is consider an even-sized set. accesses results in an out-of-bound access, which is also undefined behavior. Explicitly assert/validate your pre- and post-conditions. Do not rely on assumptions.