The final XML will be more complex and have a deeper hierarchy, and the attributes might occur across different nodes. Is XmlDocument and XPath the most efficient aproach, or would Linq to XML perhaps be faster, and what would that look like? 

Use meaningful names Your use of , and are 3 examples of meaningless variable names. Consider more meaningful names. Use independent loop bounds Your Loop uses as the loop variable and the starting index: 

Declare as a String Array tmp is assigned with the function, which returns a String array, so declare accordingly and you'll use a great deal less memory. 

Providing flexibility in the return type But what about return-type flexibility and/or longer strings that need encoding? The function forces a string on the consumer of the function, but returning an array of hex encoded characters might be more useful, and if a user does want a string, then a string-returning function just joins the results of the array returning function. That way I'd have something like: 

Unique keys and Dictionary usage The code to build a unique key and populate the dictionaries is the most expensive, so let's be careful about checking the smallest dictionary more frequently than the large dictionary. Also, there's no need to and then back, when we can just increment the count of the existing entry. 

The file has nearly all duplicated records, so I'm pushing the limits on the unique key approach. A file with all unique values will perform differently. Using your code against the 5MB file, it runs in 6.18s. If I only read the file, it reads in 0.11s. If I only read the file, split each line and build a key, it runs in 0.76s. So approximately 5.42s, or 88% of the duration is related to dictionary manipulation. So, what can we do in VBA, to improve your code Option Explicit You haven't included it in your code, so I assume it isn't declared. Declare As String The variable isn't declared, although you may have declared it at global scope. Option Explicit shows e this right away. 

Are you sure you really need that selector? Wouldn't do the job just the same? While we're at it, why are you listening to the click on the elements, and then find the via ? Can't you just listen to the event on the s themselves? Is there any method to that configuration? I wasn't able to deduce any algorithm from what you've provided, but I'm sure there is. You'd be better off calculating it on the fly, if possible. 

The method will traverse the DOM all the way up the chain. Rather use the method, which will stop at the first match: 

Just keep in mind that this will query the DOM on every single !! Are you sure you can't somehow do this differently? 

While using a closure to prevent polluting the global namespace is a good idea, you shouldn't be passing in random data like that. The way you are doing it, you are forcing the reader to scroll to the bottom of the function call before reading the function body - that's just plain confusing for no good reason. Instead, declare the variables regularly within the closure, and assign their values right then and there. That way, it's much easier to read (and maintain), while still keeping the global namespace intact. 

If you want to, you could even build that original array dynamically, which will make this much easier to maintain: 

Please remember to always cache your selectors. To get the of an element, use instead of . There's no need to use two separate steps to first get the value, then set it. Instead, pass a function to , and return the new value you want. To convert a string to a number, just prefix it with the plus sign (e.g. will return the number ). It's safer, and more concise, than . When using CSS selectors, you should always strive to use the native CSS3 selectors, since they're much faster than jQuery's own custom selectors. and are not CSS3 selectors. In your case, you should use and , since they're native CSS3 selectors. Since IDs are unique per page, there's no reason to qualify an ID selector with the tag name (as you've done with ). Just use the ID on its own. Again, better performance. 

Collect all the Widgets Then we need a class to hold all of the widgets. The all important method for enumerating the collection is which has a special attribute set. The class also has a factory method for creating a Widget (Without actually adding it to the collection). 

And why not throw in a factory method too, although some might argue it's a return to the year 2000. In order to get the enumerable features of a Collection, I'll have to use a Collection behind the scenes, but I'll augment that with a Dictionary that keeps track of the keys used in the Collection. Then, when I want to test the method, I can check the Dictionary (and get all of it's hash-tabled goodness) instead of enumerating the Collection or suppressing a potential error by checking the index/key directly. I also want to make the Collection configurable so that it can be 0 or 1 based according to preference. I've made this setting private to the Collection, so it's up to the developer to adjust for the purpose at hand, but it could easily be exposed as property or set in a factory method. Pass the Widget First, we need a class for the objects that we'll put into our custom collection. A will do nicely. Nothing special here - just a class with a few encapsulated fields, and a bonus read-only property for returning an instance of itself. 

I assume you're working with a 40MB file instead of a 40GB file. The performance will vary greatly depending upon: 

You could also omit the variable, and just use the count of the controls. But you might consider using a 2D array, or maybe a dictionary to keep track of the names. Referring to the Form Designer/Controls You use as the type of the Form, when, in this case, it will always actually be a , but you don't actually ever need the form... you need the . And the are enumerable so you can use 'For..Each`. 

Avoid using magic function/literal values You're referring to the Tab character which incurs time on every line. VBA has a built-in constant for Tab: , which makes it more efficient and easier to read. 

In addition, Crockford suggests that you put the calling parentheses inside the wrapping parenthesis. 

Your variable is declared without a , so that it's leaking into the global namespace. Don't do that. As it stands now, your isn't used anywhere in the code. I'll assume it's not applicable here. Instead of manually keeping of your iteration, use the % (Modulus) operator to calculate your rows. jQuery's method doesn't deal with code fragments the way you seem to think it does. actually appends a whole table, not just an opening tag (that's not even possible). Access to the DOM is not free. Every time you hit the DOM you incur some overhead. Try keeping DOM modification to a minimum. Unlike others, when dealing with a simple HTML construct such as this, I prefer to build my fragment from a concatenated string since it's much faster. 

P.S. You haven't described how you're exposing the plugin's additional methods. For that you should read the jQuery plugin creation tutorial. Find the section titled Provide Public Access to Secondary Functions as Applicable. 

I built this very-basic lazy list (I'll add more methods as I need them). You provide it an array, a generator or any iterator. It creates a lazy list, which lets you run a pipeline of transformations in a lazy manner, meaning that they'll only be applied as you pull values out of the list. Here's the class: 

Sane Selectors - There's no need to add all those selectors by hand. Simply use an attribute selector to select all elements that start with a given string. Selector caching - If there's one thing you can do to your code to keep it fast, it's selector caching. $.each - We're using jQuery's helper to loop through the array, since it also supports older browsers ( is not supported in IE < 9). 

Very good question. I'm pretty sure this can't be done within the selector. However, instead of checking the every time it's clicked, the collection before applying the event listener: 

When providing an object, I don't think it makes sense to pass the index into the callbacks. Rather, pass in the current key. Also, I think reads much clearer here: 

In this instance, the statement does away with the need for the statement, but if is an empty array, then you'll get a subscript out of range error when you try to ReDim with an upper bound of -1. It may be the cases that will never be empty, but it is still good practice to check. 

Clarifying the Form type Access has built-in objects, but also allows the use of VBA . It might be helpful to qualify the type as : 

Properties in Standard Modules Standard modules can have Properties, but as @Rubberduck pointed out, they're not necessarily intuitive (although they do force you to qualify a call with the module name, so there's that as a redeeming quality). You could write public methods instead, but you could also create a class, and if you wanted to avoid the need to it up, you could give that class a attribute. A class would better reflect the stateful nature of the settings, and would give you the flexibility of abstracting the persistence of settings from the retrieval and usage of settings. Right now, your approach looks up the value from the underlying table every time, and writes it to the table every time. That's time consuming disk access and page locking. It might be better to load the settings on demand, use/change the settings, and then save them on exit. Variable Names is presumably short for . Why not use the full name, or better still, something like ? could be confused for the statistical term , or a user might infer that the is Hungarian notation, but guess at what type that notation represents. SQL Injection Kudos for using the (presumably from @Mat'sMug's CR question), but you're building a SQL statement on the fly, and a malicious user, or inadvertent user could cause an error, or worse, by providing a parameter with a single-quote in the . What happens if the user supplied ? At the very least, sanitize your inputs. Better still, parameterize your queries and leave a sign up saying that Johnny DropTables isn't welcome. LateBound `PageFrame` property You're explicitly returning an , which forces usage of the property to be late-bound. You probably know the type of the return value, why not use it? If you know the return-type will always be an instance of , then return that type: