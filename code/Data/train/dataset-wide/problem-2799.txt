Editor SharedPreferences.Editor is an Interface used for modifying values in a SharedPreferences object. All changes you make in an editor are batched, and not copied back to the original SharedPreferences until you call commit() or apply() 

Visual C++ excludes rarely used stuff from the platform specific. can fail if the file system contains links to the same file that the compiler cannot follow. For example, NTFS5 (Windows) supports hard links, but you can't detect that files are linked if you access the file system across an (SMB) network. What about to use a standard include guard? It works just fine. The one caveat is that GCC didn't support it before version 3.4. 

However, the function objects can not access protected members of "their" object, which may require that you break encapsulation on the host class so that the function objects can do what they need to do. All in all, this seems like a good way to associate an object with external behavior that should be initiated by that object (e.g., a button click handler), but using it to extend the inherent behavior of a class seems like it creates more problems that it solves. The most common example of a good use of this paradigm is for callback functions or event handlers, because the class is concerned with the mechanics of drawing the button and handling mouse events (for a button class), or with managing the network protocol (for a network socket class). In these cases, making the event handler virtual and implementing it in a subclass isn't good object-oriented design because the subclasses aren't conceptually new "types" of their parent classes, just like you shouldn't have to subclass a button to change its height and width. 

I agree with all things said by @TopinFrassi and want to add some additional notes. If you have the same code repeated multiple times extract it to a method. Define method like this 

Also please place each property of a control on separate line in XAML because it is very difficult to read the code where lines go far to the right. 

should be rewritten with use of style. You can define either explicit style (with specified ) or implicit one (that will be applied automatically to all controls of the specified type): 

you don't need since the provides method which doesn't require additional memory allocation. I recommend to use for all variables where the type is obvious from the right part of expression. I hope you'll agree that 

I recommend to swap naming convention: use underscore for private fields and remove them in constructor's parameters. It is common practice that allows you to easily distinguish local variables from fields. 

SharedPreferences SharedPreferences is main of them. It's responsible for getting (parsing) stored data, provides interface for getting Editor object and interfaces for adding and removing OnSharedPreferenceChangeListener 

Exception Handling In the case of creating a Robot, if you get an AWTException as you have, remember that this means no Robot was created so you can't rely on it later. Remember also to show the exception description. Typing "error" or "unknown error" isn't so fair for me, you can easily get the description of the exception. 

If the function is a class/struct method, the array can be defined as a static (class) property outside the function, just to avoid instantiating it for each function call. Note that this solution generates a runtime exception if the num value is not in the [0, 2] range. I suggest you to apply the method by using the statement. 

case is handled by the default case, using the fallthrough keyword. Now you are able to apply this method to your code. Following the example, an alternative way to achieving the same, taking into account that the possible values are consecutive and starting from 0, is using an array: 

It will simplify all your methods. Also if you will return instead of they can be even more simpler. For example, will be 

In CLS compliant version of the indexer you should check if argument is negative and cast it to without checked context: 

the is redundant since at this moment you already know that it is because is . So the condition can be simplified to 

I'm personally not a fan of passing streams and readers in constructors to initialize an instance of some class. In my opinion constructor should be as simple as possible, without reading from streams and heavy calculations. Ideally it should take only parameters that will be stored to fields or properties. In you case I would change this code: 

you didn't pass parameter name and actual value. I recommend to use 's constructor that takes 3 arguments: message, actual value and parameter name. Here 

Method If you want to type the text without having to do each letter at a time, I'd use a Map to keep track of what code relates to each letter. Something like: 

Actually, I think you want to use rather than but this is besides the point. To write to multiple clients you want to make sure that you don't use blocking writes. You might get away with not detecting whether a particular can digest more data and thus you might not need to use (or ) when writing. However, if you want to be prepared for clients consuming data with different speed you might want to receive notifications when a client can digest more data. Other than that, or can notify on both data available in the read buffer or space available in the write buffer. The use is pretty much the same except that you need to set a different flag. Your code is well-made, but there is something you could do to make it more readable and more efficient. Coding-Style 

There is no need to store result of calculations to local variable if you return it immidiately. So you can write just 

View-model should never think about view if you want to write good WPF apps which means you should use MVVM correctly. Your and properties violate this rule. What are these indices? Where are they used in the view model? As I can see you use them only for updating view: 

which cause many memory reallocations. Since during one game grid size is a constant number you can save it at the constructor, and then just create array for result and set its elements by index. 

I would return from . It is more general approach. User will decide then what collection he want â€“ array, or something else. You even don't need to check whether contains elements or not. 

I believe it is a bad idea to use default parameter value for private methods. Default argument is an easy way to forget about parameter and get incorrect behavior. But it is just my opinion, not the rule. 

SharedPreferences - Best method Java provides many ways of storing application data. One of those ways leads us to the SharedPreferences object which is used to store private primitive data in key-value pairs. All logic are based only on three simple classes: 

A static function is almost like a global function: it doesn't need a class instance to be called on. So you only need to get the pointer to the function to be able to call it. Take a look to (or or if your compiler doesn't provide it yet), it's useful in your case as it allow you to use anything that is callable (providing () syntax or operator ) as callback, including callable objects and member functions (see or for this case). Functions aren't comparable, but pointers are. The reason functions aren't comparable is that there is no way to determine if functions are equal (not just in C++, in computer science). I.e., there is no way to determine if functions have the same value. However, by using pointers, we can at least see if they occupy the same space in memory. . Take care when using this, and you may have to perform your own checks when a callback is registered or before you call bind, to make sure that you don't have two duplicate binds of the same function but that occupy different places in memory. To use a callback to customize a class instead of subclassing, with your alternative you can: