Execute next should follow the same idea and be split in a few methods like: that produces a list of arguments and that will take care of processing them and do the appropriate thing. 

I also implemented an alternative solution. The main difference with respect to yours is that I generare a list of (numerator, denominator) pairs instead of having two separate lists. 

If you do this now you have different classes to cover different concerns with a very lightweight API. I appreciate your use of dependency injection instead of using singletons. I think it is quite good. 

you can easily determine what is the corresponding mark by going through the list until you find a lower bound greater than the value you have. For instance, if your input value is you first evaluate . is bigger than so you can move on to . Ditto for . Finally you get to , you see that and hence you know you have to return . 

I like the way you defined and . I think that using to compute the number of digits is a bit overkill. Do you really need to convert the number to a string to do that? I think that using a logarithm is better. 

clearly something went wrong because , which should really be local to never got cleared between the first and the second invocation of . Your algorithm looks ok. If you need more performances you probably need to trade some memory for a better execution time and adopt a solution based on a Sieve of Eratosthenes-like approach. 

why do you do output there? It would be much better if you return an with all the prime factors of the number passed as input. Let the client decide what it needs to do with the result. It might need to output it but it might need to do something with all the prime factors instead. Why do you create an object for that class? It should not hold any state. What you need is a static method. It should be something purely functional. . With your code, the client of your code has to instantiate a new instance, which is useless. Holding the state also causes it to produce wrong results in cases such as the following: 

I agree with Resharper and I'd go for the version. The reason is that I associate with operations in which the number of elements actually matters while in your case you just need to check if there is at least one element. On the opposite helps you communicate that you need to iterate until you have no more elements. 

I think that having a class representing a recipient is good. It makes it much easier to understand what your code does that, for instance, having just a string representing the value. I'd take a step further and create the class such that it only represents a valid recipient. If you do that, you'll always be sure that your object contains valid data and you won't have to check for its validity all the time. You can do that quite easily with a builder method, that takes as input the email address and the name, validates them and either creates an instance of or throws an exception if the data is not valid. This has also the advantage of letting you detecting bad data as soon as the user enters it instead of when you need to actually use it. 

I don't think that is a good name. What about ? style doesn't look too functional. What about ? In that way you'll have a function you can use to count the number of items matching a predicate in any list, instead of having to compute first the a list of boolean values. If you use you'll need to rearrange change and . 

Do you really need to have a dependency on ? Why don't you just require it to depend on ? I'd also completely get rid of the class. What do you need it for? If you want an abstract class to represent a you can create it but you should do it in the following way: 

I think this way the problem is better decomposed and the special case is shown at the right level of abstraction. 

I see you're writing Java code but you're not using object orientation at all. I think it would be nice if you think at how you could structure in classes your program. Why are you using a field for your variable? I'd also change its name to , it will improve the readability of your code. I think you should also create some more functions. Looking at your method I immediately felt it needs at least to be split in and in , or something similar. As I said earlier, you could probably get a better result if you introduce some classes. looks a bit too complex as it mixes your game logic with dealing with user interaction. Ideally they should be separated. You should have a method that deals with reading the number from the keyboard (dealing with possible errors as you do) and another one that takes as parameter the number inserted by the user and determines whether it is the right one. Why do you use when you could use ? Both the methods work, but I think the second is closer to the result you want to achieve. You can probably also replace most of the code you use to generate the formatted representation of the string if you create some methods like that takes as parameter some integers that represents the number of spaces and puts dots between them. You asked for comments on efficiency. I think that the problem you are addressing is simple enough that any reasonable implementation will perform well. I recommend you to focus on how you structure your code and on how to make it readable and easy to maintain rather than doing some micro-optimisations that you won't ever notice. 

I think you should clarify what is for. It is true that it allows you to run some slow operation outside the main thread but it is not meant as a way to achieve parallelism. It is just a way to allow your application to continue processing without blocking on expensive operations. Have a look at this video which explains it quite clearly. You obtain multiple threads with your fire and forget execution deriving from but you should avoid using them. They should be used only in event handlers. You need a more structured approach. You need to create several instances and start them in parallel. Obviously, each task can perform async operations. This MSDN article is a good starting point on how you can do that. This is the code I came up with and that should do the trick in a cleaner way. 

Why don't you use more self-explanatory names? For instance I'd rename to . I know the symbols you used are quite standard but I think it is a good habit to give meaningful names to the variables you use. I'd also suggest you to exploit the regular structure of your code to shrink it a bit. You can do that by creating a function that asks the user for a couple of values and executes a function. 

You should work on your comments. Why do you say that the class "Returns a GeneralEmployee object"? A method returns something, a class represents it. The comment on the constructor looks quite redundant. What does it add in addition to what is already written in the code? I think you should try to write self-esplicative code and limit comments to explain the reasons why you did something in that way or something that is particularly obscure. There is no point in repeating what it is already clear from the source code. Talking about the actual code, do you really need to change the values of and ? I'd rather make that class immutable, which has a lots of advantage in terms of ease of understanding the code and in term of maintaining it. Why do you have ? Isn't equivalent and more readable? I cannot see a reason why you want to do that. Are you sure that id generation it should be responsibility of the class? I think it would be much better to have a separate class, with a method and call it from outside the constructor and then pass to the constructor of the computer identifier. In that way you will have separate classes that address different concerns. I see you defined but not . In general it is better to define both of them. Here you can find more details. 

I am on the it's disgusting side. I usually think at extension methods as something that could be useful by themselves. In your case you need to provide some external context with , which could lead to confusing code. Who should be in charge of updating it? In my opinion you should have something that has both the responsibilities of keeping track of the current max values and to select the next one. Also, I'm not sure if you're talking about this selection method, but there they divide the fitness value of an item by the sum of the fitness values of all the items, not by a maximum value. You cannot test it. The calls to and make it impossible. I'd rather make the dependencies on random number generators explicit. As a matter of style I don't like having an empty body for a loop. Given that you want to implement the selection method I linked earlier, I'd probably go for another different approach. I'm not sure yours actually implements it (but I have not looked at it for long enough to be sure it doesn't work as you would expect to). 

Note that you need to include both the start and stop dates but returns the difference between these two dates causing an off by one error (Credits to mjolka for noticing it). For instance is one day but you want to include both these dates so we should add one to the result. 

Your implementation looks good but I can spot a some flaws in it. To begin, you check that after having already dereferenced it at . Moreover I'd like more to see an in the case of a tree rather than getting the answer. I don't even get why you create a new . Why can't you use the nodes you already have in the original tree? In your implementation you try to access the left and right children but you never set them before in . 

Disclaimer I'm not a Javascript expert so I cannot guarantee that the code I wrote works flawlessly but I hope you at least got some ideas on how you could improve your code. 

Once you have it, you're ready to compress all the duplicated code as follows. You create a list of tuples. Each tuple is in the form . Yes, you can pass around functions. 

Let's see what I don't like in your code. Object initialisation The first thing I noticed is that you create new objects all the time when you probably don't really need to. Why do you need to create a new instance in main? Why do you need to create a new instance in and in ? They all look classes that you should instantiate only once in your application. I think you need to review what an object is and how you should design object oriented programs. Misplaced responsibilities Why do you have this statement ? should not both handle choice of what to do next and getting its input. Input should come from an external source. Naming How does your class represent a word? It doesn't look it does to me. Try to use names that really represent what your class does. If you cannot thing at a meaningful name you probably want to revise your design until everything has a natural and clear name (and hence has a well defined role).