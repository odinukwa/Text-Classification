You can make the object factory smart and add properties and functions depending on the parts its made of. Or you can use the class syntax or direct to prototype and have a stricter form of inheritance via prototypes. Though closer to real polymorphism it still is not class safe. No class safety Without the strict classing of languages like C++ and Java there is no real object type. At any stage I can change an object 

It does not take much effort to avoid the try catch, and in this case the cluster of problems it has set up in your code. Quick rewrite. I did not look at variable naming, function design and layout, and other issues as It was the try catch the got my attention. Thus all I did was rewrite the try catch block as a function returning transform property or zero. If you run it here as snippet, it will throw for a very different reason though. 

Vet style commands. I would like to say "Great stuff!" as the code quality is good, but unfortunately it has some problems that make using function not as straight forward as it could be. The problem is that it does not check if the formatting requested makes intuitive sense. This can badly messes up the document and make it near impossible to correct. Examples 

Use strict mode Adding the run-time directive to the first line of a function or first line of a script allows the execution environment to make some assumptions and take some shortcuts improving performance (also forces you to write better Javascript) Iteration Loops are faster than iterators 

Logic Look for self similar logic. The following function has but 3 outcomes, with only two input values. but each input is referenced at least 3 times and at worst 7 times each. Even after you have displayed a result you still test for results that you already know are not true. 

this will enforce some stricter parsing standards and help you avoid making mistakes such as "forgetting to declare". It also has the benefit of running your code quicker. Which way to iterate. There are many ways in javascript to iterate over a set of items in arrays, objects, iterable objects, and array like objects. Using built in statements , , , , , and more The one you use is about the worst for the situation. The problem with is that it will iterate over all the arr/object enumerable properties, including properties that are inherited via the object's prototype. This means you can get almost anything for each iteration, and thus need to check every item to see if it is what you intend to be handling, and if it belongs to the object or has it be inherited from another. This is just a pain, so much so I never use it. For your code you should have used 

Hope this helps, take what you want, it is real quick nut I had to do something as your code looked like it needed a restart. 

The next example shows how the tests handle other types of random showing how mean is unaffected while randomness (flatness of distribution) approaches values below 1. All gaussian like approximations. 

No way! A few displays worth no more. No two devices have the same resources, be that due to hardware limits or current process requirements. You simply can not rely on client devices to give you more than a few screens worth of fast access pixel data. Even a top end machine may have resources tied up in other applications/processes and not be able to handle you page's need for fast random access pixels Consider the needs. A million images at medium resolution (2MegPix) will require 1,000,000(Image count) * 2,000,000(pixel count) * 4(pixel channels) = 8e12 bytes (8Tb of RAM) Nobody is going to download that much information, nor are any consumer level devices able to handle random access to such a large data store in any timely fashion. The solution This type of application need to be coupled to a server. The server holds all the images in a format that allows resolution independent access to the pixels (eg variation of wavelet image compression) the client then requests a view with details about the zoom and the server delivers the images at the resolution required. At no time does the client need to store more than the display size worth of pixels. Some examples of this approch are Google Earth / Google Maps and Microsoft's TerraServer 

A Rewrite An example as a rewrite, not how I would write it. I have change the interface a little. Rather than create a you init an existing instance via and it returns the table. You add events via . Events are decoupled from the code so that external errors do not interfere with your state management. They will also always fire in the correct order. 

The first progress bar does not work, you need to set its style correctly before you display. Dont set the class to 100% width in the style as that is happening when the page loads and can not be seen. Then when you want to start the progress add the class to the the first child of the progress bar. This will stop the first bar from completing before it is seen. The rewrite 

You create a new function each iteration. This means there is also a new closure created for each iteration that takes heap space, an unneeded overhead, which can be avoided by pre-defining the function (see suggested improvements below). No zero timeout V8 (and other browsers) throttle the timeout, it is never 0ms. What it is for V8 on the version of node you are using I don't know as the throttling value has gone through changes, and may well do again. So if you iterate 100 times and the timeout minimum is 1ms the timeout will add 100ms to the total time to complete the iteration. The ratio of the iteration time to the timeout time needs to be controlled. If the function takes 1ms and the timeout adds 1ms you double the time to do the function. If however the function takes 100ms to do a single iteration then the timeout adds only 1% to the time to complete. As you suggest doing the await every so many iterations will improve the ratio. But without knowing the time per iteration you can not be sure of a reasonable count. A suggested improvement. The can be improved using a object to handle the promises based on time rather than iteration count. Inside the loop you use as follows 

You had repeated several times in code and called many times. This is a constant so should be defined at creation. Maybe 

With the holidays stored as start of day in ms it is then trivial to check if a time is on a holiday 

Which does what you intended without the risk of getting unknown properties. Dont burn cycles Good code is efficient code, with every instruction the computer executes in your code, you burn power, sucked from batteries, the grid, You chew the clients time and you extract a little more from the environment we share as a comunity. Yes your code is trivial in the scheme of things, immeasurable, but combined millions of programmes, or with fortune on your side an app you write may end up on billions of devices, and particular parts of your code may execute trillions of times a minute. Then it matters. Always (I digress, no rant... :P) code for efficiency, even the little bits combined matter. Your code could have exited early as the problem states that there is only one set of odd numbers in the array. So as soon as you find the odd set, the job is over and you should exit. On average you will do a quarter as much processing overall. On average you could do up to a quarter less processing overall. Use appropriate Objects. You are using as a map, for each unique key (number) you create an entry and use the associated value to count the number of keys. Though technically not wrong javascript provides a object that is better suited (see rewrite) The rewrite If the array of numbers was known to be sorted or numbers were grouped then a different solution could be used that is more efficient, But as there is no mention of the array being sorted or numbers grouped apart from the sample data the best is to play safe and assume unsorted data. Some may opt to sort the array to take advantage of the better solution, but the sort is expensive and would offset any benefits the more efficient method would give. UPDATE I miss read the question and thought that counts of one were to be excluded. I have changed the code via commenting out the incorrect behaviour. 

This avoids creating endless copies of the of the links array, via the filter and map methods. It also solves the problem of paths that fail. Now to fix the cyclic reference problem To do this you need to track the traveled path to each destination. I have created a stack that tracks the current path links "traveled". When end points are found the current links are popped of the traveled stack so that the links are free to be use for another path to the destination. The code is in the example below. Well I think it works, it stops the crash, whether it finds all solutions may need some very in depth research which is beyond the scope of this answer. UPDATED code snippet I wanted to be sure that the function worked so did some more testing, and while I was doing it I realized that a further improvement could be made. The problem is that each step requires the entire array of links to be iterated, checking if each link has the correct origin. That can be offloaded to the creation of the array. Using a indexed by allows the main loop to only loop over the links with the correct origin ( returns a pre-existing array of with origin ). This is a significant performance increase.