Now i imagine the above doesn't really give much detail but it outlines the vaguest contract between whatever visual representation you choose and the source of the data. In this manner if either change the other is perfectly fine. As for an example implementation of the above: 

Although that doesn't really solve your problem. I usually like to answer a persons question first in case they choose not to do a large refactor but I would take a closer look at what you are trying to do. You have a number of larger design problems: 

Then in your Complete function you could throw an exception if is false. You would then have access to your composite different parameters in your complete method while keeping your abstraction, albeit with the caveat that your initialization is now a two stage process, that requires an initialization call; *ps, no I do not propose that to be an actual argument name! 

I recommend an approach where top level buttons, sub-buttons and content are all grouped separately. This way, these grouping wrappers can be used to scope selectors and grab all the top-level buttons into one variable b) all sub-buttons into one variable and c) all content into one variable. These grouping variables can be used to toggle off visibility for all items in that group and then the attributes can be used to toggle on specific items. Also, I've changed it so the content (lines of text) have unique selectors and the on the sub-buttons has complete selectors for their target content. This way, each sub-button doesn't have to know anything about the top-level button that toggled it. To keep track of when something is supposed to be turned off and nothing is supposed to be turned on (ie if you click the "Toggle a" button twice in a row), there are state variables for the last chosen top button and last chosen sub-button. Since this is not in a form, you might want to stick with tags. Generally, where possible, it's best to save your DOM queries. Hope this helps. 

Now, this is only one example of course, you could do a lot of alternate skill implementations. The final step would be i suppose to create PoisonModifier/ItchyLeftEarModifier etc and then apply them with some effect like +5% -20% etc, or whatever. This separation also means that while most things will be using the Skill.Value which in the case of a modified skill will be the modified version some special something could check if the skill is a Modified skill, if so cast it and use the base stat instead! (one final note) I was a bit wasteful with the Value aggregation in ModifiedSkillImpl, tbh I would probably have a private variable for modified Skill and only recalculate if the modifiers had changed since last call but you know, this is just a quick POC. 

Now I can use the appropriate reporter with no fear of effecting anything else. also, if I have to suddenly change something for ALL the reports all I have to do is swap out the settings. 

2: Slicing the string is fine. If there is more to the question, then please elaborate. 3: Use of the variable to store the match is not too clever. I recommend against assignment inside the condition, though, it's just something that can be error prone, in general. Down the road you may make an edit and forget to have only one , or something like that. It's usually considered against best-practices, but is not invalid or anything. 4: As I'm not a compiler guy, take this for what it's worth (there is probably obvious conventional wisdom that I don't know about). Using a single token type for these four operations seems fine to me. They all have similar characteristics. But, it will likely be an issue if you broaden this usage to operators that have different characteristics, like the unary (e.g. ). Having said that, you may end up keeping these four operators under one type. You may end up wanting to group on precedence, though. 5: Not a question. One thing I want to note, the and methods are organized in a way that is a little strange, to me. You consume a token (move forward), then when you are getting the next token after that, check the type of the previous token. I like to have separate methods for the various tokens I have. For instance, you might have and . Each of these can attempt to consume the correct type of token, and if it fails return . The method that called them can decide if that is an error or if another type of token should be attempted, like . As a side note, a scanner I wrote for a DSL: JavaScript and Python. It uses a mix of regular expressions and character comparisons for consuming content. The scanner has a property and a property, and any time a token is created the content spans from to . Then, is moved forward to . 

which could allow you to swap the application ordering on the fly. resolving an issue brought up by someone else. also allowing a sort of tree nesting with a RandomModifier housing a composite Modifier which has a .... and so forth. 

So you would have a chain of possible solutions, each one if checks to see if the type is one it can handle, ...then handle it. that way you have support of unlimited quest types, default quest handlers and you never have to go and update a bunch of case statements. 

May seem superfluous but when it comes to debugging it makes things alot easier than finding that one place you wrote "Memu1" 

onto the ObjectPool class: So, similar story with the private fields and so forth. aside form that, I have always hated the line: 

not make more sense? could the method not even be a method on a interface of some kind defining the rules for deciding relevancy? would that not separate your concerns, make testing easier and over all make it clearer what each piece of your code is doing? 

I recommend using bluebird for promises; it has a ton of nice features that really improve quality of life and seems to be faster than the alternatives by quite a large margin. (Note: I only briefly looked over the JSPerf, but it seems to be done well enough.) Using bluebird (and a few other adjustments), the promise version of the code can be simplifed to: 

I'm not a compiler guy, but I'll offer some feedback, anyway. Hope it helps. Nice work. Regular expressions are a powerful tool, but they can become difficult to maintain and sometimes to get right. You used them, they work, seems fine. I'd suggest making it a point to always use simple regular expressions (which you did). If you need more complex matching, using multiple simple regular expressions in a sequence or loop or in combination with character / string comparisons seems to work pretty well. To answer your questions: 1: Using integers does make error messages harder to read, so switching to strings for token types is a good idea, IMO. But, instead of adding properties onto the class I'd suggest doing something like the following: 

Darn, at first glance this looked like a simple solution but you ruled out constructor injection. The only suggestion I can come up with is to have a class that inherits from the same interface, DOES have the constructor injection is built up and added to the main object as a composite object fed in through a set only Property, maybe some kind of flagged function call like 

and with all that in place you should be able to throw a number of custom exceptions and wrap the whole thing in one catch block that will log the associated message and return the associated enum. 

So now if you decide to completely change how Foo's are delivered to the UI, replace the presenter but all views still work, want to make a different representation of the same data? make a new view object, finally your presenter could also contain a datamodel which could be swapped out between storage methods, different database's or config files or we service or whatever. 

The JS files should go at the end of the . Usually, you want all JS in external files. In practice, I find the only exception to be when the server is injecting data, for instance, if data about the current user needs to be available to JS it would go directly in the page and not in an external file. 

Nice work. You can make a lot of headway by using attributes. These are attributes you can add to any element to store whatever you want in them. They will be available on the property of the HTMLElement, and will always have string values. For instance, given the following HTMLELment: 

Generally, attaching event listeners in markup should be avoided. A couple reasons off the top of my head: 

Main thing is the first issue, the listener has to be in the global scope. I recommend either or the jQuery to listen for the event on the elements. 

Hmmm, Well I think the way you are going about it, while functionally correct won't scale well. Ideally you want to try more of an aggregation. Off the top of my head I would approach this like: 

Yeah I know you could effectively use the AAttribute for this one too again, the number comes fron a wrapped sub-attribute and not an actual base object so this is a tad cleaner. So now you have an attribute decorator, you can take a really complex , modified attribute which, through whatever combination may end up returning you something like -999 and break your game, so now you take that modifable attribute, wrap it in a Clamped decorator and all the values returned from it are safely clamped to a pre-defined acceptable range. Next, as for: 

You know, I love fluent interfaces. though I feel many misconstrue their purpose. some examples I see try to make their code a 'natural language'. but That is not the point, the point is to decrease complexity and aid understanding, often most easily done via Natural language. I can't help but feel the above has crossed the threshold into requiring more time to learn than a standard composition. If i was dead set on fluent I would sacrifice a small amount of natural sentence structure for brevity: 

Four inputs is not that many, so, doesn't really matter. But, if it grows or if you might have to change it often, probably better to loop through the inputs as I have in the jsfiddle. 

You'll notice I'm using classes of the form like , that's because it's nice to separate CSS class names that are used purely for JS from those used for styling (more info). The full JavaScript: 

With that, you can generalize what you're doing with your handlers. On each case, you can store the case number (1, 2, 3, 4) in a attribute, and store the following case in another attribute . 

The function should be called to initialize the values and it can be used as the event listener for the select inputs. 

The casts to a boolean. It's not required since an empty string is falsy, but it clarifies the intent. 

Personally I am less inclined towards this, more overhead in terms of building a fluent interface for your equation aggregation and a bit harder for newer people to grasp using but then again it reads better than any other solution at first glance regardless of ability. So if you were to package this as a modifier API for yourself it might be the way to go (but for api additions I tend to follow the rule of 3 uses so may be premature to do so); but as a problem solve for a particular project I would choose the more straightforward above method. 

in your view means if you want to swap out logic/models you dont have to change references tied directly to the model instance. 

whereby the Modify Accessor is a composite instance of the class, it adds instances to an internal enumeration and orders by weight. the Skill classes calls its composite Modify.Calculate(_baseValue) or something and still returns the combined result and all is safely encapsulated.