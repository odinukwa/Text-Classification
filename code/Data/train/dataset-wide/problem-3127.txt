Magic numbers You should replace all those , , etc with constants and give them proper names. I have no idea what they mean. You in few week will wonder too why such numbers. 

If you need that many replacements for a simple search then I think either the data or the filter is broken. I guess all those delimiters (?) have some meaning, usually they have and they look like they have, so try to build the filter according to the rules instead of changing the data to match the invalid filter. 

I don't entirely agree with the accepted answer. That part that bothers me is the suggesion about using this overload here: 

Although here it's a . This is very confusing and inconsistant. Either it's a command, or a message or something else. Currently it seems to be a god-type for every purpose. I also don't understand what an is but I guess it just adds a to . A better design would be to create an interface like that types that support an would additionaly implement. 

Putting everything inside the class was just too much. I decided it needs a slimmig diet. There were so many changes required to turn it into a testable, maintainable and extendable solution that it's hard to name them all. The most important ones are: 

Returning this from the is of no use. No default constructor -> exception. All other workarounds do only harm. 

Other improvements Magic numbers You should create an enum for the and cast the given by the user to it. Example: 

Which leads to one issue in your code namely the indexer repeats the insertion. You should use the insert method here: 

You've mixed the naming conventions a little bit. We add the suffix to methods that are awaitable. This one isn't. You could however easily fix it. 

The wrapper is very simple but I'd still change a few things to make it prettier, more reliable and more useful so these are my suggestions. 

because as a parameter name is never cleaner and abbreviating message to is also not a good style. In fact in C# we rarely use abbreviations. 

This is what remains from your original class. I swithched the order of parameters form and name to and because I find this order more natural. I also suggest implementing the interface by redirecting it to a custom implementation of becuase it not only better encapsulates the logic but also has a nicer method taking two parameters for and rather then working with the invisible and . Usage examples: 

Then the comes in play. It groups all tokens into fields and creates s. It also parses names of months and days of week. This for names and ordinal extensions I use three dictionaries. 

I've been improving some of my old sequence generators that worked with generics and lambdas in order to support binary operators for the specified : 

This is my first attempt at using T4 templates and I thought I generate the with it by getting the tables and the columns from the database to automatically create all targets. 

If the query does what you need and there aren't any performance problems then the only thing that can be improved is the formatting and naming. You know that you can split the select into multiple lines? You also don't need the becasue there is no extension attached to it like etc. One name is inconsitent with the others: should be . Will you know that is the user's name and not the product's name? The properties of the anonymous object should be PascalCase like all other property names. 

It's a one big feature that is composed of many other features. I've added the so that we can get them all and do something later with each of them. One of my favourite patterns ;-) 

If you don't have to, you shouldn't use multidimensional arrays. Linq cannot work with them. It's better to use jagged arrays 

I know the names are ugly but I don't know what the numbers mean, this is why we dislike them. They have no meaning. Next, the logic can be extracted as an easier to maintain dictionary. Now that all values are enums we can easily build such a dictionary that I find by far is better then a nested in a loop. Besides, you can reuse the dictionary to display the options in other places (if you make it a filed or a property of some class). 

You don't need any lists or multiple observable-collections. Just sort the inventory and pass the result to the final observable-collection which will become your . 

Alternatively you can make the property and return the value here instead of passing it via the constructor: 

If you happen to write the same code more then once it usually means something needs to be encapsulated. As far as loops are concerned you have two choices: 

Example To use the logger I first need to create a factory. Optionally I can specify automatic-properties. 

I need to apply some css styles to an . The generated HTML is only for emails so all styles are inline styles and the selectors are very simple, just element names, ids or class names can be used. I'm not sure whether a is the right tool to apply styles to elements but it seemed to fit for the task. This is the : 

To me it looks like this should return the hashcode of the keys and not of the dictionary. The base class is basically doing this (or will ;-)) so the behaviour isn't consistent between them. 

You write in the comment modifiter for every effect type so why not give the variable such a name: ? I nowhere see the being used. This could be removed. 

Look at these three methods. What do you see? They are virtually identical. In fact you don't need them at all because all types that you convert to have the same three properties. All you need is just this interface that all three classes implement. Alternatively you can make the an abstract class and the base class for the other types. 

This can be use just like a so we can put it inside and rewrite the method for enumerating paths like this: 

To reduce the repetitions each angle type could have helper methods like this one to implement each conversion only once. Mainly the operators would use them. 

It's a very bad idea to call the controller a and inform the user that he's going to be working with well, a file system. He should not know how you are storing the data he uploads. You should not reveal this implementation. A Web-API is a resource and should be seen by the client like one (whereever possible), this means your controller should be called . Whether you store the data in a database, a file system directly or in a cloud it's none of the user's business. Knowing the underlying technology he might try to exploit it. 

But these checks are another boilerplate code that I'd rather generate then write myself each time. So I experimented with the and wrote this helper. It creates a new type that implements properties of the specified interface and adds null checks if a property is decoreated with the (this is used by ReSharper). Derived types are cached. 

You can assign it and return it in a single line. StudySession vs Session classes I woudn't create another session object. I think you should just reuse the Seesion you get from the database. It already has everything you need. You are just copying the values. Your code would become much simpler without this mappings. Chapter class To loosen the coupling you would need to make the methods of this classes non-static and pass to the constructor an instance of the or its interface and maybe a but I don't entirely understand what it is good for. Actually you need a group id for the query. So maybe pass it as a parameter. 

DoWorkAsync is not a very expressive name. You should use a name that is more specific about what the method is doing. 

Dependency Inversion Priciple The smell is that your code violates the Dependency Inversion Priciple which reads 

I wonder why are you getting the object like this? To redraw something you should actually handle the event or override the method where you get a ready to use object from the system. And of course like @Cody Gray said, you need to dispose a graphics object acquired this way. 

This inheritance isn't necessary as the derived classes do not add any new functionality. It would be ok to have just the . With the inheritance here there is a redundancy because for one the already stands for and secondly the type of the class stands the same too. Lastly base classes are usually because they are not ready to be instantiated yet. Ideally the could be implemented like this: 

This conditios is too magical. You should introduce a helper variable, and/or use a explaining the , and/or use a for the index explaining its purpose. 

To my taste it doesn't look nice. Instead I suggest this where I also use instead of just which I find is easier to understand. 

are so bad that I wish you never have to debug such code. This is the worst you can write. You loose all the information about what went wrong. The entire stack trace, line numbers, method names and in the first case all inner exceptions. If you don't handle an execption don't do anything. Let it bubble and let the user take care of it. 

I cannot complain about your code because it looks ok to me (at first glance) so I just share an idea. You initialize all properties for an object at once. I think it many scearios you use only a few of them so making the initialization process lazy should speed it up. A good start would be the . This means you initialize the getter/setter caches only if a property is accessed and even then, I would init only one cache at a time. If you use a getter, then init only the getter and so on. The API wouldn't change, just the implemention of the constructor and and . 

Don't return a complete list of words if this isn't necessary. Use an iterator instead - by using LINQ or the . What if you wanted just the first three words? You would need to calculate them all anyway. With deferred execution you can stop whereever you want to. Example You can now easily find all pyramid words with linq: 

To me the method is too big. I'd split it in three parts. The first part would be the reflection stuff where you read and sort the properties - this could be a new class like or maybe an extension. The second part (maybe a method) would be the first that I cannot figure out what it does. The third part (maybe a method too) would be the second that does something but I'm not sure what. Putting them in methods would give them a meaning without you having to explain each time what they are good for. 

That's all. The other convenience methods using expressions for property names are now provided by the 

I never really liked them but now that I'm experimenting with expression trees I thought I rewrite these sequences too to get rid of the lambda parameter. This is not such a huge change but I think they are much easier to use now without having to specify the binary operation that could have been changed to something else even if an addition was expected. There was no way of controlling it. Here the operations are burn into each class. I've added an interface and removed the method. Concrete sequences must now only implement .