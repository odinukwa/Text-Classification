Perhaps more robust, though, is just to add a separate if check and do the creation/opening separately: 

How I learned to stop worrying and love the var When types are obvious, the common convention is to use . var all the things! Return the simplest data types possible returns a , when it should probably be returning . If you need add/remove functionality, you can use , and if you really need list functions, you can use . Take advantage of ADO.NET interfaces Rather than directly using the command and reader object constructors, there are methods you can use to build them. When building a command object, you can use your connection object with the IDbConnection.CreateCommand method. Final Version Taking the above suggestions into account, I came up with the following for your two DAL methods: 

In addition to the other two answers, you may want to use the DataRow.IsNull method within BCdotNET's method: 

It appears you are using to insert query parameters. The problem with this is that it opens up your API to SQL injection attacks. For example, if someone were to somehow pass the following for userId: 

Without knowing your domain, I just threw in placeholders for illustration purposes. Data Binding If your list of providers is fixed, you can bind any to the grid. However, in the more likely case you want to allow adding new providers, I suggest instantiating and binding to a . I would then add a BindingSource to your form which points to the type, then set the property of the grid to the binding source, and tweak your columns to look how you like. In your code-behind, you will set the property on this BindingSource to your collection of providers. The field required a little extra care. In this case, you want to set up the column as a . Once you do that, you want to supply the possible list of values for to the column so the drop-down works as expected. This can be done easily with : 

This variant consistently takes around 0.8 seconds. Perhaps unsurprisingly, the real killer was adding items to the grid row-by-row. It has the added benefit of isolating your file reading, parsing, and grid population operations into separate sections of code which could be split into methods/objects. Of course, rather than using a System.Data.DataTable, I would prefer to use a well-structured object. The DataTable was merely used to build a quick example. 

A similar refactor can be done with the two decrypt overloads. I will leave that step as an exercise for the reader. Symmetric Encryption With what's left, I cannot help but notice that this appears to be a symmetric encryption algorithm. As a result, the encrypt and decrypt steps are nearly identical to one another: 

...and so on. It is not necessarily cleaner, but it is a little more correct for the object, and it uses fewer dictionary look-ups. 

(note: The MSDN page on Regular Expression Language is always a good reference to check on when coming up with regex patterns in .NET code.) String Formatting Rather than concatenating the strings together, I would use a format string: 

Building queries with is dangerous, as it leaves you open to SQL Injection attacks. This particular case is using a value from the app settings, so perhaps it's not likely in this case, but it's a good idea to get into the habit of using parameterized queries anyways. For MySql, you inject @-delimeted names: var cmdString = string.Format("SELECT em_surname, em_name, em_netname, em_init, em_dept, em_title FROM employs WHERE em_pplid = @userID"); Then, you add it to your command with the following: 

encapsulation Most of the members in are currently public. Many do not need to be. The general interaction with the trie is going to be creating it, adding words to it (currently part of the creation step), and fetching data from it. With those use cases in mind, none of the properties need to be public, and in fact, none of them need to be properties. Instead, I would change them to private fields. By convention, you should then rename them to _camelCase (e.g., ). Also, since a caller is only going to be interested in the root, the third constructor should be private. Additionally, the method is dangerous to call on the root, but the above use cases dictate that callers only care about dealing with the root. Since all the children of happen to also be objects, you can make it private. This also allows you to remove the root flag altogether, since it was only there to prevent invalid access of , and callers can no longer directly access children. for great justice None of the properties (now fields) are modified outside a constructor, and given the behavior of , none of them should change. As such, it is best to make them explicitly read-only: 

Of course, you would have to account for roll-over for days and months in any final piece of code, but it illustrates how you could pull the date parts back out. 

(note: I switch back and forth between C# and F# , so I use more often than most - feel free to keep the explicit type declarations if you really want) 

Given the update... Since you have a stated requirement of showing properties which do not exist in the collection anyways, then why bother adding entries for properties you want to show at all? I would only build a collection of the ignored properties, and then check if the collection contains the property during filtering. As such, that check instead turns into a (if still using an IDictionary) or (for any other collection type). I would also suggest using a simpler collection like or a string array, because the set of ignored properties seems to be really small (only one in your example). The performance of dictionary lookup versus list traversal will be insignificant at that size, and it seems more natural to have a collection of names than name/(unused) pairs. 

With those changes, we can refactor our seeded encrypt and decrypt methods to call the above method, changing the class as follows: 

Use TraceSource instead. It is the suggested replacement for the Trace class. I would not use a compiler directive to switch the logging on and off. Omit the .Listeners.Add line (which also exists for TraceSource) entirely. Utilize app.config files to control whether or not the logging occurs and how it is output. 

You can use a format string to ensure that there are at least 2 digits in the format without having to check first. The format: ensures there are at least 2 digits, but allows for more. It will prefix 0 to any single-digit input. also has an overload which takes in an , so my personal preference is just to collapse that into the call. It also happens to line up nicely :) With that, you can create a method with appropriate parameters which can handle both cases: 

If your mocking framework is similar to the one I use, you probably need to stub ServerNameOrIP on your injected IServiceControllerWrapper mock. It is not uncommon for mocked objects to return default(T) for anything not yet stubbed. As an aside, I would suggest modifying your IServiceControllerWrapper to eliminate your Controller property. The purpose of the wrapper is only to expose those methods/properties that your code requires from ServiceController while hiding the fact that you are using a ServiceController object to execute them. If someone else were to code against your wrapper and use this property, they have effectively re-coupled the code to ServiceController. 

Move all the OpenFileDialog setup to the designer file. This will make it a field rather than local variable, preventing unnecessary object creation when a user clicks Add multiple times. Additionally, it will wire-up the proper Dispose call for you. Take the code for opening the files and put it into a separate method. Split off your worker event handlers into class methods rather than anonymous methods, better separating out method responsibilities. 

As a result, you could eliminate the Calculate button. The end result is that your code-behind for the form looks something more like the following (minus the click handler if you decided to go with auto-updating ): 

Strictly speaking, it depends on what InitProcess does. It may very well work OK as long as it never touches resources in the ProcessThread class which get disposed. However, even if it works this time, it is a bad idea. Passing a method group from a class which gets disposed before the thread even starts is asking for trouble. A better option would be to create a method inside your ServiceTest class that the thread executes. Inside that thread, you can instantiate a ProcessThread object, call InitProcess, and ensure that Dispose is only called once InitProcess has completed: 

Alternatively, if you have only a relatively small number of valid values, you can use tuples and LINQ to perform the comparison. You would initialize your collection of tuples with the valid values as follows: 

As a separate note, I would strongly suggest separating your database and UI logic. The ideal would be to have your view code in one class, database code in another class, and a data object you can both pass to the database class and data bind within your view: 

There is a lot here to go over: Single Responsibility Principle There are too many things going on in this method. It performs multiple database queries, and it parses/traverses XML. This should be split out into several, narrowly-focused methods. Database I would suggest using an ORM of some sort for your database access. There are plenty of solutions out there, some more well-known examples being nHibernate and Microsoft's own Entity Framework. My team has also played around with F# Type Providers. For the sake of my answer, though, I will assume making a change like that is probably outside the scope of what you are doing. With that in mind, I would suggest using an IDataReader rather than a SqlDataAdapter, since you appear to know the exact structure of the return data. Reading with IDataReader will involve less overhead, and more importantly, it will be easier to read. XML Building The older System.Xml objects still have their uses from time to time, but I have found the System.Xml.Linq objects to be far cleaner and easier to work with for most tasks. A quick example: 

Though, to be honest, this feels like you would save a lot of work having a data object for a user that can be serialized/deserialized via a DataContractSerializer rather than hand-building and parsing. 

I only implemented an overload for string values, but you can decide what you want to support and what the method name should be. Then in the code issuing the command, you can simplify your lines to something like the following: 

Sadly, creating parameters is particularly painful using just IDbCommand, so I continued using the SqlParameterCollection members. Additional questions/considerations: 

The most canonical way of accomplishing what you want is to use the testing framework's functionality for writing data-driven tests, rather than writing a common helper method and then a number of separate tests which pass arguments into it. Different frameworks do this differently, so I will focus on MSTest first, as that is the framework you use. In MSTest, there is a DataSource attribute you can supply, which defines how the framework can locate your test data. Additionally, you supply a TestContext property of type TestContext. When the tests execute, TestContext will be populated with the data for a single test case, and you can access it by using named indexing into the property. (Note: I haven't done MSTest in some time, so feel free chime in if there's a better way nowadays) Example: (Embedded resource: foo.xml) 

The underlying problem is that vio.EtchVects is , and LINQ functions still return . Your functions are expecting scalar values. For simplicity, I will build from @Bryan Watts' answer, starting only with the select statement. If you want only the EtchVectors as a flat list, you can do the following: 

This is especially true if the boolean expression is long. The safest formatting is to put the expression on the next line and enclose it in braces, even if it is a single line: 

Test/implement first. Implement the code you need (which will likely go into ) in your method now, imeplement/test next, and refactor it to use the method later. 

I would combine some of the suggestions already given and make the class stateless. Storing the object and path in fields does not really buy you anything, and it ensures that you have to construct a new object whenever you want to serialize/deserialize something else. In addition, I would probably change the name. PersistData is not a good class name (classes should be nouns). I am naming impaired, though, so I leave that as an exercise for the OP :) 

Finally, as it turns out, there is a function called Char.GetNumericValue(char) which retrieves the numeric value of a character for you, so you could use the following alternative: 

First, I would change the body of the function to use LINQ. Then, since the function is only used in one place, I would in-line it: 

The latter allows you to implement and define tests for both methods in isolation from one another, only refactoring when you have a full set of tests. With these tests, you can safely validate whether refactoring can safely switch to using or not. The former way will save you some time, and as long as you don't skip any tests for , you will probably be OK. The downside is that you have to context-switch to . 

Reduce Duplication There appears to be some significant code duplication between the encrypt and decrypt methods. Method Overloads The first and most obvious spots we can refactor are the overloads for your decrypt and encrypt functions: 

Since it looks like you are just trying to find the intersection of a known set of keys and those present in the table/column, you could just use LINQ's method. To facilitate this, I would probably pull the list of keys out to a "constant" field. Additionally, unless necessary to return a , as Heslacher suggests, I would return . 

The class unfortunately violates the Single Responsibility Principle because it has to deal with logging as well as expiring access. You could use the Decorator Pattern here and split the authorization and logging into separate classes as follows: 

If you are particularly interested in doing substring look-ups, you could look into the Trie data structure. You will be stuck writing your own, however, as there is no implementation I know of in the BCL. Alternatively, if you just want to put something together quick, you could just use a normal, single-level-deep dictionary keyed by file name. If you build your dictionary for existing MP3s first using an actual System.Collections.Hashtable or (preferably) System.Collections.Generic.Dictionary<TKey,TValue>, the key lookups will be constant-time. The only loops you will need are the initial loop to build the correct file path dictionary, then the loops over .m3u files with sub-loops over their referenced files. Retrieving the correct mp3 reference for each file in a m3u is just or . The lookups themselves are not loops - rather, they generate hash codes for the keys which ultimately translate to array indexes in the underlying data structure.