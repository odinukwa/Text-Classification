is clearer. If you want to remove the , you're going to have to "return" a lock as well, since the read is only valid while the lock is held. This might be a good idea, but it's really up to you if the cost is worth it. 

(note , not ). I removed the term because many sequence types can be palindromic, like . should , not , its values. I would change the documentation to specify the rules the output satisfy. 

The here is actually a global variable. This is one of Python's less obvious gotcha's. Instead, assign it in the constructor. I would be very wary of initializing data to wrong-but-valid-looking data. If possible, don't initialize early. If not, make it explicit - normally this means to use . 

would actually be valid (although outside of the spirit of the question) even on Python 2, where it returns a list. Your use of the inner function is avoidable by using a default variable: 

Your indentation is completely out of order. Use consistent indentation, keep your comments indented correctly and use a consistent bracing style. Don't just arbitrarily indent things either. Don't use double semicolons. Put spaces after comment markers. Don't have trailing spaces. Space brackets consistently. I loaded Eclipse just to format this. 

and only use this three times. It's not worth it; typing three times isn't going to make your code unduly long. You should add more spacing in accordance to PEP 8, and cap line lengths to something less than what you currently have (100 characters should be enough). can just be 

In this case just remove the first comment, because is already known to mean deduplicate. And remove the second since it's implied by the fact you've written the code. 

This actually removes an instruction from the total, but it seems to be pretty much random that before the compiler was going and now it does . Nonetheless, the faster early-out is a good thing, and you should see a small win proportional to the frequency of large integers in the program. The rest of the logic is a little unfortunate, and as you said it's not easy to simplify. However, you can always use a lookup table! 

Though this error is gone in Python 3, that doesn't leave me feeling good about it. I'd finish off with 

If you care about optimization, use maths to simplify the problem before the search. Starting from the bottom. 

You should consider making the first argument - it's a -like argument so normally should be at the start. Finally, consider replacing the edges with tuples, since their length is always . 

doesn't tell anything obvious yet, but keep it in mind. tells us the value to that point is divisible by 3. Divisibility by 3 can be checked by saying the sum of its digits is congruent to 0 modulo 3. 

seems to be unneeded, since is thread-safe and iterating while appending is safe. might be faster, but it might be slower. It depends on where you're bottlenecked. In particular, data transfer is slower with multiple processes. The slow aspect here is primarily repeated conversions to objects. This can be avoided by only doing the translation once, which is easiest in the producer thread: 

This is normally frowned upon (this in particular should be written ) and use where not needed is a very dangerous sight to the untrained Pythonista. Use with care. From the the function: 

would be better as a property. I would change to be the result from after translating with . I would do a single read from in and use 's parameter to read parts. This emphasised how repetitive the unpacking is, so I'd make a local function to reduce the repetition: 

You can remove when doing this. Put the code inside a function; it's not only faster by avoiding global variables, but it's nicer too. PyPy makes this much faster, brining it from about 50 seconds with CPython to 1.5 with PyPy for input . You formatting is really inconsistent. Stick to PEP 8. Invest in better names, like instead of . Some of your documentation is bad, like 

This makes the code basically instantaneous, so if optimizations were pointless to apply before they're most certainly pointless to apply now. 

Further, the lines should be split up from their current squished self: I would also use words to describe newlines. Transposing can be done with , giving 

It's worth noting that the whole thing is confusing - why is it ? The lack of documentation on why is special-cased is confusing too. I have a feeling at least some of these are bugs in the program. 

This takes 3.3 seconds for \$n = 10^9\$ for me, where the old version took 11.2. All of the changes are below: 

You could do with learning some of the more powerful tools in Python, such as . Tracing control flow, instead of 

Use instead of as a "missing value" sentinel; that's what it's for, after all. Looking further, I got confused as to why you delayed it anyway; never seems to be big so it makes sense just to do it eagerly. This pointed out what seems to be a bug: is too few bytes when represents a value of > 1 bytes. This kind of error and repetition suggests that you should really have a class to encapsulate reading data from the file. would work great for that. You also don't check for insufficient read sizes, but I'll let that be for now. Being non-lazy, you could make another immutable : 

which always allocates a new , one can index with a borrowed . Sadly this isn't supported by the API right now, but you can hack around it: 

Well, let's try and write it a little nicer, eh? First, a real argument parser is a good idea. I like Docopt, because it's so simple that it's normally easier than a hacky manual parse: 

No concerns; this is a good thing to do from a documentation perspective and it's even better with IDE support. I would be hesitant with ; the standard name is the shortened , so it would be. Even so, it seems strange to put all the ABCs in one place; why not put them with the classes that implement them? In , you do 

which will deduplicate for you. Note that this isn't likely to be faster because hashing is and in the common case. If you take this into account and extract subgroup generation into a separate function, you end up with: 

is largely OK. should have its function first. Its init function doesn't initialize all of its values; you have to then call to get that running. This suggests you have a bad separation of concerns; should be split into two classes where one handles the overall statistics and another handles the game itself. I would go with and . With this, should be split into three parts; and and which are part of . The global function can be merged into the local method and the and functions should become methods. would be called from the code that handles controlling the game (currently ) as neither class has any business dealing with it. and should return whether the game has ended ignoring whether the user wants to replay. and and aren't used, so remove them. would be 

Note that I would be wary of casting to enums where this might result in an "invalid" enum, but at least it is well-defined behaviour. 

The first thing I note is that your naming is too terse. What is ? ? ? ? ? ? ? ? I have no idea. I think might stand for . Secondly, your one comment exists seemingly solely to confuse: 

Numpy arrays are faster than lists for some things and slower for others. In particular, arrays tend to be slower when indexing single items (eg. ). They tend to be faster on operations that affect the whole array, such as , which searches the whole array. Before removing and , most of the time was spent in those two operations. This meant arrays were significantly faster. After removing them, all operations on the array were just indexes. This means that lists became faster. So lists are only faster after making certain changes to the code. 

If it doesn't give you new or clarifying information, it shouldn't be a comment. This comment should be a docstring: 

The lack of solutions for restricts , but we can keep that in mind for later. tells us not all too much extra, but keep it in mind. tells us again that we have a divisibility constraint. 

In you are making a new class with its own source code each time. You can use a backport of to cache the s: 

Thus, if we have fibonacci number \$F_{3n+2}\$, we know $$ \sum_{i=1}^{3n} F_i = F_{3n+2} - 1 $$ and thus $$ \sum_{i=1}^n F_{3i} = \frac{F_{3n+2} - 1}{2} $$ Therefore we can go back to the non-ing and do 

We are going to place onto next, for all values that will fit. Fill in the unknowns on the base with the minimal values that fit, pushing larger numbers to the edges. In this case, we cannot add , , or , so we fill in a . Treat the as a for now: 

Note that your formatting is not standardized; some start with an uppercase and other identical errors have the word-order switched. This should be fixed: 

but you should be using anyway. Further, you should be reading from its output, not directing through a file: 

You have made a new class, . You shouldn't create new errors where you old ones suffice, though; just use . Even if you do want a new class, it should be a subclass of . The only time you use you do: 

This is all well and good, but we should really be doing better. Let's go to . Because of the abstraction gained, we only really need to change 

This is a "blind" review in that I'm not testing my changes or running your code. Don't use unless actually version-agnostic; use or . This here 

But this still isn't great as it takes \$\mathcal{O}(n^2)\$ time - we're iterating over every value, and for each of those over every triplet. Rather try the other way around: 

The main loop would be better with an early exit on the check, and it should be spelt (or when inverted). 

I'm using minimum times now because PyPy gets below the minimum runtime overall. We can see that both interpreters are much faster than previously. Personally, I would write as a generator: 

I would probably stick with the original, though. I only mention it because a fair number of people don't know about it and sometimes it does matter. Your naming breaks PEP8. Don't let fool you; was written by heathens before the style guide was standardized. A quick touch-up is 

You still have global data but you localize it to the function. To me, this seems a sensible trade. Note that and the original were not constants so should not be in ALL_CAPS. Another thing that irks me is your use of strings to represent the board. Tuples of integers makes more sense and can replace your . Strings might be neglibily faster, but it seems like a poor readability trade to me. You don't use as far as I can tell. Just remove it. You do: 

Change to just . Try to use and replace / with booleans. I'll initially use and discard the second parameter to keep the transition small. Then consider that your structure is 

There is no "proper" dictionary, there are just different trade-offs. In this case, we have that gives us better asymptotic random access whereas gives us sortedness. Sorting the a after-the-fact is well and good, but is already sorted so it seems like the better choice. Rust very heavily gives tasks out to crates. This is guided by RFC 1242, and you might notice is in rust-lang-nursery. This means it is official and it is "standard rust"; it's just not in the standard library. Plus, it's as easy as adding to your , so that's no reason to avoid it. Ignoring that, that 

Lior Kogan showed manually that any timespan strictly longer than 2844 seconds reaches a global maximum. 

The call adds up everything in the container you pass it and produces the element times. Here's also a trick that comes in occasional - albeit rare - use. Instead of adding one every time, you can instead double it with 

Since this does not change as it progresses it's likely that this quickly stops doing anything productive, spending most of its time bouncing around a few points. It'll probably work better with a gradual slowing: 

Instead, do . Don't call variables ; you shadow the builtin and don't adequately name the variable anyway. Instead of 

it's problematic in that it mixes logic (converting coordinates) and fetching input (). Rather, the coordinates should be passed in to the function. The name should also be more descriptive - after this change I would call it . The docstring (as per jonrsharpe's advice again), should be more imperative (like a command) rather than a statement ("return", not "function returning").