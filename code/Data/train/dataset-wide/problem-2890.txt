Error Handling Why not use (by way of , which - as @Pimgd noted - is better done using Objects.requireNotNull(Object, String). An NPE is, very commonly, a specific kind of invalid argument. The exception heirarchy isn't set up that way, but semantically they provide clear information: "Actual argument must not be null for 'abc' in method 'xyz'" is preferable to "Actual argument is (somehow) invalid for 'abc' in method 'xyz'" - no? You get this just by using - when checking, only indicates that "some" duplicates exist, but doesn't provide even a single specific duplicated key. Providing that level of feedback would be nice, but requires either a different map collection logic and/or extra logic deferred to when the "must have had at least one dupe - let's find one specific item to report" is being done. Such extra effort should only be done once the error is detected, when it's already known to be worth the richer error reporting effort. If you are going to validate args (vs. null or otherwise), you should do so consistently in all API methods - even when you "know" that validation would also done by other methods called in that method's body. True, such checks will be redundant, but I would rather be sure that it's done consistently than have to think about if the called function validates (and reports) a violation in the way it should. This is especially true when argument names change from what the API client used to what is reported at failure (assuming you were to follow something like @Pimgd's suggestion). Unless this is a "high-performance" utility (which I don't think it is), you shouldn't bother about any inefficiency due to argument re-validation. Even so, even if this were an HP utility, I prefer to validate arguments at the class surface (API / public methods) and then transfer control to private methods that can blithely (efficiently) continue without further checking, knowing it was done at the API level. (Simple check-then-delegate API methods would likely be inlined, and would be fine even for HP. If you're still concerned about efficiency, then you should be writing micro-code...) API Names Why and ? Perhaps and Sometimes sometimes ? How about consistently ? Use established language from mathematics about function inverses, where a is considered a discrete finite function: should be When a name part is , it should refer to the already existing class , not merely "some map with enum values on one side or the other." When you mean "Map of Enum to T" you should use (which may, or may not be, an ). Conversely, for a map (not necessarily an , which would under this naming imply an enum-to-enum mapping, where the two enum's might (not) be the same Enum). Why This Way? What purpose would serve? Rather than why not ? I suppose there might be times when some existing code wants such a mapping (and it's not open to refactoring), or ... hmmm... when? (Actually, I can see the point to such a converter, even in a green-field project. I would like to see the JavaDoc suggest that such a mapping be avoided in favor of the already-available when that is sufficient.) Ditto, re: Also, the reverse situation with a is also of uncertain value. Isn't that what is for? If you don't like client code dealing with exceptions, then a utility class which swallows and/or and merely returns seems right. BTW - such a utility method wouldn't belong to the class, but rather an or class in a utility package. I know you're playing with Java 8-isms, but seems overwrought. Why not just (I made this modification to your code and all tests continue to pass.) Since takes a merge function, why not expose that capability to the clients of this utility class? You might still default it, if you like defaults, but for clients that need to keep the first item in a merge, or the greatest, or the closest to a reference, or ... - they can't use your utility as it stands (making it less utile(?)). Documentation (and related type) When a method is documented as returning an (or ), the return type of that method should be specialized to match. If you don't want to specialize the return type, then you shouldn't mention it in the JavaDoc. The doc describes the contract - and the code should be as close to it as possible. Thus, as per the current JavaDoc, I prefer: I like your use of the right-arrow in the JavaDoc, but the "raw" docs are much more readable if you use rather than . 

This is a very common pattern in rails apps that you can also see being used in the rails guides. The helper is smart enough to generate the correct path to submit the form to depending on weather or not the instance variable contains a record that has or has not been persisted. Persisted records (new ones or those with errors) will be posted to create. Records being updated will be set to whatever the action/path for that controller is. Whenever updating or saving a record fails, the controller will render the appropriate view ( or ) and use the record that failed validation when rendering the form. From here, your view can inspect the record and display any errors if they exist (). This won't fix an issue of a user navigating backwards and forwards through your form, but it should reduce the need to do so and it'll let you avoid weirdness you may have encountered while persisting form data within the variable (which gets serialized and de-serialized into whatever your session store is during each request). 

I think that makes for a bit more readable code, but I'd agree with other comments in this thread that this block of code seems to be doing too much. I'd suggest seeing if you can separate the logic used to validate and persist this data from the places you determine the controller response. Cleaner separation of purpose will make it easier to avoid things like temporary variables and make it easier to spot places where complex logic can be sequestered into a private method (for instance, a method called ) 

All that is left to is checking if all bits in the mask are set to true by the current player. This is very easy using the bitwise -operator. Example: 

First of all, I support @EBrown about whitespace and braces. Some other ideas depending on what you are doing: 

You are looping over all intervals. This means you have to check all intervals with each other. Hence complexity: This is a well known problem, you could find a lot of reading about this online if you want. 

In this case you just want your input to be an integer (or a long). So using the regex is one idea. But you should also consider malicious users. What if you try 

So we only need to work with the first 9 bits of an integer: To check if winning we can use the following masks: 

Consider using an field instead of . You are using a lot of hashing, which causes overhead on a String. 

=> All bits in mask are set to true REMARK: Instead of looping, you could hardcode all row and column masks. Which are still only 8 masks. If you understand this, you should also be able to understand how to 

Depends on what you want. Typically programming challenges are not validated on clean code. But on correctness and efficiency. 

I can't speak for that particular Railscast episode, but rails provides an idiomatic way to deal with validation errors. Taking your code as an example, I'd change it to look like this (using Rails 4.2): app/controllers/profiles_controller.rb: 

PS: I find that thinking of multi-step forms with more than one or two steps as state machines helps greatly in trying to conceptualize the different states and transitions you need to handle when you need to determine at what point in a form a particular session should be in. To that effect, I would highly recommend checking out the wicked gem which does a lot of this grunt work for you. 

There's a lot going on here, so I'm going to put all my feedback in a list as I go through your code and put a new version of it with my suggested changes at the end. Keep in mind that I'm not testing these changes and that the code I come up with may be broken or incorrect. It's simply the result of me going through this and changing things to bring them up to a level of quality I'd expect within a codebase I was responsible for. Feedback 

First off, I would also strongly suggest you avoid the keyword and prefer unless you have a very specific reason for favoring over . Look here if you're interested in seeing why a lot of ruby programmers think this way. That being said, the easiest way to clean up big conditionals like this without much refactoring is by assigning intermediary variables (optimize for readability):