Again, this is pretty basic representation of a typical model inheritance approach. You can look into popular PHP ORM's to get more full-featured behavior and to get a better idea for how they handle table realtionships and such. 

It is odd how you are working with PHP's procedural date functions interchangeably with . For example in your constructor you write this: 

Do you really want to tie IP address to session/authentication validity? I think this is an old paradigm that still pops up in "secure" web application design that really should be called into question. There are legitimate cases where a user's IP address may change during a session (a mobile user for example) and there are even more cases where a user's IP address may not be "unique" to them during a session (users on a common LAN, users behind proxies, etc.). 

Why are you trying to start a transaction here? Shouldn't this class only be concerned with getting the connection established? Do you not trust that the return value of is valid? I don't see that you are working with transactions at all in your other code, so wouldn't the happy path execution of this code lead to a bunch of unnecessarily open transactions? 

Note that we apply a data attribute called on the container of each situation "page" to uniquely identify it amongst all situations. We also have data attributes on each option specifying the that option relates to (i.e. which situation will be shown when the button is clicked). I have added another class to show which situation(s) are visible for display on initial page load. Finally, I have also introduced a class for here that is not used in the javascript at all, but could perhaps give you a handle for applying CSS styling. You use these data attributes within your javascipt to implement the logic as to what situation is shown when an option is clicked. 

I am personally a fan of pretty much limiting the "routing" aspect of a front-controller like this to just getting the request to the proper controller for further processing. But before talking about that, I want to ask you whether what you really have here is a "router" or a "URI parser"? It seems like just a URL parser to me in that is does no routing. If your goal is to create a one-fits-all URI parser, you are probably engaging in a fool's errand. As you change your application/API's behaviors and endpoint signatures, you are going to continually add more complexity to this central parser. This is probably a bad path. Now let's think about a true "router" (this thinking exercise ideally getting towards addressing your problem with not understanding how to implement MVC). What is a router intended to do? It is intended to interpret something like a URI string and do nothing other than to route that string (and of course any payload passed to POST/PUT) to an appropriate piece of logic that knows what to do with it. The RESTful URI structure you present really only requires one level of routing. That can be as simple as looking at first path segment of the URI, comparing against configuration mapping controllers with each "first segment" value, then instantiating the controller and passing it the remaining URI so it can determine what to do to with it from there. You might find yourself using a combination of classes such as 

This is pretty trivial example for review, but you are right to question use of this function from within a view. Personally I think this is information that needs to be determined upstream of this decision point, making the function unnecessary. If you always used this format for loading language: 

Should you validate presence and value of parameter in request before trying to operate against it? I ask, because without knowing what happens in , you may have a case where you are doing things like making relatively expensive database queries before validating the input. You also might need to respond with 4XX error if the input is bad, which is something that is not clear from code shown that you are doing. 

I guess this is similar to my earlier thoughts around request/response objects. I think your framework is currently quite naive around aspects of reading and setting HTTP headers, something that can be critical when trying to build a RESTful API framework. What you will likely find is that there might need to be quite a bit of logic around this, such that building these separate classes becomes mandatory in order to encapsulate this logic and not have it scattered throughout the other classes in your framework. Again you may want to look at your favorite framework(s) for inspiration in this area. 

Let me first warn you that you have fallen into a classic anti-pattern. When you see yourself tempted to write code that starts naming variables/objects/item with names like (with being numbers), usually this means you should be thinking of these things as an array. Also you have a lot of repetitive code that you can refactor out. You need to begin to come to terms that jQuery is especially powerful at dealing with collections of DOM elements. So again, when you begin doing things like make element ID's like this probably means you should be dealing with the collections of buttons logically using the same class. Finally, you really haven't embraced an "object oriented" paradigm at all, which is something that could really help organize your code. I will show you an alternate implementation that you might find helps prompt some different thinking. This may seem like a lot of code, but you might find this sort of approach helpful over the long term with regards to being able to more easily maintain and reuse this code. The approach: 

This guarantees that these objects are passed a valid dependency upon instantiation. If you try to pass anything else to the constructor, an exception will be thrown and the object will not be created. It fails loudly. This is desired behavior, as the calling code can then do whatever it needs to do to handle the failure condition, which would obviously include not trying to conduct any further operations against that object as would happen now with your current code. Your setters probably also need validation. For example, perhaps you need to fail loudly if a non-integer (or integer value in string) is set for ID value. Perhaps you need to fail if an invalid vote type is attempted to be set. 

This means you could even go so far as to pass template file paths into the function on the fly to switch out templates to be used (or you could have some config settings for template paths that the function uses). This could totally get you out of having any HTML within the function itself. 

My primary concern is over how you are coupling this functionality to the DOM. Do you ever foresee a use case where more than one of these controls might exist on a page? If so, your approach of binding functionality to the first arbitrary element instance of a class in the DOM will break. Every control you might want to apply to the page would be bound to this first set of elements of every class. Should you really be using against class names or would it be better to enforce more specific behavior by operating against specific elements based on id and using ? If you truly wanted to introduce the flexibility of query-based selection, then perhaps you might be better off to utilize and act against the collection of elements that are selected rather than always only picking the first element from DOM that meets the selector. As far as attaching event listeners, I would consider building a configuration object that could be passed to to pass along configuration information and callbacks. This begins to allow you to decouple the callback actions (adding/removing classes) from being hard coded in the definition. Perhaps that is something like this: 

There is no reason at all for your else condition, as you are returning in the previous conditional. That should just be: 

This function seems poorly named. Yes it is recursive, but what is really happening here is you are flattening a hierarchical structure. Perhaps a name like would be more fitting. Also, the comment here is misleading. You are not doing any sort of "search" at all. 

In class B, you should be using parametrized prepared statements vs. concatenating string values into your query strings. You are totally open to SQL injection as you are doing nothing to sanitize your parameters for use in the queries. 

Move this outside loop. Consider parameter typing here. If you truly want to store integers, or doubles in your DB table, then you should enforce that here as well so you are not accidentally invoking potentially unexpected type conversion behavior in the database. Your current binding logic assumes happy path. What if binding fails? 

As mentioned previously, this should have been validated in the constructor and failed long before the point where a client would ever call this method. 

Why are you continuing to work with the raw JSON string here? You already have a meaningful data structure from the previous line of code. Concatenating JSON together DOES NOT WORK, as you will get an invalid JSON string. JSON is ONLY used for data transport, not as a mechanism to build a data structure. Focus on building an appropriate data structure and then serialize to JSON for delivery. 

If you take the approach noted above and store element refences on object as well as question information on object, all of your public class methods could change signature to not require parameters to be passed. For example: 

Your variable names could certainly be more meaningful. What does convey? What does mean? does not get a year, it gets a range of years, right? 

I would think that, this being a class and all, the server address would not be hardcoded into this specific method. 4) 

Note I determine only once with this approach vs. on every iteration. You may consider returning index position of found item (or found item itself) here to make this more useful, because presumably you are checking for this key because you want to access it somehow. The caller would need to be aware of potential falsey behavior of vs. or similar. You also would probably want to rename the function at this point to something more meaningful like or Of course, this is essentially what and do. You would just need to implement your key check check in callback. That might look something like this: 

Some of your method names could perhaps be changed to something more meaningful. For example, might better be named something like , as you are not "iniatilizing" anything. The more you can get yourself in the habit of naming your variables and methods in a way that is meaningful, the more easy-to-read your code will become. 

You probably should not be directly re-populating values into your HTML template. This is causing you to have to do a bunch of logic in your display template. I would prefer to see you populate an object, associative array, or a series of variables to place value into your forms. So more a pattern like: 

This seems like it could be simplified. You are only fetching a single value after all. How about just: return ($data = $sth->fetchColumn(0)) ? $data : ''; Or non-ternary equivalent if you like. 

Be careful with applying database change logic on a single shared connection. In doing so, you probably need to add "change database" logic everywhere you use this class as you have now introduced uncertainty as to what the state (in terms of which database is in use) of this shared connection is at any point in your overall code execution. You have no way enforce that a particular database is used for a particular use case, without explicit selecting database for each case where this code is referenced. I typically like to go with the approach of spawning a whole new connection for each database that may be needed by an application (this of course assuming your application is architected in such a way that you don't need to absolutely minimize the number of DB connections). You would then inject the appropriate connection to the appropriate consuming code.