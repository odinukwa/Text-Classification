What you did forget to implement in that specific service, is an test. If the control is set to the same value again, you don't want to propagate. Even less so if the scenario mentioned above occurs, and the self-adjustment of a brightness control could possibly broadcast another update. 

You just spun off 3 threads. The one handling the input is acceptable, you don't want that one to be blocked by anything else. But what about the other two? That stuff belongs into the actual game loop. Which you don't have in your design. It would look pretty much like this, if you had one: 

Please don't do this. You are trying to provide two different functions under a single interface. That's error prone, and not exactly necessary either. The calling site should already know whether it's invoking this function with a single result set, or an array of such. Use this knowledge in your API design. In your case, this means stripping your of all the special handling regarding multi updates. 

I assume your variable was actually supposed to indicate the fill level of the original inventory tracking mechanism. Please try to name it properly the next time. There is also a second problem with , you made it even though any external modification to this variable would break the integrity of your implementation. 

Mixing languages is typically a horrible idea. A sane guideline, stick to the language predominant in the framework you are using. In the case of C++ and the STL, that's exclusively English. This is not only because other developers most likely won't be able to understand why you named something in a specific way - it's also ambiguous. For every possible variable, you want to have a naming scheme which allows only one sensible name for that variable so that you never have to guess how you named something. Having two languages to choose from, makes this already a futile attempt. 

No need to peek ahead for the loop condition. Especially not AFTER incrementing it already. Coincidence that this function was not part of the test suite? 

In terms of code style only one remark, and that is on the location of the when working with pointer types. I know, placing it next to the type feels more natural, but it's semantically inaccurate, and it will trip you the first time you attempt to declare multiple variables at once. Placing it where there compiler would sort it helps preventing these mistakes. 

This only protects you from accessing a null pointer in , but in return it now leaves uninitialized. Not "set to 0s", but actually uninitialized so it contains whatever garbage was previously at the memory address. 

The algebra is fine. That line wouldn't be necessary (IMHO even reduces readability), but apart from that it's reasonable. However, your solution is worse than it needs to be. It merely stays in-place, while the optimal solution to this problem can treat the input as read-only and limit the working-set to constant space. Your solution also depends on being implemented as in-place and manipulating the original list. Depending on such behavior is IMHO pretty bad design. In fact, if I hadn't checked the source of , I would have expected it to return a reversed copy instead. Which would obviously break your solution. 

Even when you set , any worker thread waiting on can't exit the wait as the wait condition won't be fulfilled. Only threads which were already inside at the time of invocation can even reach the loop condition and hence terminate. Which means your destructor can get caught in a deadlock. 

You don't have any private methods yet. Just food for thought, in regard to the Separation of Concerns, you could actually structure your API like this: 

Specifying the times as strings for readability in the config module is reasonable, so let's keep this as a requirement for now. This leaves us with either increasing the sample rate on the timer, or with refactoring the logic which handles the state at any given point in time. Since the sample rate can't be increased arbitrarily, let's go with refactoring the logic. 

Performing calculations directly on input events goes against the fundamental principle of the react framework. You should have stored in the state instead, and only perform the actual calculation during the method. Is goes without saying that updating the DOM inside this callback is completely off limits. 

It is unfortunately still necessary to store the entire input in memory, in order to count the elements. If it wasn't for that, you could just copy from input to output element wise. But what's important: The data structure used is now a plain vector, which removes a lot of unnecessary stress on the memory system, as the storage method is a compact as it gets. There are also no mutations to that data structure at all, it only serves to replay the input after counting all elements. 

While these two are obviously magic numbers, you are being very inconsequent by deriving a lot of other magic numbers in your codebase (essentially all screen space coordinates!) based on the value of these two. Take e.g. the bounding boxes in , every single occasion where you are drawing an UI element at a fixed location, or even the ingame object placement. All of these should have been derived from these two constants! 

is also awkward for another reason, and that is being hard wired to . An acceptable compromise would have been to overload on for debug purposes instead. But that's not all, it's providing debug information on the inner structure of the class, not a simple serialization as you would expect from a function with that name. 

To be honest: Not a very elegant approach. Let's have a look at a different hypothetical sample data to see where it breaks: 

This doesn't look right. You are essentially recreating and discarding instances over and over again, while you are technically only appending to the property. should either be mutable, or simply add the current path suffix as a parameter to , so you can create instances with the correct properties right away. 

And please don't use a trailing unless you know exactly what you are doing. You don't need it when using the class to build paths. Respectively, it doesn't even do what you think it does. 

With regard to the efficiency, the solution for that one is to use a cryptographic function, asymetric or symetric doesn't matter, which can work with a block size of 19 bit, together with a random key. Using that to map an steadily incrementing counter onto the combinatoric space of all possible names covers about ~78% of the namespace (524.288 out of 676.000 possible names) and yields pseudo-random names at a constant time. On 19 bit counter overflow, reset the secret to create a new sequence. 

I also couldn't help but notice that you defined X/Y pairs multiple times, which always resulted in copying the X and Y components individually between different structs. Define something such as a "position" once, and then just reuse / nest the struct definition. E.g. 

For instance, the boost implementation gives an never empty guarantee which your implementation does not. You are explicitly handling the case in which the Variant is in an invalid state. 

No. Even though it might have even worked, you violated the contract by attempting to wait on an unlocked mutex. 

Bonus points for wanting to support *nix systems. All gone for totally messing it up. , if at the start of a path, is already the home directory. is not a valid path. 

The at the end removes the trailing white space, resulting from the empty suffix, respectively the concatenation of the first valid suffix with the empty string. 

This is a huge problem. Even if you wanted to that again, you wouldn't be able to. You just threw away your only reference you had. If you would call now, your application would just crash or worse, because you must call on the same pointer as returned by . Even if you were to write this in C, you must always keep a pointer to the base address of the dynamically allocated memory region, or you won't be able to free the memory again. Even though it wouldn't had been necessary to allocate a new anyway. As you don't modify the data, but only the pointer, you could just have said in which case you wouldn't have needed to deal with memory allocation at all. 

All 3 of these only work as expected (or at all!) on Windows. Cross platform input handling and interaction with the terminal is rather difficult. 

This part only works as expected for the first thread, as it actually gets the lock. The second thread fails to obtain the lock. See the documentation for . The lock must be locked before entering . That means you can't use , but actually need . 

Yes, you can improve that algorithm, by optimizing the following inequation: $$n \le \prod_{i=1}^{k}{\lfloor\sqrt[k]{n}\rfloor+b_i} \quad \text{with} \quad b_i \in \{0, 1\}\land b_i >= b_{i+1}$$ Just initialize the guess for all factors for a given \$k\$ with \$\lfloor\sqrt[k]{n}\rfloor+1\$, and replace the factors one by one with \$\lfloor\sqrt[k]{n}\rfloor\$ while you are still above \$n\$. That means you will effectively only need to calculate one root per \$k\$, followed by at most \$k\$ divisions, multiplications and comparisons. 

The second occurrence where the functionality should have been encapsulated inside is . This function requires specific knowledge about how the storage is implemented, so it's inseparable from it. This also raises concerns regarding the visbility of and . These properties don't need to be exposed, if the methods belonging to are actually moved into that class. For the invoking side, only the capabilities of storing, counting, and reciting stored paths are of interest. Nothing else, especially not how the tree is implemented. Not even the fact that it is implemented as a tree at all. 

The only exception to that is the part below 1,000 which has no suffix. However, a missing suffix can simply be approximated by an empty suffix instead. So the logic approach is to write yourself a helper function which correctly formats every number from 0 to 999, because that is the range you need commonly. Your next realization should be that it is easier to start constructing a number from the LSB, than from the MSB, since you then only ever need one set of constant numbers to extract the relevant part of the number. Once you have that function, can be written much clearer: 

I hope you have placed a cache in front of that script. You are stalling the script with a REST query, and the memory footprint isn't negligible either. If the web server isn't configured to cache, you want to fix that. Caching the output with plain PHP is slightly more complex than that, with regard to acquiring a mutex on the cache during updates. 

Understanding what the database does You've got a nasty bug / conceptual error in your code. You code does work "fine" if the field is either entirely missing from , or if it contains a valid value. Well, actually it does not work fine in the first case. Because what actually happens, is that accessing sets this field to , so you are querying the database for a row with as the primary key. You then continue to insert a new row with explicit as the primary key, which the database then automatically replaces by the next sequence number. This side effect is a bug, and should be fixed. But what happens if was set before, not to , and not to an existing primary key either? You create a new row, but you did not use the sequence number generator intended by the database for that. Even being set to an empty string will most likely break this already. Actually, when does it occur that the row, which was supposed to be updated, can't be found? Either someone just guessed a random primary key (which should not happen), or the row was deleted in the meantime. In the latter case - is it actually the expected behavior to re-add the formerly deleted row? Or throw an error? Un-assign the (known to be invalid) primary key and let the database assign a new one? Either way, you certainly don't want a primary key in your table which wasn't generated by the sequence number generator. For various reasons. 

That gives you a complete list of all matched products, excluding those which are already known to be false-positives, but including those who are still unknown. The latter ones can be identified by having empty fields for the columns pulled in from the table. Why we needed a single sheet? Because that's the prerequisite for using . What you did manually is not much different from doing a , except that you essentially constructed the temporary table required for that by hand. 

There are also a couple of flaws in your database scheme: Take the table schema. You are abusing it to describe both the roles of teacher and student for any given class, without distinguishing between these two. I suspect you coded the user role into the schema instead, but it would have been better to store different roles in different schemes. You are apparently storing class names as string literals in multiple schemes, this is an indirect violation of the 2NF, but even worse, it requires string comparisons to match the corresponding columns against each other. This should be refactored ASAP. There also appears to be a possible design flaw in . If the same test is reused by two different classes, and a pupil is enrolled into both, his test results are now shared between both classes. Test results should probably linked to a specific enrollment to a class, rather than just to the generic test. This also allows to simplify this query further, as the most expensive part of joining on for querying pupil enrollment is then obsolete. 

This effectively causes 2 additional queries to the database for each 100 results in the model. This might still work reasonably in your test environment where you have at most a few dozen leads registered, but will crawl to a halt in production as the number of leads increases with time. Even worse, it requires you to stream all existing instances through PHP, even if they are not even part of the final result set. 

Neither of them have the correct signature for a copy assignment. The correct signature for that operator is . That already rules out abusing the return value to signal success or failure. If you want runtime errors, you got to do it with exceptions. If you violate that signature, it makes common patterns such as chained assignment () impossible. This may break other templated libraries depending on your datatypes to adhere to the standards. Especially returning a may cause rather unexpected side effects. 

You should revise on the API design on your service. You now have the odd situation where the needs to be aware of , while on the other side the controlling sites need to be aware of . This is a rather unfortunate situation, since you now created a dependency chain from via to . This means a can't exist, without existing in the same application. The solution to break this chain, is to make instead aware of , respectively define a generic interface in the package of which allows other components to register with this service. Now both the and the can exist and access the without the other component being part of the same application. As a side effect, this also solves the case where wants to observes the currently set brightness as well. 

Just to avoid confusion, the former paragraph isn't applicable for , and alike. However, these are not exactly clean either. Abusing a to pass in the render surface of the parent is a horrible hack. Especially when you then continue to render to absolute coordinates in the parents screenspace. At least have the decency to leave the layout to . That is simply reached by additionally passing and offsets to , so that these components (at least internally) don't need to know the layout. The clean solution would be not to let these components draw directly to the render surface, but to use separate panes instead, completely separating them from the parent component. 

If by "finished" you mean the executor is ready to be destroyed? That is already the case. Otherwise if you just mean to wait until the pool runs empty? Well, you do have in there. All you really need now, is a second condition variable: