There is a free version of DB2, the Express-C Edition, which includes most of the features of the "real" DB2 servers. It doesn't include some features, like label-based access controls or table partitioning; and it can only use up to 2GB of RAM and 2 processing cores. Have a look at this article to see what you may be missing out on from some of the "upper tier" editions of DB2. 

I see you already have an answer, and I see that you can't change the table definition because of other programs that use the table, but can you add in new columns to the table? Are you also on DB2 for Linux/Unix/Windows (tested on 9.7)? If you can, and you are, then I might suggest you create a to create a column, which you could then index for searching. 

(Assuming DB2 for Linux/Unix/Windows here, since you don't specify, but this will probably also work on the other platforms.) You don't have to do funky date math, there is a built-in function that will do it for you: 

Yes, Access on the client machine will connect directly to the linked tables located on SQL Server (or whatever ODBC back-end you're using). If you're dealing with forms and reports bound directly to these linked tables, it shouldn't cause any major performance problems. If you've written more complex queries within Access, then performance can depend on how well those have been optimized. We've got a number of small Access "apps" running against SQL Server. They're great for when you just need to bang out a simple CRUD tool for a few people in an hour or two. Haven't had any real performance problems with them, though occasionally we run into a lock being held longer than it should. My advice would be to take all the tables stored in that Access back-end and migrate them to SQL Server as well. Shared Access data files tend to be awful for performance and reliability. 

If the reports are always referring to the same index, then you might just have a corrupt nonclustered index (since the index ID is greater than 1). I'd definitely keep a close eye on hardware diagnostics, and also keep SQL Server up-to-date on patches to identify the root cause of it becoming corrupted. But you may be able to repair the problem by simply rebuilding the index: 

I see your Info Center link goes to LUW 9.7, and you mention that you've programmed in Java, but most of the experience I have with binding is with DB2 on the Mainframe with COBOL. So, you may need to adapt the explanation a bit (but generally, the concepts should be the same). I believe that binding is only relevant when you are compiling programs that include embedded SQL which is precompiled (statically bound SQL). If, for example, you're using JDBC, you aren't required to run a BIND. The JDBC driver will the statement dynamically. 

While @user22610's answer will work great if your DB2 platform is Linux/Unix/Windows, it will not work on Mainframe DB2 (z/OS). If you're using that platform, this would be your command: 

If this is a workgroup, then may be the name of the computer SQL Server is installed on. Obviously, the account you're setting here will have to exist on the computer hosting SQL Server. This setup also works for domain users trying to connect to a SQL Server instance in another domain. 

The final step in every case would be setting the database to read-only mode. What other good/better options are there for doing this? My concern is moving the data over in such a way to preserve a high fill factor, and in a logically contiguous fashion. Edit: I should mention that about 75% of the data seems to be stored in image (LOB) columns. 

In other words, a ticket is assigned to a project, notes are entered on a ticket (with a corresponding number of hours worked), and note hours are then billed to one or more agreements/contracts (if a block time agreement is exhausted, the remainder may spill over to another agreement, for example). This is all working fine, as far as the application is concerned. So now I'm creating the invoice report, and I need to provide a grand total of hours worked at the end of the report. Take a look at the 4th and 5th rows (with note_id = 8). The report footer uses , which then ends up counting that note as 10 hours. Both and come from the note row, and should be summed accordingly. Including in the grouping expression for NoteGroup has no effect on the behavior of Sum, naturally. Is there a straight-forward way to make Reporting Services sum up hours, looking only at the grouped values for that group, rather than the detail rows? I can't think of anything particularly elegant as of yet. I can fall back to weird custom code stunts if necessary. 

When you run a program through a DB2 pre-compiler, runs through your program, and if it finds any embedded SQL (in COBOL, these are statement blocks that go from to ), it carefully rips the SQL out, and replaces it with a call to the COBOL-DB2 interface. After this, there are two outputs of the , the COBOL source that has had all the embedded SQL removed ( from now on), and a that contains all the SQL that was removed (). Precompile does do some basic syntax checking, but be aware that the checks are only based on your table declarations within the program. It doesn't attach to DB2 to verify these! These two files are completely separate, and when you run the COBOL program, it has to find an and a that were generated at the same time. At this point, is compiled and linked with the standard COBOL compiler into a and placed in a load library to be used later. However, there is still a lot of work to be done with , the DBRM. This is where comes in. is sort of like a compiler for the embedded SQL code, and the output of the "compile" is a . In order to BIND the SQL into an executable "package", the BIND process attaches to DB2 and does a few things: 

Cut the chatter. Use NOCOUNT. Make sure your trigger can handle multiple rows. Prevent unbounded trigger cascading and recursion. Avoid horrible performance of the INSERTED and DELETED virtual tables. 

Once that's running, you have to connect to the dedicated-administrator connection (DAC) for the instance. You can use any tool you like, e.g. Management Studio or sqlcmd, but note that you can't connect Object Explorer in Management Studio, since it's running in single-user mode. In either case, specify the prefix for the server name. I think you can do to connect to a local default instance. After that, you can pretty much change what you want, but you'll have to figure out what the actual underlying tables are for certain system catalog views. For example, . To see the view definition, switch to the "mssqlsystemresource" database (not normally visible), and use to see the code for any system views/procedures/functions. 

A couple more (superficial) reasons: Auto-update stats will block the query that triggered the update until the new statistics are ready. ...Unless you also enable auto-update stats asynchronously. Then the query that triggered the update won't wait for the new stats, but will potentially run with the old, incorrect stats. I also ran into some strange blocking issues when a database with some relatively large tables (44M rows, 8.5 GB) would start updating stats. We decommissioned that application before I was able to really track down what was going on, though. 

According to this Microsoft KB article, SQL Server 2005 (in any form, even with all the Service Packs installed) is not supported on Windows 8. 

During the last step, all of your SQL is run through the Optimizer, which takes into account all of the statistics and various paths that the DB2 engine could take to fetch your data. It then chooses the path it came up with that has the lowest cost associated (with newer versions of DB2 [DB2 10 for z/OS], it may decide to take a "higher cost", but "lower risk" path). Once the path is selected, it is compiled and becomes a package, which is stored in the catalog (you can see all of your current packages with (z/OS)). Finally, there is a last piece that allows our programs to reunite with their packages, the . You create a plan by doing another BIND (). A plan is a collection of packages that the program is allowed to look through to find the package that shares the same name. With COBOL, you specify which plan the program should search in in your JCL. 

You can use EXCEPT as a quick and dirty way to compare data in two tables with identical column structure. 

Go to Tools, Internet Options. Go to the Security tab, click Local intranet, and click the Sites button. Click Advanced to open the list of sites. Enter the full name ("server2.newdomain.net") into the appropriate box, and click Add. 

My knee-jerk reaction would be to add a CourseSchedule table between Course and PersonTranscript. The same course could obviously be offered at different times and places, with different instructors, and maybe some sessions are online vs. on-site, etc. and you need a way to separate those properties from those that are universal for the whole Course. Then going back to the idea of adding training plans, you could have a PersonTrainingPlan table that joins Person to Course directly (they're just planning which courses to take, not actually scheduling them), whereas PersonTranscript (and possibly a PersonSchedule table if the application warrants) joins a Person to a specific instance of a CourseSchedule. 

In short, compiled code goes through these steps to generate a usable : Precompile -> Creates a DBRM (with C[++], the precompiler outputs the precompiled SQL to an HFS file, which can be sent through the command-line bind program) -> the DBRM is optimized and a set of access paths (a ) is created -> The package is added to a , which is a group of packages that allow you to create a "search path" for your programs to look through. Since these programs are statically bound, if your table statistics change drastically, then the access path the optimizer chose at bind-time might not be the best path anymore, and re-binding will allow it to re-evaluate the SQL and perhaps choose a better path. 

Edit (update for comment): If you are using the command line processor, you can pass in either a single bind package (), or a list of bind filenames (). If you pass in a list, the filename has to be prepended with a (e.g. ). Inside the .lst file, you can either put each package on an individual line, or you can separate them with :