Don't use them as a prefix. Your usage is actually fine. BUT the rules are complex and I am sure you don't know them. The fact that you did not break the rules is just complete coincidence. Pointers It is very rare to see pointers in C++ code. The problem is that pointers don't express ownership semantics. So you don't know who is the oner of the pointed at object (i.e. who is supposed to delete it). This is what caused most of the problems in C. You should use types that express ownership. References for non ownership. Smart pointers for ownership. Pointers themselves should not be used except in the very depth of a class and highly protected (and never across a public API). 

Also C++11 introduced as a replacement to the more error prone . Pre-Conditions Its normal to check pre-conditions and return early if these are not met. This makes the rest of the code flow more normally (I don;t need to check the end of the function for an part). 

You are getting worse results. Let the compiler to the cast for you. If you had let the compiler do the cast for you with: 

Does not help here just muddies up what I need to read to see the interface. If the compiler needs inline it will let you know by complaining. Don't create public functions that have no use. 

When writing C++ code you should definitely not use the C cast operator. C++ has four of its own that you can use: 

Here you do not need to hit the whole in the wall dead center and you get some wiggle room passing through. 

You define the and but the other two you don't define. So the compiler will generate the other two for you. Usually these work fine. BUT if your class contains an owned RAW pointer then the default versions don't work as you would expect. So you should look up the rule of three. If you have to define one of Copy Constructor/Copy Assignment or destructor you probably need to do all three. If your class only uses objects that obey the rule of three already then your class will obey the rule of zero automatically (look them up). Design Review Asking user to provide a large set of hash functions is unreasonable. Hash functions are hard to define in the first place and even harder to get a good distribution with over a set of them. You need to define some way that in most cases the hash is provided (though being able to provide your own is a nice touch). 

I find the logic in you main function very hard to follow. You only seem to make nodes if there is an open brace '(' that does not seem correct. You do nothing when there is a close brace? You test if the left on the current node is null but not the right on the current node. I would expect the code to be inherently more symmetrical. The fact that it is not makes it harder to follow. As an interviewer the things I would have looked for: 

If the user wanted to set the value being managed to another value you can just use the managed objects assignment operator. 

That's why we use smart pointers and containers. So the user does not need to read the documentation. 

This will limit the amount of memory you use otherwise the amount of space you use could potentially exceed memory. Also iterating over a sparse array would be expensive (As there will be lots of zero counts). By using an associative container you only iterate over valid values. 

This should return the original value but modify modify the underlying object. This means making a copy. But like the you should define this method in terms of the prefix value. 

Any function that is a callback from a C library must use the C ABI. If your code is C++ (as this is) then you MUST declare the callback function appropriately to make sure the compiler gets the correct ABI: 

And give those variables meaningful names so we can see what is happening. I have no idea how these two related to bulls/cows/ position in hunters/size of other stuff. Without this context the code is nearly indecipherable. Something that should be obvious at a glance takes 5 minutes of head scratching to understand. There is something wrong here: 

Its the same thing. See my description of usage above. Comments on Code: Always prefer to use the initializer list. The compiler is going to plant the appropriate code anyway. May as well take advantage of this fact and use the compiler to put the corret initial values in place. (Note with POD data there is no initialization but for user defined types there will be. So it will construct the object members before the function is entered. 

This is because the compiler will generate default versions of these. Under normal situations the default versions work. But when you start messing with memory management they usually need to be defined to work together (deep copy problem). In this case Subject has a compiler generated copy constructor and assignment operator. These will do a shallow copy of the object. This will result in both vectors holding the same pointers and the destructor of these objects will delete the objects (resulting in a double delete). 

Implementing your own smart pointer is very hard please don't try. If it is just to try and learn then fine you may learn something but after practicing go back to one that has been tested and is know to work. 20 seconds into looking Bug 1: 

That's 67 lines compared to the nearly 500 for writing it yourself. And I am being generous as I could collapse all the symbols into a single line. This code is basically readable BNF so any computer scientist should be able to maintain it. Code Review There are so many of these lying around. You could have picked up a nearly standard one from boost 

Now that looks like a lot of hard work. There is an easier way to achieve exactly the same affect. You can use the copy and swap idiom. 

No this does not meet the definition of std::lock(). It (std::lock) guarantees that no matter what order you specify the locks in the parameter list you will not fall into a deadlock situation. This basically means that the order you lock the mutex(s) in must be consistent (thus independent of the order they are in the parameter list). Your code is not (m1 is always locked first, m2 second; the actual order should be defined in terms of some immutable property of the underlying mutex (like its address)). This also means that if a lock in the list is already locked it must be released so that the locks are acquired in the correct order. Example of Deadlock: 

By doing it this way. You force the code to initialize the member with the default constructor. Then you reinitialize it with the assignment operator. Best to just initialize it once. 

One could even argue worse then useless as the comments over time may stray from the code (or it takes extra work to keep the comments lined up with the work). The code should explain itself (as it does: the function free_matrix() does not really need any explanation). You should use comments to explain why (or potentially how). 

Personally I don't like prefix '_' on identifiers. The rules for using '_' as a prefix are complicated. Even if you know the rules not everybody that reads your code will. 

No idea what that will be used for. If the user of your code library should not be seeing this then it should also be contained inside the private part of a classs so that they don't accidentally use it. vertex_impl 

This is also a perfect example of where is dangerous not to use '{}' around the conditional blocks. is not actually a function call (even though it looks like one). Its a macro that will be expanded inline (luckily here putchar is so commonly used that it is written well). But in C there are a lot of macros that look like functions and if they are not well written they will screw up what looks like perfectly good code. 

No point in defining destructor the default version will work perfectly. (As a side note: since it is not virtual there can be no derived types with alternative behaviors so making things symmetric is doubly useless). 

So there is no need to add it yourself. It is become standard that when main can return no other value than that the is omitted to indicate that the application can never fail. So when I see a at then end I generally look around for the other situations where it can fail. So if there are potentially failure situations and you exit early with an then add a and then end otherwise don't bother. 

Sure you can test if it is open. But usually that is a waste of time. If it failed to open nothing else is going to work. So exit the function now and reduce them number of levels of indention of the code. 

This invokes undefined behavior. It does not necessarily invoke a crash (or termination). If you want to raise the abort signal do so explicitly: 

I can. You are tightly binding your control flow logic. This makes it hard to introduce new steps or alter the logic. Following the logic in this code is even worse. It is the perfect example of spaghetti. If it works fine then great. But try following the logic when something breaks. This becomes a maintenance nightmare. 

This means it is controlling the memory managed by . And you correctly delete the memory in the drestructor. But you failed to implement Copy/Move semantics of the class (or delete them). Unless you overide them in the class the compiler will generate a default copy constructor operator and copy assignment operator. These do not behave well in the presence of owned RAW pointers and need to be specifically defined or deleted. 

The main(): In C++ we try and use objects and RAII to make the code exception safe. Any time you have init() followed by a dest() pair it is an indication that you should have wrapped in a class and done the init() in the constructor and the dest() in the destructor. Also note you never actually initialize so if it fails to initialize you end up deleting an invalid pointer. 

You should probably inherit from rather than . The and all its descendants already implement so there is no need to implement that in your code. So you can remove these: 

As a user of this class I could easily accidently pass the address of a Job object that is actual an automatic variable. Unless I read the code it is not obvious that the code will blow up. Even worse the code may not blow up for a while since the pointer is not deleted until after the work has been done. In this case I would use a smart pointer. The obvious one is . When you use this as a parameter you are indicating that you are accepting ownership of the object.