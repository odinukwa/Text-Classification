Get rid of the vectors Normally, is your friend in C++. But it is a dynamically allocated structure. Constructing the vector and pushing back is therefore costly, and you are doing it a lot. Since you only have at most four possible moves every step, just use a fixed size array to store them, and use either another variable to store how many moves are stored in that array, or use a guard value (like -1) to indicate that an entry in the array is not valid. Secondly, there is no need to use a vector to store the path. Instead, make be a 10x10 array of that store the next section of the path. For example, the top left entry in the array will store the coordinates (1, 0) if the path goes to the right, or (0, 1) if it goes down. Again, have a guard value to indicate that a position is not seen yet. Points vs indices Currently, you are using to store positions. However, this is not optimal. First, it is probably a pair of ints, so it will take up 64 bits on most computers today, when you only need a number <= 100 to store the position on the board. Second, if the implementation of and is not defined in the header file , but rather in , then the compiler will not be able to inline it, and will generate function calls. These will take a lot of time compared to just accessing a member variable directly. Third, you have to convert between points coordinates and positions in the array. While quite trivial, it can be avoided. Instead of using x/y coordinates, just use a regular to store indices into the board. A may or may not be faster. To go left or right, just add or subtract one from the index; to go down or up, just add or subtract 10. You will need to add checks to make sure you don't go off an edge of course, but you had to do that anyway. 

Use functions to avoid repeating code You have one big function that does everything. While this is a small program, it still is better to split off some logical pieces of code into their own functions. In this case, an operation that you repeat several times is copying one line of input from one input file to stdout. So write a function like this: 

Consider using The math library includes the function that will give you the next floating point number with the smallest possible, strictly positive difference with the given number. This is much safer than union-casting a float into an int, because there is no guarantee that two close floating point numbers will also be close as integers. In particular, that is only true if the exponent of both floating point numbers is the same. For example: 

Be aware though that on some systems (notably 64-bits Windows), can be smaller than , and if you would ever have a string longer than can be represented in a , the output will be incorrect. 

Then your code can just use , and so on. Don't be afraid to drop your own implementation and switch to an existing filesystem library, even though it seems like this wastes perfectly good code. The effort was not wasted, you probably learned form it. But the existing libraries have much more people working on it, and will be of a higher quality. Also, you might get collaborators working on your project in the future, and they might already be familiar with the Boost or C++17 filesystem library, so they'll be more comfortable using that. If this will really not be suitable for your project, then at least try to emulate the interface of these standard libraries as much as possible. Async Instead of making async versions of existing filesystem-related functions, consider just making use of C++'s function. Instead of having a async version of , can you just do ? Again, if this does not work in your case, then at least try to emulate how works as close as possible. In particular, returns a with the results of the function. So instead of: 

Try to read whole lines instead of characters at a time Now that you already have working code, you can think of optimizing it. Your code reads and writes one character at a time. This might not be ideal. Function calls like and are not free, and since they cannot be inlined, the compiler will have a hard time optimizing your loops. If you can read and write whole lines at once, that would be better. If you split of your line copying code into a function like above, then you only need to upgrade that function. One possibility is to use the and functions that read and write whole lines at once. Be aware though that can only read as many characters as the size of the buffer you supply (minus one), so you need to detect and handle longer lines somehow. Also, these functions assume you are working with C strings, which use NUL bytes as terminators, and as such they will give you problems if you want your program to be able to handle lines that contain NUL bytes. Another option is to the whole file into memory, or to use to map it into memory, and implement your own function to scan the memory for newline characters. When optimizing code, make sure that you run benchmarks on the old and new implementations, never assume that a particular implementation is faster or slower than another one without having measured it. Close and check for errors You should call as well at the end, and check for errors. File output is buffered, and the call will ensure any buffers are flushed. Errors can definitely happen; for example, the user might have redirected stdout to a file, and the filesystem did not have enough space to hold the output. If you silently ignore these errors, data corruption might happen more easily. For example, if you want to automate a process where two intermediate output files are generated, but you are only interested in the merged output, and will delete the temporary files afterwards, you might have a shell script that contains this line: 

Note how this function returns the last result from . In main, you can use it to simplify your code like this: 

Don't use Hungarian notation The compiler doesn't need it and doesn't check it, and for a human it is all too easy to accidentily add the wrong prefix and get confused later. So no in front of pointer variables. Array variables can be used as pointers. In the following code: 

You'd obviously only want to use this method for small values of . Is it really what you need? You are trying to check whether two floating point numbers are close, for two possible ways of closeness: floating point difference, and ULP distance. Is that really what you need? Are you sure that the values you choose for and are exactly right? If not, you might get false positives or negatives. Can you reformulate your floating point calculations into integer calculations? Integers may have a limitted range, but at least they are exact. Maybe you can use them to perform fixed-point arithmetic, or perhaps you can use two integers to form a rational number. 

Clearly define the use case When I think of "message systems", it's either message passing between different computers, processes, or threads. However, it seems that your message system only works within a single thread of code. Also, it doesn't really store and forward messages, it merely registers and calls callback functions. This is fine, and may be exactly what you want, but make this absolutely clear for potential users of your message system. Handles versus names Your message system identifies message types by name. However, you have to programmatically register message types. Instead of using an unordered map to associate message types with names, why not have return a reference to the object? This way, you can pass that reference to and , instead of a name, and avoid doing map lookups every time. Avoid global state Your is a global variable. What happens if you have a program that links with multiple libraries, each of which uses your message system? They will all use the same . This might result in conflicts. You already have made it so that you have to declare variables before you can listen to and send s. Why not make a non-static member variable of ? Check for multiple registrations of the same name Your code currently does not check if a program tries to call twice with the same name. It will just overwrite the entry in the with the second instance. Either avoid using names at all, or check that you don't add the same name twice (or alternatively, allow double registrations, but only as long as they all register the exact same message type). is not guaranteed to be unique You are using to check whether the type of a parameter pack is the same as that of a . However, while guarantees that identical types get the same hash value, there is no guarantee that two different types get a different hash value. If you avoid using message names, but rather have a reference to an actual object, then you could move functions like , to the class. Then the compiler would exactly know the type of the parameter pack, without having to rely on run-time checks. Use for callbacks Instead of forcing callbacks to be pointers to member functions, and requiring the user to specify both the member function and the object individually, use to represent a callback function. The advantage is that it will accept any type of function as a callback, whether a named function, a lambda, or a member function (using ). Make it like so: 

As you probably noticed, the slowdown happens when is large and is close to . If it is slower than it should be, it is likely because it is doing unnecessary work. Lets have a look at the case where and , and go to the point in the execution of your program where and . In the -loop in , you are looking at all possible values from to . However, not all values will actually result in valid solutions. Here is a list of all you check, and which subsets are possible: 

You don't need the second variable at all. Just use directly. Include the right header files The function is officially defined in , so make sure to that at the top of your program. Sometimes your program works, maybe even without compiler warnings, but you cannot assume that it will keep working in the future or that you can port it to other systems if you don't. Don't include headers you don't use You include headers at the top of that you are not using in that file. You should remove them. Protect your header files from multiple inclusion When you have a larger project, it can happen that your own header files need to some of your other header files. It can then become unavoidable that a header files inadvertantly gets included twice. To prevent any errors from happening, use the following trick to allow a header file to be included multiple times: 

Use better names Variables and structs should have names that are clear and to the point. Naming something is not to the point, it sounds vague and handwavy. Choose something better. The same goes for . Use for lengths and sizes The proper type to store the length of a buffer or a string is . If you read the manual page of , you will also notice that it returns a value of type . Use the correct format specifier for Use instead of when you are printing a variable of type . If is not supported by your compiler, then cast the variable to the right type when printing it; for example with , cast it to : 

Singletons There are several ways to make something a singleton. You are doing it by removing the public constructor, and forcing users to get an instance through a static member function. That works, but there are alternatives. You can create a regular class, and provide a global instance of that class. Just like so: 

As you can see, does not have any possible subsets. Or put otherwise, is too large a number at to give any solutions. Instead of trying all numbers from to , try to find out what the actual maximum is that will still give solutions. 

You then just refer to instead of . Proper naming Your class has a function , however that function does not log anything. Instead, it just returns a reference. A more appropriate name for the function would then be . If you intend to always use it as , then it might be better to just add an overload to your logging class. This has several advantages: 

By returning an error, you will have prevented the loss of the original files. Note, GNU Coreutils, the package that contains all the basic UNIX text processing utilities like , does exactly that. Try to make your program as generic as possible Your program can merge the lines from two files, but what if someone wants to merge the lines from three files? This sounds like a very logical extension, and if you made your program a little bit more generic, you can easily handle an arbitrary number of input files. Just make an array of pointers, as big as , and for each filename on the command line, open that file. Then copy lines from all open files, until all of them return . You might also want to allow specifying only one filename on the command line, or even none at all! 

Use an existing filesystem library You probably want to use the C++17 filesystem library. It is very close to what you have posted here. If you cannot use C++17, then use the Boost Fileystem library, on which the C++17 filesystem library is based. The latter should work just fine in C++11 code. To ensure you can easily switch from Boost to C++17 later, use a namespace alias. For the Boost library: 

Use const function arguments where possible You have a lot of functions that take an rvalue reference instead of a const reference. If you don't intend to change the argument (like the arguments for the member functions in ), it is better to explicitly make them const references. There are two main advantages: you will get a compiler error when you accidentily do change an argument, and if the compiler knows you will not change the argument, it can make better optimizations of your code. 

Flushing Whether or not to flush depends on what you want to log. If you log a lot of information, flushing adds considerable overhead. However, if you want to be sure that any errors that are logged are not lost when your program terminates abnormally, then it might be prudent to flush the output stream after every write to the log. Other suggestions Do you really want to use the operator? If you rather like to use the style, then consider making use of fmtlib, which provides a type-safe way to format strings the or Python way. Your logging class could look like: 

It's less typing: , or when using the alternative way of making a singleton: . You can actually read the contents of the string in your class, and check whether it ends with a newline or not.