According to the HTML validator at W3C, you have only one other problem. You should not use a closing tag; you should just leave that element open. 

If there is no block and the block throws, the does not run until the exception is caught. It can be caught anywhere up the call stack, but it must be caught or the application will probably crash. If does not throw, the will be guaranteed to run, and if it does throw and the exception is not caught, your application will probably crash. Because of this, you should either place a catch in there or the block is not needed because both statements will run in order. 

There. Clean, easy to understand and maintain, and lots of options to use. Notice that the second needs to have the one integer larger or smaller than the value you want to stop at to accommodate the multi-directional search. 

First, I get the MethodDeclarationSyntax node, then get the doc nodes for that method. If a doc node exists, I get the list of method parameter names and the list of parameter names in the XML doc. If not all method parameter names are in the XML doc parameter list, I report a diagnostic. What I am more bothered about is the code fix: 

One Ring to Rule them All fields--one instance of these fields across each instance of the class. Every time you assign a new value to one of these fields, each class starts working with the new value. This is probably a bug you will need to fix. 

I have more menus to account for, but I haven't implemented going back to them yet as I do not have them fully implemented. What is really going on here is I need to programmatically select a menu to open it so I can select a menu item within it. If I do not open the menu, will not have , so the app will crash. This is : 

I don't think those will ever return any results because you only have and . Later, you filter out the ones for your loops. Just don't include those in the first place, because they are never used anyway. 

My event is doing too much. When you look at the call, it is signaling both that the user has clicked the Remove button to remove the selected files, and that the user has clicked the Cancel button or the Close 'X' button, and wants to close the window. This is better off as two events. Previous call: 

Because the sole responsibility of is to create a list of strings, I would pass that parameter as an parameter to signify this. Then, instead of adding the values to the passed list, you create the list with the values and assign the new list to the passed list. 

I don't like how you have all your logic in the header file. You should declare your methods and fields in the header and use the .cpp file for logic. On the other hand, C++ is not strictly object oriented, the way C# and Java are. You didn't need a class for this solution, you could just have called from . Third point is your naming. actually isn't a helper function, it is the function that actually calculates the Fibonacci sequence. actually isn't recursive, like your comment says, it calls the recursive function. doesn't say what it actually does, although it is easy to guess because the program is only a couple lines long - in a large project, this could (and probably would) cause many weeks of time wasted catching bugs. Fourth is consistency: 

First, this will not work with the input . Arrays are 0-indexed, but when you create one, you need to specify the value you wish to have, which is . This part is also erroneous: 

At first, I didn't understand that duplicate items within the string were not allowed. Second, your program does not work correctly. Consider the following strings: "13234" and "43231". Your program will return for these values because the "3"s are in the same indexes in the string, and therefore the count for each item at the index matches. "123344" and "124433" also return because you only check that the items in the same index in each string have the same count. To correctly handle this with your method, you would need to first compare the strings and return for duplicate values (e.g. "1233" is considered a "permutation" of "1233"). Then, you would need to check that the count of each item in the string is 1 and that each item is in the other string. If I were to implement this program, I would do it as Paparazzi suggested, except I would check that each item is not already in the dictionary as I do the first iteration to prevent duplicates in the first string and ensure that the value is 1 every time I try to remove an item to prevent duplicates in the second string. If you were sure that each string as no duplicates, you could use Dmitry's method, but you clearly do not expect each string to contain no duplicates because you attempted to rule out duplicates in your first solution. 

This is not required, but it shows more clearly that the loop must execute at least once by definition, and it prevents someone from breaking your program by changing the to . 

This will input the entire string of input, make sure it contains only integer values, then parse the string as an integer and assign the value to the number. Unfortunately, this also breaks if you enter a value larger than an integer. You could manually check this before you attempt to convert the string input, or you could simplify your method a little and just use a / block: 

The top array does not have a beginning/ending space between the brace and the content, while the second does. I should always have braces around my s and loops: 

I'm not sure how this would affect the performance of your code, or whether it is important that the variable stay the same, but it is good to always keep your variables in as tight a scope as possible: 

I have a Back function, and it is growing. I also think this is terrible, but I don't seem to get how it can be improved: 

If you need any more information, please let me know. I removed some very repetitive code to shorten my question so it would fit better and be more easily reviewable, but the gist of it is the same. What I am mainly looking for is whether I am using the MVVM model correctly, but I am sure there are things that can be improved as well. 

Now, instead of iterating through both lists for every character, you can just get the character you need to translate and call, for example, . This will (theoretically) reduce the time needed to run your code drastically, as map access is \$O(1)\$ (unless there are hash collisions), while iterating through a list is \$O(n)\$. However, as Klitos Kyriacou noted in the comments, the actual performance and theoretical performance are not necessarily the same. 

This is written using C# 5, so please don't mention any C# 6 enhancements. All other comments are welcome. 

Your does absolutely nothing except make this difficult to read. Even the compiler knows it does nothing and compiles it away. Just write this like: 

Continuing with my web-based checkers game, this question is about the actual playing system. I'll ask for a review on my UI system in the next post. First, my BoardController.cs. Note that I have references to a class here and in other files. I consider this part of the UI, and will post it later. In fact, that is part of the reason I want a dedicated UI post--so it is up front and center. 

Avoid instantiating an instance of in a method (at least you didn't scope it in the loop!). instances should almost always be placed in class scope to reduce the chance of getting the same value for every clock tick. seeds itself with the current time when it is instantiated, and the value produced is completely dependent on the seed. 

Excess spaces don't do anything except make your eye scan more of the page to find the next statement. Data Your data looks awful long and similar. Is there any official source you could pull it from instead of hard-coding it? If there isn't, why don't you set up a separate JSON file for maintaining the data that your program reads from? Footnote "Child" in plural is "Children", not "Childs". 

This control uses four converters. Two of them convert the given to the comboboxes' to a list of localized strings, and only convert one-way. The other two take the selected item, which is now a string, and convert it back to the specific enum type used by the combobox. This is used to bind the selected item to a value in the view model that more accurately represents the selection; these latter ones must work in both directions. These are uncomfortably similar, but I am not sure how to reduce the similarities: 

The modifier is now unnecessary. Because this method is called asynchronously, the parser will still run asynchronously, but the resolver cannot start until the parse task completes.