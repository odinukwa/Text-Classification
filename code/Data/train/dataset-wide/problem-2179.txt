tl;dr - Currently you have a notes table, a user table, and an "allowed to see" table ... which is fine. Consider a "public flag" and adding a "not allowed to see" table. Your approach looks fine to me. Alternately, you could have an additional column on your NOTE table called "is_public" ... if that is set, then the note is a public note and available for everyone to see (thus avoiding your 1000*1000 scenario) ... also, you could have one final "exclusion" table so that a person could make a note public but then pick specific people who should NOT be able to see it. I'm not advocating one way or the other, since I think both are perfectly fine to use. You do need to make sure your join tables are properly indexed, though, otherwise queries will start to get slow. Frisbee has one important bit in his answer - your UserNotes table does not need an ID of it's own.. Join tables usually just have the PK as the composite set of IDs.. (so PK would be UserID/NoteID) 

Direction: I would definitly recommand this step by step tutorial that may point you to the right direction. This is the one I used when setting up similar config. You can adapt it to your needs eyes wide open. Multiple PgPool: The tutorial seems long (and it is: 6 parts!) but the part related to setting up multiple Pgpool is less than half one of 6 parts (see part 5 and 6). Even if I could consider setting up pgpool as a pain, objectively, this part is not the worth (consisting in setting up ip arping and watchdog). If you have already been through the rest for configuring one pgpool and stream or wal replication that will not be a problem. Decentralized or not: This may be only based opinion, but if I had to setup pgpool redondancy (I did not), I would prefer placing pgpools along postgresql servers in order to simplify my setup and make the whole thing accessible from outside "as if" it was a simple pgsql server. App and database layers stay good at what they are supposed to do and could stay technically "agnostic" to ascendant/descendant layer. 

Foreign Keys in general (not just composite) MUST point to a UNIQUE KEY of some sort in another table. If they did not, there would be no relational data integrity. This is complaining because, while you have a unique key on (id) .. you do NOT have a unique key on (id, num).. Thus, as far as the DB is concerned, the pair (id, num) is not GUARANTEED to be unique. Us, as humans, can figure out it will be unique, but I'm sure there would be a lot of additional code they would have to add to make Postgres smart enough to see that "oh hey .. id is supposed to be unique, so id,num should also be unique" .. I would be highly surprised if they added that code when all you have to do is create another unique index on the two columns to fix the problem. Just to be clear, the code they would have to add wouldn't be just this simple case... it would have to handle all cases, even ones where the foreign key is on 4+ columns, etc.. I'm sure the logic would be quite complex. 

Old post, but as I have just been through the pain of configuring pgpool, and have encountered similar problems, I'll answer here. I have exactly the same setup, but I made the choice to go through this excellent tutorial (in 6 parts ouch). It intends to build a full pgpool/pgsql HA infrastructure, where there is no single point failure with one pgpool server, as two pgpool are installed along two postgresql primary and standby servers in streaming replication. Anyway it is quite easy to adapt in order to keep pgpool one one separate server like I did. Regarding our problem here, I think it could be related to an incomplete primary/standby setup. And anyone having this problem shall try to setup streaming replication at postgresql level before trying to attach new node with pgpool (particularly when you have a database that is not empty). In I would check section on both servers and make sure that the standby server has . Make sure also that you have correct file on standby server. 

If you have archiving of WAL files already on, there should be no need to restart the primary db server.. If WAL archiving is NOT already turned on, then you might have to restart the server to have the configuration change be active. (Looking at the documentation, I believe issuing a is good enough for archiving .. but the postgresql.conf file may specifically say "changing this setting requires a restart") The only other requirement is that you issue a and (neither of which require a db service interruption). The PITR backup will be valid STARTING from the point of your backup.. (As in, you will not be able to recover to a point BEFORE you issue unless you have another backup from earlier). Start the backup .. perform a file-level backup of all db files .. stop the backup .. perform a file-level backup of the pg_xlog files ... you're done (with the backup process). To restore, you need to restore all the files you just backed up (plus any additional WAL files that were generated since you ran the backup) and create a recovery.conf file before starting the server.. I won't go through all the details, as you are obviously already looking through the documentation on it. :)