Try-resource blocks ensure that the resource is closed properly even if the block terminates early due to exceptions, , or statements. They wrap the call to in a block and re-throw any occurring exception (if any). Can we copy arrays less often? What your implementation does in every recursive invocation is to 

Complexity Your implementation seems overly complicated and suffers from a number of unnecessary limitations (see first point in the section above). What about this: 

Make the code flow of branches based on mutually exclusive conditions mutually exclusive In the above code the conditions and cannot both be true since isn't altered between them. To make this obvious to the reader and the compiler (though a good one should find that optimization itself), you should use mutually exclusive statements: 

In your program the user of your program enters a number, stores it in the variable which is later handed to . If is outside of the range specified above, the program behaviour is undefined. In theory that means the function may perform arbitrary operations for these cases. In practice it means that you can't rely on its return value in these cases. As an example, the specification in the manual allows the implementation of to truncate its input value to the least significant 8 bits (after checking for ) and looks up the character class in a table of length 256 (which is a sensible and realistic implementation because there are 256 different values); in that case an input value 256 would be transformed and then truncated to (256 + 48) % 256 = 48 which is the ASCII code of a digit character even though 256 is not between 0 and 9. 

On all 32- and 64-bit platforms you just saved bytes (which you could use to increase again if that is a concern). , and are indexes of plain arrays. Therefore they should have type , which is the type meant to reflect the size or position of things in memory. 

SetCommTimeouts again - senseless code. this api simply send control code to device on which file open. usually only serial controller driver handle this ioctl. the npfs.sys, which implement pipes - not understand and not support this ioctl. driver return to you ( mapped to win32 error) but you not check for errors here. 

then reallocate caller supplied buffer - this is very bad idea. for reallocate you need exactly know how caller allocate buffer. you must add to interface contract - how caller must allocate initial buffer and free final. which concrete routine use. say for example caller must allocate initial buffer with and free with . but nobody do this. usual used 2 ways: 

another way - use for buffer. windows let reserve memory space. we can reserve tens of megabytes how minimum. this operation not allocate any memory but simply mark memory region as reserved. then we can already commit memory to region begin. when, after read, will be not enough committed memory - we commit more and so on. advantage - we from begin will be have contiguous memory - we never will be need copy/move/reallocate memory with this way. this solution is better when we assume big enough final data. example: 

you not need handle this at all. return number of bytes read. and you need use it. no any difference what bytes you read. 

here - in/out parameter, but in only - if you reallocate user buffer - you must return new buffer size to user. may be next signature: 

but main question - are you need Contiguous Memory buffer at all ? for what you need cmd output ? for send it to remote system, display it in interface ? for this not need. after you read some data from cmd in fixed size buffer - just display this chunk in interface or send to remote system. and begin read new data chunk. of course you need absolute another interface for this. for parsing cmd output ? for this yes - need Contiguous Memory buffer.. but we never need parse cmd output. for what ?! if say we want list files/folders - we need do this yourself but not run dir command 

The expression inside the loop works because the Python language guarantees left-to-right evaluation (unlike many other languages, e. g. C). 2 Interleaved slices and binary map 

Macro vs. function parameter I don't find the declaration of as a macro very useful. If you want your algorithm to work on sequences of arbitrary numbers you should wrap it in a function and supply that number as a function parameter. 

While is great for formatted output, the look for formatting specifiers carries a computational overhead that doesn't have. Some compilers (like GCC) will perform that optimization automatically for you, if you use a format string literal without format specifiers. Checking whether a characters is in a set of characters In , instead of using a series of disjoint (joint with the operator) equality comparisons, you could much better express your intent and the source character set with : 

If the Brainfuck program happens to have a branch depth greater than , the variable would overflow. It typically overflows to the value -1, which would be caught with a subsequent check, but in C signed integer overflow results in undefined behaviour. That means the compiler may assume that overflow never happens and optimize the negative check to always be false, which would leave your program in a weird state. If you decide to care about that ( is 2^31 which would require a program of at least 2 GiB, all , to trigger the bug on modern architectures after all), there are basically two approaches: 

Provide some debugging info to the programmer using your interpreter It might be helpful for the user to know where in the program a parser error occurred, so you should keep track of the amount of bytes read so far: 

That way the error message would reflect the actual buffer size in case was redefined. Since the argument list of is variadic and doesn't carry type information, it would be better yet to not make assumptions on the width of the integer type of . What if someone defined to be larger than ? The best course of action would be to force into the type (more about that later). 

Once we have all of that, we can rip out the entirety of the click functions, replacing them a simple function (containing the previous code blocks). Since we are now concerned about clicking the done button first, a little code is needed to set that variable. One final note: the object was not needed, so I removed it and renamed the / variables. Working Fiddle: $URL$ 

Variables and parameters should not be capitalized unless they represent a class. As such, the parameter in should be . 

But having a list is just fine. Not knowing anything else about your requirements, I would leave it the way it is. The thing that really sticks out to me in your code is the use of a callback as a parameter in . Since this function is not asyncronous, I would ditch the callback and either log the error directly to the console or just throw the error and let it break the build. If you really want to provide a mechanism for reporting configuration errors to the user, then rename "callback" to something akin to "errorHandler". The use of the name "callback" usually signifies a function that will be executed once and only once, will be executed when the function has completed, and will not return a completed value but instead pass the value as an argument to the function. Also, I find it surprising that you do not log the time to the output of the file or console logger. Not a big deal of cource, it just stuck out. 

It's not so horrible. You managed to cache your jQuery selectors, which is more than a lot of people can say. Good job there. 

Acknowledging the state machine, look at the "want"/"want again" button. The text will always say "I want to do it again" after the done button has clicked. Essentially we can boil it down to this: 

Regular expressions are tough to read (human wise). As such, if you have a gnarly reg-ex in your code (), you should comment what it does. Furthermore, using regular expressions to check the total length of the string is inefficient and not necessary here, since you already have to check the length to report an accurate error message. As such, consider validating the username and password like this: 

ansi function usage. such as CreateProcessA this is very bad. windows is unicode (utf-8) system. almost all api implemented as unicode. the ansi (A) api - is shell over unicode (W) api. the A shell convert input ansi strings to unicode, call W api and finally convert out unicode strings to ansi. this is very not efficient. more bad that use ansi strings simply wrong by design. ansi code page is not invariant. it different on different systems. if you hardcode some ansi string in code, which use characters > 0x80 - you got different unicode strings after convert, on different systems. finally not any unicode string can be converted to the current ansi code page. use ansi code page for cmd is wrong. cmd use for pipe input/output not ansi but oem code page. this is different code pages. when cmd read multi-byte string from stdin file - he convert it to unicode via with . and when he output something to stdout file - he translate unicode string to multi-byte via with . so until he output characters in range you not view different. but if will be say "not english" file name in output, or you pass some command with "not english" file name - will be error - because you and cmd use different code pages for translation. you pass him ansi but he wait oem. he pass to you oem strings, but you wait ansi. also note about inherited handles - begin from vista better use also with for restrict list of handles to be inherited by the child process - not all inheritable handles, but only one pipe handle. yes one but not two as you use. 

again bad and wrong. for what you create 2 pipe pairs ?? when 1 pipe pair only need. one pipe handle in you process and one connected pipe end in cmd. pipe must be duplex. what you write to this pipe end in self process - will be read in cmd. what cmd write to self handle - you read via handle in self process. so not need additional pipe pair. next - always need use asynchronous pipes and io here. synchronous is not efficient and can deadlock.