In Scala, never use unless some API requires it of you; use instead. If you have to interface with an API that returns , convert the result into an . As long as you do that, you can ignore checks, for they'll always be errors: you got a from some code that shouldn't be producing it, or you forgot to convert some return value to , or else you didn't even know you had to. Use or -- seems better suited, but either will do with the proper conditionals. Also, do not use -- use . Yeah, it looks weird, but / is idiomatic, and faster. There's a function that is used for parameter validation. Either or will do. 

Most of it has already sorted out, now you can catch the event and perform whatever action you want. My advice for sending out emails would be to queue emails instead of sending them in real time, this will decrease the response time since the codes will no longer poll for email to be dispatched 

You should reconsider the responsibilities of class , too many responsibilities may lead to a lot of dependencies in many cases. It is quite possible that this class is doing a lot of work that it should not, for example populating object with sales reports, earnings reports, or activating user, checking activation status etc. It is not clear in your question but looking at the names of dependencies it looks like it does a lot of checking and population, you should consider moving respective codes to respective repositories and also refactor the service object into separate classes. This will create a spreaded hierarchy like this: 

If and in your code is the same and you supposed to call instead of in the inner loop then your code can be significantly simplified: 

This is the same as or if you really want to capture first symbol: . This means digit or... (suddenly) digit. So this group can be simplified to . The pattern ends with which means an input string can have more chars after five digits and will be matched. Add end-of-string anchor () to the end of the pattern. So final pattern will be 

the is redundant since at this moment you already know that it is because is . So the condition can be simplified to 

Now, instead of injecting , , , into and then injecting into controller you can inject and into controller with all of their respective dependencies. A couple of them looks like they can be defined as a relation. You can, for example, define as a relation on which in a typical case should be a one-to-one relationship. This should sort out the dependencies quite a bit. Main point to take home is that you should re-evaluate the responsibilities of classes and determine which object should be responsible for what action. as a basic rule of thumb, all data fetching and storing should be a responsibility of repository and all data manipulation and logical decisions should be a responsibility of a service object. If a service object requires more than one repository as a dependency then step back and check if the manipulation of data from second repo should really be a responsibility of service object ? 

As it is WPF code you should use MVVM and shouldn't populate through code-behind. Use of 'es with binding in XAML. 

I don't understand how can be a subclass of . Authority is an attribute of user and not user itself. The same applies to . In my opinion it is bad to keep users related to specific group inside the group. You should take a look at databases developing where there is the first normal form according to which you need separate objects that will connect and . And I see you have the class for this â€“ . So proceed completely with it removing list of users from the . The previous point in fact is even more important since groups contains related users and users contain related groups... In my opinion it not just can be reorganized, it have to be. 

One could also keep a , then either use it alone when computing (instead of zipping stuff), or skip that altogether and put that computation on -- incurring the cost of computation O(nlogn) times instead of O(n) times. It would make the code shorter, but whether it would be faster or not is something I'd leave to a benchmark with a real application -- I'm guessing it would depend on actual sizes for . So, let's talk a bit about performance. Before Scala 2.10, if you want performance you should avoid methods added through implicits on critical paths. The code you wrote will probably get inlined by JIT. You can also reduce the number of computations by pre-computing , and if you make that , then you don't need . More specifically, views are not guarantees of speed, particularly if the computations are light, such as here. I'd not use them at all, unless I'm specifically optimizing the code. Doing a fixed size of multiple passes on small data structures is often not a problem. You are not changing the complexity, just losing memory locality. If the data is bigger, you can incur in gc overheads, which are more substantial. If maximum performance is required, just drop immutability and go to mutable arrays. Finally, is faster on than -- and, in this particular case, a would be way faster. Call it , however, since is a general method on traversables, while set's apply is a fundamental operation. If one of them is less than optimized, it will be . This is the most idiomatic beginner's code I have ever seen... do you come from another functional language? 

Looking on this lines some people can say that omitting curly braces is very very very bad. Although I don't mind to place them for every I decided to go away from this "rule" some years ago. I totally understand what problems curly braces should prevent but I need to say that I never had any issues with s without them. So it is just a matter of taste. But you can use them and if you feel you are not experienced enough it probably will be better. 

You have a lot of code duplication. As a first step, your code should be rewritten somehow like that: 

Part of the problem is all the exceptions. There are better ways of handling exceptions, such as Scalaz Validation or Lift's Box. Scala itself comes with , which isn't particularly flexible. On the other hand, you are not returning anything, which actually turns the whole code into a reverse : you either have or . Now, the test itself, except for checking for nulls, has a name in Scala: . Only it will not tell you what the problem was. I can think of two ways of handling it. The first is just a small improvement on your pattern matching: 

Also I recommend to extract all subconditions to methods with appropriate names. It will make your code much more easy to read and understand. 

Also please place each property of a control on separate line in XAML because it is very difficult to read the code where lines go far to the right. 

It is a matter of taste but it is more common for C# to place opening curly braces on the next line: 

Looks like C-style. If method returns enum return enum. Define a field in like and return it. And then compare result in all s with rather than with zero. Do this for all methods where at now you return 0 as . 

I hope this will give you at least an idea to get started with. I, for one, am really happy about your decision to go pro. 

There are many ways you can refactor this method but since you are using Laravel things are pretty easy. Here is my attempt on refactoring (I'd rather call it re-writing) this method. First of all, this controller is overloaded with so many responsibilities, a controllers sole job should only be to accept an , defer the execution to responsible object and deliver an , that is all a controller need to do. so lets refactor it first. Defer execution to service class I'd create a service class with name and inject it into (or whatever you call it in your case), then on I'd create a method named 

I make conclusion that is invalid. If you want to compare string on equality ignoring case you should use : 

you don't need since the provides method which doesn't require additional memory allocation. I recommend to use for all variables where the type is obvious from the right part of expression. I hope you'll agree that 

should be rewritten with use of style. You can define either explicit style (with specified ) or implicit one (that will be applied automatically to all controls of the specified type): 

You are concerned about initialization of all characters in the method. I suggest to put all objects of the same type (bandit, knight, etc.) in arrays and then just iterate over them to do game logic: