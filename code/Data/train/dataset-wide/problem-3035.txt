Separating the parser from the factory makes testing easier. You can now test the parser with a mock factory once and each factory without a parser. The factory creates the segment or error message while only the parser deals with the result object. This is separate of concerns at its finest. Because is now passed to you can reuse the same parser (one per factory type) and factories if you like. This also makes testing easier. You can create an abstract factory that implements and as you did with the original parser. Move the regex constant and error message prefix to constructor parameters if all factories work the same. 

Since you'll be using this table format with each conditional block, we'll create a function to build the table cell using the data tables and person. 

Looping over the rows and columns in and is costing a lot of time. You can achieve those effects more efficiently by tracking the possible values available to each cell, row, column, and box. The last three can be modeled using a collection class that knows the cells it contains while each cell knows which groups it belongs to. 

Wow, that's pretty bad and quite unpythonic. :( Edit: Yes, I realize that reimplementing the problem doesn't help with reviewing the original solution. I was hoping to gain some insight on your solution by doing so. If it's utterly unhelpful, downvote and I'll remove the answer. Edit 2: I removed the unnecessary second recursive call. It's shorter but still not very elegant. 

To reiterate Bobby's point about using meaningful names, please consider spelling words with all their vowels in tact. This has several benefits: 

A more complicated but possibly faster solution would be to walk in from both ends simultaneously instead of scanning from left-to-right. This allows you to pick the better swap and do it only when necessary. I started on it, but it quickly got out of hand. 

Given that works solely with files, you can drop from the public method names leaving and , assuming these aren't reserved in vba. It looks like the built-in automatically adds a newline unless you specify the new character position afterwards. If that's easy, e.g. without knowing how long the file currently is, it might be nice to add a method that does so. 

Design Review As the story grows you'll find yourself spending a lot of time tracking down copy-n-paste and errors in the handlers. A lot of the code is repeated with minimal changes: key numbers, scene names, and virtues mostly. Now that you have a representative example for each type of scene it's time to generalize the handler code and move the data behind the logic into the model. The simplest is the menu as there are only two choices (one implemented) with no warnings or virtues. I've removed the explicit keys since you're using numbers and it shortens the code. 

I highly recommend Java Concurrency in Practice by Brian Goetz et al. This will give you a solid foundation for building multi-threaded Java applications. The biggest problem with is that it is not thread-safe. You must synchronize all read and write operations to be certain to see the latest values for fields. This doesn't mean you have to lock the structure the entire time. This is explained far better in the book than I can here. The short of it is that without synchronization via memory barriers, the JVM is free to cache values read in one thread and miss writes happening in another. 

Style Variables and functions (except constructors) in JavaScript are normally written in with a leading lowercase letter. It's not mandatory, but you'll find it easier to work with others if you follow a language's conventions. There are many guides out there, but I mostly follow Google's JavaScript Style Guide. Some of the variables do not change once set. These should use to denote that they are constants and probably assigned at the top. Another point in the guide is to surround all operators and keywords with a space. Omitting the space between , , etc. and the opening parenthesis makes it harder to skim without syntax highlighting. You can omit comments that merely restate the code in prose. At best they waste the readers time, and at worst they become misleading or incorrect when they aren't changed with the code. Good comments state programmer intent or clarify tricky algorithms. This comment adds no value. 

Now when two calls collide, it will always be for the same counter (e.g. ). Even if they have different new values, the worst that can happen is getting the lower value (perhaps you could pick the larger in your clause). The timestamp isn't necessary, but it's a nice feature. 

This forces to when the birth year isn't a leap year, even if is 5. It should be combined using or logic. 

These are minor changes, but they clean up the code a bit. I also renamed to to clarify what it holds. They also cut the running time by more than half. 

Index hashes of the URLs and search for those instead. Using a simple MD5 hash would probably speed up searching with the cost of dealing with false positives (unlikely but possible). Store every URL as a top-level object and add a attribute. This alleviates the need to index or search the collections. While now you need to perform two queries--one for the original URLs and another for the redirected URLs--this could end up being faster if only a small percentage of URLs are redirects. Here's some psuedocode to clarify what I mean: 

Wow, that's a lot of work--too much for a single function. Let's simplify it by extracting functions for emitting the help text and formatting the message. 

While it doesn't address the nested try-catch blocks, it does move them out of the original loop which may improve that method's readability. At least now this new method does one logical thing: mark the job completed or roll it back. That your original code s when a unit of work cannot be rolled back makes me suspect that the method should actually throw an exception in this case. 

SpellCheck You make a good effort at breaking up the methods and separating concerns, but I would take it a step further. The methods that build alternate spellings should not be responsible for checking the dictionary. Instead, combine all misspellings into a single list and search the dictionary in one place. This also allows you to remove duplicates and avoid wasted lookups. I would also completely separate all output, possibly to a new UI class to allow reuse. You did pretty well here, but should receive the list of suggestions instead of calling itself. 

The main issue here is that everything synchronizes on the restaurant object. This means that the chef cannot prepare food while the client is placing an order, waiters cannot serve while the chef is cooking, etc. The first step would be to add s to and let them manage all of the calls to and for you. You'd need one queue of orders that waiters place and chefs take and another for food that chefs place and waiters take. When a calls on the order queue, it will block until there is an order available. A calling on the same queue will block until there is room in the queue. You can make the queues bounded (maximum size) or unbounded. You might even create a queue to hold the s waiting to place orders. s would the food and client queues in their loop so they don't wait forever for food to be ready when they haven't even placed any orders yet. 

Clarity For the most part your code is pretty clean. Once you make the names more expressive it would be pretty easy to see what it does. Here are a few points: 

Sorry, a deeper review will have to wait til I'm not on my phone. I will say that my gut says a recursive approach will yield a cleaner solution. Start with clean and clear and only refractor once you have good test coverage and can identify a measurable problem. 

And seriously, you're not saving yourself any time by omitting vowels at random. In fact, it probably takes longer as you have to keep correcting yourself when you type . 

Store the current stations into local variables to avoid having to read and many times. Also, when you name variables identically except for and (unavoidable in this method), don't hide the numbers in the middle of the names. Finally, since all these time-based local variables are for line X and track minimum times, drop and from their names. 

You don't need the join on since you can compare the user IDs in the question directly. Remove that join and in the where clause replace 

Now you can pass one of the constants to which will forward it to and greatly simplify the code at the cost of exposing those constants. You could still provide the property-specific one-liners, though. 

I would perform the same encapsulation with building and managing the nodes from the . Miscellaneous 

For safety, I'd recommend saving and restoring in the module's and functions. If you don't, any exception thrown in the test will leave the mock in place. Mocking AJAX While this does result in a lot of boilerplate sometimes, you can use Sinon's fake server to mock the AJAX responses. The beauty here is that it will match up the request to the response to ensure your AJAX calls (URL, data, type, etc.) are all correct and then supplies a canned response. Here's the same test above using a fake server. 

I'm sure someone here can provide a nice proof, but I'm satisfied by examination that it is correct and sufficient. Micro-Optimization The final swap when picking the median is a micro-optimization that moves the pivot into the partition where it would eventually be placed, bypassing a needless comparison with itself. Given the layout before the swap, 

You can use to grab the preceding character and check it against a space, newline, or empty string (the case when the cursor is at the start). But let's not stop there.