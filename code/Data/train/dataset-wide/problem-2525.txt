You should be switching on event loop enum, which means, oh god, you have a three-layer switch. In any case, mp1 basically has an "on" operation and an "off" operation. You should code these up - either add them to mp1's class, or create a new object, or simply write helper functions, etc. This will reduce your inner switch to a much simpler one-line on/off situation, which is very clear and a good use of switch. In general very few lines of code should happen in switches: they should be functions that do analogous actions, on the same level. mp1 should be I think. 

This question might be more appropriate for programmers or codereview, but, this is what a code review of mine, probably with at least one controversial statement inside somewhere, would go like. Hopefully you will find some advice in here that answers your questions. 1) Make sure you want to be using C and not C++ (or Java, Perl...) for whatever you're doing. If you can avoid doing strings in C in real life code, always. Use C++ strings instead. And if you want a sturdy C library to do this in, consider glib (or writing C++ wrappers). 2) If you want to write a full ADT (abstract data type) for strings, follow the usual C paradigm: You should have functions , , and . The init will typically have a and if so cleanup will definitely have . The s I think (not sure) are only safe provided happens first and last, which without an that s would be bad. 3) But in real life I think an ADT for strings, which experienced C developers can program in pretty fluently, will make the code less readable, not more. 4) Always work on the stack when possible. is preferable to dynamic strings when possible, and it's possible more than most developers think. A few wasted bytes from safely overestimating is worth avoiding a crash or leak from dynamic memory usage. And your function from its signature looks like it will accept a stack variable as its first argument, then bam! realloc. If you're going to do something sneaky like this, it pretty much has to be with an ADT you wrote via a pattern similar to (2). 5) Along those lines, the usual way to pass a string to a function is so the caller is responsible for memory management - and in particular gets to choose whether it's stack or heap - and the inside of the function just respects those parameters passed. If you braek this I strongly recommend the ADT pattern in (2). 

There's something wrong with each of them, but I think what's wrong with the first one is more acceptable. The first has the defect that it requires unique prime factorization and the fact that . That's a pretty well-known fact, but the problem was "if 3 then fizz, if 5 then buzz, if both then fizzbuzz." The problem says "if both." so write "both", which means "". You used a math trick to condense this expression when the original problem did no such thing, so you lost faithfulness to the original problem. Simplicity of the math trick is besides the point, in fact. The second one is terrible, except I can think of one strength. Character-by-character string manipulation induces character-by-character thinking. Why did it drag me down into this sort of analysis? It's far easier to type and think "FizzBuzz" than it is to ponder on how "FizzBuzz" is a beautiful thing, made up of its constituent parts. Strings lend themselves to annoying off by one errors. I.e., where does the new line go now? It works correctly but I guarantee you it requires thought to write or evaluate. The second program is more expandable. FizzBuzzBazz would be a much easier program to write given the work in problem 2. It's not quite data-driven, but it would very easy to accept an Array of Strings corresponding to prime factors 3,5,7,11... and turn the second program into a loop. Also note that the problem statement in the more general case requires thinking about string concatenation. In general, I condone data-driven generalizations, so if the input to the program were a map of prime numbers to Strings, and it were implemented with a loop instead of an extra if block, I might call it clever but in the best of ways - it solves a more general problem, and data drives the magic numbers, and therefore has better separation of logic from appearance. For the kicker, also note that the first is a step away from generalization. So, it's applies to oranges: Invoking , or writing character-wise code that is halfway on the way to being more general. For what it's worth, I would prefer the first of the two. 

Adding quantifier also has positive effect on the number of steps taken to match characters when the characters in the character class are consecutive/adjacent to each other. Here's the demo on RegEx101, without quantifierScreenshot and with quantifierscreenshot applied on the same data. Note that in these demos, PHP is selected as the steps taken to match is not shown for JavaScript. Also, the regex is different, it also contains lowercase counterparts of those special characters as flag is not working with PHP and don't want to apply (Unicode) flag as it is not supported in JavaScript. These demos are created only to show difference when is applied on character class. The effect should be similar in JavaScript. Note that the (two underscores) are redundant as is already added in character class and with flag it'll remove all occurrences. Method Chaining As returns a string, any other string method can be called on it. Multiple calls to can be chained. 

where - boolean can be passed to the function to open or close. There is no need to change the as zero-width elements are not visible. There is no need to iterate over multiple elements and bind the event individually. jQuery does that when working on selectors that selects multiple elements. 

Same logic can be used, in your case. As will add the glue between the elements of array, the prefix and suffix need to be concatenated. The selector can be created using 

As pointed out by Heslacher, you're repeating the code. The value of can be cached and used in following statements. To get the value of param value, use RegEx. You're using which will fail if there are other params followed by for example, . 

Note that and in the diagram refer to respective capturing group. Demo on RegEx101 Although, this answer only explains about one RegEx, other RegExes can be modified in the similar way. 

Then, to disable/enable these buttons, they can be referenced. HTML5 attributes HTML5's custom attribute can be used to store custom data on HTML elements. 

Here's live demo of regex The regex can be further improved by using character class which will make the matches faster than OR conditions 

As can be seen from this jsperf, is faster than . So, your code is already efficient and expressive. 

: Optional or sign before number : Match one or more numbers : Optional decimal point. denotes non-capturing group. flag: To get all matches 

Number of functions You're creating two functions per image one to handle mouseenter event and other to handle mouseout event. If you look at the mouseenter handler of all the images, you'll notice that they are all same. A quick improvement will be to use a single function to handle mouse enter event of all the images. This will reduce the number of functions from to where is the number of images. Is there any way to reduce this to a single function? Event binding Don't use inline event handlers. Use jQuery method to bind event. See onclick=“” vs event handler Naming Using numbers as the suffix to variables/functions means you're repeating same/similar code. Also, the names are not clear. Does refer to the function which should be called when hovering second time? Useless code The body of is completely useless. It is just setting the attribute value of the image to the same value which is provided in HTML. This can be removed. Alternative: You can use to bind mouseenter and mouseleave events on images. On mouseenter, change the image to the desired image and when mouseleave revert it back to the original. Also, add a common class to all the images and use this to bind event on them.