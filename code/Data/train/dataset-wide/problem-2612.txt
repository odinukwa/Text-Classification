Then again, inside a thread or a process, you can employ the green threads/fibers/JS-esque multithreading approach again - if you feel the need for it, e.g. because of easy reasoning about concurrency issues. 

Elaborating on the PSR-0 specification The spec defines mandatory requirements your autoloader must fulfill. They provide example inputs your autoloader must accept: 

After desugaring, it is now apparent that this is the reason why will hang on the second iteration. forEachParallel vs. forEachSequential 

This is not quite right since JavaScript (i.e. ECMAScript) is not multi-threaded. Simply speaking, the VM executing the code has a queue from which it dequeues an action (e.g. "run this file") and executes it. This is done ad infinitum. It runs every dequeued element either to completion, to a (in generator functions), an (in async functions) or an (on a generator function). The only way your code can be interfered with (preempted) is using these statements. But even then no parallelism is created, the VM just switches the current queue item it is processing, e.g. to the caller of when the generator function just ed a value. I recommend you to read Concurrency model and Event Loop on MDN, which explains it in more detail and formally better than I can off the top of my head :) The effects of the execution model Endless loops cannot be avoided The following code will print and then hang in the endless loop. 

Several people and I explored this back then in a Flow-Based-Programming implementation for JS: $URL$ I'd consider the approach valid for small environments, but would prefer a different way on the global layer, e.g. 

While this may seem "decently normalized", it's not. As you said yourself, there will be a lot of (redundant) NULL values, but also, relationships will not be enforced correctly, as this schema allows for duplicate records for any combination of Post/Group/Link and Tag. For instance, you could have two tagmap records with the same and . Now, while you could add a compound key consisting of PostID, GroupID, LinkID, and TagID, then you have another problem: a single record can contain more than one (non-tag) Post/Group/Link relation. e.g. a tagmap record with = 1, = 1, AND = 1. This can lead to update anomalies. See Second normal form. A normalized solution would be to have three separate tag-relation tables as abuzittin gillifirca suggested: , , and . Doing so will eliminate all the redundant NULL values and allow you to enforce relations correctly. Having said that, I'm guessing you came up with this design, because you want to use a single query to fetch all entities assigned to one or more tags. You can still do this with multiple tag-relation tables like so: 

Since RequireJS invokes the module, it would be problematic to construct dynamically. There's no good way of creating more than one instance of your view â€“ probably not a problem. The View is tightly bound to a specific DOM structure. This means it will require extra code to make your View responsive. e.g. a small volume control for mouses (desktop) and a big one for fingers (mobile). 

Use CSS classes elements that share the same animations. This way you can just fetch all the elements that need to be animated with a single . e.g. Instead of using jQuery's animation methods, use CSS transitions. This will make your code simpler, and you know you're using the browser's native animation rendering. 

is a managed resource so you don't need any of that or hogwash. Simply call once you are done using it and call it a day (after all that's what the statement does too). Only implement the interface if you really need to move the disposing responsibility to the user of the class (you probably don't) and if you do your method should simply be 

and call it with the tolerance squared and you'll get the same result in almost half the time. Note that your special function is not used anymore and can now be removed. Also note that I changed the order in which the list is populated in the last three lines. This adds the indices in order and allows you to remove the sorting step in line 83 which should also save you some time. 

inside the loop. is of type so calling on that would fall back to (as Anthony Pegram already mentioned in the comments). However, the query turns that into an so will indeed iterate the whole enumerable in every iteration of the loop! Instead keep track of the remaining allowances by decrementing the dictionary (or a copy if you need to keep it). Something like this (untested): 

The first thing striking my eye is that you are taking the square of a vectors magnitude/length. Most frameworks offer a property to get the squared length directly (sqrMagnitude in the case of unity). The reason that this property exists is that calculating the length of a vector involves taking a square root and if you need that squared you can skip both taking the square root and the squaring. 

Move the PDO object to a constructor argument (see below) so you're not violating the Law of Demeter (see #1 and 2 here) Remove altogether and simply return the result from the method in which it's built. Break this into smaller, more meaningful methods based on responsibility (see #4 below) Create and methods with optional parameters 

This will make sure that sure only one $db is ever created. Here's the source code from Pimple's method for demonstration purposes: 

Likely, just has a single default state, but if you ever want to construct this object yourself, you should consider return-/exporting the definition from your module, rather than returning an instance of it. A simple solution here is to simply return the result of . Use a template. In the future, you can use additional templates to support other platforms. e.g. start with a desktop template, later on create a mobile template, and choose the template dynamically at runtime based on the environment. 

I think this is fine for something as simple as a volume control; however, there are some limitations to at least be aware of: 

Looks pretty good to me. Regarding , definitely don't put this in its own statement, because if there's a problem with the earlier code, the connection might not get closed. I know you're not using Python 3, but ss an alternative, you might consider using the statement and let Python handle the closing for you. See $URL$ (end of section) and $URL$ Your code might look like this: 

You could simplify this even further by using a single CSS class for all elements that need animating. e.g. Also, if there are any animations that are triggered by mousehover, you could do all the animation in CSS with the pseudo-selector. Finally, make sure the CSS transitions you use are compatible with all the browsers you're supporting. 

is of type . That means that you enumerate the whole enumerable every time you call and inside the loop! You could cast the enumerable to something like an array or a list and use or instead of (as Frank suggested). But since you are only using the loop variable to access elements of the enumerable in order you could as well just use foreach: 

Note that the algorithm only ever compares distances never using their actual value. This means that you can speed up your algorithm significantly by directly comparing the squares of the distances instead. This works because the function is monotonic and thus if and only if . This allows to change your function to this: 

This should already give you a significant speed up. The next thing to try is caching everything that won't change between calls to . For example, if the number of bodies doesn't change store the result of in a field and reuse it 

If the masses of the bodies are constant you can cache the product of their masses and the gravitational constant in the constructor too. 

(You don't even need to check the reference for first since you initialize it from the constructor so it should never be null and if it is you have a bug that needs to be fixed rather than swallowed.) All that disposing boilerplate code is only needed if your class holds a reference to an unmanaged resource and in that case managing(!) that unmanaged resource should be the sole responsibility of the class. Never should your class reference multiple unmanaged resources and never ever should it reference both managed and unmanaged resources.