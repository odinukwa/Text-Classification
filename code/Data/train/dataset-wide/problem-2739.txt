and naming variables: When possible, try to use instead of explicitly declaring your variables. The compiler will determine the type for you so you don't have to worry about that. Also give your variables meaningful names. and are not meaningful, better would be and . More reading: 

String.Format Don't concatenate variables with hardcoded values like that, use the String.Format() method instead. Following code: 

This is because you don't validate and/or catch possible exceptions. To capture the input correctly use the Double.TryParse() method: 

There is no magic method in .NET that will know the datatype and magically returns the right parsed value for you. So, creating your own method of parsing and doing manipulation is not a bad thing. This can be improved though. Use a method: I prefere to place code that does a certain manipulation or calculation on variables in a separate method/function. This gives me the ability to reuse the code if necessary and maintaining the code is also easier then looking in chunks of code to change just a small bit (like adding a datatype in your case). switch vs. if/else: When facing a simple check for a value or condition of a variable, an if/else-statement will certainly do. But when you have a list of options for a variable, it's better to use a swicth-statement. Your code not only looks cleaner, it is cleaner and again, easier to maintain. This results in following code: 

Since you don't want to manipulate the objects in the list, but simply want to output them to the screen, use the __toString() method. For this would be: 

As @Nil suggested you should use Stored Procedures for your queries instead of hard-coded queries. The reasons he provided are what I'd also suggest. 

The Evil of Eval I suggest your read following article: The Evil of Eval() in ASP.NET. Here's one of the many reasons: 

I also see you always use the row at index , is this intended or is that where you meant to take the "i-th" row? 

And then do this for the other class as well. This is not the most ideal situation because when you want to change the order of the properties for the output, you'll have to change the method in all the derived classes. There's not magic automated way to do this I believe. 

Can you simplify names like . No offense intended but reading this almost gives me a headache. And this isn't the only one, for example. Try giving methods a descriptive name, as short as possible. 

Note that my tips/code might not be perfect, just trying to make you write better/cleaner code. Hope this helps! ;) Edit: Useful tip from rolfl to reuse the parameters instead of creating new variables in the for loop. The loop will now look like this: 

It looks like overkill using the methods but your code still looks clean, readable and maintainable. It's up to you, use this method or the suggestion from Dan Lyons. 

Double code: Both the and method have a very similar structure. You could refactor the XML-handling in a separate method which you call from the other two. Both would return a double then. 

Now you know you're talking about the box and not mistaking it for some possible rectangle. Don't uppercase field names, use . Also, is not a very good name, choose a name like or . keyword: Use instead of declaring your varibales explicitly, let the compiler decide the type. Your code will also look cleaner: 

The code checks if the current bound item is an item or an alternating item. This is necessary because the binding of the header and footer will also trigger this event. If this is the case, prepare your boolean variable to set the row visible or not. Lastly, get the table row tag using the method and set its visibility to the variable. 

Same goes for displaying the information about the person. It's not a good practice to write it to screen from within this class. Just override the ToString()-method and display this on screen. The FirstChar()-method is there to check if the name exists to take the first character of that name, otherwise return a spacer. 

Now you can still use them the same way like before, and only set the values from within the class. Reading the values is also possible from outside the class. Input validation: One of the first things that struck me is that you never validate user input. Your program will throw a when entering non-numeric input. You'll have to provide some way to catch this. Change following line: 

The answer of mjolka is already showing several good points. Here are some additional remarks: Fields => Properties You're not using the fields outside the class, so why make them public? You have two options, make the fields private or create a property with a private setter. I'd prefer the second choice: 

I don't know if you already knew or tried this but I'm just pointing it out as a possibility. But I agree with you: experimenting with code is fun! :) 

Taking things a bit further I'd make the method an using yield return ... and when needed you can convert it to a when needed. Here, I left out putting the number in a variable as it used only once. 

Edit: Since you have no parameters that have influence on the calculation of the response, here's a method for re-usability: 

Why continue the program when the input is invalid (not numeric)? Check for a numeric value and only continue if the input is a number: 

If you do want to throw an exception, use a try/catch block and a regular Uri constructor. This should be placed in a method and not in the get statement then: 

Naming: Names like , or don't mean anything, not to you, not to others. Use meaningful names for your variables. would become and so on. The keyword: From the C# Programming Guide: 

Note: I use the keyword, but you may choose to use instead. Due to the fact that I let my bool-variables begin with is or has, I always know it's a boolean. 

MsgBox() - MessageBox.Show(): Although is valid, it also comes from the VB era. In the .NET framework there's the method, use that one instead: 

Idon't see why you would want to shorten that piece of code but here's the same result in one line and using a LinQ method-chain instead of query-syntax: 

You also made your method dependent of an , you cannot reuse it. Better would be to rename it to something like and leave out the -line: 

Your constructors don't handle all possible situations. What if I call with mode set to ? When you're overloading constructors, you have to reduce it to one constructor where you handle everything, if this is possible of course. Small example with a regular method: 

Coding/naming conventions: All the information about this can be found in folllowing article: Naming Guidelines. Straight from the documentation: 

And this example is bad code. I stringly suggest you read the article to understand all this and implement the correct way of the singleton pattern. 

Reason: placing selectors in variables is recommended, since overusing selectors can result in poor performance. Everytime you would call a function on , the whole DOM has to be parsed by the browser. This is not the case when you store it in a variable. 

String concatenation like that results in code that is not maintainable and looks ugly. You have other options to achieve the same: String.Format: Use the method to concatenate values, a small example: 

Avoiding : I personally don't like writing code using references. You could rewrite your code for collecting input like this: 

Variable names: Names like , , , don't have a useful meaning, not for you, nor for others who are reading/reviewing your code. Use meaningful names for your variables, this is better for readability and maintainability. 

Update: If you insist on using jQuery, cache the selector in a variable and re-use the variable. Overusing selectors can result in poor performance and since you're using the selector inside a loop this can easily occur. 

You should place the properties in variables and call the variable in the inner if/else statements. Otherwise in every if statement the condition has to step through every property again and again (). Here's how you can do this: 

In the function you are using a parameter , similar to the block of code in the function. You can just call the function from within the function and pass the variable :