My "repository" is a little different. The repository here is above the database technology being used. That way, if you want to change from EF to a webservice or something, you can change that implementation easily without affecting the handler above. Mapper 

All my queries/commands/command queries end up returning IResult because I found throwing exceptions is really expensive. Thus, this lets me deal with any issues. IResult is returned by Command and doesn't return any info about the actual call, so it doesn't violate CQS. Query returns IResult< T > that stores the data. I'll show an example here of the Create Command through the layers. CommandQuery 

After months of going back and forth, I broke down and ended up returning IResult or IResult< T > from all commands/queries. The IResult looks like this: 

If you don't mind me asking, any reason you want to register the DbContext directly? I know .NET Core seems to want you to do that, but I don't like IoC containers deciding when to leave open or close my DB connections. Insetead, I'd just do IFooDbContextFactory and have that use a "CreateAsync" method. This factory can take your IAppSettings or IDbContextSettings or something to get the connection string. Then you can call the provider async just fine and in your specific code you'd just do: 

I find if you do this in chunks together (all these classes, minus the controller) are all in the same folder as they are all related, that coding the mapping by hand isn't that big of a deal. Though, I made this generic so you could setup your own that just used AutoMapper or whatever instead. Invalidate Cache 

is a function from the standard library that takes a range of elements, applies a on every element and if the condition is satisfied, copies the element to some output. In C++, the word can take many strange shapes. My range here is the standard input! That's a range? Well, you can present it as such. This code will prompt the user to input some strings. Every time the user presses , that's a new string in the range. The end of the range is when the user uses the OS-specific end-of-input command, e.g. Ctrl-D in bash or Ctrl-Z in DOS. 

That's the output. That's where elements that satisfy the predicate will but copied. The function is how I tell to call the member function on my . Why do I specify ? That's make little sense. The multiset will keep the elements sorted according to the rules I gave it. It should not keep adding the elements at the beginning! Well, that function is a very generic one. It works for all kinds of container. With a , it would do as I wrote it. But with a or , that is just a hint and will be discarded. On to the predicate: 

Another call to the family. This is a plain copy and it will copy all elements where I tell it to. In this case, all elements will printed to standard output, with a newline in between. They will show up from the longest to the shortest. And we're done. 

Edit The last point here is that Exceptions actually are pretty slow. When I throw an exception, it ends up taking around 150 ms to get the result back. When I switched to not throwing an exception, it would get around 25ms response for the exact same check/data. That is 6 times slower! Thus, avoiding exceptions seems like a really good thing to do! :) 

That way, the rest of those scenarios are being handled by the other decorators so returning an IResult doesn't become cumbersome. At the UI level, I created a ResponseMediator instead that returned IActionResult items. This will handle the IResult and return the appropriate data/status code. i.e. (ICqsMediator is what IMediator used to be) 

Validation The validation decorator will run validation on multiple threads (if you want) and async will not block. I didn't use expressions since a lot of times validation involves multiple properties and has a lot of overhead. The BrokenRule() parameter is the "Relation" and it can be used to tie the rule somewhere on the UI. 

I also work on an e-commerce platform that has tons of data in it. What I've found is that if you have more than a very basic query, write the query yourself. EF speeds up saving records and very basic selects, but as soon as you start doing something a bit complicated, EF will spit out thousands of lines of SQL for something you could have done yourself in 100. You are better off just trying to create the SQL for it and use Dapper or just create an object that you can map directly back to from the query. Use context.Database.SqlQuery(sql, parameters).ToList() and you'll be able to get exactly what you need. Though, naturally, it is going to be way more work on your part since you have to do all the joins manually and type that out, but if you need it to perform, then I would really recommend just typing it out. I've had calls go from 60 seconds down to < 4 by just doing it myself instead of relying on EF. 

Well, I have no shame to say that I just copy-pasted @MORTAL's code for that part. :) That's a , an in-place function that you don't need to write somewhere, you just write exactly where you need it. Apart from the funny syntax, the body is the same as the more mundane but equivalent function. So now we have all palindromes saved and ordered by length order. Let's print them out: 

Good. Now, I have to read in s from the user, decide if they are palindromes and save them in my special container. The following lines of code are quite compressed. It's a single statement that does all what I just described. 

I will add one last thing. The fact that I use a (or ) does mean that this code is doing a bit more work than what you needed given your problem statement. That is, you did not necessarily wanted to keep all the palindromes sorted, you just wanted to know which one was the longest. But I offered this solution as an example to leverage stuff from the standard library that can do a lot of work for you transparently. 

Again, I don't expect you to grasp this fully. Just keep it way in the back of your head and revisit this post in a year... Ok, so I have my custom-made comparator. I can declare my container that will hold the palindromes. As I add s to this container, they will automatically be kept in sorted order by length. But wait, here's an important detail, it's possible that I may have more than one palindrome of the same length! No sweat, use . It does the exact same thing as but allows multiple values where the comparison will say they are equal, i.e. of the same length in our case. 

If you are still reading and your eyes haven't glazed over yet, what are your thoughts? Is this too much? Thanks! 

I have the complete opposite view. Every query is specific to its use case. Today it may be true that you can call the other query but if someone changes its output then your query could be impacted. Maybe the other query gets a permission added to it that yours doesn't have. It is far better to simply build and return exactly what you need and no more. You may be thinking that you aren't reusing any code this way and you would be right. If two UI had the same data on it why would you have two? 

ICommandQueryRetry will cause this to retry general exceptions up to 3 times before failing. For caching, you just add a different interfaces (a few different ones for different timeframes) and it takes care of it for you. 

I've created a "framework" or more of a library for a CQS implementation with a few decorators. Using ASP.NET Core for the front end, I wanted an opinion about how this looks/feels. I changed the default mvc approach and created a Features folder that stores both the Views and Controllers in the same folder. Then each command/query ends up being in its own folder in the implementation. I have the following decorators: Exception/Logging, Retry, Cache, Cache Invalidation, Validation, and Permission. Any input at all is welcomed! This will be along post, but it'll be an interesting read, in my opinion. :) First, CQS = Command Query Separation. Essentially, queries return data and do not modify state and commands modify state but return no data. There is a gray area here where you need to run a command but then return the data (i.e. Queues, Stacks). Thus, i Created a "CommandQuery" for those scenarios where just a command won't be good enough. CQS normally has ICommandHandler<> and IQueryHandler<> interfaces to support decorators. Decorators are classes that can add functionality to these classes without changing them. i.e. The calls are chained. They implement the same interface, but I use SimpleInjector to make those classes run before/after the actual implementation. All code becomes narrow and easy to maintain. Also, you can add more decorators to all commands/queries with one line of code. I tried to follow SOLID through all the layers here with the intention that every piece of code will be unit testable at a high level. The problems being solved inside may end up more difficult than that, but I digress. :) (My mock implementation deals with Digimon World 2... Don't ask) :) Controller 

I offer this code as something to look forward to be able to write in the future, not as something I would want you to come up with right now. What you have is great for someone at your level of C++. The most important aspect of this code is its use of . is a container that keeps its element ordered, even as you add more element to it. It's contents will always kept sorted. By default, will perform it's duties by comparing elements with a plain less-than comparator, i.e. . So, by default, a will keep a bunch of s ordered from the smallest to the greatest. Though that's the default, you can change the comparison function. The standard library already has some options ready for you to use. For example, to keep the s sorted from greatest to smallest, use instead of just . But what we want to do here is keep sorted according to their length, from longest to shortest. The standard library doesn't have something ready made for us but we can follow the example of . It would look like this: 

So, yes, I know that "you shouldn't derive from std containers" but by now it's more of philosophical rule in my mind than a technical one. I've googled again for the one fundamental reason one should never-ever-ever-ever-do-that-ever-ever-ever-or-you-die but couldn't find it. So, if there's nothing fundamentally wrong with the following and if we set aside performance considerations, can I a get a plain-old code review of this: 

There are specific scenarios in my logic where I can easily not throw an exception and have the above layers just check those boolean flags to determine what to show the end user. If a real exception occurs, I can put that on the ErrorMessage property and pull it from there. Looking at CQS, I realized that returning an IResult with this for a command is okay because it isn't returning any information about the actual process. Either it succeeded (IsSuccessful = true) or something bad occurred, meaning I need to show something bad happened to the end user and the command never ran, anyway. I created some helper methods for creating results so coder's don't really care. The only thing that gets added to the main implementation is: 

This way, I don't have to handle any exceptions to change the flow of the code except when a truly exceptional thing happens. It is caught like this in the top level exception decorator handler: 

Since we can route the different verbs to different classes, we can focus on only 1 method at a time per class. I'm using Mediators everywhere so the code looks the same across all classes. I thought this was really the Service Locator anti-pattern, but it isn't because you still know the mediator dependency. I also use async through the entire call stack because Task.CompletedTask, if needed, has very little overhead and not blocking threads is the way to go. ResponseMediator