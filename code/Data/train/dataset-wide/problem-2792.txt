You have implemented dependency injection correctly. is injected into . In terms of the correctness of your example however, pretty much everything else is completely wrong! Don't worry though, we all have to start somewhere, so I will offer some tips. These tips might help you with this example, but if you want to improve, you should probably do some personal training/studying. Pluralsight is a really nice place to start. They have some beginner C# courses that you can do with a free trial. Anyway, on with the code review! 

There is an abstraction that will automatically have any config updates when injected, so you don't need . I believe it is scoped per request, so changes to the config will not affect in-flight requests (you may want to double check this). To deal with updating the , you can write a small, thread safe that will always return the same client for a particular base URL. This would be registered as a singleton, and could be reused for all the clients in your app. 

I recently learned about using fixed point arithmetic on embedded systems without floating point hardware, so I decided to code it. I tried to write in good style, but emphasized speed over style. One hard problem I encountered was to convert the number to a string. I coded up the following in my internal class; the macros aren't leaked to the user. The intent of using macros is so that I could easily make a new function for a data-type of , , and so on, but also have different length of the fractional bits. Unfortunately, my algorithm requires a larger data-type to actually compute the fractional representation, so it's not trivial to make a fractional type for say , as there are no larger types. Also, it fails on signed integers. How is the function? 

Cool question! In addition to t3chb0t's great comments, I would suggest using a instead of a . It has additional support for blocking and bounding so you don't need to poll the queue manually, and you can limit the number of "in-flight" files. This could be used to make sure you don't read too many files into memory at once. 

There is a lot of room for improvement here, both in terms of performance and readability. You should start to worry when you see code forming an arrow shape - there is almost always a nicer way. The solution below is one way of tackling this, and also offers a large performance improvement (around 19.4s to 3.2s on my machine). 

It tends to improve readability to put a space between , , etc and the opening (like so: ), although it is a matter of style. 

This isn't too complicated, so there isn't that much to say. Your code is perfectly clear, but there are a couple things that could be improved. 

Running your demo pretty consistently has this version taking about 100 to 200 ms longer than your version (for about 2900 ms in your version). 

The keys are the first two elements of each list, still in a The values are the 3rd element of each list. 

However, since this function is only one line of code, I personally wouldn't use the function. Code duplication Notice how each block in the if statements look almost identical: 

The point of an interface is to abstract away the implementation details from the client. has the method which publicises exactly what the implementation is. This is called a leaky abstraction. When writing an interface, think about what other implementations might look like. One thing that you do know about all implementations is that they are going to need a file path. An alternative interface might then look something like this 

Generating Permutations In the Haskell snippet you referenced, is generating the a list of all the possible permutations of the numbers 1 through 9. I'm not aware of any nice way of doing this in C# other than hand rolling it. You can write a pretty short generic recursive function to do this. 

However, this version naively creates a new array for every merge. If we instead create a second array at the beginning and simply shuffle data back and forth between arrays, it becomes faster than yours by about 100 to 200 ms on average, and it sometimes reaches the speed of : 

You should probably parse the hex string into a or before working on it. Honestly, I think this is way easier to do using . 

It is a bit strange to use a class for sorting. That your sort function is in a class implies that there's state, which is unexpected. You could use a namespace. 

Interestingly, you are combining table entries with a linked-list. This makes sense from the implementation viewpoint of a hashtable, but for readability's sake, I recommend removing the entirely and simply using an array of in your class. If you don't want to use the built-in class, I still feel it is clearer if you separate these two unrelated pieces of the hashtable. This would require some other changes in the code as well. 

Once you have finished adding all the files to the collection, call , and from the other thread, your while loop becomes: 

The equivalent C# then becomes . Equation Depending on what you are doing, you might want to consider creating an class with a method and override . Failing that, you can at least pull the equation logic out into separate methods. 

Results Using the above short helper methods, you can rewrite your method to be much shorter and more readable. 

is not a builder, it is a factory. It's job is to create instances of . This shouldn't be done in it's constructor because then you need a new factory, each time you want a new . 

Naming is kind of an awkward name. First, the isn't the "program", so it would be better to call it . However, if I'm programming in Swing, I already know what a frame is; just remove the suffix to get . Build the names of GUI components from that. 

Note that this design isn't the best. You still need a constructor, and possibly accessors on the member variables. Also, and might be better as a constructor to , or a static factory function if you prefer that style. 

This is bad. You almost never want to directly include a source file, only header files. Instead, write a Huffman.h file: 

That uses , but if you want to go for a Swing timer (aka you want to use a GUI), then you could do this: 

Note that I have assumed you are wrapping inside a here, however you could choose to make behave similarly to your and return an if that is what your application needs. 

Another thing is that you are performing blocking IO when you call , and you may want to consider using an equivalent instead, freeing up more threads as you are reading. Also can be used instead of creating a . The TPL Dataflow library could be used to achieve something similar, or for a simpler approach that kicks off parallel tasks for each file, you could use something like this: 

should almost always be avoided. Try to return from async methods so they can be awaited by the caller. A should be returned from and have it's method called. 

Going further Insertion sort is a nice sorting algorithm that works for much more than just s; you can sort s, s, or even user-defined objects. Why not generify the function? You could do the following: 

Extracting out the into a variable is fruitless. Also, the naming convention googletest uses is PascalCase for test names (IIRC). Finally, you should use a more descriptive name for the test. Finally, there is one real problem with your unit tests: You never test negative numbers. When you test your code, keep in mind equivalence partitioning. Basically, just split the input into ranges and ensure you test something from each range as well as edge cases. In your specific example, the class consists of two s. A is approximately a real number. The reals go from , so the natural ranges to split into are the negative and positive numbers. So I can partition the interval into: 

EDIT What I think Mat is getting at, is that this solution is localised to this usage, and may not be suitable in an application that frequently needs to generate parallel lines. If this is the only place in your app that you create parallel lines, then keep using it (YAGNI). If however you need to create parallel lines a lot, you could make your implementation a little more general. One way of achieving this could be through extension methods. Consider the following 

Assuming that you do indeed want a mutable triangle class, then you could extract validation into a method and re-use it from your constructor and property setters like so.