I think using that form of the import will let you drop the line where you instantiate the Publisher. I like to put my mainline code in a main() routine right after the imports so it's clear where the work begins 

The idea is that rather than embedding your data in the code, you should structure it in a meaningful way, then use generic code to present the data from the structures in the way you want the player to see it. I think you're on the right track with your Creature and Item classes. I think maybe you want more classes like Place (or Room), Container (to represent boxes, chests, hidey holes, etc.). If you have to write specific logic for each step in the story, your game is going to be very linear and you'll be limited in how much branching and looping you can manage. On the other hand, if your game is just a network of Places connected to each other with Items, Containers, other Creatures and such scattered throughout for the Hero to encounter and either fight or befriend, and the Hero is free to wander from Place to Place backward and forward and in loops, then the game becomes much less predictable and more interesting. What would the code look like to process such a network of Places, Items, Containers, Creatures, and whatever else you can dream up? 

Use the returned by Edit: my original response directed the OP to use library to parse JSON-formatted text. That was incorrect, as the returned data was already parsed by library. The returned from your function is a of the key-value data shown in your "Results for from " section. Thus, you just need to access the appropriate key of the (specifically, the keys in the of the returned data). To access the and fields you were looking for, they are under the key: 

is undoing the work did for you (which is the entire reason for using ). Instead, you should do this: 

Because everything you want is under the subdictionary, I would just reference it () at the end of the call). Here are the combined suggested modifications (using the list that returns, and using ): 

Seems like that might cut the time in the final loop by almost 50%. The extraction from match_iter doesn't change, so it will take the same amount of time. The append will take about the same amount of time as one of the appends you're already doing. Since two appends will be eliminated, I think the time they're taking will go away. 

So, let's say you build a website that uses this class for storing data. Then, one evening, you and I both visit the website at the same time. We both hit the button that opens the table and reads the data into memory. Now there are two copies of the data in memory -- one in the page you're looking at, one in the page I'm looking at. You add a record. The "insert" function adds your new record and writes the file to disk. Now I update a record. But the copy of the data in my window doesn't include the record you just added. So when my instance of the code hits the statement file_put_contents(...), what happens to the record you just inserted? This is the sort of reason it's recommended to use real database engines like sqlite or mysql. They're designed to serialize calls and protect users from each other so they can't overwrite or corrupt each other's data. 

That means there are (16 choose 4) combination = 1820 possible input combinations, much less than 65,536 (or 16 * 15 * 14 * 13 = 43,680 permutations if order matters). However, that knowledge does not change the algorithm or opportunity to improve the performance. But what about the differences between the algorithms? I ran the same test inputs (including identical random data) against 3 other functions: your (but sans checking for ); my (sans checking for ); and finally, my (also sans checking for ) but following my suggestion and returning more than just or . Here are the CPU times (in seconds): 

Not only does this tell us if any "bit columns" are all , it also tells us which bit column is all (any bits that are in all of the input variables are set in ). Note that there are no logical operators here (i.e., , , ). This is important for algorithmic optimization because logical operations can "stall" pipelining or cause branch mispredictions, which can kill performance. For checking for "bit columns" of all , we could use the same concept (but with inverted inputs) as such: . But that's not taking advantage of our knowledge of Boolean logic. Recall from De Morgan's laws that (that is, "(not A) and (not B)" is equivalent to "not (A or B)". Thus, we can calculate as: 

Overall, it looks pretty good to me. I agree that you have good commenting and variable and function naming. I see just a few things to comment on. 

With the simplification in userInput() and display() above, the shouldCycle member goes away. Now, with the menu defined internally as a dictionary (self.menu_dict) and as a list (self.menu_list), display() and userInput() will look like this: 

You don't need "if not out:" at the top of this -- you're in a "while not out" loop and out hasn't had a chance to change since the top of the loop. The "for items" loop just scans through the inventory looking to see if you have the door key. That can be done in a single statement, as I show. Once you've opened the door, you're out, so we can just break out of the "while not out" loop and carry on from there. Several of your descriptions are hard-coded: 

This is a cleaner version of your code with less query (the first was unneccesary) and inside the loop you are making a lot of small query which can be really bad but first you have to modify your code to not work directly with the context in you page code but through an interface (first iterate through the rows and get all data then pass them to the worker (which can work with the context) and return the result & update the UI). 

Question #1 No. You do not need to ref the connection object in your methods' parameters - think object oriented way not class oriented. Question #2 The only way is to make this as a non static class. Avoid always statics when the current problem contains some kind of state management like a MySQL connection. Question #3 No you don't but you should implement the IDisposable interface and apply the correct disposable pattern. 

That way, apply_filter doesn't have to be aware of the list being built. It just returns a list of what it finds -- either a line that passes the filter or an empty list. Passing an empty list to extend is a no-op. 

One way to get the neighbor coordinates without checking for (a != 0) or (b != 0) on every iteration would be to use a generator. Something like this: 

Let's see if I understand what's going on with get_filtered_lines() and apply_filter(). First, get_filtered_lines() reads physical lines from the file and strings them together in line_buffer. When we find the beginning of the next logical line ('['), we pass line_buffer off to apply_filter() so the material that has been collected gets processed. Then we empty out line_buffer and start over with the beginning of the logical line just read. Here's an approach I think is simpler and clearer: 

Return if any of the inputs are . Let the output value tell you which "bit columns" were found identical. Even if you don't need that knowledge currently, calls to the function like such, 

All of the masking with individual bits and logically comparing values really eats up your performance on the randomized data. For the ordered permutation runs, it's likely that some compiler optimizations in conjunction with branch prediction helped out your times (because every group of 16 calls to had a, b, and c identical, varying d. This is evident because for the randomized data runs, your original algorithm suffers a 3x performance penalty compared to my implementation. The Takeaway This is probably one of those cases where, if performance is really important because you're operating on a lot of data, or you need hard real-time performance, that it pays to take a step back, and reconsider the data flow. If at all possible, removing the cases where you're checking the inputs {, , , } for will yield 2x-3x improvement in the algorithm computations. Alternately, if there's another way to handle those cases (mathematically, instead of conditional-logically), then you can just operate around the issue. 

So display() keeps showing the menu as long as userInput() returns None. userInput() returns None if the user's input doesn't match a button, or the inputSel value if it does match. I think the way the Controller loops is fine. The program will always stop when it gets to raw_input() and read stdin until the user hits ENTER or RETURN. That's what raw_input() does. You're managing your buttons as a list, which means you have to scan the whole list until you find the navigation element the user selected. If you put them in a dict, you can simply use the user's input to index directly into the structure and select the correct button (or determine that the user's selection is invalid). However, you still want them as a list for display because you can't control the order in which entries are pulled from a dictionary and I think you want your menu to display in the same order every time. That needs a list. I would suggest the following for the constructor for the Display class. We're going to pass in a list so it's easy to define, and we'll keep the list, but we'll also have the class internally turn that list into a dict so it can more easily find the user's input on each selection.