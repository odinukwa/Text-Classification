There's different implementations (I can't see which one you are using) which of course do perform differently, too. Memory / GC I won't go into much detail, but if the concern is performance, you should look into garbage collection. There's a few common rules to follow, as using fixed heap sizes, or in your case, using a througput collector instead of a low latency collector. Hope this helps, slowy 

Now, it might be a language or a definition subject, but if Employee is a domain model, it must not have dependencies to the view layer, at least no direct dependencies. 

I tend to use enums as a thing to represent states (open/done) or constants (monday/tuesday/...). In my opinion, the calculation of a price should be in a separate type and represented by an interface, and not implemented or even delegated in the enum itself. If there's just one thing you have to consider for the calculation of the price, e.g. - maybe a stupid example - an exchange rate, you would have to call the method in the enum with an additional parameter and change all your code. If the calculation is represented in a seperate type, you just inject something like an into it, and the callers do not care. And: It's easier to test your code, since you can mock it and you won't test the calculation of the price implicitly (for those maybe hundreds of occurrences: that means, if something changes within the enum, potentiall all your test cases which call the enum, can fail). And: In mdfst13 example: The Side does know about Order, while the Order holds a state of Side, that's a bi directional dependency and is very tightly coupled... that's okayish, but imo should be avoided. 

Philosophy lessons with slowy a priori: OP and me talked about the the solution in the initial question, let me explain why he came up with this solution. a prior II: I call it philosophy lesson, because it's less of a programming lesson ;) I must highly disagree with the "over-engineered" statement of Tamoghna Chowdhury. Of course, it depends, but since it is a learning excercise, it's the best opportunity to apply object oriented principles, right? If not applied to an easy problem, I doubt, OP will have it easy, applied to a more complex problem. I agree, make the solution, as easy as possible, but not easier. I draw the line between easy and easier earlier, it seems. And my philosphy - and the philosophy of most of the developers I talk to, which are developing large enterprise applications - is: Good code runs its test. Good code has a decent code coverage. That's how I made OP do this solution. I highly disagree with the statement "reducing maintainability" / "adding complexity", I state the opposite - of course, always with unit testing in mind: Having unit tests not only verifies, it also - and that's imo more important - enforces good design - Because of one reason: If you can't test it, you have a design problem. Now, if you have code, which is not tested and you have to refactor it, you do not know if it still works. Having a set of unit tests, which can be executed after every step of the refactoring, will always help and give you confidence. Unit tests also are a very good documentation. My experience has been: Code with decent test cases, which may seem "a bit over engineered" are easier to maintain, than code without tests - and therefore more classes/abstraction/etc. The single responsibility principle's goal - which we tried to apply here - is to reduce complexity: A class should only have one reason to change. I have catched myself too often, facing routines, which started easy as this one, but "historically grew", without having test cases and putting new requirements without thinking too much about future self. It often ends up in reverse engineering, trying to test it, introducing bugs and also - the worst - staying late friday night. In my opinion and my experience, the initial investment will pay off, sooner or later, when on the other hand, not applying the principles, will be expensive. code review Since I'm whining about test cases, I'm gonna start with that one. I applied the tdd approach as best as I could. I didn't care too much about naming (otherwise, I'd sit here all night) or exception handling, I try to explain my "ranting" from above. I used JUnit4 and mockito 2.7.22. 

... That's another example of eclipse quick fix. Dude, if it's not used, remove it. Don't suppress the warning. 

setting portrayals up shouldn't reset the display main() method Usually, the main method is at the bottom of a type. 

Commented out code Get a code repository. And never ever check in commented code. If there's commented code, no one will ever know if it's important. If you need the history, you got it in your scm. setup() method The king of the worst gets a new contender: 

Read the constructor JavaDoc of Random. If created within the same System.currentTimeMillis(), it will use the same seed. Beside that, I've seen a random variable somewhere, why not use this one? 

Expand what to include what? Why does the "Envelope MBR" - which you got from roads - must be expanded with "world.getMBR()"? 

Well, I would have made a view which does the selection and the dao would then do the mapping, or rather the disassembly and re-assembly of the resultSet (get all Cards, extract Clients, set the Client to the corresponding Card). So at least it's only one select. Or you could introduce a new type in a layer 'above' both dao's, which does the mapping. To your thoughts: 

Yeah, just a check, but jumping out of the method. progress() Progessing what? What's val? What does it return? Uses CTRL+F THE VELOCITY? WHAT? step() 

The code looks very nice! However, here my small complaints: Tests The tests are good, but you're testing the implicitly, when you test the . The itself does only the following things: stream, filter with the given predicate, and count. The static methods im should be tested separately, as should the logic of the . The problem is, if the test fails, you don't know if the problem is the or the . The more "implicit" things you test, the harder is it to find the bug. You're testing with too many values. The logic itself should be the same with two values (one is a palindrome, one is not) as with four values (two palindromes, two not). If the behaviour for two or four values is different, then it's two different test cases. The lists to count/filter can have a better name. To make a test case more readable, it's usually split in the three blocks given/when/then, separated by an empty line. Setup the test data / perform the action / assertion. Also, I recommend, but that's personal preference, to static import static methods, at least the assertion methods, so it looks a bit more clean. What's missing (at least what I couldn't find): 

Now, that's some dubious stuff, isn't it? Why can I call the method on 'MOBILE' and pass 'EMAIL'? This made me literally laugh xD. And what displayed message? Displayed where? Where do I get this display message? What does it do with it? 'getTranslationForEnum' or something would make much more sense. 

Use a (Http)ConnectionPool - which you do. Web Servers usually have different configurations about their http pool (or "Connectors"): The amount of threads, which will process requests, the amount of open connections (which will wait until the thread pool has a thread free) and often the amount of http connections open per client ip. This certainly has to match the configuration of your pool. If your app opens too many http connections, they will just wait, memory consumption will rise, memory management will take cpu time, you kill the backend server (yay). I see, your connection pool has a maximum of 1000 connections. That's a lot. Our company website has about 1000 in total, for several different servers, the max connections for our productive server are usually around 100 or 150. 

Okay, that's the most confusing part. The control flow does not make much sense, neither does the access to static variables. In general, everything here is quite confusing, to say the least. 

As RobAu said, there's a lot going on. A priori, I am developing enterprise applications, so there's usually a lot of stupid logic involved, way too much data and thousands of concurrent acccesses to databases - and maybe I sound like a bit like I'm ranting and nitpicking and maybe some suggestions are a bit overkill. But since we're here... Transactions / unit of works You are working with transactions within the method. But this method is called in which actually does whipe the table. Just keep in mind, that if you have a unit of work, where you do more than an insert, you can get inconsistent data in a concurrent environment (not only concurrent within your app, but others accessing and manipulating the database). The transaction management is usually decoupled from the database access object, since, like in your example, the method does not know about what is happening around it. I highly recommend to read about those topics (transaction management, unit of work, isolation levels). Speaking from experience: It's surprisingly easy to mess everything up, if you do not know exactly what you are doing. So easy ... delete and insert all Usually, deleting and inserting is way more expensive than to update existing, insert new ones, and deleting non existing ones. If you delete everything, and insert everything, you mess up indexes and statistics. column index access During reading, you read the values using the column indexes. It's almost always better to use the column names. If you declare the columns' order within select statement (which I do not recommend), you always have to change both, the statement and the retrieving of the column values. If you and the columns get reordered, your application will break. JSON / Model You actually provide an , but you pass json to , which then is de-jsonified to the an , which then will be passed to , within that, you get the and create the insert statement. The json has no business in the data layer, the mapping from json to the actual type to write should be performed in its separate type. I recommend to write a type which holds the data it needs and pass this one, instead of JSON, a map of channelNumbers and a map of channelImages. tidy up Your methods are way too long. For instance, the , consider the following points: Declare the insert statement as constant in the class and move the binding of the values to a separate static helper method. That should look much better. SQLite I never worked with SQLite, to be honest. But: Keep in mind, you cannot exchange your database without a huge amount of work - at least that's how it looks. I would have implemented it using standard jdbc, assuming sqllite provides a jdbc driver. other 

I did some refactoring... I disassembled everything into smaller pieces. Maybe the naming of the methods and vars could be better (I'm sure it can), but I wanted to show you, how to split 'stuff' into smaller pieces of code to make the main method (not meaning the main method in your code explicitly) tell the summary and move the details to separate methods. 

You have some concurrency problems. E.g. the ConcurrentHashMap, the java doc states for instance However, even though all operations are thread-safe, retrieval operations do not entail locking,.... It's like transactions on a database if you read committed: You only get what's done, you don't wait until other transactions have finished their work. I had a problem with this lately, there's a lot of information about that on stackoverflow. I would get rid of the leaseTime. If one operation of an app can take hours, you have to either set hours for a leaseTime - which doesn't help very much, does it? -, or use different pools, which introduces more complexity the user usually doesn't want to be bothered with. But: It's the users task, to use his backend correctly. When there's no connection left to borrow, the usualy behavior is to throw a "PoolExhaustedException". It's not the pool's task to be robust in the sense, that a user can do whatever he wants with the pool. On application servers, such as JBoss for instance, there's a message from the appl server, if the user forgets to close a connection ("closing connection for you"). The definition of the size of the pool is usually done by dev's, dba's, operations, qa and so on, at least for larger applications. About the . I'm also one of those guys who wraps abstraction layers around everything, but the java.sql API is not one of them, since it is an abstract layer itself. I'd recommend to go with the interface, but keep the , so you can write your unit tests. About your test cases: If you use annotation, always write down why it is ignored and if necessary/possible: Write what has to be done, to get rid of the annotation. Otherwise it will be remain there forever. This line: is redundant. Maybe create a method with as parameter (if you don't decide to get rid of it). The should be re-written though: You should be able to test your concurrency without a thread pool of 50k or submitting 15k threads. But imo the wrong place to explain, since it's very complicated (or: I'm not very good at concurrency testing :P). Hope this helps, slowy 

You should have seen the look on my face. Why must what be included to have what to allow something which somehow has nothing to do with the method name? Why does it return Object? Why is there an explicit comment about non-volatile? Everything.. is just.. so scary start() 

Oh and why are you declaring (Coordinate of what, btw?) and (Point of what, btw?) not within the while loop? main() method 

With the generic, misses the whole point of having the 'EnumResourceBundleAware', you can pass any enum! it should be this: 

Also, check the JavaDoc about the methods. Synchronization may not be done yet: It is imperative that the user manually synchronize on the returned map when iterating over any of its collection views. I do think, any means keys and values. 

Gzipping may take some cpu time, but transfering bytes is often way more expensive than gzipping Strings. Of course, this has to be measured, too. 

The only Reason for the is to have it as key object, right? Now, why is that confusing for me: You call that thing . What is it listening for? And what's the difference between listening and consuming? In your sample code, you actually do use this as key and use a lambda expression as parameter. So what if I would actually would overwrite the method in the type, change the method signature in from 

Too many arguments I don't think it's the scope of your assigment, but since we're here: When there are too many constructor arguments, you write for instance a , see "Builder Pattern". You then do stuff like 

"philosophy excurion" In general, with testing in mind and the attitude, that good code has a decent test coverage and applying object oriented prinipcles is always a good thing, I'd go further and moved the "LineReplacing-Logic" to a , to test the behaviour separately. I'd provided a , so I can mock it in the main routine and can actually unit test without accessing the file system (since if I would, it won't be a unit test, right?) and I can exchange implementation, because maybe the contents of the file are not from a File, maybe from a Queue. Same goes for the Writing, maybe provide a , since you maybe want to write into with a , to find a bug with production data and you don't enough space on your local harddrive. All that could maybe be "too much effort", but breaking problems into smaller problems, reaching good code coverage with your tests, applying oo principles and make the code "sexy" usually never hurts and it usually pays back in the long term. Hope this helps... 

I recommend to use brackets. I've never seen code guide lines where no-bracket-one-liner-thingies (What's it called?) are allowed. 

When it comes to design, I wouldn't put the functionality of translation into an enum, even if it's inherited. And to have a default implementation in an interface still bothers me, it feels like an oxymoron to me. The functionality of translation itself is a 'concern', and should be separated (See what I did there?). Also, let's assume the enum value can be saved in a backend, you then also pass translation functionality to the persistency layer. Not a big fan of that. And considering testing: Here's the usual 'having an abstract class'-problem. How do I test abstraction? You could use either a implementation, and call it good, or write an implementation for your test case only. It's not too bad, but it's not sexy either. My main problem with abstraction is, if you mix abstraction with implementation, in your case: your abstract method calls a method from the implementation, so the method you want to test is not tested cohesive.