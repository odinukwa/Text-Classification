Before thinking I didn't read well, I didn't want to rewrite everything: the final edit is at the bottom of the answer, but please read everything to understand it all. :) 

As you can see everything is handled in the constructor with all possible parameters. The other ones just call this one with the right parameters and the necessary action is performed. Now you only have to handle situations correctly. If I pass and the item is null you'll get a . This was also the case with your code though. Update: (tip from Morten Christiansen) When dealing with lots of code in a switch statement, you can extract that logic into a method and call that method from the case. Example: 

Output Parameters I agree that it would make more sense to initialize the output parameters with since you made the effort of making them . But if you take a step back, you realize how ugly the use of parameters is in this situation. So I deleted them and made return an instance of a new class designed to hold two pieces of information: and . I called it , but I'm sure you can find a much better name for it. LINQ Query I rewrote your query as a because I find the syntax less convoluted. However, using a method chain is also all right if it is more readable for you. End Result method 

I think better would be to change the signature of the method and add a boolean (optional) parameter to indicate if you want to refresh the result: 

Edit: Since you're not doing anything between the two if statements you can place the condition of the second statement inside the first one with an operator: 

And now you can get and/or set the value of that property using the GetValue() or SetValue() methods: 

If this can be applied in real life, the Mars Rover could keep going indefinitely, as long as the change of X is equal to the change of Y. Example: 

Here are several tips that might help write better/cleaner code. Note that my tips or help might not be perfect but it gives you an idea on how to write better code. 

To fix this, you need to check the length of before accessing and . Failure because of unnecessary cast If the correct number of arguments is supplied, your program will fail with the following output: 

Finally, we've arrived at the implementation level: We're using the Scanner to gather some valid input. 

(Note of caution: you may want to choose a different name for it since this method already exists in LINQ; technically, this is an overload, which could create problems if a future version of C# adds this signature.) This makes it possible to adapt the LINQ expression: 

Alternative implementation By refactoring step-for-step and slowly introducing changes, I arrived at the implementation shown below that aims to illustrate the points made in this answer. was renamed to and is now generic (it can work with any type of elements, as illustrated in the Usage section). It accepts an Array of elements in the static convenience method . After initialization, the frequencies can be calculated by calling . That method returns a which is the class that encapsulates the string formatting (I went ahead and made the output a bit more pretty). The naming could probably be more accurate from a mathematical perspective — go ahead and rename things if you feel that these terms aren't quite correct (probably or something would have been more exact). The frequencies are now stored as s to allow for bigger calculations, though that can be changed easily if you don't agree with the decision. If something requires further explanation, go ahead and ask in the comments. Usage 

Type constraint: Remember my point for making the serialize method generic too? For now, you don't validate the incoming and outgoing object. What if I pass an instance of a class that has no public parameterless constructor? During runtime I'll get an with a message like: 

While writing previous points I found that there had to be an easier way to achieve the same result. There are numerous ways to check for a palindrome. For numbers you can also use this method: 

Furthermore, give useful names to variables. Names like or are not meaningful, try and instead. I updated the JSFiddle working example. 

I could also have used the method and positive comparison instead of . But this is inefficient as all elements have to be checked against the condition whereas will return as soon as an element satisfies the condition (like in your loop). You can take the comparison code and throw it in an extension method for reusability. It also makes your method-code cleaner, for example: 

Of course, you may disagree with some of the implementation details — but this review isn't really about those. It's more of a demonstration of which questions you should be asking in order to end up with clean code. Good luck with your learning, and thanks for sharing your code. 

In other situations, working with can be a replacement for explicit pixel sizes. Remember that hard-coded sizes are an obstacle to localization (where long words in foreign languages are cropped) and less flexible. 

(the same goes for the ColumnDefinitions and any other empty tags) Declare styles that affect all controls of one type without a key: 

These assumptions are unreasonable and when I first tried out your code on some text, it immediately threw an exception. Naming 

Also, create another constructor that takes parameters so you can create a connection with other values. Combined you can overload the constructor and put all the logic in one. This looks clean and makes maintaining your code a lot easier. Example (classname is ): 

Solution for the Repeater - ItemTemplate Here's a solution that works when your data resides in an ASP.NET Repeater control. Following is a sample markup: 

The code iterates over the collection and keeps a counter, adding the iterated item to a temporary list. If the counter equals the desired length of a chunk it will add the temporary list to the return list. At the end, the last chunk is added. 

Alternatively, you could just use a and calculate the counts when you need them, using the LINQ extension method: 

Range Helper Class This class makes heavy use of generics to allow for flexible ranges to be defined (ranges are always inclusive in this implementation, i.e. and are included in the range). You might want to extend this class later on, but currently all we need is the convenient factory method and the check for . 

It's important to study your code carefully and step through it in the debugger to verify that your validation is actually working (it was not). This is a lot easier if you have written readable, clean code. 

Thanks for submitting your code for review — it shows that you care about code quality and you're willing to improve and learn. Note that OOP stands for object-oriented programming and does not have a plural form ;-) Alexandre has given you some good advice and one possible implementation. I'd like to critique your code a bit more thoroughly and offer another, more lightweight possibility. 

You will have to adjust the maximum and minimum allowed change though, as for now you'll only allow very small moves. Hope this helps! 

Reason: placing selectors in variables is recommended, since overusing selectors can result in poor performance. Everytime you would call a function on , the whole DOM has to be parsed by the browser. This is not the case when you store it in a variable. Also, it's a general principle to not repeat yourself in code, also called the DRY principle (as mentioned by Peter Rader in the comments). 

I am a fan of loose coupling so I would suggest that you take the values of host, username, password and database out of your class. Pass the values through the constructor and set them in the constructor. This makes it easier to reuse your code. Second, in classes such as one that creates a connection to a database I would not "echo" stuff. You better throw exceptions on error or return meaningful values to the caller. Last, I'd suggest other names. This might be nitpicking but this has more meaning to me: