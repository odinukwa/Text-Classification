That way you can export , and . Use instead of / combinations Finally, we have a look at . First of all, let's write bindings: 

Uh oh… If this was a program you want to use in a productive environment, you would check the sign of , and, after the discussion above, also check that tit doesn't get too large (or dismiss VLA). We can provide a small little helper to make sure that we get only positive integers: 

Also, you have a nice little function to check whether a list is empty. Use it. And is somewhat misleading. You don't have a temporary head, you have a temporary last element or tail. But since we focus on only one node at a time, let's call it : 

Now we know that will always return a number in the range 0-2. Foul magic However, what's ? What is ? All three numbers are magic numbers, which is usually a code smell. You, as a developer, have to remember what a certain number stands for. Save them somewhere, like 

Note that a type signature on would have been enough. Operations on are usually faster than . In you can stop at , e.g. 

I admit that is a bad name in that context. might be a better one. By the way, we cannot use or here, since that wouldn't merge the map values. Try to relax your type signatures* is fine, although you could relax its type. Also, is against a function name. You can use safely in this context. 

The rise for power Let's start with . First of all, there's a better algorithm for \$b^e\$, which takes \$\mathcal O(\log e)\$ instead of \$\mathcal O(e)\$: $$b^e = \begin{cases}\left(b^2\right)^\frac{e}{2},&e~\text{even}\\ b\left(b^2\right)^\frac{e-1}{2},&e~\text{odd}\\ \end{cases} $$ Implementing this is left as an exercise. But it seems like you want to use only in , since it doesn't work with negative exponents. Therefore, you should reduce its scope: 

where is from . You can use instead if you don't want to import another module. Now to . We will write a single helper beforehand: 

This is a lot easier to read, and you can easily check that it's correct. But why is it a bad idea at the moment? And what can you do to change that? More on that in the last section of the review. By the way, is 

The function uses , a standard library function We check user input for validity We don't values multiple times We show our intentions for the user's action with a data type We provide a succinct and let other functions handle the actual work We share common problems (getting an integer from the user) and don't repeat ourselfs. 

Magic numbers are bad. What is this everywhere? Were does it stem from? What does it mean? Of course, that's the number of characters in your alphabet, but the stray number doesn't show that information. So we should change that: 

You have a data race in your code. You access reading and writing. does not mean threadsafe. Therefore, your code exhibits undefined behaviour. 

You only need to check whether you have an empty range. If you don't, you start with the first one, and then stream the separator before the next element: 

Parsers are for parsing This is probably the strangest primality test I've ever seen. So for those that want to write their own primality test, please don't use this approach. Almost all your functions can be written without a . is probably the best example: 

That's all you need for your current options. Your program needs all of them set, especially the . An parser could look like this: 

That is now harder to use than before. Add some convenience functions like and to make it easier to work with it. Create a synonym to make more user friendly. There's a that captures this kind of computation. Which is it? Can you write with the help of that ? 

is always true for all . But in this case we won't add the elements from the right hand side! Instead, we look at our now empty left list: 

* unless it leads to performance problems or ambiguities Prefer instead of complicated start values Now, is a little bit tricky. You use in order to have a proper "zero" case. However, if the map is empty, the correct answer should be the empty set, not the complete, right? So let's handle that case first with and then use from 's instance: 

This erroneous state cannot happen now. Also note that we now have a simple . We don't have any bindings, only a single is left. Also note that we don't need to : if is an , we can use that . That being said, you should add an error message after the , e.g. 

This is personal preference, but if you put the doxygen comments into the implementation, your header gets a lot smaller and easier to read through, e.g. 

Exercises Write and yourself without looking at their respective source code. should fulfil the following properties for positive : 

This is a very bad example to learn exceptions. They are meant for situations where you cannot know that there is something wrong. For example if you want to use but you're out of memory: 

Also note that I changed argument. It's a lot harder to use a wrong compared to a . While we're at it, let's reorder some parts and get ri of the after : 

Unit tests should be put in the file they're testing It's recommended to put the unit tests into the same file as the functions you're testing. This prevents your code from getting out of sync with your tests more easily. Also, you don't want one single large for all your unit tests. Use proper types in traits At the moment, as soon as we use any function from , we end up with a : 

For any non-positive , the list should be empty. should execute the actions and collect their results, e.g. 

Either way, if you're striving for performance, you want to keep the number of function calls low, so consider an output buffer if your current variant isn't fast enough for your liking. But first measure your program before you change it. Goals Let's revisit your goals and check them now. 

Use if you use the same instance as the wrapped type anyway. Together with , we can get rid of much boilerplate (comments omitted, changes noted with ): 

However, as you've noted, it does not yield the same result as your variant. Here's the exercise, though: write an iterator that provides your behavior. 

Your code is fine and contains documentation, so there's not much to say at that point. That being said, your problem can be tackled by transforming the type class to a data type: 

Note that this also generate a help message. Other remarks Apart from the remarks mentioned above, well done. The tape movements are now \$\mathcal O(1)\$, and the same holds for jumping to the start or end of a loop. Your AST cannot represent invalid programs, which is a big plus compared to your previous approach. There are some points where I would use another style, but that's personal preference, e.g. 

Bases Vigenère has a "bug". That is due to your alphabet management. Strictly speaking, both Caesar and Vigenère advance characters in their respective alphabet. Therefore, your alphabet should be something like 

In your following functions, I would prefer to use , but that's completely up to personal preference. Also, if you use an expression only once, it might make sense to get rid of its binding if the code stays readable: 

Now we just need to get a list of strings. Since we now want to get something from the user, we have to use : 

I've kept the variable names, but that gives you an idea. Now can be used for any kind of list, regardless of whether it's a color, a taste, or kinds of megalomaniac cybercats. Note that this is more than the exercise asks for. That being said, it should be easier, right? Let us have a look at . Now, with it's new type signature, let's rename it to : 

Feel free to use instead. By the way, is missing a type signature. Recursion and Horner's method Your isn't really optimal. We can use Horner's method to get rid of . For this we need a helper: 

Other than that, the test is usually too strict, since floating point arithmetic can be a finicky beast. works well enough most of the times. Other than that, I suggest you to allow other functions than a fixed . Something along 

That's a convenient small function and makes it possible to change our later without changing too many functions. For our we want to get the next player as well as queue them to the back of the line. A list isn't the perfect data structure here, by the way, but we keep it for simplicity: 

Your code is very hard to read since there is so much empty space. Even if we don't remove all of them, the following variant is a lot easier to read: 

Why is it important to , and not simply ? Because the operation will only take effect if there are elements with the same key in both maps. Put it all together So, you've used correctly, except for the , which didn't come up because the test cases were borked. Otherwise, everything was fine, except for the things mentioned above. Here's the code that implements all the suggestions above. Note that type signatures on top-level functions are very recommended: 

You can then even provide keys to save/load your game, which helps tremendously with debugging. Keep it short and simple We've had this heading already, but it's here for a second time: make your functions shorter, if possible. Remember, code is written for two participants: the human reader, and the compiler. If the compiler doesn't understand your code, it will throw errors and warnings. If the human doesn't understand your code, it will get angry, sad, or stark raving mad. Your function is a valid candidate. The functionality of and can be split into and . Both functions will be short, and can be checked for correctness. Further remarks Now follow further remarks on your code, which aren't that important for a language learner, but still provide further feedback and place for improvement. Bugs and dead code