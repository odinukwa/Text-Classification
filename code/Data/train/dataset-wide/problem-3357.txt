You seem to be confused as to what version of PHP is installed on your system now, so let's start there. First, you have PHP 5.6.4 installed, from the remi-php56 repository, not PHP 5.4.6. You should have no issues installing from remi-php56, presuming you remembered to enable the remi and remi-php56 repos. Since they appear to be disabled, that is almost certainly the cause of the problem. There's no need to add webtatic here, and the cause of this error is that the webtatic packages conflict with the remi packages. You should remove the webtatic repo, enable the remi and remi-php56 repos, and then install php-soap. (Remi's high quality packages over the years helped him become an official Fedora packager and become employed at Red Hat. I don't know who the webtatic people are, but I have never been impressed by the quality of their packages.) 

You're on Ubuntu, which automatically starts services after installation. Thus at the time you ask for it to be enabled and started, it has already been enabled and started. And of course if you run the playbook again while it's running, it's already started... What you need to do is to set up a handler that will restart the service. For instance: 

The Jenkins API accepts normal URL encoded form data, but usually with only one field, named . The Ansible uri module does not URL encode the when sending normal URL encoded form data. You need to do this yourself. 

You already have a running program listening on port 8080, as evidenced by your output. You seem to indicate that it is Apache. You will need to reconfigure Apache so that it does not listen on port 8080, or choose a different port on which to run your Go program. 

Your iredmail machine which you named is misconfigured. It appears to be wanting users connecting on port 25 to authenticate before sending mail, which is not appropriate for incoming connections on this port. Port 25 is intended for receiving mail from other domains on the Internet. Authentication should be required only for incoming connections on port 587, the submission port, which users of your domain use to send outgoing mail. I'm not familiar enough with iredmail to tell you the exact setting to change, though this shouldn't be too hard to find. However, if you're decommissioning the box anyway, and its replacement is working, you could just ignore it and swap in the new server. 

You are missing your to divert requests to PHP when no matching static assets are present. For instance: 

Or, you may find that the people who built the kernel (Zetavault?) did not actually build in this module. In this case you need to take up the issue with them. 

Now, it appears you run a web hosting service and have numerous web apps. If one of these is compromised, it may begin sending spam. These often make direct connections to remote mail servers by looking up their MX records and connecting to port 25, as if they were actually a mail server themselves, rather than delivering mail to the local mail spool or an authenticated mail service on ports 587 or 465 as legitimate web apps do. One way I stop this is by implementing a firewall rule that prevents outgoing connections on port 25 unless the user is the mail server user. For example: 

You don't have the ASA configured to allow outgoing NTP traffic, so it doesn't. "Related/established" traffic refers to in-progress traffic, such as incoming replies from NTP servers, not newly initiated traffic, so it doesn't apply here. To resolve the issue, add rules for the appropriate groups to allow outgoing NTP traffic. For example: 

This is the #1 reason to use a packaging system, such as RPM (Red Hat) or deb (Debian). For embedded Linux systems, the usual package management system is opkg, a successor to ipkg, which is loosely based on the deb format, and is usually easy to adapt from Debian package building instructions. 

The in does not exactly add a to the end of the URL and try it. Instead, when the parameter ends with a the request is passed on to an index module, depending on whether you have specified the , or directives in your or blocks. Thus, if you had specified: 

You really don't want to disable keep-alive. Your server performance will suffer, for starters. Your clients will experience slower loading times. In rare cases, you may even get fired. Don't even THINK about doing this on a production web site. If you're just testing, you can set the HTTP header . 

This is meant to help prevent erroneous or malicious SPF records from contributing to a DNS-based denial of service attack. In your case, the problematic part seems to be: 

Your comments reveal files and directory structures which are commonly seen with rootkits. So it's a very high probability that your server has been compromised and taken over. You should begin remediation as soon as possible. 

The ownership and permissions are probably wrong. Since you weren't tracking these, you'll have to fix them manually, for every single file. By itself, git doesn't track ownership and permissions of files. That's not what it's for. This metadata was not tracked at all and was therefore lost. This is what systems like etckeeper are for. They wrap around git to keep in version control, while also keeping the metadata that git doesn't, and restoring it if necessary. To prevent this happening in future, consider using etckeeper or a similar tool. You may also want to institute some sort of backups. You currently don't appear to have any sort of backups, and this is a recipe for disaster. You've been lucky to escape with as little data loss as you have. You may not be so lucky next time. 

You didn't specify how you were dialing the call, so I'll refer you to the Skype Connect documentation, which says: 

Your routing table looks reasonable (aside from a strange route to a /96 but that probably isn't causing you any issues). At this point it's time to look at the Brocade router that's serving as your default gateway and make sure that it's behaving properly. 

Aha, I see the problem. You have provided no way for nginx to actually serve static files such as , so it is trying to pass them upstream to your backend. The quick fix would be: 

You "fix" it by getting a newer laptop. First, your laptop is using a six year old CPU (and is in power saving!) which isn't even really designed for server workloads. Second... no, that really is the root of the "problem." 

Your directive refers to , but the endpoint you are trying to use is . Because a exists with the same path, with a appended, nginx generates an internal redirect. If is the WebSocket endpoint, then you should be using . You are probably missing some other necessary headers. Here's a working example of things you should have: 

If you look carefully at the disk symlinks in you will see that there are also links for each partition on the block devices. For instance: