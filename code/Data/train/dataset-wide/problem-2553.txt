Indentation. If you are using Eclipse, please select all your code and press Ctrl + I. Your entire for-loop should be indented one step further. Use methods. One method for inputting a String, one method for making one iteration of the "decompression". Did you forget about how to properly use suddenly? You use as a condition for your while loop, that makes sense. But then you're using a for-loop to determine the location of the and characters you are going to work with. This makes no sense to me. Better variable names. Thanks to your comments on your question, I managed to figure out parts of what you are doing and write a review about that. However, Daniel still has a point that your code is not readable. Close the scanner. Your scanner is a resource that needs to be closed, call as soon as you are done with the scanner (that is, after you have received all the required inputs from it) Potential problems. What if I want to encrypt the string , how should that string be encrypted in order to be decrypted correctly? Or what would happen if I gave your program the input ? I believe your code would have a hard time with that. 

At one place you write and in others Luckily for you, it has the same dimensions so you won't notice, but should it be the following? 

No, no, NO!! If by "construct" you mean constructor, then no - use a method instead. If by "construct" you mean a set method like , then sure, if you want to change some value you'd have to do but that's fine. This won't affect performance much. Java even use a Just in Time compiler to boost the performance of such calls. If you want to you could even add a method like this to your Item class: 

It depends I personally find a method that returns it more flexible and more of a separation-of-concerns approach. And by doing so, you could even move the method into another class, such as a class that perhaps can provide you with other monster arrays. However, it is perfectly reasonable to use a method that returns if: 

Using the variables as instead of helps greatly here. It lets us check if any condition has been matched twice, and lets us use the trick to check if was matched before . 

So, let's say that the input array is , what should the output be then? At first I expected it to be , but then @Marc-Andre made me realize that in fact, that's not the case. I misunderstood the question at first. Although not explicitly written, all the numbers in the array are required to be less than 10. I strongly suggest you add a check in your loop: (which btw can be written as for-each instead, which also applies to your last loop for looping through the list) 

Beware of instanceof operator. I am sure that whatever it is that you are trying to do here, there are better ways to do it. Java is a statically typed language, use the static types whenever possible. If you really don't know what type the object have, then I will provide another alternative below. 

Card It took a while for me to understand why the was there in , it's so that you don't have to do any off-by-one fixes when accessing the values. I'm not a big fan of that though and would prefer a method called that would handle the off-by-one. I would prefer as an I don't think the and belongs in the class. I would keep the comparing logic outside this class, as there is not one clear way of how to do the comparison. The method also does not belong in the class. 

I assume that will be changed in your so that one should not be final. All fields that only get initialized once can be marked final. 

Here we don't need to switch the if-statement, we can just return inside the if as it is and drop the else. 

A nice thing about using an Input Component is that you can easily detach it from one entity and attaching it to another entity. Unfortunately you have not posted your exact code in this question, making it a bit of guesswork to fill in the blanks, but my guess is that your current code is directly tied to a specific entity which is supposed to be "controllable" by the human player. This is where Entity Component System has an advantage. It is Single Responsibility Principle at it's very best, and it decouples your different classes, a lot. Right now all your "states" that are making use of the Input "singleton" is directly tied to it. Reducing their reusability greatly. I don't think that the Entity Component System approach should be mixed up with the State Design Pattern as you have done. If anything, you can have the State as a Component inside your ECS, and then have a System for each possible state. Having more context of your actual game would have helped significantly here though. 

Here you have a multi-line , but as you're not using any -specific features (variable interpolation for example), you can replace the with 

However, you might want to consider a significantly simpler approach... what if you give the whatsnew, products and contact a matching id or class? Then the code could be as easy as: 

Since it can become a one-liner, you might not need to have it in it's own method. Most importantly, if you are not interested in the order of the set, use a rather than a . 

Not because you don't see a for-loop doesn't mean that it doesn't exist. Ask yourself the question about what does. It loops through the array, doesn't it? A faster way to handle this assignment might be to use another data structure, such as a HashSet. 

I also have to question the usefulness of your code. Hibernate is already an abstraction and does a great job in simplifying things. What is it exactly you want to make easier with these methods? Your current code: 

Magic numbers: Instead of using and (and perhaps even ) in the double-loop above, retreive the length of your array with and . 

So you see, your first item now has the same weight as the second item. This was not intended. The correct way would be to use which will randomize a number from 0 to 8 (inclusive), and then iterating and adding to again and comparing with , now let's see the distribution: 

Then you can check if returns something other than -1. If it does, use the index returned to do what you need to do. Additionally, you should really look over your indentation. And is a bad name for a loop variable as count means the same thing as . Use or as a loop variable instead. 

These exceptions should never be caught, code should be written in a way so that they don't occur in the first place! 

Secondly, your and methods are a bit slow as well. Especially considering that they are only used on the board. One way to speed such methods up generally is to store a where is a pair of x and y values. The key in this map is the of a position, so for example the value is at row and column can be: 

A general suggestion when working with touch events: Log, Log, and Log Use like a maniac! The more you log, the more you will hopefully be able to understand about MotionEvents, and the better code you will be able to write. 

Games and Players I imagine that one of the most common statistics you would want to display is: "What are my win statistics against player X?". For such a query, the table is really not optimized for it. Let's say that you want to make a query for "Find all game_ids that the user id 6354 has played in" 

Do not have any logic based on . That method is mainly meant for debugging purposes. Using a instead (as above) allows you to use for your application logic. Is a singleton really necessary? Ask yourself if you really really NEED a singleton (Hint: Answer is most likely "no"). You might be able to use dependency injection to pass the object to the classes that needs it. You might even not need a single instance, is there anything wrong with having multiple instances? All it does is read from a resource file, so worst case scenario is that you might spend a few nanoseconds reading a resource file from different places? 

Using a static variable will have the same effect as using a singleton! Imagine if you had two instances of : 

You don't need either or the in your class. As your value change listener is an anonymous inner class, it has access to the outside object, which you can access with . As your is passed as a parameter and you want to use it inside the anonymous inner class inside the method that the parameter is passed to, you can mark it as to make it usable. 

I'd just like to make a slight change to the code. When you are instantiating a , you have the opportunity to specify the capacity of it. Using this constructor, we can avoid having it resized more than necessary. 

Your JLPFlag enum can have a method for doing the test logic: (If you like this or not is up to you) 

I would not JButton. It is better to use composition/encapsulation and store a inside the class. Right now you can call plenty of methods from outside the class that is totally irrelevant to the itself. Just check the many inherited methods that a JButton has! 

But the fact is, this is slightly dangerous. Although your class is immutable, this is not. Imagine the following code: 

The home that you get will either be visible, or it won't be visible. If it is not visible, there won't be any other visible homes either. Combining this with @Vogel's suggestion of using the code would go something like this: 

"If not x equals zero and y equals one or y equals 0 and x equals one." Please don't have me read that again. I would add extra parenthesis around to avoid mixing up and . Also, by switching the logic around it becomes this, which is clearer: 

I consider this a long and tedious way of adding data to a list. A , just like many other collections in Java, has a copy-constructor where it can take another list as argument. This makes it possible to write a much shorter way to setup your list: 

There are (at least) two different approaches that are better than your current approach. One option is to run a query first to check whether it exists or not. If it exists, run . If it doesn't exist, run . Personally I wouldn't prefer this solution as it is slower than necessary and, if implemented correctly, would require more table locking. Consider the case of two scripts running simultaneously, here's what could happen: 

I don't see any reason for why you want to call in a loop. Calling it once is enough. And there's definitely no reason to call it inside the method. Call it in the constructor instead. Additionally, it is possible to initialize that array in a more compact way. 

As it currently stands, you are not doing that and have no real ability of doing so in that method. This fact is an indication that you should not use and instead use a , and therefore using composition over inheritance. Concurrency If two threads would call at the same time, there is a concurrency issue on . You need to synchronize on something there, for minimal blocking I suggest you do something like this: 

Taking it further Java is an Object Oriented language. Write your own classes, use objects, add more methods. Everything does not need to be done inside one method. I suggest you read Oracle's tutorial at $URL$ . You could use a class for example with the properties name, age, gender height. 

I see a very big advantage of your current approach rather than moving the implementation of to the class (May I suggest changing the name to ?) 

Usefulness I'm sorry, but I can't really understand why you have this class? What functionality does it provide to you? Would it be easier to have the same functionality without this class? Hopefully you have a good use case for this class, in which case, great! I'm just not sure how I myself would use this class, which brings me to the next point: Documentation Although your naming is really good (you have no idea how happy I am to be able to say that!), your class could use some documentation in the form of JavaDoc. Stating the purpose of the class and the usage of the class and it's methods in JavaDoc helps any potential users of your class, it can even help yourself several times. Thread safety Your code would likely cause problems if it would be used from multiple threads. To avoid those problems, learn about Java Concurrency. If you're not using multiple threads now, you might be later, that's why I'm mentioning this. It's something for you to learn in the future :)