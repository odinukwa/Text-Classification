Java/Java 8 tips is an unused class, and even if it is in used, class naming convention recommends the singular form rather than the plural. This is because you will have a instance or many instances, but a instance doesn't sound as right. The only pluralized class names that I can recall off-hand are for utilities classes, i.e. those that only provide a bunch of methods. Since Java 7, the recommended approach for reading from a source is , e.g. 

Now, by right, we need to negate our first condition to make sure we only when it is the second condition that has been satisfied. However, if you look at the computation of , it is always positive when , which so happens (?) to be the negation of the first condition. In other words, when the second condition is , we already know that the first condition must be . Explicit negation of the first condition is thus unnecessary. The second and final statement is just to . If we are not -ing , then that means we should check whether we need to perform the following two steps: 

It will loop against an empty , and happily declare that is a prime number since . Interfaces over implementations in declaration 

Causing your program to inexplicably when encountering a number is a particularly harsh way of handling errors... (Very) often, you will want to make it easier to recover from errors and retry wherever possible. For example, if you want to consider any input with numbers in them as wrong and re-prompt for a fresh input, you can do something like this: 

Gathering statistics The class will be a perfect replacement for your bespoke class, seeing how it has everything you need. That beats having to multiple times. Using more method references You have demonstrated good usage of some method references already, but I can't help but feel you missed out one more, to use : 

There are a handful of good Java unit testing frameworks, and I will use TestNG as an example below. You start off by having annotating a test method so that the framework recognizes that it needs to run that test (this is dependent on your unit testing framework), and an underlying method that calls your method to test: 

After sitting on this for... 8 hours, I realized can, and probably should, use the method, to encourage code re-use at a very small expense of efficiency (which isn't the goal here anyways): 

Your simplified logic doesn't appear to handle sentence structures accurately, but since you seem to be more concerned with the formatting (capitalization), then I guess it's ok. 

Sorting performs an in-array sorting, which may not be desirable if the caller of your method isn't expecting so. You may want to make a copy of the input via first. Calculation 

Util.java Since you are already using Joda-Time, you should use its utilities methods to calculate the differences in milliseconds/seconds/minutes between two instances. Actually, are you using classes consistently, or do you really have a mixture of objects as well? I suggest sticking with Joda-Time if your solution is < Java 8. Also, and doesn't appear to be used, so consider removing them. Even if you require a representation in the future, consider overriding the method . URLWeight.java I am not too sure how robust your and methods are, so I can only briefly suggest creating unit tests to ensure they work as they should. You also do not require , just will do. PingTaskManager.java The class seems to be spelled wrongly, and it's also not used in conjunction with . LinkNodeLight.java 

Maybe this is just a quick prototyping, but if you do decide to make this a full-fledged library class, you should not be having the method, the initialization block, or your fields. The fields should become class fields where needs to be instantiated. Testing should go into its own class. On another related note, you don't necessarily need to create temporary files for testing. There is a method that will work with a , which can be used in turn to wrap your test s/lines. I don't think there's a benefit to instantiating a object immediately after you have -ed the file. Things may happen between the loading and storing of properties, so regardless of whether you have this object or not, the storing process may still fail afterwards. Also, it seems like you do not need to explicitly after calling as that is already done according to the Javadoc: 

Modeling You can consider have a more domain-based modeling of the successful results, instead of a simple in your . For example, consider a of objects that have a state consisting of (aka ), and ? That seems to adhere closer to the results, giving you a more meaningful application. 

Now, you don't need a -check (it's not in the right place anyways - it should be done at the start), and I renamed the main method as . I feel that is suggesting that it is formatting a US phone number into another representation. 

In fact, this will make refactoring easier when no longer have the additional arguments: you can just remove the line . 

These look like 'debug' statements where the developer (or user) is manually checking that the counting is done correctly. Usually, this should be done through a logging framework (so that the verbosity can be adjusted), or be eliminated entirely. It does not serve a direct purpose as to the method's usage. Iterations Your approach has to iterate through the array three times: 

Guava If this is Guava we are talking about, then between the options you presented, I think it's still fine to stick with the original. Method extraction in only two places - just to 'substitute' two lines with the added complication of -ing different types altogether - is unnecessary here. And as you have observed, having to does look out of place too. Alternative I understand you are trying to unify the exception throwing when you have either no results, or no box from the given ID. In that case, perhaps you can reorder your checks accordingly: 

Java 8 or Joda-Time If you are on Java 8, there's the APIs that you can use to model these times into nicer classes to work on. If you are not, you can still rely on Joda-Time for its selection of chronology-related classes. For example, on Java 8, you can have a simple model class like: 

Construct an with the values . Box it into a . Collect the values using an instance of . For each , print it using . 

When it comes to serializing the contents of your instances into a file, you can also consider using one of the many third-party libraries to write it out as JSON, XML, or CSV, so that you don't have to roll your own implementation/format. Other observations 

Using the appropriate types Your are repeatedly casting into a , the first suggestion I will make is to cast it once first to make subsequent references easier to read: