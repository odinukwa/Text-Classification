They both check that the post exists first and then creates or destroys the like record containing the post id and user id and redirects to the post with a message depending on the outcome. In the Like model I prevent duplicate likes with: However the methods feel quite bloated... is there a better way to handle this? 

However I didn't like that it expects the AJAX request to request JS and then having a partial render inside a jQuery method that then makes an assumption about existing to render it inside. So effectively the response is also handling how it should be used. My alternative approach was: 

I have the following code that allows easy creation, pulling, and deletion of Tickets in a CakePHP application. 

This way we just return the partial or redirect depending on if the request was via AJAX. The former seems to be the standard Rails approach (according to most docs) but I find the latter far cleaner as it means I can handle how the response is handled as it just returns HTML rather than having the actual handling of the response being returned with the response. Is there a better way to handle AJAX responses? Or reasons why my approach would be considered bad practice? Of course using the first approach means using Rails UJS and my own uses custom JS to make the request and handle the response. 

Indentation and formatting First and foremost, this code is not properly indented. If a candidate presents me with an unindented or sloppily indented piece of code, I wouldn't hire him, no matter how good his code otherwise. 

According to the single responsibility principle: no. The App component defines the routing. It feels awkward that it also handles login logic. It seems to be doing too many different things. While the Login component seems perfectly suitable for handling everything login-related. 

I think your answer is perfectly valid and much better than the editorial solution. I only have two suggestions to improve it further: 

Each view would have an array of its subscribers. method would add a new item to this array. And in , after the data has been fetched from server, we'd loop through this subscribers array and call a method like on each view. 

For me the main semantic question is whether you should have a section containing articles or an article containing sections. Or perhaps even an article containing other sub-articles. From the HTML spec: 

Well... this function doesn't really do what its name says. It in itself does not process the arguments, it only create arguments parser. I would personally suggest implementing so that it actually processes the arguments and returns them, so you can pass the result directly to : 

The only thing you share among the codes is just define it as an atomic (). Even Better: Don't share anything: Let each task use it's own hit counter and sum them up at the end (easiest way to do this would be to use std::async). Create and seed a separate random number engine for each thread 

For some time it has been bothering me that there is apparently no way to directly initialize variables from input streams (something like ) My solution is this: 

Padding I just want to point out that aside from the false sharing between and , which is avoided via padding, any thread calling push or pop will access both variables anyway and afterwards you still have false sharing between the actual nodes. Performance This code contains a lot of micro optimizations, which might or might not be worth the effort if the code gets reused in different contexts (its definitively not worth for handling a worker pool). However, I'd suggest, to write at least few small benchmarks to ensure that those optimizations are in fact improving and not hurting performance. Also I want to repeat my warning from the comments that for some reason, VS2013 (and also 2015RT) seems to be unable to implement in a lock-free manner, in which case the whole structure is probably much slower than a normal stack with a mutex. 

If you're planning to place a ton of these characters on a page, you might be better of using event delegation, instead of binding the event handlers on each and every element - see the jQuery.on() function reference. 

Use smaller functions You say this code lives inside a function. But for some reason you don't give us the whole function, instead you're describing in text what the parameters and return value are. Is it because your actual function contains lots of code unrelated to your question? Even when that's not the case, this function is way too large. You should break it up to smaller functions. 

This helper doesn't really help you much in performing a swap. I can see from your pseudo-code, that you'd really like a helper like this: 

Also note the naming: the original name seems to be talking about some coordinates, which doesn't sound correct to me. By separating the two, it should be also easier to improve function so that it would not return duplicates, without having to modify anything inside . Additionally: 

Business logic or not I guess the general dichotomy is View logic v/s Business logic. So, to decide whether something is part of your application business logic, try to imagine your app having a completely different UI, like a command-line UI. Would the logic still need to part of your application with this new UI? If yes, then it's likely your business logic. Email validation and checking if user is logged in, seem to me as part of business logic. Controllers The role of a Controller is the most vague one in MVC world. That's why there exist several Model-View-* patterns: Model-View-Presenter, Model-View-ViewModel, Model-View-Adapter. To answer your question: 

Whether that is easier to understand than your version is up for discussion, but it should be a little more efficient. can be simplified by using an STL algorithm: 

I also made the deliberate design choice, to not provide a virtual destructor due to the overhead it would incur and the fact that I don't see any use case, where I would want to destruct const_string via a pointer to . Still this goes against best practices and might be suprising for other people using that code - would you accept such a code in your codebase? I haven't finished documentation and the unit tests yet (I hope the code is readable enough), but here is some sample code to play around with: 

Upon construction, no actual nodes are created, but only properly aligned memory is reserved, on which you later call the assignment operator. I believe (although I'm not sure) this is OK if T is a POD, but if not, then (move) assigning values to them is definitively not allowed, because custom move assignment operators usually assume that points to a valid, initialized object. So in general, I see two possibilities: 

As mentioned before, I'd replace the class member with a local in and pass the array as a const ref parameter to . This gets rid of the mutable problem and might even increase performance. I'd write the function a little different: 

It feels a little old now (not sure how old the code is) but wondered if certain things could be improved and if there was any parts that were considered 'bad code'. Some observations of my own: 

I have the following two methods which handle the liking and unliking of posts in my Rails application: 

But as you can see, the code is HUGE in comparison! Can anyone suggest some better ways to handle this, as I can't believe that PHP can do all of that in just one line compared to all the crazy MapPath and converting of dates etc. 

However if I pass back 1000+ records then the JavaScript struggles and it takes a few seconds to do it and causes the browser to lock up. Any ideas on how to improve this code? It seems to be the line where I append the rows to the page: 

I have the following snippet of code that redirects a user to a specific page on successful login to the application. 

The idea is that if a query string named 'next' exists and has a valid hostname that matches the actual sever hostname then send the user to that location otherwise send them to the default location. It should also handle really bad formatted urls by the parse_url method returning false. Can anyone see any issues with the above code? Or offer improvements? Thanks EDIT The next parameter can be added manually for example on a login link, but is also created automatically on the redirect when a user tries to access a protected action. The reason for adding the is because the session also contains the app url, so if your app is on a subdirectory e.g. and you try and access you will get redirected to the login form with which will then send you off to: adding /myapp twice! Doing the full url instead STOPS this from ever happening and doing the parse url prevents a malicious user from creating a login link with their own url as the return. 

In the code above you first set and then inside you set again. These two are not the same variable. Do not define instance variables outside class methods, unless you want to do some meta-programming with them. You define method for accessing the variable. As this is such a common pattern, Ruby provides a helper for generating such simpler getter methods: 

Java doesn't allow you to implement it like that, but you could implement a swap function like that: 

The main problems with the code resides in tight coupling between UI logic and business logic. For example the function: 

This code looks needlessly tricky to me. It's not immediately clear what kind of values are stored to the state. I would just write it out explicitly: 

This separation between components and logic is good. I would suggest separating them even more by moving the and functions to separate file, which you can then test completely independently from the component. The component rendering test however is dependent on the logic. That's not good: 

But all the places where method is used, could actually use the method instead. This should make one realize that this whole Tile class could be completely eliminated and replaced with a plain boolean value instead. Other smells 

Usually the first approach is better and requires no extra tooling. If you decide to go the mocking route, my personal choice is the rewire library, of which there exist various versions for various environments (e.g. for Babel). Regarding specific tests Avoid temporary variables when you can write the values inline. Instead of: