Pretty clean. Now lets think about method. It's purpose is returning some methods depending on what was found in methods group and parameter methods. Btw it can be method of another class (e.g. some service) 

Second operation is calculating sum of documents in group. Thus total number of items in all groups will be N then enumerating all groups will take N iterations: 

Even more, if all your email messages use account attributes, then you can create set of account extension methods: 

Pretty descriptive - repeat adjustment until it done. But you should pass different values to that method - , , . And this code will not look so good with all these parameters flying around. The reason is that we keep data and logic separated. So simply put logic (points adjustment with some parameters) and data (parameters) into the class. 

Here you don't have any duplication of knowledge - you specify email body template, placeholders and provide values to placeholders without setting some properties of and passing it through the system (keeping in mind that is mapped to and should have a value of ). 

And last thing I would change is class. I don't see any good reason for its existence - you can sort sequence of objects easily, especially if you will override Equals and GetHashCode methods of CustomerLead class. 

Simple as that. Now we need someone to create runners and pick them according to file type passed. You can build some specific xxxConfiguration file, but I believe it's OK to create runners directly from xml 

Now let's look what changes when selected index is changed. It's only value. It changes from to . Which is 

Create a new member in enum Add new template in method which returns new template string for new enum member Add required relevant placeholders to method to return placeholders which are used by the template on the previous step. I feel uncomfortable here, because this is a definitely duplication of knowledge - we already have specified placeholders when defined template on step 2. Also we can forget to add some placeholder which is used in template. Create new method which will duplicate knowledge again - it should know which properties should be set in . And those properties should match placeholders from step 3 which in turn should match template from step 2. 

Here lookup is created. Internally it looks like enumerating over and adding them to appropriate groupings of lookup. You can think of lookup as a . Next we do enumerating of all items (that's another N). In body of this loop we get children of item (getting appropriate group by key is pretty fast O(1) operation, comparing to enumerating all items and filtering them). Good news here is behavior of lookup when key not found - it simply returns (i.e. empty array of ), so we don't need to check anything - further calculations will work without problems: 

Now, what about nested loop? I stick to single indentation level rule of thumb. To avoid arrow anti-pattern. You can move loop logic to separate method and return outer exit loop condition from that method. Thus you can keep loop even without a body: 

I suggest not to hard-code file names in your application. Move move questions file name to application settings: 

Next is data verification. I think the best class wich knows what is appropriate values for first name, last name and email is CustomerLead itself. There is several options - one is adding guard conditions to each property setter, which will check if value is valid and throw exception if value is not valid: 

First note - do not use DEBUG_MODE constant to define whether you should print debug message or not. There are better ways to do it. You can either use conditional attribute to check if compilation symbol "DEBUG" is defined. Calls to methods marked with Conditional attribute completely removed from generated code if symbol is not defined ("DEBUG" is defined by default when you start application in debug mode): 

Also there is a problem with setter of property. I would expect that setting them back to provider will update my data in file. But actually I just change in-memory collection. So, I would remove from provider interface, remove setter for CustomerLeads and also renamed provider to repository, because you are providing data, and repository is more appropriate term for that: 

Then define display and value members of this class for combobox and after that assign collection of objects as combobox data source (I use array just as example): 

You are using string only as boolean flag (whether its null or not). So, you don't need to store current word in this variable. Actually creates many strings in memory, because strings are immutable. So, its performance and memory consuming. Remove it. Also you don't need second if. If char is not white space, then it is white space. There is no third option. And improve naming - don't use prefixes for variable names. 

Final solution Further refactoring can include moving weights calculation logic to article class, thus making it reach instead of anemic, and increasing cohesion: 

Next we do two operations. First is getting count of items in group. implements with property, and it simply returns count of items in group, without enumerating them: 

You are using the same pattern in both your loops - enable some flag before the loop, and disable that flag immediately as you enter the loop. So basically you want to always enter the loop and always exit loop unless something will enable the flag. 

I would suggest you to check if your controls have integer value before parsing text (), separate UI logic from business logic and assign to your comboboxes some objects which have value. So that you will be able to use it directly without checking indexes. You should create some class with appropriate name: 

Next: I suggest you to use more meaningful names for variables, even if it's one-letter variable. I.e. instead of for element you can use . And last, you can write following extension method to nicely compare strings 

And last - don't use variable names like , , etc. These names does not explain what data these variables hold. Use names from domain of your application. 

But I also prefer readability on first place (performance should be improved only if its a problem) so I would go with Max and Min month instead of sorting them and keeping in mind what is Last and what is First: 

First - if you are working with DataTables, then you can use Linq to DataSet, which has nice extension methods to get field values. Now let's review logic of your code. You are not using any data from and in your result. Actually you only finding joined categories between these two tables, and for each matched rows pair you are adding all values from and to result. I find this logic pretty strange. Maybe you are expecting only single match here. Then you will need boolean result (match found or not). But basically you need count of joined rows: 

For me its a little harder to understand, because you are incrementing loop variable in loop body on some conditions inside other loops. But you are not creating strings here as you do in your second approach. So it's definitely better in terms of performance and memory usage, than you original second approach. In second approach you can eliminate usage of boolean flag, and condition check in second while loop. Also with some comments this code becomes easier to understand: 

Also you are missing very important part - you should log/notify about incorrect data in your datasource. If you have guard conditions, then parsing will throw exception rather than skipping incorrect data. So, implementation of repository can look like: 

Pretty clean. You just check if parameter has value, add it command and add new filter for where clause. After that you just join all filters and you have query string ready. Next step is separating Data Access code from UI code, and making sure that connection and command are closed after usage. Following method does not know anything about UI. Actually you can move both these methods to separate class (Repository): 

Its not that fast, and it creates array of words which uses memory. But it's easy to understand for other developers. So, instead of doing premature optimization, I'd go with this approach and modified it only in case of performance problems. 

Your current code is not very easy to maintain and understand because business logic is spread between different types. Consider what you should to do when new type of email is added: 

In the perfect world, I would like to keep all this knowledge in one place. E.g. you can use the power of C# interpolated strings which is a template string with interpolated expressions: 

That will parse xml, return questions and sort them in random order. Now your game loop can look like: 

Note: last refactoring with rich domain model approach is at the bottom. But you can see my 3 refactoring steps which lead to nice object-oriented design. You can use Linq to make your code more readable. Also you can give names for intermediate results: 

You are adhering to OCP principle, which is good - you can extend providers easily without changing other code. 

Same can be achieved without using a flag - use infinite loop and break it only when your exit condition happen 

And move data-access logic into separate class (with this Question class you event can use Xml serialization attributes to deserialize questions from xml file), e.g. 

Another option is usage of logging library (NLog, log4net etc). You will be able to define logging targets (or appenders) which will write messages to console, file, database etc. You will be able to define levels of logging messages from configuration file without changing your application code. E.g. with NLog you can get instance of logger 

Note that I have added support of several extensions to single runner. Then I would create runner class which would use all these settings: 

The first thing which I would approve in this code - it's extensibility. Currently each time you add support to new file type, you have to open source code of your application, modify it, compile and only then you can use it. Same goes to modifying runner associated with file type, or changing format of args passed to process. I would made this part configurable on the fly. E.g. with xml or json config file: 

Now prepare dictionary with fileType-runner mapping (you can add validation here as well to check whether some fileTypes are mapped to several runners): 

Here for each item in collection you enumerate every item in collection to get only items which are children of current. That gives you N * N iterations totally. Count is calculated same way. Now lets look on my code. 

I also would recommend to use named constants instead of magic numbers , , . Also maybe you don't need to create new list, because it will share same articles as list yo passed to method. 

First of all - you have awful duplication of payment calculation you do this in each row. Move calculation to the bottom of method: 

Now all your if..else blocks is just a query string generation. But here goes your biggest problem. Your application is vulnerable to SQL Injection attacks (I strongly recommend you to follow link and read article). Instead of concatenating query string you should pass values to SQL server as command parameters. And command building code can look like: 

Also it would be nice if you'll explain in code why only and are appropriate values for . Something like 

As I understand logic of your - you don't want to fetch same question several times and you want to have questions in random order. Than can be done really easy without any blacklists and looping while next random question is not in blacklist: 

And use it to write debug messages if debug level message are enabled in configuration (you can change message format from config): 

You can create lookup for children. That will involve single enumeration over items collection instead of enumerating all items for each calculation of each item. I.e. you currently have 2 * N * N iterations for calculating child count and child item count. With lookup you will have N + N + N iterations 

Also I don't see any need to have nullable type for months sequence. It should have integers. If month exist in list, then you can avoid sorting - so do this check first. Thus you are not going to add/remove month, then saving ordered sequence to array is little better: 

Use English language for naming. .NET uses English for naming. You have mix of languages, and code looks like obfuscated for those who don't speak German. Use descriptive names. I don't know German, but , , is definitely not very descriptive. You have mix of presentation-related and data access code. You should split this code.