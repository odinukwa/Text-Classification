For complicated sequences of code, you have to make a subjective judgement about where to use variables and where not to in order to make the code as clear as possible. But in this case, I think most programmers would agree that the variables are fairly unnecessary. Let output formatting be controlled by the formatting routines Evaluating an RPN expression doesn't include formatting - in particular, deciding whether the result is an integer or not is a separate task from just getting the result in the first place. So at the end of , just return a . When you print it, instead of you can do 

At this point, you can spend a lot of time making little tweaks to try to squeeze some extra performance out of the program, but I don't think there are any major performance gains left. It's already something like 40% faster than the original, which is not bad. Of course, as dawg wrote in a comment, you can accomplish this task using Python's standard module . 

I leave it to you to figure out the best way to put / blocks around this code. Actually, the way I've done it here has a problem dealing with the case where is zero (this would happen if you include constants or zero-argument functions in the list of operators). To get around that, you can use the following: 

Evaluating This new function is going to do mostly the same thing as your function currently does, except that instead of prompting using , it will take a string argument, and instead of printing the result, it will it. Let me pick on a few things in that function, though. Let the stack just be a stack 

I'm not quite sure what you're asking for, but I was bored so I typed this up anyway. Hopefully it helps. ;-) Working from the outside in: Invocation 

Yes. If your functions logically only operate on 8-bit byte values, then that's an important fact you can and should capture in the type signature. If returning a value of or or would be absurd, then eliminate the possibility of that even happening! In General There are other odds and ends that could be changed or cleaned up, like comparing arguments to or instead of using them directly () or using s instead of more pattern matching (). 

A lot of repeated instances of in there, but that's not so bad given we can use this as a combinator. Now we can put our function together. 

I think what you've missed is the instance for the datatype from . Using methods from and you can eliminate the use of in your code. Because is , your method is just . And similarly your is . is largely the same logic, you just let someone else do all the work. 

Notice that we're building functions that can be easily composed to produce the functionality our final program requires. Going from an arbitrary string to just one containing valid letters all in lower case is easy, . Going by the original statement of functionality, we next need to determine a letter's position in the alphabet so that we can then keep a tally of letter frequencies. In writing a functional version though we can be smarter. Instead of picking a letter and then finding the correct tally to increase, we rearrange the order of operations. First we group letters and then we count the number of elements in each group to produce a tally. Perusing the documentation for we'll pull out and . will rearrange our list of , then will organize them into lists by equality. The last step is to run length encode the groups to produce a tally for each letter. 

Not much of a change. Actually, using is slower here, so let's discard that change. Time now to take a closer look at . 

Speed issues Since you indicated an interest in speeding up the program, the first thing to do is set a benchmark for how fast it runs. You can do this using the module's function: 

All told, the changes you need to make to the code to use indices everywhere wind up hurting, not helping. Here's the timing result: 

If you think about it, you don't even really need the common prefix itself, except for the one string you actually return from . You only need its length, so you can decide which substring is the longest. So instead of using a function that finds the full common prefix, just write one that will give you its length. You store the length, along with one of the strings, and at the end of , use the length to trim the stored string. 

But I don't see any major disadvantage to the way you're doing it. It's just that other programmers will probably find it kind of odd. 

Then, when you invoke an operator, instead of hard-coding two arguments like you did or like I did above, 

For another perspective in addition to the existing answers, here are my thoughts. I've made a github repository which goes through each of the changes I made step by step. I've linked to the corresponding commit for each of the points that follow. (There are a few relatively minor commits in the repository that I left out of this answer.) Code clarity issues 

Iterating over pairs of consecutive elements is a common task that has a fairly standard recipe, , given in the documentation for the itertools module. You can use the implementation from the more-itertools package if you want. This also lets you get rid of the / block (which probably didn't affect runtime much, but it helps code clarity). Python has a built-in function, , to find the maximum value of an iterable. If you use it, then the nuts and bolts of the loop as well as the compare-and-store-if-greater process get handled internally by the interpreter, which should be faster than doing them manually in pure Python. Repeatedly accessing an attribute of an object, namely the method , is slower than accessing it once and storing it locally as a new variable. 

I have a code that fetches rates from a website called X-Rates, and outputs to excel the monthly averages of a chosen country. The code runs quite fast, but I still think I could improve the code a little bit, but just don't know what to look for. I've done the obvious things like, making the option explicit and disabling screen updating. Can someone point my flaws? Also you will see that the code uses if's instead of select case. Could this be an improvement to think about atm? Apologies for long code, but if you help me I would be eternally grateful! 

I am trying to perfect my string splitter's performance, to be more fast, more easy to maintain if someone else reads it and more readable code-wise. Context ,Scope and Objectives Where I work we use a sort of "configuration files" to calculate some data warehouse databases. For example, if you wanted to config a file to calculate the number of supermarkets in a country, the config file would like the below example, where the: first line is the description/name of the store and the line below is the code for the program to pick up (where 50 = S is the category for the sales, 97 = 01 is the "I've bought it myself" and 183 is the column where the code for the store is stored (in this case 0040). 

I have this code that fetches rates from a website called X-Rates, and outputs to excel the monthly averages of a chosen country. The code runs quite fast, but I still think there's improvements to be done! Apologies for long code, but if you help me I would be really grateful! 

So the codes for the configuration are mostly the same across all variables, but it always end with an equal sign. It happens that when a store has more than 10 codes we have to split them manually, it results in a quite of work. My ultimate goal for this string splitter is for it to be : fast, reliable, easy to maintain /understand and user friendly. Concerns about code Being unexperienced with programming, I still have issues using the proper naming conventions. I have been studying the VBA Developers Handbook by Ken Getz and I didn't quite understand the conventions. Also I feel that I am using a shotgun to kill a ant (apologies for the cringy metaphor). Code & Logic 

Do tokenization the easy way Your input strings consist of tokens (numbers, operators, functions) separated by whitespace, right? There's a built-in method to split a whitespace-separated string: . You don't need to bother with a buffer, or with iterating through the string's characters. 

If it's faster to avoid computing a substring in your replacement, you might think of doing the same thing when you're finding the suffixes in the first place. In other words, instead of calculating all the suffixes of a string in , just make a list of tuples to represent the suffixes. Then whenever you need to actually compare two suffixes, instead of taking a substring of the original string, you just start comparing characters at the required indices. There are two problems with this in practice: first, Python isn't well suited to iterating from an arbitrary point in the middle of a string. In a language like C, where strings are character pointers, this would work out quite well, because you can jump into the middle of the string by advancing a pointer. But in Python, iterating from the middle of a string requires you to either start from the beginning and just skip the first several characters, or bypass the whole iteration mechanism and use a loop with an integer index to access characters inside the string by their indices (which typically involves more Python code that is relatively inefficient). And besides, the other reason is you need to create the substrings anyway to sort them. If you try to do it so that you use the substrings as comparison keys without actually storing them, the program spends a lot of time converting between a substring and its index. 

I have no idea what's in the code (well, I could look, but I'll leave that as an exercise), but it's clearly heavily optimized for this kind of task. It's another 25% faster than my best version of your program: 

I think in most cases you're going to be better off passing around a pure source of randomness or a seed value so that you can guarantee deterministic output if need be by using the same seed in multiple runs. That is, you made the right choice. 

I do question the necessity of writing this particular function. Concatenating and should probably be taken care of separately to prepending a tuple to a list. E.g., 

This works! I've imported from here to account for our function sometimes returning ( drops all the s and returns a list of the values). We use a right fold to accumulate our values, and a starting value of for our accumulator. There are a few ways to go from here to clean things up further. You could get rid of the value by using , at the cost of adding another composition with into the mix. If you have sharp eyes and a working knowledge of the Typeclassopedia you'll note a striking similarity between the way we use with a right fold, and a . If you don't have a working knowledge of the Typeclassopedia, our motivation is that s allow us to specify an identity element and an associative reduction operation, revealing some higher level abstractions (and functions) we can use to wire our code together. Let's make a . 

I've still yet to tackle or , but I'll hopefully have some time tomorrow to take another pass and think more about architecture and data structures and get to those then as well. 

Compute the product at each index. The rest of the code is just pretty-printing and IO. On the very small sample input you provided my version actually runs a fraction of a second faster than yours, my guess is that's due to the overhead you incur from setting up your vectors. If you have a larger sample input I'd be very interested to see the performance. I would wager that our two versions stay within an order of magnitude of each other on running time, and they should use roughly the same amount of space due to lazy evaluation in my version. Theoretically. ;)