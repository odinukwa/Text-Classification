Hint: If you find yourself doing something over and over and over, you probably need a loop. Since this is a login form and that you expect just 1 variable besides the password, don't have so many vars in your script: , , , , , , ... just use . If you really need to cycle through all possibilities build an array and loop until you find the one the user submitted: 

Remember that server code should never trust incoming data as safe, even if you wrote the front end (website) code. If I wanted to inject SQL into your queries, I would go on your website and watch what legitimate HTTP requests look like. Once I know the URL and parameters sent by your AJAX call, I would craft my custom request but replace the valid cat IDs with SQL. I don't even need to use your website to make these requests to your server so good website code does not protect you. Addendum One simple fix: in ; if your DB field holds integers, use: 

Unless I'm missing something, your and can be used for other operations as well, because you don't actually check that the queries are or respectively. In fact you call when the consuming code calls or so why have all these functions? In and , you accept an argument () that you don't use. Why? 

From what you posted, I cannot tell whether you're sanitizing the data before saving it to the database. Hopefully you're not just inserting strings you received from the client into your DB queries (this would expose you to SQL Injection attacks), but are instead using parameterized queries. How do you handle a query not returning any result? For instance when I look at , you call on your results without checking whether there is such a result. I'm not familiar with Laravel so maybe it handles this for you? Be sure to test how your script handles getting a non-existent resource. In your class, you create a new instance of every time a method is called. This is a waste because you will have a lot of parallel connections to your database that you never close and all those objects must be kept in memory. A better approach would be to instantiate a in the constructor of , assign it to a class variable, and use it for all DB queries. Then in the function of , disconnect from the DB. 

Note that I already change the container type to . Otherwise the random access through would not work and you'd have to use again (or save the iterators instead of indices). 

It's easier to write and read. The same applies for creating a random number in some interval. And while you're at it, you can also exchange the random number generator for a better one. Simplifications Your method is rather strange. If you later decide to start your population with 100 bunnies instead of 5, you would require a lot more variables to fill your list. To initialize your list with a number a default created values, simply write . This will fill the list with bunnies, which should be some variable in your class. In your method you should use a range-based-for loop instead of your loop. That will make getting the iterator beforehand obsolete: 

I'm currently using the Advent of Code programming challenges as an opportunity to learn some python. The following code is my solution for the Day 8 challenge, where the task is to write a programm that reads a set of instructions which are then performed on registers. Registers start with a value of 0. Each instruction may increase or decrease the value of a register. The programm should return the maximum value in any register at the end of execution as well as the maximum that any register had during the whole process. An instructions looks as follows: . Where is a name of a register, is either to increase the value of a register, or to decrease its value. is a comparison operator. The instruction should only be executed if the condition is true, e.g. will increase the value of the register by 10 if the current value for register is less than 0. I read the input from a file called . An example input can be found here. The expected output for this input would be . 

I'm not trying to be too critical of your variable naming but I do have to be for completionism and for other future Robot Framework users looking for how to write readable code. Because (it appears) that you're using the Python version of Robot Framework, I'd say it's good practice to keep to the Python convention of naming variables, which is for local variables or for global variables and index variables in loops. Also, shorter, more descriptive variable names are perfectly acceptable for this size of program. Re-written for that, your variables should be , , , , , and . Mechanically, I'm assuming it works fine as-written, but there's a few optimization problems. First, having a custom keyword for a single action is usually redundant (unless you want to simplify a repeated action with a lot of parameters to a single word for readability), so you could re-write your For loop as follows (using the re-formatted variables): 

I don't currently have the code available to me, so I don't feel comfortable investigating the dictionary or sub-functions, but that's the result of the small optimizations suggested. It already looks much cleaner and shorter, at least on the bottom half. EDIT: After more editing, I've transferred everything over to an array-style implementation, further shortened some of the logic, and divided the code into sub-methods. Still interested in any further optimization suggestions anyone might have. 

That makes the keyword unnecessary, making your code easier to maintain. Finally, as another good practice, Selenium2Library is outdated. You'll need to download it separately, but ExtendedSelenium2Library is more robust, contains more keywords, and includes code to deal with Angular applications. The final code after formatting and optimization looks like this (I also took some liberties on comments that are either unnecessary or too wordy for what they describe): 

The use of the range-based-for is great, but you should use a reference there, since you only need to read one value of it. Otherwise each female would be copied as the variable . Furthermore you are creating a new object and copy that into your list. You should use the method in this case, which will directly create the object in the list: 

The same goes for your checking for random events. Make that a function that can take a probability and returns or : 

Includes I figured your has some includes for , , and stuff. While you might find that helpful to only have one header , it's rather bad practice. A header should only include the stuff it really needs, no more. Otherwise you might create false dependencies. E.g. your is the only one that uses , which it only gets through including that doesn't need it. So if you change the includes in you might break . Also every header should have include guards, to prevent double inclusion. Avoid using Don't use to print the end of a line to your stream. It flushes the stream unnecessarily and makes your output slower. Simply use . For more information see here. Don't use Your header has a somewhere. Don't use that, you are poluting the global namespace with a lot of simple and common names. It's also less readable that way. The name is the namespace is so short on purpose, so that's it not a hassle to write. Again, for more info on that matter read here. Don't use magic numbers You are using hard coded numbers in your code for specific checks (required age for reproduction and max population). While it's easy to see what they are used for it gets harder to change them later on, the more your program grows. Use named variables for them, so it's easier to understand and you can see where they are actually used. Don't repeat yourself Whenever you write the same code twice, you should ask yourself, how you can prevent that in the first place. There are multiple instance where you create random numbers in some interval or check whether an event happened with a certain chance. Make those two things functions that can be reused and more easily read. And while you're at it, replace the random number generator with a better one(you can watch this to see why is considered very bad)). You could write a small namespace for such utility functions, e.g.: 

After a significant amount of optimization, I got it... mostly. The main looping variable for the While Loop is still clunky (still working through BuiltIn's method of accessing Robot Framework-style variables), but it's about 1/6 as long as the original with the same functionality, and runs significantly faster with less overhead. I'm now working on nesting the While loops. 

Given one of the main highlights of Robot Framework is readability, I'll show my suggestions to improve that first and then go into my mechanical suggestions. First, good readability practice in Robot Framework is to line up your cells by tabs (or sets of four characters depending on your IDE) and capitalize each word of your keyword uses. So, your code as sent would look like this. 

In other notes, this is actually a very good first Robot Framework script that is very optimal (as far as I can tell) other than my suggestions. Also, I completely missed who wrote this code originally when I was writing up this review. I know this guy IRL. Hey Fin! Hope this explained how I get my code to look so nice. 

A common feature of basic loops is the functionality, allowing the user to specify break points for their loop to stop. I've been creating a keyword to enable nesting loops in Robot Framework. This Nestable For Loop for Robot Framework includes the functionality. The basic code for a nestable Robot Framework For Loop is located here. This is a strict upgrade, in that it includes the functionality in the form of the keyword . requires a single argument: a Boolean expression written in a string. includes two methods to work with this kind of expression: and . returns True if the expression is a Boolean string (including unsupported Boolean expressions), and returns if the expression would logically evaluate to . Because the nature of this code is to be nestable, I need it to be as fast and efficient as possible, so I'm looking for performance and algorithm-based suggestions.