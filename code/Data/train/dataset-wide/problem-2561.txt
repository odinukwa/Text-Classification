Check if all leaves are at same level. This question is attributed to geek for geeks. Looking for code-review, optimization and best practices. 

The question is attributed to GeeksForGeeks. Since the code dictates not additional data structure, I am forced to extract out TreeNode class outside, rather than keeping it as an internal data structure. Looking for code-review, best practices and optimizations. 

Convert a sorted linkedlist into a balanced binary search tree. Looking for code-review, optimizations, and best practices. 

Given the binary Tree and the two nodes say ‘a’ and ‘b’, determine whether the two nodes are cousins of each other or not. Two nodes are cousins of each other if they are at same level and have different parents. Looking for code review, optimizations and best practices. 

Design a Data Structure SpecialStack that supports all the stack operations like push(), pop(), isEmpty(), isFull() and an additional operation getMin() which should return minimum element from the SpecialStack. All these operations of SpecialStack must be O(1). To implement SpecialStack, you should only use standard Stack data structure and no other data structure like arrays, list, .. etc. Looking for code review, optimizations, best practices. 

Finer details such as tie-breakers, rules of input params etc, are well documented. Looking for code review, optimization and best practices. 

Given a Binary Tree, find the deepest leaf node that is left child of its parent. This question is attributed to GeeksForGeeks. Looking for code-review, optimizations and best practices. 

This is very much the same idea I'm using to encapsulate "business logic" queries for re-use in PL/SQL code. So if you're looking for a validation of a concept you'll pass my review :) In a comment to the other answer you said this is just a snippet from a package code - that's good you're using packages. For PL/SQL apps in practice all code should be located in a package - a standalone subprograms a rare. The notes: 

The is just for demonstration and is to guarantee the correct ordering of the tables. The is not needed if you have other rules ensuring the id is found only from one table. If the id can be found from different tables just add a wrapper -query (the details left for exercise) to pick the first one only. Now just wrap that inside your PL/SQL as you see appropriate. When some information is not available in all tables it's up to you what is the value indicating missing value. It can be e.g. or or depending on the context. However I'd recommend unless there is other factors that rule that out. Hope this helps ! 

I'm afraid you current solution is a prime example of inappropriate use of PL/SQL when plain SQL provides much more elegant solution: 

I'd solve the problem by providing a PL/SQL procedure that knows the "split"-logic. In the example below I assume that non-splitted rows are not inserted into the table at all but all inserts should be done with the procedure. This is a rather common pattern when there's data manipulations but it is not clear from your problem statement if this is an acceptable solution in your case. I used regular expressions as it's a very handy tool for pattern matching with superior expressiveness and clarity compared to spaghetti. I didn't used triggers as it's not possible to modify the table trigger is attached to. The solution can be easily applied even if you need to read the input data (i.e. non-splitted) from the same table. Example 

Here is my thoughts: Cut out 'Manager' from the name of all those managers. becomes . The job of an object is to manage its state and behaviour, so you don't need to explicitly say it. The same way when you create a new list, you don't call it ListManager, you simply say List. When you're inside a class like you don't need to mention the class name over and over. becomes , becomes . It's pretty clear who you're referring to, the class itself. The same way when you have a list of integers you don't say . You simply say Let's have a look at this code: 

This way you can read the code easily. So, I suggest to move your method and put it below method. Also in unity you don't have to make a member variable public to see it in the inspector editor. You can simply put before any variable and it shows up in the inspector. In terms of Inheritance or Composition, use none of them in this case. Don't make your code more complicated than it should be. Your list managers don't have any client, so no need to use any of those polymorphic technique here. You might say, how about code reuse or maintenance. Your code is not big enough to worry about those right now. Always go for simplicity. Sometimes, simplicity means using inheritance and composition, but that's a big topic and there are also many opposite opinions about it. Just a quick side note. Unity3D has a component-based architecture. Try to have that in mind when designing your app architecture. 

Your core problem is how to find out top-1 and bottom-1 in a single query. This is essentially a SQL problem and has not much to do with PL/SQL. First I present you the SQL solution and then simply wrap that into PL/SQL. You didn't provided table definitions. I was lazy and didn't tried to reverse engineer your schema but instead created very simple table that illustrates the solution that you can apply to your real problem. Other notes that might or might not be relevant to your case: 

As bonus I also introduced you to standard SQL datetime-literal syntax. Let's create some data to play with: 

is always guaranteed to return a single number so the exception handler for is a dead code and should be removed. If you're just checking for existence there's no point to count beyond 1, thus enter . This also guarantees the returns either or . This might or might not help your query performance (check explain plan). It's a bit questionable if such an utility subprogram should record the exception or not but more information about your error handling implementation would be required to comment further. I usually don't but I'll let the exception propagate to the caller context and then record the full stack trace there. The good thing is that you (I just assume that from the name of ). 

Use analytic function (you might also consider using or functions instead) to assign an unique number in ordered sequence to each row. This is the standard way to implement top-N, bottom-N and inner-N queries in Oracle. Note that this example doesn't resolve ties.