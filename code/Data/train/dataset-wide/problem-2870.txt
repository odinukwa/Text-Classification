and then proceed as you are already doing (randomize the list and write it in a file, or whatever the case may be). Let me know if something is unclear. 

Transform it from the original format (in this case ) into the format of your choice (in this case ), Get the two s representing the two sides of the . Parse the two s and build the resulting object. 

In my other answer a discussion was born on the performance of 2 methods. In this answer I decided to post the code of the tests I ran for whom may be interested: 

The current method does a bit too much IMO. It parses the string and also finds the solutions. I'd split that in two parts: one which gets all the possible numbers starting from the original string and one which finds the solution based on the numbers taken from the additional method. 

Another thing from the design point of view: The class doesn't seem to need instance methods. You don't actually need to create or objects (at least, so it seems). In that case the class should be declared static and the constructor goes away and the actual instance methods and properties have to be transformed to ones (the current methods just create a object that calls the instance methods anyway). Regarding the object, what's it doing there? Is it actually needed for the algorithm? If it's there for debugging purposes use it in directives. The same for the bit. Performance Regarding the performance bottleneck on and I'd suggest two changes (besides changing the name into something more meaningful): 

As for a review for your code, I don't see any major issue. I'd just suggest to be consistent with spacing - you sometimes put 2 empty lines between methods and sometimes 1, and also sometimes put an empty line before the end of the method and sometimes don't - and also to be consistent with brackets (put them even in 1 line s). As for the solution, I'd just transform it into an iterative one. Your solution (which is the same one I came with) is similar to the Insertion Sort for arrays, so I'd argue also about the complexity you came up with. Let's discuss about the algorithm here. We have the following statuses in different times: 

First of all, I don't know python, so my answer will be pretty generic. That being said, let's address your doubts: 

Comments The last thing is about comments. Inline comments can get really long. Some (me included) like them in this way: 

Start with an empty tree with a single root Expand the root (insert the nodes for the first level) with the possible elements of the first bag If sum from to is then there is no need to proceed further on this path. If sum from to is increase counter and stop expanding this path. If sum from to is repeat point 2 with the current node instead of the root and by expanding the node with the possible elements of . 

The former should be extracted and put into a method or just return the longest sequence if you're out of the loop (and this takes care of your concern #2). The latter can just be taken out of the condition. The code inside the loop can be written as follows: 

Other than these things, everything else looks fine. P.S: The code I wrote is not tested, it's there just to better explain the idea. 

As a side note: I'd use anyway, even if performance does not improve much on small numbers, but this can be seen as a personal preference. 

As an alternative, you can make it an extension method of the class, and I'd suggest a rename of the method in this case: 

I'd say that there's a flaw in the logic of the code in the cup :). It should be more like the following: 

In order to transform the original string to an accepted string you just have to do some substitutions and then by splitting the accepted string by you get the values. So, to recap, in order to parse the you get in input you have to: 

As @Heslacher mentioned in his answer, naming should be changed into something better. I'd suggest to change: 

I'd go with removing the block. In the conditions you just have to check that is smaller than the array's length. I'd also avoid throwing the and instead just return a that cannot exist in any maze, if such a point exists, or , but that's just a preference of mine (I don't like throwing many exceptions and tend to keep them to a minimum, especially if we're talking about checked exceptions, see here why). 

Except for indentation (which I'm guessing is like this only on the question) the code seems pretty readable. Regarding performance I'd have some suggestions: 

Looking at your code, you get the type of the generic param into the method body (which can be seen also as a violation of the Separation of Concerns principle). In order to solve the issue, you can pass the type as a parameter. The resulting code should be something like the following: 

Let's take an example. If we have that and we'd need the numbers from to . We just parse to , multiply it by 10 for 3 times (length of is 2 and is 5) and return the numbers from 15000 to 15999 ( is set to 16000 which is the first value that is not allowed). In addition, if you just need an the previous method would be something like the following: 

For more ways to handle exceptions I would suggest to read this article. That being said, try to avoid creating new objects inside cycles where possible. For example: 

Personally, if I wouldn't want to refactor the code too much (because the project is too small or whatever the case may be), I'd go with: 

The same can be done with the conditions and in the upper levels. The name of the string is a little misleading. is usually used as an index. I think would be a proper name. The resulting code could be transformed from: 

because I find the control not really useful. I mean, if the is then nothing happens, remains . Better yet (in my opinion), if you add a constructor: 

Another way to go at it (which I personally like the most) would be by using the and operators and not managing s and s. In this case, the would become something like the following (still not tested): 

You declare variables inside cycles in a lot of cases. Bring the declaration outside of the cycles and assign them values in the cycles, in this way you create the object only once. Also, don't concatenate strings using the operator when you are in a cycle. Use the object. You also do some operations that are not optimal, like which is equal to . Also, can be written as which could also be put inside a block to catch overflows if it's needed. Regarding the objects, try to replace them with s. In the case of the method that you use in the code, you could just define a extension method for s. After this refactoring the code would look like the following: 

Obviously it has to be translated in Java and to be readapted/debugged/tested/etc. The end result for the string should be something like Let me know if something is unclear. 

We have a prefix indicated by a string (that has a numeric format alright, but it is a string) We have a max length, let's call it , of the numbers you can consider. The allowed length of the prefix, let's call it , should be We need all the numbers that start with the given prefix and have the given 

and set the and as fields/variables (they seem kind of magic numbers now). Basically, the refactoring just reduces the depth of the code, but that's just personal taste. As an alternative method The critical point, IMO is to know what the input string represents and seems like you've already taken care of that (if I understood it correctly). Everything else should be pretty easy. The way I'd go with it is the following: 

method In the current case, for s I mean, the method seems good. In case you consider changing it for the general case, I'd suggest the following logic: 

IMO this method does a little too much. It: checks if the parameters are valid (, which I think should also be given the context) and also takes action to prevent the application from going on (throws exceptions, in this case). I'd change it into something like the following: 

In addition to what has been said already (and if I understood the problem correctly), I'd say that you are complicating things too much. Let's think about it (on a single prefix for now): 

I agree with what @BCdotWEB said. In the first point though you could continue using and if you want to just improve readability transform it from 

can be executed in \$O(1)\$ time instead of the current \$O(n)\$. The resulting code after the change should be something in the lines of: 

I'd suggest doing the implementation of the various methods in the class. In this way, from the you just have to call . It's fine as long as you call the method very few times and space is critical. Otherwise I'd suggest to keep in each node a balance factor (like in AVL trees for example). 

As for the chosen algorithm and possible alternative I'd suggest Iterative Deepening DFS. It has the best of both Depth-First Search and Breadth-First Search - it's complete, finds the optimal solution, and doesn't use too much space. Let me know if anything's unclear. 

should be moved to another method (in order to follow the Separation of Concerns principle). In your methods, you access too many times (even in cycles). Given that the length doesn't change I'd suggest to memorize it in an variable. For readability's sake, you could transform into That being said, if performance is key, I'd overload the methods with some other methods that work directly with instead of and contain all the logic and call those from the methods working with . 

As mentioned in a comment of mine, it's possible that there's a bug in the code. The call should always sort on a single value, . The call should be equal to because the method does not filter values. That being said, I'll consider it as from here on out. If this is not the case let me know and I'll delete this answer. I see that you count likes and dislikes a couple of times in your queries, in the method and in the and properties in the final . Keeping in mind this consideration I'd change the query in the following: 

The first thing that pops in my mind is the naming you used. For example, from a method called I'd expect to receive a and not a string. The same from . In the method the variable should be renamed IMO as the name is not so meaningful. The same regarding . Also, commented code is only confusing. I'd remove it. In addition: 

This change allows you to remove the line. So, in short, the method should become something like the following (not tested): 

I'd approach this in a different way. Looking at the problem I'd sum the different bag capacities until they are \$<= n\$. The moment the sum becomes \$> n\$ I have to stop incresing this sum as it would be useless. Doing this kind of reasoning I'd go with a tree structure. The max level of the tree should be the number \$k\$ of bags/buckets. The spanning factor for each node in the -th level is (from 0 to max capacity of the bag). So, the operations of the algorithm should be the following: 

One more thing that comes to mind is to switch the comparison clauses in the and properties. Note that the two versions could be the same in terms of performance, depending on the execution plan that the query optimizer generates, but personally I prefer to put the most selective comparison clause first. So, the final version would be the following: