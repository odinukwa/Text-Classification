The string concatenation operator "+", by definition, "concatenates two or more" strings. $URL$ This query executes successfully because the implied second string is the non-null concatenation identity (empty string). This works in the same way as the operator in ; the implied second number is the non-null addition identity '0'. The syntax is allowed because of the need for expressions such as . Neither nor will execute, but only because of parser rules. Consider the Execution Plans generated by these SQL Statements (I added top(1) to obtain a plan): 

I want to extract a complete list of the node names and their paths from any arbitrary, well-formed JSON document stored as nvarchar value in SQL Server 2016. Is there a reliable way to do this? For Example, for a json value: 

We have deployed one SSIS 2012 project with two ADO.Net Project Connection Managers. (There are five packages within the project.) The project has a related Environment, with a variable containing a server name. I want to map the variable to the project connection manager ServerName property. When I right-click on the SSIS project node in SSMS 2012, launching the Configure dialog box, I can locate the Connection Manager, and highlight it to see its properties, but ServerName is not visible in the Properties list. Usually, the ServerName property is listed under the RetainSameConnection property. It's visible on other Project Connection Managers in the same project. Why would this property be hidden, just for one Connection Manager? 

Any help is appreciated. If this has been answered in another post, please let me know (I tried searching). 

The problem was, as proposed by some in comments, that Database Instant File Initialization was not enabled on the instance. I enabled this by giving the user under which the SQL Server service was running the needed permissions, and then restarted the SQL Server Service. The steps to take can be found in the following link: Database Instant File Initialization Thanks for all the suggestions, some of them pointed me to the solution. 

We have an SQL Server 2014 (recently upgraded from 2008 R2) instance where one of the databases has some strange settings for collation: In the Properties window for the database we have the following: 

I have a user defined table type in SQL Server 2014 that I need to drop and recreate. However, if I use the script from SSMS, the default value constraints that are on some of the columns, will not be created. I also have problems viewing the default constraint, so I do not what the default value should be. Is there a way to view what those default value constraints contain? 

My question is as follows: If the DIFF Backup 1-file is corrupted somehow, could I then restore the database with just the FULL and LOG backups? Like this: 

Under full recovery mode, will a differential backup "break" the previous log backups? Let me give an example: Let's say we have the following backups: 

I'm looking for a specific "best practice" or "pattern" concerning entities that are shared between different entities, having a relation to one of many. For example, one may have the generic entity "Address", which could be used to store the common address fields for customers, suppliers, employees, etc... Would a seasoned DBA take that route or would he rather add the fields to the corresponding entities? I'm also thinking about maintainability, constraints that may (in the future) differ depending on the entity, things like that. I would love to get references to any authoritative or established works on the subject. 

It returns a string '0x...(an array of hexadecimal values)'. But when I try to select on the column using copy-and-paste making sure I have the exact binary equivalent: 

This view will never be called without a where clause though (which in my case would almost return the entire database). It will always be with . However as soon as I add the where clause, the ORDER BY clause is ignored! Without the where clause it is working as expected. Actually a different question but I'm throwing it in here while I'm at it, is there a better way to retrieve such info? The and will be identical for all returned rows, which is a small waist of network bandwidth. Not that that is a problem, but I'm wondering if anything exists to tackle that without the latency overhead of multiple round-trips to the database? [Edit] The above sample was over-simplified, the calculated field has other factors so that it would return a different order than simply as it would in this example, but the principle should be clear. [Edit2] From the answer I come to the conclusion that the Graphical Designer has more features than the underlying database: 

I know that SQL SERVER 2016 can co-exist with previous versions on the same server. I wonder however if there are any gotchas that I should be aware of? We have a test server that already has 2008r2, 2012 and 2014 instances on it. Is there any chance that there are anything on the existing instances that will behave differently if we install 2016 also on the same server? 

I tried googling the collation Compatibility_60_406_30001, but the search came up empty. Anyone have any suggestions on what to do here? So far I have not seen any errors becaus of this, but I would like to choose a valid collation for this database also. 

Today I wanted to update to the new renamed procedure sp_BlitzFirst. After creating the new procedure, I changed the code in the agent job to run sp_BlitzFirst in stead, with the same parameters. Everything seems to go OK until it is time to output values to the tables, then there seem to be some kind of conversion error. The whole history output is as follows: 

) GO Above is the definition as it is created when generating script in SSMS. As you can see, the default values are not in the script. 

Anyone have any suggestions to what might cause this? Have the output tables changed somehow since the procedure was called sp_Askbrent? The version of sp_Askbrent was reported this way: sp_AskBrent (TM) v20 as of Jan 1 2016 12:00AM. Any help appreciated.