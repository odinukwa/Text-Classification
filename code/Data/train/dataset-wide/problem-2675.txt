I see that in your existing code, will have been closed when it returns to so will also not go anywhere. 

A random-initialized location might be handy for this specific program, but it’s sufficiently bizzare that it hinders the understanding of the code. Make a function to return a random location instead! 

? is repeating the same precondition as the function it forwards to. It is best practice in C++ to write the with the type, not the symbol name: 

Rather than writing your detection from scratch, use the detection idiom, either in the compiler's header if you have it, or a copy of the published definitions otherwise. 

is very repetitive. There is no built-in way to specify this like a statement, but I would use a data structure with the cutoffs and grades rather than a cascade of ’s. Let’s not worry about that for now; that is more advanced. 

Again, can your implementation do better than a linear search? Just let the user use and on your collection! 

sketch of an idea Avoid all division/modulo and instead build up the decimal representation using decimal arithmetic! A 64-bit value can also be treated as 8 bytes; each byte is a digit (not packed as BCD nibbles, but one per byte). You can add them by adding the 64-bit integers — each byte will add, and there can be no caries outside of the byte because the largest result is 18 and you can hold up to 255. In particular, doubling such a value means adding it to itself. The hard part, which I’ll explain later, is following that up with carry propagation. So, start with a 8-digit unpacked decimal set to all zeros; call that Accumulator. Loop while In != 0 : Take your normal integer (called In) and mask off the lowest bit, getting a result that is either 0 or 1. Add that to the least significant byte of Accumulator. Note that you have no here, no branching. It will simply add zero accomplishing nothing, or add one. You can do that add using a 32-bit or any other sized int aliased with the Accumulator, not just a byte, because you know the carry will not happen out of the byte. I mention this because byte arithmetic is slightly slower than 32/64. Then, shift In right one bit. Add Accumulator to itself, using the aliasing trick I mentioned before. Process the carries. [end of loop] Convert Accumulator to an ASCII representation by adding 0x30 to each byte. This can be a constant of 64 bits, so you do this in one add. So, how do you propagate the carries? Use SSE instructions. Load the Accumulator into an SSE register. Use an instruction which compares each (byte) element against 10 and produces a packed bitmap of the results. There will be 16 bits, indicating which bytes are too large for decimal. Use that bitmap as a mask to subtract 10 from each enabled byte. You can use the same SSE register loaded with all 10's for both steps. Shift the bitmap left by one bit. Now use that as a mask to add 1 to every enabled byte. Now, saving the SSE register back to RAM and loading it again will slow it down. So do the doubling (adding the register to itself) in SSE, also. Adding the new In bit can be done with separate instructions, or rolled into the carry step by setting the least bit (or not) after shifting left. Whichever is the least amount of jumping through hoops or avoiding a branch. 

comparison operators You don’t need so many forms of the comparison operators. First of all, a single template for will reverse the sense of any that you have, so don’t write all of them twice. Second, don’t write special forms for . You are discouraged from writing explicit tests against and instead use the contextual conversion to and . In fact, before C++11 you could not have special forms for this. If you have another value that is null, the general form will be used; so, it has to handle the null case. You can however provide a non-explicit constructor that converts to the smart pointer type. 

edit: ( has an init-list constructor in addition to other constructors. Touted as a feature when uniform init was promoted, it actually causes headscratching in code reviews exactly as I just fell into myself!) use (almost everywhere): 

whould be what you use. The body of has almost identical blocks for choice 1 and choice 2. The only difference is the call to Encrypt vs Decrypt. In the updated code above, this would be a difference of calling the same function with a 3 or a −3. In any case, write the block once, and use an statement or the like only for the part that is different. 

Instead, have a way to convert to polar regardless of what I start with: if already in polar, it’s easy! Internally, have two separate functions with different variables; your , , ⋯ , is just too muddled to deal with. Your comment “intermeditary variables used to stop math errors in the conversion” makes me think you just added them to fix a problem. Declaring all the variables you might need at the top of a function is bad. If you declared where needed, you see you only need half of those in each branch. And the function to do the converting should be (drum roll…) the constructor! 

Yes, I can see that this ends in a semicolon without a body. Comments should be meaningful, not just add noise to the file. 

I’m having trouble following this code. You have classes and that look like they should be polymorphic versions of an abstract policy because they have the same and functions which are declared . But they are not derived from anything. Then, you have a template which as far as I can tell doesn’t do anything at all. It derives from one of the above classes, but then adds no functionality or members at all. So why? Then you have PolyInterface which holds pointers to push and pop functions, with free functions to populate with the push/pop from the original Policy classes. That’s what the base class would have done automatically. I think what you want is: 

OK, you allocate memory and assign it to , then assign which leaks the node you just created. Likewise, is allocated, and then if the loop executes non-zero times you drop that on the floor, too. 

and get in the habit of using the non-member versions. These are to be called unqualified, so you need to import into your scope first (known as the "two step"). That is not needed here, but that will be needed for generic code, and also to keep your code from breaking when other parts of the program change. 

The style in C++ is to put the or with the type, not the identifier. This is called out specifically near the beginning of Stroustrup’s first book, and is an intentional difference from C style. Some people criticize the leading underscore of identifiers as a style. I point out that it is easy to clash with compiler-supplied identifiers and you must remember to never use a capital letter after the score, so it is a hazard. 

Keep at it! Please post your next version after making a Player class and not repeating code, and I’ll be happy to look at it again. 

Swapping a with a is strange. You should make that parameter a instead. And mark it as if has a no-throw swap. 

The && is a short-circuit operation, so the code has to jump. Jumps are slow. Testing that both bits are set is the same speed as testing one! 

Misc tip: use the container adaptor instead of a plain . I like your use of the C++shell web site for holding the code. Too bad it doesn’t have C++17 ☹.