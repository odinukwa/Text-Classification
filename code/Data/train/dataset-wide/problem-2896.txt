So, this is going to be a performance focused review. I'm going to be sacrificing other things to get some more performance. Keep in mind that you should benchmark each run because JIT compilers, memory paging and all the other stuff that tries to make code run fast these days can and will sometimes do a better job than humans. This is your run method... 

So when your boss or your teacher asks you to comment every line, there's not much to do about it. That doesn't take away that comments are usually used to explain "why" something was done in the code. Your teacher asks you to add a comment for each line, so explain "why & how", to show both your thought process and your solution. Specifically... 

Next, retrieve person using boolean and move the rest of the code out of the switched case... then apply the boolean where there's any changes. 

First, migrate the bodies of these conditionals to separate functions. , , etc. This helps anyone that wishes to understand the function - if the option type is a boolean it will create a checkbox, if the option type is a ... then they will create a... The details of creating something aren't relevant in a function that decides what has to be created. 

Ahhh. Find or create child. Nice. I'm still stuck with but that's because I have no idea what it's supposed to do. If performance is REALLY of key issue as such that you can't split up functions, start putting in some comments. Because the next programmer will have to maintain this and he will not be able to. 

This... it's kind of a separate function, but it's only so big because you have to do some filtering. I guess it can stay. 

Should only shuffle cards, because that's what it says it does. Create new methods , , , and possibly others. Assign these methods to the class that they should belong to. 

The reason I would express all these statements differently is because most of those things can simply be expressed in less code. The statement is not easier to understand, nor does it provide any semantic value over . By removing these overly complex syntactical structures, you make it easier to understand the code. 

From the documentation, it turns out that represents a number of weeks (that some action has to be taken). If you add this to the variable name, like , then the meaning of assignments and usages becomes more obvious. Specifically this part in : 

A with a for loop and stop on first number greater than or equaling the number to find will solve your problem. 

My personal preferences (nitpicks): I'd add a comment why you on the builder (I know why, it's for chaining, but others might not.). I'd also rename the functions and to and . This because it seems easy to mistake them for "growByFactor" and "shrinkByFactor". The documentation shows that this is not the case however, which makes this my personal preference rather than a notable improvement. I'd put blank lines between the end of a function and the start of a comment block documenting the next function. Doing so gives me the feeling that a function ends there and that I can process what I've read before continuing. 

So, why does this matter? Because this algorithm I just explained is about \$O(log n)\$. That is, N = 1000 takes 4 times as long as N = 1. N = 10^12 would take 12 times as long as N = 1. Your algorithm is \$O(n)\$, as it checks each number. That means N = 1000 takes a thousand times (1000) as long as N = 1. This means that for the higher cases, your code takes too long, as N = 10^12 means your code takes 1.000.000.000.000 times longer to complete than for N = 1. 

Somewhere else you use . Here your comment says "if non-indented line". Why are you not using your own utility function? 

In short, Write something that will create Expressions from Expressions, without you having to create ASTNodes by yourself. If you need the more complex structure you can create the ASTNodes but the ASTNodes seem like noise when defining a program. Using the simplified manner of creating Expressions to generate code with, restructure the generateAST so it is easier to read and see what it does. 

You ought to flip this sort of thing, so that the guard clauses are more apparent and less in the way. So handle the bad case first... 

And it becomes easier to spot if you made a mistake (like if you accidentally swapped the win condition for scissors vs paper with scissors vs rock). If you want to learn more about that, I suggest googling about "enums" or "magic numbers". Additionally, we might want to use the style convention that constants are UPPER_SNAKE_CASE: 

You would ignore it. Now, it will make a new selection instead, which supposedly ends at . So past EOF. This can be a feature ("Your comment goes past EOF!") or something that will break some asserts. 

Take care with plural named fields. It's very, very likely that any plural field is secretly a multi-valued field. You might want to extract a "Category" and "Tag" table out of this, so searching for them is easier. 

This assumes pizza's always have bacon, cheese and pepperoni. Consider treating cheese, bacon and pepperoni as toppings (four cheese pizza? How would you currently model it?). You can then make use of streams and : 

There's 100 mails. Thread cap at 3 threads. Thread 1 grabs a mail, starts a thread, sends a mail. Thread 2 grabs a mail, retrieves the thread counter, suspends. Thread 1 returns from sending mail, grabs a mail, retrieves the thread counter, suspends. Thread 2 creates a thread, sends a mail. Thread 1 creates a thread, sends a mail. You now have 4 threads. 

This is a possible design flaw, but understandable, I think. I'd love to talk about it some more, but the other issues are far more important. I wonder why being small matters, though. 

Extract to , and use a while loop to make sure that the move counter () doesn't go up if you make a bad move. Encapsulate conditionals by putting checks like into either a function (naming is hard) or just a temporary variable of some sorts. 

Here you have a possible bug: if stripping certain parts of the string makes the length drop from 11 to 9, then you'll get an exception when making the substring. Instead, first replace, then measure: 

This is a top level function. The only thing it is supposed to do is call other functions, which will do the work. Thus, I expect to be able to read it as a recipe. 

Next, we first fill the output array with all zero's with , and then we iterate over it again to add values with the for loop. Why bother, just set the values in there straight away: 

Your current isn't a finished pizza, it's a pizza that's in a certain state of construction. Consider making a that does not have setters, just getters (to examine the Pizza) and action methods (to eat the pizza). You can reuse your current Pizza class as an class. Create a new class which has the job to, well, make Pizza's. They're instantiated with an Oven, and will give Pizza's when handed a Recipe. I've written parts of a here to give you an idea how a Builder class would work. 

This should be documented or split up. I want to see something like this: (comments for mid code explanation) 

You could do this by incrementing another variable for every move operation, and decrementing this variable after the -for loop (with a minimum of 0). Start at + this other variable. Like that, it would, after the 3 moves in the first iteration, start the second iteration off at index 4 (i = 2, move counter = 3 - 1 iteration passed = 2). 

The backslash at the end of a line should "escape" the newline character that follows. But because you skip all characters until , you ignore the escaping and would return the file as 

Some of these might be subclasses and thus require removing. But there's no need to have the same line of code 6 times. 

Your TargetCodeGenerator's generateAST has multiple abstraction levels embedded into one method. And it's a long method. It has all of these details that are pretty complex - when I see functionality like 

In the constructor you set to true. But the application isn't running yet! What you should do is set to true in the start function. That way, whenever is called, the result is that the application is running (either it was running before, or it was started). Secondly, whenever a thread needs to be "resumed", you check like this: 

This because you use the T outside the Node class and you ended up having to add it to the addLast method. 

You create multiple objects. It's possible that between these lines of code, the processor switches to a different process to do things. This doesn't last very long, as your processor switches a LOT of times each second, but what you will see is that there can be a difference between these times. Don't rely on this behavior. Create only 1 object, and either set and to be the same value, or specifically add a certain amount to . 

should be "And so on, up to a maximum (...)" Lastly, as said by others already in the comments, this style of yours is hard to maintain. It's also pretty annoying to read, in my opinion. Editing of text prefixed with a lot of slashes like that is harder than it would be without the slashes, and if you're in the business of habitually revising your comments due to changes made, the slashes lead to a lot of busy work. If you need a visual indicator where your functions begin, there's a few options: 

we really don't need that null check anymore. Either it is null, in which case you're going to skip setting temp.prev to the null it already is, or it is not null, in which case you want to set the value. In both cases, simply setting the value gives the wanted outcome: the code does not crash and the top node's prev pointer points to the lower node if it exists, else to null. So remove the if statement. 

Your approach is works for a single start-stop cycle. Afterwards, things may go wrong. Let's look at the simple scenario first, though: You should keep in mind that you want to halt the running threads as soon as possible whilst maintaining system functionality. That is, when I say stop, and there's no calculating or whatever going on, the system ought to stop. But in your case, it might not. You see, what you have here, 

Have you ever heard about tussenvoegsels? They're parts of people's names. Well, in the Netherlands anyway. When used for authors, it's usually done as "van Surname, FirstName". Your regex doesn't support this, instead only accepting the last word of the surname. You should allow surnames to consist of multiple words. 

Because then it's already clear. It does make things more messy, but we're gonna clean that up too, promise. 

You might want to fix it so that they all use the same scanner, but you'll have to test carefully there, because users might be capable of entering things like "10 20" which is two separate ints (they'd answer 2 questions at the same time). 

Basically, what you don't do is check for duplicates. Now, there's two things this could mean: First option, you don't actually support duplicates. It's logically impossible for there to be duplicates. In that case, you should take an ordered, unique collection as input (a sorted set, as it were). A weaker alternative might be checking if you have duplicates and throwing errors for that, if altering the signature is not possible. Second option, you do support duplicates. In that case, you should alter your code to support duplicates. 

But it's still not threadsafe! Let's say we have 1 thread running the application and 1 external thread. The external thread first calls . It goes through and is now false. The application thread, however, is still busy with . That is to say, it's still waiting for input - as a result, it's still in the while loop and won't be going anywhere. Quick overview of the situation: Application thread is here: 

The problem with this sort is that it compares with even although on the previous iteration, multiple shifts happened. Take a look at the start: 

Your outset is wrong. The articles you've linked to present a nice story, but what you're running into here is the issue with that ideology: When your data structures AND your views are rigid, you can't change the system to do anything else. You're now stuck! Say I had to show a listing of Employees. I can't! There is no way to use the data stored in Employee to make a screen that contains a listing of employees. I also cannot make a REST API with this Employee object without some serious magic - I'd have to make a "View" which takes multiple Employees and ignores calls to "show" unless they're from an authorized source. You say "Class is not responsible for showing itself". 

What is this testing? Must a token generator somehow be able to create exactly 8 tokens? I feel you should write one test that tests the base - that a new single quote string token generator gives you the proper empty string. And one test that tests that, given a value, the first token will be the newly proper token, and the next will be an empty token. Another test tests whether you handle the special tokens properly. That way, you have tests that test functionality, rather than behavior... 

Simple copy-paste... There's a few useless things in there, though. We don't need the array, and we don't need to use . Let's strip them out: 

This, or something like it, is used A LOT through out your code. Consider making a method which returns a random node. 

Then after that comes the next statement, If not conditionA or not conditionB, then controlA is true. 

returns "undefined", which might not be what you want. Same goes for fractional values, although I guess that case could be waved... if you only support integers. Even so, you might want to add a check. At the very least, add a comment - problem descriptions are kept separate from your code right now, and that makes it non-obvious that it doesn't support such things! Negative numbers could be supported via prepending "minus", then . 

This line is hard to understand without the context of the problem statement. I'd recommend you pick a better name for - might be a good indication. Similarly, you say that you spotted that you can solve this problem with a pair sum. I think you should put that in the method name - contrast with . Another thing that bothers me, but now we're getting in pretty subjective territory, is the inconsistency in the placing of the array type. 

I tried hacking around this in various ways and practically the only way I could detect it was wrapped was by having an old reference to and using . Since you state your code will run before any other scripts will run, this shouldn't be a problem. That said, there's also , , , so maybe you'd want to wrap those too? From a code quality perspective, your variable naming needs work. You can haul it through a minifier later; what you have right now is unmaintainable. I don't even know what half of it does thanks to the variable naming.