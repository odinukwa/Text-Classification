First of all, I recommend you to ensure your code is correct (see my comment on your question). Here are a few suggestions about improving your code. 

Here's a related, but not quite the same exact plunkr. You can have more custom logic in the block, but frankly, I have no idea what are you trying to achieve and why is the first Http request's results are of any special interest. 

Naming Things Naming is important. Method is not informative. You may want to rename it to something like . A symmetric counter part is now too easy too name â€“ . 

In the upper cell is known to be unreachable (grid boundary, restricted cell, or learnt to be unreachable from the top-left cell by down/right moves). is the similar, but describes the left neighbor cell as unreachable. The current cells might only get reached from left or upper neighbor, respectively. Finally, is a special case which either denotes the complete "unreachability" of the cell from the top-left corner. However, it may also indicate the robot has now reached to top-left corner itself (). Recursive solution The code looks almost trivial if problem is solved recursively. 

Naming Name things properly and do not abbreviate words. is definitely not a short name, but it's describing what it does with 100% precision. Similarly, original transformed into . It may be funny, but first seeing I thought I'm reading code in Spanish. :) Please never never never use the , , , and similar. They are absolutely meaningless. Yes, the other dev "may understand" it, but you don't want anyone to guess what the code does. Spell things out, in most of the modern editors it's a matter of hitting . Temporary variables constants Do not hesitate to introduce reusable temporary constants with descriptive names. They make cryptic conditions or relay the intent of the writer. Avoid branching when possible, or minimize its "scope" An unnecessary if-then-else for processing array/non-array orders may be generalized, if we normalize the array first. Was: 

In the code provided below, notice that all the signatures declare parameter types and return type. 1.1. Little Type Hint Trick Often, frameworks or libraries return objects of type . When this happens, the compiler loses the narrow type information making the code less reliable. As an example, we can see that in our Observables' map part is doing exactly that. Since we know, what object the remote service API is supposed to return us back, we can immediately cast that expression to the specific type and make the compiler our helper again: . It's important to understand though, that in runtime there is no guarantee that the return object is actually of the same type as the type we cast to. In other words, this cast is practically helpful, but is sometimes misleading and should be used carefully. 2. Master JavaScript and TypeScript idioms TypeScript is a superset of JavaScript, i.e. whatever is syntactically correct in JS is also correct in TS. 

Notice, you can add more coin types very quickly now. You just need to "register" each coin as one that has a and a . 

This are just my 2 cents. I do not expect other developers necessarily agree with my opinion, that's fine. My objective was to provide yet another perspective and try to message that the best answer is probably still "it depends". Oh, and by the way, it's really important to get as close to the consensus with your peers as it's possible (both for the team health and for project direction strength). Their critique of the unit tests seems valid to me. But arguments aside, what exactly do the colleagues propose? It's not a secret that if the criticism is not constructive, it usually poisonous... 

I'm a C# developer and still know too little about JavaScript/TypeScript. If you know how to make this code look more JS-idiomatic, I'm all ears. Or I can paraphrase the question as "am I going the right/common route?" You can see that there is a lot of structural repetition in the code that creates Promises from callbacks (e.g. , , functions). Not nice. Is there a way to apply functional programming ideas here? I have a feeling that functional composition may get handy here, but I don't know how to apply it (a sign, I haven't grasp the concept yet) Resolved It's also easy to notice that is a pass-through. No callbacks here. There must be an easier way to bind one object's function to another object's function, which I don't know how to do. Very similarly, accessor is a supposed to be a pass-through. 

It's better in a way it helps avoiding OBOE. And by the way, another thing you can do is define it as an extension method in a separate static class, and will be able to invoke it as : 

Feedback I am looking for Here's the list of things I am interested to hear back (in order of significance): 

Now we need to change the component as well as it consumer. Why not make the as dumb as we can? Here's what it could look like. Notice that the component now expects the entire to be passed in via . It will also notify the consumer about receiving an answer (see . 

I really hate comments in code big time, but this is the case I totally agree that your confusion is an indicator of code readability issue. Comments would help (at cost of maintenance burden). Long lines are not a big problem on large monitors, but it is indeed possible to soften the issue at least by using proper line return positions. I don't like unnecessary and as well as and ... Thanks for pointing out the style issues. 

"Newspaper" Make code read top to bottom aka newspaper style ( is the entry point which invokes , therefore should go first). Forcing the reader to jump around the code is distracting from the act of active reading, therefore leading to avoidable complications. 

The Evil Triplets In my humble opinion, from the object-oriented design perspective it's strange to see these triplets in implementation classes: 

This is hugely improving the time complexity, which looks \$ O(rc) \$ to me, at the cost of \$ O(rc) \$ memory used for unreachable cells recording. 

Here's what functional style might look like. Unfortunately, it requires index recalculation, and overall more verbose and complicated, even though it tries to go the ".some()" way. :) I believe it's one of those cases where imperative code keeps things simple. 

Array-based double-stack We can also easily use a single array to implement two stacks. Each array boundary represents a bottom of a particular stack (if left boundary is the bottom of the first stack, the right boundary has to be the bottom of the second stack). The directions of growth for the two stacks will be opposite to each other. The end of the available array memory is detected when the two array headers are pointing to adjacent indices. Here's the illustration: 

Then you don't have the nasty proliferation of the micro-level details across the code base. It's nasty because it forces us mixing the abstractions of different levels... With the function above you can rewrite the code into a one-liner, because the complexity is encapsulated somewhere else 

Instead Of Preface My answer is split into three main parts. The first two explain how to make the small-ish code changes to improve readability and decrease fragility. The third part covers more of a design aspect which you may find important. A. Tactical Improvements 1. TypeScript is about Types Use explicit types wherever possible. This will: 

C. Strategic Improvements One question you may want to ask yourself whenever assessing a system or its part is: Does it scale [well]? There's an issue with the way we load data. If , , , or API or their combination return(s) enormous amount of data, our single page application (SPA) is very likely going to screw up: 

Whether I miss anything in terms of JavaScript/TypeScript idioms. Same about Jasmine idioms, techniques, approaches. General code improvements. Test differentiation/separation techniques (some are real unit-tests, other are more of integration tests). 

I really think your code is having at least two issues. The first one is something that may confuse your service consumers a lot. The second one is probably a bug. 

Step 2: applying the Strategy pattern [optional] In your particular case applying the Strategy design pattern would be an overkill. However, if your code had more branching, or had more complex branch selection logic, or had heavier logic in branch(es), or a combination of those, I'd consider using Strategy. This answer may be a good illustration of the pattern application in a situation similar to yours. Update 1 s are just very nasty code smell. They should be avoided when the things start being complicated. There's even a small anti-if movement. P.S. Let me know if you want to see some pseudo-code or more real code for the Step 2. 

function attempts to set a single bit to via bitwise or () operator with a shifted to every possible position. If the result of that application to does not equal to itself, it means the bit has changed the state from to and the resulting number should be used in the next step. The numbers from the previous steps are iterated through via function. The seed value is set to which indicates an "unknown" maximal length of sequence of s (which is determined by making a call to . The function slides from one side of the bit array to another and increments the sequence length by 1 for each observed -bit; or resets the sequence length to when a -bit is observed. The code actually explains this part better... 

Starting point Unfortunately, I am not familiar enough with node.js to make high confidence claims about the code. My guess is that I/O operations are more likely to be the bottleneck in the code rather anything else. Even the does not look too heavy computationally. Experiment with the way the data is being read. Now the code does this: 

As long as your code is dealing with configuration only, it looks good to me overall. (I assume, you don't have a login screen.) Otherwise, you may want to look at real life authentication example with Auth0. I'm not pointing to technology here, but rather how the concerns are being separated and organized. I might rename into to be a bit more specific, but I don't know the complete structure of the object and whether it holds any non-endpoint configuration or not. 

The last part is your consumer component. It orchestrates objects creation and iteration. The collection of is created in rather than constructor, and it defines the number, kind, and order of the Cards. 's constructor is used to inject the dependencies and prepare a that is than passed to the s (remember, they now require it in their constructors). method is used to react to the corresponding event. In my code I assumed that we only need to iterate through the questions linearly (first to last). If that is not the case (e.g. you may need to jump from Card1 to Card3 if a specific Answer was selected), then would need to emit event with some data. For example, and . Then the answerId could be used in for implementing more complex iteration logic.