Other answers show examples of how to use and it might be worth looking at them and trying "to see" them as recursive. It is probably worth using instead of recursion if you plan to share Python code with other people because in the context of Python's community, recursive code is harder to understand. Magic Numbers The Danish alphabet has 29 letters. Icelandic has 32. Russian, 33. The length of the Latin alphabet, 26, is hard coded into the functions. These languages use characters that are not directly representable in ASCII. The code assumes that they are and hard codes the offset . It may be the case that the Latin 26 character alphabet is hard coded into Google Sheets, now. If it is, that assumption should be made explicitly in one place so that maintenance will be easier if Google changes (or if there already is localization). Magic numbers are a "code smell". Sprinkling the same numbers throughout the code is another. A => 1 Python is zero indexed. Indexing the Latin alphabet from is fighting against the language. I can follow your rationales for wrestling the snake. But I have to think too much about your rationales in order to understand your code. If you had created a Domain Specific Language in Python and then were writing your functions in that, 1-indexing would make sense. But your code is in Python. The biggest advantage of Python is that people know what to expect. They don't expect 1-indexing. Data Architecture Zero-indexing versus one-indexing is mostly a matter of not conceptually separating the internal data representation of your application from the external interface of the Google API. The architecture of your application is: 

What is the purpose of your class ? You are just using its constructor to run some code which is completely unrelated to itself. You are doing the same thing with the two other objects you instanciate : and . When writing a GUI in Swing, you generally write classes that extend , and the constructors contains the code that initialize the inner components. It's a bad idea to let the constructor have a side effect (the display of a frame) like you have. Also, try to follow the Java naming conventions : variables and types names use camel case, and variables start with a lowercase. When initializing a , you might be interrested in calling the method (generally with or ) 

Short answer Use a state machine. Longer answer I haven't read your code in detail, but I already worked with the Java's non-blocking sockets. So I can say it's pretty difficult to get it right. I once inherited a codebase that was similar to your code. My task was to write unit tests, in order to be close to 100% branches coverage. I tried to write tests without touching the code, but there are so much states to track (the selector, the buffers, the socket's state) that I was not able to reliably test the code. So, I re-wrote the code, using a state-machine to encapsulate these states. I ended up with 7 small classes, each one representing the state of the sockets, or the state of the request processing. The resulting code was more robust (many missing edge-cases became obvious), easier to understand and to maintain. Writing the tests was easier, then. If I had to do it again, I'd try to use Netty (as Ihor suggested). Netty encapsulates the states too, and manages the connection errors in a more unified way. 

Warning: The following is opinionated at times. At other times it is more opinionated. Channeling PG I've heard on the internet so it must be true, that Paul Graham will get right to the point when interviewing applicants to Y-Combinator with "What problem does this solve?" It's hard to understand code without understanding what it is supposed to do. And only Google and watching a video twice make me think I might. Since I still don't understand the code though, I can't tell whether it solves the problem or not. The "water pouring problem" is a canonical toy problem in programming curricula. Wolfram Mathworld describes it as a special case of the three jugs problem. The special case is where the third jug: 

2: The use of provides a clear name for the role of the variable within the function. Assigning it to makes the default behavior explicit. 3: A block is "the trick" to using the Python Standard Library and returning if the value is not found. Using blocks is not guaranteed to be what the question was designed to ask (for example if when the question's purpose is to determine ability to iterate on a string). 5: The only way to know that raises when the substring is not found is from the documentation/experiment. Note that this handles no other exception (example: raised by ). Additional errors can be handled similarly. 7: The function only returns in one location. That location is at the end, which is at least as good as another location in the code. Semi-Relevant Rambling Remarks on Interview Coding Questions Interview coding questions are typically selected for purposes unique to interviews: 

So, you are generating every possible permutations of the array, which is a O(n!) operation. This is huge. I think this can be done with an O(nÂ²) algorithm. I would do : 

A big performance killer in your code is the use of mode to open the file. The forces every write to be synchronously written on the physical disk. A quick benchmark gives me a 500x speed improvement just by removing the in your code. I did a profiling of your code, and it appears that the majority of the time is spent in the function. This is because internally calls eight times, and each time a physical write is performed ! You should remove this mode and insert flushing instructions at strategic places. I think is the right method for that. Adding this instruction in , and gives me a 12x speed improvement compared to the original code. 

You can replace by For the rest of the code, it would help if you explain the algorithm you are implementing, or if you name it (if it's a known hash algorithm) 

And then you can use to find the content of the groups. There is still one thing missing : the fact that the numbering of the original pattern is lost. For that, you can parse the original pattern string to extract those numbers, to create a mapping table. When you convert your pattern string into a Pattern, be careful to escape the substrings between the using . I don't know if this solution would be an improvement of yours, but it's an alternative to consider. Edit The implementation of my solution : 

Having ordered line segments makes some geometric operations (eg. Bentley-Ottmann) involving line segments substantially easier as well. 

Understand the purpose of the program. Understand how the program achieves the purpose. Determine whether or not the program achieves the purpose. 

Potentially Surprising Behavior Without specifying the number of bits we are interested in the inversions don't necessarily behave the way a programmer might expect: 

Even in the absence of change, the code will be more readable. And by extension a reviewer will spend less time trying to map the problem statement into the code. In Racket, unlike many other languages, the idiom is to err on the side of verbosity and explanation. The guiding document is How to Design Programs (first edition, second edition) often referred to as HtDP. The methodology includes lots and lots of comments...even for someone who thinks the Easter Bunny and self-documenting code share some common features. Code golf the method is not. Data Structures HtDP methodology starts with data structures. The data structures should reflect the problem domain / business logic. Conversely as a general rule, working with is a often code smell in Racket. There are a few corner cases where it is necessary and perhaps a few existing code bases where doing so maintains consistency. Otherwise it is likely that data structures will produce more modular and easier to read code. Being only parameters passed to procedures, the review code's data structures are ad hoc and diffuse. Programmer defined data types are an idiomatic alternative.