All imports should be on the top. Globals Imports should be followed by your global variables. Often those globals are supposed to be constant (note that Python does not actually enforce them being constant). The naming convention for constants is . This makes it clear to anyone reading the code the value should not be changed and is probably defined at module level. This also means that other variables should not use the same casing. All relevant casing styles are in the PEP8. Variable naming Now we're handling variables anyway, please use more descriptive variable names. Single-letter variables and functions make for hard-to-read code. Code should be self descriptive. With good names, many of your comments would become redundant. Functions with names are can definitely use something more descriptive. Whitespace Give your operators and commas some breathing room. is a lot easier on the eyes than . Indentation is done with spaces, not with tabs. Multiples of 4 are preferred, but multiples of 2 are also common. 

Something along those lines. Note that is the preferred method of writing function names in Python. The moment you see so many , you know your code won't survive in the long run. It's not maintainable and not extensible. Classes are your friend. So what's the deal with ? is required if you want to modify a global variable inside a function's scope. You can read a variable without that keyword, but modifying it without one only modifies the local version of that variable. Basically, you're potentially shadowing variables with multiple versions of themselves depending on what local scope they're currently in. This means you'll have to declare your variable is in every function where you modify it. This could have it's cases in variables which aren't changed often, but I hope we can agree a is a variable which is supposed to change. Keeping up your current method of writing will lead to big lists of variables at the top of each function, which is among other things considered needless repetition. Simplified your code looks like this and it will only get worse: 

Globals in Python are not necessarily a bad thing, especially for what you're using them for. However, they can be prevented. There are a couple of major flaws I found so I'm glad you came over to get a review. The point you're most worried about will be handled at the end. Style Clean Python code adheres to PEP8, the general style guide for Python. Your code violates this guide in a couple of ways. I'll explain the violations I deem most important and fixed it up for you to show the difference. I do recommend you read PEP8 yourself as well. To verify whether your code adheres to the guide, you can either use the tool inside Python itself or pep8online. This will validate your code against most of the guide. Import Import statements should be on top of your file for maintainability purposes. This is a common practice in many languages, including C, C++, C# and Java. If I now skim your code, I'll see unexpected functions like because I didn't notice the following line: 

This is in no way a full answer, but I couldn't keep it to myself either. can handle newlines, so you don't need repeated statements. This: 

Objective Oriented Programming This is one of the best solutions against global variables: objective oriented programming. Did you know you can make classes in Python? 

And all of a sudden you can have 20 instances of because they all have their own list. A class should hold it's own data as much as possible. The following can be improved a lot: 

Now it will work regardless of where the script is located. Of-course, you just made the problem worse for non-Linux systems. Even better would be to ask where the user wants to drop his files, possibly by using arguments (take a look at ). But why don't you simply drop it instead? A map named will simply be created in the current directory. This would be obvious and expected behaviour. 

To calculate which levels were affected by what attack, I wrote a calculator. It takes 1 to 6 numbers between 1 and 99 inclusive and reports what will affect the player characters with those numbers. Since there's at maximum 6 player characters under the player's control, I limited the amount to a full party size of 6. Code: 

The following code is used to access a shield which converts settings written over I2C to Servo output. I make use of the MRAA library since that's the default supported by my hardware. To prevent my I2C commands from being written all at the same time, I use to wait a given amount of time before executing the next. For those unfamiliar with MRAA and I2C: accepts two arguments. The first is the target register, the second is the data. As long as two different registers are being written, it's no problem if one is written earlier than the other. However, I want to make this code more generic so it can be used with something different than Servos as well. A generic solution should give me the possibility to burst multiple parts of data to the same address and keep the order intact. Save to say my current structure is not easily expandable. How should I make it more expandable the Node.JS way? Expandability is more important than performance, but since I'm looking for an idiomatic solution this shouldn't be relevant. Also note the data written seems redundant, but there are out-of-scope reasons for this. 

Which does exactly the same. The way you print your messages uses a lot of spaces. It's not easy to see how many spaces you're using and why exactly that many. The following can help: 

Have you considered using an Array/List/Vector/Dictionary/Collection/etc. instead? If you have a dictionary, you can simply check whether a key (in this case, a particular type of bill) exists and if so, what the amount of bills left (value) is. This makes your ATM future-proof, in case it ever needs to spit out low-value bills like $1 and $5 or high-value bills like $100. 

I highly doubt it's idiomatic Lua, so I'm open for suggestions. As far as I know mixedCase and 2-space indentation are the way to go for Lua, but feel free to prove me wrong. 

Honestly? It looks pretty straightforward. Everything in your code screams you've done this before. Good! You're adhering to the standards of Python (the PEPs). The imports are at the exactly right places. The code is readable, easy to understand and does things the easiest way possible. In other words: it's Pythonic. You could consider wrapping your statements in into a template so you'll only need one call. However, since you only print once, I'm not sure how useful this would be in the end. While your code is easy to understand, you might want to make the naming even better. You got 5 variables with the term in it, not even counting where you use some of the exact names again. You're also overwriting after the after using it as a temporary variable. That's probably not the most maintainable way. Single-character variable names should be avoided, even if they appear to be obvious. 

Your program will crash at invalid input. 2 possible ways out: validate input before trying to put a square block through a round hole, or keep trying till a round block is used. Aces When an Ace is drawn, you check whether the player wants the ace to count as 11 or 1 point. I'm not sure what version of Blackjack you're used to, but around here the value of the Ace can change at will and doesn't have to be set at draw. For example, if I initially draw an Ace and 7, I'll consider the hand to be 18 and 8 at the same time. Should I decide to draw another card and it's a 3, the Ace is 11 and the hand 21. If it's any higher than a 3, the Ace turns into a 1 to avoid going bust. Your program doesn't account for this. Random cards At one point in the game both the dealer and I had the Ace of Diamonds. Your random selector should account for that. Now I know for certain the dealer is cheating. Part of the game is to know what cards are in play so you can calculate your chances. If the dealer has a King and you have 2 Kings, what are the odds of the dealer having another King? This gets even better when playing with multiple players at the same table. The more cards are on the table, the less you have to guess about the cards remaining. I don't expect a beginner program to track the cards over multiple rounds (just assume the cards will be shuffled after every round and it doesn't matter anymore), but at the moment your program allows to have 5 Aces at the same time on the field. If you're truly interested in Blackjack, I recommend reading "Bringing down the house" by Ben Mezrich (2002). Or watch the movie adaptation "21" (2008). The book is much better. 

I'm not sure what you're trying to convey here. I am sure there should be a space between the hash and the rest of the comment for improved readability. 

While reading your code I had one thought coming over and over: Get yourself acquainted with Object-Oriented Programming. Python allows you to build your own classes. Use that to your advantage. Why? It will remove constructions like: 

This is too big for a comment, but I have reason to believe your links are not working. A random example, challenge 54: 

Is here a magic number (if so, put it in a constant) or the most obvious choice which shouldn't be changed? In case of the latter I'd still put it in a constant, to explicitly state it shouldn't be changed. I'd also expect a comment here. If you insert a comment, don't make it something general like but more along the lines of why this is the final situation. 

This forces your to lower-case and checks whether the user wants to continue or not. This will also counter empty input. You can also easily expand on this. You're currently using the following variable names: 

Does it matter when you only have 2 import lines? No. Does it keep things easier when you have 20 of them? Definitely. 

Which doesn't do what you think it does. If you'd make a Player class, that class could have a function which is only allowed to move the current Player. 

The latter may not look familiar to you, but it's an include guard. It's a good practice to start using those, especially if you ever want to re-use parts of your code. Now your only gets executed if the script is called directly, not when it's called by . Which leaves us after the first couple of edits with the following: 

While I appreciate your indentation style here, it's not necessary if you just check whether the amount to withdraw is valid. 

Which still isn't much, but the structure is getting better. Note that I made your comma's breath ( is more readable when written as and there's no longer a behind your . It's Python, we don't need semi-colons after / etc. One of the major things fixed now is your code was executing before you finished reading your input. That's usually a bad idea unless you're in some kind of loop, which this wasn't. Now it waits for all input before it executes the rest. I/O used to be: 

Bug Input A bug in both the original and the Python 3 version is apparent when you want to bet more money than available: 

Whitespace Indentation In Python, indentation is important. Forget to indent a line of code the proper amount and your code will do something different altogether (if it still does anything at all). To notice indentation problems, it helps if the indentation is enough to be easily noticeable but not so much that it will make the lines unnecessarily long. 4 spaces is good. If you prefer using tabs during programming, set your editor tabs-to-spaces with a tab length of 4. If you're not sure what editor to use, give Atom a go. Runs on everything. Blank lines The amount of blank lines between pieces of code help to see in just a glance where you are in the program. While not as important as indentation (blank lines, or vertical whitespace, won't make or break your program), every bit helps. Remember what I said about consistency? For example, between imports and the rest of your code there'll always be 2 blank lines. Between methods? A single blank line. Between global functions? 2 lines. Between class declaration and the first method? Zero lines. Operators All operators get spaces around them, except around the when assigning default values. After a comma there's always a space, but never more than one. So this: 

You're using in all functions except the top one. Why not declare it at the top of your file? You seem to have thought about readability. You're declaring variables for just that purpose here: