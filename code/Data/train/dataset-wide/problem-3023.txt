That is smart and clean way to get a substring, but has potential to confuse a rookie. Consider adding a comment. 

The next thing I notice is that you're calling the and methods without specifying a worksheet. This means you're implicitly calling these methods on the . This should be avoided because it leaves a small chance that the user will change the worksheet while the code is executing. You should instead create a worksheet variable that gets set at the very beginning, then work with that instead. 

This is terribly error prone. It's hard to get right the first time and it's even harder to refactor later. Always use . 

There are also a lot of magic numbers in your code, but I'll get back to that. First, let's talk about extracting some well named methods. The random number logic is a good one to extract out. When reading this method, we don't care really how the random number is generated, only that we are getting one. 

I noticed that you've left code that has been commented out. That's dead code and should be removed. If you're worried about needing it later, that means you're not using any type of Version Control software. You really should look into it. It can and will save you headaches down the road. This line of code gets repeated a lot. I would wrap it in a private method that return a connection. 

I'm wary of any constructor that "news up" anything. It makes it hard to test and inject dependencies. I would also be wary of using optional arguments. Now, I understand you're just making sure the class has what it needs to function, but you should carefully consider if you should have a default constructor and an overloaded one that takes a list, dict, and capacity in as dependencies. I would write your constructor more like this. 

It's not bad. An extension method is a nice choice here. There's no state and you're extending a class that you don't own/can't directly modify. Good design decision. I also like that you're using the paradigm. A common mistake for VB6 devs moving to .Net is carrying over the VB6 error handling pattern. One thing I don't like about what you've done is this. 

I don't have much to add, other than I noticed a complete lack of error handling. I'm going to guess that this template won't work correctly if the modules aren't loaded correctly. You should take some time to identify possible failure points and handle possible runtime errors by notifying the user that there was an issue loading required files, logging relevant info off someplace, and then shutting down the template. 

You appear to be missing something in your object model. Consider this snippet that creates the regex pattern. 

These really feel like they belong to another class. I'm not really sure what to name that class, but these belong closer to the Parser. Maybe they're static members of and respectively. Maybe they're extension methods, or maybe they both belong to some helper class, but I have a hard time believing that no other s need to know which tokens are primitive types, or which declaration types are classes. The other issue with these is that the arrays can be modified, if someone was silly enough to do it. 

Dead dumb simple right? These classes really aren't much more than data structures. (At least right now. They can, and might, actually have methods in the future. Serialization does not prevent it.) We're not quite ready to serialize/deserialize them though. We need to add some attributes to these classes. To keep things clean, we'll use the XML Serialization namespace. 

You could perhaps write a stored procedure to contain the logic as well. While it could also be stored in your schema as a view, it seems a little silly to have a view that returns one record with one field. This one should also be a stored proedure that returns a single value. 

Minor nitpick that wasn't touched on: The assignments could use a little breathing space around the for better readability. There's also inconsistent spacing between the brackets. 

Or forget all that and just use the newer SendMailAsync(MailMessage) method. Just be sure to await the result. 

You're returning the that you passed in as an argument to begin with? I guess it also returns other items that match the arg as well. It's not as immediately obvious as it could be. Consider the Linq query here. 

Rss.fs And the parsing code. The module contains all the record types and a single method that returns a record. 

Since you seem to be very interested in an API where you can specify a list of divisors to check, you might like this solution. I can't speak to it's efficiency though. 

As it is, you couldn't take your class and use it in a different context. Your implementation shouldn't depend on Excel. It should take some values in, do some work on them, and return them in a new form. Your class (bad name by the way) should be responsible for fetching those values and passing them to . I would recommend making its constructor take in , , , and as arguments instead. This breaks the dependency and makes it so you could use the class in a console program (or anywhere really) if you so chose. 

Untested and the types might not be right, but I'm sure you get the gist. There are also a couple of unimplemented methods in there. They'll let you abstract away the decisions you made for each different into single methods in the source code. The calling code will end up looking significantly different. 

The server still has to wait for the entire request to be ready before returning it to the client, but declaring them as promises frees your server up to handle more requests "simultaneously". This way, the server can begin processing the next request while it waits on the first one to finish processing. Doing it the way you did it means that each request will block until it's finished. If you get many requests, it can become a problem. 

Your method does too much and that makes it hard to follow/optimize. This should be extracted into its own method. 

It's not obvious to me how to fix it, but there should be some way to clean up the seeming duplication here. It should be possible to write a single function to do this work. Perhaps it takes a boolean parameter. I'm not sure, but I know there's a way. 

I can't speak to the performance, but you should make sure your resources get closed properly when an exception occurs. Either switch to a using statement, or move your clean up code to a finally block. 

And then call this subroutine from your main routine once for each sheet that needs to be processed. 

There's a small optimization to be had by only searching column D until there are no more values. Find the last used cell in the sheet and only search until you reach that cell. As it is, I think your code does many more iterations than it has to. 

Then in the Getter/Setter, you'll transform the list into something bindable (personally, I like the ) and bind it to the datagrid. There's a great example of binding a list to a datatable and datagridview on dotnetpearls. So, we've gotten all of the from outside of the form and injected it in. Great, but what about all those pesky events? Well, we'll add some to the interface for the presenter to respond to. The will just delegate it's own events by raising 's events. For example, let's handle a selected record change. 

I'm going to go down through the code line by line. I may be harsh at times, but remember, I say these things so that you might become a better programmer. 

Let's take a quick look at your Delete query while we wait for your schema definition. I took the liberty of properly indenting the code block. Looks like we've got some arrow code here. 

Why? Wouldn't it be much simpler to just create the list inline to work with? More importantly, why does it need a list at all? The first thing you do to it is it. 

Comments Comments should clarify the code, not simply restate it. You have a lot of comments like this. 

There's dead code here... It happened because you're physically changing the code in order to switch between your two different strategies. It would be better to actually implement the strategy pattern. You could create a like this. 

I'm convinced that your loop could be simplified with some Linq, but I've not quite worked out exactly how yet. Something like this maybe. 

But I find it a bit odd that a validation routine is returning a string. I would consider returning a boolean instead. It has a smaller memory footprint than a string and is, in theory, faster than a string. 

But it doesn't matter much, because this method is kind of a useless abstraction. I would just directly set , etc. 

is declared as . You know exactly how long it is, so is a better choice of datatype. Even better yet would be to declare it as an and let the RDBMS implicitly cast it so you don't have to later. This is a function that returns multiple fields for multiple records. Functions should only return a single field and record. This is better designed as a stored procedure. Scratch that. You used a table valued function. "dbo" stands for "Database Owner". The schema should be reserved for database maintenance tasks and data. Business data and logic should be kept separate in its own schema(s). 

I don't like how you've mixed the concerns of calculating with output. I know that right now you only want to output to a file, but what if you decide later that you want to work with this data in some other program? Writing to the file system is expensive and slow. Why write to a file and then read it back in. I would modify this to be in two parts. One to generate the names from the dictionary and one that uses that class to output to a file. This leaves things open to writing the output to Standard IO, some other UI, or for another program to simply work with the data. The idea is that each class should do one thing and do it well. On this note, each of your comments indicates a missed opportunity to extract a well named method that does one and only one thing. 

The latter two can be solved by taking advantage of casing, but what about ??? Why, we just call it what it is, a (regex) pattern. 

But I personally don't like doing that if I can help it. You can remove the need to implement the interface if you keep your connections short lived. 

But like I said, it's non-standard. The standard is to use PascalCase for methods, camelCase for local vars, and _underscoredCamelCase for private fields. 

Do you expect the code for returning a new mock with no setup to change? I'd just chalk it up to rounding out an exercise in futility and ego stroking. But yes, the code looks nice. You have a good style. 

A minor point, but what if you want to create a single threaded as well? I would rename your interface to something like so that you could have a different interface . 

Follow Up to my earlier question. This is an RSS Parser intended only to parse the feed Wordpress provides (and even then, only what I actually want to display on my website). and are unavailable because I'm targeting .Net Core instead of the full framework. I think I've achieved a more idiomatic implementation this time. Where can I improve? Are there opportunities to compose higher order functions that I'm missing? Rss.fs 

Are , , and zero or one? Only declare one variable per line and we don’t ever have to think about it. 

Go ahead and extract it into a private method of it's own. I have a minor concern about that snippet though. You ask the user to "n" to quit, but in reality, anything but "y" will exit the program. I'd consider that to be a bug. 

Nifty little program you have there. I think you'll do well if you read up a bit about "Abstract Data Structures" and "Abstraction". All in all you write pretty neat and readable code. Those are good things. 

But minimally, you should replace with a constant value so you never accidentally change the delimiter in one place, but not the other. 

Notice how the consumer is the one responsible for decoding and using it? Also note that the unmanaged string is always released from memory before the method exits. My implementation is faced with many of the same issues. It still has to decode the string, but it never exposes a manage string to anyplace it could be copied. It gets sent to the external library with no room for anyone to ever make copies of the password. You should strive a little more towards that goal. To make things clear, there's no reason a developer couldn't do this with your implementation. 

I'm honestly not a fan of concatenating cell addresses like this, but I think it does a world of good to the readability and maintainability of this code. While we're at it, I think this is useful enough to extract into it's own subroutine. 

Use an anonymous type to store a single object retrieved from the database and then populate your view from this temporary (and anonymous) object. Answering from my mobile, so I apologize if this doesn't compile. 

Sidenote: Replacing was a real PITA. Lastly, Sub and Function names should have Verb-Noun type names. tells the dev using this code absolutely nothing. Perhaps would be a good name. WhiteSpace Again, this is a readability thing. (I do promise to get around to a better way to do this, but first we do need to be able to read the code.) You are indenting your code, which is good. I've seen worse, but it could be better. Indentation should visually tell me at what level we're currently working at. For example, consider this snippet. 

At first glance, I want to tell you to use a string builder again, but I honestly don't have the foggiest idea why you just split the string apart, just to put it back together. Forget what I just said about splitting, and just . Don't split. It looks to be unecessary. 

I'm not sure if that's expected behavior or not, but I'm not sure it matters. I don't really think you need a special function to accomplish what you're doing. Just take your number and it. If the data is coming in as a string, then simply cast it to a value first. 

You actually might want to split that into several methods. Also, watch your white space. There's never a need for more than a single blank line. 

Some may say that the extra index variable is superfluous, but I actually like that you've realized that even though and always hold the same value, they represent different things. 

Now, I don't know much about webscraping, but I don't think there's much you can do to make this method of going about it any faster. You're restricted by how fast Internet Explorer can retrieve the website. There's also the fact that VBA is a single threaded language. So, multi-threading is out of the question.... or is it? I would tackle this problem a little differently. I would create a swarm of VBScript scripts to retrieve the data you're after. This works by using VBA to writing many VBScript files to a drive location and using a shell to execute them. Each VBScript is responsible for writing the data it finds to the appropriate cell in Excel. You can find a reasonable example of this (including a workbook with the code) here courtesy of Daniel Ferry. 

It's redundant and noisy. They actually make the code hard to read in my opinion. Secondly, I love doc comments. They're great, but I see no value in placing them on members. If a private member needs a comment, use a regular one. Or even better, refactor/rename so that a comment is no longer needed. Constructors You have a lot of them and they tend to duplicate functionality. If you changed one of them, you'd have to change many of them. Use CTor chaining instead. Every other constructor should call on this one. The one that takes in every possible argument. 

This returns the range of numbers [2..10]. Which is fine, I guess, but it is surprising and as such deserves a doc comment describing what it does. It took me a minute to parse it, which was time that could have been saved with a good comment. Like I said, I don't like it. It should return an empty set, but at that point, just use . If you decide to keep it, I'd move it to a static class of it's own. It doesn't belong in the code behind, nor does it logically group into a class.