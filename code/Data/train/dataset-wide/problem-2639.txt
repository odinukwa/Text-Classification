If you have a set of mutually exclusive conditional statement you should use . Only one of the conditions will pass so there is no need to test other conditions if one has passed. Also as at least one condition has to pass the last else need not have the statement it is the last and only option left so it must pass. 

The rows are symmetrical, the right side is a mirror of the left. There is a formula that lets you calculate a row which can help reduce the complexity. 

As Object.prototype As you are after a fundamental function you can chose to add it to the Object prototype thus making it available to all object. Many here will throw their hands up and say "NO WAY", I expect this answer to get more downvotes than up simply because of this. But it is a valid way of using the language, and is better understood than hidden behind gasps of "No" and "Run for the hills the end is now". If you do it the following way you make it easier to use in your code. But there are warnings. Warning when adding to the prototype of basic objects If you do however you must take some precautions. Do not use the function if it already exists as the source may be unknown thus unsafe. Ensure that the function can not be overwritten as the object prototype is global and could be hijacked. Ensure that it works, the last thing you want to do is add a prototype to a basic object that requires some form of vetting before use. It should be bulletproof or it should not end up on the object's prototype. The object prototype form 

Find the operator Now we can cut the sum in half to find the two numbers. We know that after the first number we need a "-" or "+". Again a RegExp is used to find the location and value of the first "+" or "-" after the first number. find and "0-9" or "." followed by "+" or "-" 

Review A little ambiguous, and overly complex. You need to familiarize your self with radians and forget about degrees Style Block-less blocks A block is a section of code delimited by many C like syntax languages allow you to skip the block delimiters for single line blocks after conditional statements. This can be a major source of life long frustration, and there is not a programmer alive that does not know the insidious nature of the bugs that can result when you make changes to the code and forget the 

calls a function, that starts, then maintains the iteration, (first context change) it calls your iterator function (second context change), your iterator calls the memoized function (third context change) it makes a memory assignment and then calls your function (fourth context change). Remember you are just setting 1 32bit word and you are already 4 levels deep into the call stack, each needs to create closures and context, and the memoize need to allocate memory. You paint the pixel and the whole process need to be undone. Memory and Objects. Creating objects is slow, like snail pace slow. Your code 

Recursion is a state stack. Function context Every time a function is called JS creates a new context (function state), even if the function does nothing, creates no variables, has no arguments, only calls another function, it still requires its own context. The process of creating and pushing to the heap costs memory and processing time. The minimum memory cost varies between JS engines, but 1K is a reasonable estimate for an empty context. Note The exception is Proper tail call Functions that by nature of the return, may not require their own context, they use the calling functions context. (No browser current lets you use this ES6 required standard feature) Recursive state stack In general recursion is used as a way create a state stack. Each iteration (recursive) call creates a new function context, with closure that is pushed to the heap. When the a function exits its state is deleted popped from the heap and the calling function's state is reinstated from the heap. Example showing states pushed and popped The following illustrates the state stack. The state includes a random value. Each iteration waits 200ms before creating the next. When the recursion exits each state is popped from the heap, the functions complete execution until the stack is clear. 

You could get an earlier exit for the offset option by adding below the line but on average this increases the amount of work so best to keep it as simple as possible. 

Well!! First off I will say that is an impressive amount of work for a sort, lots of research and references. BUT!!! I am not going to sugar coat the rest. The implementation is overly complex and very inefficient, the testing touched none of the edge cases or expected failure states, and the overall design and layout of the code is chaotic and difficult to follow. Your concerns 

Underscores are used in languages like C/C++ to ensure that variables and functions in libraries did not clash, however it is only a convention not part of the language. Most commonly it would be double underscore This has also been used in other languages for the same reason, more commonly just as a single underscore. In Javascript it has been adopted as a sign that a variable is private, and is particularly common in code that uses the token which does not allow for private properties. It is bad because the language does not enforce the rule. is by trust not enforced in the language. You can use it if you like but you must still treat it as a public property if you wish to trust your object's state. And if you go through the effort of ensuring the safety of the property then why bother with the underscore in the first place. 

Or use direct DOM refernces to access the DOM. Just use the elements id as a variable name. Be sure that element ID's are unique on the page. Example of direct element reference, and what not to do. 

Keep the global scope clean and data/code segregation First I will say your code is good for a beginner but you are missing some concepts and techniques that will help you improve your code and improve the client experience. Some important concepts 

From an external view its behaviour is identical, from a resource point of view its is remarkably different, will much lower memory use and associated GC overhead upon exit. It can also handle any size text, unlike the recursive method was limited to the available call stack size. 

Simple and pure Regarding the comments the following is an example of a simple JS solution to the problem. Turns out that it is also a pure function. 

Cyclic references. But still the approch is unfortunately flawed. See what happens in the next example 

If it is just the boundary of the box you are after. The only comparison is to find out which part of the box the line ends on, top/bottom or left/right the rest works by preserving dx and dy's sign. It also works if or is zero. The only thing I am not sure of is if the offset is from the target, if so I would change to 

Code design. You logic statements are a little inefficient. The majority of pages will use the final else block. That means most pages require you to divide by 2 three times. There is just too much repetition and noise. Consider using functions like and to clamp values rather than statements, For flooring positive numbers you can use , and use ternary expressions for simple condition statements. The function is impractical having the paging description hard coded. It would be much better to supply an object describing the page. A rewrite 

V8 specific Watch out when using . Some of these code challenge sites are still running on older versions of V8 and let used to add a big overhead especially inside loops. Careful with indexing indexing. Some JS engines are not as efficient as others when it comes to array indexing and property referencing. For example V8 will be slower when you reference an array elements using multiple indexes 

Some extra items that have not been raised and are so important. Declare vars Every variable must have a declaration. If you dont define the variable it is automatically defined and placed in the global scope. This becomes a major source of bugs, headaches, frustration and madness. 

Eloquent Eloquent is simple, efficient in both processing and memory use, easy to understand, and adaptable. Simplicity Don't store unneeded data it adds complexity. The problem is looking for averages grouped by century. That means that there is no need to store any persons age, only the sum of ages for each century and the count of deaths are needed for the solution Efficacy Doing the minimum work possible. To get a result requires, one pass to group, sum, and count the data. Then one pass over the centuries to display the results. With 39 persons and 6 centuries. the number of iterations should only be 45. Your solution passes over the data 118 times over 2 times more than needed. The solution by 200_success improves that a little with 90 iterative steps, twice as many as needed. Understandable. Code should be easy to follow. In the old days of coding there was a style of code commonly referred to as spaghetti code. To understand it you had to follow a complicated path of processing. Each time you jump from one section of source code to the next, it breaks the logic flow stored in your head. Following disjointed source code is hard. Now we have named functions. The idea is that the name of the function gives all the information needed to follow the logic without having to step into the function. This is seldom how it works, and tracing functions because the function name lacks the information to understand the process is a modern form of spaghetti code. Adaptability Time is money, and good code means that it is reusable with the minimum of effort. How long would it take to get only male or female averages. Do you need to think about it, or is the solution already in the code and you know instantly what to add, or change. Can the code handle bad data, can the code handle vary large data sets. What needs to change to make it a distributed solution. An Eloquent solution. Minimal iteration passes, efficient with no irrelevant data stored, and only 45 iterations. Understandable, not a sea of nested function calls, Logic can be followed fairly much from top to bottom without needing to step into disjointed inadequately named function calls. Could be a little simplier but I went for adaptability over simplicity. The allows a variety of groupings. The output function means it is easily be formatted to any type of visualization, storage, or additional processing, Ancestry data can be randomly split and processing distributed with output providing a collation service. No side effects and pure as Snow White.