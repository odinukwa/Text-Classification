While I could try to improve your existing code, I'll rather tell you from step one how I'd do it myself. Let's start from the basics : You want to make a 'ToDo' application with multiple users (stored in a database) that each have a list of tasks. This application will be printed to the console (at least at the beginning). At this point, you should make a quick UML class diagram : We'll have a which will fetch the users from our database (for now, we'll go with a ), as we have user, we'll manipulate objects and they'll themselves store multiple s. Plus, we'll have a that'll mix every previous objects together and will be responsible of managing the various inputs. Finally, there'll be a that'll print the data given by the and send the user input to the . Here is a quick example of some of the classes : 

This interface would simply replace the variable part, we can now create a simple method that will be usable everytime you need a TTransport that is opened, do some actions and closed : 

That's quite complicated just to read something from the console consider using for such a simple use case 

As we have greatly reduced the number of side-effects, you can now unit test your code. For example, one unit test can look like : 

TreeSet are guaranteed to always be sorted so maybe can take a TreeSet as an argument ? If you want to only manipulate then I'd recommend you to copy the input into another variable and then sort it. 

3) You aren't checking that the given to your constructors/factory methods aren't set to . can (and will) really mess with any calculations and should be removed/avoided if possible, so I'd consider testing for the presence of this troublemakers 4) I'd consider using stream when applicable : For example with the all zero method : 

...can be restructured in a much more readable way (and get rid of the heebie-jeebies I get when I see a jump out of a block) like this: 

While the intent may have been to group aliased members, you can make this explicit by just assigning aliases within the declaration itself: 

General Notes First - In addition to replacing the magic numbers, I'd put your file path into a constant at the top of the module for easier maintenance: 

Miscellania Remove your dead and unused variables in , in and in (which you inexplicably after never using - see Setting objects to ) jump out, but there might be others. As far as the design and function, I'll let others tackle that - but I will mention that if you're doing anything that I mentioned above to make the class more "generally usable" it's a code smell. For example, if you use and all over the place to make it "generic", you should really be looking at compositing and using interfaces instead. The performance penalties and potential for trading compile-time errors for run-time errors just isn't worth the hassle of having to debug and maintain it. 

Conclusion - Burn it. Burn it with fire. The premise behind the code is that there is a common set of operations that you can do to "speed up" code. In fact, this is never true. In reality, you are turning off Excel functionality that can slow down code. There's a big difference. If you approach performance issues by looking outside of code that you've written, you're starting out looking in the wrong direction. A catch-all "solution" for performance simply doesn't exist, so I wouldn't pretend to be be providing it. The best way to look at it is to imagine that any code under performance review to be copied and pasted in place of this... 

The test is taking the return value of the default property of , which is (it returns a ) and is seeing if it is equal to . This is a good way to run into problems later, because if the cell has a formula in it that evaluates to , will return : 

which sadly breaks one of the most basic contract from equals (reflexivity), you should then only use equals with reduced number 

One last point : some people think it's a bad practice to use s as parameter in Java ;) Hope it helps ! 

It'd also remove some useless comments such as as the code would now look like which is more readable. does way too much and should be refactored almost entirely. Finally, 

Here you should use instead of . On a sidenote, Array_Size and Rotation_Number aren't variable name that matches Java standards. A variable or field in java follows the camelCase convention (so it'd be rotationNumber instead of Rotation_Number). 

The could be abstracted with a function... Since Java 8 we can pass objects that are very tiny wrappers around functions, they are called s. Let's take a look at the package storing all those objects : $URL$ We sadly cannot use as it cannot throw exception... there is a interface in java.util.concurrent but we cannot use it as it doesn't take any parameter... so let's use a new functional interface that suits our needs : 

You are putting a value in cache (which is cool BTW) but since your object is mutable, you may have strange behaviours. You should either remove the cache manually in all methods that do a mutation, remove mutation altogether (recommended :P) or remove the cache. Avoid declaring two variables on the same line and don't use label (they basically are s). You should be able to solve this by using the method from ;) 11) Lastly, I find it more readable when the // methods are at the very end of the class 12) Your and methods are bugged IMO as they use 13) The method is not used anywhere and, thus, should be removed Now onto the tests classes ! 1) Basically, the same as before : avoid using for every test, you can replace the 

Getting back to , your code isn't equivalent at all. The original function is actually pretty efficient at what it does - it calculates what it needs to copy, then does that in a single operation. Your code doesn't perform a calculation at all - it counts row by row with this code (line continuations added for clarity): 

Test code This isn't nearly as much fun without some test code, so I knocked together a super basic ... 

2. The range selection interface duplicates Excel functionality Note that this is more a matter of personal preference than anything, but if Excel already provides an interface to select a cell or range of cells, why duplicate that? I'd simply use the existing object when the macro starts. You're already prompting the user to confirm that the that they selected when prompted is the one they want to work on, so why not just skip that entire process and use the object instead? Errors @Zak already addressed the big issue with the error handling, so I'll nitpick a little instead. 1. Duplicated code Your error handlers in and are identical, and only display the error condition to the user. I'd recommend extracting that section to it's own Sub: 

Properties - This is a one cell that determines where the display rectangle will be placed. It will raise an error if more than one cell is passed. and are the row and column number of the in the parent Worksheet's coordinates. These are read-only and are derived from the . and set the dimensions of the display. is the size of each "pixel", and the rows and columns in the display range are set to this width and height (in pixels). Currently I have it limited to CGA resolution (mainly for convenience when I test it), but the limits can be set by altering the appropriate constants. sets the background color for the display. Any pixel in an that matches the will be "transparent". 

for additions : one test that prove that a matrix M + a matrix full of zeroes give the matrix M for scale : one test that proves that a matrix M * 0 is a matrix full of zeroes for scale : one test that proves that a matrix M * 1 is the matrix M for multiplications : one test that proves that a matrix M * a matrix full of zeroes give the matrix full of zeroes for multiplications : one test that proves that a matrix M * the identity matrix is the matrix M for additions : one test that prove that a matrix A + a matrix B gives the same result as a matrix B + the matrix A for additions and multiplications and scale : show that your method(s) are associative for division : show that your method(s) are NOT associative 

is a poor name for a field. The may actually never be closed which is also a problem if you were to write a bigger program. As mentionned earlier in my post, most static methods should be put into their own class and turned to object method. It also feels off to have the stored as an an not as an enum which would more closely matches the fact that it's a protocol. 

Your code is pretty neat looking but, alas, I think the architecture is wrong. Packet should be an immutable object acting as a passive container IMO.... by doing this you are removing the following fields : 

With a default that takes an address and the . As already said, if you want to use your cache between your differents implementations you may need to inject it through the constructor. The class would not retry to send datas by default, it's better to let your users decide whatever they want to retry or not. You could use a parameter for this but I'd rather create a decorator like this : 

You always cache the and regardless of whether it is necessary or not. I would guess that roughly 1% of all the code I've written requires this. Same thing with . Same thing with . Do I write another if I need that turned on? Or maybe ? None of this work is free, and it seems like a jumbled collection of "this will make your code go faster anecdotes" collected from SO comments. The cargo cult has found thier messiah in this wrapper. 

Use a array - This is probably going to be the biggest performance gain if you're able to hold the entire working on in memory at once. If not, you could probably "page" it by processing in chunks of 10000 rows or something like that. The implementation details are probably out of scope for my review (although another reviewer might cover it), but take a look at the procedure above - it pulls the column into an array and works with that. I'd probably start by tackling to lower hanging fruit above, then switch to array processing if you're still not in the performance neighbourhood you need to be in. Good luck! 

Note that this does a couple things - it avoids the need to add one to the - calculation and then just subtract it again. If you're testing to see if an array has at least 2 elements, > is sufficient (and protects from cases where and\or is negative). It also explicitly protects against the case of , which returns -1. This leads me to... 8 - Your guard clauses have a very subtle bug. Before you process the cell, you use this test: 

Methods , and are the main methods for interacting with the display. Any item added to the container will be rendered. forces the display to repaint itself. If changes were made to any of the properties that alter how it is rendered on the Worksheet, it will apply those changes. As a side note, this should eventually include Z-ordering, but I'm still up in the air as to the implementation details (and Tetris doesn't need the functionality - maybe for some other game...). There's also room for improvement in the resize - I currently have the conversion between character width and pixels fixed, but it should really calculate it based on the display settings. is simply a factory method. I'm open to ideas as to how to make the "default constructor" private. :-P