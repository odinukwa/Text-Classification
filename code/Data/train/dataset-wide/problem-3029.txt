This is a classic example of where the Modulo operator is useful. The modulo allows you to determine where in a sequence you hit a repeating part of the pattern. For example, you are processing thousands of lines of data, so you want to log some output, you print a message every 1000 lines with: 

ReWrite I am not one of those people who thinks 'continue' is a bad thing. I like it for the job it can do, but your use of the is excessive.... Every path through the loop is a 'continue... this is something easily solved with a little planning. Consider this rewrite: 

So, from the context you provide, I would have called this something like an , and I would have a factory method on it that takes a server, and credential as parameters. There should be no need to 'remember' the credentials after the initial login. Given the challenge: 

Code-wise I can't really see any major problems. The only glaring issue I see is that should be private. The remainder of the code is neat, and consistent. I like that. The rest of my review is about the usability. It irritated me that I had to click on the text entry to add my name. I realized that you forced the focus on to the button in order to make the "prompt" text visible in the Text Field. When you click on the field the prompt goes away though.... leaving you with nothing. I prefer the use of labels, in combination with the prompt, in order to guide the user. Prompts that disappear are a problem. So, I would add a label "Name:" before the TextField, and I would force the focus on to instead of . With those changes you can start the app, type text, hit enter, and get a reply - no mouse needed.... ... which leads to the next problem, the only way to reset the system is to exit, and restart.... you should have something to help with that, but, I know, this is just an entry-level system. As an aside, when I added my label, I also had to set the HBox alignment to Pos.CENTER and I set the spacing to 5 on the layout too. 

In the above subselect, is an aggregation function. It aggregates all the values in a given group. You group by , but, you also have the nested join condition history`.`itemID` = `items`.`id`` .... which means your subselect will only return values for a single anyway. There is no need to group the subselect. MySQL has this feature which I call a bug, and that is that it allows you to group by columns that are not in the select, and not group by non-aggregated columns that are in the select: The 'feature' documentation here . The most interesting part is this: 

A while ago I was experiencing 'flakiness' on my home ADSL line. I run a Linux server in my basement, VOIP, and a few other things (like Netflix) and I was experiencing a few minutes of network downtime every few hours. This was dropping very important things, like the kids watching cartoons, and my phone-calls with my parents. In communication with my ISP (who are fantastic, I'm not complaining), they wondered how often the connection was dropping, and I could not easily say... so I wrote a script to monitor.... All it does is ping the remote side of my ADSL line every second (my gateway). This is a short hop, and not much of an impact. Here's the script I wrote, and, based on it, I was able to escalate the problem, and copy relevant mails to the ISP, and they were able to correlate the issue to problems somewhere... which ended up with me replacing my ADSL modem, and problem solved. Long story, for some short code, but, this is a classic perl hack... My perl is somewhat old-school, so I am looking for ideas on how to modernize my usage, and any other tips and tricks. 

One lase comment, I have found that the more I use Java 8 features the easier it gets to establish the right mindset when reading the code. You may just find that it grows on you, and your statement "I find the lambda approaches more difficult to read than the simple for-loop" is no longer true. Also, consider this: 

Factorial is used as one of those introductory lessons to recursion. It's a shame that you don't use recursion here. As an added bonus, by using recursion, you take the factorial code out of the main method, and reduce your multi-responsibilities on the main method too: 

If this is the case, you should: Only connect once! The connection to the database should happen outside the loop (not a new connection for every record). The , and should all be 'prepared' outside the loop too. You should select more than just 'TOP 1' from the results, and you should probably be careful with your transactions so that the database performance is not limited by the amount of time it takes to unzip a file 

The compile concept produced incorrect results for me. When I run your code the template does not produce the correct results. For the input parameters: 

Your code is a reasonably neat use of recursion to solve the problem, and recursion is a good solution to this problem. I prefer it for people to make it obvious that a function is used recursively to prepare myself for what to expect, I tend to use "recursive" in the name. You don't show how you set up the recursive method, though, and in general it's poor form to embed print statements inside functions that do other things too (single responsibility principle: $URL$ A better solution would be to return a collection of results that you can print in a separate place. What really bothers me, though, is two things: 

The trick for splitting up the version blurb for just the version number, is to pass the values you want in before the command, and then shift them off . you have done a relatively unfamiliar-to-me parsing mechanism with the resetting the field separators, etc. Using bash as a parser is a problem for me (and I've never hated myself enough to try....). I would set up a function that takes a co-ordinate of a version as a line/word combination, and rely on out-of-bash tools to do it...... I will probably get nailed for starting 4 sub-processes, but head, tail, and cut are small.... right? (Forgive me already, you won't be calling this in a tight loop, will you? You're already doing that a bit with the bash operator...) 

Your code takes an argument, but returns an . These things have been discussed before. Your actual nodes contain an int, so you need to find a better solution to the mixing of primitive and Object types. There is a simpler way to do this using a single queue, and adding a null value to the queue to mark the end-of-line for the tree. This saves having to swap the and instances. You throw an exception with a space as the first character, and it's not well formatted.... ... additionally, it is a 1-liner statement without using braces. These are things that have been said before, but don't seem to be sinking in. You use 1-liner if-blocks for the left and right adds as well. The 'Dude!' exception is cheesy, and not relevant. Consider the alternate code: 

I really like how you have set up a system for running your tests. This is a worthwhile investment. I have taken your system, and extended it quite a lot. I have made the performance tests a bit more structured. Also, I have rearranged the class. This is a compliment for your code... not a criticism... it's good. I just want to use it differently from you. On the other hand, you may like what I have done, so have a look. I did find some problems... you are doing long-division on the time values: 

Yes, No, and Maybe. Yes The table has 10 rows, the column is used as a constant argument in a query, and the query optimizer has ways to do index lookups (probes) in a very fast way. So, if the query parser decides to access the menu table by the literal, instead of the , then the index will likely help. Also, for 10 rows, it will not take much space. No Because you use a left-join from to , on the column, the reality is that the query plan will likely have to process all the records in before joining to so that it can do the outer-join right. This means that all the query access to the table should be through the column, and the column will be secondary, and the index on the (if any) will be ignored. Maybe Query optimizers can sometimes make dumb, and also very smart choices, and there is a chance that having the index will help, despite my best-guess that it wont. Additionally, there is a chance the optimizer will use the index, even though that will make it slower. There is no way to know unless you try it. My suggestion Create the index, but don't expect it to be used for this query. A second suggestion is to create the index because sometimes putting them together in an index helps avoid a data page lookup, but for just 10 rows, it's not going to make much difference. 

Still, that is potentially buggy if the last line has a terminator, since it only strips 1 char. Your version may be better, but it's still simpler with the pre-stripped input file: 

Edit/Update I ran the query on Stack Overflow, and it fails because there are so many questions that the fails with an arithmetic overflow. I have updated the query to only consider the past 68 years worth of data... (in case there are large date differences in seconds), and also to convert the elapsed in to a float (which does not overflow on ) 

Now, your code will only get an opportunity to run every 10 seconds ;-) Although this seems contrived, I have encountered a number of situations where monitors are used in places where you don't expect them, leading to hard-to-debug concurrency problems. What's the solution? Well, that's easy, create a special lock instance: 

Instead of having each socket handled by a thread, you have a small-ish pool of threads ready, and waiting, to handle the few sockets that actually do something. At the same time (actually, shortly after) as NIO was introduced, the cost factor of creating, and maintaining many threads was significantly reduced, in Java, on the core platforms (Intel, AMD, etc.). As a result, it became effectively just as reasonable to have 1 thread per client again, even if there are thousands of clients. The issue is now mostly confined to places where thread handling is still hard, slow, and expensive. NIO is still relevant today where there are many, many client connections, or where the infrastructure still has expensive context-switches, or thread startup times. Tutorial For NIO Selectors to make sense in Java, you should follow particular pattern in your code: 

In your code, what does this mean? It means the code is not great, and that you should find a way to accomplish this with communication instead. Further, there's no need for a in your code, a simpler would be better... For "Communication" in go, you need a go routine to communicate with. The go-routine is linked to the instance, and it's the only routine that knows the state, and the only go-routine that can change that state. Now, you just need to communicate state changes to/from that go-routine using channels. In code, it would look like: 

Now, sample is a Decimal value from 0.0 to 1.0 inclusive (assuming you got your Sample() method right...) The cast-to-int will do a decimal truncation on the Sample, and reduce it to an int of 1, if the Sample was , and 0 if the sample was anything else...... (somewhere from 0.0 inclusive to 1.0 exclusive). Which means there is a \$\frac{long.MaxValue - 1}{long.MaxValue}\$ chance the value will be 0, and a \$\frac{1}{long.MaxValue}\$ chance it is 1. you should run the example code, and see if you ever get the value 1 for: I ran your code here on Ideone and it shows poor distribution.... 

static variables (those values in there are constants no need to recreate them every time). merging the arrays. 

When you have methods that do multiple things it becomes hard to isolate and reuse the logic. Your code should be split in to parts, and the method should take the input and return a Complicated end-of-loop handling The condition is a complicated construct, that needs a comment. That logic is key to the process, and guarantees that you are left with a "dangling" 1 for the high-bit, and also handles the input case. It took me a number of minutes to figure out how that code works, and that's not useful for your readers... (or yourself, a year in the future). As it happens, a do-while loop is the structure you want, and it simplifies the logic a whole bunch.... mystery I assume you have done a static import of the class? Otherwise the method is not defined. Doesn't this defeat some of your "old-school" desire? Also, why not just use a simple 2-value lookup table. The digits are either or , so it's simply: