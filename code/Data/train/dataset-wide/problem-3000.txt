You'll notice that I've contracted the case statements for each word into a single method , which I pass the word into. That's because there is a lot of duplication between the different case statements that you should be able to remove. You can use to get the length of the word to guess for example, rather than hard coding the value (4/5). Rather than hard coding the letters for the word to guess you can use . etc. Nesting Too many nesting levels are bad. They make the code wander across the page to the right until it falls off the edge of your screen. You can avoid excessive nesting by breaking your code into appropriate methods. You can also avoid using it when it isn't necessary. For example, at the start of your program you do: 

Depending on what your application does you may be better off using Thread.Yield, rather than Thread.Sleep. I've mocked up an alternate implementation using ConcurrentDictionary ( I haven't extensively tested it). Essentially it works on the premiss that if a thread manages to add the key to the dictionary, it has locked that entry, so can do some processing and then remove the entry. 

Serial2 Vs MyBtooth It looks like you started off using , then defined to make it more explicit when you were talking to blue tooth vs serial. There are some lingering references to in the code that should be updated so that it is consistent throughout. 

btnSend_Click bug If the user clicks on the send button, before they've clicked on the Listen button, your member won't have been initialised so will throw an exception when you do: 

As an aside, usually you would simply expect the combined full name, rather than it being explicitly stated which is which, so you would have: 

Hard coded paths Try to avoid putting hard coded paths into your source code. It means that if you want to change your source or destination paths you have to recompile your application. Unless you really want this level of commitment to the paths, then a better approach is either to take the paths as command line arguments, or to put them into the app.config file. For example Config: 

On a modern cpu, you can gain some benefit from parallel execution. Since the number of executions required is quite small, you need to avoid starting/ending threads however as this can have quite an overhead so you want to use threads from the thread pool. You also want to minimise contention between the threads, so you don't want them all updating the same Max variable. A basic strategy is to split the processing into a number of sections (where the number of sections is the number of CPUs). Each window, calculates the max for that window, then compares it with the max for the other windows. The calculation stage can then but opitimised using the various other techniques suggested. This results in code something like the following (I haven't really validated the upper bounds checking however it does result in the correct answer so I've assumed it is close enough). 

Centralise Responsibility At the moment, your is responsible for knowing the target path, but your class is responsible for knowing the source path. Since they are related, it's better to have the paths referenced from the same area of code. If you push the knowledge of the source path into your class and pass it in then it will be possible to reuse the functionality in other classes in future. This leaves the class looking like this: 

magic numbers You use some defines at the top for magic numbers, however you also use 5 in several places like this: 

This might be ok if is expecting , however I tend to think of positions as . Either way, using and as the variable names for the loops would have made it easier to have confidence that the code was correct. Your method seems to confirm that there is an issue, since it updates the cell: 

As has been said by @domi1819, hashing by individual characters would be better than your current approach. As the test suite seems to have been written as part of the exercise you're limited in how you can change the class and still have the tests run in their current form, which is a pity because the suite is forcing you to construct a class that feels wrong. If your goal is simply to implement the code required to pass the suite however, I'd remove the member variable of the class. Other than in the initial calculation of the score this isn't used. Instead, change the signature of the method to accept the phrase as an argument instead. Similarly, the method could simply update the member of the class, rather than returning an integer. 

You have your own version of this, however I would tend to use the exact case where possible, which you haven't done. Your tests for ignoring numbers > 1000 only use one value (1001), only have a single instance of the value in the string and only have the value at the end of the string. This could be simply implemented as ignore 1001. Think about naive implementations when writing your cases in order to make sure the implementation does what's expected: 

If it can't happen, why are you checking it? Callback definitions Consider typedefing the callback methods to cleanup the method definitions and make them more explicit: 

This seems counter intuitive. Perhaps it should be or something and called by where both of them sit in the class... Player Construction contains an array of players, which it creates on construction, however it isn't responsible for populating the players. This tightly couples the class to in your class. If is called before the players are created the program will crash. A better approach might be to have actually create an array of players and then have the array passed into the constructor of , rather than the number of players. That way, is in a completely constructed state and is ready for other methods on the class to be called. 

I haven't used any parentheses... Overflow checking You don't limit the size of the input stream, so it's possible to overflow the input: 

When I look at this line, it looks like the method is going to generate 0 words which doesn't make sense. Looking at the function definition, the parameter is labelled as , which again adds no context. Console Output At the moment your outputting straight to the console as you generate the combinations. Generally, you want to try to separate user interaction from your algorithms. This allows you to reuse the algorithms in different contexts, put different front ends on your code etc. Static State At the moment, your storing your state in static variables that are accessed from your recursive method. This is OK in your example code, however if you were to put the method into a library, it would mean that you couldn't call it from two different threads to process different word lists. If the state is passed in, instead, the methods become more flexible. Minimise what your client needs to know When you write recursive functions, you'll often need to pass extra parameters into the method in order to support the recursion and the termination conditions. Clients shouldn't need to know this information (this give you more flexibility if you want to change the way the method works in the future). Putting it together Putting some of the above together, you might end up with code something like this: