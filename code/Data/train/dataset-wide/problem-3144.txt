There are probably more and better ways to write the test, but this just shows where I started. FYI in case you are curious what my new BranchData class looks like (it isn't complete it is just enough to make those 2 tests pass) 

(Note that I did this in Notepad++ so syntax might not be 100% as it is for example only) Now with your stats. Take a step back and consider what it means to put in a getter and setter in a player for his stats. If Conan levels up and has an increase in stats you're giving yourself multiple ways of increasing his stats. You could new up a set of stats and set that. You could increase the stats manually on each property. The problem with multiple ways of doing something is that it allows for subtle bugs that can't be covered in tests. Lets say for instance you want to have fireworks go off when Conan goes up a level. You would put in a listener for when the level changes, but what if you new up all that? The level would technically not have changed and therefor the fireworks never go off. Now Conan destroys your monitor because you didn't give him due reverence. Consider the next 3 methods. The first two are how a person could increase Conan's level, and the third is a potential way that you could implement. Which one gives the least amount of reasons to change? 

In the end the commands are not going to change, so I've considered just using a byte array instead of a whole class for command. I don't like the idea of making an extension method for a byte array which makes me second guess doing that. Every command except for GetDeviceId takes in as it's first parameter the device id. So I wrote down on paper an idea about writing something like or I've also thought about making a non-static Command factory pass in the deviceId and have it send back commands. Then I wouldn't have to pass in the device Id each time. Are there any design patterns that would better match what I'm trying to acheive? 

I'm suprised no one has mentioned that having all of your game in the Main method is also not good practice. So I will. Don't put all of your code in a single method, even more so don't put all of your code in the MAIN method. itsbruce mentions a great solution to this problem. So in my answer to you I want to show you the merits of Unit Tests. There is tons of info out there, and I'll never write it out as good as some of the posts/blogs/videos can. However I can show you that with this style game you'll see how beneficial it is quickly. Personally I imagine that your game could be written in stages, and making different stage classes that do the 4 steps that itsbruce mentions. I also imaging a collection of those classes and looping through them all. If you make it to the end you win. a mock up of what I mean would be this 

sorry for spelling and grammar i'm on a tablet. As for your unit tests you should always do your tests first. think of it like a school test. does your teacher give you a blank paper and tell you you have thirty minutes to finish. your unit tests are the questions on a test. your production code is the answer. asserts is your teacher checking your answers. so with your tests think to your self, how do i want to save my users, how do i want to load my users into memory, how should i add more users to my collection...etc once you get those questions written then write your code to do that. now in the future if you forget how a method works you can just go back to your unit test and see how you implemented it. i hope this illustration gives you a small step in the right direction 

NOTE: No Attempt to clean up code was made, just safe encapsulating now the getSqrt() method looks like this 

that is the bit of code I use to test this bug. I can't seem to fix it, and I've concluded that my multithreaded skills are.. lacking. In my second thread that is checking for the cards it works something like this. 

This information would have been better served in your question. But the test is simple and is simple to reproduce using , , or . The latter two being among the more popular but MSTest is built into Visual Studio. I see that you put in your "test" so that you can watch the debug screen. Well how about instead of reading the debug screen you watch the test runner screen for a green check or red x for a pass or fail? You could even copy and paste your code but you'd run into an immediate hicup. You have testable code inside a non-testable class. Solution: extract that method into its own very small class. 

Those tests all pass with your current code. However, because I have tests I can now easily change your code (fyi it took about 5ms to run all 3 of those tests) And here is a portion of the resulting new code. Granted it's not that much different... but it is testable. 

when I change degrees to private the compiler will now show me a few places where degrees is used. One in particular that stands out is in 

Normally I would also mention testing, and one place in particular that I would like to get under some sort of test framework is Baller because there is some logic in there that needs to get tested. specically there is a bug (as far as I can tell) that if my paddle is at a steep angle the collision detection is wrong. I'm not sure specifically where it is wrong, but the ball fell right through my paddle but did move slighly (almost like there was a hole in my paddle that the ball fell into). That is all I have for now. 

So although this code is a small example it still can benefit from having a few methods sprinkled in to help clear up what you are trying to do. For instance what if you decided that you wanted to change the max and min to be entered in as a parameter to starting the program? You would have to change max and min to be equal to the int value of args[0] and args[1] although for a small example that is not a big deal, but it would be a little more simple to of had a method similar to this. 

you put all sorts of work in the . One bit of work you do is check if a file is present and sets some text. One of the driving forces for using MVVM pattern is claimed testability. Well using codebehind has potential to still have well tested code. (just most frequently you'll see examples that show no testing, or testing ability). So what if you had a class that return a boolean value, and a success method? That is testable. Consider this class 

If you have to put a comment to specify what a request type is then you should either change Request type to be a enum so it uses words, or if you can't do that then use a constant in your class that would change. I'm going to assume you can't change RequestType easily, so I'll just show using constants 

Somethign about the way that I parse the string back to the Enum (well the entire process really) doesn't sit well with me. I'm very bad at LINQ but have been trying hard to learn it and use it more and more when I play with XML. Is there a better/cleaner way to parse the FunctionKeys? EDIT I forgot to mention that I can change any portion of the code or XML file. Right now this is a new idea and can be changed to make it better. 

There we go. Now if the user was telling the truth this test would fail. If it passed, well then there is a bug in our code. Good luck, and welcome to Code Review! 

it's not much different, but I don't plan on exposing any of the commands from my Enum to the user since most if not all of the commands require a certain order. Where as the LED example is a good example (to me atleast) of when to use a enum. The user has to choose a very narrow set of LED's. in the end the user still only sees the few methods that I mark as public and would still never know if I ever deleted the Commands enum or not. What do you think? Keep them or remove them? 

So I suppose the answer to your question can go in a few different routes. Best practices would suggest that you write tests, encapsulate and use some different design patterns. However my thoughts when looking at your code is that this might be a little frustrating to you. But your question also points to something that I think a few people will miss. Making 10 small classes to solve the same problem (in terms of lines of code) will be the same as 1 large class. I'll offer this suggestion as a rebuttal and an answer. Learn how to encapsulate in clear logical manners. You'll end up with 10 (just a random number) small classes. The point being that the smaller the class the easier it is to understand what it does. To answer your question as a superficial answer would be to make methods to remove the duplicate code. Your method has TONS of duplicate code and would be greatly simplified like so 

Now for the section is bothers me. The "LED" on the device is actually a RGB LED. So to get White i have to make 3 api calls to turn on Red Green and Blue. Same goes with any other color I want. Below is the code. I took out the boring non-relevant code. 

Unit Tests I can see why you would not like your unit tests. Although it isn't required for you to use a test framework to write unit tests it is helpful to use them because you can run them in isolation and quickly and as an extra bonus visual studio has a nice window showing the status of your unit tests. MSDN - Run unit tests with Test Explorer 

ok, so now in roughly 0.015 seconds I can see if any changes I make to IntegerCalculator broke my logic. I also know exactly how to use it and can refer to my tests as a form of documentation. Ok, If you pasted that above test in, then you'll know that IntegerCalculator does not exist. Here it is (well, most of it) IntegerCalculator.java 

By pulling that out I start to see what the code is wanting to do. I thought to myself, what is this total doing in the else statement? I commented it out and ran the tests to see what failed and it is just the case where a discount rule is not found for a grouping, or to put it differently it should be applied when a discount isn't applied. Since this is a checkout scenario anything not at discount is at full price, and since I am checking out I should have the price added always anyway! Which brings another point of change to light. What if the customer wants to see all items printed out at full price, then show a list of discounts in the receipt? (I know at least 2 companies that do that) That's my two cents. Open Close Principle. Try that approach next time you do this Kata. 

I would consider putting in a few methods in Player such as MovePaddleUp, and MovePaddleDown. this could possible lead to you not needing the enum Move. In the end I would think about the few principles I've stated and think over the rest of your classes that I did not cover and see if you can't work them just a little bit more. Lastly, I've ALWAYS hated it when when a Form extends something other than a Form. This makes it very fragile. Instead just override/subscribe to events in your form that you want your controller to do (like you already do with KeyDown) 

ok, so now how do I use it? if you listened to h.j.k and use a common actionListener for all your number buttons, and another for your operator buttons then it is super simple. here are the important parts that i did to make it work (it's not super pretty) 

note: I'm using TestNG and made IntelliJ do most of the heavy lifting for me. So the first 3 lines of code are from the IDE. It is importing all that I need to start testing. The method I created with the annotation. (you can read more about how TestNG finds tests to execute on your own). So the actual arrange for this is simple. I created a new and a new set of arguments that I want to give it. In this case it is an empty String array. Act Now that we have the test arranged like we want we act on it. most of the time this is a simple one line call. 

the test runs in about 300ms, and it took me about 2 minutes to make that test. 300ms may seem like a lot, but that includes compile time, setup time and execution time. Actual time to format that is very minimal. So now I have a string that is formatted the way you want NumberDisplay to show it. You would pass in your numberformatter in the constructor, and use setNumber which would run the number through the formatter and put up the appropriate images as needed. (I have that code on my personal laptop so maybe it could be a exercise for you) Speaking of which, before I couldn't get this working without first having to change all your images to use . I believe it is good practice to use that instead of hardcoded string literals. I even pulled out all the images into a abstract ImageResources class which loaded statically. 

More importantly I am able to also test this in isolation. I don't have to load up the program at all to see if my TvRepository is correct. This leads me to my final point Unit Testing Unit testing is a fast and easy way to check if your code is doing what you want it to do. I'm not going to tell you how to unit test because of the abundance of information available on how to unit test. (Plus as I write this I'm also doing it in code and can create another pull request) Since only needs a file path I can make a very simple xml file with no more than 10 items in it. Once that works as needed I could do a much larger test check the one xml file you have in your project ANN_AnimeDB_20-12-2015.xml. So I create a TestDb.xml file and put 10 items into it from your bigger xml 

Get code out of Program.cs and main First thing I would do with your code is to not be in the practice of putting any sort of code in Program. I don't mean to have 0 code, but it should be responsible for only 1 thing: Program state. That means just enough code to start, and just enough to exit (optionally report abnormal exits). To that extent lets take the first step. Copy the entire DrawBoard method and paste it into a new class. I've chosen . 

I use the state to tell if the reader is potentially sending commands to the API. I tried putting in a CCtricialSection in my reader class but when I compile it says cannot access private memdeclared in class 'CObject'. I find that stupid because in my main class it has a CCriticalSection declared with no problem. so I had to comment out the CCriticalSection and the 2 methods I tried to use in reader.SetState 

Methods Probably the easiest thing to lookup and learn how to do, but also comes with a few caveats. I'll try to break it down and apply it to your code. The greatest reason for writing methods is for clarity when reading your code. As someone who reviews your code I want to know from a high level what your code is doing and make a decision along the way which method I want to dive into. So for instance in your code. I'm looking at a variable called In order for me to understand what each of the choice numbers mean I have to read the code. Well what if your code looked like this example code: