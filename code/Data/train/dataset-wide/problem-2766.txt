Moreover about the class, I think it can be misleading that member is typed as a , if it's a it should be named or it should be typed as a . Then I think you can simplify the code with interfaces representing the server responses, here is a fixed and commented version of the code: 

and some semicolons are missing. If you use with this project, I suggest to point and fix thoses little issues. In the class, we are expecting a message as a but in case of failure we are passing an : 

Finally you don't need jQuery to achieve the functionality and you can use Angular and native types in your API: 

You can spot the previous points with the command. Lifecycle hooks only work in components. You can drop the JS convention of prefixing private members with . Members of the class can be marked as . Moreover, Angular is a rxjs-everywhere-framework so is a confusing name since it's a common type of . is a dependency of your service, maybe it can be treated like every other dependencies, with injection. You can also type the jQuery objects if you install the package. 

Your code works but it's buggy. The array will never stop growing and may cause performance issue. You can add an "unsubscribing" method in your service, components will call it in their method; but I think it's a bad design, consumers of your service will forget to call the method for sure because they will assume that they only have to unsubscribe from the observable you provide. You have to get rid of this array. I suggest creating an Observable directly from the click events and then filtering it in : 

As you can see, it's quite different from the promised code, but you will see with practice that observables are more powerful than promises. You can easily limit the number of calls to the tracking service: 

First of all, you are using some kind of C# code style in your typescript. I suggest the command-line to conform with typescript/angular code style. Moreover prefixing interfaces with is not a typescript convention ($URL$ I think the difficult part of your code with rxjs is how to know which room we have to update when we receive a status. I find a way to keep track of the room without changing the api of the via zipping the observables returned by the with an observable containing the room. Here is a proposal with rxjs, I tried to fill the blanks in your posted code to make it run so focus on the function and the method: the component with the dropdown: 

You can use the method to require only one lookup for most map implementations (esp. important for concurrent maps that may contain values to ensure reliable results). 

Runtime improvement If you take a look at the last digit of the first few fibonacci numbers you will see that the digits are repeated after 60 numbers. As the digits in this range have a sum of you can calculate the sum for instead. Bug The task states that the given integer are non-negative, is a valid value. Currently you are returning i.e. for the range as is treated as , the initialization of sum has to be changed to: 

The array can be an int array instead of a long array. You can replace the modulo operation with a multiplication and a subtraction (which could/should be faster). 

If you cannot/do not want to change the interface, you can use an intermediate abstract class to have the forwarding method only once for all implementations 

Besides that could (and should) be a local variable. The spacing between operators is inconsistent, you should add whitespace around the operators (except for unary operators) to improve readability. 

In the context of the quoted task I would stick with , documenting the possible return values should be sufficient (besides maybe renaming the method to something more meaningful like ). getCoinToss Using or would avoid quite a few calculations and thus would be significantly faster. Additionally the current approach will perform poorly if the method is accessed by many threads. 

Implementation You can invert the values for and to avoid the initial . The innermost loop can start at instead of : 

calculateCombinations Your method does a lot of not required iterating. You only have to iterate up to in the outer loop as afterwards the if statement evaluates always to false (-> you can remove the number variable and thus the call). The value of and is the same on each iteration -> you can drop the variable. The if statement can be removed by starting the inner loop at . The resulting code would look something like: 

Stream vs Loop The main problem I see with a stream based approach is (besides the overhead of the streams), that it is more difficult to optimize compared to a loop approach as the abstraction level is higher. For example converting the implementation to a parallel approach is in my opinion way more complicated with a stream approach. Algorithm improvements (not directly related to the question) You can use a (or directly a // array) to ensure that each entry in the sieve consumes only one bit (instead of currently (likely) 8). You are storing all values from to in the sieve, you can save memory by skipping multiples of (and , , ...) at the cost of some additional calculations to convert between sieve position and value. For larger values of it might be advantageous to divide the sieving process in smaller steps and use a small array instead of a large array for all values and sieving the complete range at once. The sieving process can be converted to a parallel implementation with nearly linear speedup as two or more values can be sieved simultaneously (sieving process of each value is independent from other values). Approx. performance for , included my implementation (which utilizes most of the improvements mentioned above) as reference value: 

Perhaps instead of using a to keep track of the merged meetings, you could use a stack (though do not use , rather something like , refer to the docs why). Instead of getting the last element from the list, you just the top, and if you have to merge again. I am not sure how I feel about 

I think you are really thinking well about what is going on, what potential up and downsides are. I am not really familiar with card games, but my initial guess would be that it may be a bit long stretched to find a unified interface for all types of card games. In general you have cards, hands and decks, but the similarities can pretty much end there. I also like that you used good descriptive names, private fields, and final where possible (though you are not entirely consistent with it). There is quite a bit of code, so I'll comment on the major code wise things that spring to mind: 

Your question about only changing state through the public interface: definitely yes! It is a really good principle. It makes sure you are in control. Finally, this is me, but I am not much of a fan of using the prefix. Apart from implying it always is a simple field acces (which granted, in this case is generally true), for me it feels superfluous. Apparently, it also has a name, namely the . There are some interesting reads about this I think. 

I am not sure I agree that a loop is more elegant per se. The downside of your method compared to a traditional loop is that it requires a bit more processing most of the time, because you need to create a new character buffer and put the replacements in there, and you create a new object. I would probably create an initial implementation with a Java 8 , e.g.: 

Well, I do not want to be the one always hammering on using s, but your second solution was almost immediatly clear to me, whereas the first was not. It does help that with the second one you split it up into methods, a very good thing! Nontheless, I still think you can improve the second solution: 

Besides that I would rename the method as it prints the combinations, with the current name I would assume that the method returns the combinations. permutation This method is effectively a recursively written loop that returns the product of the range (=factorial, thus method should be renamed to factorial) and thus can be replaced with: 

Currently each future processes elements (increasing the increases the total workload ()). Instead you want to divide the workload between each of the futures: 

(I would initialize with a ternary operator instead.) Types As the values of , and are always in the range , you can use instead of for these variables, arithmetic is likely to be faster than arithmetic. Alternative implementation The remaining range is quite small -> you could cache the results for every number in the range to avoid calculating the sum on each invocation. 

generateValue The conversion to and from strings slows your method down, bitshifts are more appropiate ( returns the same result). As @Piers Williams already stated, an iterative approach is preferable. A possible implementation: 

Space efficiency: Currently you are storing 50% of all values, this can be reduced to 33% quite easily by not storing any multiples of . (Excluding additional values is possible but complicates the calculation between value and index, you might have to check until which point excluding values is advantaguous.) Sidenote: You reduced the space consumption by the factor 2*8=16, not 64, compared to an implementation that uses a (at least for the OracleJVM). Performance: You are iterating over each bit, I would use to process the bits in blocks of 32 bits. You might want to use multiple threads to sieve, a simple implementation could use multiple threads to strike of multiples of different starting values. (For comparison: my quite similar implementation that skips multiples of (and uses instead of ) is around 25% (singlethreaded)/60% (multithreaded) faster than your current implementation.) Implementation: You don't need the variable as it is equivalent to . Your current implementation may overflow for larger sieve sizes. I would iterate over the indices rather than over the values to avoid converting while striking values off. Possible implementation (the resulting array should be encapsulated in a class that provides methods to operate on the sieved values): 

I have a feeling there is a direct way to compute this amount, but I am not really into all the mathematics, you could possibly look it up. I'll talk about your code as is: 

I can't think of a way with better time complexity, you have to know all values before you can sort. Though with some Java 8 stream capability added to the class, you could implement it quite cleanly as follows: 

I think it makes the loop implementation a bit confusing, because this is only called once to add the first element to the merged elements. I wonder if using and iterating over that would be better, or a manual iterator... Also, should the s become immutable, it would change the implementation a bit. Note that you are now changeing objects which are coming from the outside. Your method assumes that the start time of first is always the smallest start time, and that the end time of second is always the greatest start time. This would be wrong for e.g. first = [8, 12], second = [9, 10]. It will return [8, 10], when it should be [8, 12]. The overlaps method also is a bit incorrect, because multiple meetings starting at the same point in time will not be merged. Also is the same as . Finally, your show method ends each line with a comma. Should you want to simply delimit each meeting with a comma, but not one at the end of the line, you could solve it for example as: 

A short comment about your first approach, using a would be a good thing, because concatenating s with each time builds a new object, whereas with a , you would only make a new when you concatenated all parts. In this very case though, pure performance wise, it might get optimized under the hood to use a anyway. 

I'd like to give some thoughts which spring to my mind when I read your given code. Now, you have an implementation specific for primitive ints. A more advanced step would of course be to implement a generic like the one in the JDK, just mentioning it. First up, I like that you use clear variable names, and that you reuse methods like \ . Kudos for that! As an aside, you do not need the variable, as it is the same as . It is a fixed size stack, so it does mean you have to know beforehand how much elements it would take up, in order to not waste space (or run out of it). Perhaps for a follow up exercise you could try and make it dynamically resizable? Now, for the method. I would not let it silently succeed if the stack is already full. Seeing as it is a fixed size stack, I would probably opt to throw an , because to me it looks like a programming error. A possible second idea could be to return a , signaling succes or failure (though I don't think it is the better solution). Same with peek. It now silently succeeds and returns , which is very well a valid value which could reside in the stack ( exists by the way!). The solution would not work here of course. Also, I personally do not think the extra new line is an improvement, on the contrary. Finally, to me means taking off the top element of the stack. So why not return it?