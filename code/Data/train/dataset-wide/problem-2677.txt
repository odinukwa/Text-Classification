4 - User compiled queries where possible. If you know you might be performing a query multiple times, there is little sense in having the query provider generate the sql each time, you might as well take advantage of the type: 

Pagination should be done by the database server where applicable. There is really no point pushing data down the wire if it is not being used, so what you should think about doing, is passing in your page number and count variables to the query or preferable a stored procedure, and use SQL to select the subset of data you want. There are SQL constructs in most SQL language variants to do this. Here is an example using MySql: 

Other comments: 5 - Rename your data context type to something more applicable. I'm sure your app isn't called ? The naming of a type should be relevant, in terms of data contexts, you might want to name it after the database name. 6 - You're not storing the plain text password in the database are you? Only ever store the hash. Importantly the changes above allow you to logically separate out the concerns of the original method, now your validate function should be more streamlined: 

Regardless of how you do it, at some point in the execution of a method like that, there will be a enumeration. What you can do, is make the method more terse by using a LINQ method: 

These are small performance improvements, you'll appreciate them more if you are doing a lot of DOM manipulation and lookup. More simplistic applications won't have such an apparent performance improvement. 

I know there are already many responses to this question, but here are a few other tweaks: 1 - Refactor the method to return a boolean result.. the method shouldn't really care about how you report errors, it should care about returning a simple result... , the password's match, , they don't: 

Along with @kingjv's suggestions, you can improve the performance of your jQuery selections by making some simply tweaks to the selectors. Consider if I have the following html: 

If you I am using a class selector, such as then the selector engine has to do a little more than it needs to. In this example, the selector engine has to walk the entire DOM to match the correct elements. We can improve this a couple of ways: 

Something to remember about the Java libraries (especially older ones) is that they were written when Java was a new language. Some of the techniques and patterns we use as standard now were not available and the compilers, optimizers etc were a lot less smart. A lot of things we can just ignore now and let hotspot handle had to be considered in the code, and since these are core libraries that must run well on every possible Java device they cannot assume anything about the environment they run in so have to do as many optimizations as possible by hand. Sun's code to compute hash of string: 

I would try and approach this more generically. Define a rules interface, run each section of the string through the Rule and add the result. The rules can then check individually for all caps, exclamation marks, etc rather than hard coding it into your central method. (i.e. a rule that returns 1 point for every exclamation mark it finds or something). Might be worth having two types of rule - "full string rule" and "word rule". the full string rule can process things like total number of exclamation marks and stuff, then you split the string on whitespace and run all the found words through the word rules. For things like nice/nasty words I would have a configuration file somewhere listing words and a positive or negative score next to them - for example please -10, swearing +10, etc. Your word rule can then scan your words against that dictionary and apply the result to your score. 

You are using a lot of different variables to store the objects in and declaring them for your whole main method. If you really needed four it would be better to have an array of but in this case you are better just having 2 (maybe still in an array) but only create them when you actually need them and set them to the right type then. By using the array that then lets you change the player 1 and player 2 while loop into one for loop to run over the array[] and you can remove all that duplicated code. It also lets you support any number of players virtually for free. For the loop you can use a do-while loop as you know you always have to run through the loop at least once. It would be more efficient to use one Random object created in Main and then passed into anywhere else that needs it. Other than that your Pile object looks fine. Your Player object is a classic case where inheritance should be used. Create an abstract base class Player and then create subclasses HumanPlayer, ComputerPlayer and SmartComputerPlayer (the computer players may or may not also have a common ancestor). Then you just have a Player object reference in your main class and it calls the relevant method in that - which gets sent to the right subclass automatically.