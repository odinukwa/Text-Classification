As for other ways to do the ladder of possibilities: In this case, because you're doing expression SFINAE, I don't think you can get any better. If you were willing to name your constraints, via 

I was going to say "-qualify your reference parameter" here, too; but it looks like your function actually does modify ! This is a big no-no. You should make a copy of the matrix if you're going to modify it inside the function, so that the caller's original matrix doesn't suddenly contain different values just because he called . In C++11, the way you unconditionally make a copy of a parameter is to just drop the ampersand: 

Now the caller doesn't have to worry about things like "is the the first or second argument to ?" or "does secretly have to bear some relationship to ?" or anything like that. The only parameter the caller needs to worry about is the predicate, which is an opaque lambda type that clearly can do whatever it wants. Notice that the type is a different type in all three of the calls here. So we have a little bit more template explosion, maybe; but it'll all be inlined anyway. Also, at this point, we've got something that's very close to the standard algorithm . So we might like to get rid of the member-function algorithm and just provide a pair of member functions to create iterators into the unordered elements of the heap: 

In C++, is a side-effecting expression: it means "actually increment , and then return the old value." So (in C++11 and C++14), this statement as a whole has undefined behavior: it's telling the compiler that you want to increment , but also assign a new value to . In C++17, this statement may or may not have defined behavior; I'll have to read up on it and get back to you. Certainly is guaranteed to be evaluated prior to the assignment, but I don't know if that completely solves the problem. Anyway, what you meant to write was simply 

Okay, here's the bug (I think; please let me know if I missed something). Suppose thread T1 is trying to resize the storage, and thread T2 is coming in as a new reader trying to pop. T1: enters T1: increments from 0 to 1 T1: calls , which returns without doing anything T1: enters with T1: sets T1: locks T1: tests , which is false because T1: therefore doesn't execute any iterations of the loop T1: a bunch of unsynchronized stuff culminating in Meanwhile, T2: enters T2: enters T2: increments from 1 to 2 T2: enters T2: tests , which is T2: decrements from 2 to 1 T2: acquires and releases it T2: increments from 1 to 2 T2: returns from T2: a bunch of unsynchronized stuff culminating in Let's interleave those so it's clear what's going on: T1: enters T1: increments from 0 to 1 T1: calls , which returns without doing anything T1: enters with T1: sets T2: enters T2: enters T2: increments from 1 to 2 T2: enters T2: tests , which is T2: decrements from 2 to 1 T2: acquires and releases it T1: locks T1: tests , which is false because T1: therefore doesn't execute any iterations of the loop T1: a bunch of unsynchronized stuff culminating in T2: increments from 1 to 2 T2: returns from T2: a bunch of unsynchronized stuff culminating in 

In general, declarations are frowned upon; although again in this case it's harmless. declarations in header files are the really bad thing. In "ToBase64.cc", you could just as well get away with 

Three optimizations I'd make to this code for better API design: First, don't use default function arguments. If I meant to write but fat-fingered instead, give me an error! If I meant to write , trust me to write it. You're hurting more than you're helping when you try to save your caller that one extra character of typing. Second, use radians. Radians are the right answer for trig in the same way that UTF-8 is the right answer for character encoding. Trust the past couple millennia of mathematicians when they tell you that angles should be measured in radians. This will save you some repetition here, and some unnecessary rounding errors as well. Third, optionally, use ; it'll give you more accuracy and be no slower — maybe even faster — than if you're targeting a normal desktop computer. Obviously if you're targeting a 32-bit microprocessor with hardware and software-emulated , don't use . :) In your real code, the above will be super readable because you'll be using real names for the variables instead of long placeholders like . You can also say or instead of . So: 

In C++, this does what you want (although modern idiom would have you write instead of ). In C, this defines a -qualified global variable; the idiomatic way to define actual compile-time constants (capable of being constant-propagated and so on) is to use macros or unnamed enums. 

We can tell instantly that it can't possibly work, because it's got this thing called that's basically a "carry flag" for the addition. The reason we know it can't be right is that this carry flag doesn't have enough bits to store an arbitrarily large number of carries! Try adding together 4294967297 copies of the hugeint and see what happens. One bit of carry is only enough for 2 addends, and 32 bits of carry is only enough for 4294967296 addends. What you need is a 's worth of carry; or else just get rid of this whole "carry" business and just expand the result as you go; or else get rid of the notion that it's a good idea to add arbitrarily many addends and just make a that does the obvious thing. 

Go away, angel! But "fudge" has a way of being wrong, or at least fragile. Suppose a year from now you went back and changed this code to 

On my MacBook Pro, after I set bound just to get the timings back into human scale, the Python code executes (with , i.e. Python 2.7.10) in 5.169 seconds and the C code executes in 0.073 seconds (after compilation with ). If you're compiling without , well, that could inflate your numbers quite a bit. With (implicitly ), my test case takes 0.195 seconds, i.e., almost three times as slow. 

Now notice that you don't use or anywhere in the code — instead, you pass around the caller's original and as parameters. And with the refactoring above, you don't use . So what you're left with here is a that is effectively the same thing as an . So, get rid of the useless class! 

This makes a shallow copy of the heap and passes it in by value; used consistently, this can absolutely enforce that no weird mutations are going on, and even (theoretically) allow the compiler to optimize more. But it's definitely "for advanced users only" and maybe "not a good idea anyway." ;) 

Anyway, these signatures are both getting into crazy metaprogramming, but the point is that I want to be able to construct a engine from e.g. or or whatever; I don't want to have to copy my key into a in order to build a . 

The repeated subexpression is a red flag: both because you're creating a string over and over (which does heap allocation, which is slow) and because you're using a C-style cast (type-casts are always red flags in both C and C++) and because you're casting away . /me checks the function signature again — No, you're not casting away . But you should be! A parsing function shouldn't be allowed to mutate the message buffer. Make that signature . Or even better: . 

VS2017 generates perfect code, and as a (non-negligible) bonus, you end up with really nice syntax — no ugly boilerplate. You just write the exact code you want to run — kind of like Go's but even better (due to subtleties of eager evaluation in Go that aren't relevant here ;)). 

Notice that I'm adhering to the Rule of Zero: the compiler-generated destructor is good enough for me, so I don't need to write it out explicitly. Similarly, I don't need to write out the body of the default constructor; I can just it. And I don't need to write a member-initializer for ; I can rely on the compiler to default-initialize that vector to the empty state. I do, however, provide a default constructor, because without a default constructor you can't do some really useful things such as call . 

This seems fine to me, but I'm surprised that you're following neither the "Almost Always Auto zealot" pattern of 

([1] Or else wrap around with a fixed length, in which case it doesn't need to grow in either direction and you can just use a plain old array.) 

A guideline was proposed: "Unconstrained forwarding references are always a bad idea." I don't yet 100% agree with that guideline, but I definitely agree when forwarding references are used in ways that might be mistaken for special member functions. The above code breaks usages like the following: 

One minor improvement you could make would be to split out the subproblem of "concatenating an arbitrary number of s", so that you could write without the recursion. 

From 36 lines down to 27 — and with no pollution of the global namespace, no templates, and — mainly as a result of flattening and inlining things with complicated dependencies on each other — it's just a little bit harder to break accidentally. 

And then we realize that we could just remove the assertion and let fail noisily; the caller will get the same general symptom (an exception) and will have to go fix their buggy code either way. So we've completely eliminated this line of code! 

Well, one coding-style improvement: You need those casts to shut up compiler warnings about unused parameters... in C. But in C++ you don't need those casts; what you do instead is, if you're not going to use a parameter, just don't give it a name. 

To answer the question you asked: You want to repeat asking the user for a seat number until he enters a valid seat number. In some languages (e.g. Pascal), there's actually a control-flow primitive called . In C, we spell it . Sample code follows, far below.