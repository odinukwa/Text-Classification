Standard C# naming convention for public fields is . You are mixing bracing styles. Sometime you put the starting on a new line and sometimes you put it at the end of the previous line. Be consistent. In you have a bunch of public fields (which has already been mentioned as something you should avoid). Some of these fields are initialized with yet you have code which relies on them not being . If you have properties which have to have been initialized properly for your operations on the class to make sense then you should have a constructor which requires these as parameter possibly garnished with a in case someone passes in . Some something along these lines: 

Just a note to your mutex usage: You have to be careful to make sure you always unlock your mutex on any code path otherwise you run into the danger of locking your cache forever potentially causing deadlocks which will be hard to track down. Right now you have forgotten to unlock the mutex when you find the entry but the object is not set (you do there). Also if any code should throw an exception for any reason it will leave the mutex in a locked state. To ensure your mutex is always unlocked you should use a : 

Clearly formatted code is a lot easier to read, maintain and is less prone to contain bugs. Naming is inconsistent as well, e.g. vs vs . There is no need to place braces around the value like this: . It should simply be . is not a function call. In order to append blocks to the end of each of the lists you currently iterate to find the end. It would pay off to keep a tail pointer pointing to the last element of each of the lists which avoids that. I think there is a bug when calling on the last block allocated. Example: 

Your class has implicit dependencies which should be passed in because otherwise unit testing can become painful. Those are and . Now while looking at these it becomes obvious that is purely used to retrieve the and it should therefore be removed as class member. Checking further it seems that is purely used to obtain a . Hence the class can be simplified by just passing the login URL via the constructor and let something else worry about to obtain it. This removes a concern from the class which it really shouldn't have to deal with. You could even make that a parameter to which is the only method which cares about it and remove that dependency from the class all together. This code seems slightly weird: 

However, no such allocation happens with so there is no reason to avoid nested reduces. Note that the proverbial "sufficiently smart compiler" should be able to handle these problems (but not necessarily the quadraticity above!), so you should only worry about this if you discover it to be the performance bottleneck. Remember (SICP): 

Algorithm Your algorith is quadratic for no good reason because and are linear in list length. I suggest that you add new elements to the beginning instead of the end of the return value in and 

Performance is probably quadratic in your implementation, so you might want to consider another approach for larger values of 1000 :-) 

Trivial Use instead of . Avoid very long lines (Emacs will indent for you). Do not use when a single without would do. Memory Use instead of when possible to avoid unnecessary consing (in your case, allocates a fresh list, so its result can be passed to ). Catastrophic Whenever you use , you are using the wrong algorithm. Optimal search is linearithmic: . Insert search is quadratic: . Your implementation is : 

You compute twice - this is a waste. You return instead of the improved guess, i.e., you return a worse approximation than you could. 

it in . Style Avoid in favor of . is better written as . Avoid mixing and : keep conditions in and side-effects (like ) in . Repeated and Each (and et al) allocates a fresh list, so doing a repeated can waste memory (and garbage collection cycles), so either using 

Lisp is a multiparadigm language. is just as lispy as recursion, and, in a way, much more so (think in HOFs)! Style 

You are doing fine, other than a few simple nitpicks. You are not using (which is a crazy thing to do anyway), please drop it. You should fix your indentation, it would make your code much easier to read. You probably want to divide by , not , in and you probably want to simplify the code there by dividing by instead of multiplying by the reciprocal; also is relatively expensive, so, if you were not i/o bound anyway, you might want to replace it with multiplication. Function should probably return multiple values instead of a . Global variable should be local to . Function should probably be called (it read the whole list). 

You should be able to get rid of the call to by inlining the call yourself. You just need to do some pre-computation (this time sticking with ): 

and the only difference is the index into . So you may as well have an outer loop for all the user input indices: 

will guarantee you that will point to which it doesn't. It might work or it might not. Your registers should be an array instead. Your machine state is a set of global variables. I'd actually consider encapsulating this in a like this: 

In C# methods are generally same goes for public fields and properties. Prefixing names with their type like or (also known as hungarian notation) generally provides no value and just creates clutter which decreases readability. Please use sensible names for variables, fields etc. , , , , , ... etc. That just nuts. A name should convey the purpose of the variable/field - what is it being used for and what kind of information does it hold - in a concise but readable manner. Maintainability is about someone coming back to it 6 or 12 months later and still being able to understand what that stuff all means. 

quadratic complexity which is probably not what the user of the structure would expect. This is probably one of the reasons why doesn't implement indexed access (neither does C#'s for example). Also I noticed that you initialize variables of primitive types like this: 

Not sure about the "faster" thing but you can replace the 31 lines of assignments with a 3 line for loop: 

You don't need to capture the result of a function call in a local variable to return it outside of the lock. You can simply do: 

Well, it depends what you want to do with this data. If you ever want to query individual field names or debug an issue with a field you will have a hard time extracting this kind of information out of an XML blob. Potential pitfall: According to the coldfusion docs, maps to columns on MSSQL. You need to make sure that the column is as XML can get pretty verbose and any character limit might get hit. On how to better store the data this is hard to say. From your example it looks like a form has fields and each field could have multiple values. This looks like a classic 1:n relationship to me: Form table: