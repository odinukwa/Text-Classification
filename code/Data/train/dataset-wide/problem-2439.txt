It's more than okay, it is nicely readable, has no problems and involves no abuse whatsoever. I sometimes do the same. 

I'm doing my first major jQuery development. It's a Widget for recurring events, and is as such a fairly complex beast. The full code is available at $URL$ for those who want to check it out. I appreciate any kind of feedback about any part of the code, so anyone who wants to take a look at it, that would be awesome. I have a couple of specific questions, and it seems best to put them as separate posts, so here is the first one: Does my directory layout fit with what a jQuery developer would expect? Is it "best practice"? The directory structure is this (somewhat simplified): 

Yes, too much for one line, yes, too confusing. Making a map an lambda for two values like that is silly, unless you are trying to win an obfuscation contest. So, the middle version is best. 

I'm doing my first major jQuery development. It's a Widget for recurring events, and is as such a fairly complex beast. The full code is available at $URL$ for those who want to check it out. I appreciate any kind of feedback about any part of the code, so anyone who wants to take a look at it, that would be awesome. I have a couple of specific questions, and it seems best to put them as separate posts, and here is the second one: I have several big snippets of HTML and I'm using jQuery templating for this. My question is on the best way to include these templates. Currently I'm using two different ways, and none of them are obviously better than any other. In one case I use a string literal: 

This is neat and simple, but the result is a lot of HTML inline. One of the templates is 219 lines long... :-) The other technique I use is to include the template as if it is a script in the HTML: 

Why are you first removing the quotes and then putting them back? And why are you removing the brackets and them putting them back? This does the same thing, except change ' to ". It also doesn't handle commas in names, so if you have that it won't work. In that case I'd probably use a regexp. 

Update: sucks, and that means your format is inconsistent and not parseable without horrid hacks. In that case your code seems OK, although I'd probably do it differently. I would most likely use a regexp to find all cases of commas that are NOT preceded by > and followed by a space to something else, say chr(128) or something like that. I'd then parse the code with my code above, extract the email from withing the brackets, strip all quotes and brackets from the remander, and replace back chr(128) with commas. And the lastly write that to the outfile. The difference there is that I don't try to handle a horrid format, I first try to fix the problems. It makes for cleaner code, IMO. Update 2: I instead replaced the commas that should be split on, making it simpler, like so: 

I agree with the question comments - there's no real way to avoid them (unless you can restructure the databases!), but the code can be made more readable by removing the loops into a separate generator function, especially since you're not doing any processing between each loop. Consider something like (caution: untested): 

Deduplicate points. Form the bounding rectangle of the points. If it's a solid rectangle, then you should have width*height points. If it's a hollow rectangle, then the outer ring will have 2*(width + height - 2) points and the inside 0. 

Is it quicker to deal with one blob of size max*max, and replacing dp[i][j] with dp[i+j*N]? Are you sure that your values are doubles, or could they be 32, 16, or even 8-bit integers? - less space to alloc/memset. Similarly, is your 2000 limit a specified one or one "large enough"? I'm not convinced that you actually need memset at all (You'll need to guard the term which reaches below the diagonal for the first cells)! Because you're always refering to values to the 'bottom left' of the current cell, you never access values generated by the previous run... Also, because you "shouldn't" access values below the diagonal, all the dp[i] lines are actually (N - i) in length, so less to alloc/zero. You will though need to make other changes to the indices in the loops (and especially guard the term). 

Because I was in the mood, I adapted your program to how I'd do it. It's a bit over-engineered and it's not 'there' yet, but should give you several ideas. 

Rather than 'removing' s, it may be better to move them around! But please, put for every , even if it has only one statement (another if). It makes it a lot easier to read. 

Rather than having a single class, create separate classes for each direction, then select which in a function. The two directions share no code in common. Rather than storing the result, return it directly. 

Remove any global line and mark out which variables are neither local to the function, nor passed in as a parameter (this is obviously easier to do with smallish functions!). 

Enumerate over the array/columns when displaying as you do in other places. This will stop you doing an list index that's repeated: 

It's not bad. A couple of issues regarding validating input, which you know about, but a few 'style' things, some of which you may not know about yet. In addition to Ryan's answer, a couple more suggestions: 

Put your "header processing" part into another function, since it performs a single task. It's a little awkward with the number of parameters even so, but you're removing three levels of indentation while reading it. 

You may be over thinking this, all the types have a common implementation and you can use to parse from a string. 

So what is happening here? First we need to sort these by the smaller and larger numbers, this reduces the number of iterations required. If either of the numbers is zero, then we return zero (since ). If the minimum number is 1, then we return max (since ). Now we can apply the shift operator since shifting one to the right divides the number by 2. By recursion we keep doing this until returns or . We can then determine the value if is even by adding the two half-products or if is odd by adding the two half products and max. Again, even in your original solution this will break for negative numbers. You can code around that by switching the sign () and swapping the sign at the end (, unless both are negative then you leave it positive). I'll leave that as an exercise for you. 

Also notice I changed the name. Also notice how I left out the method. This isn't a good way to do that, what if you wanted different text? Or only the number? In a different language? Try not to be too specific in implementation, leave that up to the "end" user. Actually instead of an class, I think this would be better off as an interface, this is what it would look like: 

I don't see anything apparently wrong with the coding, other than the selection of your index variables seems to be random ( in the outer loop, in the inner one for example). is pretty apparent as to its meaning (index), but things like don't really have any semantic meaning. Like other variables, you are free to choose one that best describes its purpose and loop variables can have more than one character. The other thing I see is that at the top of your file you have this: 

Method Name The method name is confusing, because the word "Log" to most developers means some kind of diagnostic routine that writes data to a file or console purely for debugging purposes. You are using it to take over the console (by clearing it) and output the text graphic of the dungeon to the console. I think a better name would be something like or something like that. However I think you shouldn't be having methods anywhere in this class, let the user decide what to do with it. If a class has a valid representation, you should be overriding the method instead, so becomes : 

Avoid Mutable Properties Your has a few externally mutable properties that I don't see a reason for them to be mutable. It would be better if these weren't mutable: 

and reword it to the following to make it easier to read (imo) and maybe even split the loop contents into another () function: 

Since we're all sharing methods, here's mine. Not as elegant as some, but may be considered simpler. 

One of the points that should raise a query is the amount of repeated code - you have a duplicate for every if. This suggests creating a function to handle it instead. Personally, I would end up with something like the following: 

Notice any patterns in the GLOBAL parts, in the same way as you simplified your buy/sell function. Separate these out into "access functions" for the globals - in this way, you isolate the globals into a (hopefully) single point, and remove their (direct) use scattered elsewhere in the code. These access functions should be as small as possible. 

From a quick thought - Shouldn't WriteFile actually work when hOutFile is the console? Otherwise I guess that you may need to check whether GetStdHandle(...) == hOutFile. 

As an extra bonus, it seems likely that the loops now in will be common in your code, so that it's now usable elsewhere. 

Which is just another version of ony's answer. Slightly simpler (maybe), but either version will need keeping in step. 

If you have 10 stacked braces at the end of the method, the method is too long. Break it up rather than remove the braces. re - it'll gain readability. One thing though that you may want to do is to set an initial capacity (say, ) - itself reallocates memory/copies data on resizing. Have you tried using a different image format, say png, rather than jpeg. It may be quicker to compress or smaller, depending on the type of image. You could also try spliting the image up into quandrants/etc, compressing & sending those and reassembling them at the other side. It may be overall quicker. And of course, if you want 'quicker', always base it on actual timings rather than feelings :) 

Warning: this hasn't been rigorously tested (i.e., with a known seed)! There are a couple of things that can be tried without majorly changing things: 

Treat the as a precondition for the loop contents. It's right at the start, so it's obvious that you're doing something 'special' with it. Maybe even change the to a to push it further up. 

I think you can use these to prove anything you like. If your program is running too slowly, your attention probably should be directed elsewhere. 

Always use for single line s (and , etc), even if it's not required. It'll save a lot of time one day... Rather than and then , you might consider using instead to do it automatically. leaves still allocated, and hence a memory leak. Either free it in the block, or use another label and free it there. I would avoid for statements with multiple controlling variables like