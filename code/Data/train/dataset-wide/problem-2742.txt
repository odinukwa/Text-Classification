You're doing three things here: splitting up the listing into sentences, parsing the listing, and recording the results. You can clean this up by separating these out into separate functions functions or classes. This keeps the code less nested and easier to follow. To keep things simpler I'm using regexes for the room names as well as for the dimensions. This will actually be a bit slower - "in" is really fast - but it is more flexible (for example, if you have to support plural endings or something else besides string lookups). I'm compiling the regexes using re.compile to make them faster and re.I to make them case-insenstive. Lastly, I'm returning the results as a list-of-dictionaries, where each dictionary includes the room, dimensions and the sentence from which they came. This lets you keep the printout display separate from the parsing. In practice I would probably use instead of a dictionary but I didn't want to get too far off topic 

don't use You should not use because it eliminates some important information, which may lead to some conflicts with your classes or classes of other libraries. It is not uncommon to have a class, which has a totally other meaning than the . And to be honest, it isn't that much more work, to type in front of the classes/functions, is it? use You do everything with for loops, which is bloated and error prone. Use the algorithms of the namespace instead. I provide you with a short an clean example, how you could do the above task (and more) with less lines. your algorithm itself You should think about logical improvements. Is it necessary to store every score in a vector, when equal scores produce the same rankings, and the following scores just increments by one? Therefore I took the algorithm, which returns a . doesn't erase anything itself. It just moves duplicates to the end of the range (our ); you have to them manually. But, before you can use you have to order your elements. I don't know if it's guaranteed to get the score input in a descending order; thus I simply use to ensure this. After that, it's a simple (which is a binary search instead a linear search) to get the first iterator to an element, which is not less than the provided score (ok, I had to pass an other function object, because we want to check for greater and not for less). starts with a zero index. This means, we have to add 1 to our index, to get the official ranking. Easy, huh? 

Conceptually this is halfway between 'traditional' inheritance heavy OOP and @MichaelUrman's data customization approach. All three have their applications, and the neat thing about python is that it's very good at both @MichaelUrman's method and mine -- which is not true for languages obsessed with type-checking and signature maintenance. 2) On the strategy level, in the long term you'll benefit from a finer grained approach. Engines, transmissions, and tires for example might be their own classes instead of aspects of vehicle (a station wagon and a sedan, for example, might share everything but body styles). The class hierarchy becomes less of an issue as you do more mix-and-match customization by creating collections of components. The usual pretentious programmer way to say this is 'prefer composition over inheritance' 

tl;dr Sort the , remove the duplicates and use a binary search instead of your linear approach and you will discover a huge performance benefit. 

In the end I did not review the correctness of your code, I just stepped over the obviously mistakes you made in your code. 

As you can see, I renamed my class to SynchronizedValue, because I find it more descriptive than LockedValue. The behaviour of the class stays unchanged, I only did some minor changes and I want to describe why. In every state of this class, only one mutex gets locked. Even in the move parts, I only had to lock one at the same time. This prevents me from getting into a deadlock. The real important part is in the function. In the last state of this class I returned a rvalue reference, which was bad, because when I really started to move the value from other, outside of the function, the mutex already was getting unlocked. This means a race-condition could occur, which is absolutely bad. To fix this, my only change here is to return a real object instead of a rvalue reference. The second important change is no code change at all. It is also closely related to the function. I am talking about the move assignment operator. While I had to check the self assign in the previous version, I can now just take the value and store it safely. The cleanup, which is the bad thing of a self-move, already happened inside of the function. Thus, it should be absolutely safe to deal with the self-moving problem. Why no noexcept The lock functions of a might throw, this means I am not able to make a guarantee for exception safety, unless I would write the whole function inside of a block, which is never a good idea to deal with exceptions. It is not a mistake to declare a move-assign not ; it just makes some optimizations for some classes impossible. why a and copy ctor That's a good question. While I know, that usually a copy ctor is enough, unless you have to modify the original object, it is here required to make the templated ctor possible. If I delete the non-const version of the copy ctor, everything works fine, unless I try to copy from a non-const SynchronizedValue object. A conversion from to is required; and a templated overloading always has a closer match than an overloading which requires a conversation; even when it's just the to a reference. I played a little bit around with SFINAE, but I got no nice solution for that (there might be a solution; but I wasn't able to make it work), thus I used this easy way to deal with this issue. The problem is, I can't SFINAE the copy ctor, this is the wrong way. I have to remove the templated ctor from the match list when I want to copy; and that's the real issue here. The idea, which someone came up with, was to try this one: 

I'd strongly suggest moving the HTML content out of the code and into separate files; I know you want to keep this simple and single-file but in this case there some real benefits to treating the HTML as a resource rather than as code: 

When you're composing, think about how you want to access the components you're putting together. In this example, you are asking the window to include a DrawRect that always draws to a 50 x 50 pixsel square. Does the window really need to include that rect? The DrawRect has all the info it needs -- you add the window reference in the constructor -- so what's the rationale for including it in the window? In the example code you create a DrawRect outside the window, and another inside the Window - and then never update the independent DrawRect so it never shows up. This seems less like composition and more like gluing things together which don't need to be connected. Consider the alternative: 

I prefer over , because it enables the possibility to create the objects inside the vector in place instead of copying. use the parallel std algorithms In the end you could simply use the std::transform overloading for ExecutionPolicies rather than writing the stuff yourself on the base of threads. Have a look here. 

Most of the points are already mentioned by others, thus I will only tell you my opinion about the missing ones. I don't really like your function. You obviously know how to use , why don't you simply use them for your purpose? It all boils down to something like that: 

The main idea here is to use the dictionary CircleSet as a sparse grid: it will only have keys where a point falls into a circle. I'm using a separate set() object to track intersections so that the 'overlaps' function does not have to look at every value and see if there are multiple entries, but you could ditch that and do 

I'd second @michaelUrman's point about the room constructor- the long list of params makes it hard to follow what's going on. Since you don't do much with the constructor - you're not processing or otherwise mutating the incoming data - you could just create empty lists/dictionaries as needed and then have separate methods such as 'add_wall' and 'add_person' which would make the code read more legibly. I'd be more aggressive about pushing the logic down into the different pieces. For example, you have a lot of logic in Room.display_Room() which depends on knowledge of what the state of different items in the room is. If the room simply called a standard "display" method that gave back the description of things in the room based on their own code the whole setup would be much cleaner. This is the much-discussed 'single-responsibility principle' You could combine that with generalizing the various types of room contents into a common base class so you don't need to manage so many types of pieces in different variables. This would make it easy to inventory and search through room contents and also make future expansion easier. Here's a very simplified example. 

Be aware of the fact, that you have to take care for the cases, where your vector size isn't a multiplication of thread count. There will be some elements left untouched, but I let this job as a task for you ;) 

You are running into undefined behavior here, because you are reading from a union property without writing to it first. Unions should not be used to convert types to each other. It is not safe! I am sure, the code doesn't do what you expect. Your code says, you are converting a uint8_t pointer to uint16_t integer. You are not accessing the data, just the address! 

The biggest thing you can do to improve the code is to find ways to make the relationship between the game flow, the data, and the code more concise. Right now the whole game is a series of if statements, and you're using variable names as the equivalent of old-fashioned GOTOs to jump around the code. For something this short that's bearable, but it won't scale to any larger size. Moreover, your structure is going to force the user to make one-time-only decisions at each point - you don't have a way for users to, say, go to the window and THEN look at the wristband. Or to go back, for that matter. That might be your design intention but if you change your mind the current structure will be a lot of work to fix. Last but not least, you don't have any error handling - if the user enters a wrong choice, the program will just move on to the next prompt without assistance. On a very general level you need to establish a structure that reflects the nature of the game. Most text adventures are really a series of linked containers; the container (a 'room' in the old school dungeon game, a 'scene' in a conversation based game, etc) contains a descriptive text and a set of options for the user which link to other containers, and so on. The contents differ but the structures are basically identical; it's a good idea to write the code in a way that reflects the way the game actually works. If you're familiar with object oriented programming, this is a perfect problem to tackle with classes. If not, you can still make your life easier by creating a function that handles the repetitive part and putting the data into clearly labeled variables. Here's a very rudimentary example that uses dictionaries to represent each room and a dictionary of rooms to represent the map. The 'code' is just to keep calling the same function on whatever rooms the user gets from their choice of actions. 

Use C++ not C First of all, you are making a lot usage of C, not C++. In C++ you either use the keyword class or struct to declare a class/struct, not together with the keyword typedef. You are using uint32_t a lot. This is also C style, the proper C++ style is the std::unit32_t type. But most of the times you don't really need to specify the width of your integer directly. This only makes sense if you want to serialize/deserialize them. Use new and delete instead of malloc and free. Better: use smartpointers like std::unique_ptr and std::shared_ptr. declare properties private (encapsulate them) The problem here is, you are using public available objects inside of the IMAGE_STRUCT struct, which can be modified from the outside. split-up your functions Your atImageEvent function is huge! Split it up into smaller parts. name conventions There are no explicit name conventions at all, but you should not declare your classes/structs with only capital characters (like IMAGE_STRUCT). Most of the times words with only capital characters are macros. It's not a mistake rather than a bit of taste. if I am not totally wrong names beginning with _ are reserved by the standard and should not be used for custom code. To be honest, I am using them by myself, but I think its worth to mention this. undefined behaviour 

and so on. The 'ui' for the program then really amounts to creating custom filter functions and returning them. You can manufacture them easily: 

which will except if dist is not a number; most python coders just try/catch around it. Without try's you'd have to provide a way of checking for floats that doesn't require a try/catch; maybe it's the point of the assignment? Apart from input validation, it's just doing a division otherwise. To get a float from a string without a try, you could do: 

I would avoid inlining the actual constants in the list comprehension tool - that's bad for readability if it's not sitting on the outermost outline level. On the philosophical level, I'm ambivalent. I hate all the quotes etc too, but this only works for strings, so it's not a general purpose idiom. You could extend it with exec or eval to get non-string values, but that's a whole big can o' worms :)