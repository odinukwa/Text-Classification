If I would encounter such a non-describing error I would have thought that something went totally wrong in your program. State instead "You entered an incorrect value, please input either a, b or c...". 

It seems like what you are trying to accomplish here is to make your Queue class immutable. That in itself is good, but there are a couple of issues with your approach: 

When writing this method, be aware that primitive types passed as arguments to a method are passed by value, not by reference. You need to think of a smart way to return the results of this method. To return more than one thing, you can return an object. 

Now, imagine that you hade your if-else switched so that you wanted to check for non-existing user first: 

There is actually quite a lot of boilerplate code involved here. Other alternatives I was considering suggesting making a / class to programmatically specify a string pattern. However, in the end I don't think it can beat the method. I'm sad to say it, but I don't find your code either re-usable or useful enough to be an alternative to . 

I tested your JSFiddle and I selected a couple of lines, thinking that it would add four spaces to each line when I pressed Shift + Space. However, it seems like the selected code got duplicated after pressing Shift + Space. I would expect selecting this part: 

Yes, you should handle that in your class. It is good to make your classes as re-usable as possible. The remove method is part of your class so it should handle all aspects of that method properly. You might want to throw a if remove is called on an empty list. 

Your current situation: You are storing all the visited numbers in a list and then querying only the size of the list. Instead of doing this you can instead have a single variable that keeps track of the number of visited numbers. You don't need a list. 

You seem to be very inconsistent in using on the fields. Remember to use private whenever possible. It is standard practice in Java to keep all class-variables (a.k.a. fields) at the top of the class together. This makes a typical Java class have the order 1. fields 2. constructor 3. methods. 4. static-methods (where you place the static-methods can differ, but they should always be put together whenever there are any). 

Another edge case that should be handled is the empty string. I assume you don't want to classify that as a valid mobile number? Then handle it also in or handle it in . 

Additional observations Currently all your champions are hard-coded into the code. I can highly recommend loading the champion data from a file. Additionally, your 'icon' and 'portrait' are very similar, perhaps it is enough to specify instead of and ? In your code it seems to be "obvious" that a .gif is icon and .jpg is portrait. I would recommend naming them and instead though. 

At first when I took a look at your question I was thinking: Why do you first set values in a boolean matrix to true? I quickly realized, "Oh. That's why." Overall, well done. I like your code. I would have solved it in the same way. Your coding style is consistent, which makes it easy to follow your code, even though I don't agree with the coding style itself. Two comments: 

Side note: If you are using JavaFX 8, you have the possibility to define an in your FXML for your buttons, this will be associated with a method of that name in your controller. See also $URL$ 

Not the prettiest one-liner I've ever seen, but I believe it works. Personally, I'd prefer a non-one-liner for this method. Writing code on one line just because you can isn't always the best option. Note that this uses the Ternary Operator, which you should read up on to make sure you understand it in case you haven't seen it already. Edit: As correctly stated by Josay in the comments below, the ternary operator can be re-written once more using boolean OR: 

This way, you can keep having only s as listeners in your , no need to split it up into three separate listeners. And if you want to easily create a listener that listens only to cards being swapped, you can easily do so. The trick here is that I'm overriding a default method and removing the implementation, thus making it abstract again. While letting the original interface have default implementations for all the methods. 

A completely different approach This problem can be seen as a problem about factorizing numbers. Consider \$4^2=16\$, why is that the same as \$2^4\$ ? Because if you factorize it differently, we know that those two values are exactly the same. So this problem is actually solvable without calculating the actual powers, by factorizing the powers instead of calculating them. I am unsure whether or not this approach would be any increase in speed, but when in doubt about performance there's only one thing to do, benchmark! 

Scottish Notation There's a thing called Hungarian Notation where you prefix a variable name with the type of the variable, such as (array named 'numbers'), (string for 'name'), but your variable name is something I'm calling Scottish Notation. Scottish Notation is, in my opinion, even worse than Hungarian Notation. You're using a very very short name (Scots are said to be cheap so they don't want to waste letters). And yet you haven't provided any information whatsoever about what this variable is used for. You have only stated the obvious, as short for . I can see that it's an array from the use of . A better name would be or possibly (although naming it is a bit overkill as it is an after all, of course it contains numbers! As stated before, naming things totally correct is hard...) Please avoid Scottish Notation! 

If you would like to make another project and use this class, you would have to copy it and change those values. That's not a good idea. Programmers hate copy-pasting code within their projects. This class could be made more flexible by not making it dependent of which project is using it. The best way to do that would be to store the constants in a project-specific class, and that the project calls your class with the resource-ids (such as ). Currently, if you've forgotten to call for a sound but try to play it directly with , you wouldn't hear anything. You could save yourself some debugging time from making it either log a warning or try to play a sound with that id. Using the values directly would help with this. Some final words As you've said yourself: This is working like a charm. Your code works, be happy! Really, I mean it. 

It's not until you call that the loop is actually performed, this is because is a "terminal operation". I would recommend to read more about Streams on Oracle's website 

Speed Looping over each and every tile in the game is a bit slow. You might want to consider keeping track of the zones that actually have some content on them. You can do this by using a , or perhaps even , or if there are generally a lot of empty tiles, perhaps would be enough. You might want to consider splitting your world data structure so that general tile data is kept as a two-dimensional array, and objects that do something are kept in a . 

First you perform the query. If the query fails (i.e. it returns a false-ish value), you , but if the query works then you call the query again. And if the second query is successful, then you call . THAT MAKES NO SENSE! 

I have tested this code for many cases using a for-loop, and it works mostly fine. I had one problem with using though as the was converted into , which loses some accuracy. So it seems like you need a special case for : 

Another Library If you would use Jackson and it's XML-parsing capabilities, you would reduce a lot of your code. Jackson has the ability to parse XML and provide a Java object for it - if you first manage to create a class that has correct structure and annotations for the data with which Jackson should create it. I am not sure if using Jackson will make your code any faster or not, however. The method, or rather, which you might want to rename it to, has a lot of parameters. By using the Jackson library, you will be able to reduce the number of parameters to only one. Logging The first parameter to should be a TAG that is used to categorize logging messages. Preferably, your entire application should use the same tag. 

Possible improvement: Catch (or use a regex in advance to make sure that it is a number, but that might a bit over your head right now). 

I don't think that's a good approach. should be called by the Android framework, not by your code. It is automatically called by Android after a call to . 

Now for the interesting parts, deciding which book to display. Your main logic for giving the right book suggestion has some logic paths that are a bit hard to read and understand when they will happen. I would highly recommend avoid combining and on the same without using parenthesis. Now, what if you want to recommend multiple books in some cases? Then you can just copy and change the statement, right? Yes, you can. However, it is not easy at the moment to maintain a list of books and specifying which book to apply in which situation. 

There are two important speed improvements I see at first glance. First of all, call only once. That method does a bit of work, and there's no need to call that twice for each tile you loop through. This leads us to the following: 

You only use fields which reduces the usefulness of your solution, as you can only check one Sudoku board at a time. Learn more about object-oriented programming and use classes and objects without static fields. Checking a 3x3 square can be improved by writing another (nested) for-loop, instead of hardcoding the position of the squares to check (which is prone to coding-errors). You check for non-duplicates and for the sum 45, but what about the integers \$0, -2, 4, 5, -21, 1, 13, 42, 3\$? They also add up to 45. So what you have here is not necessarily a Sudoku checker, it could be a Math puzzle checker. 

This variable has a bad name. It's not until I read this code that I realize "ok, it counts the number of guesses". It could just as well have been the number you guessed at. would be a better name. 

When using Hibernate, you have the ability to tell it all about the one-to-many/many-to-many/one-to-one/many-to-one relationships, and tell it when to cascade operations for you. Here's an example of how your could look. 

We're creating a unique each time, but I am assuming that you always use the same , and therefore the object will always be the same. I would recommend not creating a method for this and instead extract a constant for the format: 

has some duplication from . It might be better remove the output from and call the methods like this: 

...actually says just as much as the default one, if you would not catch the exception in the first place: 

Your code won't work correctly. Code Style It is a good practice to use a bit more spacing than you are using, ittendstohelpswithreadability. It is also recommended to always use braces, even on one-line statements. Bugs have happened before because of this, only a matter of time before bugs happen again. For example: 

I would create a helper method for returning the value you want to give to , and also store the value of in a variable. 

Preferably, to avoid double-negation, you should use instead of However, there's no way of having to do a method call to (or a similar method call) on your line. 

425 is a magic and seemingly random number. Magic numbers should not be entered in your code directly but instead used as named constants. Instead, use this at the top of your class: 

Isn't that more readable? At least it is to me. Variable names You are using way too many variable names with only one letter. I suggest renaming them like this: 

As your is only used inside the method, I would use it as a local variable inside that method. I would also rename the variable to . 

When using inner classes, this can be an issue yes. But when implementing two different interfaces, this will not be an issue. 

First of all, I have to say that the code formatting is very clean. It's been a long while since I read such well-formatted code. It's probably even cleaner than my own code, and definitely cleaner than my apartment. It is good to take advantage of the specification that the inputs are sorted. Overall you have done so nicely, but I have a few comments. 

This code would not work, and you might not be aware of why exactly. You might be just lucky that you did not code it this way from the start. The issue is that you are calling twice. You should not do that, there can only be a maximum of one result, which means that the second if will always be false. Your original code should look like this: 

Of course, if you still want to, you could provide an overloaded constructor that requires a and tries to instantiate that, although I think it is better to stick with one way and this seems to be the best way IMO, with regards to flexibility, dependency injection, and a whole lot of other things. 

Overall, the setup of Pascal's Triangle looks OK. I might not have done it the exact same way (I would especially handle the edges differently), but I have no specifics to pick on there. 

More important than the performance, your code is very likely vulnerable to SQL Injection. (I can't say for sure without looking at your PHP code) If or is chosen by the user in any way, then you have a problem. And even if it is not, I would highly recommend using prepared queries. I don't know if you're using the methods or methods or the extention, but you should be aware that the methods are deprecated (That means: Don't use them) and that you should either use (note the ) or . 

, and is way too similar. As the game model seems to use a class, perhaps you should make a class that is responsible for displaying a . There is also some duplicate code in , but I believe that can be handled by using a class. Then you could call on each . 

(Yes, you could use a simple for-loop to setup this) Then we have to determine first of all: Is our username in the map or not? If it isn't, that corresponds to our case. 

Ah, this is where the score comes in again. It's important to distinguish between a Question and the user's answer to a question. Maybe your system should support multiple users that should be able to answer different things? Then you need to connect each question that a user has answered to a score. So, besides the Question class that I've already mentioned, you could have some more things: 

A different approach that's capable of doing the same thing Consider Google's EventBus code. With the right event classes, this can accomplish the same things. Example code following: (not tested, but something similar would work) 

Only a suggestion: Use Hibernate (object-relational mapper) and/or C3p0 (connection pooling). They can be difficult to get started with but they are wildly used in many Java projects, for good reasons. Learning them can be both good for your program, and good for your Java knowledge. 

I'm sorry, but I have to ask: If you're not sure about exactly what the Set contains, why are you storing it in a set in the first place? Consider instead something like where can be a , a , or something else that can tell you what type it is. When adding items to this map you could use: