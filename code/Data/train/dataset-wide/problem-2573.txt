The differences are related to floating point accuracy and performance. In my original design, the iterator would endlessly spit out the initial value if the step value was too small in comparison, literally . In addition, if the increment was not perfectly represented as a float (e.g. ), error would pile up on the output after many iterations. By incrementing an integer and multiplying by instead, the iterator would eventually halt and always yield the most appropriate float. The reason I did not do this initially is that I had integers in mind; while all numbers in JS are supposed to be of interchangeable real number type, it is theoretically possible for a JIT or something to optimize into integer addition if it was always used that way. Integer math is way faster than floating point math, and addition is much faster than multiplying for either type. Math between a float and an integer is actually the worst, since conversion eats time too. After some testing, I have concluded that only very few cases (e.g. asm.js style for caller & callee) will allow that optimization to occur and translate into a tangible performance difference, and on many platforms it can just as easily be prevented by using and or overshadowed by call and return time. Given time, ES6 implementations may evolve to do better at this, and a special fast integer iterator will be justified, but for the moment, the suggestion of multiplying the step instead of repeatedly adding it is sound. Finally, the original code fails to produce number sequences of a single element because it returns early if the second element will be beyond . The intent of the early was to make the iterator empty if was the wrong sign. I tried to combine that idea with invalidating the iterator if you gave it equal to , for e.g. not iterating the indexes of an empty array or string by using , but that doesn't work. It's better to spell out both conditions, and the final correct code is: 

How I would write it I've been writing a lot of C lately, so here's how I'd reimplement your idea. Mine writes a lot less STDOUT, but you could make it do more with the information the functions give you: 

is not returned or modified, nor should it be. As such, it should be declared , so that the compiler may make optimizations and assumptions around the fact it will not change: 

Compiler errors First of all, this code does not compile with the (IMO too lenient) command line of : 

This scalably-threaded server has endpoints at and . This is just an example of how to use antiCSRF and you should never ever keep reusable, long-living secrets in your users' browser history. In the real world, instead of negotiating over , use with JSON or URLEncoded data, like me. I'd especially appreciate guidance on improving the threadsafe aspect of the library, but of course all recommendations and criticisms are appreciated. Finally, I fully expect to be told this is an insecure and wrong implementation, so tell me how I can write it better from an internet security perspective. 

As an exercise, I think your evaluation is fair - by all means, carry on. I think it's worth mentioning, though, that in terms of production, the factors you've enumerated aren't all weighted equally. At the end of the day, if your code is totally DRY, you can go home happy. DRY (don't repeat yourself) implies that every datum about how your system works is located in exactly one place in your source. You can't make readable, DRY code difficult to extend - there's only one place to make a change. The "code inertia" as I like to call it, as measured in keystrokes per behavior difference, is at its minimum. Beyond that point, any addition of complexity should be driven by necessity only. If the system outside of your adders and swappers evolves such that the simpler design cannot logically suffice, that's when you can think about picking apart the simplest thing that could possibly work. If your simpler design is DRY, there is minimal risk in leaving it alone. Complexity, on the other hand, is always a cost - it's work expanding to fill available time, and it's more time you have to spend training someone when you get promoted before they can test/maintain/extend your code. Since I don't see egregious repetition in either design, I would therefore prefer the simpler one. 

Use better names and do not use in headers The name is rather arbitrary. or is a lot better. That, by the way, is a perfect example why you shouldn't use when you write a header. There's already , so a would conflict with . Since you're writing a template class all your code will reside in a header at some point, so is out of the question either way. Use a smarter data store Use or instead of raw pointers for the memory. Or re-use , unless you want to practice writing a completely by hand. Use instead of Instead of return or a custom enum in . If I want to store elements in a circular buffer, I need to know whether worked. I cannot check stdout for error messages. Sizes are positive Use for sizes, not . Check all return paths Return (C++11 or higher) or in if the queue is empty. However, a pointer at that point is dangerous: the user must make a copy at some point, or they might end up with another object. Use if you have C++17 at hand instead, or 

That really depends on the functionality you want to guarantee. Assuming this is working code and your interest is to "declare" all aspects of a "class" in one block and also have reflection (access to the class hierarchy, via in your example, it breaks if you have a name collision. i.e. you want properties called and that have nothing to do with the framework. I'm having a little trouble seeing how this code works, though: 

Then, you can make your list of number formats more declarative; construct an array, output the descriptions, and have the user pick what will effectively become an index into the array for the source format. Then read the destination format and numeric string, in either order. As it stands, the input method is needlessly coupled to a finite set of formats and their names, as is the source/destination pairings. I once wrote a hex-by-default calculator/expression evaluator in assembly, so I'm the last guy that's going to call a wheel-reinvention foul on you; in fact, I like the general theme of your code because I've never seen a number formatter that covers absolutely everything, like your binary output's adding leading zeroes to pad 4 bit groups. Bravo on making a wheel that spins exactly like you want it to. With regard to the conversions themselves, I see more twos complement math than is necessary. In particular, I see several s while converting to binary. If I'm interested in a number's binary representation, I will probably find the equivalent ones complement operations in your code just as readable, if not more so. The sequence: 

Exercise: write . Note that there is a function that might help you in the process. We end up with the following : 

However, that's again \$\mathcal O(n)\$. But we know the length of our current solution; almost. It's the number of recursive calls: 

Since you're interested in performance, you probably want to split the into two parts to skip the unneeded even integers: 

Why as second argument and not as first? Because you usually have a function that is a polynom . That way you can easily give a name to and then only use , and so on: 

That's a good question. The answer is: yes, is a right type, but it's not the right type. Most of the time, you want to use the result of in some operation that wants an , not a , just like you want to use . Note that I said that is a correct type. You can of course use . 

In these four lines, six names are used. A total of eight references are made to names from this translation unit, but only one of these names was declared anywhere near this code. I know what is; it's a mutable double. For the other names, I have to think a little bit, to remember where they came from -- this is bad, because it should be explicit and obvious where they came from. I still can't think why those need to be globals, but nevermind that. Ditto on the braces, too. 

I've never been too bothered by the lack of (and thus ) support for Factor collections and other objects, but I've never needed to generate Factor programs from JSON until now. To that end, I use these methods to turn arrays, hashtables and assocs into roundtrippable strings: 

However, unless you're going for the last bit of performance, it's a better idea to use the standard library to your advantage: 

Same holds for your . Prefer to C-style casts Instead of use . Or use floating point literals. By the way, your is already a , so a cast isn't necessary. Using Only use in toy programs, and never in headers. 

The and the parameters and are good examples why has to be handled with care. All those names are already in . Use only if you know the risks. That being said, your generic variant will only work with random access iterators. If you want to make it more generic, you have to use and instead of and : 

No, sorry. You're heading in the right direction, but makes your algorithm \$\mathcal O(n^2)\$, and if it wasn't for , appending to the would also lead to \$\mathcal O(n^2)\$ due to . Or taking the all the time. Well, basically any function that you use in each iteration that needs to (possibly) traverse the complete list makes your function non-efficient. But let us start at the top. I suggest you to put your documentation before the type signature. That way, the type and the names are still close, which makes your function easier to understand if height is limited: 

I am going to assume your table rows are for a real table, i.e. they're full of data itemized to present to the user. If this is not the case, do not use tables. Only use tables for layout if you are a real cretin that wants to exclude visually impaired persons with screen readers from using your product. I would look over all of your s and see if there's a more sound tag for them. implies a logical division with no semantic significance, so if you're using them just to divide your page visually, there is probably a better element to represent the content that can be visually blocked the way you want with CSS. The reason I suspect this to be the case is that your HTML contains only , , and table-related elements. Unless the web app is truly something the HTML standards committee has just never thought of, either the tables, s, or both are being used inappropriately for layout. Previous reviewers have mentioned replacing some of your IDs with classes and/or changing the names that include "body", as well as unwrapping some more meaningful elements from their enclosing s. These are all good ideas. I'm not certain that the rationale has been stated, though. attributes are a good idea in the broadest semantic sense when the element serves a role that is logically necessarily unique among all elements. They are additionally necessary to target anchors and elements. Long long ago, they were the most logical way to make an element accessible from JS, but preemptively ing almost every element in case it's needed in JS creates a maintenance hazard that can now be avoided. If it's conceivable that there could be more than one (there are two sides after all) in some future revision, for example, adding it will involve more work and possible catastrophic name collisions if you're identifying everything with IDs. You'll basically start defining what a sidebar is and should look like from scratch in the page's CSS and JS. Then you have to maintain that code, too. The attribute allows you to assign similar styles and behaviors to the elements that share them. If two elements share any stylistic or functional aspect, they should share a . Unwrapping elements from their parent is an extension of using more appropriate tags and abandoning the "everything needs an id" approach because there are many s which do literally nothing but possess an and contain a more meaningful element. If the element inside needs to be identified, give it an or attribute as appropriate. The wrapping it just makes it harder to revise or transplant without breaking CSS rules and layout. 

Huh. I never got to solve that kata, so congratulations first. Working with a given AST As you said yourself, the AST type isn't optimal. We could use 

The standard functions for splitting lists at some point are , , , , , , and . They all are concerned with a single element in their predicate, so they are not candidates for our problem, unless we already have our splits: 

We need to lift twice: once through the functor , and once through the next . QuickCheck Your instance isn't very flexible. Furthermore, QuickCheck cannot set its size. Instead of a fixed size, use : 

You start with . However, throughout your program, the following property will hold: . So if the is greater then , it will certainly not be lesser than . We can reflect that with an :