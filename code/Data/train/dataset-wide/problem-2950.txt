Next portion of the code is reached only if we still have work to do (we didn't get to the inside the ). It's outdented, but maybe that's hard to see with my comments between the lines. Now, look at your line. What you really want is , because you use it in the next line (). So we'll use map. It should be pretty straightforward: 

As you can see, equals , at least at the first go. What we'll change will be the loops. Instead of thinking in terms of , we'll think more like - transforming the arrays with our , , functions or their CoffeeScript counterparts. Now, we have to define the transforming function for the , because we want to do something like . You see, with a little bit of imagination you had in your code. Now we'll do exactly that - our function for the will get a step at every call, just like your loop did. So that's that. Next problem we have is rewriting the "global" changes you make inside the loop. So we need to do something about the and lines. We'll make the changes propagate through the result values. But how can we make two things propagate through one value? We'll use an array. Remember, is an array and is a number. Essentially we'll insert the at the beginning (or the end, wouldn't matter) of the array and at each call of our reduce callback extract it from there - and of course, after the reduce finishes. 

And we need to prepare these new values for the next "iteration" - and return them. You can see that instead of deciding whether to finish or loop again right after changing the , we delegate that to the beginning of the callback. If we had it here instead of at the beginning, we'd do unnecessary (and potentially harmful) changes to the numbers array, because we can't stop the reduce from getting through all the steps. That's a minor disadvantage of this approach - we do some unnecessary work. But we can limit it to just finding out if we actually need to do something or can just return immediately. 

So that's the extraction part. Pretty trivial with CoffeeScript. Next part is little bit trickier. If you're familiar with recursion, you know the base case is usually written before the other parts of recursive function. We'll do something similar - check for your condition before we do anything else. If it's true, it will simply mean that we don't need to do any of that sieving mumbo jumbo, that we're done and just need to wait till we get through all the elements, because we can't stop the reduce function midway. 

By the way, thanks for your question - I see the Sundaram's sieve for the first time. Seems very elegant :) The final code: either copypaste the snippets above or use this gist :) But I sincerely hope you at least read through this and not just use the final thing, because of the time I put into writing the explanations... :D 

MVC is a concept that stems from good OOP practices. It's about seperating your application to three different parts: InputControllers, ProcessingModel and OutputView. What you are describing is the bootstrap page, which, at least from my perspective should not be a class. Here's my approach to this: index.php 

What's wrong with your sanitizing Sanitizing is an important job of the server. It makes sure nothing nasty comes in and affects what your users are seeing/experiencing. Sanitizing is done as late as possible, for a simple reason. When the username is entered to the database, you shouldn't make assumptions on who is going to use that username. It could be your application later on, it could be an API you may or may not choose to provide one day, it could be a desktop application or a mobile application which does not care for HTML formatting. When you extract that value from the database and are about to put it in HTML, that's the point where you should escape for HTML using . Maybe at a different point you may want to output it to a JSON response for an API, in which case, is good, but not as much. 

You should first ask yourself this: Why am I sanitizing input in this way? Let's say I have a login form, and the user enters his credentials, an email and a password. The email will be queried against the database, to figure out the user's hashed password (You are hashing your passwords, right?!), and the password would be hashed, to be compared against that hash. Both of those fields will never be outputted to HTML, the password is never kept in plain-text form for very long, and the username is queried against the database and then discarded. So why should you escape them for HTML? 

What you should be doing when receiving your input, and as early as possible, is validating the input, i.e. making sure the input matched what you expect in format, and in business logic. Format means "This is a valid email address", and business logic means "This comment that the user is trying to edit, really belongs to him". 

And that last snippet the only thing that's specific to your current DOM, so when your DOM changes, you don't need to change all of your code, just the bit that interacts with it. Additional notes for future snippets (just general things I've noticed): 

Note that this way the User has no knowledge of where the data in it came from, could have been files, could have been a session or even a REST api. 

Business rule validation belongs in the Domain Object itself. (i.e. the object directly). While your data-integrity checks should be done by the RDBM. More often than not, the RDBM (which is usually MySQL when talking about PHP) is not capable of doing all of that (which is why moving away to a better RDBM is encouraged), in which case those things also need to happen at the Domain Object level. TL;DR It's the job of the domain object to validate itself. It's the job of the storage manager (the database) to make sure the data is correct from the constraints point of view. The validator class ends up (usually) as a utility class, which is nice to have, but unneeded for an actual project. 

I want to implement a generic method for my ASP MVC application, which gets data from an MS Access database. This is what I have so far, where I am testing it on the object. Access Get 

Site.js Next, add this code to a file, which adds a event for each row in a , which navigates to the value stored in and the id stored in the first column of the row (id). Is there a better way of finding out which row was selected rather than getting the id from the first column? 

After working on this for a while, I think I have improved it quite a bit in that it is now more generic, has a cleaner usage, and is entirely contained in its own file. I still think it can be improved upon, so I am thinking I should ask a new question with the improved code. Usage in document.Ready 

selectTag returns the element for the given tag name in the given area. It would be great if thigs was not needed, but can't find a way of finding the tag using . 

I needed a generic way to display a where I can just click on a row to navigate to that items view instead of having a link in each row. ViewModel.cs First, we need to add a property in the , which contains the columns we want to include in the table as well as the names we want to appear there. This was problematic for me, because I couldn't find a way to pull files declared in each property's attribute onto the (It seems that this feature just doesn't exist). I am also not sure if it is acceptable/advisable to include this type of property in a . Would really appreciate any thoughts on this. 

Once I have completed this I will also look into creating generic Insert, Update etc methods. my main goal here is to just reduce the amount of code in the project, as I currently have a seperate method for each database query. Does anyone have any thoughts or suggestionss on this? Many thanks for taking the time to look! ___________- I initially wanted to implement an containing and , where can inherit from this and store the values inside itself, but I got an error, as the property is of type , and C# does not seem to allow me to assign the output of to this value when I included a . 

TagSelector.js tagAdded This method is called whenever a tag is added to either the selection area or the input area. It basically just finds the required tag with and then calls to add some styling (currently just sets the background colour for colour tags). 

initialiseTagSelector initialises our inputs. One tag area for selection, and one for the inputting through the form. Once initialised, we add our tag selection to the selection area, ignoring any which already exist in the input area (this is to handle page refreshes).