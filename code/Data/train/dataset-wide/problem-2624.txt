Drop the and inheritance of command objects and instead create an that creates a POGO and stores it in the scope. Then in the controller, I pass both the object and the to the layer. Just pass the 3 fields through the scope and don't worry about creating the or an . Instead, every method in the would have an additional 3 arguments for these fields. 

My Question: Do you think this is an appropriate design? I believe the biggest drawback to this is that the is mutable. Brainstorming a few other ways: 

I've implemented the coin change algorithm using Dynamic Programming and Greedy Algorithm w/ backtracking. The description is as follows: 

I used a ´toString()´ because it is for debugging and printing to the screen while I might want to overload in/output operators for real in/output. I dont like so much the ordering of the template parameters, as both the second and the third parameter would make a good fit as the last parameter so it can be ommited on the instantiation. However, I guess there is no better solution than simply choosing one ordering. I have no idea how to provide good initial values. My idea was to use something like , however, it depends too much on the choosen relation whether it should be , or something completely different. Maybe the easiest is let the user choose them when calling the constructor. Aside from its functionaliy, which probably could be achieved with less code and a simple lambda or the like, is there anything inherently broken with this code? Anything obvious that could be improved? Note that this is pre-C++11, but I would also be interested in any post-C++11 stuff. 

I'm integrating with a 3rd party vendor that has and in it. My tool is a user administration tool that allows us to store information in our local database about the and that we manage in the 3rd party vendor. So the and are stored in the 3rd party vendor as well as our database (we act as the middle man sort of). I'm at a crossroads with some ideas and would like to hear what others thought of the following problem and my solution. Before I dive in, we're using Grails 2.4.4 One use case for the tool is creating a . We create the user in the 3rd party vendor via an API call, and then we store information about that user in our database. There are many uses cases like this and there are 3 fields that are always in common between them, an a and an . These 3 fields are required for just about every API call we make to our 3rd party vendor and most of the result in an API call being made. For this reason, I had the idea to make a "Common" with these 3 fields on it that can be extended by another Command Object. 

I needed a timer that fires in intervals for a given duration when e.g. a button is pressed. The button can be pressed several times thus I thought it would be easiest to create a new timer for each button press and the timer destroys itself when its duration passed. I wrote this... Interface: 

I just decided to get a bit more acustomed to using templates. Maybe this is a stupid question, but in my experience in C++ there is always some pitfall lurking aroung the corner. Thus I prefer the danger of embarresment instead of building up on bad habbits. Mainly as an exercise I wrote this: 

Can you use and to read in all of your numbers and operators at once, from a line like or ? matches a regular expression, and is the pattern for any single character. Error Handling: What happens if the user types in a bad operator? If someone tries to ask for , the operation is ignored in this case. Instead of getting the result of = 12, they could get a result of 21 without realizing there was a mistake. A good way to protect against that is to use a statement in your switch block. A way to handle these errors and let the program or the user know there was a mistake is by writing 

However, it is still too slow. There are several points that in principle I could optimize, but for each I have my doubts whether it will bring any benefit: 

...it works, but I wonder if there is an easier way (less code) and it is horribly inflexible. I am a bit stuck when I want to change the code to allow different callbacks (that take different parameters). I first tried a virtual slot as interface. I think it would work somehow, but when inherits , then my inherits twice and I could not get it running. Also if there is anything else that I can/should fix please let me know. 

is never actually changed or used. is functionally equivalent to the loop that you wrote. This is a fairly common pattern, and there are a few ways to go about organizing it. Yours is handy because the variable communicates that this loop will continue until something is 'done'. The best place to explain to the reader how a loop is supposed to terminate is right there in the condition. One more descriptive (but also less clean) way to write that condition would be 

This assigns the operator to and performs the comparison without the need for a statement. You can use a do-while loop to handle the first number and print "Operator: " to the console before reading , if you like. 

Is there anything that comes to your mind to make this more efficient? Is my assumption that the above points are not really worth to change wrong? Please note that this is pre-C++11. 

I am working on a project where the hotspot is some code that is supposed to find an offset, such that the squared differences between a reference vector and a given vector becomes minimal. The core function is this: 

This is called from some minimization routine, that (for now) I dont want to change. It varies the to get the minimum . I know that I could probably do the task faster by using a FFT, but for now I want to see how much I can get out of the current approach. I could already make it faster (roughly x2.5) by adding some memoization: