I know this is a lot to throw at a code review, but this does allow for loose coupling, plus all the functionality is componentized and reusable. Since each class has all of its dependencies as public properties (like the ) it becomes easy to mock up those dependencies for the purpose of unit testing. 

If you couple business rule validations to the domain object, you cannot apply different business rules to the same domain object. Never assume you will only have one set of business rules. By creating validators outside the domain object, you give yourself the flexibility of creating whole different swaths of business rules without touching the domain layer. Basically, by the time you go to save a domain object to a database or other repository it should be completely valid from a business rule AND storage perspective. This allows you to communicate problems to the user in a manor that allows them to correct their mistake. If you let a SQL error propagate up the call stack and result in a 500 Internal Server Error, you as a programmer have not done your due diligence when validating data. Now I could see a case for separating the storage validations from the business rules. Maybe you start out persisting your domain objects in a database, but later you move to a RESTfull web service. The web service may have different basic data validations, which you can then swap out for a different validator while keeping your existing business rule validations. I disagree that this solution doesn't scale. Quite the opposite actually. It scales very well. Mashing your validations into the domain object is what doesn't scale. Changing the storage mechanism or needing to apply different categories of business rules gets complicated when your domain objects validate themselves. Domain objects should be mere boxes containing data. The decision of whether that data is correct is wholly out of scope for the domain object, in my opinion. The storage manager should have absolutely no validations. It should accept a domain object, attempt to persist it and throw an exception if anything goes wrong. 

Maarten Bodewes has said a lot, so instead, I'll focus on smaller pieces. The method uses a StringBuilder, which is great, but you're concatenating two strings inside the StringBuilder method, which ruins the point of using a StringBuilder: 

If you want to read more about Javadoc, I suggest you read this article. The class should not have public fields, but private fields with public getters and setters instead. As for why, you can search online, but this is also a good explanation: Why do we need private variables? If you have any questions, feel free to ask. NOTE I used the name to highlight that the class name should clearly explain what it is. However, I wouldn't personally use that class name and instead, I would use because the keyword is reserved (switch case). 

The name of your class is a generic name, yet it is used for a specific kind of request being that the and parameters are hard coded. I think what you want is a class that encapsulates specific AJAX calls. For this, the Repository Pattern would work well: 

The Ugly Nothing is really ugly here. For that you'd need a helluva lot more Clint Eastwood. Breaking Down Your Application Into Components To really organize your code, you need to break it down into components that focus on one specific task, for example, adding a category. Looking at your code, I can see the following tasks: 

Trying to use JavaScript like a class based language is what you make it. It sounds like someone was expressing an opinion, rather than imperial evidence. As for your implementation, it's very confusing how you'll expect to use the object. Be very careful with mixins or, "multiple inheritance." If you need multiple inheritance, I would argue that you need Composition over inheritance. 

I like to think that one of the most important aspect when trying to write clean code is consistency. If your code is consistent, even if other developers use different conventions, they can get used to it fairly easy because it is consistent. In your case, you have some exceptions that are final, some that aren't. In some places, you leave an extra blank line before of after a block of code, but not everywhere. e.g.: 

And each square looks like a case. Each case contains a value, and a position determined by the row number and the column number of the case, so those 3 parameters will be our fields: 

I can see that you are a beginner - it's a little hard to explain what you should work on, because the path you're taking toward finding the highest value in an array is a little hard to understand. Normally, you'd just need to do something like 

The hardest part of managing HTTP requests is that there are a million ways for these things to die. Any assistance you can give for error handling will be appreciated by all who use this class. 

Your service could get the object for the view model, and then inspect the using class reflection. This could make processing multiple view models easily repeatable with little additional code. 

As an added bonus, adding a new decoration/drawing style becomes trivial. Add a new value in a attribute, and then create a new function using as the name of the function. No need to update . 

If using actual private variables in my class, create get/set properties for those I want accessible to the outside world: 

to find the maximum value of a 2D array (which is the question), but instead, you're returning an object . I can understand where you got the class name idea -- locating a value -- however, it's counter-intuitive. Instead, a class name such as or would be a bit more descriptive due to the fact that the noun location has multiple meanings. I'll show you what I would do to answer the question (finds the largest value in a 2D array), and then, to help you learn, I'll give you some tips on the code you already wrote. As this question is extremely wide, I won't go as far as to explain everything, but I'll give you a few pointers. What I would do This isn't a really complex problem per se, so there's not a lot to explain. Since you want to know the coordinates of the maximum value (column and row), we still need to create a custom class. First, you must determine what the class represents. In this case, it represents an element in a multidimensional array, so like I said earlier, I'll just use something a little bit more intuitive like a . Why is a better name? If you visualize the 2D array, it looks like this: