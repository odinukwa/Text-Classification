I don’t need the dictionary. I can just add the desired primes to a list. In less than 0.11 seconds. Problem 2: List Primes every power of 10 I want to find primes at 1, 10, 100, 1000, etc., up to 100 million. With a simple sieve, this will again take you at least 8 seconds. Yet this takes a blistering 0.015 seconds: 

Call the method that reads and validates inputs Call the method performing calculations based on the validated inputs Call the method performing outputs 

Naming Naming could be better, e.g. in methods without a could simple be . In methods with a and , you could use and as names. Code Changes In , I think this: 

Where it's easy to get lost on and wonder what means (e.g. does it mean last element in the array or last value you worked with), that you could instead have a (or if you insist ) in a variable named and you could use: 

Heslacher's answer had a closing remark about not using in my method. I got a basic implementation working and performance went from 5 seconds down to 0.7. Great suggestion. I then tried to add the new code to Heslacher's answer but an unnamed editor (okay, I'll name the editor: Heslacher) said I should post it as my own answer. Basic Implemention: Requires: 

Which is far less messy. I leave it to you to create method to return the appropriate type. The nice thing with the above is that the code should work whether you return an array or a list. 

This answer would work across midnight across different dates and for DST transitions. Plus it shortens up the code. Shorter and simpler is easier to follow and maintain. 

It’s more DRY, that is adheres to principle of Don’t Repeat Yourself, than code to load each segment, which you had to do to flip between vertical and horizontal lists. It fixes the missing check for distance. But if you examine the next section, it doesn’t seem DRY after all. 

And it should be faster since it uses far fewer , though I leave the testing to you. If it's faster but you are still exceeding your time limit, you now have cleaner code that others could understand better to help with additional performance tweaks. 

This very fast, simple sieve quickly finds 31 bit primes. It uses a memory efficient for odd numbers. How a 32 bit is a 31 bit prime Since a prime number must be > 1, the sign bit has no bearing, leaving 31 bits to store the positive numbers. This differs from which truly would be 32 bit primes. See this Microsoft link on Magic Numbers. If you find the value on that page you will see this text: 

Not Interested In This class uses a and . PERIOD. Don’t bother suggesting that I could perform parallel writes with a . I am not interested in that here. Yet I would be happy to read a new, original thread created by you where you use . Don’t bother suggesting that I could use larger integral types. I am not interested in that here. Yet I would be happy to read a new, original thread created by you where you use , , , or even . The cached counts is a feature that I refuse to remove but am open to improvements. It’s called on-demand, trades-off a small but acceptable amount of memory, and really boosts performance of . Concerns This was my first time to use a function delegate, as well as a custom enumerator. The function is declared in the class, and for the sake of DRY is referenced within the class. Since this was my first time to use either, I don’t know if it’s a proper use or not. is the yin to ‘s yang but since the enumerator doesn’t use it, I have its access as private. Should it stay private or should it be public like it twin ? Usage I tried to make the usage feel natural. Consider: 

What's missing here is the (now deleted) update to your original link. In that brief lived update there were 2 problems not known to others here. One was the stopwatch wasn't being started. The other was the OP wanted help understanding this line: 

You have a clearly stated goal. You want a smaller, more readable loop, if possible. Part of the more readable part of C# is adhering to certain conventions. Things of note: Property names should be Pascal cased with the first letter capitalized, i.e. "Name" instead of "name". Underscores should be reserved as private class-level fields. You reference both o.name and o._name. Either that's a typo or worse, more confusing to someone as to why you have 2 variables so closely named the same. Usually the underscore is reserved for a backing field to a public property. Brackets usually are on their own line without extra indentation. Rare exception: one-liners. Using for declaration where the type becomes obvious. So your 

It's much easier for someone to follow what you mean. And once they can follow that, they will be better positioned to comment on the algorithm. 

Stylistically there is room for improvement. With C# you are encouraged to use meaningful names. Also parameters and variables should begin with a lowercase. That would change this: 

Certainly needs to be a BigInteger to hold . But the constraint is that will be less than . So could be a simple integer, which means there will be no implicit casting in the conditional. So I took your code and tried removing all such implicit castings to BigInteger while making an . I got over 10% improvement. On a side note, local variables should begin with a lowercase letter. 

While this again is slightly faster, slighter cleaner, and recommended in practice, it still lags well behind @vnp 's array solution. UPDATED Worst Case Array I composed a worst case array to test of 100000 items where the very last item is the first duplicate of the 2nd to last item. Your code and mine returned the correct value. 

I did find a spot that could cause problems. The should be changed to keep the declaration for variable before the block but move the initialization using an estimated capacity inside the where the out-of-memory exception is caught. The out-of-memory exception I get with upper limit of is REAL. And note the class does NOT use or . It uses the memory efficient for odd numbers only – and I still get the exception. Yes it’s a lot of code for a simple sieve, which I alluded to in the OP (see 2nd to last paragraph). But this sieve has beneficial features that make it more than simple. Let me clearly state: if you can output the primes to , then you should do so. I whole heartily recommend trying that first. But if you can’t because you get an out-of-memory exception – an ACTUAL one not a theoretical one – then my sieve has some benefits. Upper Limit int.MaxValue There will be over 105 million primes found. Below I present 2 problems to solve when using upper limit . I already know I can’t dump it to a list without getting an exception. So I am forced to iterate over the sieve. Consider this simple serial counter: 

The resulting method also looks cleaner. Someone looking at this understands more readily what the code is trying to achieve: 

But that is only if is a typo. Additional: Besides the confusion over and , I also can't help but wonder is is a typo. This could be easier to read if rather than a one-letter lower-cased property name you refactored to a more meaning name, e.g. or . Or did you intend for it to be simlply ? Futhermore, where does the f come from? Apparently its external to your code snippet. It has no contextual meaning. It should have a fuller, more descriptive name. Following my own suggestions except for , I would expect to see code such as: