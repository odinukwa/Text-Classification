From a memory management point of view, your implementation is a linked list, that is, all items are allocated separately, and the next item is found by following a pointer. As the theoretical advantages of linked lists lie in insertions and deletions from the middle, they don't make for a very good implementation of a stack, where you only really care about adding and removing from one end. Especially here, when you're only storing a single number, the pointer to the next item is likely to be at least as large as the data stored, and that's not counting the space overhead of malloc. (Let alone the time spent on updating malloc's internal bookkeeping.) I would suggest storing the values in a single array, and resizing it with as necessary. Something to the direction of this quick mock-up: 

This means that you're iterating starting from the beginning again and again for every node in the list, i.e. doing \$O(n^2)\$ work, instead of \$O(n)\$ which would be enough for simply iterating over the list. The point of a linked list is that you don't need to know where the end is when you start walking it, and that you can hold valid pointers to the nodes in the middle and do something useful with them. Here, every operation starts from instead. For printing, I'd rather make a loop similar to when you count the nodes: 

Conceptual Framework for Domain Model In your application, there's a rule imposed (via your Drools XML) that there is a fixed set of values to a 's move. My opinion here is that your domain model should reflect that requirement, and seeing as you have generics in your code, your application should also be able to support Java enum. I think it's better to capture this restriction on valid moves by creating an enum called like the following: 

I'm not really sure, but somehow I feel like this can be an instance of a refused bequest, or some sort of breach of contract. I think you have few options here: 

Admittedly, I don't know much about Drools, but guessing from how the rules are defined here, using this class, rules can be defined like (this is not Drools syntax): 

This way, the code structure itself imposes the rule on what values are valid. In addition, by doing this, you won't have to specify the validation rules elsewhere. As for your class, I think that it should be something that captures some form of playing strategy. It can be as simple as one move player like what you have here essentially, or something more complex. The simplest modification I have for this would be to restructure it the following way: 

For a simple routine like this, you could save almost half the source code lines with no lack of readability (but leaving more of the code visible at one time): 

Also, I'd separate the functions of creating a node, and inserting a node at a given point, since there might well be cases where you just want to move a given node from one list to another, and doing a malloc/free pair at that point is a waste. What if the list is empty The funny thing is, that having a pointer that is when the list is empty, seems natural, but it requires always checking if the list is empty. You can see this in that the insertion functions specifically test for , and you have to assign to in the main program after calling them. It also makes adding in the middle a bit difficult, since if the list is empty, you'd need to change the pointer (to point to the newly added item), but if it isn't empty, you don't want to touch at all, for efficiency's sake. A bit of a conundrum, I'd say. One solution would be to make a separate structure for the list in general, which would contain a pointer to the first item, and possibly some metadata about the list. (e.g. it could cache the list size if that is often needed, and a pointer to the last item to make it faster to add at the end.) That has the downside that all additions would require handing out a pointer to the main structure, and the node being operated on. Having no actual nodes would still be a special case, too. Another way is to just demand that the list never be empty(!). This is easiest to do by having a node that contains some invalid value (a sentinel node), something that is skipped by all functions actually handling the data. Sounds like a bit of a waste, though it's just a trivial version of a separate main structure, with the advantage that this time all the structs and pointers would be the same type. (Or rather, build the list functions such that they don't handle empty lists. The application program could of course have a pointer to a list node, that happens to be .) 

This way, you have more control over the internal state of a given class within the context of a given method, while limiting the method's behavior to something that's more specific. It also makes the code a little more traceable in that if there is no requirement that says a completed can go back to being non-completed, you don't have to enable such state transition. I think it's also somehow more "poetic" to have an invocation like compared to . 

Ideally, class should be itself the , but since Drools seem to rely on POJOs and, the constructor for can't be made private, I think this is an acceptable compromise. With this, there probably won't be a need to have separate rule for validating unless there are expected, more complex checking. Also, since the application is checking an external file for values, there isn't a need to recompile or rebuild the code when a new Move like Jedi is introduced into the system. As for the rules on game proper, I'd say they should have been applied to a and not to separate players. The system doesn't even seem to be interested enough in Players to give them names like "Player 1", or "Player 2"; they merely carry a Move in them. A contains 2 objects, each from 2 opponents. The fact that there is a class seems to suggest there should have been a class to begin with. 

This is a bit confusing, since you're testing the date 8 days from now, but printing what the current day is. Why not just test if the starting day is from Monday to Friday, if that's what you mean: . Also, is True for values 2,3,4 and 5, but not for 6, which is probably not what you want. 

As for the code itself, I won't repeat what @Loki stated. But, you're not handling errors fully, a memory allocation error will leave the file opened: 

These should be in the function that draws the circle, as they're part of the logic of drawing, not the circle as an object. 

That's not bad. I like that the input functions actually check the entered input matches the wanted type. Though in some cases a user might like to be able to abort some action at the prompt, so returning or some default value for an empty input might be one choice. The one thing where I succeeded in breaking it was by entering a divisor of zero. 

This has a single move strategy, which is what you set to it upon construction. Structuring the the way you did is, to me, a little weak because the class doesn't seem to be in charge of its own state; it seems to rely on some external component in deciding what to do next. In some way, it can be considered an anemic data model whose only purpose is to carry data instead of representing an abstraction or a concept. Going back to my point about the class representing some playing strategy, we know that, conceptually, there many ways a player can play. What I suggest here is that instead of making a Java class, declare it to be an interface instead, like the following: 

Hopefully the class illustrates my point about classes being in charge of their own state, actions, etc. Lastly, about , I will also say that this class is weak, and overly transparent. My idea is that once a object is created, it will never change. Because of this, I think that should be defined this way: 

Doing extra work in printList The thing that most catches my eye, is that in , you first get the length of the list, then iterate over it, calling on every iteration: 

Though if you really want to be smart, you only need four conversion functions: Celsius to/from Kelvin, and Fahrenheit to/from Kelvin. (or with Celsius on the middle.) Doesn't matter much here, but if you wanted to convert between angstroms, mils, inches, feet, yards, meters, chains, furlongs, miles, light-years and parsecs, you'd appreciate a common "standard" unit to convert from and to. As for the function names, I wouldn't find it sinful to use even something like here, in the case of local helper functions that will not be called from the outside and since the units are so few that there's no place for confusion. (Of course with more units, like the 11 I listed, the latter point would not apply.) 

Calculate the rate the grains are eaten and just divide to get the result? If a pigeon eats 1 grain in t seconds, then it eats 1/t grains per second, and the rates sum. Though this will result in a rounding error at the end, after there are less grains than the number of pigeons (since they don't actually consume partial grains), so you'll have to fix that if you care about the exact result. Another way would be to find the least common multiple of the time intervals, and iterate over time slots of that length (you know they'll eat a whole number of grains in that time). Though with a large number of pigeons or large intervals that will be unwieldy. Just so there's at least something about code review here, I'll just note that technically your code lets the number of grains get smaller than zero, if multiple pigeon try to eat the last grain. Doesn't matter though, since it happens on a single second, but some of the pigeons could mind. Often intervals are also counted downward, it saves one subtraction on every iteration. 

Each move has some seemingly intrinsic characteristics. In particular, each of their name should be lower case Strings, and their values are limited to some given set of words. My impression is that these rules aren't bound to change that much anyway, so why rely on the rules engine to impose them? For one, instead of checking if their names are lower case, why don't we just ensure that they always are? Instead of making it a rule, why not turn it into a basic assumption? 

Hopefully there's a way to make this work both ways. Anyway, I don't expect to get everything correctly here, but I hope somehow I raised interesting points regarding your code structure, and domain design 

My personal view in methods like this is that instead of making them setters/mutators, you turn them into actions/features. So instead of having a that takes a from a client component, I think it would be a bit more sensible to have something like: 

To me, this is a very simple construct that captures the essence of what a Player is: an object that returns a when it s. With interface like this, you can define many different types of Players, like, for instance, one that plays randomly. For example: 

I changed the loop on purpose, I feel putting the test in the statement makes it more readable, since there is only one exit condition anyway. Also, you don't need a separate for , since does the test first. Always starting from head In addition to , the other functions you have, also always take the node. For this is obvious, and you might want an function too that can start from the head. But what about inserting in the middle, in an arbitrary point? The (theoretical) advantage of linked lists is that insertion is \$O(1)\$, and as above, always searching from the beginning thrashes that. So, in the least, you should add a function for inserting after a given node, something like 

For simple squaring, you may want to avoid and instead use just . The former implements a general exponential and may well be slower than a single multiplication. 

Like @Caridorc wrote in their answer, this is always true. But even you meant , why are Monday and Sunday special cases here? 

(Granted, that is not likely to matter much, since if fails your program might not be able to continue anyway. But still.) Make sure to on every error exit after opening the file, either in every single place where you do an early , or by collecting the cleanup code and to a single place.