Imagine a first call to in thread A makes it inside the statement and gets stalled just before executing . Now another thread B calls and successfully gets past ; the writer now has a value different than reader because of the compare/exchange operation. However, the store of an element has not happened yet since thread A is still stalled. What is thread B going to pop? It's going to access whatever garbage memory is at that location. Issue #2: Malfunctioning empty function The load from and the load from followed by a comparison is not thread safe. 

To indicate that the first three files have been processed. You would then only have to check the first character of every line you read, instead of the whole file name, to know which files have been processed. This is the technique I would personally use, as it doesn't require an extra file and it keeps the original file mostly intact while providing a much faster comparison. 

1. Description 1.1. Functionality The objective of these types is to provide type erasure for any function while maintaining the ability to provide a return value through a combination of and its associated . 1.2. Motivation This is useful for any sort of dispatch manager, a thread pool that you can submit tasks to being the actual target; where a task is any function with any parameters and return type. 2. Implementation 2.1. deferred_invoker.h This is the main functionality. Type erasure is provided through the base class, which simply has a virtual member function that is called when the function has to be invoked. The specializations will then know how to deal with the invocation and whether they have to save a result. They also take care of ensuring the correct initialization arguments required for the call are initialized and saved in a tuple. This applies for template parameter which is any function. A simple tag dispatch system takes care of return types. I've omitted a third implementation of for lambda and functor types to focus the review. It's basically the same style as the other two (possible design issue?), but it takes a copy of the lambda/functor and the arguments, instead of a pointer to the function. 

I'm not a fan of your idea. I would prefer you store and filter out items on the Function prototype as follows: 

I'm not a minifier but theres no good reason to do Counter proposal: I believe you should drop the arity requirement and drop the global - instead inform the user they should cache the original locally. I've rewritten the code with these considerations in mind. Here's a jsbin with these changes (note I haven't removed the global to respect your test cases): 

Anyway, you are correct in that calling these loop methods will take time per call and it's a good idea to apply filters first to limit . If you're looking for an interesting read take a look at the Lazy.js documentation. Edit, just noticed, because you mention reduce, the way you'd write this with reduce is akin to you way 

Along with @jerrycoffin and @RobertoBonvallet's suggestions, I would write this as a loop 10 times out of 10 (this is the conventional for loop case afterall). I tend to use loops whenever I'm iterating every item of a single collection and a loop for any other purpose (but either can always be written as the other so w/e floats your boat). I would also probably cache the result of and if I were using anywhere else in the loop I would probably make a variable for it as well. I usually consider using a if I use 3 or more so if you extend further that may be something to consider Also is a cryptic name for a loop control variable. Use , or - don't worry about variable name length as you'll usually end up minifying your code if you're writing anything substantial. That said 

Consider what happens if returns value A, but before the expression is evaluated, is changed to some other value B. This could cause to say that the queue is empty when it isn't or that it isn't when it actually is. Conclusion These are two of many issues that are currently in your code. I've decided to stop here since that's a pretty bad problem. This current implementation if not safe at all. I recommend you do some more reading and learning about thread interaction. Good luck. 

Specialization for special types You can also provide a way to read whole lines through template specialization or through a different function, since it would be useful for strings (reading a phrase, for example). More functionality You can provide a way to obtain values based on a predicate. So that it can be a lot easier for people to get valid values. For example, I want to get easy input of an integer that is between 0 and 10 from an user. Example 

3.2. Example 2 This example displays a more "real-world" use. Instead of having the function call , that would be done by threads consuming from the data member. Since this is an example, I've provided a simple function that works only for free functions; overloads can easily be added to deal with functors and member functions. 

The way I would do this with the current iteration of (1.6) would be through reduce. Note use if you want to favour items to the left 

Your loops are not equivalent. In the first one will be mapped with some action, while in the second you could do that just using a filter. The equivalent way of writing the loop would be to use . Of course you would cache it as you use earlier in the function. The equivalent way of writing your loop with just would be 

I would probably add a class/something to use as a selector (in this case I added ) to make lookup easier. You can do this in other ways such as getting the values of the actors map so do it as you will. Also your case is calling on a string as is the current contents of whatever the event is hooked to. 

Some key things to notice - see that its checking backwards, that will improve speed for near sorted collections. You can use instead of the while loop -- thats the difference between the and implementations. You can write the while loop as below if ya prefer 

Notes A faster way to check if a file has been processed would be to add a character indicating that it has been processed, for example: 

Basic algorithm Since you have very large files, you should consider streaming the file one line at a time instead of loading them all once; your program would use a lot less memory. You would also not have to copy your , which is very large! In order to know which files you've already processed, you could create a new file that holds a list of all the files you've processed and write to it as you stream from the original file. This is of course, assuming you want to keep the original file intact. I will continue under this assumption as the other case (simply delete from the list as items are processed) is simpler. Check the Notes section for a better idea that you can implement with inspiration from the following section. Implementation The following is a sample implementation for the algorithm I described in the previous section. For brevity's sake, I did not include the items mentioned under the Form section, nor did I include exception checking; I will leave those things for you to figure out. It is also most likely not as optimal as it should be, but it's merely meant to show you streaming. Sample 

Spent a little hacking away at this to simplify the code. I wrote comments on changes inline the script, let me know if you have any questions Some thoughts on the changes. Notice that how I restructured your validators in the form 

No need to check if the variables are . A dates value is its time so when you make (less than/greater than) comparisons with a Date instance () you're essentially comparing it to or which will be the same as . Therefore the below will always be equivalent: 

Alright I'm going to focus on some potential errors with your function. The first obvious issue is you're relying on being set. This isn't always the case - for instance consider any class declared . Now if you run . Furthermore, many frameworks provide some class extension/constructs such as which would invalidate that check. Further issues may present themselves with code minification. Out of curiosity, I decided to plug your code into the underscore js test suite to see how it would do. I couldn't implement as it accepts multiple types as objects. It passes all the tests but the ones for understandably. I excluded the tests as I couldn't get them working on gists or jsbin but they pass as well. Not bad :)! 

You can expand on this by providing functions that use the "Error hiding pattern". That is that they return a to indicate whether the input operation succeeded or not, while the result is stored in a reference parameter. Other isn't the only object that can be streamed from. For example, you can also stream from files. You should provide a way for users of your function to specify what they want to stream from (this can be as simple as having a parameter. 

Welcome to Code Review. This queue implementation is not truly concurrent-ready. Arbitrary initial capacity 

2.2. function_traits.h These are simple template class specializations that provide the required function traits for the implementation of . I realize that specializations for and functions are required. 

What this means is that when the comparison fails, E is updated to the current value of X. If the comparison succeeds, X is updated with the value of N. Therefore, you don't need to update X again! That is the whole point of a compare/exchange operation; you're basically saying: "I was the last to modify X." Issue #1: Unsynchronized access to writer In your code, you perform a store to the atomic variable with a copy of a value you last obtained from the update performed in the compare/exchange operation, but this is not atomic. 

To answer the actual question OP seems to be posing -- the pattern is fine I wouldn't change it but I would expose whatever you want to expose explicitly into a namespace using this format (window or whatever namespace): 

Here's the most elegant way I can think of writing this. I use to handle both Arrays and Objects as your tests showed you wanted to support them, though as pointed out in comments your code didn't. These changes also allow you to use more than 2 pick properties () as you can with the normal /. For 3 and 1.8? you'll need to change to the rest of the code should remain the same. 

I'm biased here, but as a past Mootools developer I keep comparing your function with Class.refactor. Personally I would prefer you add a reference to the original function on - maybe as some property or let the user handle storing the original. I'm not a fan of adding a global for the original function. A question, why do you not pass to your constructors? If you're wrapping some classes this seems like it may make usuage less intuitive. Update (still at work and can't look into removing the approach yet but I think I found a great change... You can rewrite the extremely confusing like this (unit tests passing): 

3. Sample usage Here's some sample usage to show how a user can get the return values. Basically, the user would send in their function/functor to the dispatcher and would take care of the rest; the dispatcher would return the from its submit-a-function function. 3.1. Example 1 This example is pretty much just a test of the template deduction rules and shows how you can use a collection to erase types. The main feature is that you can have a collection of functions that all have different signatures and return types. 

Why have you decided that the default size should be 100? Different people have different needs; having default values like this isn't a good idea because there is no true advantage to having a default size of 100. While this is subjective, I suggest you remove that default size and just have users be required to specify the size that they want. Compare/exchange confusion There seems to be a misunderstanding in regards to the use of compare/exchange. The compare/exchange operations work as follows: 

I've actually implemented the same functionality in the past, so here are my comments. Wrong behaviour? It depends on what you can consider wrong. Consider running your own example and inputting . The 2nd will be left in the stream buffer and will be automatically assigned to your 2nd variable. This clearly causes weird behaviour, but it is the same behaviour that occurs when normally using . Suggestions The following are what I consider to be useful features for such an utility function. Better interface In order to provide a nicer interface, you could instead read a single value from your stream and then discard anything else that's been left in the stream buffer; calls to will always return one single value and successive calls won't be forced to take what's left in the stream buffer. Example