Can my solution be improved? Are there any C++11 or C++14 features I forgot to use that would improve it (I'm compiling with Visual Studio 2017)? Is the name for the container a good choice or is it too similar to the objects it contains? Also, I've made the constructor private and deleted the copy constructor to try to make sure only a can construct a and nothing can copy one -- are there any other ways to construct or copy a that I've missed? Is it a good idea to prevent construction/copies or is it unnecessarily restrictive? 

Not only is this an opportunity to refactor that code into a function, but the numbers and (arguments to here) appear multiple times in your code with the same purpose. Instead, define a constant (e.g. ) and use that constant. This means that if you ever want to change that value you'd only have to change the value of that constant once (the value of the ) instead of trying to find the literal all over your program. Use meaningful comments Your functions are commented as so: 

That code required me to re-invent the wheel a bit since I was using an old compiler, and I had not discovered / yet. I've re-written that code to use a single class template called , C++11 and C++14 features, and or . I've also included some additional utilities (inserting a into a , clamping values, computing spec limits based on a value and a % tolerance, etc.). I have not added yet support for guardbands as in the previous implementation, but I plan to do so later. Here is the implementation using . My compiler is Visual Studio 2017 (which can use C++17's ), but I'm only using C++14 features in the project this will be used in. I've provided commented-out code below to use instead: 

While it's a good idea to provide documentation on the parameters for your functions, these comments as is are not helpful. They just take up space and are distracting -- after all, I can see the names of the parameters just a few lines below the comments. Instead of simply listing the parameter name, provide some explanation of what values it is allowed to take (e.g. should be between 1 and 12, inclusive), what happens if the parameter value is not valid, etc. 

I've developed a set of functions to convert a or to a or insert it into a using . They are intended to be part of a larger library of conversion functions so I've included a few additional functions in the library for demonstration. There are two versions of each function: the normal one in the namespace, and one that uses a compact form of a string in the namespace. For example, the ratio is normally converted to the string and its compact form is . Not all conversions have a compact form, so in those cases the functions in simply call their counterparts in . Conversions of s take advantage of the conversions for s if the period ratio matches a typedef provided by the standard library. Similarly, proper conversions are implemented for period ratios which match a typedef provided by the standard library (e.g. and ). Here is the header file of functions, convert.h: 

Obviously, I can't quote the whole section here, and if you disagree with his opinion, I'd advise familiarising yourself with the rest of his argument before posting a reply. He goes into greater detail over the next 3-4 pages which I can't summarise here because he has already written the appropriate amount of text on the subject. I do reference his ideas in the following paragraphs which is again why I recommend being familiar with his full opinion before replying. In the class with the constructor, it's not obvious what order the parameters should go in (no natural ordering - page 42). You can't give a hint to the programmer with the method's name because it's the constructor, which should succinctly describe the object, not the order of its construction parameters (encode the names of the arguments into the function name - page 43). With the constructor, an error will occur when the object is created if there are too few parameters. With the setters, an error will still occur later if each property is not set correctly, which is also the case for the constructor, so no clear advantage either way. Some IDEs will warn the programmer if the method signature doesn't match, while they can't warn about missing setters. The parameters in this case can't be combined into an sensible object, because PathGenerator is the sensible object! , & don't have a logical grouping (reduce the number of arguments by creating objects out of them - page 43). The class with the setters seems like a lot of work. It also seems too easy to miss one of the setters before trying to get it to do some work. However, reading the code that uses the setter class, it's obvious what it does, much more so than the large constructor version! The third option, passing in a object/array, as I've seen recommended elsewhere, seems to combine the worst of both styles: extra work is needed to construct the object and it's easy to miss a parameter. My goal is that the code should be easy to maintain (therefore also easy to understand) and easy to use. Which of the two styles is cleaner? 

I don't have access to the httpd.conf file on the hosted server. The .htaccess file is below. It sets to the directory the .htaccess file is in, making it the "virtual" web root. It also sets and which are the bits before and after where the would be in the URL if it hadn't been taken out. For example: The .htaccess file is in . There is an index.php file in and another one in . When the above URL is requested the script in will get executed. PHP will have access to three additional fields in : , & . It seems to behave properly. Can the code/rules be simplified? Am I using any unnecessary flags? Have I missed any flags that would really help? Is there a better way of serving the final matched file other than setting and testing for it in the next iteration? 

I also don't see why there's a callback passed to ? There's no async operation and the callback is executed at the end of the function with no args so the caller could just put that same code right after the call. There doesn't seem to be any reason for a callback argument. 

FYI, if speed is really your goal here, recursion is not the fastest way to do this (because functions calls are kind of slow in javascript), particularly if you don't have much or any local state in the function so you could just use a loop of sorts. 

There are problems with your readFile and writeFile functions. These functions are asynchronous. As such, the callbacks you pass to and to are called some time in the future, long after and have already returned and finished executing. As such, the return value you have in those callbacks just returns back into the bowels of the file I/O sub-system and does not go back to any of your code. So, as you have the code written, you have these problems: 

Cache since it doesn't change. Make your comparison be because you may never get . Use a larger pixel increment until you get close, then step down to a smaller increment 

Wrapping an existing promise with a manually created promise is a promise anti-pattern and should not be done. Instead, you should just return the promise you already have. If you're going to use more than one async operation and thus find you want to use rather than chain your promises with , then you can do that like this: 

FYI, when looking at the Parse documentation, looks like it also returns a promise and looks like it has a method (not sure if that needs to be called). 

FYI, I also find this a LOT easier to follow what's actually happening than the code you have. It also saves several comparisons on the value. 

because there should only ever be one item in the entire document so if that was the case, you could just do this: 

In modern versions of node.js (v6.0 or v4.x in strict mode) or when using an ES6 transpiler, you can use the ES6 keyword: 

You're doing a 200ms interval on a 400ms animation or a 200ms interval on a 700ms animation. That sounds like you're asking for trouble and won't visually get what you want with two/three animations competing at the same time. You probably don't want to be recalculating the selectors every time your setInterval gets called as that's a lot of wasted CPU multiple times per second. Calculate them once before you start the setInterval and use that result. should be changed to in this code as should only be used if you're saving a reference to the removed items and reusing them later. Otherwise, does a better job cleaning up jQuery stuff and I assume you probably want to only clean up the item you are no longer hovering over: