Now, this puts the responsibility of creating complete valid s on the client class. If you want to be able to verify that the new s has all mandatory properties at the time of instance creation, you can utilize the Builder pattern and have the method validate that all properties were assigned: 

Design As was mentioned in the bugs section, the design of the ATM requires that you create a new ATM instance for every customer. In order to fix this, let us imagine how a real ATM probably works: One ATM machine can serve customers from multiple banks. When a customer enters the card and a PIN number, the ATM identifies the bank and sends these details to it. The Bank holds the list of its customers and is responsible for authenticating them. After the authentication process is over, the ATM will get a instance. The ATM will use this instance to do the balance queries and modifications. At the end of the process, when the customer gets his/her credit card back, the ATM machine should send the object back to the bank so it can update its internal records. Translating this into OO design. We have the following Classes: a class much like the one you have. a class that holds a (or any other collection/data structure) of s. The exposes a and methods. the also does the authentication. the ATM class gets a (or any other collection/data structure) of s in the constructor and should be able to identify the bank from the customer's account number. We can say that the first two digits are the bank ID. this design is both robust and modular. It allows each bank to do their own book keeping, customer authorization etc. If this looks like an overkill, then You can say that the ATM handles customers from one bank (make sure to mention this in a comment so it is known that you didn't omit this considearion). In this case, an ATM should maintain the customers list (probably get the list in the constructor). Best Practices 

EDIT #2 good pointer to the function. I was able to find the ultimate chain of functions that eliminates all if conditions! 

Here are my comments, in order of severity: Bugs (or bug-like behavior) 1) resource leaks: You do not close any of the IO resources that you use (DB connection and various s you open on the input file). unclosed resources (aka leaks) leave JVM- or OS- level handlers open behind. even if you use DB connection pool (I hope you did, did you?), you have to close the connection to return it to the pool. Use Java 7 try-with-resources feature to optimally handle the life cycle of IO resources Note: is also a closeable resource. 2) SQL injection vulnerability: when you insert data with SQL INSERT statement Do not embed the values in the statement. Use bind variables. 3) redundant instance creation: the third statement in creates an instance of . since the method is non static, you already have an instance of : . use it. Performance 1) parsing the input file: You parse the input file twice (and create two unclosed s). 'nough said. 2) redundant size calculation: if you already took the trouble to calculate and put it in an int variable , why do you keep calling the method in further processing? Design 1) Extensibility: When you decide that accepts argument, you limit the usefulness of the method to very specific input type. However, the processing of does not rely on any specific feature of and can operate on any . is more general purpose interface than so you will be able to use the same for other scenarios. if you want to save the client the trouble of converting to you can offer an overloaded variation of the method 

"Main work was the instance-version of parse()" I am guessing that this means the non static method. it contains 4 lines of code. out of 140 lines posted, that is very little "Main work"... like it was said in the comments, it is not clear what code is yours and what was given. So I restricted my comments to the non static method in class: 

TreeNode.java 1) where is equals() You put child s in a but did not implement . Even if you meant that instances are equal if the references point to the same object, you should state this explicitly and not rely on the default implemetnation in - it may change in future (or past) versions of the JRE. As a rule of thumb, should always be explicitly implemented if instances of the class are put in a Collection (any collection as all implement some kind of query but especially in a that implies concept of uniqeness) 2) null initialized instance variables I see two problems with this: one is of performance: you are quering if the set is null every time a child is added and every time the view is requested. The second bigger problem is that this code is not thread safe. multiple threads that will try to add the first child to the same node can override each other's operation. The easiest solution is to initialise the instance variable in 's constructor. You were probably trying to implement a lazy initialization DP, but what did you save? creating an empty ? that is hardly a costly operation both in performance or memory terms. now, is a different story. if I understand correctly, this is needed only when a view is requested (i.e. in ) so why create an instance when a child is added? TreeNodeChildrenView.java At first I was buffled as to why you created this feature. I think I understand that you wanted to do some validation checks when a client adds or removes child nodes. However, you already have an in so why not add all other methods there? (you can even have an overloaded version of that accepts arg) seems more natural place to me. Regarding the class itself: 1) add parameterized generic Insted of implementing interface, I would improve on it by adding the missing generics to the methods. instead of go for and let the compiler ensure type safety 2) inner class should be moved to be an inner non-static class of . IMO - a perfect fit for this case - every instance of the view lives only within the scope of a (non-null!) instance from the enclosing class. 

Here are my comments: 1) In the first version of the consumer, you compared the enum values correctly. However, in the edited version you suddenly decided to use the names for comparison. This is simply wrong. First, you have the popular bug of using instead of in several places. Second, using enum values allows the compiler to check you didn't mistype "EQUALS" in one of the (many) places you typed it. 2) Your expression picking logic in is overly complex and confusing in my eyes. You pick an expression based on condition and action. this results in the confusing situation of returning when the condition is . A better approach would be to ignore the action during expression picking. this way, the connection between the filter's and the type of is simpler and straightforward. The consumer gets the result of the s evaluation, then queries the action and simply reverse the answer accordingly. now, while we are talking about expression picking: your current logic goes though great length to enforce the assumption that "lesser then" is the opposite of "greater then" - so why did you write both expressions? you can write just one of them (for example "lesser then") and then in "greater then"'s method call of "lesser then" and return opposite value. 3) regarding responsibilities: if holds the condition (and action) why not let it pick the expression? moreover, if we do decide that a is all that is needed, why not let the enum itself pick the expression? 4) regarding the s: the can be simplified: 

Declare variables in the smallest scope In addition, you have all your variables declared in the beginning of the one method you have. Some of these are used in particular places only. For example, is only used when is used. another OO paradigm rule says that variables should be declared inside the smallest scope that they are used. why? 1) it makes for easier reading of the code when one knows where a variable is used and where it is not. 2) it makes for safer modifications in the variable 3) sometimes you can use the same name on different local variables instead of having / and so on: 

Advantages: 1.1) no need to take care of thread synchronization. You are guaranteed to have a single instance by the class loading mechanism (actually, you will have one instance per class loader, but assuming you use the JVM system class loader, this will work just fine) 1.2) you can make the variable ensuring it is not ever modified. in fact, you don't need a method at all. the static variable can be declared public. How's that for simplicity. Disdvantages: 1.1) static constructor cannot receive an argument. You will need to obtain a by other means. read a file from the file system? 1.2) This is an eager initialization that will take place when the class is first accessed. Assuming the program will access that class when you need to access the singleton cache store, this seems reasonable. Also, judging from the code, the initialization creates an empty cache store, so it seems a low overhead. 1.3) static constructor cannot throw an exception. You need to catch and log it in the constructor otherwise it gets lost. 2) use enum enum values are in fact static singleton instances of the enum class! a perfect fit! 

this is much better. you might consider breaking the above statement to two lines for further clarity. 3) String joining: Java 8 stream api can (and should) be used in almost all the places where a loop used to be. This is especially true with String-joining loops. For example, the entire loop that is used in the building of the SQL statement can be replaced by one line: 

the operator in startX index (adding and substracting 1) the team compared against - it is the opposite team of 

The best solution for that is to create a Java enum type to host all the choices. However, if you are not yet familiar with this construct, you can replace the constant literals with constant variables. These are static final variables that effectively become literals 

(this is following the performance advice regarding processing of sinlge lines) and you wil have several implementations like 

since you requested to focus on effeciency only, I will do just that, although there is a lot to be said about the quality of the code. first of all, why do you split the line on white space only? what if there is a tab between the words? you should use the predefined class which includes all white space characters (incl' tab, new line, and more) secondly, you do the split into an array, then add the items one-by-one into a list and then search the list using why not use the loop on the array to compare its items to and just increase a counter? this saves the loop inside (for sure there is one) and also does not require to load all words of a file into memory EDIT following the comment below: if you need to update the file, there is still no reason to load the words into list. for one, in the list you lose the separation to lines so you will write just one line to the new file? second, why not read one line, process it (either count or make a new modified line) and write the modified line to the output? (modifying a file inline is not recomended!) regarind code quality, you process a single file separate from processing directory. but processing directory is processing single files in that directory so why not put processing of single file in a separate method and then you can call it for process a single file or in a loop for files in the directory 

3) Design This last comment falls into "best practice" category: the method does too many unrelated tasks: receive input from user, file handling and main loop. if, for example, you have a separate method that is responsible for communicating with the user, receiving user input and validating it, then perhaps you would be able to check for existence of input file as part of validation... then again, one method for receiving user input and validating it? hmm maybe we can design further break down ... 

Java has a method. why is it better to use that than quering the size? because you might choose to replace with another Collection implementation, one that implements differently. in the method I would prefer to call 's method since it saves the doubt where adds the new item. 

I can suggest you use common table expression (Oracle calls it "Subquery Factoring") at the very least you will be doing the filtering by date and name one time only 

Break code into smaller enclosed pieces The code may be fairly simple but it doesn't look so. it is hard to follow the logic of such long, meandering code. They have a name for such code: "spaghetti" code because with all the flow paths in one place, it reminds of spaghetti noodles that are entangled together in a mess. In order to clarify and organize, you should separate this into smaller pieces of code that do small enclosed tasks and put these in separate methods. This process can (and should) be iterated, braking the smaller pieces into even smaller ones, for the sole purple of clarity and brevity. it is not uncommon to see methods containing just one line of code. Break code into reuseable pieces Another motivation for breaking up long code into smaller pieces is reuseability. The game consists of asking 13 questions. the process that needs to be done in each question is identical: present the question, get the answer, validate it, check if it is correct, offer remaining lifelines, etc etc . all that changes is the contents: the text of the question and possible answers. So instead of asking 13 times and nearly duplicating the code inside the if statements, create a method that handles the process of asking a question and getting the answer . the method should receive the "changing" part of the code: the text of the question, what is the correct answer, and perhaps few more pieces of data. Organize your Data So far, I mentioned programming rules that are universal to every paradigm and are considered "common sense" in the sense that all they demand is to be clear and organized. Now I will talk about a rule that is part of Object Oriented paradigm: data encapsulation . Let us consider the concept of a question: it has the following properties: question text, 4 possible answers, one of which is the correct one. at the beginning of processing of a question, all possible answers are displayed, but during the processing, some of them should be "hidden" (due to usage of lifelines) so perhaps it is a good idea to add a property to each answer. so according to the data encapsulation rule, the concept of a should be a separate class that holds the relevant properties and is also responsible for doing the tasks that involve accessing and modifying the properties. only the methods of a class should directly access the properties. why? because you may decide to put the question and answer text in a file, or you may decide to support other languages... the idea is that the data may change, and when the data is encapsulated in one class, you know you need to change only that class. So a class should have a instance variable and a method that returns the text. it may contains just but like we said, you have one place which is responsible for reading the question text, and that allows for fexibility of future changes. So, based on all the above, Here is a suggestion for high level break up of code into methods: 

When I encounter similar cases, I use the Apache Commons Lang library. It has a class with all sorts of useful String utilities. For null-safe check if a String is not all whitespaces, you can use the following: