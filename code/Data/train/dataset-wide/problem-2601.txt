This saves all those methods in the class instance variable . One could then use the earlier approach to make the validity checks that draw only on the information in , and cycle through to perform the others: 

It takes a couple of seconds to generate the hash, then each random string takes very little time to generate. [Edit: Flambino pointed out that it makes more sense to use an array: 

It can be inferred (and easily proved by induction) that after rearrangements, if ball has not yet been fixed in its final position, it will be at offset: 

You may wish to consider writing this as follows: First obtain the number of months per billing period: 

Your first question was answered nicely by @sockmonk. You could have written , which, though longer, is arguably clearer. Regarding the second question, I suppose that's a matter of individual preference, but I am happy to use a ternary operator when it fits comfortably on one line. One reason is that it reads fasters than an clause or statement, as we humans have greater experience reading horizontally than vertically. @200_success makes an important point in his comment on the question. For the example he gave: 

where is one member of the hash and is another, but since we are sorting on the keys, and do not use the values and , we can replace the latter with underscores. We could have done this differently, using without a block, had we used instead of for the key for directories without trailing numbers, and chosen so that it was larger than any of the other keys. This is one way to do that: 

This is made possible by Player and Referee They are not both classes, as you can see in the code above. Here is 

Because you call you are actually getting a much larger array than what you start out with. Don't you mean to partition the array collection by pairs, rather than taking all elements of the array and getting every combination of possible pairs? Instead of dealing with 4k pairs, you are dealing with almost 32 million pais. Your method name suggests that you will return pairs from a given array, but it returns an integer. The name doesn't convey the idea of the methods return. This makes it more difficult to understand the intent of your method, even with the code. 

Given that on some file systems a directory is simply a File with special attributes (or to put it another way a specialized file), does it really matter? Unlink it if it can be unlinked if that is what you want to do. If it can't be unlinked, why would you bother? And why would you care what it is? If you care what it is, then use If the inode can be unlinked, unlink it. 

Though I would probably do away with the variable named result, this would be a clean way to do this. In other words, regarding the variable assignment, don't conditionally assign a variable through all conditional paths. Just assign it the result of the condition one time. 

Again, the block is not used because does not have a key . The third element of is passed to the block: 

Enter market on day 1 Now suppose we enter the market on day 1. We could compute a new net_gain array: 

Edit: In view of @Tokland's suggestion of constructing a set of prepositions when processing the words one at a time, I thought it might be interesting to run some benchmarks. You'll see that I just used random arrays and words, rather than read and write to files. 

is shorthand for , so if is undefined (), as it is here, causes ; if is already defined as an array (so is neither nor ), is not considered. Alternatively (as @Nat mentioned), we could substitute for following . Next, is assigned the value . We compute 

It remains to construct the method to return an array similar to above. As I've rambled on awhile, I'll leave it to others to cover that. 

but only a fraction of these are shown in the documentation. Perhaps a reader could provide an explanation. In any event, the two methods I mentioned are used as follows (when applied to @Ben's example): 

The latter solution is relatively inefficient, as we make three passes through the unsorted list each time we move one or more values from the unsorted to the sorted list. That's mainly because I wanted to illustrate how the sort could be done without using indices. This is a sort of "fake" recursion, because it doesn't exploit the power of recursion; we could have simply put the code that transfers the in a loop. I don't see how recursion can be used to advantage here. 

I have the following python code which implements a simple neural network (two inputs, one hidden layer with 2 neurons, and one output) with a sigmoid activation function to learn a XOR gate. The code runs fine (ie no syntax errors or runtime errors or anything) and I have it plotting error over time to visualize its progress. I have tested it piece by piece; I know the feedforward works correctly as I tried hardcoding in weights and feeding it through and it gave the expected results, and while I didn't have the patience to backpropagate errors for the entire network by hand, I worked out the errors on the output and one of the hidden layer nodes and got similar numbers to the code. However, when I try to train it on the 4 test cases I have cyclically, the network consistently converges to . I've tried changing various parameters (, , , etc.) but to no avail. I even tried replacing the function with for the activation but that didn't change the results either. I've used in some places to make the matrix/vector math cleaner. I would greatly appreciate any suggestions on how I can improve my code, as well as what could be causing my problem. 

Suppose, for example, and are to have and tuples, respectively, and in cases, the first element of a tuple in matches the first element of a tuple in . Thus tuples in have no match in and tuples in have no match in . Then 

For this example value of , this is what's happening: First save each coeffient's index with its value: 

The third element of () shows that the eastbound car in that position is being followed by one other eastbound car. The fourth element () indicates that the westbound car in that position will pass two eastbound cars. 

To see where each search terminated, divide by , round up and subtract . For example, for , this would be: 

As you have not indicated whether you are looking for a quick and dirty--possibly one-off--solution, or production code, and have said nothing of file size, I decided to suggest something you could employ for the former purpose, when the file is not humongous (because I read it all into a string): 

[Edit: I'm not happy with my solution after reflecting on it. Constructing the array is wasteful, as one can just maintain a running count, as others have done.] Here's a slightly different way of looking at it. Let be a car position, west to east. First compute an array , such that: 

I have which declares a single method; the following classes implement : : represents code that assigns a value to a variable 

subclasses and implements the specific syntax of [math_expr] GT|LT|EQ [math_expr] which is not covered by : 

Then instead of at each iteration, just add to that set; this ensures that it is unique. Or if you want to print it right away, do something like this instead of the 

: Represents an expression that evaluates to a single value. This is an abstract class, and is subclassed by and which differ only in the operators implemented in the overridden method. 

The codebase itself consists of 22 classes which is a ridiculous number to copy/paste into here, so I figured I'd just share the relevant/important ones and then provide a quick description of the others. If code from the other classes is relevant, I can edit this to include them. Without further ado, here is the tokenizer class (): 

I am following good programming practice (I'm not new at Java but its been a while and I usually code in python so I am likely to miss idiomatic ways of doing things) My class design/structure is appropriate and (more importantly) easily extensible if I want to add more features somewhere down the line I'm handling the actual logic (tokenizing, parsing, building syntax trees, etc.) the correct way. My interpreter works right now for what it is supposed to do, but I want to make sure I am doing things the right way so that in the future it is easy for me to expand it. 

There are two cases to consider, depending on whether is even or odd. The easier of the two is when it is odd. Suppose, for example, and , so and is odd. In this case the range can be divided into and . Let be the array that will hold the products. When calculating: 

This alternate calculation of is not especially interesting in itself, but note that can be computed: 

Assuming you can use Ruby's standard library, there's no reason to reinvent the wheel. What you need is contained in the module OpenSSL::BN, namely, the methods OpenSSL::BN#to_bn and . I can't find documentation for the latter method (or for other instance methods in that module). Note: 

[Edit: a couple of days ago an anonymous user proposed an edit that was rejected by two members, both on the grounds that "the edit deviates from the original intent of the post." While I'm sure those members had good intentions, neither appears to have experience with Ruby, so I don't understand how they were able to arrive at that conclusion. The anonymous user was not just improving my code, he or she was correcting an error I made. It was a good catch and a good fix. I've edited to incorporate the fix (and made a few other small changes). If you are that anonymous user, please accept my thanks. A small suggestion: it probably would have been better if you had just left a comment, but the main thing is that the code is now fixed. (I hope.)] 

You asked if you should set up an array to keep track of things. I find math is sometimes much easier to keep a count of things. I do so in the code below. I have set this up with the following (somewhat standard) folder structure: 

As you move other things out of the more of the game mechanics may be managed by the Referee module. There is still a lot of work to do in these files, and you will rearrange things as they make sense to you. I spent just a few minutes on it this afternoon, but I hope it helps. 

You require pry, and you don't seem to use it. Perhaps it is being used for troubleshooting, and the or other code, has been removed. In that case it may be more appropriate to simply use the option as in . Then you don't have to remember to remove that line, just the troubleshooting line. (Or even better, set up a system that lets you leave things in but turn them off and on from an option in the system call. Perhaps -w or -v flags. Perhaps an environment variable. A line in with this in mind may look like this: And a ) Looking at your tells me that you have an infinite loop. But you have a well defined exit strategy, there is no need for an infinite loop. Using something like will run the block at least once, and will stop when your method returns true/truthy value. You also call 'play' from inside the loop inside of play, but it is already going to start from the beginning of the loop. If you had folders , , I would expect some of the code in your file to be in maybe . The equivalent for sure. This will allow you to use the file in a way that someone that requires that library would expect. Right now, you are unable to require that library file without starting the game. The interface of using words like seems clumsy and error prone, even if it is nice. Creating a numbered or lettered menu or presenting the grid with numbers or letters could make play easier, less typing to do, less error prone. Perhaps a lettered 'x, y' grid. Presenting that grid would also document the game play, and make initial play more straight forward. Your "choose_character" method does two things, it prompts and processes the choice. The @player_character and @computer_character is repetitive, confusing in a way. Simply having @player and @computer is probably clear enough. @player.character might be better, though I think we consider that letter a 'marker', as the player mark may be 'X' and the AI mark may be 'O'. Looking at you could be using the new named arguments in Ruby 2.0. In the Board file you can likely use the Enumerable method, if an array has the markers that match the current players marker, then that player is the winner. 

creates an array of separators that is passed as the argument in when the middle name or initial is to be included. Each element of that array is the (string) value of bracketed by a separator (except in one case where the initial is converted to (). For example, 

I don't know if you really need to create classes for checking each of the substrings in the file name prefix. After all, there are only two types of checks that need to be made: against a list or matching a regex. Consider a simple, straighforward approach like this: 

I would take a different approach. First I would convert the number to words using an idealized numbering system, with none of the complications of the tens or teens. By way of example, 413,230 would be . Here would be . (I have shown the results of this first step in the examples below.) Then I would use the hash to correct the grammar. This results in there being relatively little code, but a fair amount of data. Note that the order of the elements in the hash is important. (Insertion order of hash elements is maintained in Ruby 1.9+. This is the first time I have found that change useful, but useful it is.) The substrings must be replaced first, then the substrings (the numbers 11-19) and lastly the substrings. Please let me know if what I have is not quite correct. 

UPDATE: I took the time and backpropagated the errors by hand for a couple of random initial configurations, and my results matched what the network calculates. Also, I ran it once on each test case and saw that the error for that test case improved marginally after the update, so I know my backprop and weight update steps are correct. Unfortunately, it still converges on bad values. Any ideas? 

I am working on a project that involves me writing an interpreter for a small toy language in Java, and while I intend to build it into a fully featured programming language at some point, it is currently in its very early stages (I have only implemented parsing complex mathematical expressions and boolean expressions involving , , , and , as well as a very rudimentary way of storing values in variables). My code seems to be increasing in complexity very rapidly, and before I continue on to implementing statements, loops, and functions, I want to make sure that 

is a tiny class I wrote to "box" variable types so that I don't have to know what kind of an it is, just that it has to be evaluated. I'm not sure that this is the best way to do it, but I couldn't think of anything else that maintains that level of abstraction. I'm also slightly uncomfortable with how complicated the class got, but it doesn't really fit into the because that deals with operators whose arguments are also s, whereas takes arguments. Finally, the method in my class currently just tries to evaluate a boolean expression and if it doesn't work it tries to get a math expression; the boolean expression class tries to parse a single boolean and if it doesn't work, it tries to find a comparison. I don't like this "guess and check" approach but I don't know how else to do it, because I can't just look ahead in the token stream as I wouldn't know how many tokens to look ahead. Any and all advice you can give me would be greatly appreciated.