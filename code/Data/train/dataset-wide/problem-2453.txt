(The full puzzle description, including examples, is available on the official AoC website.) The mentioned puzzle input consists of a file containing a grid of and . My Solution 

Here are some more things that bother me a little (adding to what yuri already wrote in their answer): Design Ugh, globals Globals are bad. They introduce hidden state that the execution of your functions depends on, are difficult to track, are prone to the static initialization fiasco and so on and so forth. Instead of making a global that is accessed from in the shadows, add a dictionary parameter to . This will also make accomplishing point 3, localization, much, much easier, as you can then pass different dictionaries for different languages. Other tips and tricks 

Do not use , especially not in a header. It can introduce subtle bugs. You class has no destructor and is leaking memory. Everything that is allocated through has to be d again (or, in the case of arrays, d). makes no sense because your array is not two dimensional (and I doubt that a two dimensional array would perform better than a one dimensional, but you are free to prove me wrong). If this is meant as a hint for you to improve the implementation later on, you should probably mark it as such (e.g. using the well known comment). Comments like are superfluous when followed by lines such as , because the variable name makes its purpose sufficiently clear. Generally, using comments is good, but they can also be overused (or written badly); using them effectively is key (and also not easy). You should generally avoid using , at least when the code is supposed to be portable. In this case is not portable at all (it is VS only) and generally also hints at bad code separation. If you think your file is unreadable without it, you should split it up into multiple. 

Whether exists in the global namespace is entirely left to the implementation. As such, your program might not compile with a conforming standard library (although, to the best of my knowledge, all big standard library providers provide those functions). To circumvent this, utilize the versions of every C type and function you use. It would be nice of you to order your includes alphabetically to facilitate include checking. Some of your comments don't add much to the code, omit those. For example, is something that is perfectly clear from the corresponding code line. Also, it is a lot more common to see comments before the line they refer as opposed to after, so you may want to change your comment style. is not the C++ way to define constants. Use , and with file-scope variables where appropriate. This allows you to have typed constants as well. There is no need to write out in lines like ; suffices (structs in C++ are not like structs in C). Don't use . It causes unnecessary performance degradation through flushing where a simple would suffice. You don't need to write out in type names such as or ; and are enough. While there is inherently nothing wrong with adding the part, most people just omit it. Ultimately, it's your choice. Since never terminates, you have some dead code at the end of , which you should remove. Of course, it would be better if actually terminated. The command line command you supplied to compile your program does not include warning flags. Compiler warning flags are oftentimes very useful in catching stupid bugs early, and not providing warning flags on Code Review always makes me suspicious that you either don't know about them, don't use them, or are trying to hide the fact that your code produces warnings, neither of which are particularly good (clang does accept your code without any utterances, however, so I assume that you did actually compile at least once with warnings enabled). Also, is not strictly necessary to compile your program, so I'd have omitted it here. Boolean checks such as can simply be reduced to . There is no need to compare with and since the value you get is already a . 

You should order your includes more, and also differently. More in a sense of alphabetically and differently in a sense of grouping. Why should you order your includes alphabetically? Simply to increase readability and to facilitate include checking. However, you should also group your includes by what project they belong and order those groups. Generally, I prefer: The header your current file is implementing (if any), then any headers from the same project, then headers from different projects and libraries and finally standard headers. This order has the benefit of providing an additional error check: If one of your headers is missing an include, including that header first will make the compiler tell you about it. Otherwise, you might just happen to include the missing header first because you need some functionality from it and hide the missing include. You should consider passing iterators by value. Usually, iterators are designed to be lightweight and easily copyable, which is why the standard library always takes them by value, too. You are not going to gain much by passing them by reference, so you should prefer the clearer and more idiomatic pass by value. I find your use of excessive. For example, in my opinion should rather return a because you're transferring ownership here. If you are looking for rules on when to use which smart pointer (or even a raw pointer), you should take a look at the Cpp Core Guidelines. Please don't use . It doesn't only do what its name suggests, but also flushes the output buffer which is almost never necessary and can be harmful to performance. If you really need to flush the buffer, you should use instead. You actually have a missing include in . You are using (which really should be as the global name is not guaranteed), but are missing an include for (or one of the other headers that define it). 

Please feel free, of course, to also review my code generally without respect to the above questions. 

What is evident from this is that variable points to an array on the heap containing pointers to objects on the heap. However, your destructor only takes care of the objects the contents of the array point to, not of the array itself. The fix is simple: Just add at the end. Speaking of which... Don't do manual memory management in C++ unless you really, positively, absolutely have to. Take this as a lesson. Your program leaks memory, which is one of the least bad things that can happen when working with manual memory management. The potential to shoot yourself in the foot is much, much greater, and C++ offers a variety of auxiliary classes and containers to prevent you from leaving your toes somewhere during program execution. Knowing this, let's look for help in the standard library. Your use case is something like this: You want an array on the heap, the size of which is fixed and which contains owning pointers to objects on the heap. What standard containers offer such functionality? Well, since your size is known at compile time, would be one possibility, although in that case, the contents would live wherever the enclosing object lives (i.e. if you have your queue on the stack, all of the memory for this array is also going to be allocated on the stack), which comes with a risk of stack overflow. Thus, let's make this an . Another alternative would be to use the arguably most common standard container, , which is completely dynamic (i.e. can change its size at runtime) but usually doesn't incur any additional costs when accessed like a normal array. The decision about which one should be taken depends largely on whether you want to keep as a template parameter. In my opinion, doing so is almost completely useless since you don't really do anything at compile time with it and it hinders interoperability. Instead, I would just have the constructor take the desired size as an argument and initialize the underlying container dynamically, in which case becomes unfit since the size is no longer determinable at compile time. Ultimately, the choice is yours; however, you should ask yourself whether you can provide any real justification for restricting the use of your queue to cases where the required size is known at compile time (which is not the majority of cases as far as I can judge). Even in that case, the benefit that provides is largely marginalized to the fact that you're allocating it on the heap. But even after that choice, we're still not done here. Another reason that raw pointers are largely discouraged in modern C++ is the problem of ownership semantics. What are ownership semantics? Well, basically it means expressing which part of your code owns which values, and which part only uses or borrows values from other parts in the code directly. There are different approaches to this for different parts of the problem, but for the owning-pointer-to-heap problem, C++ offers and since C++11. The benefit of these pointers is twofold: Firstly, they express how the object they contain is being owned (single ownership for , shared ownership for ) and secondly, they provide safety through RAII abstraction of the memory allocation process. Both pointers automatically free the memory they point to when being destructed. In your case, the ownership relations are clear: Every object in your queue is a part of the queue and only of the queue, i.e. the queue owns it uniquely. The container just hands out pointers to single elements so that such elements can be used by other parts of your code, while not giving up and transferring the ownership over these elements. Accordingly, this is a perfect use case for . The element type of the container you choose should be , and those elements should be initialized using (or if C++14 is not available to you). 

looks much nicer. Includes You are missing an include for . Preferably, that would be , although there are at least five other headers guaranteed to define it. Similarly, you are missing for , and the whole package, and for . Finally, you are also missing for , for and , and for everything -related. Please be more careful around your includes! Another thing that bothers me a little is that your include are not sorted alphabetically. While this is not a problem per se for such a small project as yours, it can grow to be a quite a nuisance in larger projects with dozens or more of includes. Ordering your includes from a to z makes getting an overview over them much easier and helps verify whether all includes are actually there. Typos and Spelling Inconsistencies Finally, the most pedantic and least useful code review point of all! contains a member variable spelled . However, in the constructor, you have the comment 

Fix your includes. You're missing (for ), (for ) and or similar (for ). Don't rely on C legacy types being defined in the global namespace. may not exist; use instead. should be . The latter is arguably more correct here and expresses your intents better. Why do you take an as argument for ? This limits your dereference to the size of , whereas the underlying container can have a size of . It appears you have typo'ed "difference" in . 

I'm not convinced that it is still appropriate to define as a macro in our modern times. You likely know about all the drawbacks macros have (no type safety, proneness to bad behavior because of missing parentheses etc.), and you don't have any significant drawbacks if you defined it as a function (except for the issue of type rigidity, which does not apply in your case, however, since you only use once and could define it for the appropriate type). In my opinion, and are rather obfuscating the underlying code. Since both of these functions consist of a simple check, and their names do not actually convey what is checked, you are actually losing clarity here. Encountering calls to these functions in the code inevitably makes you go back and read their definitions, because the name just suggests that a check is carried out, not what check. My suggestion would be an -like method to which you pass a condition and which calls if that condition is not met. That way, you abstract a part of the functionality away (the fail-on-error), but retain the self-explaining property of those checks. You can omit the parentheses around the argument of if it is not a type argument. For example, can be written as . The advantage of removing the parentheses here is to make it clear when the argument is a variable and when it is a type name. I don't know how much you care about such things, but ideally, you should check the return value of functions that could fail. This includes , and if your program fails, it is a matter of grace and correctness whether you let it just crash or fail gracefully (correctness in a sense that failing gracefully implies that you accounted for a certain edge condition, such as out-of-memory). Consider factoring "run once"-code out of loops. For example, 

Don't make assumptions about the signedness of your type, which seems to represent the size type of the array. Oftentimes, will be unsigned (e.g. because it is ), which means returning on not finding a value might be unexpected behaviour for your users. Check that is greater than zero. If it is not, your program invokes undefined behaviour. Take by const reference since you don't know which type it will be, whether it will be trivially copyable and so on and so forth. The same is true for , and ; you should either make them pointers to elements in the array or make them store the index to their respective elements instead. Be careful with overflow. In particular, may overflow the passed size type and you may end up getting nowhere. Instead, divide them separately and add the results together. 

This answer is by far not comprehensive, but I suggest you go and rework your code, then come back for another review. I am not going to sugarcoat it for you: Your code is horrible by C++ standards. You freely mix C legacy functions with code bearing only the slightest resemblance with what is called modern C++. There is a middle ground between C and C++ which is called "C with classes" by most people. If you want to write code that's closer to C, you could consider sticking with that. Otherwise, I strongly recommend you to pick up a good book and learn how to write reasonably good C++ first. 

Making your Code more C++-y As you remarked yourself, your current code is not very much C++-like, but we're going to change that by making good use of the standard library. As you know, checking whether a string is a palindrome is equal to checking the to halves of the string for equality, only that the latter half is traversed in reverse order. Luckily for us, checking ranges of elements for equality is one of the things that are needed quite frequently by a lot of people, so C++ offers the very useful . , in its most basic form, takes three iterators: one to the beginning of a range of elements, one to its end, and another one that points to the beginning of the range the elements should be compared with. The only problem here is that we actually need our second range to be iterated in reverse. Again, the STL comes to our rescue. There is , which, who would have guessed, allows iterating in reverse order, and also , which is a member function of that returns a reverse iterator from the end of the string. Combining these, we get 

Having as a beautified interface to seems kind of ugly to me. Is there a way to clean this up and join the two functions? Or is this a common pattern? How readable is this code? As its author, I find it hard to judge how (un-)pleasant this code is to the eye of a third person, especially since I have next to no experience in reading and writing Haskell code. What can I do to improve readability? seems very verbose to me. Is there a more concise way to implement it?