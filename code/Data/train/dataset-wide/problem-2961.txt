The advantage of this design is that you'd quickly find that you don't really need much inheritance at all. I would aim to have at most a single pure abstract base class, and implementations for the different abilities. Any time you need to share some code, just make a new class, and have the other classes own one. LEAKY ENCAPSULATION Make everything private. If something needs to be public, check to see where it's used. If it's only used somewhere else, move it. Never use public fields - anything public should be a property. Never set data on another class instance - all setters should be at most private, but better, simply non-existent (i.e. either set in the constructor or implicit functions). That's it for now. Two general points to always bear in mind: 

Introduce and AbilityCaster class, which is basically the instance of an ability owned by an Entity. This would know about the owner (but not the target list). The idea is that calling StartCast() would take a list of targets as a parameter, and return a new CastTracker (you can return a special "already finished" cast tracker for instantaneous abilities). Introduce a CastTracker class that just tracks the timing of a cast, and maintains the list of targets. This would have the Tick() method, and a Cancel() method if something other than timing can cancel a cast. Each tick would call back into the associated AbilityCaster class, with the necessary information to decide what to do. Remove all time tracking code from the Ability class, so it just becomes a stateless specification of capability. This could potentially be abstract, with just one level of implementation for the different capabilities. Something like an abstract DoDamage(Entity owner, IEnumerable targets) method. 

Inheritance is the devil. Never implement an "is-a" relationship with inheritance. Any time you reach for inheritance, you need to cultivate an instinct to stop and do something different. Note this is different from abstract definition and sealed implementation - that's just a strategy pattern, which is absolutely fine. Make more classes, that do fewer things. 

Your code is going to log an awful lot of "GameObject is not null" items, for very few non-null game objects. Basically, you've made an O(n * m * p * q) algorithm, where all you needed was (at most) an O(n + m + p + q) algorithm. This would achieve the same effect - beyond the fact that you'll get fewer logs of the same non-null combination over and over again. This code assumes that the library requires an enumerator. 

Glad you took my suggestion and posted over here. I'm going to start from the most important (but also high-level) bits, and work my way towards specifics and code here. DESIGN ISSUES The main issue is that you're using lots of inheritance, which is a BadThing(tm). See below: There are a few things about your design that could be greatly improved, before we go into code. First off are some basic principles of OOP, called SOLID for short. I'm listing all of them for completeness, but your posted code is falling foul of the O and L bits: Single Object Responsibility: Each class should have one thing that it does (you are doing this). Open/Closed: A component should be open for extension, but closed for modification - you're falling down here because you're using very deep inheritance trees. This means that, if you need a specific ability to do something new, you will either have to cast that ability to the specific type or add a virtual method in the base class (thus needing to modify the base class design). This process eventually leads to an anti-pattern where the base class accumulates more and more virtual methods. $URL$ Liskov Substitution Principle: This is perhaps the most important, and the one that your design fails quite badly on. Basically, this says that if you have a base class, instances of that base class should all adhere to the same contract, regardless of the types derived from it. Roughly speaking, this equates to "don't specialise by inheritance". As in, inherit from a type ONLY to extend its capabilities, not to restrict them. Clearly almost any deep inheritance hierarchy is going to violate this principle. The alternative is to "own" a capability rather than "being" a capability. $URL$ (a little abstract) and also $URL$ (which is basically a design philosophy that arises from Liskov substitution). Interface Segregation - interfaces should represent indivisible capabilities. You aren't using interfaces here, but you should be (see below). Dependency Inversion - your Ability class depends on your Entity class. Assuming that your Entity class also depends on your ability class, you're falling foul of this. The best way to avoid it is to have the Ability class depend on a minimal interface, which has just the properties and methods that you need. CONFUSION BETWEEN TYPE AND INSTANCE There is a key issue with this design, beyond OOP principles, which is that you appear to be confusing type and instance - there isn't a distinction between the ability to pray, and the ability of a particular character to pray, for instance. Essentially, you're missing an entire set of classes that actually cast these abilities. For instance, suppose you wanted to introduce an ability that could be re-cast a limited number of times while it was already in progress. You would have a problem, because the class hierarchy that captures the ability to pray is the same one that's responsible for tracking the execution of a particular prayer. I would do the following: 

The idea is that rather than embedding your data in the code, you should structure it in a meaningful way, then use generic code to present the data from the structures in the way you want the player to see it. I think you're on the right track with your Creature and Item classes. I think maybe you want more classes like Place (or Room), Container (to represent boxes, chests, hidey holes, etc.). If you have to write specific logic for each step in the story, your game is going to be very linear and you'll be limited in how much branching and looping you can manage. On the other hand, if your game is just a network of Places connected to each other with Items, Containers, other Creatures and such scattered throughout for the Hero to encounter and either fight or befriend, and the Hero is free to wander from Place to Place backward and forward and in loops, then the game becomes much less predictable and more interesting. What would the code look like to process such a network of Places, Items, Containers, Creatures, and whatever else you can dream up? 

You don't need "if not out:" at the top of this -- you're in a "while not out" loop and out hasn't had a chance to change since the top of the loop. The "for items" loop just scans through the inventory looking to see if you have the door key. That can be done in a single statement, as I show. Once you've opened the door, you're out, so we can just break out of the "while not out" loop and carry on from there. Several of your descriptions are hard-coded: 

So display() keeps showing the menu as long as userInput() returns None. userInput() returns None if the user's input doesn't match a button, or the inputSel value if it does match. I think the way the Controller loops is fine. The program will always stop when it gets to raw_input() and read stdin until the user hits ENTER or RETURN. That's what raw_input() does. You're managing your buttons as a list, which means you have to scan the whole list until you find the navigation element the user selected. If you put them in a dict, you can simply use the user's input to index directly into the structure and select the correct button (or determine that the user's selection is invalid). However, you still want them as a list for display because you can't control the order in which entries are pulled from a dictionary and I think you want your menu to display in the same order every time. That needs a list. I would suggest the following for the constructor for the Display class. We're going to pass in a list so it's easy to define, and we'll keep the list, but we'll also have the class internally turn that list into a dict so it can more easily find the user's input on each selection.