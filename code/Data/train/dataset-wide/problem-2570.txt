Why create methods/functions/lines of code that do something that's already been made for you. If you want to get the filename without the extension, use the Path.GetFileNameWithoutExtension() method. 

Is there a reason why they are in separate methods? The only overlapping part is that in two conditions can be the same as (1 and 3). If this is a mistake, you can place all the code in one method, if the checks are correct and you want to keep both methods, also fine. I'll base my answer on the correctness of your code and keep two methods. 

Coding style Variable names Avoid variable names like or . In your code they still make sense because they're the abbreviation of the class name and it's not a lot of code, but it is still bad practice. When you have lots of code with less obvious class names or origins for the abbreviations, it'll become unclear what they are really fast. Rename them to and or something similar that clearly indicates what it is. Casing Per the Naming Guidelines by Microsoft, use the following rules: 

Note that this last line will enable the item when it is checked, not only disable the item when it is unchecked. This logic can also be applied to all the if statements in the code. 

First to note, your code seems to work and the code-style is OK. There is not much to review :) ...but still: Using the not to write reallocation (growing) yourself is fine, but the is unnecessary, as all the time, it is redundant. will throw IndexOutOfRangeException if the queue is empty. It would be better to check and throw InvalidOperationException instead. 

Stateless C++11 allocators Allocators were at first (my opinion) designed to be simple empty classes / templates, to just call or similar function. They are treated this way as if copying was no-cost. I would personally design it in a bit different way, but I understand that it is what it is. Allocator must therefore be either empty (with only static/shared members) or a reference/pointer to the real logic. Using is therefore fine and satisfy the stateless requirement as I understand it (it handles the destruction as well). boost::pool as allocator This is actually something I have used myself for tiny blocks. It can help a lot if your application needs to allocate many tiny objects (2-3 pointers/integers per object). But beware... used in std::vector But vector is not so good with such an allocator, would be. The problem is that is an array, which reallocates as needed. That often means that new array is created, items copyed and old array destroyed. Container that does not reallocate its node would be better (e.g. tree or deque). In better words: would better be utilized with such "no-destroy unless deleting" container. using single allocator in multiple containers Yes, of course you can. But take care about thread-safety and copy/move constructors (which you solved by using ). the code Well, your indentation may need some improvements, your last line looks like you have the counter outside of the class. But other than that, I can see no errors. 

Tip: new Constraint (C# Reference) I cannot reproduce your code and therefore cannot test the method. Please let me know if you got it to work using this method. Hope this helps! 

Furthermore, give useful names to variables. Names like or are not meaningful, try and instead. I updated the JSFiddle working example. 

I would not over-complicate the matter by splitting it up in several models. But if you want to stick to the choice of splitting it up, I would define an base class and create a and model. Because in the current situation I find the naming not 100% clear. Certainly because (which sounds generic/basic) derives from (which is specific). It should be the other way around, a specific class should inherit from a generic/basic class. Here's a rough implementation: 

This makes that you have to check for different situations and so your if-statement cannot really be shortened to one statement. What you also can do is loop over the fields and do a count of the empty fields and validate this: 

Solution Make the server-side by adding to to the tag and give it an ID. Now you can access the tr-tag from the code-behind and set it's visibility property. Example: Markup 

For I would not worry about duplication, but you can solve it by const_proxy->proxy private constructor (and ) and some to help you. Not nice, I would rather copy three lines and adapt. Again, some templated private helper could solve that as well. It is your class, if you are fine with , then it is fine. If not, enhance it and use std category tag. 

Which you should try to avoid (if you plan to have good Queue) by using Circular Buffer. Use two indexes - one for writing, one for reading and reset them to zero when they reach which becomes your . Leave one slot empty to never have write_index == read_index for both empty and full queue. You could even enhance it to create Doubly-Ended Queue that you can add/remove to/from both ends. 

Overall the interface looks good and I have no problem with private inheritance here, it allows you to use to export (publish) some features that are already there. Second option would be to use private member and forward everything (typedefs, methods simply calling the method on the inner variable), no win here, I would prefer private inheritance. The allows you to have those links in second vector instead of using that without problems with , but I personally don't see big problem in using or directly - it is your vector, you have the right to define as you choose and any vector have to accept integral types as indexes - again, I can see no big problem, but to make sure, would be good: 

This is wrong, the setter should be used to set the value of a instance, certainly not to save a value in the object. Also since this has all to do with and not with the , maybe this belongs in the class. 

See how the other names make more sense? Try to avoid verbs as a classname. Methods can and most likely will be or contain verbs, but not classnames. Also, leaving the query out of the class leaves you the option to use the same code for other queries. Note that this is no perfect code, I was only suggesting what might be changed. Hope this helps! :) Edit: You call the function selectData() and pass the query-string as a parameter. This changes nothing, it gives the same result as your code. Only in my case you can pass other queries to the function whereas your function is limited to the embedded query. Now for the result. This has also to do with the decoupling of your connection-class and what will be shown to the user. I showed u the usage of the class, the code below is how you can process the result. Create a function (but not in the connection class!) that returns the result in a table: 

Usage example That was not part of the code for review, just and imperfect example. The real objects are a bit different. 

I would personally use and private inheritance and few static_asserts, but you can as well think about private member, your custom and doing everything by hand to make it work in any possible scenairo. Note that this is my personal review and may not fully express the customs of this community ;) EDIT: Using seems to be better idea since C++11. See comments. 

After some tests (adding more time-points), we can find that the double for-loop used to find all abundant numbers is the slowest. Now we can think about speeding it up, by shortening the inner loop. We start with and try every number we find can divide upto . We immediatelly know that the product will of course divide the number as well, but need to take special care for numbers of the form . 

More functions like this are needed (e.g. ). Documentation The is no longer default behaviour of Doxygen and the comments shall therefore be changed: 

Your code will work, but you are using events in a way they should not be used. Once they are public, they are for signing and unsigning as per user of the class (those that start the operation), not to be unsigned by the class (controller). If you still for whatever reason need to preserve the class (and its state) and call the action once, it should be a parameter of the start method: 

Now when the remaining lifetime is greater than 0, your rover can happily move and will die when you keep subtracting the changes from its remaining lifetime. This gets me to another error in the logic. This is the formula you use to calculate the number to subtract from the lifetime: 

Just out of curiosity, how would you do this without an if-statement? I wonder where you heard this. In code, the moment you need to check for a condition (of a variable or the result of a method), you have to use an if-statement. Spacing: Just for readability, leave spaces between assignments and checks in conditions: 

Naming: Don't use variable names such as . They're not meaningful, not for you, not for others. In this case, use . Class names, public fields and method names use and not . So, will become . But then again, this is also not a meaningful name. Boolean methods or properties in C# will most likely start with or . An example for the name of your method would be . keyword: Use to declare your variables instead of declaring them explicitly. The compiler will determine the type for you and your code looks cleaner. The method: Your code looks good. You could however make it cleaner by using LinQ. Loops won't be avoided but it looks cleaner. I'm not saying this is a perfect solution but here goes: 

And original added to destructor, similar changes througout the interface. This way, the caller is made responsible for the pointer and the object gets disposed if the return value is not used. Other pointers (like on ) are no problem. No other proposal (except formatting options for the preprocessor) was accepted, see comments at the end, if you wish. Vertical spacing Given sample of the real source code: 

This is reaction to comments: firda: Why do you have all those small classes connected through properties instead of using class hierarchy? I would create SearchRequest and UpdateRequest both derived from Request, while making SecondAction virtual get or protected set. Any problem with such solution? archytect: That seems logical, but it's not easy to grasp. Could you provide some code to better visualize it? 

How to synchronize? We have to protect anything that we may access from different threads. The common practice is to have some that we can use for . The list of is exactly what we need. So, any access can be protected this way: 

as the is unnecessary Reuse code, don't duplicate You can use one and have one in the final catch for each method body. That could possibly have some speed penalty, but not something really important. Simplicity, readability and maintainability is more important (especially for managed language/code). Why the argument? Do you really need it? Does it have to be parameter? Are you calling it with variable or always , or default? I would personaly create methods returning that throws (e.g. and one with name starting with (e.g. ) that would call the first and on exception. Actually, you intent to throw for DEBUG, to know it, to diagnose. So, it seems to be designed to throw, not to return false (this sounds like: we rather remain silent in release instead of crashing the app). 

Naming conventions: As per the Microsoft guidelines, use PascalCase for method names. Read more here: Capitalization Conventions. Your method names will become and . Object Initialization and Format String: Use the String.Format method to build your string, don't use concatenation. The building of your CAML query will be: 

I know I have strayed from the Exception subject but I thought this might help you too refactoring your code. Keep in mind that exceptions are for when your code does something unexpected. Ecxeption-handling is for catching situations which might result in abnormal behavior of your program, not for data that you (not the code) expect there to be. I hope you understand what I mean and that this helps! ;) 

Here are several tips that might help write better/cleaner code. Note that my tips or help might not be perfect but it gives you an idea on how to write better code. 

Methods: is something I don't understand. It is a void method but doesn't do anything important enough to be a separate method. Let it return a instead. Rewritten: 

There are several remarks I could tell on your singleton implementation but since there's a far more better expert than me on these things, I'll reference his work. His name is Jon Skeet and he has an article on the singleton pattern which can be found here. Here are several points from the article that can help: 

- what is that method doing? Number of vectors? Something different? The names and design The looks like , where is something like location/position (seen in example) - a key - and is the value. Why not naming it that way? As already mentioned, may describe what is it about, but still is too connected with the implementation, not the purpose. (The location could be enumeration and our metric could measure the distance using dijkstra or whatever algorithm.) vs. + : I would take inspiration in and use pair of iterators - there would be no need for and the two methods could be made one. vs. : which of the two will be most used? What about adding another template parameter ( or ) for it? The name could then be simply ( can be removed as well). 

I don't know the book but have personally written few parsers, compilers and virtual machines, so, I will answer from this perspective. AST v.s. eval() I do not fully understand why you have selected mathematical representation of numbers which can be found in set-theory. There is one element to be known - zero (or empty set) and a construct to create another - succ(zero) (e.g. set containing one element - the previous set). In classical numerical evaluation, you would have some type containing the numeric value. and would then access the value and add/substract one (increase or decrease). With your cunnert design, , but does not know , it only knows or . This way you either have to make somehow public (e.g. by public getter) or have to use the friending as you did. C++ features used It is safe to use but it would be better to have some constants and actually share them! The examle would be - looks like good attempt to share, but you'll need to make it working (trully sharing one instance, not creating new ones). But you will also need static versions and probably hide the constructor (to ensure, there is only one and only one , not multiple). The can be replaced by