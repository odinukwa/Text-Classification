is quite weirdly implemented. Why not just use a loop? Alternatively, if you want to maintain laziness, you could do something like: 

What you could get is multiple threads calling , waiting on that lock, then one at a time they run the code inside the lock. That's inefficient but shouldn't lead to any actual bugs. If you want to avoid this, you could put a lock on the expiration check. However, I'd suggest profiling this, because this will potentially be hit many times more than , and potentially may have a greater performance cost. Another alternative might be to have the an initial expiration check as it is, then a second, identical one inside the lock, returning immediately if it hasn't expired. This will mean most calls will be able to go through without ever hitting the lock, and if multiple threads do end up entering one after the other, only one will actually do the expensive value calculation. Again, you should choose between this and one of the other two based on profiling with what you think are reasonable expiration intervals. 

You require a in your constructor, but then let be set publicly. This doesn't really make much sense- somebody could just pass default(T) to the constructor, making the constructor meaningless. You're giving two different ways to set the value, for no particular reason. It's not a big deal, but is needlessly confusing. Consider whether you actually need to be able to change for an existing instance. If so, remove the constructor. If not (and this is probably better!), make the property . This makes the value immutable, which makes it much easier to reason about the class. For example, if I hold an instance, I know I can pass that instance to whoever I want without having to worry about them changing the value without me expecting it. 

As for the main question, if point 1 was not true, then I'd definitely prefer the second version. You should only throw an exception in an exceptional circumstance. If does not know whether being false is exceptional, it should not throw an exception, and instead leave that to the caller to decide. Given point 1, I don't think I have a strong preference between the two. I think the best guiding principle here would be the single responsibility principle: which of the two methods is best positioned to take the responsibility of deciding which exception to throw, and with what message? As for testing, I don't think either approach would be particularly easier or harder to test than the other. 

Unfortunately as you can see, this is pretty quickly going to end up with a load of really similar methods, all of which are frustratingly large. The solution to this is two-fold. First, because the only difference between the methods is which function we call, the use of can cut it down to just one method: 

Looks to me like its own method. There's quite a lot of information here that the brain has to do some reading/calculation to work out: 

Okay, hopefully that's convincing. So the change is simple, as I suggested, just delete the , and fields, and the constructor overload which sets , and change the signature of . Static? You're now left with just two members: a parameterless constructor and the new method. In fact, an empty parameterless constructor isn't needed now that the other one is gone, so that can be removed too. And at this point you might think that perhaps you should make the method- or in fact the class- static. There is, after all, no preserved state, and nothing instance-specific that's required. Well, this is often a judgement call. Here are a few things you can't do if it's static: 

Now we have a , but we can't really do anything with it. I already decided that the constructor shouldn't be exposed publicly, its behaviour seems too confusing to expose directly to consumers. LINQ-to-Objects can give us another hint here: static constructors and extension methods are likely to be very powerful. Let's start with: 

Given that this program has a single class, and in fact a single method, it doesn't really matter where you declare things. However, in general if you're only using a variable inside a method, you should declare it in that method rather than at the class level like you have. Even if you were using it throughout the class, you should still keep it private, not public, unless you explicitly want to expose it to other classes. 

These are judgement calls you need to make, but in this particular case, I'd suggest that the first point is persuasive and the second two are probably not. An example of state you might want to preserve is if you take a dynamic programming approach to Fibonacci, where you cache the results of previous calculations. This probably could be done with statics, but when dealing with static vs. instance, generally the best guideline is err on the side of instance. It costs very little and it's the safer option. Unneeded A small style point, but one that can be important. If you exit a method- either by returning or throwing an exception- inside an statement, there's no need to then have an . By the time you've hit the line, you already know the condition wasn't true, or you'd have exited out of the method by then. So you can cut out some unneeded lines and indentation, neatening up your method: 

That's a start, but a good general idea with programming is to say what you're doing, not how you're doing it. So the above might become: 

Overall, the problem of having a collection, not knowing whether it's null, and wanting to treat a null collection the same as an empty one is probably a problem to be avoided, rather than solved. But that's beyond the scope of this question. 

Enumerator The first thing I notice here are the stacks. And the first thing that makes me think: recursion! You're not only worrying about keeping two stacks aligned, but you also have to keep track of how deep you are inside them. Taking advantage of the call stack to take care of that for you makes life a lot easier. So start with the signature: 

Update As a couple of people have noted in comments, using a instead of a may be preferable, as it is more in fitting with the meaning of these structures. This makes the add/subtract tick logic slightly more verbose, but not prohibitively. 

You can return this directly from , or if that's causing performance issues you can calculate it once and store the result. This will follow the contract of - i.e. objects that are equal (meaning, in this case, that their , , and properties are equal) will be guaranteed to have the same hash code, but objects with the same hash code may not be equal. 

The second point is rather more difficult to deal with. While it would be possible to move the logic for matching against an individual username or email to a class, it would be hard to do that in a way which EF would still be able to translate to SQL. To avoid adding a lot of complexity, it's probably best not to try to do this. Do make sure your validation won't allow for usernames and email addresses which could match, though! 

Class vs Method This class is structured so that you give it an input (), and then from it you get an output (). Well, we already have something that's much more specifically suited for that than a class: a method! Instead of 

This makes a nice unit of functionality itself, with a single, simple purpose: Get a color from an integer index. So put the above in a method (say, , with as a parameter replacing ). The other ingredient is generating unique integers. This is what you really want to separate out into its own class, implementing an interface. That way, you can generate numbers however you want to get different patterns: increment by one, increment by an offset, use the numbers 1 to N shuffled randomly, whatever you can think of! By using polymorphism, instead of being limited to one way of generating numbers with some potential for parametrization (like ), you will be able to use whatever algorithms you want. Fortunately, an interface already exists for exactly what you want: . You can often think of an as a collection to iterate over, but in some situations I find it more conceptually useful to think of it as a box that I can just keep asking for a new (though it may eventually reach the end of its s). In this case, that's exactly what you want- a box you can just keep pulling integers out of. So let's pull this together: 

There's likely still scope for improvement- e.g. adding a better way of doing exception/error handling and logging, dependency injection. But those would be beyond the scope of this question. 

Here the new methods , and would be private methods containing the bits of code they replace. This method now immediately states what it is doing: it's validating the text in as an IP, if it's valid then enable the controls, otherwise disable them. Potentially you could get rid of and just put that call directly into the statement, it's up to you what you think reads better. You may also be able to improve on those names a bit (enable which controls, for example). Repetition Now look at the second method. You'll see that can be used here too. This means that just by making the first method a clearer statement of what it's doing, we've discovered a valuable abstraction, and we no longer have to repeat that enabling controls means enabling and . We can almost use too, but there's a slight difference- the messages. So to fix that, should take the message as a string parameter: 

Instead of predicates, you can now create and use classes which implement this interface. This gives better adherence to the design principles I mentioned before, and allows you take full advantage of polymorphism (for more complicated validation you might find that inheritance is useful, for example). At this point your original method would be: 

Beyond this, I have to echo Heslacher on both the issues with naming and with this method mixing its responsibilities. In fact, these issues are linked, because taking care with your naming is often the best early-warning mechanism for a method doing too much, or lacking a single purpose. For example, what should this method be called? as Heslacher suggests is nice, but doesn't actually describe your initial method well, because it gives no indication that it's also going to be doing IO. would be a more accurate name, and this should immediately raise alarm bells: Why is this description so long? Why does it combine two unrelated concepts (initializing an array and console IO)? The answer is that the method lacks a single purpose (or "responsibility"), and should be separated out. 

HostViewModel This is where I start to get a bit more confused. Why is something called being treated as an entity, or stored in a database? Without knowing more it's hard to comment on what's going on here exactly, but EF is supposed to let you handle - these are essentially domain objects. So a is a good candidate for an entity. A might be, depending on what "host" actually means in this context. But a ? That seems like extreme mixing of concerns between your UI and your core domain. Or, possibly what's going on is that your actual entity is a , and the repository is not only doing its usual repository business, but also in charge of mapping from an entity to a view model. This is also a problematic mixing of concerns. You may, for example, have a view model which does not have sufficient information to create a new entity from. So how would you handle the method for that type? Transformation between entities and view models is a UI concern and should be kept away from the repository pattern, which is a data access/persistence pattern. HostRepository As already mentioned, it's very weird that should be returning a collection of s. The bulk of that method can be simplified with LINQ, too: 

Of those, the first would be my preference. In terms of choosing approaches, with the above changes made I would prefer the second. In my opinion, returning early makes code easier to read because, mentally, you can completely discount paths through the code which have already returned. Having to only temporarily make that mental switch as you enter an statement means having to maintain a more complex mental "stack" of possible paths through the method. True, you could scroll all the way to end end of the statement and see that there's no more code afterwards, but it's much nicer to be able to read code start-to-finish, rather than jumping back and forth. 

Of these, the latter is far more situational, and in the example in your question, is likely not to be a concern. The former, though, is the key distinguishing feature between the first exception and your "why not also" example. The answer, then, to "where should we stop" is when you're no longer providing significant value through one or both of the above reasons. 

Both of these create common situations where you'll have collisions. Fortunately, though, you probably don't really have to worry about this problem, because .NET already gives you a way to create a hash code from multiple objects: 

This one's pretty straightforward. If you have rows of length , then the row is (note that with integer arithmetic this automatically rounds down to the nearest integer) and the column is . 

Aside: Naming Actually, now that we're here, extracting this method has brought into sharper focus that maybe the naming isn't ideal. is extremely vague- why not , which is what you actually use it as inside the method? Likewise would be better as a description of something the method is doing, like . Initializing the height One of the uglier pieces of logic is the special case for the number of cycles being 0. Is that necessary? What are we actually getting at with this: