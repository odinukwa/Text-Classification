This has the benefit of treating null input essentially as if it were not provided, which would seem a more expected result. You could still have an error thrown, but I don't see the value. If you choose to have an error, at least make the issue more obvious. "Prototype chains are assumed to be delimited by Object.prototype." is confusing and unclear what the issue is to me. I would go for something like: "Cannot appendToProto of null." In general the error message should indicate what is wrong with the input instead of the codes philosophy regarding what its input should be. 

I wish I had a suggestion on how to improve your loop, but as you said, it's much trickier than you might think, and I'm probably not smart enough. ;-) Only suggestions I can think of here: 

I agree with tomdemuyt that requiring this to be used with jQuery seems to contradict your description of it being "lightweight". Most of the code doesn't reference jQuery, I'd look into factoring out the jQuery dependence. 

To figure out, how long the i/o takes, remove everything between within the loop. So you know where you can focus first. Or where it doesn't make any sense. I'm reading 829MB's in around two seconds on my machine(Using your way to load the file, without the magic within the while loop). If I use BufferedInputStream->FileInputStream, it's half a second, using a 8*1024 buffer. Well, that works as long as you don't work with fancy charsets. Here's an interesting article, one guy did a test a lot of ways to load data from a stream: $URL$ Here's an interesting article about buffer sizes: $URL$ If nothing helps: If you're in charge of the part which writes the file: Write different files on different harddisks and have a thread for every file and merge the results together. Regards, slowy 

Ordering The ordering is a bit mixed. Try to an ordering such as: variables, constructor, public methods, private methods. There's no real convention for that, but try to tell the reader the story about your class. As for instance the member vars are the protagonists, the Constructor is the entry of a book, and the methods are the chapters. Probable bugs 

In this code, I'm overriding the sorter and matcher for Twitter-Bootstrap's Typeahead functionality. The reason for the override is to allow state (technically Jurisdiction) abbreviations to be used to match the full state name. I've reduced the length of the source array in this example for brevity, but a full version is available on this fiddle. I also decided to make it so that duplicate entries could not be made. I went out of my way to make JSHint like my code, but I'd basically like any suggestions. This is my first time doing something like this and I'm relatively new with Javascript anyway. The only things I'm not interested in is white space as I simply formatted this based upon JSFiddle's TidyUp function, the css (as I didn't create it), and suggestions to override highlighter as I don't see the need. Note: In production the number of inputs is dynamic, which is why I am selecting them each time. If you need to view the Typeahead source code to understand my overrides, you can download it here HTML for Example 

I think it's too much to ask, to point everything out or give more or less exact statements about what you may need to refactor to what and why, since with some reading about the presentation patterns, you should come up with your own pattern decisions which you then will implement. I think that needs a few iterations ;-) (Check Passive View, MVP, MVVM/Presentation Model, that's the most common used, imo, or check for open source projects). Comments 99% percent of your comments are obsolete. First, they explain what the code is doing - don't comment what you are doing. They will lie one day, for instances the comment. One day it will be 30, or dynamic, or whatever. If you comment, comment why you are doing something. But in general, even that is often not necessary. In enterprise applications, it's usual because of "business illogic" / absurd requirements. Naming Try to be as clear as possible when it comes to naming. For instance, in , you declare g, d and dt, I see from the constructor, what those are. But when I have for instance a bug to fix and I know it's in , I read the following line: . I have only a clue about what dt, g and d would be. If you'd name it better, it could read which is much more clear. Also be consistent. In the name of the parameter is , which will be assigned to . So you have three different names for the same thing which makes it much harder to read. double precision I recommend to use instead of doubles, because of the preciscion problem, I think that could be a problem in the future. See wiki's "Floating Point" page, why I mention that. direction / position You might want to wrap direction and position into vectors. The main benefit would be, that you have a lot less parameters to pass and set, and it's usually quite clear, what a Vector is. Also not really sure if the calculation of the positions should be within the Projectile, since those are very common calculations - you might want to calculate those in a separate "MyMaths" type, or even in a Vector itself, maybe. The "maybe 3d in the future" problem should then be easier to implement (I have to admit, I suck at maths, so not quite sure if that would really help) Other 

For reference, here's the code I used to find that your program doesn't handle intervals the way I would expect. Add a break point at the commented lines and inspect your locals to see what I mean: 

The only difference between your first and the is the final line, so I moved the conditional to the end to avoid repeating the same logic. Additionally, I assume there's some way you could pad with blank spaces so that you only have to call and print once per iteration. 

Your comments are excessive. Commented out code helps no one. If you remove code and want it later, that's what version control is for. Your method is too long. You should break it into smaller pieces. Use loops instead of very similar repeated code for instance: 

I'll admit to being new to this concept, and can't think of a real-world application for this method. Regardless, here's my thoughts. Issues #1 and #2 are directly results of your use of Object.Assign which seems an acceptable limitation. Issue #3 is stating a fact of how Object prototypes are set up. The prototype of Object.prototype is by definition null, so #3 is technically a given. However, your questions make your meaning of #3 more clear. 

So, you're checking if the email attribute is not in the session, then get the cookie, and then set it to the session. Maybe wrap it in a -Method or something? Same goes for the token. And I'm pretty sure you can write one method which works for the email and for the token. This if is also confusing 

Change behaviour during runtime Decorators provide a flexible alternative to subclassing for extending functionality. 

First of all, it's very well written and I can easily understand what's going on. I also want to point out to another post which is similar to yours with a lot of good code, answers and comments: Object Oriented Design of Card Deck However ... What 'hurts' the most is the very long main method. A lot of things in the main method can be moved to separate types/methods, for instance, the loading of the Deck: Consider writing something like . It's still quite clear what you should happen, but it's written / summarized in one line. As others have mentioned, it's better to move the 'game itself' to its separate type. Why? Assume you want to provide a GUI for your game - what do you have to change? Yeah, a lot, because a lot of the code is not reusable. I think, with that in mind, you will have a total different approach of writing the game, its classes and methods and the control flows. And by how your posted code looks, and how you are already "thinking in objects", I think you can do that without me pointing out every single tiny thing I see - so I won't go into detail about what part of code you should refactor to where and why - which would really take a lot of time. Now, some smaller thingies: 

Not a full review, but: is completely unnecessary. Because Data will be null if you didn't set it within the If portion. Just add an to the previous if and have it . 

Euler2 is a confusing variable name. It has the disadvantage of resembling Hungarian notation, so those exposed to that may read it as booleanIsHigher which makes no sense. Rather than trying to find a better name, you can actually factor out the need for the variable. You get the same result from the following: 

Not if I understand what you're doing correctly. So essentially each image has itself, and then some other element that should be before it as a buddy? Assuming they are all siblings, you should utilize some of jQuery's functions that support working with siblings. Here's an example, though I'm sure it could still be better: 

Did you start out code golfing? Use variable names that mean something. The only variable you used that has any meaning to the reader is . This means that unless you remember, every time you hit a variable you have to scroll up to find out what it is. This almost looks obfuscated. (It's not, but it is painful to read.) I'm not even reviewing the logic itself. You need to use meaningful variable names or no one else will ever want to touch your code. 

Looks good, except: activateObject/passivateObject method: I don't see any usage of the running variable? Beside that, you don't need to do anything in that method anyway, that will be called, before the object will be returned, I don't think that is needed for a Cipher instance, isn't it? But why I'm actually answering: I'm fairly certain you won't gain any benefit by using a pool for Cipher instances. The management of the pool, the synchronizing, the maintaining of the code and the additional library will use way more ressources. A general rule is, "by definition": More code means less performance. Of course, that's not entirely true - what I want to say: If you want to improve performance, you have to measure, before and after your changes. And not only millis, but also cpu, memory, gc, io and so on. You have to be sure, you're changes actually did make an improvement and not the opposite. Hope that helps,... 

basemoveRate is never used again. Beside that, it should be a constant: private static final BASE_MOVE_RATE = 10.0; 

Scope your variables. Change your code to target all instead of one element with the id . Use when events are triggered to make sure you have the correct element. Remove the added elements instead of hiding them. Remember to call using the smallest possible parent container. Possibly a or ? Use short circuiting where appropriate. Use to get the appended elements parent. 

I know names aren't hugely important but my 2 cents in addition to having already written some of what @tomdemuyt said (which I editted out): 

Also your variable names could use some work. I actually don't know what is supposed to stand for here. 

Do not use multiple statements to check the same variable. Either use an block or You do not have to post all of your project, but you should at least post pieces that are whole. If we must go to a separate site to even properly review what you posted, it probably isn't going to happen. 

There's not much here to optimize mostly because there's very little here. A few things you could do: Store your selection to a variable outside both functions (bad idea if you may have multiple notificationDivs).